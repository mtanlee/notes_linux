.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Utf 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_UniChar, Tcl_UniCharCaseMatch, Tcl_UniCharNcasecmp, Tcl_UniCharToUtf, Tcl_UtfToUniChar, Tcl_UniCharToUtfDString, Tcl_UtfToUniCharDString, Tcl_UniCharLen, Tcl_UniCharNcmp, Tcl_UtfCharComplete, Tcl_NumUtfChars, Tcl_UtfFindFirst, Tcl_UtfFindLast, Tcl_UtfNext, Tcl_UtfPrev, Tcl_UniCharAtIndex, Tcl_UtfAtIndex, Tcl_UtfBackslash \- routines for manipulating UTF-8 strings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
typedef ... Tcl_UniChar;
.sp
int
\fBTcl_UniCharToUtf\fR(\fIch, buf\fR)
.sp
int
\fBTcl_UtfToUniChar\fR(\fIsrc, chPtr\fR)
.sp
char *
\fBTcl_UniCharToUtfDString\fR(\fIuniStr, uniLength, dsPtr\fR)
.sp
Tcl_UniChar *
\fBTcl_UtfToUniCharDString\fR(\fIsrc, length, dsPtr\fR)
.sp
int
\fBTcl_UniCharLen\fR(\fIuniStr\fR)
.sp
int
\fBTcl_UniCharNcmp\fR(\fIucs, uct, numChars\fR)
.sp
int
\fBTcl_UniCharNcasecmp\fR(\fIucs, uct, numChars\fR)
.sp
int
\fBTcl_UniCharCaseMatch\fR(\fIuniStr, uniPattern, nocase\fR)
.sp
int
\fBTcl_UtfNcmp\fR(\fIcs, ct, numChars\fR)
.sp
int
\fBTcl_UtfNcasecmp\fR(\fIcs, ct, numChars\fR)
.sp
int
\fBTcl_UtfCharComplete\fR(\fIsrc, length\fR)
.sp
int 
\fBTcl_NumUtfChars\fR(\fIsrc, length\fR)
.sp
const char *
\fBTcl_UtfFindFirst\fR(\fIsrc, ch\fR)
.sp
const char *
\fBTcl_UtfFindLast\fR(\fIsrc, ch\fR)
.sp
const char *
\fBTcl_UtfNext\fR(\fIsrc\fR)
.sp
const char *
\fBTcl_UtfPrev\fR(\fIsrc, start\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharAtIndex\fR(\fIsrc, index\fR)
.sp
const char *
\fBTcl_UtfAtIndex\fR(\fIsrc, index\fR)
.sp
int
\fBTcl_UtfBackslash\fR(\fIsrc, readPtr, dst\fR)
.SH ARGUMENTS
.AS "const Tcl_UniChar" *uniPattern in/out
.AP char *buf out
Buffer in which the UTF-8 representation of the Tcl_UniChar is stored.  At most
\fBTCL_UTF_MAX\fR bytes are stored in the buffer.
.AP int ch in
The Tcl_UniChar to be converted or examined.
.AP Tcl_UniChar *chPtr out
Filled with the Tcl_UniChar represented by the head of the UTF-8 string.
.AP "const char" *src in
Pointer to a UTF-8 string.
.AP "const char" *cs in
Pointer to a UTF-8 string.
.AP "const char" *ct in
Pointer to a UTF-8 string.
.AP "const Tcl_UniChar" *uniStr in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *ucs in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *uct in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *uniPattern in
A null-terminated Unicode string.
.AP int length in
The length of the UTF-8 string in bytes (not UTF-8 characters).  If
negative, all bytes up to the first null byte are used.
.AP int uniLength in
The length of the Unicode string in characters.  Must be greater than or
equal to 0.
.AP "Tcl_DString" *dsPtr in/out
A pointer to a previously initialized \fBTcl_DString\fR.
.AP "unsigned long" numChars in
The number of characters to compare.
.AP "const char" *start in
Pointer to the beginning of a UTF-8 string.
.AP int index in
The index of a character (not byte) in the UTF-8 string.
.AP int *readPtr out
If non-NULL, filled with the number of bytes in the backslash sequence, 
including the backslash character.
.AP char *dst out
Buffer in which the bytes represented by the backslash sequence are stored.
At most \fBTCL_UTF_MAX\fR bytes are stored in the buffer.
.AP int nocase in
Specifies whether the match should be done case-sensitive (0) or
case-insensitive (1).
.BE

.SH DESCRIPTION
.PP
These routines convert between UTF-8 strings and Tcl_UniChars.  A
Tcl_UniChar is a Unicode character represented as an unsigned, fixed-size
quantity.  A UTF-8 character is a Unicode character represented as
a varying-length sequence of up to \fBTCL_UTF_MAX\fR bytes.  A multibyte UTF-8
sequence consists of a lead byte followed by some number of trail bytes.
.PP
\fBTCL_UTF_MAX\fR is the maximum number of bytes that it takes to
represent one Unicode character in the UTF-8 representation.
.PP
\fBTcl_UniCharToUtf\fR stores the Tcl_UniChar \fIch\fR as a UTF-8 string
in starting at \fIbuf\fR.  The return value is the number of bytes stored
in \fIbuf\fR.
.PP
\fBTcl_UtfToUniChar\fR reads one UTF-8 character starting at \fIsrc\fR
and stores it as a Tcl_UniChar in \fI*chPtr\fR.  The return value is the
number of bytes read from \fIsrc\fR.  The caller must ensure that the
source buffer is long enough such that this routine does not run off the
end and dereference non-existent or random memory; if the source buffer
is known to be null-terminated, this will not happen.  If the input is
not in proper UTF-8 format, \fBTcl_UtfToUniChar\fR will store the first
byte of \fIsrc\fR in \fI*chPtr\fR as a Tcl_UniChar between 0x0000 and
0x00ff and return 1.  
.PP
\fBTcl_UniCharToUtfDString\fR converts the given Unicode string
to UTF-8, storing the result in a previously initialized \fBTcl_DString\fR.
You must specify \fIuniLength\fR, the length of the given Unicode string.
The return value is a pointer to the UTF-8 representation of the
Unicode string.  Storage for the return value is appended to the
end of the \fBTcl_DString\fR.
.PP
\fBTcl_UtfToUniCharDString\fR converts the given UTF-8 string to Unicode,
storing the result in the previously initialized \fBTcl_DString\fR.
In the argument \fIlength\fR, you may either specify the length of
the given UTF-8 string in bytes or
.QW \-1 ,
in which case \fBTcl_UtfToUniCharDString\fR uses \fBstrlen\fR to
calculate the length.  The return value is a pointer to the Unicode
representation of the UTF-8 string.  Storage for the return value
is appended to the end of the \fBTcl_DString\fR.  The Unicode string
is terminated with a Unicode null character.
.PP
\fBTcl_UniCharLen\fR corresponds to \fBstrlen\fR for Unicode
characters.  It accepts a null-terminated Unicode string and returns
the number of Unicode characters (not bytes) in that string.
.PP
\fBTcl_UniCharNcmp\fR and \fBTcl_UniCharNcasecmp\fR correspond to
\fBstrncmp\fR and \fBstrncasecmp\fR, respectively, for Unicode characters.
They accept two null-terminated Unicode strings and the number of characters
to compare.  Both strings are assumed to be at least \fInumChars\fR characters
long. \fBTcl_UniCharNcmp\fR  compares the two strings character-by-character
according to the Unicode character ordering.  It returns an integer greater
than, equal to, or less than 0 if the first string is greater than, equal
to, or less than the second string respectively.  \fBTcl_UniCharNcasecmp\fR
is the Unicode case insensitive version.
.PP
\fBTcl_UniCharCaseMatch\fR is the Unicode equivalent to
\fBTcl_StringCaseMatch\fR.  It accepts a null-terminated Unicode string,
a Unicode pattern, and a boolean value specifying whether the match should
be case sensitive and returns whether the string matches the pattern.
.PP
\fBTcl_UtfNcmp\fR corresponds to \fBstrncmp\fR for UTF-8 strings. It
accepts two null-terminated UTF-8 strings and the number of characters
to compare.  (Both strings are assumed to be at least \fInumChars\fR
characters long.)  \fBTcl_UtfNcmp\fR compares the two strings
character-by-character according to the Unicode character ordering.
It returns an integer greater than, equal to, or less than 0 if the
first string is greater than, equal to, or less than the second string
respectively.
.PP
\fBTcl_UtfNcasecmp\fR corresponds to \fBstrncasecmp\fR for UTF-8
strings.  It is similar to \fBTcl_UtfNcmp\fR except comparisons ignore
differences in case when comparing upper, lower or title case
characters.
.PP
\fBTcl_UtfCharComplete\fR returns 1 if the source UTF-8 string \fIsrc\fR
of \fIlength\fR bytes is long enough to be decoded by
\fBTcl_UtfToUniChar\fR, or 0 otherwise.  This function does not guarantee
that the UTF-8 string is properly formed.  This routine is used by
procedures that are operating on a byte at a time and need to know if a
full Tcl_UniChar has been seen.
.PP
\fBTcl_NumUtfChars\fR corresponds to \fBstrlen\fR for UTF-8 strings.  It
returns the number of Tcl_UniChars that are represented by the UTF-8 string
\fIsrc\fR.  The length of the source string is \fIlength\fR bytes.  If the
length is negative, all bytes up to the first null byte are used.
.PP
\fBTcl_UtfFindFirst\fR corresponds to \fBstrchr\fR for UTF-8 strings.  It
returns a pointer to the first occurrence of the Tcl_UniChar \fIch\fR
in the null-terminated UTF-8 string \fIsrc\fR.  The null terminator is
considered part of the UTF-8 string.  
.PP
\fBTcl_UtfFindLast\fR corresponds to \fBstrrchr\fR for UTF-8 strings.  It
returns a pointer to the last occurrence of the Tcl_UniChar \fIch\fR
in the null-terminated UTF-8 string \fIsrc\fR.  The null terminator is
considered part of the UTF-8 string.  
.PP
Given \fIsrc\fR, a pointer to some location in a UTF-8 string,
\fBTcl_UtfNext\fR returns a pointer to the next UTF-8 character in the
string.  The caller must not ask for the next character after the last
character in the string if the string is not terminated by a null
character.
.PP
Given \fIsrc\fR, a pointer to some location in a UTF-8 string (or to a
null byte immediately following such a string), \fBTcl_UtfPrev\fR
returns a pointer to the closest preceding byte that starts a UTF-8
character.
This function will not back up to a position before \fIstart\fR,
the start of the UTF-8 string.  If \fIsrc\fR was already at \fIstart\fR, the
return value will be \fIstart\fR.
.PP
\fBTcl_UniCharAtIndex\fR corresponds to a C string array dereference or the
Pascal Ord() function.  It returns the Tcl_UniChar represented at the
specified character (not byte) \fIindex\fR in the UTF-8 string
\fIsrc\fR.  The source string must contain at least \fIindex\fR
characters.  Behavior is undefined if a negative \fIindex\fR is given.
.PP
\fBTcl_UtfAtIndex\fR returns a pointer to the specified character (not
byte) \fIindex\fR in the UTF-8 string \fIsrc\fR.  The source string must
contain at least \fIindex\fR characters.  This is equivalent to calling 
\fBTcl_UtfNext\fR \fIindex\fR times.  If a negative \fIindex\fR is given,
the return pointer points to the first character in the source string.
.PP
\fBTcl_UtfBackslash\fR is a utility procedure used by several of the Tcl
commands.  It parses a backslash sequence and stores the properly formed
UTF-8 character represented by the backslash sequence in the output
buffer \fIdst\fR.  At most \fBTCL_UTF_MAX\fR bytes are stored in the buffer.
\fBTcl_UtfBackslash\fR modifies \fI*readPtr\fR to contain the number
of bytes in the backslash sequence, including the backslash character.
The return value is the number of bytes stored in the output buffer.
.PP
See the \fBTcl\fR manual entry for information on the valid backslash
sequences.  All of the sequences described in the Tcl manual entry are
supported by \fBTcl_UtfBackslash\fR.

.SH KEYWORDS
utf, unicode, backslash
                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToExternal.3tcl                       0100644 0001750 0001750 00000102744 12566232332 025021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997-1998 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Encoding.3,v 1.29 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_GetEncoding 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_GetEncoding, Tcl_FreeEncoding, Tcl_GetEncodingFromObj, Tcl_ExternalToUtfDString, Tcl_ExternalToUtf, Tcl_UtfToExternalDString, Tcl_UtfToExternal, Tcl_WinTCharToUtf, Tcl_WinUtfToTChar, Tcl_GetEncodingName, Tcl_SetSystemEncoding, Tcl_GetEncodingNameFromEnvironment, Tcl_GetEncodingNames, Tcl_CreateEncoding, Tcl_GetEncodingSearchPath, Tcl_SetEncodingSearchPath, Tcl_GetDefaultEncodingDir, Tcl_SetDefaultEncodingDir \- procedures for creating and using encodings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Encoding
\fBTcl_GetEncoding\fR(\fIinterp, name\fR)
.sp
void
\fBTcl_FreeEncoding\fR(\fIencoding\fR)
.sp
.VS 8.5
int
\fBTcl_GetEncodingFromObj\fR(\fIinterp, objPtr, encodingPtr\fR)
.VE 8.5
.sp
char *
\fBTcl_ExternalToUtfDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
char *
\fBTcl_UtfToExternalDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
int
\fBTcl_ExternalToUtf\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
int
\fBTcl_UtfToExternal\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
char *
\fBTcl_WinTCharToUtf\fR(\fItsrc, srcLen, dstPtr\fR)
.sp
TCHAR *
\fBTcl_WinUtfToTChar\fR(\fIsrc, srcLen, dstPtr\fR)
.sp
const char *
\fBTcl_GetEncodingName\fR(\fIencoding\fR)
.sp
int
\fBTcl_SetSystemEncoding\fR(\fIinterp, name\fR)
.sp
.VS 8.5
const char *
\fBTcl_GetEncodingNameFromEnvironment\fR(\fIbufPtr\fR)
.VE 8.5
.sp
void
\fBTcl_GetEncodingNames\fR(\fIinterp\fR)
.sp
Tcl_Encoding
\fBTcl_CreateEncoding\fR(\fItypePtr\fR)
.sp
.VS 8.5
Tcl_Obj *
\fBTcl_GetEncodingSearchPath\fR()
.sp
int
\fBTcl_SetEncodingSearchPath\fR(\fIsearchPath\fR)
.VE 8.5
.sp
const char *
\fBTcl_GetDefaultEncodingDir\fR(\fIvoid\fR)
.sp
void
\fBTcl_SetDefaultEncodingDir\fR(\fIpath\fR)
.SH ARGUMENTS
.AS "const Tcl_EncodingType" *dstWrotePtr in/out
.AP Tcl_Interp *interp in
Interpreter to use for error reporting, or NULL if no error reporting is
desired.
.AP "const char" *name in
Name of encoding to load.
.AP Tcl_Encoding encoding in
The encoding to query, free, or use for converting text.  If \fIencoding\fR is 
NULL, the current system encoding is used.
.AP Tcl_Obj *objPtr in
.VS 8.5
Name of encoding to get token for.
.VE 8.5
.AP Tcl_Encoding *encodingPtr out
.VS 8.5
Points to storage where encoding token is to be written.
.VE 8.5
.AP "const char" *src in
For the \fBTcl_ExternalToUtf\fR functions, an array of bytes in the
specified encoding that are to be converted to UTF-8.  For the
\fBTcl_UtfToExternal\fR and \fBTcl_WinUtfToTChar\fR functions, an array of
UTF-8 characters to be converted to the specified encoding.  
.AP "const TCHAR" *tsrc in
An array of Windows TCHAR characters to convert to UTF-8.
.AP int srcLen in 
Length of \fIsrc\fR or \fItsrc\fR in bytes.  If the length is negative, the 
encoding-specific length of the string is used.
.AP Tcl_DString *dstPtr out
Pointer to an uninitialized or free \fBTcl_DString\fR in which the converted
result will be stored.
.AP int flags in
Various flag bits OR-ed together.  
\fBTCL_ENCODING_START\fR signifies that the
source buffer is the first block in a (potentially multi-block) input
stream, telling the conversion routine to reset to an initial state and
perform any initialization that needs to occur before the first byte is
converted. \fBTCL_ENCODING_END\fR signifies that the source buffer is the last
block in a (potentially multi-block) input stream, telling the conversion
routine to perform any finalization that needs to occur after the last
byte is converted and then to reset to an initial state.
\fBTCL_ENCODING_STOPONERROR\fR signifies that the conversion routine should
return immediately upon reading a source character that does not exist in
the target encoding; otherwise a default fallback character will
automatically be substituted.  
.AP Tcl_EncodingState *statePtr in/out
Used when converting a (generally long or indefinite length) byte stream
in a piece-by-piece fashion.  The conversion routine stores its current
state in \fI*statePtr\fR after \fIsrc\fR (the buffer containing the
current piece) has been converted; that state information must be passed
back when converting the next piece of the stream so the conversion
routine knows what state it was in when it left off at the end of the
last piece.  May be NULL, in which case the value specified for \fIflags\fR 
is ignored and the source buffer is assumed to contain the complete string to
convert.
.AP char *dst out
Buffer in which the converted result will be stored.  No more than
\fIdstLen\fR bytes will be stored in \fIdst\fR.
.AP int dstLen in
The maximum length of the output buffer \fIdst\fR in bytes.
.AP int *srcReadPtr out
Filled with the number of bytes from \fIsrc\fR that were actually
converted.  This may be less than the original source length if there was
a problem converting some source characters.  May be NULL.
.AP int *dstWrotePtr out
Filled with the number of bytes that were actually stored in the output
buffer as a result of the conversion.  May be NULL.
.AP int *dstCharsPtr out
Filled with the number of characters that correspond to the number of bytes
stored in the output buffer.  May be NULL.
.AP Tcl_DString *bufPtr out
.VS 8.5
Storage for the prescribed system encoding name.
.VE 8.5
.AP "const Tcl_EncodingType" *typePtr in
Structure that defines a new type of encoding.  
.AP Tcl_Obj *searchPath in
.VS 8.5
List of filesystem directories in which to search for encoding data files.
.VE 8.5
.AP "const char" *path in
A path to the location of the encoding file.  
.BE
.SH INTRODUCTION
.PP
These routines convert between Tcl's internal character representation,
UTF-8, and character representations used by various operating systems or
file systems, such as Unicode, ASCII, or Shift-JIS.  When operating on
strings, such as such as obtaining the names of files or displaying
characters using international fonts, the strings must be translated into
one or possibly multiple formats that the various system calls can use.  For
instance, on a Japanese Unix workstation, a user might obtain a filename
represented in the EUC-JP file encoding and then translate the characters to
the jisx0208 font encoding in order to display the filename in a Tk widget.
The purpose of the encoding package is to help bridge the translation gap.
UTF-8 provides an intermediate staging ground for all the various
encodings.  In the example above, text would be translated into UTF-8 from
whatever file encoding the operating system is using.  Then it would be
translated from UTF-8 into whatever font encoding the display routines
require.
.PP
Some basic encodings are compiled into Tcl.  Others can be defined by the
user or dynamically loaded from encoding files in a
platform-independent manner.
.SH DESCRIPTION
.PP
\fBTcl_GetEncoding\fR finds an encoding given its \fIname\fR.  The name may
refer to a built-in Tcl encoding, a user-defined encoding registered by
calling \fBTcl_CreateEncoding\fR, or a dynamically-loadable encoding
file.  The return value is a token that represents the encoding and can be
used in subsequent calls to procedures such as \fBTcl_GetEncodingName\fR,
\fBTcl_FreeEncoding\fR, and \fBTcl_UtfToExternal\fR.  If the name did not
refer to any known or loadable encoding, NULL is returned and an error
message is returned in \fIinterp\fR.
.PP
The encoding package maintains a database of all encodings currently in use.
The first time \fIname\fR is seen, \fBTcl_GetEncoding\fR returns an
encoding with a reference count of 1.  If the same \fIname\fR is requested
further times, then the reference count for that encoding is incremented
without the overhead of allocating a new encoding and all its associated
data structures.  
.PP
When an \fIencoding\fR is no longer needed, \fBTcl_FreeEncoding\fR
should be called to release it.  When an \fIencoding\fR is no longer in use
anywhere (i.e., it has been freed as many times as it has been gotten)
\fBTcl_FreeEncoding\fR will release all storage the encoding was using
and delete it from the database. 
.PP
.VS 8.5
\fBTcl_GetEncodingFromObj\fR treats the string representation of
\fIobjPtr\fR as an encoding name, and finds an encoding with that
name, just as \fBTcl_GetEncoding\fR does. When an encoding is found,
it is cached within the \fBobjPtr\fR value for future reference, the
\fBTcl_Encoding\fR token is written to the storage pointed to by
\fIencodingPtr\fR, and the value \fBTCL_OK\fR is returned. If no such
encoding is found, the value \fBTCL_ERROR\fR is returned, and no
writing to \fB*\fR\fIencodingPtr\fR takes place. Just as with
\fBTcl_GetEncoding\fR, the caller should call \fBTcl_FreeEncoding\fR
on the resulting encoding token when that token will no longer be
used.
.VE 8.5
.PP
\fBTcl_ExternalToUtfDString\fR converts a source buffer \fIsrc\fR from the
specified \fIencoding\fR into UTF-8.  The converted bytes are stored in 
\fIdstPtr\fR, which is then null-terminated.  The caller should eventually
call \fBTcl_DStringFree\fR to free any information stored in \fIdstPtr\fR.
When converting, if any of the characters in the source buffer cannot be
represented in the target encoding, a default fallback character will be
used.  The return value is a pointer to the value stored in the DString.
.PP
\fBTcl_ExternalToUtf\fR converts a source buffer \fIsrc\fR from the specified
\fIencoding\fR into UTF-8.  Up to \fIsrcLen\fR bytes are converted from the
source buffer and up to \fIdstLen\fR converted bytes are stored in \fIdst\fR.
In all cases, \fI*srcReadPtr\fR is filled with the number of bytes that were
successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR is filled with
the corresponding number of bytes that were stored in \fIdst\fR.  The return
value is one of the following:
.RS
.IP \fBTCL_OK\fR 29
All bytes of \fIsrc\fR were converted.
.IP \fBTCL_CONVERT_NOSPACE\fR 29
The destination buffer was not large enough for all of the converted data; as
many characters as could fit were converted though.
.IP \fBTCL_CONVERT_MULTIBYTE\fR 29
The last few bytes in the source buffer were the beginning of a multibyte
sequence, but more bytes were needed to complete this sequence.  A
subsequent call to the conversion routine should pass a buffer containing
the unconverted bytes that remained in \fIsrc\fR plus some further bytes
from the source stream to properly convert the formerly split-up multibyte
sequence.  
.IP \fBTCL_CONVERT_SYNTAX\fR 29
The source buffer contained an invalid character sequence.  This may occur
if the input stream has been damaged or if the input encoding method was
misidentified.
.IP \fBTCL_CONVERT_UNKNOWN\fR 29
The source buffer contained a character that could not be represented in
the target encoding and \fBTCL_ENCODING_STOPONERROR\fR was specified.  
.RE
.LP
\fBTcl_UtfToExternalDString\fR converts a source buffer \fIsrc\fR from UTF-8 
into the specified \fIencoding\fR.  The converted bytes are stored in
\fIdstPtr\fR, which is then terminated with the appropriate encoding-specific
null.  The caller should eventually call \fBTcl_DStringFree\fR to free any
information stored in \fIdstPtr\fR.  When converting, if any of the
characters in the source buffer cannot be represented in the target
encoding, a default fallback character will be used.  The return value is
a pointer to the value stored in the DString.
.PP
\fBTcl_UtfToExternal\fR converts a source buffer \fIsrc\fR from UTF-8 into
the specified \fIencoding\fR.  Up to \fIsrcLen\fR bytes are converted from
the source buffer and up to \fIdstLen\fR converted bytes are stored in
\fIdst\fR.  In all cases, \fI*srcReadPtr\fR is filled with the number of
bytes that were successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR
is filled with the corresponding number of bytes that were stored in
\fIdst\fR.  The return values are the same as the return values for
\fBTcl_ExternalToUtf\fR.
.PP
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR are
Windows-only convenience
functions for converting between UTF-8 and Windows strings.  On Windows 95
(as with the Unix operating system),
all strings exchanged between Tcl and the operating system are
.QW "char"
based.  On Windows NT, some strings exchanged between Tcl and the
operating system are
.QW "char"
oriented while others are in Unicode.  By
convention, in Windows a TCHAR is a character in the ANSI code page
on Windows 95 and a Unicode character on Windows NT.
.PP
If you planned to use the same
.QW "char"
based interfaces on both Windows
95 and Windows NT, you could use \fBTcl_UtfToExternal\fR and
\fBTcl_ExternalToUtf\fR (or their \fBTcl_DString\fR equivalents) with an
encoding of NULL (the current system encoding).  On the other hand,
if you planned to use the Unicode interface when running on Windows NT
and the
.QW "char"
interfaces when running on Windows 95, you would have
to perform the following type of test over and over in your program
(as represented in pseudo-code):
.CS
if (running NT) {
    encoding <- Tcl_GetEncoding("unicode");
    nativeBuffer <- Tcl_UtfToExternal(encoding, utfBuffer);
    Tcl_FreeEncoding(encoding);
} else {
    nativeBuffer <- Tcl_UtfToExternal(NULL, utfBuffer);
}
.CE
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR automatically
handle this test and use the proper encoding based on the current
operating system.  \fBTcl_WinUtfToTChar\fR returns a pointer to
a TCHAR string, and \fBTcl_WinTCharToUtf\fR expects a TCHAR string
pointer as the \fIsrc\fR string.  Otherwise, these functions
behave identically to \fBTcl_UtfToExternalDString\fR and
\fBTcl_ExternalToUtfDString\fR.
.PP
\fBTcl_GetEncodingName\fR is roughly the inverse of \fBTcl_GetEncoding\fR.
Given an \fIencoding\fR, the return value is the \fIname\fR argument that
was used to create the encoding.  The string returned by 
\fBTcl_GetEncodingName\fR is only guaranteed to persist until the
\fIencoding\fR is deleted.  The caller must not modify this string.
.PP
\fBTcl_SetSystemEncoding\fR sets the default encoding that should be used
whenever the user passes a NULL value for the \fIencoding\fR argument to
any of the other encoding functions.  If \fIname\fR is NULL, the system
encoding is reset to the default system encoding, \fBbinary\fR.  If the
name did not refer to any known or loadable encoding, \fBTCL_ERROR\fR is
returned and an error message is left in \fIinterp\fR.  Otherwise, this
procedure increments the reference count of the new system encoding,
decrements the reference count of the old system encoding, and returns
\fBTCL_OK\fR.
.PP
.VS 8.5
\fBTcl_GetEncodingNameFromEnvironment\fR provides a means for the Tcl
library to report the encoding name it believes to be the correct one
to use as the system encoding, based on system calls and examination of
the environment suitable for the platform.  It accepts \fIbufPtr\fR,
a pointer to an uninitialized or freed \fBTcl_DString\fR and writes
the encoding name to it.  The \fBTcl_DStringValue\fR is returned.
.VE 8.5
.PP
\fBTcl_GetEncodingNames\fR sets the \fIinterp\fR result to a list
consisting of the names of all the encodings that are currently defined
or can be dynamically loaded, searching the encoding path specified by
\fBTcl_SetDefaultEncodingDir\fR.  This procedure does not ensure that the
dynamically-loadable encoding files contain valid data, but merely that they
exist.
.PP
\fBTcl_CreateEncoding\fR defines a new encoding and registers the C
procedures that are called back to convert between the encoding and
UTF-8.  Encodings created by \fBTcl_CreateEncoding\fR are thereafter
visible in the database used by \fBTcl_GetEncoding\fR.  Just as with the
\fBTcl_GetEncoding\fR procedure, the return value is a token that
represents the encoding and can be used in subsequent calls to other
encoding functions.  \fBTcl_CreateEncoding\fR returns an encoding with a
reference count of 1. If an encoding with the specified \fIname\fR
already exists, then its entry in the database is replaced with the new
encoding; the token for the old encoding will remain valid and continue
to behave as before, but users of the new token will now call the new
encoding procedures.  
.PP
The \fItypePtr\fR argument to \fBTcl_CreateEncoding\fR contains information 
about the name of the encoding and the procedures that will be called to
convert between this encoding and UTF-8.  It is defined as follows:
.PP
.CS
typedef struct Tcl_EncodingType {
        const char *\fIencodingName\fR;
        Tcl_EncodingConvertProc *\fItoUtfProc\fR;
        Tcl_EncodingConvertProc *\fIfromUtfProc\fR;
        Tcl_EncodingFreeProc *\fIfreeProc\fR;
        ClientData \fIclientData\fR;
        int \fInullSize\fR;
} Tcl_EncodingType;  
.CE
.PP
The \fIencodingName\fR provides a string name for the encoding, by
which it can be referred in other procedures such as
\fBTcl_GetEncoding\fR.  The \fItoUtfProc\fR refers to a callback
procedure to invoke to convert text from this encoding into UTF-8.
The \fIfromUtfProc\fR refers to a callback procedure to invoke to
convert text from UTF-8 into this encoding.  The \fIfreeProc\fR refers
to a callback procedure to invoke when this encoding is deleted.  The
\fIfreeProc\fR field may be NULL.  The \fIclientData\fR contains an
arbitrary one-word value passed to \fItoUtfProc\fR, \fIfromUtfProc\fR,
and \fIfreeProc\fR whenever they are called.  Typically, this is a
pointer to a data structure containing encoding-specific information
that can be used by the callback procedures.  For instance, two very
similar encodings such as \fBascii\fR and \fBmacRoman\fR may use the
same callback procedure, but use different values of \fIclientData\fR
to control its behavior.  The \fInullSize\fR specifies the number of
zero bytes that signify end-of-string in this encoding.  It must be
\fB1\fR (for single-byte or multi-byte encodings like ASCII or
Shift-JIS) or \fB2\fR (for double-byte encodings like Unicode).
Constant-sized encodings with 3 or more bytes per character (such as
CNS11643) are not accepted.
.PP
The callback procedures \fItoUtfProc\fR and \fIfromUtfProc\fR should match the
type \fBTcl_EncodingConvertProc\fR:
.PP
.CS
typedef int Tcl_EncodingConvertProc(
        ClientData \fIclientData\fR,
        const char *\fIsrc\fR, 
        int \fIsrcLen\fR, 
        int \fIflags\fR, 
        Tcl_EncodingState *\fIstatePtr\fR,
        char *\fIdst\fR, 
        int \fIdstLen\fR, 
        int *\fIsrcReadPtr\fR,
        int *\fIdstWrotePtr\fR,
        int *\fIdstCharsPtr\fR);
.CE
.PP
The \fItoUtfProc\fR and \fIfromUtfProc\fR procedures are called by the
\fBTcl_ExternalToUtf\fR or \fBTcl_UtfToExternal\fR family of functions to
perform the actual conversion.  The \fIclientData\fR parameter to these
procedures is the same as the \fIclientData\fR field specified to
\fBTcl_CreateEncoding\fR when the encoding was created.  The remaining
arguments to the callback procedures are the same as the arguments,
documented at the top, to \fBTcl_ExternalToUtf\fR or
\fBTcl_UtfToExternal\fR, with the following exceptions.  If the
\fIsrcLen\fR argument to one of those high-level functions is negative,
the value passed to the callback procedure will be the appropriate
encoding-specific string length of \fIsrc\fR.  If any of the \fIsrcReadPtr\fR, 
\fIdstWrotePtr\fR, or \fIdstCharsPtr\fR arguments to one of the high-level
functions is NULL, the corresponding value passed to the callback
procedure will be a non-NULL location.
.PP
The callback procedure \fIfreeProc\fR, if non-NULL, should match the type 
\fBTcl_EncodingFreeProc\fR:
.CS
typedef void Tcl_EncodingFreeProc(
        ClientData \fIclientData\fR);
.CE
.PP
This \fIfreeProc\fR function is called when the encoding is deleted.  The
\fIclientData\fR parameter is the same as the \fIclientData\fR field
specified to \fBTcl_CreateEncoding\fR when the encoding was created.  
.PP
.VS 8.5
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR
are called to access and set the list of filesystem directories searched
for encoding data files.  
.PP
The value returned by \fBTcl_GetEncodingSearchPath\fR
is the value stored by the last successful call to
\fBTcl_SetEncodingSearchPath\fR.  If no calls to
\fBTcl_SetEncodingSearchPath\fR have occurred, Tcl will compute an initial
value based on the environment.  There is one encoding search path for the
entire process, shared by all threads in the process.
.PP
\fBTcl_SetEncodingSearchPath\fR stores \fIsearchPath\fR and returns
\fBTCL_OK\fR, unless \fIsearchPath\fR is not a valid Tcl list, which
causes \fBTCL_ERROR\fR to be returned.  The elements of \fIsearchPath\fR
are not verified as existing readable filesystem directories.  When
searching for encoding data files takes place, and non-existent or
non-readable filesystem directories on the \fIsearchPath\fR are silently
ignored.
.PP
\fBTcl_GetDefaultEncodingDir\fR and \fBTcl_SetDefaultEncodingDir\fR
are obsolete interfaces best replaced with calls to
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR.
They are called to access and set the first element of the \fIsearchPath\fR
list.  Since Tcl searches \fIsearchPath\fR for encoding data files in
list order, these routines establish the
.QW default
directory in which to find encoding data files.
.VE 8.5
.SH "ENCODING FILES"
Space would prohibit precompiling into Tcl every possible encoding
algorithm, so many encodings are stored on disk as dynamically-loadable
encoding files.  This behavior also allows the user to create additional
encoding files that can be loaded using the same mechanism.  These
encoding files contain information about the tables and/or escape
sequences used to map between an external encoding and Unicode.  The
external encoding may consist of single-byte, multi-byte, or double-byte
characters.  
.PP
Each dynamically-loadable encoding is represented as a text file.  The
initial line of the file, beginning with a
.QW #
symbol, is a comment
that provides a human-readable description of the file.  The next line
identifies the type of encoding file.  It can be one of the following
letters:
.IP "[1] \fBS\fR"
A single-byte encoding, where one character is always one byte long in the
encoding.  An example is \fBiso8859-1\fR, used by many European languages.
.IP "[2] \fBD\fR"
A double-byte encoding, where one character is always two bytes long in the
encoding.  An example is \fBbig5\fR, used for Chinese text.
.IP "[3] \fBM\fR"
A multi-byte encoding, where one character may be either one or two bytes long.
Certain bytes are lead bytes, indicating that another byte must follow
and that together the two bytes represent one character.  Other bytes are not
lead bytes and represent themselves.  An example is \fBshiftjis\fR, used by
many Japanese computers.
.IP "[4] \fBE\fR"
An escape-sequence encoding, specifying that certain sequences of bytes
do not represent characters, but commands that describe how following bytes
should be interpreted.  
.PP
The rest of the lines in the file depend on the type.  
.PP
Cases [1], [2], and [3] are collectively referred to as table-based encoding
files.  The lines in a table-based encoding file are in the same
format as this example taken from the \fBshiftjis\fR encoding (this is not
the complete file):
.CS
# Encoding file: shiftjis, multi-byte
M
003F 0 40
00
0000000100020003000400050006000700080009000A000B000C000D000E000F
0010001100120013001400150016001700180019001A001B001C001D001E001F
0020002100220023002400250026002700280029002A002B002C002D002E002F
0030003100320033003400350036003700380039003A003B003C003D003E003F
0040004100420043004400450046004700480049004A004B004C004D004E004F
0050005100520053005400550056005700580059005A005B005C005D005E005F
0060006100620063006400650066006700680069006A006B006C006D006E006F
0070007100720073007400750076007700780079007A007B007C007D203E007F
0080000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000FF61FF62FF63FF64FF65FF66FF67FF68FF69FF6AFF6BFF6CFF6DFF6EFF6F
FF70FF71FF72FF73FF74FF75FF76FF77FF78FF79FF7AFF7BFF7CFF7DFF7EFF7F
FF80FF81FF82FF83FF84FF85FF86FF87FF88FF89FF8AFF8BFF8CFF8DFF8EFF8F
FF90FF91FF92FF93FF94FF95FF96FF97FF98FF99FF9AFF9BFF9CFF9DFF9EFF9F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
81
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
300030013002FF0CFF0E30FBFF1AFF1BFF1FFF01309B309C00B4FF4000A8FF3E
FFE3FF3F30FD30FE309D309E30034EDD30053006300730FC20152010FF0F005C
301C2016FF5C2026202520182019201C201DFF08FF0930143015FF3BFF3DFF5B
FF5D30083009300A300B300C300D300E300F30103011FF0B221200B100D70000
00F7FF1D2260FF1CFF1E22662267221E22342642264000B0203220332103FFE5
FF0400A200A3FF05FF03FF06FF0AFF2000A72606260525CB25CF25CE25C725C6
25A125A025B325B225BD25BC203B301221922190219121933013000000000000
000000000000000000000000000000002208220B2286228722822283222A2229
000000000000000000000000000000002227222800AC21D221D4220022030000
0000000000000000000000000000000000000000222022A52312220222072261
2252226A226B221A223D221D2235222B222C0000000000000000000000000000
212B2030266F266D266A2020202100B6000000000000000025EF000000000000
.CE
.PP
The third line of the file is three numbers.  The first number is the
fallback character (in base 16) to use when converting from UTF-8 to this
encoding.  The second number is a \fB1\fR if this file represents the
encoding for a symbol font, or \fB0\fR otherwise.  The last number (in base
10) is how many pages of data follow.  
.PP
Subsequent lines in the example above are pages that describe how to map
from the encoding into 2-byte Unicode.  The first line in a page identifies
the page number.  Following it are 256 double-byte numbers, arranged as 16
rows of 16 numbers.  Given a character in the encoding, the high byte of
that character is used to select which page, and the low byte of that
character is used as an index to select one of the double-byte numbers in
that page \- the value obtained being the corresponding Unicode character.
By examination of the example above, one can see that the characters 0x7E
and 0x8163 in \fBshiftjis\fR map to 203E and 2026 in Unicode, respectively.
.PP
Following the first page will be all the other pages, each in the same
format as the first: one number identifying the page followed by 256
double-byte Unicode characters.  If a character in the encoding maps to the
Unicode character 0000, it means that the character does not actually exist.
If all characters on a page would map to 0000, that page can be omitted.
.PP
Case [4] is the escape-sequence encoding file.  The lines in an this type of
file are in the same format as this example taken from the \fBiso2022-jp\fR
encoding:
.CS
.ta 1.5i
# Encoding file: iso2022-jp, escape-driven
E
init		{}
final		{}
iso8859-1	\ex1b(B
jis0201		\ex1b(J
jis0208		\ex1b$@
jis0208		\ex1b$B
jis0212		\ex1b$(D
gb2312		\ex1b$A
ksc5601		\ex1b$(C
.CE
.PP
In the file, the first column represents an option and the second column
is the associated value.  \fBinit\fR is a string to emit or expect before
the first character is converted, while \fBfinal\fR is a string to emit
or expect after the last character.  All other options are names of
table-based encodings; the associated value is the escape-sequence that
marks that encoding.  Tcl syntax is used for the values; in the above
example, for instance,
.QW \fB{}\fR
represents the empty string and
.QW \fB\ex1b\fR
represents character 27.
.PP
When \fBTcl_GetEncoding\fR encounters an encoding \fIname\fR that has not
been loaded, it attempts to load an encoding file called \fIname\fB.enc\fR
from the \fBencoding\fR subdirectory of each directory that Tcl searches
for its script library.  If the encoding file exists, but is
malformed, an error message will be left in \fIinterp\fR.
.SH KEYWORDS
utf, encoding, convert
                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToExternalDString.3tcl                0100644 0001750 0001750 00000102744 12566232332 026314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997-1998 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Encoding.3,v 1.29 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_GetEncoding 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_GetEncoding, Tcl_FreeEncoding, Tcl_GetEncodingFromObj, Tcl_ExternalToUtfDString, Tcl_ExternalToUtf, Tcl_UtfToExternalDString, Tcl_UtfToExternal, Tcl_WinTCharToUtf, Tcl_WinUtfToTChar, Tcl_GetEncodingName, Tcl_SetSystemEncoding, Tcl_GetEncodingNameFromEnvironment, Tcl_GetEncodingNames, Tcl_CreateEncoding, Tcl_GetEncodingSearchPath, Tcl_SetEncodingSearchPath, Tcl_GetDefaultEncodingDir, Tcl_SetDefaultEncodingDir \- procedures for creating and using encodings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Encoding
\fBTcl_GetEncoding\fR(\fIinterp, name\fR)
.sp
void
\fBTcl_FreeEncoding\fR(\fIencoding\fR)
.sp
.VS 8.5
int
\fBTcl_GetEncodingFromObj\fR(\fIinterp, objPtr, encodingPtr\fR)
.VE 8.5
.sp
char *
\fBTcl_ExternalToUtfDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
char *
\fBTcl_UtfToExternalDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
int
\fBTcl_ExternalToUtf\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
int
\fBTcl_UtfToExternal\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
char *
\fBTcl_WinTCharToUtf\fR(\fItsrc, srcLen, dstPtr\fR)
.sp
TCHAR *
\fBTcl_WinUtfToTChar\fR(\fIsrc, srcLen, dstPtr\fR)
.sp
const char *
\fBTcl_GetEncodingName\fR(\fIencoding\fR)
.sp
int
\fBTcl_SetSystemEncoding\fR(\fIinterp, name\fR)
.sp
.VS 8.5
const char *
\fBTcl_GetEncodingNameFromEnvironment\fR(\fIbufPtr\fR)
.VE 8.5
.sp
void
\fBTcl_GetEncodingNames\fR(\fIinterp\fR)
.sp
Tcl_Encoding
\fBTcl_CreateEncoding\fR(\fItypePtr\fR)
.sp
.VS 8.5
Tcl_Obj *
\fBTcl_GetEncodingSearchPath\fR()
.sp
int
\fBTcl_SetEncodingSearchPath\fR(\fIsearchPath\fR)
.VE 8.5
.sp
const char *
\fBTcl_GetDefaultEncodingDir\fR(\fIvoid\fR)
.sp
void
\fBTcl_SetDefaultEncodingDir\fR(\fIpath\fR)
.SH ARGUMENTS
.AS "const Tcl_EncodingType" *dstWrotePtr in/out
.AP Tcl_Interp *interp in
Interpreter to use for error reporting, or NULL if no error reporting is
desired.
.AP "const char" *name in
Name of encoding to load.
.AP Tcl_Encoding encoding in
The encoding to query, free, or use for converting text.  If \fIencoding\fR is 
NULL, the current system encoding is used.
.AP Tcl_Obj *objPtr in
.VS 8.5
Name of encoding to get token for.
.VE 8.5
.AP Tcl_Encoding *encodingPtr out
.VS 8.5
Points to storage where encoding token is to be written.
.VE 8.5
.AP "const char" *src in
For the \fBTcl_ExternalToUtf\fR functions, an array of bytes in the
specified encoding that are to be converted to UTF-8.  For the
\fBTcl_UtfToExternal\fR and \fBTcl_WinUtfToTChar\fR functions, an array of
UTF-8 characters to be converted to the specified encoding.  
.AP "const TCHAR" *tsrc in
An array of Windows TCHAR characters to convert to UTF-8.
.AP int srcLen in 
Length of \fIsrc\fR or \fItsrc\fR in bytes.  If the length is negative, the 
encoding-specific length of the string is used.
.AP Tcl_DString *dstPtr out
Pointer to an uninitialized or free \fBTcl_DString\fR in which the converted
result will be stored.
.AP int flags in
Various flag bits OR-ed together.  
\fBTCL_ENCODING_START\fR signifies that the
source buffer is the first block in a (potentially multi-block) input
stream, telling the conversion routine to reset to an initial state and
perform any initialization that needs to occur before the first byte is
converted. \fBTCL_ENCODING_END\fR signifies that the source buffer is the last
block in a (potentially multi-block) input stream, telling the conversion
routine to perform any finalization that needs to occur after the last
byte is converted and then to reset to an initial state.
\fBTCL_ENCODING_STOPONERROR\fR signifies that the conversion routine should
return immediately upon reading a source character that does not exist in
the target encoding; otherwise a default fallback character will
automatically be substituted.  
.AP Tcl_EncodingState *statePtr in/out
Used when converting a (generally long or indefinite length) byte stream
in a piece-by-piece fashion.  The conversion routine stores its current
state in \fI*statePtr\fR after \fIsrc\fR (the buffer containing the
current piece) has been converted; that state information must be passed
back when converting the next piece of the stream so the conversion
routine knows what state it was in when it left off at the end of the
last piece.  May be NULL, in which case the value specified for \fIflags\fR 
is ignored and the source buffer is assumed to contain the complete string to
convert.
.AP char *dst out
Buffer in which the converted result will be stored.  No more than
\fIdstLen\fR bytes will be stored in \fIdst\fR.
.AP int dstLen in
The maximum length of the output buffer \fIdst\fR in bytes.
.AP int *srcReadPtr out
Filled with the number of bytes from \fIsrc\fR that were actually
converted.  This may be less than the original source length if there was
a problem converting some source characters.  May be NULL.
.AP int *dstWrotePtr out
Filled with the number of bytes that were actually stored in the output
buffer as a result of the conversion.  May be NULL.
.AP int *dstCharsPtr out
Filled with the number of characters that correspond to the number of bytes
stored in the output buffer.  May be NULL.
.AP Tcl_DString *bufPtr out
.VS 8.5
Storage for the prescribed system encoding name.
.VE 8.5
.AP "const Tcl_EncodingType" *typePtr in
Structure that defines a new type of encoding.  
.AP Tcl_Obj *searchPath in
.VS 8.5
List of filesystem directories in which to search for encoding data files.
.VE 8.5
.AP "const char" *path in
A path to the location of the encoding file.  
.BE
.SH INTRODUCTION
.PP
These routines convert between Tcl's internal character representation,
UTF-8, and character representations used by various operating systems or
file systems, such as Unicode, ASCII, or Shift-JIS.  When operating on
strings, such as such as obtaining the names of files or displaying
characters using international fonts, the strings must be translated into
one or possibly multiple formats that the various system calls can use.  For
instance, on a Japanese Unix workstation, a user might obtain a filename
represented in the EUC-JP file encoding and then translate the characters to
the jisx0208 font encoding in order to display the filename in a Tk widget.
The purpose of the encoding package is to help bridge the translation gap.
UTF-8 provides an intermediate staging ground for all the various
encodings.  In the example above, text would be translated into UTF-8 from
whatever file encoding the operating system is using.  Then it would be
translated from UTF-8 into whatever font encoding the display routines
require.
.PP
Some basic encodings are compiled into Tcl.  Others can be defined by the
user or dynamically loaded from encoding files in a
platform-independent manner.
.SH DESCRIPTION
.PP
\fBTcl_GetEncoding\fR finds an encoding given its \fIname\fR.  The name may
refer to a built-in Tcl encoding, a user-defined encoding registered by
calling \fBTcl_CreateEncoding\fR, or a dynamically-loadable encoding
file.  The return value is a token that represents the encoding and can be
used in subsequent calls to procedures such as \fBTcl_GetEncodingName\fR,
\fBTcl_FreeEncoding\fR, and \fBTcl_UtfToExternal\fR.  If the name did not
refer to any known or loadable encoding, NULL is returned and an error
message is returned in \fIinterp\fR.
.PP
The encoding package maintains a database of all encodings currently in use.
The first time \fIname\fR is seen, \fBTcl_GetEncoding\fR returns an
encoding with a reference count of 1.  If the same \fIname\fR is requested
further times, then the reference count for that encoding is incremented
without the overhead of allocating a new encoding and all its associated
data structures.  
.PP
When an \fIencoding\fR is no longer needed, \fBTcl_FreeEncoding\fR
should be called to release it.  When an \fIencoding\fR is no longer in use
anywhere (i.e., it has been freed as many times as it has been gotten)
\fBTcl_FreeEncoding\fR will release all storage the encoding was using
and delete it from the database. 
.PP
.VS 8.5
\fBTcl_GetEncodingFromObj\fR treats the string representation of
\fIobjPtr\fR as an encoding name, and finds an encoding with that
name, just as \fBTcl_GetEncoding\fR does. When an encoding is found,
it is cached within the \fBobjPtr\fR value for future reference, the
\fBTcl_Encoding\fR token is written to the storage pointed to by
\fIencodingPtr\fR, and the value \fBTCL_OK\fR is returned. If no such
encoding is found, the value \fBTCL_ERROR\fR is returned, and no
writing to \fB*\fR\fIencodingPtr\fR takes place. Just as with
\fBTcl_GetEncoding\fR, the caller should call \fBTcl_FreeEncoding\fR
on the resulting encoding token when that token will no longer be
used.
.VE 8.5
.PP
\fBTcl_ExternalToUtfDString\fR converts a source buffer \fIsrc\fR from the
specified \fIencoding\fR into UTF-8.  The converted bytes are stored in 
\fIdstPtr\fR, which is then null-terminated.  The caller should eventually
call \fBTcl_DStringFree\fR to free any information stored in \fIdstPtr\fR.
When converting, if any of the characters in the source buffer cannot be
represented in the target encoding, a default fallback character will be
used.  The return value is a pointer to the value stored in the DString.
.PP
\fBTcl_ExternalToUtf\fR converts a source buffer \fIsrc\fR from the specified
\fIencoding\fR into UTF-8.  Up to \fIsrcLen\fR bytes are converted from the
source buffer and up to \fIdstLen\fR converted bytes are stored in \fIdst\fR.
In all cases, \fI*srcReadPtr\fR is filled with the number of bytes that were
successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR is filled with
the corresponding number of bytes that were stored in \fIdst\fR.  The return
value is one of the following:
.RS
.IP \fBTCL_OK\fR 29
All bytes of \fIsrc\fR were converted.
.IP \fBTCL_CONVERT_NOSPACE\fR 29
The destination buffer was not large enough for all of the converted data; as
many characters as could fit were converted though.
.IP \fBTCL_CONVERT_MULTIBYTE\fR 29
The last few bytes in the source buffer were the beginning of a multibyte
sequence, but more bytes were needed to complete this sequence.  A
subsequent call to the conversion routine should pass a buffer containing
the unconverted bytes that remained in \fIsrc\fR plus some further bytes
from the source stream to properly convert the formerly split-up multibyte
sequence.  
.IP \fBTCL_CONVERT_SYNTAX\fR 29
The source buffer contained an invalid character sequence.  This may occur
if the input stream has been damaged or if the input encoding method was
misidentified.
.IP \fBTCL_CONVERT_UNKNOWN\fR 29
The source buffer contained a character that could not be represented in
the target encoding and \fBTCL_ENCODING_STOPONERROR\fR was specified.  
.RE
.LP
\fBTcl_UtfToExternalDString\fR converts a source buffer \fIsrc\fR from UTF-8 
into the specified \fIencoding\fR.  The converted bytes are stored in
\fIdstPtr\fR, which is then terminated with the appropriate encoding-specific
null.  The caller should eventually call \fBTcl_DStringFree\fR to free any
information stored in \fIdstPtr\fR.  When converting, if any of the
characters in the source buffer cannot be represented in the target
encoding, a default fallback character will be used.  The return value is
a pointer to the value stored in the DString.
.PP
\fBTcl_UtfToExternal\fR converts a source buffer \fIsrc\fR from UTF-8 into
the specified \fIencoding\fR.  Up to \fIsrcLen\fR bytes are converted from
the source buffer and up to \fIdstLen\fR converted bytes are stored in
\fIdst\fR.  In all cases, \fI*srcReadPtr\fR is filled with the number of
bytes that were successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR
is filled with the corresponding number of bytes that were stored in
\fIdst\fR.  The return values are the same as the return values for
\fBTcl_ExternalToUtf\fR.
.PP
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR are
Windows-only convenience
functions for converting between UTF-8 and Windows strings.  On Windows 95
(as with the Unix operating system),
all strings exchanged between Tcl and the operating system are
.QW "char"
based.  On Windows NT, some strings exchanged between Tcl and the
operating system are
.QW "char"
oriented while others are in Unicode.  By
convention, in Windows a TCHAR is a character in the ANSI code page
on Windows 95 and a Unicode character on Windows NT.
.PP
If you planned to use the same
.QW "char"
based interfaces on both Windows
95 and Windows NT, you could use \fBTcl_UtfToExternal\fR and
\fBTcl_ExternalToUtf\fR (or their \fBTcl_DString\fR equivalents) with an
encoding of NULL (the current system encoding).  On the other hand,
if you planned to use the Unicode interface when running on Windows NT
and the
.QW "char"
interfaces when running on Windows 95, you would have
to perform the following type of test over and over in your program
(as represented in pseudo-code):
.CS
if (running NT) {
    encoding <- Tcl_GetEncoding("unicode");
    nativeBuffer <- Tcl_UtfToExternal(encoding, utfBuffer);
    Tcl_FreeEncoding(encoding);
} else {
    nativeBuffer <- Tcl_UtfToExternal(NULL, utfBuffer);
}
.CE
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR automatically
handle this test and use the proper encoding based on the current
operating system.  \fBTcl_WinUtfToTChar\fR returns a pointer to
a TCHAR string, and \fBTcl_WinTCharToUtf\fR expects a TCHAR string
pointer as the \fIsrc\fR string.  Otherwise, these functions
behave identically to \fBTcl_UtfToExternalDString\fR and
\fBTcl_ExternalToUtfDString\fR.
.PP
\fBTcl_GetEncodingName\fR is roughly the inverse of \fBTcl_GetEncoding\fR.
Given an \fIencoding\fR, the return value is the \fIname\fR argument that
was used to create the encoding.  The string returned by 
\fBTcl_GetEncodingName\fR is only guaranteed to persist until the
\fIencoding\fR is deleted.  The caller must not modify this string.
.PP
\fBTcl_SetSystemEncoding\fR sets the default encoding that should be used
whenever the user passes a NULL value for the \fIencoding\fR argument to
any of the other encoding functions.  If \fIname\fR is NULL, the system
encoding is reset to the default system encoding, \fBbinary\fR.  If the
name did not refer to any known or loadable encoding, \fBTCL_ERROR\fR is
returned and an error message is left in \fIinterp\fR.  Otherwise, this
procedure increments the reference count of the new system encoding,
decrements the reference count of the old system encoding, and returns
\fBTCL_OK\fR.
.PP
.VS 8.5
\fBTcl_GetEncodingNameFromEnvironment\fR provides a means for the Tcl
library to report the encoding name it believes to be the correct one
to use as the system encoding, based on system calls and examination of
the environment suitable for the platform.  It accepts \fIbufPtr\fR,
a pointer to an uninitialized or freed \fBTcl_DString\fR and writes
the encoding name to it.  The \fBTcl_DStringValue\fR is returned.
.VE 8.5
.PP
\fBTcl_GetEncodingNames\fR sets the \fIinterp\fR result to a list
consisting of the names of all the encodings that are currently defined
or can be dynamically loaded, searching the encoding path specified by
\fBTcl_SetDefaultEncodingDir\fR.  This procedure does not ensure that the
dynamically-loadable encoding files contain valid data, but merely that they
exist.
.PP
\fBTcl_CreateEncoding\fR defines a new encoding and registers the C
procedures that are called back to convert between the encoding and
UTF-8.  Encodings created by \fBTcl_CreateEncoding\fR are thereafter
visible in the database used by \fBTcl_GetEncoding\fR.  Just as with the
\fBTcl_GetEncoding\fR procedure, the return value is a token that
represents the encoding and can be used in subsequent calls to other
encoding functions.  \fBTcl_CreateEncoding\fR returns an encoding with a
reference count of 1. If an encoding with the specified \fIname\fR
already exists, then its entry in the database is replaced with the new
encoding; the token for the old encoding will remain valid and continue
to behave as before, but users of the new token will now call the new
encoding procedures.  
.PP
The \fItypePtr\fR argument to \fBTcl_CreateEncoding\fR contains information 
about the name of the encoding and the procedures that will be called to
convert between this encoding and UTF-8.  It is defined as follows:
.PP
.CS
typedef struct Tcl_EncodingType {
        const char *\fIencodingName\fR;
        Tcl_EncodingConvertProc *\fItoUtfProc\fR;
        Tcl_EncodingConvertProc *\fIfromUtfProc\fR;
        Tcl_EncodingFreeProc *\fIfreeProc\fR;
        ClientData \fIclientData\fR;
        int \fInullSize\fR;
} Tcl_EncodingType;  
.CE
.PP
The \fIencodingName\fR provides a string name for the encoding, by
which it can be referred in other procedures such as
\fBTcl_GetEncoding\fR.  The \fItoUtfProc\fR refers to a callback
procedure to invoke to convert text from this encoding into UTF-8.
The \fIfromUtfProc\fR refers to a callback procedure to invoke to
convert text from UTF-8 into this encoding.  The \fIfreeProc\fR refers
to a callback procedure to invoke when this encoding is deleted.  The
\fIfreeProc\fR field may be NULL.  The \fIclientData\fR contains an
arbitrary one-word value passed to \fItoUtfProc\fR, \fIfromUtfProc\fR,
and \fIfreeProc\fR whenever they are called.  Typically, this is a
pointer to a data structure containing encoding-specific information
that can be used by the callback procedures.  For instance, two very
similar encodings such as \fBascii\fR and \fBmacRoman\fR may use the
same callback procedure, but use different values of \fIclientData\fR
to control its behavior.  The \fInullSize\fR specifies the number of
zero bytes that signify end-of-string in this encoding.  It must be
\fB1\fR (for single-byte or multi-byte encodings like ASCII or
Shift-JIS) or \fB2\fR (for double-byte encodings like Unicode).
Constant-sized encodings with 3 or more bytes per character (such as
CNS11643) are not accepted.
.PP
The callback procedures \fItoUtfProc\fR and \fIfromUtfProc\fR should match the
type \fBTcl_EncodingConvertProc\fR:
.PP
.CS
typedef int Tcl_EncodingConvertProc(
        ClientData \fIclientData\fR,
        const char *\fIsrc\fR, 
        int \fIsrcLen\fR, 
        int \fIflags\fR, 
        Tcl_EncodingState *\fIstatePtr\fR,
        char *\fIdst\fR, 
        int \fIdstLen\fR, 
        int *\fIsrcReadPtr\fR,
        int *\fIdstWrotePtr\fR,
        int *\fIdstCharsPtr\fR);
.CE
.PP
The \fItoUtfProc\fR and \fIfromUtfProc\fR procedures are called by the
\fBTcl_ExternalToUtf\fR or \fBTcl_UtfToExternal\fR family of functions to
perform the actual conversion.  The \fIclientData\fR parameter to these
procedures is the same as the \fIclientData\fR field specified to
\fBTcl_CreateEncoding\fR when the encoding was created.  The remaining
arguments to the callback procedures are the same as the arguments,
documented at the top, to \fBTcl_ExternalToUtf\fR or
\fBTcl_UtfToExternal\fR, with the following exceptions.  If the
\fIsrcLen\fR argument to one of those high-level functions is negative,
the value passed to the callback procedure will be the appropriate
encoding-specific string length of \fIsrc\fR.  If any of the \fIsrcReadPtr\fR, 
\fIdstWrotePtr\fR, or \fIdstCharsPtr\fR arguments to one of the high-level
functions is NULL, the corresponding value passed to the callback
procedure will be a non-NULL location.
.PP
The callback procedure \fIfreeProc\fR, if non-NULL, should match the type 
\fBTcl_EncodingFreeProc\fR:
.CS
typedef void Tcl_EncodingFreeProc(
        ClientData \fIclientData\fR);
.CE
.PP
This \fIfreeProc\fR function is called when the encoding is deleted.  The
\fIclientData\fR parameter is the same as the \fIclientData\fR field
specified to \fBTcl_CreateEncoding\fR when the encoding was created.  
.PP
.VS 8.5
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR
are called to access and set the list of filesystem directories searched
for encoding data files.  
.PP
The value returned by \fBTcl_GetEncodingSearchPath\fR
is the value stored by the last successful call to
\fBTcl_SetEncodingSearchPath\fR.  If no calls to
\fBTcl_SetEncodingSearchPath\fR have occurred, Tcl will compute an initial
value based on the environment.  There is one encoding search path for the
entire process, shared by all threads in the process.
.PP
\fBTcl_SetEncodingSearchPath\fR stores \fIsearchPath\fR and returns
\fBTCL_OK\fR, unless \fIsearchPath\fR is not a valid Tcl list, which
causes \fBTCL_ERROR\fR to be returned.  The elements of \fIsearchPath\fR
are not verified as existing readable filesystem directories.  When
searching for encoding data files takes place, and non-existent or
non-readable filesystem directories on the \fIsearchPath\fR are silently
ignored.
.PP
\fBTcl_GetDefaultEncodingDir\fR and \fBTcl_SetDefaultEncodingDir\fR
are obsolete interfaces best replaced with calls to
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR.
They are called to access and set the first element of the \fIsearchPath\fR
list.  Since Tcl searches \fIsearchPath\fR for encoding data files in
list order, these routines establish the
.QW default
directory in which to find encoding data files.
.VE 8.5
.SH "ENCODING FILES"
Space would prohibit precompiling into Tcl every possible encoding
algorithm, so many encodings are stored on disk as dynamically-loadable
encoding files.  This behavior also allows the user to create additional
encoding files that can be loaded using the same mechanism.  These
encoding files contain information about the tables and/or escape
sequences used to map between an external encoding and Unicode.  The
external encoding may consist of single-byte, multi-byte, or double-byte
characters.  
.PP
Each dynamically-loadable encoding is represented as a text file.  The
initial line of the file, beginning with a
.QW #
symbol, is a comment
that provides a human-readable description of the file.  The next line
identifies the type of encoding file.  It can be one of the following
letters:
.IP "[1] \fBS\fR"
A single-byte encoding, where one character is always one byte long in the
encoding.  An example is \fBiso8859-1\fR, used by many European languages.
.IP "[2] \fBD\fR"
A double-byte encoding, where one character is always two bytes long in the
encoding.  An example is \fBbig5\fR, used for Chinese text.
.IP "[3] \fBM\fR"
A multi-byte encoding, where one character may be either one or two bytes long.
Certain bytes are lead bytes, indicating that another byte must follow
and that together the two bytes represent one character.  Other bytes are not
lead bytes and represent themselves.  An example is \fBshiftjis\fR, used by
many Japanese computers.
.IP "[4] \fBE\fR"
An escape-sequence encoding, specifying that certain sequences of bytes
do not represent characters, but commands that describe how following bytes
should be interpreted.  
.PP
The rest of the lines in the file depend on the type.  
.PP
Cases [1], [2], and [3] are collectively referred to as table-based encoding
files.  The lines in a table-based encoding file are in the same
format as this example taken from the \fBshiftjis\fR encoding (this is not
the complete file):
.CS
# Encoding file: shiftjis, multi-byte
M
003F 0 40
00
0000000100020003000400050006000700080009000A000B000C000D000E000F
0010001100120013001400150016001700180019001A001B001C001D001E001F
0020002100220023002400250026002700280029002A002B002C002D002E002F
0030003100320033003400350036003700380039003A003B003C003D003E003F
0040004100420043004400450046004700480049004A004B004C004D004E004F
0050005100520053005400550056005700580059005A005B005C005D005E005F
0060006100620063006400650066006700680069006A006B006C006D006E006F
0070007100720073007400750076007700780079007A007B007C007D203E007F
0080000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000FF61FF62FF63FF64FF65FF66FF67FF68FF69FF6AFF6BFF6CFF6DFF6EFF6F
FF70FF71FF72FF73FF74FF75FF76FF77FF78FF79FF7AFF7BFF7CFF7DFF7EFF7F
FF80FF81FF82FF83FF84FF85FF86FF87FF88FF89FF8AFF8BFF8CFF8DFF8EFF8F
FF90FF91FF92FF93FF94FF95FF96FF97FF98FF99FF9AFF9BFF9CFF9DFF9EFF9F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
81
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
300030013002FF0CFF0E30FBFF1AFF1BFF1FFF01309B309C00B4FF4000A8FF3E
FFE3FF3F30FD30FE309D309E30034EDD30053006300730FC20152010FF0F005C
301C2016FF5C2026202520182019201C201DFF08FF0930143015FF3BFF3DFF5B
FF5D30083009300A300B300C300D300E300F30103011FF0B221200B100D70000
00F7FF1D2260FF1CFF1E22662267221E22342642264000B0203220332103FFE5
FF0400A200A3FF05FF03FF06FF0AFF2000A72606260525CB25CF25CE25C725C6
25A125A025B325B225BD25BC203B301221922190219121933013000000000000
000000000000000000000000000000002208220B2286228722822283222A2229
000000000000000000000000000000002227222800AC21D221D4220022030000
0000000000000000000000000000000000000000222022A52312220222072261
2252226A226B221A223D221D2235222B222C0000000000000000000000000000
212B2030266F266D266A2020202100B6000000000000000025EF000000000000
.CE
.PP
The third line of the file is three numbers.  The first number is the
fallback character (in base 16) to use when converting from UTF-8 to this
encoding.  The second number is a \fB1\fR if this file represents the
encoding for a symbol font, or \fB0\fR otherwise.  The last number (in base
10) is how many pages of data follow.  
.PP
Subsequent lines in the example above are pages that describe how to map
from the encoding into 2-byte Unicode.  The first line in a page identifies
the page number.  Following it are 256 double-byte numbers, arranged as 16
rows of 16 numbers.  Given a character in the encoding, the high byte of
that character is used to select which page, and the low byte of that
character is used as an index to select one of the double-byte numbers in
that page \- the value obtained being the corresponding Unicode character.
By examination of the example above, one can see that the characters 0x7E
and 0x8163 in \fBshiftjis\fR map to 203E and 2026 in Unicode, respectively.
.PP
Following the first page will be all the other pages, each in the same
format as the first: one number identifying the page followed by 256
double-byte Unicode characters.  If a character in the encoding maps to the
Unicode character 0000, it means that the character does not actually exist.
If all characters on a page would map to 0000, that page can be omitted.
.PP
Case [4] is the escape-sequence encoding file.  The lines in an this type of
file are in the same format as this example taken from the \fBiso2022-jp\fR
encoding:
.CS
.ta 1.5i
# Encoding file: iso2022-jp, escape-driven
E
init		{}
final		{}
iso8859-1	\ex1b(B
jis0201		\ex1b(J
jis0208		\ex1b$@
jis0208		\ex1b$B
jis0212		\ex1b$(D
gb2312		\ex1b$A
ksc5601		\ex1b$(C
.CE
.PP
In the file, the first column represents an option and the second column
is the associated value.  \fBinit\fR is a string to emit or expect before
the first character is converted, while \fBfinal\fR is a string to emit
or expect after the last character.  All other options are names of
table-based encodings; the associated value is the escape-sequence that
marks that encoding.  Tcl syntax is used for the values; in the above
example, for instance,
.QW \fB{}\fR
represents the empty string and
.QW \fB\ex1b\fR
represents character 27.
.PP
When \fBTcl_GetEncoding\fR encounters an encoding \fIname\fR that has not
been loaded, it attempts to load an encoding file called \fIname\fB.enc\fR
from the \fBencoding\fR subdirectory of each directory that Tcl searches
for its script library.  If the encoding file exists, but is
malformed, an error message will be left in \fIinterp\fR.
.SH KEYWORDS
utf, encoding, convert
                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToLower.3tcl                          0100644 0001750 0001750 00000021333 12566232352 024323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997 by Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: ToUpper.3,v 1.3 2004/09/06 09:44:57 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_UtfToUpper 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_UniCharToUpper, Tcl_UniCharToLower, Tcl_UniCharToTitle, Tcl_UtfToUpper, Tcl_UtfToLower, Tcl_UtfToTitle \- routines for manipulating the case of Unicode characters and UTF-8 strings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_UniChar
\fBTcl_UniCharToUpper\fR(\fIch\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharToLower\fR(\fIch\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharToTitle\fR(\fIch\fR)
.sp
int
\fBTcl_UtfToUpper\fR(\fIstr\fR)
.sp
int
\fBTcl_UtfToLower\fR(\fIstr\fR)
.sp
int
\fBTcl_UtfToTitle\fR(\fIstr\fR)
.SH ARGUMENTS
.AS char *str in/out
.AP int ch in
The Tcl_UniChar to be converted.
.AP char *str in/out
Pointer to UTF-8 string to be converted in place.
.BE

.SH DESCRIPTION
.PP
The first three routines convert the case of individual Unicode characters:
.PP
If \fIch\fR represents a lower-case character,
\fBTcl_UniCharToUpper\fR returns the corresponding upper-case
character.  If no upper-case character is defined, it returns the
character unchanged.
.PP
If \fIch\fR represents an upper-case character,
\fBTcl_UniCharToLower\fR returns the corresponding lower-case
character.  If no lower-case character is defined, it returns the
character unchanged.
.PP
If \fIch\fR represents a lower-case character,
\fBTcl_UniCharToTitle\fR returns the corresponding title-case
character.  If no title-case character is defined, it returns the
corresponding upper-case character.  If no upper-case character is
defined, it returns the character unchanged.  Title-case is defined
for a small number of characters that have a different appearance when
they are at the beginning of a capitalized word.
.PP
The next three routines convert the case of UTF-8 strings in place in
memory:
.PP
\fBTcl_UtfToUpper\fR changes every UTF-8 character in \fIstr\fR to
upper-case.  Because changing the case of a character may change its
size, the byte offset of each character in the resulting string may
differ from its original location.  \fBTcl_UtfToUpper\fR writes a null
byte at the end of the converted string.  \fBTcl_UtfToUpper\fR returns
the new length of the string in bytes.  This new length is guaranteed
to be no longer than the original string length.
.PP
\fBTcl_UtfToLower\fR is the same as \fBTcl_UtfToUpper\fR except it
turns each character in the string into its lower-case equivalent.
.PP
\fBTcl_UtfToTitle\fR is the same as \fBTcl_UtfToUpper\fR except it
turns the first character in the string into its title-case equivalent
and all following characters into their lower-case equivalents.

.SH BUGS
.PP
At this time, the case conversions are only defined for the ISO8859-1
characters.  Unicode characters above 0x00ff are not modified by these
routines.

.SH KEYWORDS
utf, unicode, toupper, tolower, totitle, case
                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToTitle.3tcl                          0100644 0001750 0001750 00000021333 12566232352 024314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997 by Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: ToUpper.3,v 1.3 2004/09/06 09:44:57 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_UtfToUpper 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_UniCharToUpper, Tcl_UniCharToLower, Tcl_UniCharToTitle, Tcl_UtfToUpper, Tcl_UtfToLower, Tcl_UtfToTitle \- routines for manipulating the case of Unicode characters and UTF-8 strings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_UniChar
\fBTcl_UniCharToUpper\fR(\fIch\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharToLower\fR(\fIch\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharToTitle\fR(\fIch\fR)
.sp
int
\fBTcl_UtfToUpper\fR(\fIstr\fR)
.sp
int
\fBTcl_UtfToLower\fR(\fIstr\fR)
.sp
int
\fBTcl_UtfToTitle\fR(\fIstr\fR)
.SH ARGUMENTS
.AS char *str in/out
.AP int ch in
The Tcl_UniChar to be converted.
.AP char *str in/out
Pointer to UTF-8 string to be converted in place.
.BE

.SH DESCRIPTION
.PP
The first three routines convert the case of individual Unicode characters:
.PP
If \fIch\fR represents a lower-case character,
\fBTcl_UniCharToUpper\fR returns the corresponding upper-case
character.  If no upper-case character is defined, it returns the
character unchanged.
.PP
If \fIch\fR represents an upper-case character,
\fBTcl_UniCharToLower\fR returns the corresponding lower-case
character.  If no lower-case character is defined, it returns the
character unchanged.
.PP
If \fIch\fR represents a lower-case character,
\fBTcl_UniCharToTitle\fR returns the corresponding title-case
character.  If no title-case character is defined, it returns the
corresponding upper-case character.  If no upper-case character is
defined, it returns the character unchanged.  Title-case is defined
for a small number of characters that have a different appearance when
they are at the beginning of a capitalized word.
.PP
The next three routines convert the case of UTF-8 strings in place in
memory:
.PP
\fBTcl_UtfToUpper\fR changes every UTF-8 character in \fIstr\fR to
upper-case.  Because changing the case of a character may change its
size, the byte offset of each character in the resulting string may
differ from its original location.  \fBTcl_UtfToUpper\fR writes a null
byte at the end of the converted string.  \fBTcl_UtfToUpper\fR returns
the new length of the string in bytes.  This new length is guaranteed
to be no longer than the original string length.
.PP
\fBTcl_UtfToLower\fR is the same as \fBTcl_UtfToUpper\fR except it
turns each character in the string into its lower-case equivalent.
.PP
\fBTcl_UtfToTitle\fR is the same as \fBTcl_UtfToUpper\fR except it
turns the first character in the string into its title-case equivalent
and all following characters into their lower-case equivalents.

.SH BUGS
.PP
At this time, the case conversions are only defined for the ISO8859-1
characters.  Unicode characters above 0x00ff are not modified by these
routines.

.SH KEYWORDS
utf, unicode, toupper, tolower, totitle, case
                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToUniChar.3tcl                        0100644 0001750 0001750 00000040620 12566232353 024565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Utf.3,v 1.25 2007/12/13 15:22:32 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Utf 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_UniChar, Tcl_UniCharCaseMatch, Tcl_UniCharNcasecmp, Tcl_UniCharToUtf, Tcl_UtfToUniChar, Tcl_UniCharToUtfDString, Tcl_UtfToUniCharDString, Tcl_UniCharLen, Tcl_UniCharNcmp, Tcl_UtfCharComplete, Tcl_NumUtfChars, Tcl_UtfFindFirst, Tcl_UtfFindLast, Tcl_UtfNext, Tcl_UtfPrev, Tcl_UniCharAtIndex, Tcl_UtfAtIndex, Tcl_UtfBackslash \- routines for manipulating UTF-8 strings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
typedef ... Tcl_UniChar;
.sp
int
\fBTcl_UniCharToUtf\fR(\fIch, buf\fR)
.sp
int
\fBTcl_UtfToUniChar\fR(\fIsrc, chPtr\fR)
.sp
char *
\fBTcl_UniCharToUtfDString\fR(\fIuniStr, uniLength, dsPtr\fR)
.sp
Tcl_UniChar *
\fBTcl_UtfToUniCharDString\fR(\fIsrc, length, dsPtr\fR)
.sp
int
\fBTcl_UniCharLen\fR(\fIuniStr\fR)
.sp
int
\fBTcl_UniCharNcmp\fR(\fIucs, uct, numChars\fR)
.sp
int
\fBTcl_UniCharNcasecmp\fR(\fIucs, uct, numChars\fR)
.sp
int
\fBTcl_UniCharCaseMatch\fR(\fIuniStr, uniPattern, nocase\fR)
.sp
int
\fBTcl_UtfNcmp\fR(\fIcs, ct, numChars\fR)
.sp
int
\fBTcl_UtfNcasecmp\fR(\fIcs, ct, numChars\fR)
.sp
int
\fBTcl_UtfCharComplete\fR(\fIsrc, length\fR)
.sp
int 
\fBTcl_NumUtfChars\fR(\fIsrc, length\fR)
.sp
const char *
\fBTcl_UtfFindFirst\fR(\fIsrc, ch\fR)
.sp
const char *
\fBTcl_UtfFindLast\fR(\fIsrc, ch\fR)
.sp
const char *
\fBTcl_UtfNext\fR(\fIsrc\fR)
.sp
const char *
\fBTcl_UtfPrev\fR(\fIsrc, start\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharAtIndex\fR(\fIsrc, index\fR)
.sp
const char *
\fBTcl_UtfAtIndex\fR(\fIsrc, index\fR)
.sp
int
\fBTcl_UtfBackslash\fR(\fIsrc, readPtr, dst\fR)
.SH ARGUMENTS
.AS "const Tcl_UniChar" *uniPattern in/out
.AP char *buf out
Buffer in which the UTF-8 representation of the Tcl_UniChar is stored.  At most
\fBTCL_UTF_MAX\fR bytes are stored in the buffer.
.AP int ch in
The Tcl_UniChar to be converted or examined.
.AP Tcl_UniChar *chPtr out
Filled with the Tcl_UniChar represented by the head of the UTF-8 string.
.AP "const char" *src in
Pointer to a UTF-8 string.
.AP "const char" *cs in
Pointer to a UTF-8 string.
.AP "const char" *ct in
Pointer to a UTF-8 string.
.AP "const Tcl_UniChar" *uniStr in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *ucs in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *uct in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *uniPattern in
A null-terminated Unicode string.
.AP int length in
The length of the UTF-8 string in bytes (not UTF-8 characters).  If
negative, all bytes up to the first null byte are used.
.AP int uniLength in
The length of the Unicode string in characters.  Must be greater than or
equal to 0.
.AP "Tcl_DString" *dsPtr in/out
A pointer to a previously initialized \fBTcl_DString\fR.
.AP "unsigned long" numChars in
The number of characters to compare.
.AP "const char" *start in
Pointer to the beginning of a UTF-8 string.
.AP int index in
The index of a character (not byte) in the UTF-8 string.
.AP int *readPtr out
If non-NULL, filled with the number of bytes in the backslash sequence, 
including the backslash character.
.AP char *dst out
Buffer in which the bytes represented by the backslash sequence are stored.
At most \fBTCL_UTF_MAX\fR bytes are stored in the buffer.
.AP int nocase in
Specifies whether the match should be done case-sensitive (0) or
case-insensitive (1).
.BE

.SH DESCRIPTION
.PP
These routines convert between UTF-8 strings and Tcl_UniChars.  A
Tcl_UniChar is a Unicode character represented as an unsigned, fixed-size
quantity.  A UTF-8 character is a Unicode character represented as
a varying-length sequence of up to \fBTCL_UTF_MAX\fR bytes.  A multibyte UTF-8
sequence consists of a lead byte followed by some number of trail bytes.
.PP
\fBTCL_UTF_MAX\fR is the maximum number of bytes that it takes to
represent one Unicode character in the UTF-8 representation.
.PP
\fBTcl_UniCharToUtf\fR stores the Tcl_UniChar \fIch\fR as a UTF-8 string
in starting at \fIbuf\fR.  The return value is the number of bytes stored
in \fIbuf\fR.
.PP
\fBTcl_UtfToUniChar\fR reads one UTF-8 character starting at \fIsrc\fR
and stores it as a Tcl_UniChar in \fI*chPtr\fR.  The return value is the
number of bytes read from \fIsrc\fR.  The caller must ensure that the
source buffer is long enough such that this routine does not run off the
end and dereference non-existent or random memory; if the source buffer
is known to be null-terminated, this will not happen.  If the input is
not in proper UTF-8 format, \fBTcl_UtfToUniChar\fR will store the first
byte of \fIsrc\fR in \fI*chPtr\fR as a Tcl_UniChar between 0x0000 and
0x00ff and return 1.  
.PP
\fBTcl_UniCharToUtfDString\fR converts the given Unicode string
to UTF-8, storing the result in a previously initialized \fBTcl_DString\fR.
You must specify \fIuniLength\fR, the length of the given Unicode string.
The return value is a pointer to the UTF-8 representation of the
Unicode string.  Storage for the return value is appended to the
end of the \fBTcl_DString\fR.
.PP
\fBTcl_UtfToUniCharDString\fR converts the given UTF-8 string to Unicode,
storing the result in the previously initialized \fBTcl_DString\fR.
In the argument \fIlength\fR, you may either specify the length of
the given UTF-8 string in bytes or
.QW \-1 ,
in which case \fBTcl_UtfToUniCharDString\fR uses \fBstrlen\fR to
calculate the length.  The return value is a pointer to the Unicode
representation of the UTF-8 string.  Storage for the return value
is appended to the end of the \fBTcl_DString\fR.  The Unicode string
is terminated with a Unicode null character.
.PP
\fBTcl_UniCharLen\fR corresponds to \fBstrlen\fR for Unicode
characters.  It accepts a null-terminated Unicode string and returns
the number of Unicode characters (not bytes) in that string.
.PP
\fBTcl_UniCharNcmp\fR and \fBTcl_UniCharNcasecmp\fR correspond to
\fBstrncmp\fR and \fBstrncasecmp\fR, respectively, for Unicode characters.
They accept two null-terminated Unicode strings and the number of characters
to compare.  Both strings are assumed to be at least \fInumChars\fR characters
long. \fBTcl_UniCharNcmp\fR  compares the two strings character-by-character
according to the Unicode character ordering.  It returns an integer greater
than, equal to, or less than 0 if the first string is greater than, equal
to, or less than the second string respectively.  \fBTcl_UniCharNcasecmp\fR
is the Unicode case insensitive version.
.PP
\fBTcl_UniCharCaseMatch\fR is the Unicode equivalent to
\fBTcl_StringCaseMatch\fR.  It accepts a null-terminated Unicode string,
a Unicode pattern, and a boolean value specifying whether the match should
be case sensitive and returns whether the string matches the pattern.
.PP
\fBTcl_UtfNcmp\fR corresponds to \fBstrncmp\fR for UTF-8 strings. It
accepts two null-terminated UTF-8 strings and the number of characters
to compare.  (Both strings are assumed to be at least \fInumChars\fR
characters long.)  \fBTcl_UtfNcmp\fR compares the two strings
character-by-character according to the Unicode character ordering.
It returns an integer greater than, equal to, or less than 0 if the
first string is greater than, equal to, or less than the second string
respectively.
.PP
\fBTcl_UtfNcasecmp\fR corresponds to \fBstrncasecmp\fR for UTF-8
strings.  It is similar to \fBTcl_UtfNcmp\fR except comparisons ignore
differences in case when comparing upper, lower or title case
characters.
.PP
\fBTcl_UtfCharComplete\fR returns 1 if the source UTF-8 string \fIsrc\fR
of \fIlength\fR bytes is long enough to be decoded by
\fBTcl_UtfToUniChar\fR, or 0 otherwise.  This function does not guarantee
that the UTF-8 string is properly formed.  This routine is used by
procedures that are operating on a byte at a time and need to know if a
full Tcl_UniChar has been seen.
.PP
\fBTcl_NumUtfChars\fR corresponds to \fBstrlen\fR for UTF-8 strings.  It
returns the number of Tcl_UniChars that are represented by the UTF-8 string
\fIsrc\fR.  The length of the source string is \fIlength\fR bytes.  If the
length is negative, all bytes up to the first null byte are used.
.PP
\fBTcl_UtfFindFirst\fR corresponds to \fBstrchr\fR for UTF-8 strings.  It
returns a pointer to the first occurrence of the Tcl_UniChar \fIch\fR
in the null-terminated UTF-8 string \fIsrc\fR.  The null terminator is
considered part of the UTF-8 string.  
.PP
\fBTcl_UtfFindLast\fR corresponds to \fBstrrchr\fR for UTF-8 strings.  It
returns a pointer to the last occurrence of the Tcl_UniChar \fIch\fR
in the null-terminated UTF-8 string \fIsrc\fR.  The null terminator is
considered part of the UTF-8 string.  
.PP
Given \fIsrc\fR, a pointer to some location in a UTF-8 string,
\fBTcl_UtfNext\fR returns a pointer to the next UTF-8 character in the
string.  The caller must not ask for the next character after the last
character in the string if the string is not terminated by a null
character.
.PP
Given \fIsrc\fR, a pointer to some location in a UTF-8 string (or to a
null byte immediately following such a string), \fBTcl_UtfPrev\fR
returns a pointer to the closest preceding byte that starts a UTF-8
character.
This function will not back up to a position before \fIstart\fR,
the start of the UTF-8 string.  If \fIsrc\fR was already at \fIstart\fR, the
return value will be \fIstart\fR.
.PP
\fBTcl_UniCharAtIndex\fR corresponds to a C string array dereference or the
Pascal Ord() function.  It returns the Tcl_UniChar represented at the
specified character (not byte) \fIindex\fR in the UTF-8 string
\fIsrc\fR.  The source string must contain at least \fIindex\fR
characters.  Behavior is undefined if a negative \fIindex\fR is given.
.PP
\fBTcl_UtfAtIndex\fR returns a pointer to the specified character (not
byte) \fIindex\fR in the UTF-8 string \fIsrc\fR.  The source string must
contain at least \fIindex\fR characters.  This is equivalent to calling 
\fBTcl_UtfNext\fR \fIindex\fR times.  If a negative \fIindex\fR is given,
the return pointer points to the first character in the source string.
.PP
\fBTcl_UtfBackslash\fR is a utility procedure used by several of the Tcl
commands.  It parses a backslash sequence and stores the properly formed
UTF-8 character represented by the backslash sequence in the output
buffer \fIdst\fR.  At most \fBTCL_UTF_MAX\fR bytes are stored in the buffer.
\fBTcl_UtfBackslash\fR modifies \fI*readPtr\fR to contain the number
of bytes in the backslash sequence, including the backslash character.
The return value is the number of bytes stored in the output buffer.
.PP
See the \fBTcl\fR manual entry for information on the valid backslash
sequences.  All of the sequences described in the Tcl manual entry are
supported by \fBTcl_UtfBackslash\fR.

.SH KEYWORDS
utf, unicode, backslash
                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToUniCharDString.3tcl                 0100644 0001750 0001750 00000040620 12566232353 026060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Utf.3,v 1.25 2007/12/13 15:22:32 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Utf 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_UniChar, Tcl_UniCharCaseMatch, Tcl_UniCharNcasecmp, Tcl_UniCharToUtf, Tcl_UtfToUniChar, Tcl_UniCharToUtfDString, Tcl_UtfToUniCharDString, Tcl_UniCharLen, Tcl_UniCharNcmp, Tcl_UtfCharComplete, Tcl_NumUtfChars, Tcl_UtfFindFirst, Tcl_UtfFindLast, Tcl_UtfNext, Tcl_UtfPrev, Tcl_UniCharAtIndex, Tcl_UtfAtIndex, Tcl_UtfBackslash \- routines for manipulating UTF-8 strings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
typedef ... Tcl_UniChar;
.sp
int
\fBTcl_UniCharToUtf\fR(\fIch, buf\fR)
.sp
int
\fBTcl_UtfToUniChar\fR(\fIsrc, chPtr\fR)
.sp
char *
\fBTcl_UniCharToUtfDString\fR(\fIuniStr, uniLength, dsPtr\fR)
.sp
Tcl_UniChar *
\fBTcl_UtfToUniCharDString\fR(\fIsrc, length, dsPtr\fR)
.sp
int
\fBTcl_UniCharLen\fR(\fIuniStr\fR)
.sp
int
\fBTcl_UniCharNcmp\fR(\fIucs, uct, numChars\fR)
.sp
int
\fBTcl_UniCharNcasecmp\fR(\fIucs, uct, numChars\fR)
.sp
int
\fBTcl_UniCharCaseMatch\fR(\fIuniStr, uniPattern, nocase\fR)
.sp
int
\fBTcl_UtfNcmp\fR(\fIcs, ct, numChars\fR)
.sp
int
\fBTcl_UtfNcasecmp\fR(\fIcs, ct, numChars\fR)
.sp
int
\fBTcl_UtfCharComplete\fR(\fIsrc, length\fR)
.sp
int 
\fBTcl_NumUtfChars\fR(\fIsrc, length\fR)
.sp
const char *
\fBTcl_UtfFindFirst\fR(\fIsrc, ch\fR)
.sp
const char *
\fBTcl_UtfFindLast\fR(\fIsrc, ch\fR)
.sp
const char *
\fBTcl_UtfNext\fR(\fIsrc\fR)
.sp
const char *
\fBTcl_UtfPrev\fR(\fIsrc, start\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharAtIndex\fR(\fIsrc, index\fR)
.sp
const char *
\fBTcl_UtfAtIndex\fR(\fIsrc, index\fR)
.sp
int
\fBTcl_UtfBackslash\fR(\fIsrc, readPtr, dst\fR)
.SH ARGUMENTS
.AS "const Tcl_UniChar" *uniPattern in/out
.AP char *buf out
Buffer in which the UTF-8 representation of the Tcl_UniChar is stored.  At most
\fBTCL_UTF_MAX\fR bytes are stored in the buffer.
.AP int ch in
The Tcl_UniChar to be converted or examined.
.AP Tcl_UniChar *chPtr out
Filled with the Tcl_UniChar represented by the head of the UTF-8 string.
.AP "const char" *src in
Pointer to a UTF-8 string.
.AP "const char" *cs in
Pointer to a UTF-8 string.
.AP "const char" *ct in
Pointer to a UTF-8 string.
.AP "const Tcl_UniChar" *uniStr in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *ucs in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *uct in
A null-terminated Unicode string.
.AP "const Tcl_UniChar" *uniPattern in
A null-terminated Unicode string.
.AP int length in
The length of the UTF-8 string in bytes (not UTF-8 characters).  If
negative, all bytes up to the first null byte are used.
.AP int uniLength in
The length of the Unicode string in characters.  Must be greater than or
equal to 0.
.AP "Tcl_DString" *dsPtr in/out
A pointer to a previously initialized \fBTcl_DString\fR.
.AP "unsigned long" numChars in
The number of characters to compare.
.AP "const char" *start in
Pointer to the beginning of a UTF-8 string.
.AP int index in
The index of a character (not byte) in the UTF-8 string.
.AP int *readPtr out
If non-NULL, filled with the number of bytes in the backslash sequence, 
including the backslash character.
.AP char *dst out
Buffer in which the bytes represented by the backslash sequence are stored.
At most \fBTCL_UTF_MAX\fR bytes are stored in the buffer.
.AP int nocase in
Specifies whether the match should be done case-sensitive (0) or
case-insensitive (1).
.BE

.SH DESCRIPTION
.PP
These routines convert between UTF-8 strings and Tcl_UniChars.  A
Tcl_UniChar is a Unicode character represented as an unsigned, fixed-size
quantity.  A UTF-8 character is a Unicode character represented as
a varying-length sequence of up to \fBTCL_UTF_MAX\fR bytes.  A multibyte UTF-8
sequence consists of a lead byte followed by some number of trail bytes.
.PP
\fBTCL_UTF_MAX\fR is the maximum number of bytes that it takes to
represent one Unicode character in the UTF-8 representation.
.PP
\fBTcl_UniCharToUtf\fR stores the Tcl_UniChar \fIch\fR as a UTF-8 string
in starting at \fIbuf\fR.  The return value is the number of bytes stored
in \fIbuf\fR.
.PP
\fBTcl_UtfToUniChar\fR reads one UTF-8 character starting at \fIsrc\fR
and stores it as a Tcl_UniChar in \fI*chPtr\fR.  The return value is the
number of bytes read from \fIsrc\fR.  The caller must ensure that the
source buffer is long enough such that this routine does not run off the
end and dereference non-existent or random memory; if the source buffer
is known to be null-terminated, this will not happen.  If the input is
not in proper UTF-8 format, \fBTcl_UtfToUniChar\fR will store the first
byte of \fIsrc\fR in \fI*chPtr\fR as a Tcl_UniChar between 0x0000 and
0x00ff and return 1.  
.PP
\fBTcl_UniCharToUtfDString\fR converts the given Unicode string
to UTF-8, storing the result in a previously initialized \fBTcl_DString\fR.
You must specify \fIuniLength\fR, the length of the given Unicode string.
The return value is a pointer to the UTF-8 representation of the
Unicode string.  Storage for the return value is appended to the
end of the \fBTcl_DString\fR.
.PP
\fBTcl_UtfToUniCharDString\fR converts the given UTF-8 string to Unicode,
storing the result in the previously initialized \fBTcl_DString\fR.
In the argument \fIlength\fR, you may either specify the length of
the given UTF-8 string in bytes or
.QW \-1 ,
in which case \fBTcl_UtfToUniCharDString\fR uses \fBstrlen\fR to
calculate the length.  The return value is a pointer to the Unicode
representation of the UTF-8 string.  Storage for the return value
is appended to the end of the \fBTcl_DString\fR.  The Unicode string
is terminated with a Unicode null character.
.PP
\fBTcl_UniCharLen\fR corresponds to \fBstrlen\fR for Unicode
characters.  It accepts a null-terminated Unicode string and returns
the number of Unicode characters (not bytes) in that string.
.PP
\fBTcl_UniCharNcmp\fR and \fBTcl_UniCharNcasecmp\fR correspond to
\fBstrncmp\fR and \fBstrncasecmp\fR, respectively, for Unicode characters.
They accept two null-terminated Unicode strings and the number of characters
to compare.  Both strings are assumed to be at least \fInumChars\fR characters
long. \fBTcl_UniCharNcmp\fR  compares the two strings character-by-character
according to the Unicode character ordering.  It returns an integer greater
than, equal to, or less than 0 if the first string is greater than, equal
to, or less than the second string respectively.  \fBTcl_UniCharNcasecmp\fR
is the Unicode case insensitive version.
.PP
\fBTcl_UniCharCaseMatch\fR is the Unicode equivalent to
\fBTcl_StringCaseMatch\fR.  It accepts a null-terminated Unicode string,
a Unicode pattern, and a boolean value specifying whether the match should
be case sensitive and returns whether the string matches the pattern.
.PP
\fBTcl_UtfNcmp\fR corresponds to \fBstrncmp\fR for UTF-8 strings. It
accepts two null-terminated UTF-8 strings and the number of characters
to compare.  (Both strings are assumed to be at least \fInumChars\fR
characters long.)  \fBTcl_UtfNcmp\fR compares the two strings
character-by-character according to the Unicode character ordering.
It returns an integer greater than, equal to, or less than 0 if the
first string is greater than, equal to, or less than the second string
respectively.
.PP
\fBTcl_UtfNcasecmp\fR corresponds to \fBstrncasecmp\fR for UTF-8
strings.  It is similar to \fBTcl_UtfNcmp\fR except comparisons ignore
differences in case when comparing upper, lower or title case
characters.
.PP
\fBTcl_UtfCharComplete\fR returns 1 if the source UTF-8 string \fIsrc\fR
of \fIlength\fR bytes is long enough to be decoded by
\fBTcl_UtfToUniChar\fR, or 0 otherwise.  This function does not guarantee
that the UTF-8 string is properly formed.  This routine is used by
procedures that are operating on a byte at a time and need to know if a
full Tcl_UniChar has been seen.
.PP
\fBTcl_NumUtfChars\fR corresponds to \fBstrlen\fR for UTF-8 strings.  It
returns the number of Tcl_UniChars that are represented by the UTF-8 string
\fIsrc\fR.  The length of the source string is \fIlength\fR bytes.  If the
length is negative, all bytes up to the first null byte are used.
.PP
\fBTcl_UtfFindFirst\fR corresponds to \fBstrchr\fR for UTF-8 strings.  It
returns a pointer to the first occurrence of the Tcl_UniChar \fIch\fR
in the null-terminated UTF-8 string \fIsrc\fR.  The null terminator is
considered part of the UTF-8 string.  
.PP
\fBTcl_UtfFindLast\fR corresponds to \fBstrrchr\fR for UTF-8 strings.  It
returns a pointer to the last occurrence of the Tcl_UniChar \fIch\fR
in the null-terminated UTF-8 string \fIsrc\fR.  The null terminator is
considered part of the UTF-8 string.  
.PP
Given \fIsrc\fR, a pointer to some location in a UTF-8 string,
\fBTcl_UtfNext\fR returns a pointer to the next UTF-8 character in the
string.  The caller must not ask for the next character after the last
character in the string if the string is not terminated by a null
character.
.PP
Given \fIsrc\fR, a pointer to some location in a UTF-8 string (or to a
null byte immediately following such a string), \fBTcl_UtfPrev\fR
returns a pointer to the closest preceding byte that starts a UTF-8
character.
This function will not back up to a position before \fIstart\fR,
the start of the UTF-8 string.  If \fIsrc\fR was already at \fIstart\fR, the
return value will be \fIstart\fR.
.PP
\fBTcl_UniCharAtIndex\fR corresponds to a C string array dereference or the
Pascal Ord() function.  It returns the Tcl_UniChar represented at the
specified character (not byte) \fIindex\fR in the UTF-8 string
\fIsrc\fR.  The source string must contain at least \fIindex\fR
characters.  Behavior is undefined if a negative \fIindex\fR is given.
.PP
\fBTcl_UtfAtIndex\fR returns a pointer to the specified character (not
byte) \fIindex\fR in the UTF-8 string \fIsrc\fR.  The source string must
contain at least \fIindex\fR characters.  This is equivalent to calling 
\fBTcl_UtfNext\fR \fIindex\fR times.  If a negative \fIindex\fR is given,
the return pointer points to the first character in the source string.
.PP
\fBTcl_UtfBackslash\fR is a utility procedure used by several of the Tcl
commands.  It parses a backslash sequence and stores the properly formed
UTF-8 character represented by the backslash sequence in the output
buffer \fIdst\fR.  At most \fBTCL_UTF_MAX\fR bytes are stored in the buffer.
\fBTcl_UtfBackslash\fR modifies \fI*readPtr\fR to contain the number
of bytes in the backslash sequence, including the backslash character.
The return value is the number of bytes stored in the output buffer.
.PP
See the \fBTcl\fR manual entry for information on the valid backslash
sequences.  All of the sequences described in the Tcl manual entry are
supported by \fBTcl_UtfBackslash\fR.

.SH KEYWORDS
utf, unicode, backslash
                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_UtfToUpper.3tcl                          0100644 0001750 0001750 00000021333 12566232352 024326  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997 by Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: ToUpper.3,v 1.3 2004/09/06 09:44:57 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_UtfToUpper 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_UniCharToUpper, Tcl_UniCharToLower, Tcl_UniCharToTitle, Tcl_UtfToUpper, Tcl_UtfToLower, Tcl_UtfToTitle \- routines for manipulating the case of Unicode characters and UTF-8 strings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_UniChar
\fBTcl_UniCharToUpper\fR(\fIch\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharToLower\fR(\fIch\fR)
.sp
Tcl_UniChar
\fBTcl_UniCharToTitle\fR(\fIch\fR)
.sp
int
\fBTcl_UtfToUpper\fR(\fIstr\fR)
.sp
int
\fBTcl_UtfToLower\fR(\fIstr\fR)
.sp
int
\fBTcl_UtfToTitle\fR(\fIstr\fR)
.SH ARGUMENTS
.AS char *str in/out
.AP int ch in
The Tcl_UniChar to be converted.
.AP char *str in/out
Pointer to UTF-8 string to be converted in place.
.BE

.SH DESCRIPTION
.PP
The first three routines convert the case of individual Unicode characters:
.PP
If \fIch\fR represents a lower-case character,
\fBTcl_UniCharToUpper\fR returns the corresponding upper-case
character.  If no upper-case character is defined, it returns the
character unchanged.
.PP
If \fIch\fR represents an upper-case character,
\fBTcl_UniCharToLower\fR returns the corresponding lower-case
character.  If no lower-case character is defined, it returns the
character unchanged.
.PP
If \fIch\fR represents a lower-case character,
\fBTcl_UniCharToTitle\fR returns the corresponding title-case
character.  If no title-case character is defined, it returns the
corresponding upper-case character.  If no upper-case character is
defined, it returns the character unchanged.  Title-case is defined
for a small number of characters that have a different appearance when
they are at the beginning of a capitalized word.
.PP
The next three routines convert the case of UTF-8 strings in place in
memory:
.PP
\fBTcl_UtfToUpper\fR changes every UTF-8 character in \fIstr\fR to
upper-case.  Because changing the case of a character may change its
size, the byte offset of each character in the resulting string may
differ from its original location.  \fBTcl_UtfToUpper\fR writes a null
byte at the end of the converted string.  \fBTcl_UtfToUpper\fR returns
the new length of the string in bytes.  This new length is guaranteed
to be no longer than the original string length.
.PP
\fBTcl_UtfToLower\fR is the same as \fBTcl_UtfToUpper\fR except it
turns each character in the string into its lower-case equivalent.
.PP
\fBTcl_UtfToTitle\fR is the same as \fBTcl_UtfToUpper\fR except it
turns the first character in the string into its title-case equivalent
and all following characters into their lower-case equivalents.

.SH BUGS
.PP
At this time, the case conversions are only defined for the ISO8859-1
characters.  Unicode characters above 0x00ff are not modified by these
routines.

.SH KEYWORDS
utf, unicode, toupper, tolower, totitle, case
                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_ValidateAllMemory.3tcl                   0100644 0001750 0001750 00000020017 12566232331 025617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1992-1999 Karl Lehenbauer and Mark Diekhans.
'\" Copyright (c) 2000 by Scriptics Corporation.
'\" All rights reserved.
'\" 
'\" RCS: @(#) $Id: DumpActiveMemory.3,v 1.8 2004/10/07 15:15:36 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH "Tcl_DumpActiveMemory" 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_DumpActiveMemory, Tcl_InitMemory, Tcl_ValidateAllMemory \- Validated memory allocation interface
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_DumpActiveMemory\fR(\fIfileName\fR)
.sp
void
\fBTcl_InitMemory\fR(\fIinterp\fR)
.sp
void
\fBTcl_ValidateAllMemory\fR(\fIfileName, line\fR)

.SH ARGUMENTS
.AS Tcl_Interp *fileName
.AP Tcl_Interp *interp in
Tcl interpreter in which to add commands.
.AP "const char" *fileName in
For \fBTcl_DumpActiveMemory\fR, name of the file to which memory
information will be written.  For \fBTcl_ValidateAllMemory\fR, name of
the file from which the call is being made (normally \fB__FILE__\fR).
.AP int line in
Line number at which the call to \fBTcl_ValidateAllMemory\fR is made
(normally \fB__LINE__\fR).
.BE

.SH DESCRIPTION
These functions provide access to Tcl memory debugging information.
They are only functional when Tcl has been compiled with
\fBTCL_MEM_DEBUG\fR defined at compile-time.  When \fBTCL_MEM_DEBUG\fR
is not defined, these functions are all no-ops.
.PP 
\fBTcl_DumpActiveMemory\fR will output a list of all currently
allocated memory to the specified file.  The information output for
each allocated block of memory is:  starting and ending addresses
(excluding guard zone), size, source file where \fBckalloc\fR was
called to allocate the block and line number in that file.  It is
especially useful to call \fBTcl_DumpActiveMemory\fR after the Tcl
interpreter has been deleted.
.PP
\fBTcl_InitMemory\fR adds the Tcl \fBmemory\fR command to the
interpreter given by \fIinterp\fR.  \fBTcl_InitMemory\fR is called
by \fBTcl_Main\fR.
.PP
\fBTcl_ValidateAllMemory\fR forces a validation of the guard zones of
all currently allocated blocks of memory.  Normally validation of a
block occurs when its freed, unless full validation is enabled, in
which case validation of all blocks occurs when \fBckalloc\fR and
\fBckfree\fR are called.  This function forces the validation to occur
at any point.

.SH "SEE ALSO"
TCL_MEM_DEBUG, memory

.SH KEYWORDS
memory, debug


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_VarEval.3tcl                             0100644 0001750 0001750 00000034556 12566232333 023623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\" Copyright (c) 2000 Scriptics Corporation.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Eval.3,v 1.27 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Eval 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_EvalObjEx, Tcl_EvalFile, Tcl_EvalObjv, Tcl_Eval, Tcl_EvalEx, Tcl_GlobalEval, Tcl_GlobalEvalObj, Tcl_VarEval, Tcl_VarEvalVA \- execute Tcl scripts
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_EvalObjEx\fR(\fIinterp, objPtr, flags\fR)
.sp
int
\fBTcl_EvalFile\fR(\fIinterp, fileName\fR)
.sp
int
\fBTcl_EvalObjv\fR(\fIinterp, objc, objv, flags\fR)
.sp
int
\fBTcl_Eval\fR(\fIinterp, script\fR)
.sp
int
\fBTcl_EvalEx\fR(\fIinterp, script, numBytes, flags\fR)
.sp
int
\fBTcl_GlobalEval\fR(\fIinterp, script\fR)
.sp
int
\fBTcl_GlobalEvalObj\fR(\fIinterp, objPtr\fR)
.sp
int
\fBTcl_VarEval\fR(\fIinterp, part, part, ... \fB(char *) NULL\fR)
.sp
int
\fBTcl_VarEvalVA\fR(\fIinterp, argList\fR)
.SH ARGUMENTS
.AS Tcl_Interp **termPtr
.AP Tcl_Interp *interp in
Interpreter in which to execute the script.  The interpreter's result is
modified to hold the result or error message from the script.
.AP Tcl_Obj *objPtr in
A Tcl object containing the script to execute.
.AP int flags in
ORed combination of flag bits that specify additional options.
\fBTCL_EVAL_GLOBAL\fR and \fBTCL_EVAL_DIRECT\fR are currently supported.
.AP "const char" *fileName in
Name of a file containing a Tcl script.
.AP int objc in
The number of objects in the array pointed to by \fIobjPtr\fR;
this is also the number of words in the command.
.AP Tcl_Obj **objv in
Points to an array of pointers to objects; each object holds the
value of a single word in the command to execute.
.AP int numBytes in
The number of bytes in \fIscript\fR, not including any
null terminating character.  If \-1, then all characters up to the
first null byte are used.
.AP "const char" *script in
Points to first byte of script to execute (null-terminated and UTF-8).
.AP char *part in
String forming part of a Tcl script.
.AP va_list argList in
An argument list which must have been initialized using
\fBva_start\fR, and cleared using \fBva_end\fR.
.BE

.SH DESCRIPTION
.PP
The procedures described here are invoked to execute Tcl scripts in
various forms.
\fBTcl_EvalObjEx\fR is the core procedure and is used by many of the others.
It executes the commands in the script stored in \fIobjPtr\fR
until either an error occurs or the end of the script is reached.
If this is the first time \fIobjPtr\fR has been executed,
its commands are compiled into bytecode instructions
which are then executed.  The
bytecodes are saved in \fIobjPtr\fR so that the compilation step
can be skipped if the object is evaluated again in the future.
.PP
The return value from \fBTcl_EvalObjEx\fR (and all the other procedures
described here) is a Tcl completion code with
one of the values \fBTCL_OK\fR, \fBTCL_ERROR\fR, \fBTCL_RETURN\fR,
\fBTCL_BREAK\fR, or \fBTCL_CONTINUE\fR, or possibly some other
integer value originating in an extension.
In addition, a result value or error message is left in \fIinterp\fR's
result; it can be retrieved using \fBTcl_GetObjResult\fR.
.PP
\fBTcl_EvalFile\fR reads the file given by \fIfileName\fR and evaluates
its contents as a Tcl script.  It returns the same information as
\fBTcl_EvalObjEx\fR.
If the file could not be read then a Tcl error is returned to describe
why the file could not be read.
The eofchar for files is
.QW \e32
(^Z) for all platforms. If you require a
.QW ^Z
in code for string comparison, you can use
.QW \e032
or
.QW \eu001a ,
which will be safely substituted by the Tcl interpreter into
.QW ^Z .
.PP
\fBTcl_EvalObjv\fR executes a single pre-parsed command instead of a
script.  The \fIobjc\fR and \fIobjv\fR arguments contain the values
of the words for the Tcl command, one word in each object in
\fIobjv\fR.  \fBTcl_EvalObjv\fR evaluates the command and returns
a completion code and result just like \fBTcl_EvalObjEx\fR.
The caller of \fBTcl_EvalObjv\fR has to manage the reference count of the
elements of \fIobjv\fR, insuring that the objects are valid until
\fBTcl_EvalObjv\fR returns.  
.PP
\fBTcl_Eval\fR is similar to \fBTcl_EvalObjEx\fR except that the script to
be executed is supplied as a string instead of an object and no compilation
occurs.  The string should be a proper UTF-8 string as converted by
\fBTcl_ExternalToUtfDString\fR or \fBTcl_ExternalToUtf\fR when it is known
to possibly contain upper ASCII characters whose possible combinations
might be a UTF-8 special code.  The string is parsed and executed directly
(using \fBTcl_EvalObjv\fR) instead of compiling it and executing the
bytecodes.  In situations where it is known that the script will never be
executed again, \fBTcl_Eval\fR may be faster than \fBTcl_EvalObjEx\fR.
 \fBTcl_Eval\fR returns a completion code and result just like 
\fBTcl_EvalObjEx\fR.  Note: for backward compatibility with versions before
Tcl 8.0, \fBTcl_Eval\fR copies the object result in \fIinterp\fR to
\fIinterp->result\fR (use is deprecated) where it can be accessed directly.
 This makes \fBTcl_Eval\fR somewhat slower than \fBTcl_EvalEx\fR, which
does not do the copy.
.PP
\fBTcl_EvalEx\fR is an extended version of \fBTcl_Eval\fR that takes
additional arguments \fInumBytes\fR and \fIflags\fR.  For the
efficiency reason given above, \fBTcl_EvalEx\fR is generally preferred
over \fBTcl_Eval\fR.
.PP
\fBTcl_GlobalEval\fR and \fBTcl_GlobalEvalObj\fR are older procedures
that are now deprecated.  They are similar to \fBTcl_EvalEx\fR and
\fBTcl_EvalObjEx\fR except that the script is evaluated in the global
namespace and its variable context consists of global variables only
(it ignores any Tcl procedures that are active).  These functions are
equivalent to using the \fBTCL_EVAL_GLOBAL\fR flag (see below).
.PP
\fBTcl_VarEval\fR takes any number of string arguments
of any length, concatenates them into a single string,
then calls \fBTcl_Eval\fR to execute that string as a Tcl command.
It returns the result of the command and also modifies
\fIinterp->result\fR in the same way as \fBTcl_Eval\fR.
The last argument to \fBTcl_VarEval\fR must be NULL to indicate the end
of arguments.  \fBTcl_VarEval\fR is now deprecated.
.PP
\fBTcl_VarEvalVA\fR is the same as \fBTcl_VarEval\fR except that
instead of taking a variable number of arguments it takes an argument
list. Like \fBTcl_VarEval\fR, \fBTcl_VarEvalVA\fR is deprecated.

.SH "FLAG BITS"
Any ORed combination of the following values may be used for the
\fIflags\fR argument to procedures such as \fBTcl_EvalObjEx\fR:
.TP 23
\fBTCL_EVAL_DIRECT\fR
This flag is only used by \fBTcl_EvalObjEx\fR; it is ignored by
other procedures.  If this flag bit is set, the script is not
compiled to bytecodes; instead it is executed directly
as is done by \fBTcl_EvalEx\fR.  The
\fBTCL_EVAL_DIRECT\fR flag is useful in situations where the
contents of an object are going to change immediately, so the
bytecodes will not be reused in a future execution.  In this case,
it is faster to execute the script directly.
.TP 23
\fBTCL_EVAL_GLOBAL\fR
If this flag is set, the script is processed at global level.  This
means that it is evaluated in the global namespace and its variable
context consists of global variables only (it ignores any Tcl
procedures at are active).

.SH "MISCELLANEOUS DETAILS"
.PP
During the processing of a Tcl command it is legal to make nested
calls to evaluate other commands (this is how procedures and
some control structures are implemented).
If a code other than \fBTCL_OK\fR is returned
from a nested \fBTcl_EvalObjEx\fR invocation,
then the caller should normally return immediately,
passing that same return code back to its caller,
and so on until the top-level application is reached.
A few commands, like \fBfor\fR, will check for certain
return codes, like \fBTCL_BREAK\fR and \fBTCL_CONTINUE\fR, and process them
specially without returning.
.PP
\fBTcl_EvalObjEx\fR keeps track of how many nested \fBTcl_EvalObjEx\fR
invocations are in progress for \fIinterp\fR.
If a code of \fBTCL_RETURN\fR, \fBTCL_BREAK\fR, or \fBTCL_CONTINUE\fR is
about to be returned from the topmost \fBTcl_EvalObjEx\fR
invocation for \fIinterp\fR,
it converts the return code to \fBTCL_ERROR\fR
and sets \fIinterp\fR's result to an error message indicating that
the \fBreturn\fR, \fBbreak\fR, or \fBcontinue\fR command was
invoked in an inappropriate place.
This means that top-level applications should never see a return code
from \fBTcl_EvalObjEx\fR other then \fBTCL_OK\fR or \fBTCL_ERROR\fR.

.SH KEYWORDS
execute, file, global, object, result, script
                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_VarEvalVA.3tcl                           0100644 0001750 0001750 00000034556 12566232333 024052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\" Copyright (c) 2000 Scriptics Corporation.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Eval.3,v 1.27 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Eval 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_EvalObjEx, Tcl_EvalFile, Tcl_EvalObjv, Tcl_Eval, Tcl_EvalEx, Tcl_GlobalEval, Tcl_GlobalEvalObj, Tcl_VarEval, Tcl_VarEvalVA \- execute Tcl scripts
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_EvalObjEx\fR(\fIinterp, objPtr, flags\fR)
.sp
int
\fBTcl_EvalFile\fR(\fIinterp, fileName\fR)
.sp
int
\fBTcl_EvalObjv\fR(\fIinterp, objc, objv, flags\fR)
.sp
int
\fBTcl_Eval\fR(\fIinterp, script\fR)
.sp
int
\fBTcl_EvalEx\fR(\fIinterp, script, numBytes, flags\fR)
.sp
int
\fBTcl_GlobalEval\fR(\fIinterp, script\fR)
.sp
int
\fBTcl_GlobalEvalObj\fR(\fIinterp, objPtr\fR)
.sp
int
\fBTcl_VarEval\fR(\fIinterp, part, part, ... \fB(char *) NULL\fR)
.sp
int
\fBTcl_VarEvalVA\fR(\fIinterp, argList\fR)
.SH ARGUMENTS
.AS Tcl_Interp **termPtr
.AP Tcl_Interp *interp in
Interpreter in which to execute the script.  The interpreter's result is
modified to hold the result or error message from the script.
.AP Tcl_Obj *objPtr in
A Tcl object containing the script to execute.
.AP int flags in
ORed combination of flag bits that specify additional options.
\fBTCL_EVAL_GLOBAL\fR and \fBTCL_EVAL_DIRECT\fR are currently supported.
.AP "const char" *fileName in
Name of a file containing a Tcl script.
.AP int objc in
The number of objects in the array pointed to by \fIobjPtr\fR;
this is also the number of words in the command.
.AP Tcl_Obj **objv in
Points to an array of pointers to objects; each object holds the
value of a single word in the command to execute.
.AP int numBytes in
The number of bytes in \fIscript\fR, not including any
null terminating character.  If \-1, then all characters up to the
first null byte are used.
.AP "const char" *script in
Points to first byte of script to execute (null-terminated and UTF-8).
.AP char *part in
String forming part of a Tcl script.
.AP va_list argList in
An argument list which must have been initialized using
\fBva_start\fR, and cleared using \fBva_end\fR.
.BE

.SH DESCRIPTION
.PP
The procedures described here are invoked to execute Tcl scripts in
various forms.
\fBTcl_EvalObjEx\fR is the core procedure and is used by many of the others.
It executes the commands in the script stored in \fIobjPtr\fR
until either an error occurs or the end of the script is reached.
If this is the first time \fIobjPtr\fR has been executed,
its commands are compiled into bytecode instructions
which are then executed.  The
bytecodes are saved in \fIobjPtr\fR so that the compilation step
can be skipped if the object is evaluated again in the future.
.PP
The return value from \fBTcl_EvalObjEx\fR (and all the other procedures
described here) is a Tcl completion code with
one of the values \fBTCL_OK\fR, \fBTCL_ERROR\fR, \fBTCL_RETURN\fR,
\fBTCL_BREAK\fR, or \fBTCL_CONTINUE\fR, or possibly some other
integer value originating in an extension.
In addition, a result value or error message is left in \fIinterp\fR's
result; it can be retrieved using \fBTcl_GetObjResult\fR.
.PP
\fBTcl_EvalFile\fR reads the file given by \fIfileName\fR and evaluates
its contents as a Tcl script.  It returns the same information as
\fBTcl_EvalObjEx\fR.
If the file could not be read then a Tcl error is returned to describe
why the file could not be read.
The eofchar for files is
.QW \e32
(^Z) for all platforms. If you require a
.QW ^Z
in code for string comparison, you can use
.QW \e032
or
.QW \eu001a ,
which will be safely substituted by the Tcl interpreter into
.QW ^Z .
.PP
\fBTcl_EvalObjv\fR executes a single pre-parsed command instead of a
script.  The \fIobjc\fR and \fIobjv\fR arguments contain the values
of the words for the Tcl command, one word in each object in
\fIobjv\fR.  \fBTcl_EvalObjv\fR evaluates the command and returns
a completion code and result just like \fBTcl_EvalObjEx\fR.
The caller of \fBTcl_EvalObjv\fR has to manage the reference count of the
elements of \fIobjv\fR, insuring that the objects are valid until
\fBTcl_EvalObjv\fR returns.  
.PP
\fBTcl_Eval\fR is similar to \fBTcl_EvalObjEx\fR except that the script to
be executed is supplied as a string instead of an object and no compilation
occurs.  The string should be a proper UTF-8 string as converted by
\fBTcl_ExternalToUtfDString\fR or \fBTcl_ExternalToUtf\fR when it is known
to possibly contain upper ASCII characters whose possible combinations
might be a UTF-8 special code.  The string is parsed and executed directly
(using \fBTcl_EvalObjv\fR) instead of compiling it and executing the
bytecodes.  In situations where it is known that the script will never be
executed again, \fBTcl_Eval\fR may be faster than \fBTcl_EvalObjEx\fR.
 \fBTcl_Eval\fR returns a completion code and result just like 
\fBTcl_EvalObjEx\fR.  Note: for backward compatibility with versions before
Tcl 8.0, \fBTcl_Eval\fR copies the object result in \fIinterp\fR to
\fIinterp->result\fR (use is deprecated) where it can be accessed directly.
 This makes \fBTcl_Eval\fR somewhat slower than \fBTcl_EvalEx\fR, which
does not do the copy.
.PP
\fBTcl_EvalEx\fR is an extended version of \fBTcl_Eval\fR that takes
additional arguments \fInumBytes\fR and \fIflags\fR.  For the
efficiency reason given above, \fBTcl_EvalEx\fR is generally preferred
over \fBTcl_Eval\fR.
.PP
\fBTcl_GlobalEval\fR and \fBTcl_GlobalEvalObj\fR are older procedures
that are now deprecated.  They are similar to \fBTcl_EvalEx\fR and
\fBTcl_EvalObjEx\fR except that the script is evaluated in the global
namespace and its variable context consists of global variables only
(it ignores any Tcl procedures that are active).  These functions are
equivalent to using the \fBTCL_EVAL_GLOBAL\fR flag (see below).
.PP
\fBTcl_VarEval\fR takes any number of string arguments
of any length, concatenates them into a single string,
then calls \fBTcl_Eval\fR to execute that string as a Tcl command.
It returns the result of the command and also modifies
\fIinterp->result\fR in the same way as \fBTcl_Eval\fR.
The last argument to \fBTcl_VarEval\fR must be NULL to indicate the end
of arguments.  \fBTcl_VarEval\fR is now deprecated.
.PP
\fBTcl_VarEvalVA\fR is the same as \fBTcl_VarEval\fR except that
instead of taking a variable number of arguments it takes an argument
list. Like \fBTcl_VarEval\fR, \fBTcl_VarEvalVA\fR is deprecated.

.SH "FLAG BITS"
Any ORed combination of the following values may be used for the
\fIflags\fR argument to procedures such as \fBTcl_EvalObjEx\fR:
.TP 23
\fBTCL_EVAL_DIRECT\fR
This flag is only used by \fBTcl_EvalObjEx\fR; it is ignored by
other procedures.  If this flag bit is set, the script is not
compiled to bytecodes; instead it is executed directly
as is done by \fBTcl_EvalEx\fR.  The
\fBTCL_EVAL_DIRECT\fR flag is useful in situations where the
contents of an object are going to change immediately, so the
bytecodes will not be reused in a future execution.  In this case,
it is faster to execute the script directly.
.TP 23
\fBTCL_EVAL_GLOBAL\fR
If this flag is set, the script is processed at global level.  This
means that it is evaluated in the global namespace and its variable
context consists of global variables only (it ignores any Tcl
procedures at are active).

.SH "MISCELLANEOUS DETAILS"
.PP
During the processing of a Tcl command it is legal to make nested
calls to evaluate other commands (this is how procedures and
some control structures are implemented).
If a code other than \fBTCL_OK\fR is returned
from a nested \fBTcl_EvalObjEx\fR invocation,
then the caller should normally return immediately,
passing that same return code back to its caller,
and so on until the top-level application is reached.
A few commands, like \fBfor\fR, will check for certain
return codes, like \fBTCL_BREAK\fR and \fBTCL_CONTINUE\fR, and process them
specially without returning.
.PP
\fBTcl_EvalObjEx\fR keeps track of how many nested \fBTcl_EvalObjEx\fR
invocations are in progress for \fIinterp\fR.
If a code of \fBTCL_RETURN\fR, \fBTCL_BREAK\fR, or \fBTCL_CONTINUE\fR is
about to be returned from the topmost \fBTcl_EvalObjEx\fR
invocation for \fIinterp\fR,
it converts the return code to \fBTCL_ERROR\fR
and sets \fIinterp\fR's result to an error message indicating that
the \fBreturn\fR, \fBbreak\fR, or \fBcontinue\fR command was
invoked in an inappropriate place.
This means that top-level applications should never see a return code
from \fBTcl_EvalObjEx\fR other then \fBTCL_OK\fR or \fBTCL_ERROR\fR.

.SH KEYWORDS
execute, file, global, object, result, script
                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_VarTraceInfo.3tcl                        0100644 0001750 0001750 00000054365 12566232352 024607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: TraceVar.3,v 1.19 2007/12/13 15:22:32 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_TraceVar 3 7.4 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_TraceVar, Tcl_TraceVar2, Tcl_UntraceVar, Tcl_UntraceVar2, Tcl_VarTraceInfo, Tcl_VarTraceInfo2 \- monitor accesses to a variable
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_TraceVar(\fIinterp, varName, flags, proc, clientData\fB)\fR
.sp
int
\fBTcl_TraceVar2(\fIinterp, name1, name2, flags, proc, clientData\fB)\fR
.sp
\fBTcl_UntraceVar(\fIinterp, varName, flags, proc, clientData\fB)\fR
.sp
\fBTcl_UntraceVar2(\fIinterp, name1, name2, flags, proc, clientData\fB)\fR
.sp
ClientData
\fBTcl_VarTraceInfo(\fIinterp, varName, flags, proc, prevClientData\fB)\fR
.sp
ClientData
\fBTcl_VarTraceInfo2(\fIinterp, name1, name2, flags, proc, prevClientData\fB)\fR
.SH ARGUMENTS
.AS Tcl_VarTraceProc prevClientData
.AP Tcl_Interp *interp in
Interpreter containing variable.
.AP "const char" *varName in
Name of variable.  May refer to a scalar variable, to
an array variable with no index, or to an array variable
with a parenthesized index.
.AP int flags in
OR-ed combination of the values \fBTCL_TRACE_READS\fR,
\fBTCL_TRACE_WRITES\fR, \fBTCL_TRACE_UNSETS\fR, \fBTCL_TRACE_ARRAY\fR,
\fBTCL_GLOBAL_ONLY\fR, \fBTCL_NAMESPACE_ONLY\fR,
\fBTCL_TRACE_RESULT_DYNAMIC\fR and \fBTCL_TRACE_RESULT_OBJECT\fR.
Not all flags are used by all
procedures.  See below for more information.
.AP Tcl_VarTraceProc *proc in
Procedure to invoke whenever one of the traced operations occurs.
.AP ClientData clientData in
Arbitrary one-word value to pass to \fIproc\fR.
.AP "const char" *name1 in
Name of scalar or array variable (without array index).
.AP "const char" *name2 in
For a trace on an element of an array, gives the index of the
element.  For traces on scalar variables or on whole arrays,
is NULL.
.AP ClientData prevClientData in
If non-NULL, gives last value returned by \fBTcl_VarTraceInfo\fR or
\fBTcl_VarTraceInfo2\fR, so this call will return information about
next trace.  If NULL, this call will return information about first
trace.
.BE
.SH DESCRIPTION
.PP
\fBTcl_TraceVar\fR allows a C procedure to monitor and control
access to a Tcl variable, so that the C procedure is invoked
whenever the variable is read or written or unset.
If the trace is created successfully then \fBTcl_TraceVar\fR returns
\fBTCL_OK\fR.  If an error occurred (e.g. \fIvarName\fR specifies an element
of an array, but the actual variable is not an array) then \fBTCL_ERROR\fR
is returned and an error message is left in the interpreter's result.
.PP
The \fIflags\fR argument to \fBTcl_TraceVar\fR indicates when the
trace procedure is to be invoked and provides information
for setting up the trace.  It consists of an OR-ed combination
of any of the following values:
.TP
\fBTCL_GLOBAL_ONLY\fR
Normally, the variable will be looked up at the current level of
procedure call;  if this bit is set then the variable will be looked
up at global level, ignoring any active procedures.
.TP
\fBTCL_NAMESPACE_ONLY\fR
Normally, the variable will be looked up at the current level of
procedure call;  if this bit is set then the variable will be looked
up in the current namespace, ignoring any active procedures.
.TP
\fBTCL_TRACE_READS\fR
Invoke \fIproc\fR whenever an attempt is made to read the variable.
.TP
\fBTCL_TRACE_WRITES\fR
Invoke \fIproc\fR whenever an attempt is made to modify the variable.
.TP
\fBTCL_TRACE_UNSETS\fR
Invoke \fIproc\fR whenever the variable is unset.
A variable may be unset either explicitly by an \fBunset\fR command,
or implicitly when a procedure returns (its local variables are
automatically unset) or when the interpreter is deleted (all
variables are automatically unset).
.TP
\fBTCL_TRACE_ARRAY\fR
Invoke \fIproc\fR whenever the array command is invoked.
This gives the trace procedure a chance to update the array before
array names or array get is called.  Note that this is called
before an array set, but that will trigger write traces.
.TP
\fBTCL_TRACE_RESULT_DYNAMIC\fR
The result of invoking the \fIproc\fR is a dynamically allocated
string that will be released by the Tcl library via a call to
\fBckfree\fR.  Must not be specified at the same time as
\fBTCL_TRACE_RESULT_OBJECT\fR.
.TP
\fBTCL_TRACE_RESULT_OBJECT\fR
The result of invoking the \fIproc\fR is a Tcl_Obj* (cast to a char*)
with a reference count of at least one.  The ownership of that
reference will be transferred to the Tcl core for release (when the
core has finished with it) via a call to \fBTcl_DecrRefCount\fR.  Must
not be specified at the same time as \fBTCL_TRACE_RESULT_DYNAMIC\fR.
.PP
Whenever one of the specified operations occurs on the variable,
\fIproc\fR will be invoked.
It should have arguments and result that match the type
\fBTcl_VarTraceProc\fR:
.CS
typedef char *Tcl_VarTraceProc(
        ClientData \fIclientData\fR,
        Tcl_Interp *\fIinterp\fR,
        char *\fIname1\fR,
        char *\fIname2\fR,
        int \fIflags\fR);
.CE
The \fIclientData\fR and \fIinterp\fR parameters will
have the same values as those passed to \fBTcl_TraceVar\fR when the
trace was created.
\fIClientData\fR typically points to an application-specific
data structure that describes what to do when \fIproc\fR
is invoked.
\fIName1\fR and \fIname2\fR give the name of the traced variable
in the normal two-part form (see the description of \fBTcl_TraceVar2\fR
below for details).
\fIFlags\fR is an OR-ed combination of bits providing several
pieces of information.
One of the bits \fBTCL_TRACE_READS\fR, \fBTCL_TRACE_WRITES\fR,
\fBTCL_TRACE_ARRAY\fR, or \fBTCL_TRACE_UNSETS\fR
will be set in \fIflags\fR to indicate which operation is being performed
on the variable.
The bit \fBTCL_GLOBAL_ONLY\fR will be set whenever the variable being
accessed is a global one not accessible from the current level of
procedure call:  the trace procedure will need to pass this flag
back to variable-related procedures like \fBTcl_GetVar\fR if it
attempts to access the variable.
The bit \fBTCL_NAMESPACE_ONLY\fR will be set whenever the variable being
accessed is a namespace one not accessible from the current level of
procedure call:  the trace procedure will need to pass this flag
back to variable-related procedures like \fBTcl_GetVar\fR if it
attempts to access the variable.
The bit \fBTCL_TRACE_DESTROYED\fR will be set in \fIflags\fR if the trace is
about to be destroyed;  this information may be useful to \fIproc\fR
so that it can clean up its own internal data structures (see
the section \fBTCL_TRACE_DESTROYED\fR below for more details).
Lastly, the bit \fBTCL_INTERP_DESTROYED\fR will be set if the entire
interpreter is being destroyed.
When this bit is set, \fIproc\fR must be especially careful in
the things it does (see the section \fBTCL_INTERP_DESTROYED\fR below).
The trace procedure's return value should normally be NULL;  see
\fBERROR RETURNS\fR below for information on other possibilities.
.PP
\fBTcl_UntraceVar\fR may be used to remove a trace.
If the variable specified by \fIinterp\fR, \fIvarName\fR, and \fIflags\fR
has a trace set with \fIflags\fR, \fIproc\fR, and
\fIclientData\fR, then the corresponding trace is removed.
If no such trace exists, then the call to \fBTcl_UntraceVar\fR
has no effect.
The same bits are valid for \fIflags\fR as for calls to \fBTcl_TraceVar\fR.
.PP
\fBTcl_VarTraceInfo\fR may be used to retrieve information about
traces set on a given variable.
The return value from \fBTcl_VarTraceInfo\fR is the \fIclientData\fR
associated with a particular trace.
The trace must be on the variable specified by the \fIinterp\fR,
\fIvarName\fR, and \fIflags\fR arguments (only the \fBTCL_GLOBAL_ONLY\fR and
\fBTCL_NAMESPACE_ONLY\fR bits from \fIflags\fR is used;  other bits are
ignored) and its trace procedure must the same as the \fIproc\fR
argument.
If the \fIprevClientData\fR argument is NULL then the return
value corresponds to the first (most recently created) matching
trace, or NULL if there are no matching traces.
If the \fIprevClientData\fR argument is not NULL, then it should
be the return value from a previous call to \fBTcl_VarTraceInfo\fR.
In this case, the new return value will correspond to the next
matching trace after the one whose \fIclientData\fR matches
\fIprevClientData\fR, or NULL if no trace matches \fIprevClientData\fR
or if there are no more matching traces after it.
This mechanism makes it possible to step through all of the
traces for a given variable that have the same \fIproc\fR.
.SH "TWO-PART NAMES"
.PP
The procedures \fBTcl_TraceVar2\fR, \fBTcl_UntraceVar2\fR, and
\fBTcl_VarTraceInfo2\fR are identical to \fBTcl_TraceVar\fR,
\fBTcl_UntraceVar\fR, and \fBTcl_VarTraceInfo\fR, respectively,
except that the name of the variable consists of two parts.
\fIName1\fR gives the name of a scalar variable or array,
and \fIname2\fR gives the name of an element within an array.
When \fIname2\fR is NULL, 
\fIname1\fR may contain both an array and an element name:
if the name contains an open parenthesis and ends with a
close parenthesis, then the value between the parentheses is
treated as an element name (which can have any string value) and
the characters before the first open
parenthesis are treated as the name of an array variable.
If \fIname2\fR is NULL and \fIname1\fR does not refer
to an array element it means that either the variable is
a scalar or the trace is to be set on the entire array rather
than an individual element (see WHOLE-ARRAY TRACES below for
more information). 
.SH "ACCESSING VARIABLES DURING TRACES"
.PP
During read, write, and array traces, the
trace procedure can read, write, or unset the traced
variable using \fBTcl_GetVar2\fR, \fBTcl_SetVar2\fR, and
other procedures.
While \fIproc\fR is executing, traces are temporarily disabled
for the variable, so that calls to \fBTcl_GetVar2\fR and
\fBTcl_SetVar2\fR will not cause \fIproc\fR or other trace procedures
to be invoked again.
Disabling only occurs for the variable whose trace procedure
is active;  accesses to other variables will still be traced.
However, if a variable is unset during a read or write trace then unset
traces will be invoked.
.PP
During unset traces the variable has already been completely
expunged.
It is possible for the trace procedure to read or write the
variable, but this will be a new version of the variable.
Traces are not disabled during unset traces as they are for
read and write traces, but existing traces have been removed
from the variable before any trace procedures are invoked.
If new traces are set by unset trace procedures, these traces
will be invoked on accesses to the variable by the trace
procedures.
.SH "CALLBACK TIMING"
.PP
When read tracing has been specified for a variable, the trace
procedure will be invoked whenever the variable's value is
read.  This includes \fBset\fR Tcl commands, \fB$\fR-notation
in Tcl commands, and invocations of the \fBTcl_GetVar\fR
and \fBTcl_GetVar2\fR procedures.
\fIProc\fR is invoked just before the variable's value is
returned.
It may modify the value of the variable to affect what
is returned by the traced access.
If it unsets the variable then the access will return an error
just as if the variable never existed.
.PP
When write tracing has been specified for a variable, the
trace procedure will be invoked whenever the variable's value
is modified.  This includes \fBset\fR commands,
commands that modify variables as side effects (such as
\fBcatch\fR and \fBscan\fR), and calls to the \fBTcl_SetVar\fR
and \fBTcl_SetVar2\fR procedures).
\fIProc\fR will be invoked after the variable's value has been
modified, but before the new value of the variable has been
returned.
It may modify the value of the variable to override the change
and to determine the value actually returned by the traced
access.
If it deletes the variable then the traced access will return
an empty string.
.PP
When array tracing has been specified, the trace procedure
will be invoked at the beginning of the array command implementation,
before any of the operations like get, set, or names have been invoked.
The trace procedure can modify the array elements with \fBTcl_SetVar\fR
and \fBTcl_SetVar2\fR.
.PP
When unset tracing has been specified, the trace procedure
will be invoked whenever the variable is destroyed.
The traces will be called after the variable has been
completely unset.
.SH "WHOLE-ARRAY TRACES"
.PP
If a call to \fBTcl_TraceVar\fR or \fBTcl_TraceVar2\fR specifies
the name of an array variable without an index into the array,
then the trace will be set on the array as a whole.
This means that \fIproc\fR will be invoked whenever any
element of the array is accessed in the ways specified by
\fIflags\fR.
When an array is unset, a whole-array trace will be invoked
just once, with \fIname1\fR equal to the name of the array
and \fIname2\fR NULL;  it will not be invoked once for each
element.
.SH "MULTIPLE TRACES"
.PP
It is possible for multiple traces to exist on the same variable.
When this happens, all of the trace procedures will be invoked on each
access, in order from most-recently-created to least-recently-created.
When there exist whole-array traces for an array as well as
traces on individual elements, the whole-array traces are invoked
before the individual-element traces.
If a read or write trace unsets the variable then all of the unset
traces will be invoked but the remainder of the read and write traces
will be skipped.
.SH "ERROR RETURNS"
.PP
Under normal conditions trace procedures should return NULL, indicating
successful completion.
If \fIproc\fR returns a non-NULL value it signifies that an
error occurred.
The return value must be a pointer to a static character string
containing an error message,
unless (\fIexactly\fR one of) the \fBTCL_TRACE_RESULT_DYNAMIC\fR and
\fBTCL_TRACE_RESULT_OBJECT\fR flags is set, which specify that the result is
either a dynamic string (to be released with \fBckfree\fR) or a
Tcl_Obj* (cast to char* and to be released with
\fBTcl_DecrRefCount\fR) containing the error message.
If a trace procedure returns an error, no further traces are
invoked for the access and the traced access aborts with the
given message.
Trace procedures can use this facility to make variables
read-only, for example (but note that the value of the variable
will already have been modified before the trace procedure is
called, so the trace procedure will have to restore the correct
value).
.PP
The return value from \fIproc\fR is only used during read and
write tracing.
During unset traces, the return value is ignored and all relevant
trace procedures will always be invoked.
.SH "RESTRICTIONS"
.PP
A trace procedure can be called at any time, even when there
is a partially formed result in the interpreter's result area.  If
the trace procedure does anything that could damage this result (such
as calling \fBTcl_Eval\fR) then it must save the original values of
the interpreter's \fBresult\fR and \fBfreeProc\fR fields and restore
them before it returns.
.SH "UNDEFINED VARIABLES"
.PP
It is legal to set a trace on an undefined variable.
The variable will still appear to be undefined until the
first time its value is set.
If an undefined variable is traced and then unset, the unset will fail
with an error
.PQ "no such variable" "" ,
but the trace procedure will still be invoked.
.SH "TCL_TRACE_DESTROYED FLAG"
.PP
In an unset callback to \fIproc\fR, the \fBTCL_TRACE_DESTROYED\fR bit
is set in \fIflags\fR if the trace is being removed as part
of the deletion.
Traces on a variable are always removed whenever the variable
is deleted;  the only time \fBTCL_TRACE_DESTROYED\fR is not set is for
a whole-array trace invoked when only a single element of an
array is unset.
.SH "TCL_INTERP_DESTROYED"
.PP
When an interpreter is destroyed, unset traces are called for
all of its variables.
The \fBTCL_INTERP_DESTROYED\fR bit will be set in the \fIflags\fR
argument passed to the trace procedures.
Trace procedures must be extremely careful in what they do if
the \fBTCL_INTERP_DESTROYED\fR bit is set.
It is not safe for the procedures to invoke any Tcl procedures
on the interpreter, since its state is partially deleted.
All that trace procedures should do under these circumstances is
to clean up and free their own internal data structures.
.SH BUGS
.PP
Tcl does not do any error checking to prevent trace procedures
from misusing the interpreter during traces with \fBTCL_INTERP_DESTROYED\fR
set.
.PP
Array traces are not yet integrated with the Tcl \fBinfo exists\fR command,
nor is there Tcl-level access to array traces.
.SH KEYWORDS
clientData, trace, variable
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_VarTraceInfo2.3tcl                       0100644 0001750 0001750 00000054365 12566232352 024671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: TraceVar.3,v 1.19 2007/12/13 15:22:32 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_TraceVar 3 7.4 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_TraceVar, Tcl_TraceVar2, Tcl_UntraceVar, Tcl_UntraceVar2, Tcl_VarTraceInfo, Tcl_VarTraceInfo2 \- monitor accesses to a variable
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_TraceVar(\fIinterp, varName, flags, proc, clientData\fB)\fR
.sp
int
\fBTcl_TraceVar2(\fIinterp, name1, name2, flags, proc, clientData\fB)\fR
.sp
\fBTcl_UntraceVar(\fIinterp, varName, flags, proc, clientData\fB)\fR
.sp
\fBTcl_UntraceVar2(\fIinterp, name1, name2, flags, proc, clientData\fB)\fR
.sp
ClientData
\fBTcl_VarTraceInfo(\fIinterp, varName, flags, proc, prevClientData\fB)\fR
.sp
ClientData
\fBTcl_VarTraceInfo2(\fIinterp, name1, name2, flags, proc, prevClientData\fB)\fR
.SH ARGUMENTS
.AS Tcl_VarTraceProc prevClientData
.AP Tcl_Interp *interp in
Interpreter containing variable.
.AP "const char" *varName in
Name of variable.  May refer to a scalar variable, to
an array variable with no index, or to an array variable
with a parenthesized index.
.AP int flags in
OR-ed combination of the values \fBTCL_TRACE_READS\fR,
\fBTCL_TRACE_WRITES\fR, \fBTCL_TRACE_UNSETS\fR, \fBTCL_TRACE_ARRAY\fR,
\fBTCL_GLOBAL_ONLY\fR, \fBTCL_NAMESPACE_ONLY\fR,
\fBTCL_TRACE_RESULT_DYNAMIC\fR and \fBTCL_TRACE_RESULT_OBJECT\fR.
Not all flags are used by all
procedures.  See below for more information.
.AP Tcl_VarTraceProc *proc in
Procedure to invoke whenever one of the traced operations occurs.
.AP ClientData clientData in
Arbitrary one-word value to pass to \fIproc\fR.
.AP "const char" *name1 in
Name of scalar or array variable (without array index).
.AP "const char" *name2 in
For a trace on an element of an array, gives the index of the
element.  For traces on scalar variables or on whole arrays,
is NULL.
.AP ClientData prevClientData in
If non-NULL, gives last value returned by \fBTcl_VarTraceInfo\fR or
\fBTcl_VarTraceInfo2\fR, so this call will return information about
next trace.  If NULL, this call will return information about first
trace.
.BE
.SH DESCRIPTION
.PP
\fBTcl_TraceVar\fR allows a C procedure to monitor and control
access to a Tcl variable, so that the C procedure is invoked
whenever the variable is read or written or unset.
If the trace is created successfully then \fBTcl_TraceVar\fR returns
\fBTCL_OK\fR.  If an error occurred (e.g. \fIvarName\fR specifies an element
of an array, but the actual variable is not an array) then \fBTCL_ERROR\fR
is returned and an error message is left in the interpreter's result.
.PP
The \fIflags\fR argument to \fBTcl_TraceVar\fR indicates when the
trace procedure is to be invoked and provides information
for setting up the trace.  It consists of an OR-ed combination
of any of the following values:
.TP
\fBTCL_GLOBAL_ONLY\fR
Normally, the variable will be looked up at the current level of
procedure call;  if this bit is set then the variable will be looked
up at global level, ignoring any active procedures.
.TP
\fBTCL_NAMESPACE_ONLY\fR
Normally, the variable will be looked up at the current level of
procedure call;  if this bit is set then the variable will be looked
up in the current namespace, ignoring any active procedures.
.TP
\fBTCL_TRACE_READS\fR
Invoke \fIproc\fR whenever an attempt is made to read the variable.
.TP
\fBTCL_TRACE_WRITES\fR
Invoke \fIproc\fR whenever an attempt is made to modify the variable.
.TP
\fBTCL_TRACE_UNSETS\fR
Invoke \fIproc\fR whenever the variable is unset.
A variable may be unset either explicitly by an \fBunset\fR command,
or implicitly when a procedure returns (its local variables are
automatically unset) or when the interpreter is deleted (all
variables are automatically unset).
.TP
\fBTCL_TRACE_ARRAY\fR
Invoke \fIproc\fR whenever the array command is invoked.
This gives the trace procedure a chance to update the array before
array names or array get is called.  Note that this is called
before an array set, but that will trigger write traces.
.TP
\fBTCL_TRACE_RESULT_DYNAMIC\fR
The result of invoking the \fIproc\fR is a dynamically allocated
string that will be released by the Tcl library via a call to
\fBckfree\fR.  Must not be specified at the same time as
\fBTCL_TRACE_RESULT_OBJECT\fR.
.TP
\fBTCL_TRACE_RESULT_OBJECT\fR
The result of invoking the \fIproc\fR is a Tcl_Obj* (cast to a char*)
with a reference count of at least one.  The ownership of that
reference will be transferred to the Tcl core for release (when the
core has finished with it) via a call to \fBTcl_DecrRefCount\fR.  Must
not be specified at the same time as \fBTCL_TRACE_RESULT_DYNAMIC\fR.
.PP
Whenever one of the specified operations occurs on the variable,
\fIproc\fR will be invoked.
It should have arguments and result that match the type
\fBTcl_VarTraceProc\fR:
.CS
typedef char *Tcl_VarTraceProc(
        ClientData \fIclientData\fR,
        Tcl_Interp *\fIinterp\fR,
        char *\fIname1\fR,
        char *\fIname2\fR,
        int \fIflags\fR);
.CE
The \fIclientData\fR and \fIinterp\fR parameters will
have the same values as those passed to \fBTcl_TraceVar\fR when the
trace was created.
\fIClientData\fR typically points to an application-specific
data structure that describes what to do when \fIproc\fR
is invoked.
\fIName1\fR and \fIname2\fR give the name of the traced variable
in the normal two-part form (see the description of \fBTcl_TraceVar2\fR
below for details).
\fIFlags\fR is an OR-ed combination of bits providing several
pieces of information.
One of the bits \fBTCL_TRACE_READS\fR, \fBTCL_TRACE_WRITES\fR,
\fBTCL_TRACE_ARRAY\fR, or \fBTCL_TRACE_UNSETS\fR
will be set in \fIflags\fR to indicate which operation is being performed
on the variable.
The bit \fBTCL_GLOBAL_ONLY\fR will be set whenever the variable being
accessed is a global one not accessible from the current level of
procedure call:  the trace procedure will need to pass this flag
back to variable-related procedures like \fBTcl_GetVar\fR if it
attempts to access the variable.
The bit \fBTCL_NAMESPACE_ONLY\fR will be set whenever the variable being
accessed is a namespace one not accessible from the current level of
procedure call:  the trace procedure will need to pass this flag
back to variable-related procedures like \fBTcl_GetVar\fR if it
attempts to access the variable.
The bit \fBTCL_TRACE_DESTROYED\fR will be set in \fIflags\fR if the trace is
about to be destroyed;  this information may be useful to \fIproc\fR
so that it can clean up its own internal data structures (see
the section \fBTCL_TRACE_DESTROYED\fR below for more details).
Lastly, the bit \fBTCL_INTERP_DESTROYED\fR will be set if the entire
interpreter is being destroyed.
When this bit is set, \fIproc\fR must be especially careful in
the things it does (see the section \fBTCL_INTERP_DESTROYED\fR below).
The trace procedure's return value should normally be NULL;  see
\fBERROR RETURNS\fR below for information on other possibilities.
.PP
\fBTcl_UntraceVar\fR may be used to remove a trace.
If the variable specified by \fIinterp\fR, \fIvarName\fR, and \fIflags\fR
has a trace set with \fIflags\fR, \fIproc\fR, and
\fIclientData\fR, then the corresponding trace is removed.
If no such trace exists, then the call to \fBTcl_UntraceVar\fR
has no effect.
The same bits are valid for \fIflags\fR as for calls to \fBTcl_TraceVar\fR.
.PP
\fBTcl_VarTraceInfo\fR may be used to retrieve information about
traces set on a given variable.
The return value from \fBTcl_VarTraceInfo\fR is the \fIclientData\fR
associated with a particular trace.
The trace must be on the variable specified by the \fIinterp\fR,
\fIvarName\fR, and \fIflags\fR arguments (only the \fBTCL_GLOBAL_ONLY\fR and
\fBTCL_NAMESPACE_ONLY\fR bits from \fIflags\fR is used;  other bits are
ignored) and its trace procedure must the same as the \fIproc\fR
argument.
If the \fIprevClientData\fR argument is NULL then the return
value corresponds to the first (most recently created) matching
trace, or NULL if there are no matching traces.
If the \fIprevClientData\fR argument is not NULL, then it should
be the return value from a previous call to \fBTcl_VarTraceInfo\fR.
In this case, the new return value will correspond to the next
matching trace after the one whose \fIclientData\fR matches
\fIprevClientData\fR, or NULL if no trace matches \fIprevClientData\fR
or if there are no more matching traces after it.
This mechanism makes it possible to step through all of the
traces for a given variable that have the same \fIproc\fR.
.SH "TWO-PART NAMES"
.PP
The procedures \fBTcl_TraceVar2\fR, \fBTcl_UntraceVar2\fR, and
\fBTcl_VarTraceInfo2\fR are identical to \fBTcl_TraceVar\fR,
\fBTcl_UntraceVar\fR, and \fBTcl_VarTraceInfo\fR, respectively,
except that the name of the variable consists of two parts.
\fIName1\fR gives the name of a scalar variable or array,
and \fIname2\fR gives the name of an element within an array.
When \fIname2\fR is NULL, 
\fIname1\fR may contain both an array and an element name:
if the name contains an open parenthesis and ends with a
close parenthesis, then the value between the parentheses is
treated as an element name (which can have any string value) and
the characters before the first open
parenthesis are treated as the name of an array variable.
If \fIname2\fR is NULL and \fIname1\fR does not refer
to an array element it means that either the variable is
a scalar or the trace is to be set on the entire array rather
than an individual element (see WHOLE-ARRAY TRACES below for
more information). 
.SH "ACCESSING VARIABLES DURING TRACES"
.PP
During read, write, and array traces, the
trace procedure can read, write, or unset the traced
variable using \fBTcl_GetVar2\fR, \fBTcl_SetVar2\fR, and
other procedures.
While \fIproc\fR is executing, traces are temporarily disabled
for the variable, so that calls to \fBTcl_GetVar2\fR and
\fBTcl_SetVar2\fR will not cause \fIproc\fR or other trace procedures
to be invoked again.
Disabling only occurs for the variable whose trace procedure
is active;  accesses to other variables will still be traced.
However, if a variable is unset during a read or write trace then unset
traces will be invoked.
.PP
During unset traces the variable has already been completely
expunged.
It is possible for the trace procedure to read or write the
variable, but this will be a new version of the variable.
Traces are not disabled during unset traces as they are for
read and write traces, but existing traces have been removed
from the variable before any trace procedures are invoked.
If new traces are set by unset trace procedures, these traces
will be invoked on accesses to the variable by the trace
procedures.
.SH "CALLBACK TIMING"
.PP
When read tracing has been specified for a variable, the trace
procedure will be invoked whenever the variable's value is
read.  This includes \fBset\fR Tcl commands, \fB$\fR-notation
in Tcl commands, and invocations of the \fBTcl_GetVar\fR
and \fBTcl_GetVar2\fR procedures.
\fIProc\fR is invoked just before the variable's value is
returned.
It may modify the value of the variable to affect what
is returned by the traced access.
If it unsets the variable then the access will return an error
just as if the variable never existed.
.PP
When write tracing has been specified for a variable, the
trace procedure will be invoked whenever the variable's value
is modified.  This includes \fBset\fR commands,
commands that modify variables as side effects (such as
\fBcatch\fR and \fBscan\fR), and calls to the \fBTcl_SetVar\fR
and \fBTcl_SetVar2\fR procedures).
\fIProc\fR will be invoked after the variable's value has been
modified, but before the new value of the variable has been
returned.
It may modify the value of the variable to override the change
and to determine the value actually returned by the traced
access.
If it deletes the variable then the traced access will return
an empty string.
.PP
When array tracing has been specified, the trace procedure
will be invoked at the beginning of the array command implementation,
before any of the operations like get, set, or names have been invoked.
The trace procedure can modify the array elements with \fBTcl_SetVar\fR
and \fBTcl_SetVar2\fR.
.PP
When unset tracing has been specified, the trace procedure
will be invoked whenever the variable is destroyed.
The traces will be called after the variable has been
completely unset.
.SH "WHOLE-ARRAY TRACES"
.PP
If a call to \fBTcl_TraceVar\fR or \fBTcl_TraceVar2\fR specifies
the name of an array variable without an index into the array,
then the trace will be set on the array as a whole.
This means that \fIproc\fR will be invoked whenever any
element of the array is accessed in the ways specified by
\fIflags\fR.
When an array is unset, a whole-array trace will be invoked
just once, with \fIname1\fR equal to the name of the array
and \fIname2\fR NULL;  it will not be invoked once for each
element.
.SH "MULTIPLE TRACES"
.PP
It is possible for multiple traces to exist on the same variable.
When this happens, all of the trace procedures will be invoked on each
access, in order from most-recently-created to least-recently-created.
When there exist whole-array traces for an array as well as
traces on individual elements, the whole-array traces are invoked
before the individual-element traces.
If a read or write trace unsets the variable then all of the unset
traces will be invoked but the remainder of the read and write traces
will be skipped.
.SH "ERROR RETURNS"
.PP
Under normal conditions trace procedures should return NULL, indicating
successful completion.
If \fIproc\fR returns a non-NULL value it signifies that an
error occurred.
The return value must be a pointer to a static character string
containing an error message,
unless (\fIexactly\fR one of) the \fBTCL_TRACE_RESULT_DYNAMIC\fR and
\fBTCL_TRACE_RESULT_OBJECT\fR flags is set, which specify that the result is
either a dynamic string (to be released with \fBckfree\fR) or a
Tcl_Obj* (cast to char* and to be released with
\fBTcl_DecrRefCount\fR) containing the error message.
If a trace procedure returns an error, no further traces are
invoked for the access and the traced access aborts with the
given message.
Trace procedures can use this facility to make variables
read-only, for example (but note that the value of the variable
will already have been modified before the trace procedure is
called, so the trace procedure will have to restore the correct
value).
.PP
The return value from \fIproc\fR is only used during read and
write tracing.
During unset traces, the return value is ignored and all relevant
trace procedures will always be invoked.
.SH "RESTRICTIONS"
.PP
A trace procedure can be called at any time, even when there
is a partially formed result in the interpreter's result area.  If
the trace procedure does anything that could damage this result (such
as calling \fBTcl_Eval\fR) then it must save the original values of
the interpreter's \fBresult\fR and \fBfreeProc\fR fields and restore
them before it returns.
.SH "UNDEFINED VARIABLES"
.PP
It is legal to set a trace on an undefined variable.
The variable will still appear to be undefined until the
first time its value is set.
If an undefined variable is traced and then unset, the unset will fail
with an error
.PQ "no such variable" "" ,
but the trace procedure will still be invoked.
.SH "TCL_TRACE_DESTROYED FLAG"
.PP
In an unset callback to \fIproc\fR, the \fBTCL_TRACE_DESTROYED\fR bit
is set in \fIflags\fR if the trace is being removed as part
of the deletion.
Traces on a variable are always removed whenever the variable
is deleted;  the only time \fBTCL_TRACE_DESTROYED\fR is not set is for
a whole-array trace invoked when only a single element of an
array is unset.
.SH "TCL_INTERP_DESTROYED"
.PP
When an interpreter is destroyed, unset traces are called for
all of its variables.
The \fBTCL_INTERP_DESTROYED\fR bit will be set in the \fIflags\fR
argument passed to the trace procedures.
Trace procedures must be extremely careful in what they do if
the \fBTCL_INTERP_DESTROYED\fR bit is set.
It is not safe for the procedures to invoke any Tcl procedures
on the interpreter, since its state is partially deleted.
All that trace procedures should do under these circumstances is
to clean up and free their own internal data structures.
.SH BUGS
.PP
Tcl does not do any error checking to prevent trace procedures
from misusing the interpreter during traces with \fBTCL_INTERP_DESTROYED\fR
set.
.PP
Array traces are not yet integrated with the Tcl \fBinfo exists\fR command,
nor is there Tcl-level access to array traces.
.SH KEYWORDS
clientData, trace, variable
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WaitForEvent.3tcl                        0100644 0001750 0001750 00000105436 12566232341 024633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1998-1999 Scriptics Corporation
'\" Copyright (c) 1995-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Notifier.3,v 1.21 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Notifier 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_CreateEventSource, Tcl_DeleteEventSource, Tcl_SetMaxBlockTime, Tcl_QueueEvent, Tcl_ThreadQueueEvent, Tcl_ThreadAlert, Tcl_GetCurrentThread, Tcl_DeleteEvents, Tcl_InitNotifier, Tcl_FinalizeNotifier, Tcl_WaitForEvent, Tcl_AlertNotifier, Tcl_SetTimer, Tcl_ServiceAll, Tcl_ServiceEvent, Tcl_GetServiceMode, Tcl_SetServiceMode \- the event queue and notifier interfaces
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
void
\fBTcl_CreateEventSource\fR(\fIsetupProc, checkProc, clientData\fR)
.sp
void
\fBTcl_DeleteEventSource\fR(\fIsetupProc, checkProc, clientData\fR)
.sp
void
\fBTcl_SetMaxBlockTime\fR(\fItimePtr\fR)
.sp
void
\fBTcl_QueueEvent\fR(\fIevPtr, position\fR)
.sp
void
\fBTcl_ThreadQueueEvent\fR(\fIthreadId, evPtr, position\fR)
.sp
void
\fBTcl_ThreadAlert\fR(\fIthreadId\fR)
.sp
Tcl_ThreadId
\fBTcl_GetCurrentThread\fR()
.sp
void
\fBTcl_DeleteEvents\fR(\fIdeleteProc, clientData\fR)
.sp
ClientData
\fBTcl_InitNotifier\fR()
.sp
void
\fBTcl_FinalizeNotifier\fR(\fIclientData\fR)
.sp
int
\fBTcl_WaitForEvent\fR(\fItimePtr\fR)
.sp
void
\fBTcl_AlertNotifier\fR(\fIclientData\fR)
.sp
void
\fBTcl_SetTimer\fR(\fItimePtr\fR)
.sp
int
\fBTcl_ServiceAll\fR()
.sp
int
\fBTcl_ServiceEvent\fR(\fIflags\fR)
.sp
int
\fBTcl_GetServiceMode\fR()
.sp
int
\fBTcl_SetServiceMode\fR(\fImode\fR)
.sp
void
\fBTcl_ServiceModeHook\fR(\fImode\fR)
.sp
void
\fBTcl_SetNotifier\fR(\fInotifierProcPtr\fR)
.SH ARGUMENTS
.AS Tcl_EventDeleteProc *notifierProcPtr
.AP Tcl_EventSetupProc *setupProc in
Procedure to invoke to prepare for event wait in \fBTcl_DoOneEvent\fR.
.AP Tcl_EventCheckProc *checkProc in
Procedure for \fBTcl_DoOneEvent\fR to invoke after waiting for
events.  Checks to see if any events have occurred and, if so,
queues them.
.AP ClientData clientData in
Arbitrary one-word value to pass to \fIsetupProc\fR, \fIcheckProc\fR, or
\fIdeleteProc\fR.
.AP Tcl_Time *timePtr in
Indicates the maximum amount of time to wait for an event.  This
is specified as an interval (how long to wait), not an absolute
time (when to wakeup).  If the pointer passed to \fBTcl_WaitForEvent\fR
is NULL, it means there is no maximum wait time:  wait forever if
necessary.
.AP Tcl_Event *evPtr in
An event to add to the event queue.  The storage for the event must
have been allocated by the caller using \fBTcl_Alloc\fR or \fBckalloc\fR.
.AP Tcl_QueuePosition position in
Where to add the new event in the queue:  \fBTCL_QUEUE_TAIL\fR,
\fBTCL_QUEUE_HEAD\fR, or \fBTCL_QUEUE_MARK\fR.
.AP Tcl_ThreadId threadId in
A unique identifier for a thread.
.AP Tcl_EventDeleteProc *deleteProc in
Procedure to invoke for each queued event in \fBTcl_DeleteEvents\fR.
.AP int flags in
What types of events to service.  These flags are the same as those
passed to \fBTcl_DoOneEvent\fR.
.AP int mode in
Indicates whether events should be serviced by \fBTcl_ServiceAll\fR.
Must be one of \fBTCL_SERVICE_NONE\fR or \fBTCL_SERVICE_ALL\fR.
.AP Tcl_NotifierProcs* notifierProcPtr in
Structure of function pointers describing notifier procedures that are
to replace the ones installed in the executable.  See
\fBREPLACING THE NOTIFIER\fR for details.
.BE

.SH INTRODUCTION
.PP
The interfaces described here are used to customize the Tcl event
loop.  The two most common customizations are to add new sources of
events and to merge Tcl's event loop with some other event loop, such
as one provided by an application in which Tcl is embedded.  Each of
these tasks is described in a separate section below.
.PP
The procedures in this manual entry are the building blocks out of which
the Tcl event notifier is constructed.  The event notifier is the lowest
layer in the Tcl event mechanism.  It consists of three things:
.IP [1]
Event sources: these represent the ways in which events can be
generated.  For example, there is a timer event source that implements
the \fBTcl_CreateTimerHandler\fR procedure and the \fBafter\fR
command, and there is a file event source that implements the
\fBTcl_CreateFileHandler\fR procedure on Unix systems.  An event
source must work with the notifier to detect events at the right
times, record them on the event queue, and eventually notify
higher-level software that they have occurred.  The procedures
\fBTcl_CreateEventSource\fR, \fBTcl_DeleteEventSource\fR,
and \fBTcl_SetMaxBlockTime\fR, \fBTcl_QueueEvent\fR, and
\fBTcl_DeleteEvents\fR are used primarily by event sources.
.IP [2]
The event queue: for non-threaded applications,
there is a single queue for the whole application,
containing events that have been detected but not yet serviced.  Event
sources place events onto the queue so that they may be processed in
order at appropriate times during the event loop. The event queue
guarantees a fair discipline of event handling, so that no event
source can starve the others.  It also allows events to be saved for
servicing at a future time.  Threaded applications work in a
similar manner, except that there is a separate event queue for
each thread containing a Tcl interpreter.
\fBTcl_QueueEvent\fR is used (primarily
by event sources) to add events to the event queue and 
\fBTcl_DeleteEvents\fR is used to remove events from the queue without
processing them.  In a threaded application, \fBTcl_QueueEvent\fR adds
an event to the current thread's queue, and \fBTcl_ThreadQueueEvent\fR
adds an event to a queue in a specific thread.
.IP [3]
The event loop: in order to detect and process events, the application
enters a loop that waits for events to occur, places them on the event
queue, and then processes them.  Most applications will do this by
calling the procedure \fBTcl_DoOneEvent\fR, which is described in a
separate manual entry.
.PP
Most Tcl applications need not worry about any of the internals of
the Tcl notifier.  However, the notifier now has enough flexibility
to be retargeted either for a new platform or to use an external event
loop (such as the Motif event loop, when Tcl is embedded in a Motif
application).  The procedures \fBTcl_WaitForEvent\fR and
\fBTcl_SetTimer\fR are normally implemented by Tcl, but may be
replaced with new versions to retarget the notifier (the
\fBTcl_InitNotifier\fR, \fBTcl_AlertNotifier\fR,
\fBTcl_FinalizeNotifier\fR, \fBTcl_Sleep\fR,
\fBTcl_CreateFileHandler\fR, and \fBTcl_DeleteFileHandler\fR must
also be replaced; see CREATING A NEW NOTIFIER below for details).
The procedures \fBTcl_ServiceAll\fR, \fBTcl_ServiceEvent\fR,
\fBTcl_GetServiceMode\fR, and \fBTcl_SetServiceMode\fR are provided
to help connect Tcl's event loop to an external event loop such as
Motif's.
.SH "NOTIFIER BASICS"
.PP
The easiest way to understand how the notifier works is to consider
what happens when \fBTcl_DoOneEvent\fR is called.
\fBTcl_DoOneEvent\fR is passed a \fIflags\fR argument that indicates
what sort of events it is OK to process and also whether or not to
block if no events are ready.  \fBTcl_DoOneEvent\fR does the following
things:
.IP [1]
Check the event queue to see if it contains any events that can
be serviced.  If so, service the first possible event, remove it
from the queue, and return.  It does this by calling
\fBTcl_ServiceEvent\fR and passing in the \fIflags\fR argument.
.IP [2]
Prepare to block for an event.  To do this, \fBTcl_DoOneEvent\fR
invokes a \fIsetup procedure\fR in each event source.
The event source will perform event-source specific initialization and
possibly call \fBTcl_SetMaxBlockTime\fR to limit how long
\fBTcl_WaitForEvent\fR will block if no new events occur.
.IP [3]
Call \fBTcl_WaitForEvent\fR.  This procedure is implemented differently
on different platforms;  it waits for an event to occur, based on the
information provided by the event sources.
It may cause the application to block if \fItimePtr\fR specifies
an interval other than 0.
\fBTcl_WaitForEvent\fR returns when something has happened,
such as a file becoming readable or the interval given by \fItimePtr\fR
expiring.  If there are no events for \fBTcl_WaitForEvent\fR to
wait for, so that it would block forever, then it returns immediately
and \fBTcl_DoOneEvent\fR returns 0.
.IP [4]
Call a \fIcheck procedure\fR in each event source.  The check
procedure determines whether any events of interest to this source
occurred.  If so, the events are added to the event queue.
.IP [5]
Check the event queue to see if it contains any events that can
be serviced.  If so, service the first possible event, remove it
from the queue, and return.
.IP [6]
See if there are idle callbacks pending. If so, invoke all of them and
return.
.IP [7]
Either return 0 to indicate that no events were ready, or go back to
step [2] if blocking was requested by the caller.

.SH "CREATING A NEW EVENT SOURCE"
.PP
An event source consists of three procedures invoked by the notifier,
plus additional C procedures that are invoked by higher-level code
to arrange for event-driven callbacks.  The three procedures called
by the notifier consist of the setup and check procedures described
above, plus an additional procedure that is invoked when an event
is removed from the event queue for servicing.
.PP
The procedure \fBTcl_CreateEventSource\fR creates a new event source.
Its arguments specify the setup procedure and check procedure for
the event source.
\fISetupProc\fR should match the following prototype:
.CS
typedef void Tcl_EventSetupProc(
        ClientData \fIclientData\fR,
        int \fIflags\fR);
.CE
The \fIclientData\fR argument will be the same as the \fIclientData\fR
argument to \fBTcl_CreateEventSource\fR;  it is typically used to
point to private information managed by the event source.
The \fIflags\fR argument will be the same as the \fIflags\fR
argument passed to \fBTcl_DoOneEvent\fR except that it will never
be 0 (\fBTcl_DoOneEvent\fR replaces 0 with \fBTCL_ALL_EVENTS\fR).
\fIFlags\fR indicates what kinds of events should be considered;
if the bit corresponding to this event source is not set, the event
source should return immediately without doing anything.  For
example, the file event source checks for the \fBTCL_FILE_EVENTS\fR
bit.
.PP
\fISetupProc\fR's job is to make sure that the application wakes up
when events of the desired type occur.  This is typically done in a
platform-dependent fashion.  For example, under Unix an event source
might call \fBTcl_CreateFileHandler\fR; under Windows it might
request notification with a Windows event.  For timer-driven event
sources such as timer events or any polled event, the event source
can call \fBTcl_SetMaxBlockTime\fR to force the application to wake
up after a specified time even if no events have occurred.
If no event source calls \fBTcl_SetMaxBlockTime\fR
then \fBTcl_WaitForEvent\fR will wait as long as necessary for an
event to occur; otherwise, it will only wait as long as the shortest
interval passed to \fBTcl_SetMaxBlockTime\fR by one of the event
sources.  If an event source knows that it already has events ready to
report, it can request a zero maximum block time.  For example, the
setup procedure for the X event source looks to see if there are
events already queued.  If there are, it calls
\fBTcl_SetMaxBlockTime\fR with a 0 block time so that
\fBTcl_WaitForEvent\fR does not block if there is no new data on the X
connection.
The \fItimePtr\fR argument to \fBTcl_WaitForEvent\fR points to
a structure that describes a time interval in seconds and
microseconds:
.CS
typedef struct Tcl_Time {
        long \fIsec\fR;
        long \fIusec\fR;
} Tcl_Time;
.CE
The \fIusec\fR field should be less than 1000000.
.PP
Information provided to \fBTcl_SetMaxBlockTime\fR
is only used for the next call to \fBTcl_WaitForEvent\fR; it is
discarded after \fBTcl_WaitForEvent\fR returns.
The next time an event wait is done each of the event sources'
setup procedures will be called again, and they can specify new
information for that event wait.
.PP
If the application uses an external event loop rather than
\fBTcl_DoOneEvent\fR, the event sources may need to call
\fBTcl_SetMaxBlockTime\fR at other times.  For example, if a new event
handler is registered that needs to poll for events, the event source
may call \fBTcl_SetMaxBlockTime\fR to set the block time to zero to
force the external event loop to call Tcl.  In this case,
\fBTcl_SetMaxBlockTime\fR invokes \fBTcl_SetTimer\fR with the shortest
interval seen since the last call to \fBTcl_DoOneEvent\fR or
\fBTcl_ServiceAll\fR.
.PP
In addition to the generic procedure \fBTcl_SetMaxBlockTime\fR, other
platform-specific procedures may also be available for
\fIsetupProc\fR, if there is additional information needed by
\fBTcl_WaitForEvent\fR on that platform.  For example, on Unix systems
the \fBTcl_CreateFileHandler\fR interface can be used to wait for file events.
.PP
The second procedure provided by each event source is its check
procedure, indicated by the \fIcheckProc\fR argument to
\fBTcl_CreateEventSource\fR.  \fICheckProc\fR must match the
following prototype:
.CS
typedef void Tcl_EventCheckProc(
        ClientData \fIclientData\fR,
        int \fIflags\fR);
.CE
The arguments to this procedure are the same as those for \fIsetupProc\fR.
\fBCheckProc\fR is invoked by \fBTcl_DoOneEvent\fR after it has waited
for events.  Presumably at least one event source is now prepared to
queue an event.  \fBTcl_DoOneEvent\fR calls each of the event sources
in turn, so they all have a chance to queue any events that are ready.
The check procedure does two things.  First, it must see if any events
have triggered.  Different event sources do this in different ways.
.PP
If an event source's check procedure detects an interesting event, it
must add the event to Tcl's event queue.  To do this, the event source
calls \fBTcl_QueueEvent\fR.  The \fIevPtr\fR argument is a pointer to
a dynamically allocated structure containing the event (see below for
more information on memory management issues).  Each event source can
define its own event structure with whatever information is relevant
to that event source.  However, the first element of the structure
must be a structure of type \fBTcl_Event\fR, and the address of this
structure is used when communicating between the event source and the
rest of the notifier.  A \fBTcl_Event\fR has the following definition:
.CS
typedef struct {
    Tcl_EventProc *\fIproc\fR;
    struct Tcl_Event *\fInextPtr\fR;
} Tcl_Event;
.CE
The event source must fill in the \fIproc\fR field of
the event before calling \fBTcl_QueueEvent\fR.
The \fInextPtr\fR is used to link together the events in the queue
and should not be modified by the event source.
.PP
An event may be added to the queue at any of three positions, depending
on the \fIposition\fR argument to \fBTcl_QueueEvent\fR:
.IP \fBTCL_QUEUE_TAIL\fR 24
Add the event at the back of the queue, so that all other pending
events will be serviced first.  This is almost always the right
place for new events.
.IP \fBTCL_QUEUE_HEAD\fR 24
Add the event at the front of the queue, so that it will be serviced
before all other queued events.
.IP \fBTCL_QUEUE_MARK\fR 24
Add the event at the front of the queue, unless there are other
events at the front whose position is \fBTCL_QUEUE_MARK\fR;  if so,
add the new event just after all other \fBTCL_QUEUE_MARK\fR events.
This value of \fIposition\fR is used to insert an ordered sequence of
events at the front of the queue, such as a series of
Enter and Leave events synthesized during a grab or ungrab operation
in Tk.
.PP
When it is time to handle an event from the queue (steps 1 and 4
above) \fBTcl_ServiceEvent\fR will invoke the \fIproc\fR specified
in the first queued \fBTcl_Event\fR structure.
\fIProc\fR must match the following prototype:
.CS
typedef int Tcl_EventProc(
        Tcl_Event *\fIevPtr\fR,
        int \fIflags\fR);
.CE
The first argument to \fIproc\fR is a pointer to the event, which will
be the same as the first argument to the \fBTcl_QueueEvent\fR call that
added the event to the queue.
The second argument to \fIproc\fR is the \fIflags\fR argument for the
current call to \fBTcl_ServiceEvent\fR;  this is used by the event source
to return immediately if its events are not relevant.
.PP
It is up to \fIproc\fR to handle the event, typically by invoking
one or more Tcl commands or C-level callbacks.
Once the event source has finished handling the event it returns 1
to indicate that the event can be removed from the queue.
If for some reason the event source decides that the event cannot
be handled at this time, it may return 0 to indicate that the event
should be deferred for processing later;  in this case \fBTcl_ServiceEvent\fR
will go on to the next event in the queue and attempt to service it.
There are several reasons why an event source might defer an event.
One possibility is that events of this type are excluded by the
\fIflags\fR argument.
For example, the file event source will always return 0 if the
\fBTCL_FILE_EVENTS\fR bit is not set in \fIflags\fR.
Another example of deferring events happens in Tk if
\fBTk_RestrictEvents\fR has been invoked to defer certain kinds
of window events.
.PP
When \fIproc\fR returns 1, \fBTcl_ServiceEvent\fR will remove the
event from the event queue and free its storage.
Note that the storage for an event must be allocated by
the event source (using \fBTcl_Alloc\fR or the Tcl macro \fBckalloc\fR)
before calling \fBTcl_QueueEvent\fR, but it
will be freed by \fBTcl_ServiceEvent\fR, not by the event source.
.PP
Threaded applications work in a
similar manner, except that there is a separate event queue for
each thread containing a Tcl interpreter.
Calling \fBTcl_QueueEvent\fR in a multithreaded application adds
an event to the current thread's queue.
To add an event to another thread's queue, use \fBTcl_ThreadQueueEvent\fR.
\fBTcl_ThreadQueueEvent\fR accepts as an argument a Tcl_ThreadId argument,
which uniquely identifies a thread in a Tcl application.  To obtain the
Tcl_ThreadID for the current thread, use the \fBTcl_GetCurrentThread\fR
procedure.  (A thread would then need to pass this identifier to other
threads for those threads to be able to add events to its queue.)
After adding an event to another thread's queue, you then typically
need to call \fBTcl_ThreadAlert\fR to
.QW "wake up"
that thread's notifier to alert it to the new event.
.PP
\fBTcl_DeleteEvents\fR can be used to explicitly remove one or more
events from the event queue.  \fBTcl_DeleteEvents\fR calls \fIproc\fR
for each event in the queue, deleting those for with the procedure
returns 1.  Events for which the procedure returns 0 are left in the
queue.  \fIProc\fR should match the following prototype:
.CS
typedef int Tcl_EventDeleteProc(
        Tcl_Event *\fIevPtr\fR,
        ClientData \fIclientData\fR);
.CE
The \fIclientData\fR argument will be the same as the \fIclientData\fR
argument to \fBTcl_DeleteEvents\fR; it is typically used to point to
private information managed by the event source.  The \fIevPtr\fR will
point to the next event in the queue.
.PP
\fBTcl_DeleteEventSource\fR deletes an event source.  The \fIsetupProc\fR,
\fIcheckProc\fR, and \fIclientData\fR arguments must exactly match those
provided to the \fBTcl_CreateEventSource\fR for the event source to be deleted.
If no such source exists, \fBTcl_DeleteEventSource\fR has no effect.

.SH "CREATING A NEW NOTIFIER"
.PP
The notifier consists of all the procedures described in this manual
entry, plus \fBTcl_DoOneEvent\fR and \fBTcl_Sleep\fR, which are
available on all platforms, and \fBTcl_CreateFileHandler\fR and
\fBTcl_DeleteFileHandler\fR, which are Unix-specific.  Most of these
procedures are generic, in that they are the same for all notifiers.
However, none of the procedures are notifier-dependent:
\fBTcl_InitNotifier\fR, \fBTcl_AlertNotifier\fR,
\fBTcl_FinalizeNotifier\fR, \fBTcl_SetTimer\fR, \fBTcl_Sleep\fR,
\fBTcl_WaitForEvent\fR, \fBTcl_CreateFileHandler\fR,
\fBTcl_DeleteFileHandler\fR and \fBTcl_ServiceModeHook\fR.  To support a
new platform or to integrate Tcl with an application-specific event loop,
you must write new versions of these procedures.
.PP
\fBTcl_InitNotifier\fR initializes the notifier state and returns
a handle to the notifier state.  Tcl calls this
procedure when initializing a Tcl interpreter.  Similarly,
\fBTcl_FinalizeNotifier\fR shuts down the notifier, and is
called by \fBTcl_Finalize\fR when shutting down a Tcl interpreter.
.PP
\fBTcl_WaitForEvent\fR is the lowest-level procedure in the notifier;
it is responsible for waiting for an
.QW interesting
event to occur or
for a given time to elapse.  Before \fBTcl_WaitForEvent\fR is invoked,
each of the event sources' setup procedure will have been invoked.
The \fItimePtr\fR argument to
\fBTcl_WaitForEvent\fR gives the maximum time to block for an event,
based on calls to \fBTcl_SetMaxBlockTime\fR made by setup procedures
and on other information (such as the \fBTCL_DONT_WAIT\fR bit in
\fIflags\fR).
.PP
Ideally, \fBTcl_WaitForEvent\fR should only wait for an event
to occur; it should not actually process the event in any way.
Later on, the
event sources will process the raw events and create Tcl_Events on
the event queue in their \fIcheckProc\fR procedures.
However, on some platforms (such as Windows) this is not possible;
events may be processed in \fBTcl_WaitForEvent\fR, including queuing
Tcl_Events and more (for example, callbacks for native widgets may be
invoked).  The return value from \fBTcl_WaitForEvent\fR must be either
0, 1, or \-1.  On platforms such as Windows where events get processed in
\fBTcl_WaitForEvent\fR, a return value of 1 means that there may be more
events still pending that have not been processed.  This is a sign to the
caller that it must call \fBTcl_WaitForEvent\fR again if it wants all
pending events to be processed. A 0 return value means that calling
\fBTcl_WaitForEvent\fR again will not have any effect: either this is a
platform where \fBTcl_WaitForEvent\fR only waits without doing any event
processing, or \fBTcl_WaitForEvent\fR knows for sure that there are no
additional events to process (e.g. it returned because the time
elapsed).  Finally, a return value of \-1 means that the event loop is
no longer operational and the application should probably unwind and
terminate.  Under Windows this happens when a WM_QUIT message is received;
under Unix it happens when \fBTcl_WaitForEvent\fR would have waited
forever because there were no active event sources and the timeout was
infinite.
.PP
\fBTcl_AlertNotifier\fR is used in multithreaded applications to allow
any thread to
.QW "wake up"
the notifier to alert it to new events on its
queue.  \fBTcl_AlertNotifier\fR requires as an argument the notifier
handle returned by \fBTcl_InitNotifier\fR.
.PP
If the notifier will be used with an external event loop, then it must
also support the \fBTcl_SetTimer\fR interface.  \fBTcl_SetTimer\fR is
invoked by \fBTcl_SetMaxBlockTime\fR whenever the maximum blocking
time has been reduced.  \fBTcl_SetTimer\fR should arrange for the
external event loop to invoke \fBTcl_ServiceAll\fR after the specified
interval even if no events have occurred.  This interface is needed
because \fBTcl_WaitForEvent\fR is not invoked when there is an external
event loop.  If the
notifier will only be used from \fBTcl_DoOneEvent\fR, then
\fBTcl_SetTimer\fR need not do anything.
.PP
\fBTcl_ServiceModeHook\fR is called by the platform-independent portion
of the notifier when client code makes a call to
\fBTcl_SetServiceMode\fR. This hook is provided to support operating
systems that require special event handling when the application is in
a modal loop (the Windows notifier, for instance, uses this hook to
create a communication window).
.PP
On Unix systems, the file event source also needs support from the
notifier.  The file event source consists of the
\fBTcl_CreateFileHandler\fR and \fBTcl_DeleteFileHandler\fR
procedures, which are described in the \fBTcl_CreateFileHandler\fR
manual page.
.PP
The \fBTcl_Sleep\fR and \fBTcl_DoOneEvent\fR interfaces are described
in their respective manual pages.
.PP
The easiest way to create a new notifier is to look at the code
for an existing notifier, such as the files \fBunix/tclUnixNotfy.c\fR
or \fBwin/tclWinNotify.c\fR in the Tcl source distribution.

.SH "REPLACING THE NOTIFIER"
.PP
A notifier that has been written according to the conventions above
can also be installed in a running process in place of the standard
notifier.  This mechanism is used so that a single executable can be
used (with the standard notifier) as a stand-alone program and reused
(with a replacement notifier in a loadable extension) as an extension
to another program, such as a Web browser plugin.
.PP
To do this, the extension makes a call to \fBTcl_SetNotifier\fR
passing a pointer to a \fBTcl_NotifierProcs\fR data structure.  The
structure has the following layout:
.CS
typedef struct Tcl_NotifierProcs {
    Tcl_SetTimerProc *setTimerProc;
    Tcl_WaitForEventProc *waitForEventProc;
    Tcl_CreateFileHandlerProc *createFileHandlerProc;
    Tcl_DeleteFileHandlerProc *deleteFileHandlerProc;
    Tcl_InitNotifierProc *initNotifierProc;
    Tcl_FinalizeNotifierProc *finalizeNotifierProc;
    Tcl_AlertNotifierProc *alertNotifierProc;
    Tcl_ServiceModeHookProc *serviceModeHookProc;
} Tcl_NotifierProcs;
.CE
Following the call to \fBTcl_SetNotifier\fR, the pointers given in
the \fBTcl_NotifierProcs\fR structure replace whatever notifier had
been installed in the process.
.PP
It is extraordinarily unwise to replace a running notifier. Normally,
\fBTcl_SetNotifier\fR should be called at process initialization time
before the first call to \fBTcl_InitNotifier\fR.

.SH "EXTERNAL EVENT LOOPS"
.PP
The notifier interfaces are designed so that Tcl can be embedded into
applications that have their own private event loops.  In this case,
the application does not call \fBTcl_DoOneEvent\fR except in the case
of recursive event loops such as calls to the Tcl commands \fBupdate\fR
or \fBvwait\fR.  Most of the time is spent in the external event loop
of the application.  In this case the notifier must arrange for the
external event loop to call back into Tcl when something
happens on the various Tcl event sources.  These callbacks should
arrange for appropriate Tcl events to be placed on the Tcl event queue.
.PP
Because the external event loop is not calling \fBTcl_DoOneEvent\fR on
a regular basis, it is up to the notifier to arrange for
\fBTcl_ServiceEvent\fR to be called whenever events are pending on the
Tcl event queue.  The easiest way to do this is to invoke
\fBTcl_ServiceAll\fR at the end of each callback from the external
event loop.  This will ensure that all of the event sources are
polled, any queued events are serviced, and any pending idle handlers
are processed before returning control to the application.  In
addition, event sources that need to poll for events can call
\fBTcl_SetMaxBlockTime\fR to force the external event loop to call
Tcl even if no events are available on the system event queue.
.PP
As a side effect of processing events detected in the main external
event loop, Tcl may invoke \fBTcl_DoOneEvent\fR to start a recursive event
loop in commands like \fBvwait\fR.  \fBTcl_DoOneEvent\fR will invoke
the external event loop, which will result in callbacks as described
in the preceding paragraph, which will result in calls to
\fBTcl_ServiceAll\fR.  However, in these cases it is undesirable to
service events in \fBTcl_ServiceAll\fR.  Servicing events there is
unnecessary because control will immediately return to the
external event loop and hence to \fBTcl_DoOneEvent\fR, which can
service the events itself.  Furthermore, \fBTcl_DoOneEvent\fR is
supposed to service only a single event, whereas \fBTcl_ServiceAll\fR
normally services all pending events.  To handle this situation,
\fBTcl_DoOneEvent\fR sets a flag for \fBTcl_ServiceAll\fR
that causes it to return without servicing any events.
This flag is called the \fIservice mode\fR;
\fBTcl_DoOneEvent\fR restores it to its previous value before it returns.
.PP
In some cases, however, it may be necessary for \fBTcl_ServiceAll\fR
to service events
even when it has been invoked from \fBTcl_DoOneEvent\fR.  This happens
when there is yet another recursive event loop invoked via an
event handler called by \fBTcl_DoOneEvent\fR (such as one that is
part of a native widget).  In this case, \fBTcl_DoOneEvent\fR may not
have a chance to service events so \fBTcl_ServiceAll\fR must service
them all.  Any recursive event loop that calls an external event
loop rather than \fBTcl_DoOneEvent\fR must reset the service mode so
that all events get processed in \fBTcl_ServiceAll\fR.  This is done
by invoking the \fBTcl_SetServiceMode\fR procedure.  If
\fBTcl_SetServiceMode\fR is passed \fBTCL_SERVICE_NONE\fR, then calls
to \fBTcl_ServiceAll\fR will return immediately without processing any
events.  If \fBTcl_SetServiceMode\fR is passed \fBTCL_SERVICE_ALL\fR,
then calls to \fBTcl_ServiceAll\fR will behave normally.
\fBTcl_SetServiceMode\fR returns the previous value of the service
mode, which should be restored when the recursive loop exits.
\fBTcl_GetServiceMode\fR returns the current value of the service
mode.

.SH "SEE ALSO"
\fBTcl_CreateFileHandler\fR, \fBTcl_DeleteFileHandler\fR, \fBTcl_Sleep\fR,
\fBTcl_DoOneEvent\fR, \fBThread(3)\fR
.SH KEYWORDS
event, notifier, event queue, event sources, file events, timer, idle, service mode, threads
                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WaitPid.3tcl                             0100644 0001750 0001750 00000021473 12566232330 023613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: DetachPids.3,v 1.7 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_DetachPids 3 "" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_DetachPids, Tcl_ReapDetachedProcs, Tcl_WaitPid \- manage child processes in background
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_DetachPids\fR(\fInumPids, pidPtr\fR)
.sp
\fBTcl_ReapDetachedProcs\fR()
.sp
Tcl_Pid
\fBTcl_WaitPid\fR(\fIpid, statusPtr, options\fR)
.SH ARGUMENTS
.AS Tcl_Pid *statusPtr out
.AP int numPids in
Number of process ids contained in the array pointed to by \fIpidPtr\fR.
.AP int *pidPtr in
Address of array containing \fInumPids\fR process ids.
.AP Tcl_Pid pid in
The id of the process (pipe) to wait for.
.AP int *statusPtr out
The result of waiting on a process (pipe). Either 0 or ECHILD.
.AP int options in
The options controlling the wait. WNOHANG specifies not to wait when
checking the process.
.BE
.SH DESCRIPTION
.PP
\fBTcl_DetachPids\fR and \fBTcl_ReapDetachedProcs\fR provide a
mechanism for managing subprocesses that are running in background.
These procedures are needed because the parent of a process must
eventually invoke the \fBwaitpid\fR kernel call (or one of a few other
similar kernel calls) to wait for the child to exit.  Until the
parent waits for the child, the child's state cannot be completely
reclaimed by the system.  If a parent continually creates children
and doesn't wait on them, the system's process table will eventually
overflow, even if all the children have exited.
.PP
\fBTcl_DetachPids\fR may be called to ask Tcl to take responsibility
for one or more processes whose process ids are contained in the
\fIpidPtr\fR array passed as argument.  The caller presumably
has started these processes running in background and does not
want to have to deal with them again.
.PP
\fBTcl_ReapDetachedProcs\fR invokes the \fBwaitpid\fR kernel call
on each of the background processes so that its state can be cleaned
up if it has exited.  If the process has not exited yet,
\fBTcl_ReapDetachedProcs\fR does not wait for it to exit;  it will check again
the next time it is invoked.
Tcl automatically calls \fBTcl_ReapDetachedProcs\fR each time the
\fBexec\fR command is executed, so in most cases it is not necessary
for any code outside of Tcl to invoke \fBTcl_ReapDetachedProcs\fR.
However, if you call \fBTcl_DetachPids\fR in situations where the
\fBexec\fR command may never get executed, you may wish to call
\fBTcl_ReapDetachedProcs\fR from time to time so that background
processes can be cleaned up.
.PP
\fBTcl_WaitPid\fR is a thin wrapper around the facilities provided by
the operating system to wait on the end of a spawned process and to
check a whether spawned process is still running. It is used by
\fBTcl_ReapDetachedProcs\fR and the channel system to portably access
the operating system.

.SH KEYWORDS
background, child, detach, process, wait
                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WinTCharToUtf.3tcl                       0100644 0001750 0001750 00000102744 12566232332 024716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997-1998 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Encoding.3,v 1.29 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_GetEncoding 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_GetEncoding, Tcl_FreeEncoding, Tcl_GetEncodingFromObj, Tcl_ExternalToUtfDString, Tcl_ExternalToUtf, Tcl_UtfToExternalDString, Tcl_UtfToExternal, Tcl_WinTCharToUtf, Tcl_WinUtfToTChar, Tcl_GetEncodingName, Tcl_SetSystemEncoding, Tcl_GetEncodingNameFromEnvironment, Tcl_GetEncodingNames, Tcl_CreateEncoding, Tcl_GetEncodingSearchPath, Tcl_SetEncodingSearchPath, Tcl_GetDefaultEncodingDir, Tcl_SetDefaultEncodingDir \- procedures for creating and using encodings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Encoding
\fBTcl_GetEncoding\fR(\fIinterp, name\fR)
.sp
void
\fBTcl_FreeEncoding\fR(\fIencoding\fR)
.sp
.VS 8.5
int
\fBTcl_GetEncodingFromObj\fR(\fIinterp, objPtr, encodingPtr\fR)
.VE 8.5
.sp
char *
\fBTcl_ExternalToUtfDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
char *
\fBTcl_UtfToExternalDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
int
\fBTcl_ExternalToUtf\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
int
\fBTcl_UtfToExternal\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
char *
\fBTcl_WinTCharToUtf\fR(\fItsrc, srcLen, dstPtr\fR)
.sp
TCHAR *
\fBTcl_WinUtfToTChar\fR(\fIsrc, srcLen, dstPtr\fR)
.sp
const char *
\fBTcl_GetEncodingName\fR(\fIencoding\fR)
.sp
int
\fBTcl_SetSystemEncoding\fR(\fIinterp, name\fR)
.sp
.VS 8.5
const char *
\fBTcl_GetEncodingNameFromEnvironment\fR(\fIbufPtr\fR)
.VE 8.5
.sp
void
\fBTcl_GetEncodingNames\fR(\fIinterp\fR)
.sp
Tcl_Encoding
\fBTcl_CreateEncoding\fR(\fItypePtr\fR)
.sp
.VS 8.5
Tcl_Obj *
\fBTcl_GetEncodingSearchPath\fR()
.sp
int
\fBTcl_SetEncodingSearchPath\fR(\fIsearchPath\fR)
.VE 8.5
.sp
const char *
\fBTcl_GetDefaultEncodingDir\fR(\fIvoid\fR)
.sp
void
\fBTcl_SetDefaultEncodingDir\fR(\fIpath\fR)
.SH ARGUMENTS
.AS "const Tcl_EncodingType" *dstWrotePtr in/out
.AP Tcl_Interp *interp in
Interpreter to use for error reporting, or NULL if no error reporting is
desired.
.AP "const char" *name in
Name of encoding to load.
.AP Tcl_Encoding encoding in
The encoding to query, free, or use for converting text.  If \fIencoding\fR is 
NULL, the current system encoding is used.
.AP Tcl_Obj *objPtr in
.VS 8.5
Name of encoding to get token for.
.VE 8.5
.AP Tcl_Encoding *encodingPtr out
.VS 8.5
Points to storage where encoding token is to be written.
.VE 8.5
.AP "const char" *src in
For the \fBTcl_ExternalToUtf\fR functions, an array of bytes in the
specified encoding that are to be converted to UTF-8.  For the
\fBTcl_UtfToExternal\fR and \fBTcl_WinUtfToTChar\fR functions, an array of
UTF-8 characters to be converted to the specified encoding.  
.AP "const TCHAR" *tsrc in
An array of Windows TCHAR characters to convert to UTF-8.
.AP int srcLen in 
Length of \fIsrc\fR or \fItsrc\fR in bytes.  If the length is negative, the 
encoding-specific length of the string is used.
.AP Tcl_DString *dstPtr out
Pointer to an uninitialized or free \fBTcl_DString\fR in which the converted
result will be stored.
.AP int flags in
Various flag bits OR-ed together.  
\fBTCL_ENCODING_START\fR signifies that the
source buffer is the first block in a (potentially multi-block) input
stream, telling the conversion routine to reset to an initial state and
perform any initialization that needs to occur before the first byte is
converted. \fBTCL_ENCODING_END\fR signifies that the source buffer is the last
block in a (potentially multi-block) input stream, telling the conversion
routine to perform any finalization that needs to occur after the last
byte is converted and then to reset to an initial state.
\fBTCL_ENCODING_STOPONERROR\fR signifies that the conversion routine should
return immediately upon reading a source character that does not exist in
the target encoding; otherwise a default fallback character will
automatically be substituted.  
.AP Tcl_EncodingState *statePtr in/out
Used when converting a (generally long or indefinite length) byte stream
in a piece-by-piece fashion.  The conversion routine stores its current
state in \fI*statePtr\fR after \fIsrc\fR (the buffer containing the
current piece) has been converted; that state information must be passed
back when converting the next piece of the stream so the conversion
routine knows what state it was in when it left off at the end of the
last piece.  May be NULL, in which case the value specified for \fIflags\fR 
is ignored and the source buffer is assumed to contain the complete string to
convert.
.AP char *dst out
Buffer in which the converted result will be stored.  No more than
\fIdstLen\fR bytes will be stored in \fIdst\fR.
.AP int dstLen in
The maximum length of the output buffer \fIdst\fR in bytes.
.AP int *srcReadPtr out
Filled with the number of bytes from \fIsrc\fR that were actually
converted.  This may be less than the original source length if there was
a problem converting some source characters.  May be NULL.
.AP int *dstWrotePtr out
Filled with the number of bytes that were actually stored in the output
buffer as a result of the conversion.  May be NULL.
.AP int *dstCharsPtr out
Filled with the number of characters that correspond to the number of bytes
stored in the output buffer.  May be NULL.
.AP Tcl_DString *bufPtr out
.VS 8.5
Storage for the prescribed system encoding name.
.VE 8.5
.AP "const Tcl_EncodingType" *typePtr in
Structure that defines a new type of encoding.  
.AP Tcl_Obj *searchPath in
.VS 8.5
List of filesystem directories in which to search for encoding data files.
.VE 8.5
.AP "const char" *path in
A path to the location of the encoding file.  
.BE
.SH INTRODUCTION
.PP
These routines convert between Tcl's internal character representation,
UTF-8, and character representations used by various operating systems or
file systems, such as Unicode, ASCII, or Shift-JIS.  When operating on
strings, such as such as obtaining the names of files or displaying
characters using international fonts, the strings must be translated into
one or possibly multiple formats that the various system calls can use.  For
instance, on a Japanese Unix workstation, a user might obtain a filename
represented in the EUC-JP file encoding and then translate the characters to
the jisx0208 font encoding in order to display the filename in a Tk widget.
The purpose of the encoding package is to help bridge the translation gap.
UTF-8 provides an intermediate staging ground for all the various
encodings.  In the example above, text would be translated into UTF-8 from
whatever file encoding the operating system is using.  Then it would be
translated from UTF-8 into whatever font encoding the display routines
require.
.PP
Some basic encodings are compiled into Tcl.  Others can be defined by the
user or dynamically loaded from encoding files in a
platform-independent manner.
.SH DESCRIPTION
.PP
\fBTcl_GetEncoding\fR finds an encoding given its \fIname\fR.  The name may
refer to a built-in Tcl encoding, a user-defined encoding registered by
calling \fBTcl_CreateEncoding\fR, or a dynamically-loadable encoding
file.  The return value is a token that represents the encoding and can be
used in subsequent calls to procedures such as \fBTcl_GetEncodingName\fR,
\fBTcl_FreeEncoding\fR, and \fBTcl_UtfToExternal\fR.  If the name did not
refer to any known or loadable encoding, NULL is returned and an error
message is returned in \fIinterp\fR.
.PP
The encoding package maintains a database of all encodings currently in use.
The first time \fIname\fR is seen, \fBTcl_GetEncoding\fR returns an
encoding with a reference count of 1.  If the same \fIname\fR is requested
further times, then the reference count for that encoding is incremented
without the overhead of allocating a new encoding and all its associated
data structures.  
.PP
When an \fIencoding\fR is no longer needed, \fBTcl_FreeEncoding\fR
should be called to release it.  When an \fIencoding\fR is no longer in use
anywhere (i.e., it has been freed as many times as it has been gotten)
\fBTcl_FreeEncoding\fR will release all storage the encoding was using
and delete it from the database. 
.PP
.VS 8.5
\fBTcl_GetEncodingFromObj\fR treats the string representation of
\fIobjPtr\fR as an encoding name, and finds an encoding with that
name, just as \fBTcl_GetEncoding\fR does. When an encoding is found,
it is cached within the \fBobjPtr\fR value for future reference, the
\fBTcl_Encoding\fR token is written to the storage pointed to by
\fIencodingPtr\fR, and the value \fBTCL_OK\fR is returned. If no such
encoding is found, the value \fBTCL_ERROR\fR is returned, and no
writing to \fB*\fR\fIencodingPtr\fR takes place. Just as with
\fBTcl_GetEncoding\fR, the caller should call \fBTcl_FreeEncoding\fR
on the resulting encoding token when that token will no longer be
used.
.VE 8.5
.PP
\fBTcl_ExternalToUtfDString\fR converts a source buffer \fIsrc\fR from the
specified \fIencoding\fR into UTF-8.  The converted bytes are stored in 
\fIdstPtr\fR, which is then null-terminated.  The caller should eventually
call \fBTcl_DStringFree\fR to free any information stored in \fIdstPtr\fR.
When converting, if any of the characters in the source buffer cannot be
represented in the target encoding, a default fallback character will be
used.  The return value is a pointer to the value stored in the DString.
.PP
\fBTcl_ExternalToUtf\fR converts a source buffer \fIsrc\fR from the specified
\fIencoding\fR into UTF-8.  Up to \fIsrcLen\fR bytes are converted from the
source buffer and up to \fIdstLen\fR converted bytes are stored in \fIdst\fR.
In all cases, \fI*srcReadPtr\fR is filled with the number of bytes that were
successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR is filled with
the corresponding number of bytes that were stored in \fIdst\fR.  The return
value is one of the following:
.RS
.IP \fBTCL_OK\fR 29
All bytes of \fIsrc\fR were converted.
.IP \fBTCL_CONVERT_NOSPACE\fR 29
The destination buffer was not large enough for all of the converted data; as
many characters as could fit were converted though.
.IP \fBTCL_CONVERT_MULTIBYTE\fR 29
The last few bytes in the source buffer were the beginning of a multibyte
sequence, but more bytes were needed to complete this sequence.  A
subsequent call to the conversion routine should pass a buffer containing
the unconverted bytes that remained in \fIsrc\fR plus some further bytes
from the source stream to properly convert the formerly split-up multibyte
sequence.  
.IP \fBTCL_CONVERT_SYNTAX\fR 29
The source buffer contained an invalid character sequence.  This may occur
if the input stream has been damaged or if the input encoding method was
misidentified.
.IP \fBTCL_CONVERT_UNKNOWN\fR 29
The source buffer contained a character that could not be represented in
the target encoding and \fBTCL_ENCODING_STOPONERROR\fR was specified.  
.RE
.LP
\fBTcl_UtfToExternalDString\fR converts a source buffer \fIsrc\fR from UTF-8 
into the specified \fIencoding\fR.  The converted bytes are stored in
\fIdstPtr\fR, which is then terminated with the appropriate encoding-specific
null.  The caller should eventually call \fBTcl_DStringFree\fR to free any
information stored in \fIdstPtr\fR.  When converting, if any of the
characters in the source buffer cannot be represented in the target
encoding, a default fallback character will be used.  The return value is
a pointer to the value stored in the DString.
.PP
\fBTcl_UtfToExternal\fR converts a source buffer \fIsrc\fR from UTF-8 into
the specified \fIencoding\fR.  Up to \fIsrcLen\fR bytes are converted from
the source buffer and up to \fIdstLen\fR converted bytes are stored in
\fIdst\fR.  In all cases, \fI*srcReadPtr\fR is filled with the number of
bytes that were successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR
is filled with the corresponding number of bytes that were stored in
\fIdst\fR.  The return values are the same as the return values for
\fBTcl_ExternalToUtf\fR.
.PP
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR are
Windows-only convenience
functions for converting between UTF-8 and Windows strings.  On Windows 95
(as with the Unix operating system),
all strings exchanged between Tcl and the operating system are
.QW "char"
based.  On Windows NT, some strings exchanged between Tcl and the
operating system are
.QW "char"
oriented while others are in Unicode.  By
convention, in Windows a TCHAR is a character in the ANSI code page
on Windows 95 and a Unicode character on Windows NT.
.PP
If you planned to use the same
.QW "char"
based interfaces on both Windows
95 and Windows NT, you could use \fBTcl_UtfToExternal\fR and
\fBTcl_ExternalToUtf\fR (or their \fBTcl_DString\fR equivalents) with an
encoding of NULL (the current system encoding).  On the other hand,
if you planned to use the Unicode interface when running on Windows NT
and the
.QW "char"
interfaces when running on Windows 95, you would have
to perform the following type of test over and over in your program
(as represented in pseudo-code):
.CS
if (running NT) {
    encoding <- Tcl_GetEncoding("unicode");
    nativeBuffer <- Tcl_UtfToExternal(encoding, utfBuffer);
    Tcl_FreeEncoding(encoding);
} else {
    nativeBuffer <- Tcl_UtfToExternal(NULL, utfBuffer);
}
.CE
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR automatically
handle this test and use the proper encoding based on the current
operating system.  \fBTcl_WinUtfToTChar\fR returns a pointer to
a TCHAR string, and \fBTcl_WinTCharToUtf\fR expects a TCHAR string
pointer as the \fIsrc\fR string.  Otherwise, these functions
behave identically to \fBTcl_UtfToExternalDString\fR and
\fBTcl_ExternalToUtfDString\fR.
.PP
\fBTcl_GetEncodingName\fR is roughly the inverse of \fBTcl_GetEncoding\fR.
Given an \fIencoding\fR, the return value is the \fIname\fR argument that
was used to create the encoding.  The string returned by 
\fBTcl_GetEncodingName\fR is only guaranteed to persist until the
\fIencoding\fR is deleted.  The caller must not modify this string.
.PP
\fBTcl_SetSystemEncoding\fR sets the default encoding that should be used
whenever the user passes a NULL value for the \fIencoding\fR argument to
any of the other encoding functions.  If \fIname\fR is NULL, the system
encoding is reset to the default system encoding, \fBbinary\fR.  If the
name did not refer to any known or loadable encoding, \fBTCL_ERROR\fR is
returned and an error message is left in \fIinterp\fR.  Otherwise, this
procedure increments the reference count of the new system encoding,
decrements the reference count of the old system encoding, and returns
\fBTCL_OK\fR.
.PP
.VS 8.5
\fBTcl_GetEncodingNameFromEnvironment\fR provides a means for the Tcl
library to report the encoding name it believes to be the correct one
to use as the system encoding, based on system calls and examination of
the environment suitable for the platform.  It accepts \fIbufPtr\fR,
a pointer to an uninitialized or freed \fBTcl_DString\fR and writes
the encoding name to it.  The \fBTcl_DStringValue\fR is returned.
.VE 8.5
.PP
\fBTcl_GetEncodingNames\fR sets the \fIinterp\fR result to a list
consisting of the names of all the encodings that are currently defined
or can be dynamically loaded, searching the encoding path specified by
\fBTcl_SetDefaultEncodingDir\fR.  This procedure does not ensure that the
dynamically-loadable encoding files contain valid data, but merely that they
exist.
.PP
\fBTcl_CreateEncoding\fR defines a new encoding and registers the C
procedures that are called back to convert between the encoding and
UTF-8.  Encodings created by \fBTcl_CreateEncoding\fR are thereafter
visible in the database used by \fBTcl_GetEncoding\fR.  Just as with the
\fBTcl_GetEncoding\fR procedure, the return value is a token that
represents the encoding and can be used in subsequent calls to other
encoding functions.  \fBTcl_CreateEncoding\fR returns an encoding with a
reference count of 1. If an encoding with the specified \fIname\fR
already exists, then its entry in the database is replaced with the new
encoding; the token for the old encoding will remain valid and continue
to behave as before, but users of the new token will now call the new
encoding procedures.  
.PP
The \fItypePtr\fR argument to \fBTcl_CreateEncoding\fR contains information 
about the name of the encoding and the procedures that will be called to
convert between this encoding and UTF-8.  It is defined as follows:
.PP
.CS
typedef struct Tcl_EncodingType {
        const char *\fIencodingName\fR;
        Tcl_EncodingConvertProc *\fItoUtfProc\fR;
        Tcl_EncodingConvertProc *\fIfromUtfProc\fR;
        Tcl_EncodingFreeProc *\fIfreeProc\fR;
        ClientData \fIclientData\fR;
        int \fInullSize\fR;
} Tcl_EncodingType;  
.CE
.PP
The \fIencodingName\fR provides a string name for the encoding, by
which it can be referred in other procedures such as
\fBTcl_GetEncoding\fR.  The \fItoUtfProc\fR refers to a callback
procedure to invoke to convert text from this encoding into UTF-8.
The \fIfromUtfProc\fR refers to a callback procedure to invoke to
convert text from UTF-8 into this encoding.  The \fIfreeProc\fR refers
to a callback procedure to invoke when this encoding is deleted.  The
\fIfreeProc\fR field may be NULL.  The \fIclientData\fR contains an
arbitrary one-word value passed to \fItoUtfProc\fR, \fIfromUtfProc\fR,
and \fIfreeProc\fR whenever they are called.  Typically, this is a
pointer to a data structure containing encoding-specific information
that can be used by the callback procedures.  For instance, two very
similar encodings such as \fBascii\fR and \fBmacRoman\fR may use the
same callback procedure, but use different values of \fIclientData\fR
to control its behavior.  The \fInullSize\fR specifies the number of
zero bytes that signify end-of-string in this encoding.  It must be
\fB1\fR (for single-byte or multi-byte encodings like ASCII or
Shift-JIS) or \fB2\fR (for double-byte encodings like Unicode).
Constant-sized encodings with 3 or more bytes per character (such as
CNS11643) are not accepted.
.PP
The callback procedures \fItoUtfProc\fR and \fIfromUtfProc\fR should match the
type \fBTcl_EncodingConvertProc\fR:
.PP
.CS
typedef int Tcl_EncodingConvertProc(
        ClientData \fIclientData\fR,
        const char *\fIsrc\fR, 
        int \fIsrcLen\fR, 
        int \fIflags\fR, 
        Tcl_EncodingState *\fIstatePtr\fR,
        char *\fIdst\fR, 
        int \fIdstLen\fR, 
        int *\fIsrcReadPtr\fR,
        int *\fIdstWrotePtr\fR,
        int *\fIdstCharsPtr\fR);
.CE
.PP
The \fItoUtfProc\fR and \fIfromUtfProc\fR procedures are called by the
\fBTcl_ExternalToUtf\fR or \fBTcl_UtfToExternal\fR family of functions to
perform the actual conversion.  The \fIclientData\fR parameter to these
procedures is the same as the \fIclientData\fR field specified to
\fBTcl_CreateEncoding\fR when the encoding was created.  The remaining
arguments to the callback procedures are the same as the arguments,
documented at the top, to \fBTcl_ExternalToUtf\fR or
\fBTcl_UtfToExternal\fR, with the following exceptions.  If the
\fIsrcLen\fR argument to one of those high-level functions is negative,
the value passed to the callback procedure will be the appropriate
encoding-specific string length of \fIsrc\fR.  If any of the \fIsrcReadPtr\fR, 
\fIdstWrotePtr\fR, or \fIdstCharsPtr\fR arguments to one of the high-level
functions is NULL, the corresponding value passed to the callback
procedure will be a non-NULL location.
.PP
The callback procedure \fIfreeProc\fR, if non-NULL, should match the type 
\fBTcl_EncodingFreeProc\fR:
.CS
typedef void Tcl_EncodingFreeProc(
        ClientData \fIclientData\fR);
.CE
.PP
This \fIfreeProc\fR function is called when the encoding is deleted.  The
\fIclientData\fR parameter is the same as the \fIclientData\fR field
specified to \fBTcl_CreateEncoding\fR when the encoding was created.  
.PP
.VS 8.5
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR
are called to access and set the list of filesystem directories searched
for encoding data files.  
.PP
The value returned by \fBTcl_GetEncodingSearchPath\fR
is the value stored by the last successful call to
\fBTcl_SetEncodingSearchPath\fR.  If no calls to
\fBTcl_SetEncodingSearchPath\fR have occurred, Tcl will compute an initial
value based on the environment.  There is one encoding search path for the
entire process, shared by all threads in the process.
.PP
\fBTcl_SetEncodingSearchPath\fR stores \fIsearchPath\fR and returns
\fBTCL_OK\fR, unless \fIsearchPath\fR is not a valid Tcl list, which
causes \fBTCL_ERROR\fR to be returned.  The elements of \fIsearchPath\fR
are not verified as existing readable filesystem directories.  When
searching for encoding data files takes place, and non-existent or
non-readable filesystem directories on the \fIsearchPath\fR are silently
ignored.
.PP
\fBTcl_GetDefaultEncodingDir\fR and \fBTcl_SetDefaultEncodingDir\fR
are obsolete interfaces best replaced with calls to
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR.
They are called to access and set the first element of the \fIsearchPath\fR
list.  Since Tcl searches \fIsearchPath\fR for encoding data files in
list order, these routines establish the
.QW default
directory in which to find encoding data files.
.VE 8.5
.SH "ENCODING FILES"
Space would prohibit precompiling into Tcl every possible encoding
algorithm, so many encodings are stored on disk as dynamically-loadable
encoding files.  This behavior also allows the user to create additional
encoding files that can be loaded using the same mechanism.  These
encoding files contain information about the tables and/or escape
sequences used to map between an external encoding and Unicode.  The
external encoding may consist of single-byte, multi-byte, or double-byte
characters.  
.PP
Each dynamically-loadable encoding is represented as a text file.  The
initial line of the file, beginning with a
.QW #
symbol, is a comment
that provides a human-readable description of the file.  The next line
identifies the type of encoding file.  It can be one of the following
letters:
.IP "[1] \fBS\fR"
A single-byte encoding, where one character is always one byte long in the
encoding.  An example is \fBiso8859-1\fR, used by many European languages.
.IP "[2] \fBD\fR"
A double-byte encoding, where one character is always two bytes long in the
encoding.  An example is \fBbig5\fR, used for Chinese text.
.IP "[3] \fBM\fR"
A multi-byte encoding, where one character may be either one or two bytes long.
Certain bytes are lead bytes, indicating that another byte must follow
and that together the two bytes represent one character.  Other bytes are not
lead bytes and represent themselves.  An example is \fBshiftjis\fR, used by
many Japanese computers.
.IP "[4] \fBE\fR"
An escape-sequence encoding, specifying that certain sequences of bytes
do not represent characters, but commands that describe how following bytes
should be interpreted.  
.PP
The rest of the lines in the file depend on the type.  
.PP
Cases [1], [2], and [3] are collectively referred to as table-based encoding
files.  The lines in a table-based encoding file are in the same
format as this example taken from the \fBshiftjis\fR encoding (this is not
the complete file):
.CS
# Encoding file: shiftjis, multi-byte
M
003F 0 40
00
0000000100020003000400050006000700080009000A000B000C000D000E000F
0010001100120013001400150016001700180019001A001B001C001D001E001F
0020002100220023002400250026002700280029002A002B002C002D002E002F
0030003100320033003400350036003700380039003A003B003C003D003E003F
0040004100420043004400450046004700480049004A004B004C004D004E004F
0050005100520053005400550056005700580059005A005B005C005D005E005F
0060006100620063006400650066006700680069006A006B006C006D006E006F
0070007100720073007400750076007700780079007A007B007C007D203E007F
0080000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000FF61FF62FF63FF64FF65FF66FF67FF68FF69FF6AFF6BFF6CFF6DFF6EFF6F
FF70FF71FF72FF73FF74FF75FF76FF77FF78FF79FF7AFF7BFF7CFF7DFF7EFF7F
FF80FF81FF82FF83FF84FF85FF86FF87FF88FF89FF8AFF8BFF8CFF8DFF8EFF8F
FF90FF91FF92FF93FF94FF95FF96FF97FF98FF99FF9AFF9BFF9CFF9DFF9EFF9F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
81
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
300030013002FF0CFF0E30FBFF1AFF1BFF1FFF01309B309C00B4FF4000A8FF3E
FFE3FF3F30FD30FE309D309E30034EDD30053006300730FC20152010FF0F005C
301C2016FF5C2026202520182019201C201DFF08FF0930143015FF3BFF3DFF5B
FF5D30083009300A300B300C300D300E300F30103011FF0B221200B100D70000
00F7FF1D2260FF1CFF1E22662267221E22342642264000B0203220332103FFE5
FF0400A200A3FF05FF03FF06FF0AFF2000A72606260525CB25CF25CE25C725C6
25A125A025B325B225BD25BC203B301221922190219121933013000000000000
000000000000000000000000000000002208220B2286228722822283222A2229
000000000000000000000000000000002227222800AC21D221D4220022030000
0000000000000000000000000000000000000000222022A52312220222072261
2252226A226B221A223D221D2235222B222C0000000000000000000000000000
212B2030266F266D266A2020202100B6000000000000000025EF000000000000
.CE
.PP
The third line of the file is three numbers.  The first number is the
fallback character (in base 16) to use when converting from UTF-8 to this
encoding.  The second number is a \fB1\fR if this file represents the
encoding for a symbol font, or \fB0\fR otherwise.  The last number (in base
10) is how many pages of data follow.  
.PP
Subsequent lines in the example above are pages that describe how to map
from the encoding into 2-byte Unicode.  The first line in a page identifies
the page number.  Following it are 256 double-byte numbers, arranged as 16
rows of 16 numbers.  Given a character in the encoding, the high byte of
that character is used to select which page, and the low byte of that
character is used as an index to select one of the double-byte numbers in
that page \- the value obtained being the corresponding Unicode character.
By examination of the example above, one can see that the characters 0x7E
and 0x8163 in \fBshiftjis\fR map to 203E and 2026 in Unicode, respectively.
.PP
Following the first page will be all the other pages, each in the same
format as the first: one number identifying the page followed by 256
double-byte Unicode characters.  If a character in the encoding maps to the
Unicode character 0000, it means that the character does not actually exist.
If all characters on a page would map to 0000, that page can be omitted.
.PP
Case [4] is the escape-sequence encoding file.  The lines in an this type of
file are in the same format as this example taken from the \fBiso2022-jp\fR
encoding:
.CS
.ta 1.5i
# Encoding file: iso2022-jp, escape-driven
E
init		{}
final		{}
iso8859-1	\ex1b(B
jis0201		\ex1b(J
jis0208		\ex1b$@
jis0208		\ex1b$B
jis0212		\ex1b$(D
gb2312		\ex1b$A
ksc5601		\ex1b$(C
.CE
.PP
In the file, the first column represents an option and the second column
is the associated value.  \fBinit\fR is a string to emit or expect before
the first character is converted, while \fBfinal\fR is a string to emit
or expect after the last character.  All other options are names of
table-based encodings; the associated value is the escape-sequence that
marks that encoding.  Tcl syntax is used for the values; in the above
example, for instance,
.QW \fB{}\fR
represents the empty string and
.QW \fB\ex1b\fR
represents character 27.
.PP
When \fBTcl_GetEncoding\fR encounters an encoding \fIname\fR that has not
been loaded, it attempts to load an encoding file called \fIname\fB.enc\fR
from the \fBencoding\fR subdirectory of each directory that Tcl searches
for its script library.  If the encoding file exists, but is
malformed, an error message will be left in \fIinterp\fR.
.SH KEYWORDS
utf, encoding, convert
                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WinUtfToTChar.3tcl                       0100644 0001750 0001750 00000102744 12566232332 024716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1997-1998 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Encoding.3,v 1.29 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_GetEncoding 3 "8.1" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_GetEncoding, Tcl_FreeEncoding, Tcl_GetEncodingFromObj, Tcl_ExternalToUtfDString, Tcl_ExternalToUtf, Tcl_UtfToExternalDString, Tcl_UtfToExternal, Tcl_WinTCharToUtf, Tcl_WinUtfToTChar, Tcl_GetEncodingName, Tcl_SetSystemEncoding, Tcl_GetEncodingNameFromEnvironment, Tcl_GetEncodingNames, Tcl_CreateEncoding, Tcl_GetEncodingSearchPath, Tcl_SetEncodingSearchPath, Tcl_GetDefaultEncodingDir, Tcl_SetDefaultEncodingDir \- procedures for creating and using encodings
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Encoding
\fBTcl_GetEncoding\fR(\fIinterp, name\fR)
.sp
void
\fBTcl_FreeEncoding\fR(\fIencoding\fR)
.sp
.VS 8.5
int
\fBTcl_GetEncodingFromObj\fR(\fIinterp, objPtr, encodingPtr\fR)
.VE 8.5
.sp
char *
\fBTcl_ExternalToUtfDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
char *
\fBTcl_UtfToExternalDString\fR(\fIencoding, src, srcLen, dstPtr\fR)
.sp
int
\fBTcl_ExternalToUtf\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
int
\fBTcl_UtfToExternal\fR(\fIinterp, encoding, src, srcLen, flags, statePtr,
                  dst, dstLen, srcReadPtr, dstWrotePtr, dstCharsPtr\fR)
.sp
char *
\fBTcl_WinTCharToUtf\fR(\fItsrc, srcLen, dstPtr\fR)
.sp
TCHAR *
\fBTcl_WinUtfToTChar\fR(\fIsrc, srcLen, dstPtr\fR)
.sp
const char *
\fBTcl_GetEncodingName\fR(\fIencoding\fR)
.sp
int
\fBTcl_SetSystemEncoding\fR(\fIinterp, name\fR)
.sp
.VS 8.5
const char *
\fBTcl_GetEncodingNameFromEnvironment\fR(\fIbufPtr\fR)
.VE 8.5
.sp
void
\fBTcl_GetEncodingNames\fR(\fIinterp\fR)
.sp
Tcl_Encoding
\fBTcl_CreateEncoding\fR(\fItypePtr\fR)
.sp
.VS 8.5
Tcl_Obj *
\fBTcl_GetEncodingSearchPath\fR()
.sp
int
\fBTcl_SetEncodingSearchPath\fR(\fIsearchPath\fR)
.VE 8.5
.sp
const char *
\fBTcl_GetDefaultEncodingDir\fR(\fIvoid\fR)
.sp
void
\fBTcl_SetDefaultEncodingDir\fR(\fIpath\fR)
.SH ARGUMENTS
.AS "const Tcl_EncodingType" *dstWrotePtr in/out
.AP Tcl_Interp *interp in
Interpreter to use for error reporting, or NULL if no error reporting is
desired.
.AP "const char" *name in
Name of encoding to load.
.AP Tcl_Encoding encoding in
The encoding to query, free, or use for converting text.  If \fIencoding\fR is 
NULL, the current system encoding is used.
.AP Tcl_Obj *objPtr in
.VS 8.5
Name of encoding to get token for.
.VE 8.5
.AP Tcl_Encoding *encodingPtr out
.VS 8.5
Points to storage where encoding token is to be written.
.VE 8.5
.AP "const char" *src in
For the \fBTcl_ExternalToUtf\fR functions, an array of bytes in the
specified encoding that are to be converted to UTF-8.  For the
\fBTcl_UtfToExternal\fR and \fBTcl_WinUtfToTChar\fR functions, an array of
UTF-8 characters to be converted to the specified encoding.  
.AP "const TCHAR" *tsrc in
An array of Windows TCHAR characters to convert to UTF-8.
.AP int srcLen in 
Length of \fIsrc\fR or \fItsrc\fR in bytes.  If the length is negative, the 
encoding-specific length of the string is used.
.AP Tcl_DString *dstPtr out
Pointer to an uninitialized or free \fBTcl_DString\fR in which the converted
result will be stored.
.AP int flags in
Various flag bits OR-ed together.  
\fBTCL_ENCODING_START\fR signifies that the
source buffer is the first block in a (potentially multi-block) input
stream, telling the conversion routine to reset to an initial state and
perform any initialization that needs to occur before the first byte is
converted. \fBTCL_ENCODING_END\fR signifies that the source buffer is the last
block in a (potentially multi-block) input stream, telling the conversion
routine to perform any finalization that needs to occur after the last
byte is converted and then to reset to an initial state.
\fBTCL_ENCODING_STOPONERROR\fR signifies that the conversion routine should
return immediately upon reading a source character that does not exist in
the target encoding; otherwise a default fallback character will
automatically be substituted.  
.AP Tcl_EncodingState *statePtr in/out
Used when converting a (generally long or indefinite length) byte stream
in a piece-by-piece fashion.  The conversion routine stores its current
state in \fI*statePtr\fR after \fIsrc\fR (the buffer containing the
current piece) has been converted; that state information must be passed
back when converting the next piece of the stream so the conversion
routine knows what state it was in when it left off at the end of the
last piece.  May be NULL, in which case the value specified for \fIflags\fR 
is ignored and the source buffer is assumed to contain the complete string to
convert.
.AP char *dst out
Buffer in which the converted result will be stored.  No more than
\fIdstLen\fR bytes will be stored in \fIdst\fR.
.AP int dstLen in
The maximum length of the output buffer \fIdst\fR in bytes.
.AP int *srcReadPtr out
Filled with the number of bytes from \fIsrc\fR that were actually
converted.  This may be less than the original source length if there was
a problem converting some source characters.  May be NULL.
.AP int *dstWrotePtr out
Filled with the number of bytes that were actually stored in the output
buffer as a result of the conversion.  May be NULL.
.AP int *dstCharsPtr out
Filled with the number of characters that correspond to the number of bytes
stored in the output buffer.  May be NULL.
.AP Tcl_DString *bufPtr out
.VS 8.5
Storage for the prescribed system encoding name.
.VE 8.5
.AP "const Tcl_EncodingType" *typePtr in
Structure that defines a new type of encoding.  
.AP Tcl_Obj *searchPath in
.VS 8.5
List of filesystem directories in which to search for encoding data files.
.VE 8.5
.AP "const char" *path in
A path to the location of the encoding file.  
.BE
.SH INTRODUCTION
.PP
These routines convert between Tcl's internal character representation,
UTF-8, and character representations used by various operating systems or
file systems, such as Unicode, ASCII, or Shift-JIS.  When operating on
strings, such as such as obtaining the names of files or displaying
characters using international fonts, the strings must be translated into
one or possibly multiple formats that the various system calls can use.  For
instance, on a Japanese Unix workstation, a user might obtain a filename
represented in the EUC-JP file encoding and then translate the characters to
the jisx0208 font encoding in order to display the filename in a Tk widget.
The purpose of the encoding package is to help bridge the translation gap.
UTF-8 provides an intermediate staging ground for all the various
encodings.  In the example above, text would be translated into UTF-8 from
whatever file encoding the operating system is using.  Then it would be
translated from UTF-8 into whatever font encoding the display routines
require.
.PP
Some basic encodings are compiled into Tcl.  Others can be defined by the
user or dynamically loaded from encoding files in a
platform-independent manner.
.SH DESCRIPTION
.PP
\fBTcl_GetEncoding\fR finds an encoding given its \fIname\fR.  The name may
refer to a built-in Tcl encoding, a user-defined encoding registered by
calling \fBTcl_CreateEncoding\fR, or a dynamically-loadable encoding
file.  The return value is a token that represents the encoding and can be
used in subsequent calls to procedures such as \fBTcl_GetEncodingName\fR,
\fBTcl_FreeEncoding\fR, and \fBTcl_UtfToExternal\fR.  If the name did not
refer to any known or loadable encoding, NULL is returned and an error
message is returned in \fIinterp\fR.
.PP
The encoding package maintains a database of all encodings currently in use.
The first time \fIname\fR is seen, \fBTcl_GetEncoding\fR returns an
encoding with a reference count of 1.  If the same \fIname\fR is requested
further times, then the reference count for that encoding is incremented
without the overhead of allocating a new encoding and all its associated
data structures.  
.PP
When an \fIencoding\fR is no longer needed, \fBTcl_FreeEncoding\fR
should be called to release it.  When an \fIencoding\fR is no longer in use
anywhere (i.e., it has been freed as many times as it has been gotten)
\fBTcl_FreeEncoding\fR will release all storage the encoding was using
and delete it from the database. 
.PP
.VS 8.5
\fBTcl_GetEncodingFromObj\fR treats the string representation of
\fIobjPtr\fR as an encoding name, and finds an encoding with that
name, just as \fBTcl_GetEncoding\fR does. When an encoding is found,
it is cached within the \fBobjPtr\fR value for future reference, the
\fBTcl_Encoding\fR token is written to the storage pointed to by
\fIencodingPtr\fR, and the value \fBTCL_OK\fR is returned. If no such
encoding is found, the value \fBTCL_ERROR\fR is returned, and no
writing to \fB*\fR\fIencodingPtr\fR takes place. Just as with
\fBTcl_GetEncoding\fR, the caller should call \fBTcl_FreeEncoding\fR
on the resulting encoding token when that token will no longer be
used.
.VE 8.5
.PP
\fBTcl_ExternalToUtfDString\fR converts a source buffer \fIsrc\fR from the
specified \fIencoding\fR into UTF-8.  The converted bytes are stored in 
\fIdstPtr\fR, which is then null-terminated.  The caller should eventually
call \fBTcl_DStringFree\fR to free any information stored in \fIdstPtr\fR.
When converting, if any of the characters in the source buffer cannot be
represented in the target encoding, a default fallback character will be
used.  The return value is a pointer to the value stored in the DString.
.PP
\fBTcl_ExternalToUtf\fR converts a source buffer \fIsrc\fR from the specified
\fIencoding\fR into UTF-8.  Up to \fIsrcLen\fR bytes are converted from the
source buffer and up to \fIdstLen\fR converted bytes are stored in \fIdst\fR.
In all cases, \fI*srcReadPtr\fR is filled with the number of bytes that were
successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR is filled with
the corresponding number of bytes that were stored in \fIdst\fR.  The return
value is one of the following:
.RS
.IP \fBTCL_OK\fR 29
All bytes of \fIsrc\fR were converted.
.IP \fBTCL_CONVERT_NOSPACE\fR 29
The destination buffer was not large enough for all of the converted data; as
many characters as could fit were converted though.
.IP \fBTCL_CONVERT_MULTIBYTE\fR 29
The last few bytes in the source buffer were the beginning of a multibyte
sequence, but more bytes were needed to complete this sequence.  A
subsequent call to the conversion routine should pass a buffer containing
the unconverted bytes that remained in \fIsrc\fR plus some further bytes
from the source stream to properly convert the formerly split-up multibyte
sequence.  
.IP \fBTCL_CONVERT_SYNTAX\fR 29
The source buffer contained an invalid character sequence.  This may occur
if the input stream has been damaged or if the input encoding method was
misidentified.
.IP \fBTCL_CONVERT_UNKNOWN\fR 29
The source buffer contained a character that could not be represented in
the target encoding and \fBTCL_ENCODING_STOPONERROR\fR was specified.  
.RE
.LP
\fBTcl_UtfToExternalDString\fR converts a source buffer \fIsrc\fR from UTF-8 
into the specified \fIencoding\fR.  The converted bytes are stored in
\fIdstPtr\fR, which is then terminated with the appropriate encoding-specific
null.  The caller should eventually call \fBTcl_DStringFree\fR to free any
information stored in \fIdstPtr\fR.  When converting, if any of the
characters in the source buffer cannot be represented in the target
encoding, a default fallback character will be used.  The return value is
a pointer to the value stored in the DString.
.PP
\fBTcl_UtfToExternal\fR converts a source buffer \fIsrc\fR from UTF-8 into
the specified \fIencoding\fR.  Up to \fIsrcLen\fR bytes are converted from
the source buffer and up to \fIdstLen\fR converted bytes are stored in
\fIdst\fR.  In all cases, \fI*srcReadPtr\fR is filled with the number of
bytes that were successfully converted from \fIsrc\fR and \fI*dstWrotePtr\fR
is filled with the corresponding number of bytes that were stored in
\fIdst\fR.  The return values are the same as the return values for
\fBTcl_ExternalToUtf\fR.
.PP
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR are
Windows-only convenience
functions for converting between UTF-8 and Windows strings.  On Windows 95
(as with the Unix operating system),
all strings exchanged between Tcl and the operating system are
.QW "char"
based.  On Windows NT, some strings exchanged between Tcl and the
operating system are
.QW "char"
oriented while others are in Unicode.  By
convention, in Windows a TCHAR is a character in the ANSI code page
on Windows 95 and a Unicode character on Windows NT.
.PP
If you planned to use the same
.QW "char"
based interfaces on both Windows
95 and Windows NT, you could use \fBTcl_UtfToExternal\fR and
\fBTcl_ExternalToUtf\fR (or their \fBTcl_DString\fR equivalents) with an
encoding of NULL (the current system encoding).  On the other hand,
if you planned to use the Unicode interface when running on Windows NT
and the
.QW "char"
interfaces when running on Windows 95, you would have
to perform the following type of test over and over in your program
(as represented in pseudo-code):
.CS
if (running NT) {
    encoding <- Tcl_GetEncoding("unicode");
    nativeBuffer <- Tcl_UtfToExternal(encoding, utfBuffer);
    Tcl_FreeEncoding(encoding);
} else {
    nativeBuffer <- Tcl_UtfToExternal(NULL, utfBuffer);
}
.CE
\fBTcl_WinUtfToTChar\fR and \fBTcl_WinTCharToUtf\fR automatically
handle this test and use the proper encoding based on the current
operating system.  \fBTcl_WinUtfToTChar\fR returns a pointer to
a TCHAR string, and \fBTcl_WinTCharToUtf\fR expects a TCHAR string
pointer as the \fIsrc\fR string.  Otherwise, these functions
behave identically to \fBTcl_UtfToExternalDString\fR and
\fBTcl_ExternalToUtfDString\fR.
.PP
\fBTcl_GetEncodingName\fR is roughly the inverse of \fBTcl_GetEncoding\fR.
Given an \fIencoding\fR, the return value is the \fIname\fR argument that
was used to create the encoding.  The string returned by 
\fBTcl_GetEncodingName\fR is only guaranteed to persist until the
\fIencoding\fR is deleted.  The caller must not modify this string.
.PP
\fBTcl_SetSystemEncoding\fR sets the default encoding that should be used
whenever the user passes a NULL value for the \fIencoding\fR argument to
any of the other encoding functions.  If \fIname\fR is NULL, the system
encoding is reset to the default system encoding, \fBbinary\fR.  If the
name did not refer to any known or loadable encoding, \fBTCL_ERROR\fR is
returned and an error message is left in \fIinterp\fR.  Otherwise, this
procedure increments the reference count of the new system encoding,
decrements the reference count of the old system encoding, and returns
\fBTCL_OK\fR.
.PP
.VS 8.5
\fBTcl_GetEncodingNameFromEnvironment\fR provides a means for the Tcl
library to report the encoding name it believes to be the correct one
to use as the system encoding, based on system calls and examination of
the environment suitable for the platform.  It accepts \fIbufPtr\fR,
a pointer to an uninitialized or freed \fBTcl_DString\fR and writes
the encoding name to it.  The \fBTcl_DStringValue\fR is returned.
.VE 8.5
.PP
\fBTcl_GetEncodingNames\fR sets the \fIinterp\fR result to a list
consisting of the names of all the encodings that are currently defined
or can be dynamically loaded, searching the encoding path specified by
\fBTcl_SetDefaultEncodingDir\fR.  This procedure does not ensure that the
dynamically-loadable encoding files contain valid data, but merely that they
exist.
.PP
\fBTcl_CreateEncoding\fR defines a new encoding and registers the C
procedures that are called back to convert between the encoding and
UTF-8.  Encodings created by \fBTcl_CreateEncoding\fR are thereafter
visible in the database used by \fBTcl_GetEncoding\fR.  Just as with the
\fBTcl_GetEncoding\fR procedure, the return value is a token that
represents the encoding and can be used in subsequent calls to other
encoding functions.  \fBTcl_CreateEncoding\fR returns an encoding with a
reference count of 1. If an encoding with the specified \fIname\fR
already exists, then its entry in the database is replaced with the new
encoding; the token for the old encoding will remain valid and continue
to behave as before, but users of the new token will now call the new
encoding procedures.  
.PP
The \fItypePtr\fR argument to \fBTcl_CreateEncoding\fR contains information 
about the name of the encoding and the procedures that will be called to
convert between this encoding and UTF-8.  It is defined as follows:
.PP
.CS
typedef struct Tcl_EncodingType {
        const char *\fIencodingName\fR;
        Tcl_EncodingConvertProc *\fItoUtfProc\fR;
        Tcl_EncodingConvertProc *\fIfromUtfProc\fR;
        Tcl_EncodingFreeProc *\fIfreeProc\fR;
        ClientData \fIclientData\fR;
        int \fInullSize\fR;
} Tcl_EncodingType;  
.CE
.PP
The \fIencodingName\fR provides a string name for the encoding, by
which it can be referred in other procedures such as
\fBTcl_GetEncoding\fR.  The \fItoUtfProc\fR refers to a callback
procedure to invoke to convert text from this encoding into UTF-8.
The \fIfromUtfProc\fR refers to a callback procedure to invoke to
convert text from UTF-8 into this encoding.  The \fIfreeProc\fR refers
to a callback procedure to invoke when this encoding is deleted.  The
\fIfreeProc\fR field may be NULL.  The \fIclientData\fR contains an
arbitrary one-word value passed to \fItoUtfProc\fR, \fIfromUtfProc\fR,
and \fIfreeProc\fR whenever they are called.  Typically, this is a
pointer to a data structure containing encoding-specific information
that can be used by the callback procedures.  For instance, two very
similar encodings such as \fBascii\fR and \fBmacRoman\fR may use the
same callback procedure, but use different values of \fIclientData\fR
to control its behavior.  The \fInullSize\fR specifies the number of
zero bytes that signify end-of-string in this encoding.  It must be
\fB1\fR (for single-byte or multi-byte encodings like ASCII or
Shift-JIS) or \fB2\fR (for double-byte encodings like Unicode).
Constant-sized encodings with 3 or more bytes per character (such as
CNS11643) are not accepted.
.PP
The callback procedures \fItoUtfProc\fR and \fIfromUtfProc\fR should match the
type \fBTcl_EncodingConvertProc\fR:
.PP
.CS
typedef int Tcl_EncodingConvertProc(
        ClientData \fIclientData\fR,
        const char *\fIsrc\fR, 
        int \fIsrcLen\fR, 
        int \fIflags\fR, 
        Tcl_EncodingState *\fIstatePtr\fR,
        char *\fIdst\fR, 
        int \fIdstLen\fR, 
        int *\fIsrcReadPtr\fR,
        int *\fIdstWrotePtr\fR,
        int *\fIdstCharsPtr\fR);
.CE
.PP
The \fItoUtfProc\fR and \fIfromUtfProc\fR procedures are called by the
\fBTcl_ExternalToUtf\fR or \fBTcl_UtfToExternal\fR family of functions to
perform the actual conversion.  The \fIclientData\fR parameter to these
procedures is the same as the \fIclientData\fR field specified to
\fBTcl_CreateEncoding\fR when the encoding was created.  The remaining
arguments to the callback procedures are the same as the arguments,
documented at the top, to \fBTcl_ExternalToUtf\fR or
\fBTcl_UtfToExternal\fR, with the following exceptions.  If the
\fIsrcLen\fR argument to one of those high-level functions is negative,
the value passed to the callback procedure will be the appropriate
encoding-specific string length of \fIsrc\fR.  If any of the \fIsrcReadPtr\fR, 
\fIdstWrotePtr\fR, or \fIdstCharsPtr\fR arguments to one of the high-level
functions is NULL, the corresponding value passed to the callback
procedure will be a non-NULL location.
.PP
The callback procedure \fIfreeProc\fR, if non-NULL, should match the type 
\fBTcl_EncodingFreeProc\fR:
.CS
typedef void Tcl_EncodingFreeProc(
        ClientData \fIclientData\fR);
.CE
.PP
This \fIfreeProc\fR function is called when the encoding is deleted.  The
\fIclientData\fR parameter is the same as the \fIclientData\fR field
specified to \fBTcl_CreateEncoding\fR when the encoding was created.  
.PP
.VS 8.5
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR
are called to access and set the list of filesystem directories searched
for encoding data files.  
.PP
The value returned by \fBTcl_GetEncodingSearchPath\fR
is the value stored by the last successful call to
\fBTcl_SetEncodingSearchPath\fR.  If no calls to
\fBTcl_SetEncodingSearchPath\fR have occurred, Tcl will compute an initial
value based on the environment.  There is one encoding search path for the
entire process, shared by all threads in the process.
.PP
\fBTcl_SetEncodingSearchPath\fR stores \fIsearchPath\fR and returns
\fBTCL_OK\fR, unless \fIsearchPath\fR is not a valid Tcl list, which
causes \fBTCL_ERROR\fR to be returned.  The elements of \fIsearchPath\fR
are not verified as existing readable filesystem directories.  When
searching for encoding data files takes place, and non-existent or
non-readable filesystem directories on the \fIsearchPath\fR are silently
ignored.
.PP
\fBTcl_GetDefaultEncodingDir\fR and \fBTcl_SetDefaultEncodingDir\fR
are obsolete interfaces best replaced with calls to
\fBTcl_GetEncodingSearchPath\fR and \fBTcl_SetEncodingSearchPath\fR.
They are called to access and set the first element of the \fIsearchPath\fR
list.  Since Tcl searches \fIsearchPath\fR for encoding data files in
list order, these routines establish the
.QW default
directory in which to find encoding data files.
.VE 8.5
.SH "ENCODING FILES"
Space would prohibit precompiling into Tcl every possible encoding
algorithm, so many encodings are stored on disk as dynamically-loadable
encoding files.  This behavior also allows the user to create additional
encoding files that can be loaded using the same mechanism.  These
encoding files contain information about the tables and/or escape
sequences used to map between an external encoding and Unicode.  The
external encoding may consist of single-byte, multi-byte, or double-byte
characters.  
.PP
Each dynamically-loadable encoding is represented as a text file.  The
initial line of the file, beginning with a
.QW #
symbol, is a comment
that provides a human-readable description of the file.  The next line
identifies the type of encoding file.  It can be one of the following
letters:
.IP "[1] \fBS\fR"
A single-byte encoding, where one character is always one byte long in the
encoding.  An example is \fBiso8859-1\fR, used by many European languages.
.IP "[2] \fBD\fR"
A double-byte encoding, where one character is always two bytes long in the
encoding.  An example is \fBbig5\fR, used for Chinese text.
.IP "[3] \fBM\fR"
A multi-byte encoding, where one character may be either one or two bytes long.
Certain bytes are lead bytes, indicating that another byte must follow
and that together the two bytes represent one character.  Other bytes are not
lead bytes and represent themselves.  An example is \fBshiftjis\fR, used by
many Japanese computers.
.IP "[4] \fBE\fR"
An escape-sequence encoding, specifying that certain sequences of bytes
do not represent characters, but commands that describe how following bytes
should be interpreted.  
.PP
The rest of the lines in the file depend on the type.  
.PP
Cases [1], [2], and [3] are collectively referred to as table-based encoding
files.  The lines in a table-based encoding file are in the same
format as this example taken from the \fBshiftjis\fR encoding (this is not
the complete file):
.CS
# Encoding file: shiftjis, multi-byte
M
003F 0 40
00
0000000100020003000400050006000700080009000A000B000C000D000E000F
0010001100120013001400150016001700180019001A001B001C001D001E001F
0020002100220023002400250026002700280029002A002B002C002D002E002F
0030003100320033003400350036003700380039003A003B003C003D003E003F
0040004100420043004400450046004700480049004A004B004C004D004E004F
0050005100520053005400550056005700580059005A005B005C005D005E005F
0060006100620063006400650066006700680069006A006B006C006D006E006F
0070007100720073007400750076007700780079007A007B007C007D203E007F
0080000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000FF61FF62FF63FF64FF65FF66FF67FF68FF69FF6AFF6BFF6CFF6DFF6EFF6F
FF70FF71FF72FF73FF74FF75FF76FF77FF78FF79FF7AFF7BFF7CFF7DFF7EFF7F
FF80FF81FF82FF83FF84FF85FF86FF87FF88FF89FF8AFF8BFF8CFF8DFF8EFF8F
FF90FF91FF92FF93FF94FF95FF96FF97FF98FF99FF9AFF9BFF9CFF9DFF9EFF9F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
81
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
300030013002FF0CFF0E30FBFF1AFF1BFF1FFF01309B309C00B4FF4000A8FF3E
FFE3FF3F30FD30FE309D309E30034EDD30053006300730FC20152010FF0F005C
301C2016FF5C2026202520182019201C201DFF08FF0930143015FF3BFF3DFF5B
FF5D30083009300A300B300C300D300E300F30103011FF0B221200B100D70000
00F7FF1D2260FF1CFF1E22662267221E22342642264000B0203220332103FFE5
FF0400A200A3FF05FF03FF06FF0AFF2000A72606260525CB25CF25CE25C725C6
25A125A025B325B225BD25BC203B301221922190219121933013000000000000
000000000000000000000000000000002208220B2286228722822283222A2229
000000000000000000000000000000002227222800AC21D221D4220022030000
0000000000000000000000000000000000000000222022A52312220222072261
2252226A226B221A223D221D2235222B222C0000000000000000000000000000
212B2030266F266D266A2020202100B6000000000000000025EF000000000000
.CE
.PP
The third line of the file is three numbers.  The first number is the
fallback character (in base 16) to use when converting from UTF-8 to this
encoding.  The second number is a \fB1\fR if this file represents the
encoding for a symbol font, or \fB0\fR otherwise.  The last number (in base
10) is how many pages of data follow.  
.PP
Subsequent lines in the example above are pages that describe how to map
from the encoding into 2-byte Unicode.  The first line in a page identifies
the page number.  Following it are 256 double-byte numbers, arranged as 16
rows of 16 numbers.  Given a character in the encoding, the high byte of
that character is used to select which page, and the low byte of that
character is used as an index to select one of the double-byte numbers in
that page \- the value obtained being the corresponding Unicode character.
By examination of the example above, one can see that the characters 0x7E
and 0x8163 in \fBshiftjis\fR map to 203E and 2026 in Unicode, respectively.
.PP
Following the first page will be all the other pages, each in the same
format as the first: one number identifying the page followed by 256
double-byte Unicode characters.  If a character in the encoding maps to the
Unicode character 0000, it means that the character does not actually exist.
If all characters on a page would map to 0000, that page can be omitted.
.PP
Case [4] is the escape-sequence encoding file.  The lines in an this type of
file are in the same format as this example taken from the \fBiso2022-jp\fR
encoding:
.CS
.ta 1.5i
# Encoding file: iso2022-jp, escape-driven
E
init		{}
final		{}
iso8859-1	\ex1b(B
jis0201		\ex1b(J
jis0208		\ex1b$@
jis0208		\ex1b$B
jis0212		\ex1b$(D
gb2312		\ex1b$A
ksc5601		\ex1b$(C
.CE
.PP
In the file, the first column represents an option and the second column
is the associated value.  \fBinit\fR is a string to emit or expect before
the first character is converted, while \fBfinal\fR is a string to emit
or expect after the last character.  All other options are names of
table-based encodings; the associated value is the escape-sequence that
marks that encoding.  Tcl syntax is used for the values; in the above
example, for instance,
.QW \fB{}\fR
represents the empty string and
.QW \fB\ex1b\fR
represents character 27.
.PP
When \fBTcl_GetEncoding\fR encounters an encoding \fIname\fR that has not
been loaded, it attempts to load an encoding file called \fIname\fB.enc\fR
from the \fBencoding\fR subdirectory of each directory that Tcl searches
for its script library.  If the encoding file exists, but is
malformed, an error message will be left in \fIinterp\fR.
.SH KEYWORDS
utf, encoding, convert
                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_Write.3tcl                               0100644 0001750 0001750 00000110560 12566232342 023343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1996-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\"
'\" RCS: @(#) $Id: OpenFileChnl.3,v 1.36 2007/12/13 15:22:31 dgp Exp $
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_OpenFileChannel 3 8.3 Tcl "Tcl Library Procedures"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx, Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw \- buffered I/O facilities using channels
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Channel
\fBTcl_OpenFileChannel\fR(\fIinterp, fileName, mode, permissions\fR)
.sp
Tcl_Channel
\fBTcl_OpenCommandChannel\fR(\fIinterp, argc, argv, flags\fR)
.sp
Tcl_Channel
\fBTcl_MakeFileChannel\fR(\fIhandle, readOrWrite\fR)
.sp
Tcl_Channel
\fBTcl_GetChannel\fR(\fIinterp, channelName, modePtr\fR)
.sp
int
\fBTcl_GetChannelNames\fR(\fIinterp\fR)
.sp
int
\fBTcl_GetChannelNamesEx\fR(\fIinterp, pattern\fR)
.sp
void
\fBTcl_RegisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_UnregisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_DetachChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_IsStandardChannel\fR(\fIchannel\fR)
.sp
int
\fBTcl_Close\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_ReadChars\fR(\fIchannel, readObjPtr, charsToRead, appendFlag\fR)
.sp
int
\fBTcl_Read\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_GetsObj\fR(\fIchannel, lineObjPtr\fR)
.sp
int
\fBTcl_Gets\fR(\fIchannel, lineRead\fR)
.sp
int
\fBTcl_Ungets\fR(\fIchannel, input, inputLen, addAtEnd\fR)
.sp
int
\fBTcl_WriteObj\fR(\fIchannel, writeObjPtr\fR)
.sp
int
\fBTcl_WriteChars\fR(\fIchannel, charBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Write\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_ReadRaw\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_WriteRaw\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Eof\fR(\fIchannel\fR)
.sp
int
\fBTcl_Flush\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBlocked\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBuffered\fR(\fIchannel\fR)
.sp
int
\fBTcl_OutputBuffered\fR(\fIchannel\fR)
.sp
Tcl_WideInt
\fBTcl_Seek\fR(\fIchannel, offset, seekMode\fR)
.sp
Tcl_WideInt
\fBTcl_Tell\fR(\fIchannel\fR)
.sp
.VS 8.5
int
\fBTcl_TruncateChannel\fR(\fIchannel, length\fR)
.VE 8.5
.sp
int
\fBTcl_GetChannelOption\fR(\fIinterp, channel, optionName, optionValue\fR)
.sp
int
\fBTcl_SetChannelOption\fR(\fIinterp, channel, optionName, newValue\fR)
.sp
.SH ARGUMENTS
.AS Tcl_DString *channelName in/out
.AP Tcl_Interp *interp in
Used for error reporting and to look up a channel registered in it.
.AP "const char" *fileName in
The name of a local or network file.
.AP "const char" *mode in
Specifies how the file is to be accessed.  May have any of the values
allowed for the \fImode\fR argument to the Tcl \fBopen\fR command.  
.AP int permissions in
POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.
.AP int argc in
The number of elements in \fIargv\fR.
.AP "const char" **argv in
Arguments for constructing a command pipeline.  These values have the same
meaning as the non-switch arguments to the Tcl \fBexec\fR command.
.AP int flags in
Specifies the disposition of the stdio handles in pipeline: OR-ed
combination of \fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, \fBTCL_STDERR\fR, and
\fBTCL_ENFORCE_MODE\fR. If \fBTCL_STDIN\fR is set, stdin for the first child
in the pipe is the pipe channel, otherwise it is the same as the standard
input of the invoking process; likewise for \fBTCL_STDOUT\fR and
\fBTCL_STDERR\fR. If \fBTCL_ENFORCE_MODE\fR is not set, then the pipe can
redirect stdio handles to override the stdio handles for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR and \fBTCL_STDERR\fR have been set.  If it
is set, then such redirections cause an error.
.AP ClientData handle in
Operating system specific handle for I/O to a file. For Unix this is a
file descriptor, for Windows it is a HANDLE.
.AP int readOrWrite in
OR-ed combination of \fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR to indicate
what operations are valid on \fIhandle\fR.
.AP "const char" *channelName in
The name of the channel. 
.AP int *modePtr out
Points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR denoting whether the channel is
open for reading and writing.
.AP "const char" *pattern in
The pattern to match on, passed to Tcl_StringMatch, or NULL.
.AP Tcl_Channel channel in
A Tcl channel for input or output.  Must have been the return value
from a procedure such as \fBTcl_OpenFileChannel\fR.
.AP Tcl_Obj *readObjPtr in/out
A pointer to a Tcl Object in which to store the characters read from the
channel.
.AP int charsToRead in
The number of characters to read from the channel.  If the channel's encoding 
is \fBbinary\fR, this is equivalent to the number of bytes to read from the 
channel.
.AP int appendFlag in
If non-zero, data read from the channel will be appended to the object.
Otherwise, the data will replace the existing contents of the object.
.AP char *readBuf out
A buffer in which to store the bytes read from the channel.
.AP int bytesToRead in
The number of bytes to read from the channel.  The buffer \fIreadBuf\fR must
be large enough to hold this many bytes.
.AP Tcl_Obj *lineObjPtr in/out
A pointer to a Tcl object in which to store the line read from the
channel.  The line read will be appended to the current value of the
object. 
.AP Tcl_DString *lineRead in/out
A pointer to a Tcl dynamic string in which to store the line read from the
channel.  Must have been initialized by the caller.  The line read will be
appended to any data already in the dynamic string.
.AP "const char" *input in
The input to add to a channel buffer.
.AP int inputLen in
Length of the input
.AP int addAtEnd in
Flag indicating whether the input should be added to the end or
beginning of the channel buffer.
.AP Tcl_Obj *writeObjPtr in
A pointer to a Tcl Object whose contents will be output to the channel.
.AP "const char" *charBuf in
A buffer containing the characters to output to the channel.
.AP "const char" *byteBuf in
A buffer containing the bytes to output to the channel.
.AP int bytesToWrite in
The number of bytes to consume from \fIcharBuf\fR or \fIbyteBuf\fR and
output to the channel.
.AP Tcl_WideInt offset in
How far to move the access point in the channel at which the next input or
output operation will be applied, measured in bytes from the position
given by \fIseekMode\fR.  May be either positive or negative.
.AP int seekMode in
Relative to which point to seek; used with \fIoffset\fR to calculate the new
access point for the channel. Legal values are \fBSEEK_SET\fR,
\fBSEEK_CUR\fR, and \fBSEEK_END\fR.
.AP Tcl_WideInt length in
The (non-negative) length to truncate the channel the channel to.
.AP "const char" *optionName in
The name of an option applicable to this channel, such as \fB\-blocking\fR.
May have any of the values accepted by the \fBfconfigure\fR command.
.AP Tcl_DString *optionValue in
Where to store the value of an option or a list of all options and their
values. Must have been initialized by the caller.
.AP "const char" *newValue in
New value for the option given by \fIoptionName\fR.
.BE

.SH DESCRIPTION
.PP
The Tcl channel mechanism provides a device-independent and
platform-independent mechanism for performing buffered input
and output operations on a variety of file, socket, and device
types.
The channel mechanism is extensible to new channel types, by
providing a low-level channel driver for the new type; the channel driver
interface is described in the manual entry for \fBTcl_CreateChannel\fR. The
channel mechanism provides a buffering scheme modeled after
Unix's standard I/O, and it also allows for nonblocking I/O on
channels.
.PP
The procedures described in this manual entry comprise the C APIs of the
generic layer of the channel architecture. For a description of the channel
driver architecture and how to implement channel drivers for new types of
channels, see the manual entry for \fBTcl_CreateChannel\fR.

.SH TCL_OPENFILECHANNEL
.PP
\fBTcl_OpenFileChannel\fR opens a file specified by \fIfileName\fR and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the \fBfopen\fR procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl \fBopen\fR command when opening a file.
If an error occurs while opening the channel, \fBTcl_OpenFileChannel\fR
returns NULL and records a POSIX error code that can be
retrieved with \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, \fBTcl_OpenFileChannel\fR
leaves an error message in \fIinterp\fR's result after any error.  
As of Tcl 8.4, the object-based API \fBTcl_FSOpenFileChannel\fR should 
be used in preference to \fBTcl_OpenFileChannel\fR wherever possible.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_OPENCOMMANDCHANNEL
.PP
\fBTcl_OpenCommandChannel\fR provides a C-level interface to the
functions of the \fBexec\fR and \fBopen\fR commands.
It creates a sequence of subprocesses specified
by the \fIargv\fR and \fIargc\fR arguments and returns a channel that can
be used to communicate with these subprocesses.
The \fIflags\fR argument indicates what sort of communication will
exist with the command pipeline.
.PP
If the \fBTCL_STDIN\fR flag is set then the standard input for the
first subprocess will be tied to the channel: writing to the channel
will provide input to the subprocess.  If \fBTCL_STDIN\fR is not set,
then standard input for the first subprocess will be the same as this
application's standard input.  If \fBTCL_STDOUT\fR is set then
standard output from the last subprocess can be read from the channel;
otherwise it goes to this application's standard output.  If
\fBTCL_STDERR\fR is set, standard error output for all subprocesses is
returned to the channel and results in an error when the channel is
closed; otherwise it goes to this application's standard error.  If
\fBTCL_ENFORCE_MODE\fR is not set, then \fIargc\fR and \fIargv\fR can
redirect the stdio handles to override \fBTCL_STDIN\fR,
\fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR; if it is set, then it is an
error for argc and argv to override stdio channels for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR have been set.
.PP
If an error occurs while opening the channel, \fBTcl_OpenCommandChannel\fR
returns NULL and records a POSIX error code that can be retrieved with
\fBTcl_GetErrno\fR.
In addition, \fBTcl_OpenCommandChannel\fR leaves an error message in
the interpreter's result if \fIinterp\fR is not NULL.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_MAKEFILECHANNEL
.PP
\fBTcl_MakeFileChannel\fR makes a \fBTcl_Channel\fR from an existing,
platform-specific, file handle.
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_GETCHANNEL
.PP
\fBTcl_GetChannel\fR returns a channel given the \fIchannelName\fR used to
create it with \fBTcl_CreateChannel\fR and a pointer to a Tcl interpreter in
\fIinterp\fR. If a channel by that name is not registered in that interpreter,
the procedure returns NULL. If the \fImodePtr\fR argument is not NULL, it
points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR describing whether the channel is
open for reading and writing.
.PP
\fBTcl_GetChannelNames\fR and \fBTcl_GetChannelNamesEx\fR write the
names of the registered channels to the interpreter's result as a
list object.  \fBTcl_GetChannelNamesEx\fR will filter these names
according to the \fIpattern\fR.  If \fIpattern\fR is NULL, then it
will not do any filtering.  The return value is \fBTCL_OK\fR if no
errors occurred writing to the result, otherwise it is \fBTCL_ERROR\fR,
and the error message is left in the interpreter's result.

.SH TCL_REGISTERCHANNEL
.PP
\fBTcl_RegisterChannel\fR adds a channel to the set of channels accessible
in \fIinterp\fR. After this call, Tcl programs executing in that
interpreter can refer to the channel in input or output operations using
the name given in the call to \fBTcl_CreateChannel\fR.  After this call,
the channel becomes the property of the interpreter, and the caller should
not call \fBTcl_Close\fR for the channel; the channel will be closed
automatically when it is unregistered from the interpreter.
.PP
Code executing outside of any Tcl interpreter can call
\fBTcl_RegisterChannel\fR with \fIinterp\fR as NULL, to indicate that it
wishes to hold a reference to this channel. Subsequently, the channel can
be registered in a Tcl interpreter and it will only be closed when the
matching number of calls to \fBTcl_UnregisterChannel\fR have been made.
This allows code executing outside of any interpreter to safely hold a
reference to a channel that is also registered in a Tcl interpreter.
.PP
This procedure interacts with the code managing the standard
channels. If no standard channels were initialized before the first
call to \fBTcl_RegisterChannel\fR, they will get initialized by that
call. See \fBTcl_StandardChannels\fR for a general treatise about
standard channels and the behaviour of the Tcl library with regard to
them.

.SH TCL_UNREGISTERCHANNEL
.PP
\fBTcl_UnregisterChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
If this operation removed the last registration of the channel in any
interpreter, the channel is also closed and destroyed.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_UnregisterChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, it will now be closed.  \fBTcl_UnregisterChannel\fR
is very similar to \fBTcl_DetachChannel\fR except that it will also
close the channel if no further references to it exist.

.SH TCL_DETACHCHANNEL
.PP
\fBTcl_DetachChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
Beyond that, this command has no further effect.  It cannot be used on
the standard channels (stdout, stderr, stdin), and will return
\fBTCL_ERROR\fR if passed one of those channels.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_DetachChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, unlike \fBTcl_UnregisterChannel\fR, 
it will not be closed.

.SH TCL_ISSTANDARDCHANNEL
.PP
\fBTcl_IsStandardChannel\fR tests whether a channel is one of the
three standard channels, stdin, stdout or stderr.  If so, it returns
1, otherwise 0.
.PP
No attempt is made to check whether the given channel or the standard 
channels are initialized or otherwise valid.

.SH TCL_CLOSE
.PP
\fBTcl_Close\fR destroys the channel \fIchannel\fR, which must denote a
currently open channel. The channel should not be registered in any
interpreter when \fBTcl_Close\fR is called. Buffered output is flushed to
the channel's output device prior to destroying the channel, and any
buffered input is discarded.  If this is a blocking channel, the call does
not return until all buffered data is successfully sent to the channel's
output device.  If this is a nonblocking channel and there is buffered
output that cannot be written without blocking, the call returns
immediately; output is flushed in the background and the channel will be
closed once all of the buffered data has been output.  In this case errors
during flushing are not reported.
.PP
If the channel was closed successfully, \fBTcl_Close\fR returns \fBTCL_OK\fR.
If an error occurs, \fBTcl_Close\fR returns \fBTCL_ERROR\fR and records a
POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.
If the channel is being closed synchronously and an error occurs during
closing of the channel and \fIinterp\fR is not NULL, an error message is
left in the interpreter's result.
.PP
Note: it is not safe to call \fBTcl_Close\fR on a channel that has been
registered using \fBTcl_RegisterChannel\fR; see the documentation for
\fBTcl_RegisterChannel\fR, above, for details. If the channel has ever
been given as the \fBchan\fR argument in a call to
\fBTcl_RegisterChannel\fR, you should instead use
\fBTcl_UnregisterChannel\fR, which will internally call \fBTcl_Close\fR
when all calls to \fBTcl_RegisterChannel\fR have been matched by
corresponding calls to \fBTcl_UnregisterChannel\fR.

.SH "TCL_READCHARS AND TCL_READ"
.PP
\fBTcl_ReadChars\fR consumes bytes from \fIchannel\fR, converting the bytes
to UTF-8 based on the channel's encoding and storing the produced data in 
\fIreadObjPtr\fR's string representation.  The return value of
\fBTcl_ReadChars\fR is the number of characters, up to \fIcharsToRead\fR,
that were stored in \fIreadObjPtr\fR.  If an error occurs while reading, the
return value is \-1 and \fBTcl_ReadChars\fR records a POSIX error code that
can be retrieved with \fBTcl_GetErrno\fR.
.PP
Setting \fIcharsToRead\fR to \fB\-1\fR will cause the command to read
all characters currently available (non-blocking) or everything until
eof (blocking mode).
.PP
The return value may be smaller than the value to read, indicating that less
data than requested was available.  This is called a \fIshort read\fR.  In
blocking mode, this can only happen on an end-of-file.  In nonblocking mode,
a short read can also occur if there is not enough input currently
available:  \fBTcl_ReadChars\fR returns a short count rather than waiting
for more data.
.PP
If the channel is in blocking mode, a return value of zero indicates an
end-of-file condition.  If the channel is in nonblocking mode, a return
value of zero indicates either that no input is currently available or an
end-of-file condition.  Use \fBTcl_Eof\fR and \fBTcl_InputBlocked\fR to tell
which of these conditions actually occurred.
.PP
\fBTcl_ReadChars\fR translates the various end-of-line representations into
the canonical \fB\en\fR internal representation according to the current
end-of-line recognition mode.  End-of-line recognition and the various
platform-specific modes are described in the manual entry for the Tcl
\fBfconfigure\fR command.
.PP
As a performance optimization, when reading from a channel with the encoding
\fBbinary\fR, the bytes are not converted to UTF-8 as they are read.
Instead, they are stored in \fIreadObjPtr\fR's internal representation as a
byte-array object.  The string representation of this object will only be
constructed if it is needed (e.g., because of a call to
\fBTcl_GetStringFromObj\fR).  In this way, byte-oriented data can be read
from a channel, manipulated by calling \fBTcl_GetByteArrayFromObj\fR and
related functions, and then written to a channel without the expense of ever
converting to or from UTF-8.
.PP
\fBTcl_Read\fR is similar to \fBTcl_ReadChars\fR, except that it does not do
encoding conversions, regardless of the channel's encoding.  It is deprecated
and exists for backwards compatibility with non-internationalized Tcl
extensions.  It consumes bytes from \fIchannel\fR and stores them in
\fIreadBuf\fR, performing end-of-line translations on the way.  The return value
of \fBTcl_Read\fR is the number of bytes, up to \fIbytesToRead\fR, written in
\fIreadBuf\fR.  The buffer produced by \fBTcl_Read\fR is not null-terminated.
Its contents are valid from the zeroth position up to and excluding the
position indicated by the return value.  
.PP
\fBTcl_ReadRaw\fR is the same as \fBTcl_Read\fR but does not
compensate for stacking. While \fBTcl_Read\fR (and the other functions
in the API) always get their data from the topmost channel in the
stack the supplied channel is part of, \fBTcl_ReadRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the channel below into the transformation.

.SH "TCL_GETSOBJ AND TCL_GETS"
.PP
\fBTcl_GetsObj\fR consumes bytes from \fIchannel\fR, converting the bytes to
UTF-8 based on the channel's encoding, until a full line of input has been
seen.  If the channel's encoding is \fBbinary\fR, each byte read from the
channel is treated as an individual Unicode character.  All of the
characters of the line except for the terminating end-of-line character(s)
are appended to \fIlineObjPtr\fR's string representation.  The end-of-line
character(s) are read and discarded.
.PP
If a line was successfully read, the return value is greater than or equal
to zero and indicates the number of bytes stored in \fIlineObjPtr\fR.  If an
error occurs, \fBTcl_GetsObj\fR returns \-1 and records a POSIX error code
that can be retrieved with \fBTcl_GetErrno\fR.  \fBTcl_GetsObj\fR also
returns \-1 if the end of the file is reached; the \fBTcl_Eof\fR procedure
can be used to distinguish an error from an end-of-file condition.
.PP
If the channel is in nonblocking mode, the return value can also be \-1 if
no data was available or the data that was available did not contain an
end-of-line character.  When \-1 is returned, the \fBTcl_InputBlocked\fR
procedure may be invoked to determine if the channel is blocked because
of input unavailability.
.PP
\fBTcl_Gets\fR is the same as \fBTcl_GetsObj\fR except the resulting
characters are appended to the dynamic string given by
\fIlineRead\fR rather than a Tcl object.

.SH "TCL_UNGETS"
.PP
\fBTcl_Ungets\fR is used to add data to the input queue of a channel,
at either the head or tail of the queue.  The pointer \fIinput\fR points
to the data that is to be added.  The length of the input to add is given
by \fIinputLen\fR.  A non-zero value of \fIaddAtEnd\fR indicates that the
data is to be added at the end of queue; otherwise it will be added at the
head of the queue.  If \fIchannel\fR has a
.QW sticky
EOF set, no data will be
added to the input queue.  \fBTcl_Ungets\fR returns \fIinputLen\fR or
\-1 if an error occurs.

.SH "TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE"
.PP
\fBTcl_WriteChars\fR accepts \fIbytesToWrite\fR bytes of character data at
\fIcharBuf\fR.  The UTF-8 characters in the buffer are converted to the
channel's encoding and queued for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_WriteChars\fR expects \fIcharBuf\fR
to be null-terminated and it outputs everything up to the null.
.PP
Data queued for output may not appear on the output device immediately, due
to internal buffering.  If the data should appear immediately, call
\fBTcl_Flush\fR after the call to \fBTcl_WriteChars\fR, or set the 
\fB\-buffering\fR option on the channel to \fBnone\fR.  If you wish the data
to appear as soon as a complete line is accepted for output, set the
\fB\-buffering\fR option on the channel to \fBline\fR mode.
.PP
The return value of \fBTcl_WriteChars\fR is a count of how many bytes were
accepted for output to the channel.  This is either greater than zero to
indicate success or \-1 to indicate that an error occurred.  If an error
occurs, \fBTcl_WriteChars\fR records a POSIX error code that may be
retrieved with \fBTcl_GetErrno\fR.
.PP
Newline characters in the output data are translated to platform-specific
end-of-line sequences according to the \fB\-translation\fR option for the
channel.  This is done even if the channel has no encoding.
.PP
\fBTcl_WriteObj\fR is similar to \fBTcl_WriteChars\fR except it
accepts a Tcl object whose contents will be output to the channel.  The
UTF-8 characters in \fIwriteObjPtr\fR's string representation are converted
to the channel's encoding and queued for output to \fIchannel\fR.  
As a performance optimization, when writing to a channel with the encoding
\fBbinary\fR, UTF-8 characters are not converted as they are written.
Instead, the bytes in \fIwriteObjPtr\fR's internal representation as a
byte-array object are written to the channel.  The byte-array representation
of the object will be constructed if it is needed.  In this way,
byte-oriented data can be read from a channel, manipulated by calling
\fBTcl_GetByteArrayFromObj\fR and related functions, and then written to a
channel without the expense of ever converting to or from UTF-8.
.PP
\fBTcl_Write\fR is similar to \fBTcl_WriteChars\fR except that it does not do
encoding conversions, regardless of the channel's encoding.  It is
deprecated and exists for backwards compatibility with non-internationalized
Tcl extensions.  It accepts \fIbytesToWrite\fR bytes of data at
\fIbyteBuf\fR and queues them for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_Write\fR expects \fIbyteBuf\fR to be
null-terminated and it outputs everything up to the null.
.PP
\fBTcl_WriteRaw\fR is the same as \fBTcl_Write\fR but does not
compensate for stacking. While \fBTcl_Write\fR (and the other
functions in the API) always feed their input to the topmost channel
in the stack the supplied channel is part of, \fBTcl_WriteRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the transformation into the channel below
it.

.SH TCL_FLUSH
.PP
\fBTcl_Flush\fR causes all of the buffered output data for \fIchannel\fR
to be written to its underlying file or device as soon as possible.
If the channel is in blocking mode, the call does not return until
all the buffered data has been sent to the channel or some error occurred.
The call returns immediately if the channel is nonblocking; it starts
a background flush that will write the buffered data to the channel
eventually, as fast as the channel is able to absorb it.
.PP
The return value is normally \fBTCL_OK\fR.
If an error occurs, \fBTcl_Flush\fR returns \fBTCL_ERROR\fR and
records a POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.

.SH TCL_SEEK
.PP
\fBTcl_Seek\fR moves the access point in \fIchannel\fR where subsequent
data will be read or written. Buffered output is flushed to the channel and
buffered input is discarded, prior to the seek operation.
.PP
\fBTcl_Seek\fR normally returns the new access point.
If an error occurs, \fBTcl_Seek\fR returns \-1 and records a POSIX error
code that can be retrieved with \fBTcl_GetErrno\fR.
After an error, the access point may or may not have been moved.

.SH TCL_TELL
.PP
\fBTcl_Tell\fR returns the current access point for a channel. The returned
value is \-1 if the channel does not support seeking.

.SH TCL_TRUNCATECHANNEL
.PP
.VS 8.5
\fBTcl_TruncateChannel\fR truncates the file underlying \fIchannel\fR
to a given \fIlength\fR of bytes. It returns \fBTCL_OK\fR if the
operation succeeded, and \fBTCL_ERROR\fR otherwise.
.VE 8.5

.SH TCL_GETCHANNELOPTION
.PP
\fBTcl_GetChannelOption\fR retrieves, in \fIoptionValue\fR, the value of one of
the options currently in effect for a channel, or a list of all options and
their values.  The \fIchannel\fR argument identifies the channel for which
to query an option or retrieve all options and their values.
If \fIoptionName\fR is not NULL, it is the name of the
option to query; the option's value is copied to the Tcl dynamic string
denoted by \fIoptionValue\fR. If
\fIoptionName\fR is NULL, the function stores an alternating list of option
names and their values in \fIoptionValue\fR, using a series of calls to
\fBTcl_DStringAppendElement\fR. The various preexisting options and
their possible values are described in the manual entry for the Tcl
\fBfconfigure\fR command. Other options can be added by each channel type.
These channel type specific options are described in the manual entry for
the Tcl command that creates a channel of that type; for example, the
additional options for TCP based channels are described in the manual entry
for the Tcl \fBsocket\fR command.
The procedure normally returns \fBTCL_OK\fR. If an error occurs, it returns
\fBTCL_ERROR\fR and calls \fBTcl_SetErrno\fR to store an appropriate POSIX
error code.

.SH TCL_SETCHANNELOPTION
.PP
\fBTcl_SetChannelOption\fR sets a new value \fInewValue\fR
for an option \fIoptionName\fR on \fIchannel\fR.
The procedure normally returns \fBTCL_OK\fR.  If an error occurs,
it returns \fBTCL_ERROR\fR;  in addition, if \fIinterp\fR is non-NULL,
\fBTcl_SetChannelOption\fR leaves an error message in the interpreter's result.

.SH TCL_EOF
.PP
\fBTcl_Eof\fR returns a nonzero value if \fIchannel\fR encountered
an end of file during the last input operation.

.SH TCL_INPUTBLOCKED
.PP
\fBTcl_InputBlocked\fR returns a nonzero value if \fIchannel\fR is in
nonblocking mode and the last input operation returned less data than
requested because there was insufficient data available.
The call always returns zero if the channel is in blocking mode.

.SH TCL_INPUTBUFFERED
.PP
\fBTcl_InputBuffered\fR returns the number of bytes of input currently
buffered in the internal buffers for a channel. If the channel is not open
for reading, this function always returns zero.

.SH TCL_OUTPUTBUFFERED
\fBTcl_OutputBuffered\fR returns the number of bytes of output
currently buffered in the internal buffers for a channel. If the
channel is not open for writing, this function always returns zero.

.SH "PLATFORM ISSUES"
.PP
The handles returned from \fBTcl_GetChannelHandle\fR depend on the
platform and the channel type.  On Unix platforms, the handle is
always a Unix file descriptor as returned from the \fBopen\fR system
call.  On Windows platforms, the handle is a file \fBHANDLE\fR when
the channel was created with \fBTcl_OpenFileChannel\fR,
\fBTcl_OpenCommandChannel\fR, or \fBTcl_MakeFileChannel\fR.  Other
channel types may return a different type of handle on Windows
platforms.

.SH "SEE ALSO"
DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3)

.SH KEYWORDS
access point, blocking, buffered I/O, channel, channel driver, end of file,
flush, input, nonblocking, output, read, seek, write
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WriteChars.3tcl                          0100644 0001750 0001750 00000110560 12566232342 024324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1996-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\"
'\" RCS: @(#) $Id: OpenFileChnl.3,v 1.36 2007/12/13 15:22:31 dgp Exp $
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_OpenFileChannel 3 8.3 Tcl "Tcl Library Procedures"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx, Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw \- buffered I/O facilities using channels
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Channel
\fBTcl_OpenFileChannel\fR(\fIinterp, fileName, mode, permissions\fR)
.sp
Tcl_Channel
\fBTcl_OpenCommandChannel\fR(\fIinterp, argc, argv, flags\fR)
.sp
Tcl_Channel
\fBTcl_MakeFileChannel\fR(\fIhandle, readOrWrite\fR)
.sp
Tcl_Channel
\fBTcl_GetChannel\fR(\fIinterp, channelName, modePtr\fR)
.sp
int
\fBTcl_GetChannelNames\fR(\fIinterp\fR)
.sp
int
\fBTcl_GetChannelNamesEx\fR(\fIinterp, pattern\fR)
.sp
void
\fBTcl_RegisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_UnregisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_DetachChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_IsStandardChannel\fR(\fIchannel\fR)
.sp
int
\fBTcl_Close\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_ReadChars\fR(\fIchannel, readObjPtr, charsToRead, appendFlag\fR)
.sp
int
\fBTcl_Read\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_GetsObj\fR(\fIchannel, lineObjPtr\fR)
.sp
int
\fBTcl_Gets\fR(\fIchannel, lineRead\fR)
.sp
int
\fBTcl_Ungets\fR(\fIchannel, input, inputLen, addAtEnd\fR)
.sp
int
\fBTcl_WriteObj\fR(\fIchannel, writeObjPtr\fR)
.sp
int
\fBTcl_WriteChars\fR(\fIchannel, charBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Write\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_ReadRaw\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_WriteRaw\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Eof\fR(\fIchannel\fR)
.sp
int
\fBTcl_Flush\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBlocked\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBuffered\fR(\fIchannel\fR)
.sp
int
\fBTcl_OutputBuffered\fR(\fIchannel\fR)
.sp
Tcl_WideInt
\fBTcl_Seek\fR(\fIchannel, offset, seekMode\fR)
.sp
Tcl_WideInt
\fBTcl_Tell\fR(\fIchannel\fR)
.sp
.VS 8.5
int
\fBTcl_TruncateChannel\fR(\fIchannel, length\fR)
.VE 8.5
.sp
int
\fBTcl_GetChannelOption\fR(\fIinterp, channel, optionName, optionValue\fR)
.sp
int
\fBTcl_SetChannelOption\fR(\fIinterp, channel, optionName, newValue\fR)
.sp
.SH ARGUMENTS
.AS Tcl_DString *channelName in/out
.AP Tcl_Interp *interp in
Used for error reporting and to look up a channel registered in it.
.AP "const char" *fileName in
The name of a local or network file.
.AP "const char" *mode in
Specifies how the file is to be accessed.  May have any of the values
allowed for the \fImode\fR argument to the Tcl \fBopen\fR command.  
.AP int permissions in
POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.
.AP int argc in
The number of elements in \fIargv\fR.
.AP "const char" **argv in
Arguments for constructing a command pipeline.  These values have the same
meaning as the non-switch arguments to the Tcl \fBexec\fR command.
.AP int flags in
Specifies the disposition of the stdio handles in pipeline: OR-ed
combination of \fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, \fBTCL_STDERR\fR, and
\fBTCL_ENFORCE_MODE\fR. If \fBTCL_STDIN\fR is set, stdin for the first child
in the pipe is the pipe channel, otherwise it is the same as the standard
input of the invoking process; likewise for \fBTCL_STDOUT\fR and
\fBTCL_STDERR\fR. If \fBTCL_ENFORCE_MODE\fR is not set, then the pipe can
redirect stdio handles to override the stdio handles for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR and \fBTCL_STDERR\fR have been set.  If it
is set, then such redirections cause an error.
.AP ClientData handle in
Operating system specific handle for I/O to a file. For Unix this is a
file descriptor, for Windows it is a HANDLE.
.AP int readOrWrite in
OR-ed combination of \fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR to indicate
what operations are valid on \fIhandle\fR.
.AP "const char" *channelName in
The name of the channel. 
.AP int *modePtr out
Points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR denoting whether the channel is
open for reading and writing.
.AP "const char" *pattern in
The pattern to match on, passed to Tcl_StringMatch, or NULL.
.AP Tcl_Channel channel in
A Tcl channel for input or output.  Must have been the return value
from a procedure such as \fBTcl_OpenFileChannel\fR.
.AP Tcl_Obj *readObjPtr in/out
A pointer to a Tcl Object in which to store the characters read from the
channel.
.AP int charsToRead in
The number of characters to read from the channel.  If the channel's encoding 
is \fBbinary\fR, this is equivalent to the number of bytes to read from the 
channel.
.AP int appendFlag in
If non-zero, data read from the channel will be appended to the object.
Otherwise, the data will replace the existing contents of the object.
.AP char *readBuf out
A buffer in which to store the bytes read from the channel.
.AP int bytesToRead in
The number of bytes to read from the channel.  The buffer \fIreadBuf\fR must
be large enough to hold this many bytes.
.AP Tcl_Obj *lineObjPtr in/out
A pointer to a Tcl object in which to store the line read from the
channel.  The line read will be appended to the current value of the
object. 
.AP Tcl_DString *lineRead in/out
A pointer to a Tcl dynamic string in which to store the line read from the
channel.  Must have been initialized by the caller.  The line read will be
appended to any data already in the dynamic string.
.AP "const char" *input in
The input to add to a channel buffer.
.AP int inputLen in
Length of the input
.AP int addAtEnd in
Flag indicating whether the input should be added to the end or
beginning of the channel buffer.
.AP Tcl_Obj *writeObjPtr in
A pointer to a Tcl Object whose contents will be output to the channel.
.AP "const char" *charBuf in
A buffer containing the characters to output to the channel.
.AP "const char" *byteBuf in
A buffer containing the bytes to output to the channel.
.AP int bytesToWrite in
The number of bytes to consume from \fIcharBuf\fR or \fIbyteBuf\fR and
output to the channel.
.AP Tcl_WideInt offset in
How far to move the access point in the channel at which the next input or
output operation will be applied, measured in bytes from the position
given by \fIseekMode\fR.  May be either positive or negative.
.AP int seekMode in
Relative to which point to seek; used with \fIoffset\fR to calculate the new
access point for the channel. Legal values are \fBSEEK_SET\fR,
\fBSEEK_CUR\fR, and \fBSEEK_END\fR.
.AP Tcl_WideInt length in
The (non-negative) length to truncate the channel the channel to.
.AP "const char" *optionName in
The name of an option applicable to this channel, such as \fB\-blocking\fR.
May have any of the values accepted by the \fBfconfigure\fR command.
.AP Tcl_DString *optionValue in
Where to store the value of an option or a list of all options and their
values. Must have been initialized by the caller.
.AP "const char" *newValue in
New value for the option given by \fIoptionName\fR.
.BE

.SH DESCRIPTION
.PP
The Tcl channel mechanism provides a device-independent and
platform-independent mechanism for performing buffered input
and output operations on a variety of file, socket, and device
types.
The channel mechanism is extensible to new channel types, by
providing a low-level channel driver for the new type; the channel driver
interface is described in the manual entry for \fBTcl_CreateChannel\fR. The
channel mechanism provides a buffering scheme modeled after
Unix's standard I/O, and it also allows for nonblocking I/O on
channels.
.PP
The procedures described in this manual entry comprise the C APIs of the
generic layer of the channel architecture. For a description of the channel
driver architecture and how to implement channel drivers for new types of
channels, see the manual entry for \fBTcl_CreateChannel\fR.

.SH TCL_OPENFILECHANNEL
.PP
\fBTcl_OpenFileChannel\fR opens a file specified by \fIfileName\fR and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the \fBfopen\fR procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl \fBopen\fR command when opening a file.
If an error occurs while opening the channel, \fBTcl_OpenFileChannel\fR
returns NULL and records a POSIX error code that can be
retrieved with \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, \fBTcl_OpenFileChannel\fR
leaves an error message in \fIinterp\fR's result after any error.  
As of Tcl 8.4, the object-based API \fBTcl_FSOpenFileChannel\fR should 
be used in preference to \fBTcl_OpenFileChannel\fR wherever possible.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_OPENCOMMANDCHANNEL
.PP
\fBTcl_OpenCommandChannel\fR provides a C-level interface to the
functions of the \fBexec\fR and \fBopen\fR commands.
It creates a sequence of subprocesses specified
by the \fIargv\fR and \fIargc\fR arguments and returns a channel that can
be used to communicate with these subprocesses.
The \fIflags\fR argument indicates what sort of communication will
exist with the command pipeline.
.PP
If the \fBTCL_STDIN\fR flag is set then the standard input for the
first subprocess will be tied to the channel: writing to the channel
will provide input to the subprocess.  If \fBTCL_STDIN\fR is not set,
then standard input for the first subprocess will be the same as this
application's standard input.  If \fBTCL_STDOUT\fR is set then
standard output from the last subprocess can be read from the channel;
otherwise it goes to this application's standard output.  If
\fBTCL_STDERR\fR is set, standard error output for all subprocesses is
returned to the channel and results in an error when the channel is
closed; otherwise it goes to this application's standard error.  If
\fBTCL_ENFORCE_MODE\fR is not set, then \fIargc\fR and \fIargv\fR can
redirect the stdio handles to override \fBTCL_STDIN\fR,
\fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR; if it is set, then it is an
error for argc and argv to override stdio channels for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR have been set.
.PP
If an error occurs while opening the channel, \fBTcl_OpenCommandChannel\fR
returns NULL and records a POSIX error code that can be retrieved with
\fBTcl_GetErrno\fR.
In addition, \fBTcl_OpenCommandChannel\fR leaves an error message in
the interpreter's result if \fIinterp\fR is not NULL.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_MAKEFILECHANNEL
.PP
\fBTcl_MakeFileChannel\fR makes a \fBTcl_Channel\fR from an existing,
platform-specific, file handle.
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_GETCHANNEL
.PP
\fBTcl_GetChannel\fR returns a channel given the \fIchannelName\fR used to
create it with \fBTcl_CreateChannel\fR and a pointer to a Tcl interpreter in
\fIinterp\fR. If a channel by that name is not registered in that interpreter,
the procedure returns NULL. If the \fImodePtr\fR argument is not NULL, it
points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR describing whether the channel is
open for reading and writing.
.PP
\fBTcl_GetChannelNames\fR and \fBTcl_GetChannelNamesEx\fR write the
names of the registered channels to the interpreter's result as a
list object.  \fBTcl_GetChannelNamesEx\fR will filter these names
according to the \fIpattern\fR.  If \fIpattern\fR is NULL, then it
will not do any filtering.  The return value is \fBTCL_OK\fR if no
errors occurred writing to the result, otherwise it is \fBTCL_ERROR\fR,
and the error message is left in the interpreter's result.

.SH TCL_REGISTERCHANNEL
.PP
\fBTcl_RegisterChannel\fR adds a channel to the set of channels accessible
in \fIinterp\fR. After this call, Tcl programs executing in that
interpreter can refer to the channel in input or output operations using
the name given in the call to \fBTcl_CreateChannel\fR.  After this call,
the channel becomes the property of the interpreter, and the caller should
not call \fBTcl_Close\fR for the channel; the channel will be closed
automatically when it is unregistered from the interpreter.
.PP
Code executing outside of any Tcl interpreter can call
\fBTcl_RegisterChannel\fR with \fIinterp\fR as NULL, to indicate that it
wishes to hold a reference to this channel. Subsequently, the channel can
be registered in a Tcl interpreter and it will only be closed when the
matching number of calls to \fBTcl_UnregisterChannel\fR have been made.
This allows code executing outside of any interpreter to safely hold a
reference to a channel that is also registered in a Tcl interpreter.
.PP
This procedure interacts with the code managing the standard
channels. If no standard channels were initialized before the first
call to \fBTcl_RegisterChannel\fR, they will get initialized by that
call. See \fBTcl_StandardChannels\fR for a general treatise about
standard channels and the behaviour of the Tcl library with regard to
them.

.SH TCL_UNREGISTERCHANNEL
.PP
\fBTcl_UnregisterChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
If this operation removed the last registration of the channel in any
interpreter, the channel is also closed and destroyed.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_UnregisterChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, it will now be closed.  \fBTcl_UnregisterChannel\fR
is very similar to \fBTcl_DetachChannel\fR except that it will also
close the channel if no further references to it exist.

.SH TCL_DETACHCHANNEL
.PP
\fBTcl_DetachChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
Beyond that, this command has no further effect.  It cannot be used on
the standard channels (stdout, stderr, stdin), and will return
\fBTCL_ERROR\fR if passed one of those channels.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_DetachChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, unlike \fBTcl_UnregisterChannel\fR, 
it will not be closed.

.SH TCL_ISSTANDARDCHANNEL
.PP
\fBTcl_IsStandardChannel\fR tests whether a channel is one of the
three standard channels, stdin, stdout or stderr.  If so, it returns
1, otherwise 0.
.PP
No attempt is made to check whether the given channel or the standard 
channels are initialized or otherwise valid.

.SH TCL_CLOSE
.PP
\fBTcl_Close\fR destroys the channel \fIchannel\fR, which must denote a
currently open channel. The channel should not be registered in any
interpreter when \fBTcl_Close\fR is called. Buffered output is flushed to
the channel's output device prior to destroying the channel, and any
buffered input is discarded.  If this is a blocking channel, the call does
not return until all buffered data is successfully sent to the channel's
output device.  If this is a nonblocking channel and there is buffered
output that cannot be written without blocking, the call returns
immediately; output is flushed in the background and the channel will be
closed once all of the buffered data has been output.  In this case errors
during flushing are not reported.
.PP
If the channel was closed successfully, \fBTcl_Close\fR returns \fBTCL_OK\fR.
If an error occurs, \fBTcl_Close\fR returns \fBTCL_ERROR\fR and records a
POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.
If the channel is being closed synchronously and an error occurs during
closing of the channel and \fIinterp\fR is not NULL, an error message is
left in the interpreter's result.
.PP
Note: it is not safe to call \fBTcl_Close\fR on a channel that has been
registered using \fBTcl_RegisterChannel\fR; see the documentation for
\fBTcl_RegisterChannel\fR, above, for details. If the channel has ever
been given as the \fBchan\fR argument in a call to
\fBTcl_RegisterChannel\fR, you should instead use
\fBTcl_UnregisterChannel\fR, which will internally call \fBTcl_Close\fR
when all calls to \fBTcl_RegisterChannel\fR have been matched by
corresponding calls to \fBTcl_UnregisterChannel\fR.

.SH "TCL_READCHARS AND TCL_READ"
.PP
\fBTcl_ReadChars\fR consumes bytes from \fIchannel\fR, converting the bytes
to UTF-8 based on the channel's encoding and storing the produced data in 
\fIreadObjPtr\fR's string representation.  The return value of
\fBTcl_ReadChars\fR is the number of characters, up to \fIcharsToRead\fR,
that were stored in \fIreadObjPtr\fR.  If an error occurs while reading, the
return value is \-1 and \fBTcl_ReadChars\fR records a POSIX error code that
can be retrieved with \fBTcl_GetErrno\fR.
.PP
Setting \fIcharsToRead\fR to \fB\-1\fR will cause the command to read
all characters currently available (non-blocking) or everything until
eof (blocking mode).
.PP
The return value may be smaller than the value to read, indicating that less
data than requested was available.  This is called a \fIshort read\fR.  In
blocking mode, this can only happen on an end-of-file.  In nonblocking mode,
a short read can also occur if there is not enough input currently
available:  \fBTcl_ReadChars\fR returns a short count rather than waiting
for more data.
.PP
If the channel is in blocking mode, a return value of zero indicates an
end-of-file condition.  If the channel is in nonblocking mode, a return
value of zero indicates either that no input is currently available or an
end-of-file condition.  Use \fBTcl_Eof\fR and \fBTcl_InputBlocked\fR to tell
which of these conditions actually occurred.
.PP
\fBTcl_ReadChars\fR translates the various end-of-line representations into
the canonical \fB\en\fR internal representation according to the current
end-of-line recognition mode.  End-of-line recognition and the various
platform-specific modes are described in the manual entry for the Tcl
\fBfconfigure\fR command.
.PP
As a performance optimization, when reading from a channel with the encoding
\fBbinary\fR, the bytes are not converted to UTF-8 as they are read.
Instead, they are stored in \fIreadObjPtr\fR's internal representation as a
byte-array object.  The string representation of this object will only be
constructed if it is needed (e.g., because of a call to
\fBTcl_GetStringFromObj\fR).  In this way, byte-oriented data can be read
from a channel, manipulated by calling \fBTcl_GetByteArrayFromObj\fR and
related functions, and then written to a channel without the expense of ever
converting to or from UTF-8.
.PP
\fBTcl_Read\fR is similar to \fBTcl_ReadChars\fR, except that it does not do
encoding conversions, regardless of the channel's encoding.  It is deprecated
and exists for backwards compatibility with non-internationalized Tcl
extensions.  It consumes bytes from \fIchannel\fR and stores them in
\fIreadBuf\fR, performing end-of-line translations on the way.  The return value
of \fBTcl_Read\fR is the number of bytes, up to \fIbytesToRead\fR, written in
\fIreadBuf\fR.  The buffer produced by \fBTcl_Read\fR is not null-terminated.
Its contents are valid from the zeroth position up to and excluding the
position indicated by the return value.  
.PP
\fBTcl_ReadRaw\fR is the same as \fBTcl_Read\fR but does not
compensate for stacking. While \fBTcl_Read\fR (and the other functions
in the API) always get their data from the topmost channel in the
stack the supplied channel is part of, \fBTcl_ReadRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the channel below into the transformation.

.SH "TCL_GETSOBJ AND TCL_GETS"
.PP
\fBTcl_GetsObj\fR consumes bytes from \fIchannel\fR, converting the bytes to
UTF-8 based on the channel's encoding, until a full line of input has been
seen.  If the channel's encoding is \fBbinary\fR, each byte read from the
channel is treated as an individual Unicode character.  All of the
characters of the line except for the terminating end-of-line character(s)
are appended to \fIlineObjPtr\fR's string representation.  The end-of-line
character(s) are read and discarded.
.PP
If a line was successfully read, the return value is greater than or equal
to zero and indicates the number of bytes stored in \fIlineObjPtr\fR.  If an
error occurs, \fBTcl_GetsObj\fR returns \-1 and records a POSIX error code
that can be retrieved with \fBTcl_GetErrno\fR.  \fBTcl_GetsObj\fR also
returns \-1 if the end of the file is reached; the \fBTcl_Eof\fR procedure
can be used to distinguish an error from an end-of-file condition.
.PP
If the channel is in nonblocking mode, the return value can also be \-1 if
no data was available or the data that was available did not contain an
end-of-line character.  When \-1 is returned, the \fBTcl_InputBlocked\fR
procedure may be invoked to determine if the channel is blocked because
of input unavailability.
.PP
\fBTcl_Gets\fR is the same as \fBTcl_GetsObj\fR except the resulting
characters are appended to the dynamic string given by
\fIlineRead\fR rather than a Tcl object.

.SH "TCL_UNGETS"
.PP
\fBTcl_Ungets\fR is used to add data to the input queue of a channel,
at either the head or tail of the queue.  The pointer \fIinput\fR points
to the data that is to be added.  The length of the input to add is given
by \fIinputLen\fR.  A non-zero value of \fIaddAtEnd\fR indicates that the
data is to be added at the end of queue; otherwise it will be added at the
head of the queue.  If \fIchannel\fR has a
.QW sticky
EOF set, no data will be
added to the input queue.  \fBTcl_Ungets\fR returns \fIinputLen\fR or
\-1 if an error occurs.

.SH "TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE"
.PP
\fBTcl_WriteChars\fR accepts \fIbytesToWrite\fR bytes of character data at
\fIcharBuf\fR.  The UTF-8 characters in the buffer are converted to the
channel's encoding and queued for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_WriteChars\fR expects \fIcharBuf\fR
to be null-terminated and it outputs everything up to the null.
.PP
Data queued for output may not appear on the output device immediately, due
to internal buffering.  If the data should appear immediately, call
\fBTcl_Flush\fR after the call to \fBTcl_WriteChars\fR, or set the 
\fB\-buffering\fR option on the channel to \fBnone\fR.  If you wish the data
to appear as soon as a complete line is accepted for output, set the
\fB\-buffering\fR option on the channel to \fBline\fR mode.
.PP
The return value of \fBTcl_WriteChars\fR is a count of how many bytes were
accepted for output to the channel.  This is either greater than zero to
indicate success or \-1 to indicate that an error occurred.  If an error
occurs, \fBTcl_WriteChars\fR records a POSIX error code that may be
retrieved with \fBTcl_GetErrno\fR.
.PP
Newline characters in the output data are translated to platform-specific
end-of-line sequences according to the \fB\-translation\fR option for the
channel.  This is done even if the channel has no encoding.
.PP
\fBTcl_WriteObj\fR is similar to \fBTcl_WriteChars\fR except it
accepts a Tcl object whose contents will be output to the channel.  The
UTF-8 characters in \fIwriteObjPtr\fR's string representation are converted
to the channel's encoding and queued for output to \fIchannel\fR.  
As a performance optimization, when writing to a channel with the encoding
\fBbinary\fR, UTF-8 characters are not converted as they are written.
Instead, the bytes in \fIwriteObjPtr\fR's internal representation as a
byte-array object are written to the channel.  The byte-array representation
of the object will be constructed if it is needed.  In this way,
byte-oriented data can be read from a channel, manipulated by calling
\fBTcl_GetByteArrayFromObj\fR and related functions, and then written to a
channel without the expense of ever converting to or from UTF-8.
.PP
\fBTcl_Write\fR is similar to \fBTcl_WriteChars\fR except that it does not do
encoding conversions, regardless of the channel's encoding.  It is
deprecated and exists for backwards compatibility with non-internationalized
Tcl extensions.  It accepts \fIbytesToWrite\fR bytes of data at
\fIbyteBuf\fR and queues them for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_Write\fR expects \fIbyteBuf\fR to be
null-terminated and it outputs everything up to the null.
.PP
\fBTcl_WriteRaw\fR is the same as \fBTcl_Write\fR but does not
compensate for stacking. While \fBTcl_Write\fR (and the other
functions in the API) always feed their input to the topmost channel
in the stack the supplied channel is part of, \fBTcl_WriteRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the transformation into the channel below
it.

.SH TCL_FLUSH
.PP
\fBTcl_Flush\fR causes all of the buffered output data for \fIchannel\fR
to be written to its underlying file or device as soon as possible.
If the channel is in blocking mode, the call does not return until
all the buffered data has been sent to the channel or some error occurred.
The call returns immediately if the channel is nonblocking; it starts
a background flush that will write the buffered data to the channel
eventually, as fast as the channel is able to absorb it.
.PP
The return value is normally \fBTCL_OK\fR.
If an error occurs, \fBTcl_Flush\fR returns \fBTCL_ERROR\fR and
records a POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.

.SH TCL_SEEK
.PP
\fBTcl_Seek\fR moves the access point in \fIchannel\fR where subsequent
data will be read or written. Buffered output is flushed to the channel and
buffered input is discarded, prior to the seek operation.
.PP
\fBTcl_Seek\fR normally returns the new access point.
If an error occurs, \fBTcl_Seek\fR returns \-1 and records a POSIX error
code that can be retrieved with \fBTcl_GetErrno\fR.
After an error, the access point may or may not have been moved.

.SH TCL_TELL
.PP
\fBTcl_Tell\fR returns the current access point for a channel. The returned
value is \-1 if the channel does not support seeking.

.SH TCL_TRUNCATECHANNEL
.PP
.VS 8.5
\fBTcl_TruncateChannel\fR truncates the file underlying \fIchannel\fR
to a given \fIlength\fR of bytes. It returns \fBTCL_OK\fR if the
operation succeeded, and \fBTCL_ERROR\fR otherwise.
.VE 8.5

.SH TCL_GETCHANNELOPTION
.PP
\fBTcl_GetChannelOption\fR retrieves, in \fIoptionValue\fR, the value of one of
the options currently in effect for a channel, or a list of all options and
their values.  The \fIchannel\fR argument identifies the channel for which
to query an option or retrieve all options and their values.
If \fIoptionName\fR is not NULL, it is the name of the
option to query; the option's value is copied to the Tcl dynamic string
denoted by \fIoptionValue\fR. If
\fIoptionName\fR is NULL, the function stores an alternating list of option
names and their values in \fIoptionValue\fR, using a series of calls to
\fBTcl_DStringAppendElement\fR. The various preexisting options and
their possible values are described in the manual entry for the Tcl
\fBfconfigure\fR command. Other options can be added by each channel type.
These channel type specific options are described in the manual entry for
the Tcl command that creates a channel of that type; for example, the
additional options for TCP based channels are described in the manual entry
for the Tcl \fBsocket\fR command.
The procedure normally returns \fBTCL_OK\fR. If an error occurs, it returns
\fBTCL_ERROR\fR and calls \fBTcl_SetErrno\fR to store an appropriate POSIX
error code.

.SH TCL_SETCHANNELOPTION
.PP
\fBTcl_SetChannelOption\fR sets a new value \fInewValue\fR
for an option \fIoptionName\fR on \fIchannel\fR.
The procedure normally returns \fBTCL_OK\fR.  If an error occurs,
it returns \fBTCL_ERROR\fR;  in addition, if \fIinterp\fR is non-NULL,
\fBTcl_SetChannelOption\fR leaves an error message in the interpreter's result.

.SH TCL_EOF
.PP
\fBTcl_Eof\fR returns a nonzero value if \fIchannel\fR encountered
an end of file during the last input operation.

.SH TCL_INPUTBLOCKED
.PP
\fBTcl_InputBlocked\fR returns a nonzero value if \fIchannel\fR is in
nonblocking mode and the last input operation returned less data than
requested because there was insufficient data available.
The call always returns zero if the channel is in blocking mode.

.SH TCL_INPUTBUFFERED
.PP
\fBTcl_InputBuffered\fR returns the number of bytes of input currently
buffered in the internal buffers for a channel. If the channel is not open
for reading, this function always returns zero.

.SH TCL_OUTPUTBUFFERED
\fBTcl_OutputBuffered\fR returns the number of bytes of output
currently buffered in the internal buffers for a channel. If the
channel is not open for writing, this function always returns zero.

.SH "PLATFORM ISSUES"
.PP
The handles returned from \fBTcl_GetChannelHandle\fR depend on the
platform and the channel type.  On Unix platforms, the handle is
always a Unix file descriptor as returned from the \fBopen\fR system
call.  On Windows platforms, the handle is a file \fBHANDLE\fR when
the channel was created with \fBTcl_OpenFileChannel\fR,
\fBTcl_OpenCommandChannel\fR, or \fBTcl_MakeFileChannel\fR.  Other
channel types may return a different type of handle on Windows
platforms.

.SH "SEE ALSO"
DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3)

.SH KEYWORDS
access point, blocking, buffered I/O, channel, channel driver, end of file,
flush, input, nonblocking, output, read, seek, write
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WriteObj.3tcl                            0100644 0001750 0001750 00000110560 12566232342 023776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1996-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\"
'\" RCS: @(#) $Id: OpenFileChnl.3,v 1.36 2007/12/13 15:22:31 dgp Exp $
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_OpenFileChannel 3 8.3 Tcl "Tcl Library Procedures"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx, Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw \- buffered I/O facilities using channels
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Channel
\fBTcl_OpenFileChannel\fR(\fIinterp, fileName, mode, permissions\fR)
.sp
Tcl_Channel
\fBTcl_OpenCommandChannel\fR(\fIinterp, argc, argv, flags\fR)
.sp
Tcl_Channel
\fBTcl_MakeFileChannel\fR(\fIhandle, readOrWrite\fR)
.sp
Tcl_Channel
\fBTcl_GetChannel\fR(\fIinterp, channelName, modePtr\fR)
.sp
int
\fBTcl_GetChannelNames\fR(\fIinterp\fR)
.sp
int
\fBTcl_GetChannelNamesEx\fR(\fIinterp, pattern\fR)
.sp
void
\fBTcl_RegisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_UnregisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_DetachChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_IsStandardChannel\fR(\fIchannel\fR)
.sp
int
\fBTcl_Close\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_ReadChars\fR(\fIchannel, readObjPtr, charsToRead, appendFlag\fR)
.sp
int
\fBTcl_Read\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_GetsObj\fR(\fIchannel, lineObjPtr\fR)
.sp
int
\fBTcl_Gets\fR(\fIchannel, lineRead\fR)
.sp
int
\fBTcl_Ungets\fR(\fIchannel, input, inputLen, addAtEnd\fR)
.sp
int
\fBTcl_WriteObj\fR(\fIchannel, writeObjPtr\fR)
.sp
int
\fBTcl_WriteChars\fR(\fIchannel, charBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Write\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_ReadRaw\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_WriteRaw\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Eof\fR(\fIchannel\fR)
.sp
int
\fBTcl_Flush\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBlocked\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBuffered\fR(\fIchannel\fR)
.sp
int
\fBTcl_OutputBuffered\fR(\fIchannel\fR)
.sp
Tcl_WideInt
\fBTcl_Seek\fR(\fIchannel, offset, seekMode\fR)
.sp
Tcl_WideInt
\fBTcl_Tell\fR(\fIchannel\fR)
.sp
.VS 8.5
int
\fBTcl_TruncateChannel\fR(\fIchannel, length\fR)
.VE 8.5
.sp
int
\fBTcl_GetChannelOption\fR(\fIinterp, channel, optionName, optionValue\fR)
.sp
int
\fBTcl_SetChannelOption\fR(\fIinterp, channel, optionName, newValue\fR)
.sp
.SH ARGUMENTS
.AS Tcl_DString *channelName in/out
.AP Tcl_Interp *interp in
Used for error reporting and to look up a channel registered in it.
.AP "const char" *fileName in
The name of a local or network file.
.AP "const char" *mode in
Specifies how the file is to be accessed.  May have any of the values
allowed for the \fImode\fR argument to the Tcl \fBopen\fR command.  
.AP int permissions in
POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.
.AP int argc in
The number of elements in \fIargv\fR.
.AP "const char" **argv in
Arguments for constructing a command pipeline.  These values have the same
meaning as the non-switch arguments to the Tcl \fBexec\fR command.
.AP int flags in
Specifies the disposition of the stdio handles in pipeline: OR-ed
combination of \fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, \fBTCL_STDERR\fR, and
\fBTCL_ENFORCE_MODE\fR. If \fBTCL_STDIN\fR is set, stdin for the first child
in the pipe is the pipe channel, otherwise it is the same as the standard
input of the invoking process; likewise for \fBTCL_STDOUT\fR and
\fBTCL_STDERR\fR. If \fBTCL_ENFORCE_MODE\fR is not set, then the pipe can
redirect stdio handles to override the stdio handles for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR and \fBTCL_STDERR\fR have been set.  If it
is set, then such redirections cause an error.
.AP ClientData handle in
Operating system specific handle for I/O to a file. For Unix this is a
file descriptor, for Windows it is a HANDLE.
.AP int readOrWrite in
OR-ed combination of \fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR to indicate
what operations are valid on \fIhandle\fR.
.AP "const char" *channelName in
The name of the channel. 
.AP int *modePtr out
Points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR denoting whether the channel is
open for reading and writing.
.AP "const char" *pattern in
The pattern to match on, passed to Tcl_StringMatch, or NULL.
.AP Tcl_Channel channel in
A Tcl channel for input or output.  Must have been the return value
from a procedure such as \fBTcl_OpenFileChannel\fR.
.AP Tcl_Obj *readObjPtr in/out
A pointer to a Tcl Object in which to store the characters read from the
channel.
.AP int charsToRead in
The number of characters to read from the channel.  If the channel's encoding 
is \fBbinary\fR, this is equivalent to the number of bytes to read from the 
channel.
.AP int appendFlag in
If non-zero, data read from the channel will be appended to the object.
Otherwise, the data will replace the existing contents of the object.
.AP char *readBuf out
A buffer in which to store the bytes read from the channel.
.AP int bytesToRead in
The number of bytes to read from the channel.  The buffer \fIreadBuf\fR must
be large enough to hold this many bytes.
.AP Tcl_Obj *lineObjPtr in/out
A pointer to a Tcl object in which to store the line read from the
channel.  The line read will be appended to the current value of the
object. 
.AP Tcl_DString *lineRead in/out
A pointer to a Tcl dynamic string in which to store the line read from the
channel.  Must have been initialized by the caller.  The line read will be
appended to any data already in the dynamic string.
.AP "const char" *input in
The input to add to a channel buffer.
.AP int inputLen in
Length of the input
.AP int addAtEnd in
Flag indicating whether the input should be added to the end or
beginning of the channel buffer.
.AP Tcl_Obj *writeObjPtr in
A pointer to a Tcl Object whose contents will be output to the channel.
.AP "const char" *charBuf in
A buffer containing the characters to output to the channel.
.AP "const char" *byteBuf in
A buffer containing the bytes to output to the channel.
.AP int bytesToWrite in
The number of bytes to consume from \fIcharBuf\fR or \fIbyteBuf\fR and
output to the channel.
.AP Tcl_WideInt offset in
How far to move the access point in the channel at which the next input or
output operation will be applied, measured in bytes from the position
given by \fIseekMode\fR.  May be either positive or negative.
.AP int seekMode in
Relative to which point to seek; used with \fIoffset\fR to calculate the new
access point for the channel. Legal values are \fBSEEK_SET\fR,
\fBSEEK_CUR\fR, and \fBSEEK_END\fR.
.AP Tcl_WideInt length in
The (non-negative) length to truncate the channel the channel to.
.AP "const char" *optionName in
The name of an option applicable to this channel, such as \fB\-blocking\fR.
May have any of the values accepted by the \fBfconfigure\fR command.
.AP Tcl_DString *optionValue in
Where to store the value of an option or a list of all options and their
values. Must have been initialized by the caller.
.AP "const char" *newValue in
New value for the option given by \fIoptionName\fR.
.BE

.SH DESCRIPTION
.PP
The Tcl channel mechanism provides a device-independent and
platform-independent mechanism for performing buffered input
and output operations on a variety of file, socket, and device
types.
The channel mechanism is extensible to new channel types, by
providing a low-level channel driver for the new type; the channel driver
interface is described in the manual entry for \fBTcl_CreateChannel\fR. The
channel mechanism provides a buffering scheme modeled after
Unix's standard I/O, and it also allows for nonblocking I/O on
channels.
.PP
The procedures described in this manual entry comprise the C APIs of the
generic layer of the channel architecture. For a description of the channel
driver architecture and how to implement channel drivers for new types of
channels, see the manual entry for \fBTcl_CreateChannel\fR.

.SH TCL_OPENFILECHANNEL
.PP
\fBTcl_OpenFileChannel\fR opens a file specified by \fIfileName\fR and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the \fBfopen\fR procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl \fBopen\fR command when opening a file.
If an error occurs while opening the channel, \fBTcl_OpenFileChannel\fR
returns NULL and records a POSIX error code that can be
retrieved with \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, \fBTcl_OpenFileChannel\fR
leaves an error message in \fIinterp\fR's result after any error.  
As of Tcl 8.4, the object-based API \fBTcl_FSOpenFileChannel\fR should 
be used in preference to \fBTcl_OpenFileChannel\fR wherever possible.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_OPENCOMMANDCHANNEL
.PP
\fBTcl_OpenCommandChannel\fR provides a C-level interface to the
functions of the \fBexec\fR and \fBopen\fR commands.
It creates a sequence of subprocesses specified
by the \fIargv\fR and \fIargc\fR arguments and returns a channel that can
be used to communicate with these subprocesses.
The \fIflags\fR argument indicates what sort of communication will
exist with the command pipeline.
.PP
If the \fBTCL_STDIN\fR flag is set then the standard input for the
first subprocess will be tied to the channel: writing to the channel
will provide input to the subprocess.  If \fBTCL_STDIN\fR is not set,
then standard input for the first subprocess will be the same as this
application's standard input.  If \fBTCL_STDOUT\fR is set then
standard output from the last subprocess can be read from the channel;
otherwise it goes to this application's standard output.  If
\fBTCL_STDERR\fR is set, standard error output for all subprocesses is
returned to the channel and results in an error when the channel is
closed; otherwise it goes to this application's standard error.  If
\fBTCL_ENFORCE_MODE\fR is not set, then \fIargc\fR and \fIargv\fR can
redirect the stdio handles to override \fBTCL_STDIN\fR,
\fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR; if it is set, then it is an
error for argc and argv to override stdio channels for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR have been set.
.PP
If an error occurs while opening the channel, \fBTcl_OpenCommandChannel\fR
returns NULL and records a POSIX error code that can be retrieved with
\fBTcl_GetErrno\fR.
In addition, \fBTcl_OpenCommandChannel\fR leaves an error message in
the interpreter's result if \fIinterp\fR is not NULL.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_MAKEFILECHANNEL
.PP
\fBTcl_MakeFileChannel\fR makes a \fBTcl_Channel\fR from an existing,
platform-specific, file handle.
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_GETCHANNEL
.PP
\fBTcl_GetChannel\fR returns a channel given the \fIchannelName\fR used to
create it with \fBTcl_CreateChannel\fR and a pointer to a Tcl interpreter in
\fIinterp\fR. If a channel by that name is not registered in that interpreter,
the procedure returns NULL. If the \fImodePtr\fR argument is not NULL, it
points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR describing whether the channel is
open for reading and writing.
.PP
\fBTcl_GetChannelNames\fR and \fBTcl_GetChannelNamesEx\fR write the
names of the registered channels to the interpreter's result as a
list object.  \fBTcl_GetChannelNamesEx\fR will filter these names
according to the \fIpattern\fR.  If \fIpattern\fR is NULL, then it
will not do any filtering.  The return value is \fBTCL_OK\fR if no
errors occurred writing to the result, otherwise it is \fBTCL_ERROR\fR,
and the error message is left in the interpreter's result.

.SH TCL_REGISTERCHANNEL
.PP
\fBTcl_RegisterChannel\fR adds a channel to the set of channels accessible
in \fIinterp\fR. After this call, Tcl programs executing in that
interpreter can refer to the channel in input or output operations using
the name given in the call to \fBTcl_CreateChannel\fR.  After this call,
the channel becomes the property of the interpreter, and the caller should
not call \fBTcl_Close\fR for the channel; the channel will be closed
automatically when it is unregistered from the interpreter.
.PP
Code executing outside of any Tcl interpreter can call
\fBTcl_RegisterChannel\fR with \fIinterp\fR as NULL, to indicate that it
wishes to hold a reference to this channel. Subsequently, the channel can
be registered in a Tcl interpreter and it will only be closed when the
matching number of calls to \fBTcl_UnregisterChannel\fR have been made.
This allows code executing outside of any interpreter to safely hold a
reference to a channel that is also registered in a Tcl interpreter.
.PP
This procedure interacts with the code managing the standard
channels. If no standard channels were initialized before the first
call to \fBTcl_RegisterChannel\fR, they will get initialized by that
call. See \fBTcl_StandardChannels\fR for a general treatise about
standard channels and the behaviour of the Tcl library with regard to
them.

.SH TCL_UNREGISTERCHANNEL
.PP
\fBTcl_UnregisterChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
If this operation removed the last registration of the channel in any
interpreter, the channel is also closed and destroyed.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_UnregisterChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, it will now be closed.  \fBTcl_UnregisterChannel\fR
is very similar to \fBTcl_DetachChannel\fR except that it will also
close the channel if no further references to it exist.

.SH TCL_DETACHCHANNEL
.PP
\fBTcl_DetachChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
Beyond that, this command has no further effect.  It cannot be used on
the standard channels (stdout, stderr, stdin), and will return
\fBTCL_ERROR\fR if passed one of those channels.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_DetachChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, unlike \fBTcl_UnregisterChannel\fR, 
it will not be closed.

.SH TCL_ISSTANDARDCHANNEL
.PP
\fBTcl_IsStandardChannel\fR tests whether a channel is one of the
three standard channels, stdin, stdout or stderr.  If so, it returns
1, otherwise 0.
.PP
No attempt is made to check whether the given channel or the standard 
channels are initialized or otherwise valid.

.SH TCL_CLOSE
.PP
\fBTcl_Close\fR destroys the channel \fIchannel\fR, which must denote a
currently open channel. The channel should not be registered in any
interpreter when \fBTcl_Close\fR is called. Buffered output is flushed to
the channel's output device prior to destroying the channel, and any
buffered input is discarded.  If this is a blocking channel, the call does
not return until all buffered data is successfully sent to the channel's
output device.  If this is a nonblocking channel and there is buffered
output that cannot be written without blocking, the call returns
immediately; output is flushed in the background and the channel will be
closed once all of the buffered data has been output.  In this case errors
during flushing are not reported.
.PP
If the channel was closed successfully, \fBTcl_Close\fR returns \fBTCL_OK\fR.
If an error occurs, \fBTcl_Close\fR returns \fBTCL_ERROR\fR and records a
POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.
If the channel is being closed synchronously and an error occurs during
closing of the channel and \fIinterp\fR is not NULL, an error message is
left in the interpreter's result.
.PP
Note: it is not safe to call \fBTcl_Close\fR on a channel that has been
registered using \fBTcl_RegisterChannel\fR; see the documentation for
\fBTcl_RegisterChannel\fR, above, for details. If the channel has ever
been given as the \fBchan\fR argument in a call to
\fBTcl_RegisterChannel\fR, you should instead use
\fBTcl_UnregisterChannel\fR, which will internally call \fBTcl_Close\fR
when all calls to \fBTcl_RegisterChannel\fR have been matched by
corresponding calls to \fBTcl_UnregisterChannel\fR.

.SH "TCL_READCHARS AND TCL_READ"
.PP
\fBTcl_ReadChars\fR consumes bytes from \fIchannel\fR, converting the bytes
to UTF-8 based on the channel's encoding and storing the produced data in 
\fIreadObjPtr\fR's string representation.  The return value of
\fBTcl_ReadChars\fR is the number of characters, up to \fIcharsToRead\fR,
that were stored in \fIreadObjPtr\fR.  If an error occurs while reading, the
return value is \-1 and \fBTcl_ReadChars\fR records a POSIX error code that
can be retrieved with \fBTcl_GetErrno\fR.
.PP
Setting \fIcharsToRead\fR to \fB\-1\fR will cause the command to read
all characters currently available (non-blocking) or everything until
eof (blocking mode).
.PP
The return value may be smaller than the value to read, indicating that less
data than requested was available.  This is called a \fIshort read\fR.  In
blocking mode, this can only happen on an end-of-file.  In nonblocking mode,
a short read can also occur if there is not enough input currently
available:  \fBTcl_ReadChars\fR returns a short count rather than waiting
for more data.
.PP
If the channel is in blocking mode, a return value of zero indicates an
end-of-file condition.  If the channel is in nonblocking mode, a return
value of zero indicates either that no input is currently available or an
end-of-file condition.  Use \fBTcl_Eof\fR and \fBTcl_InputBlocked\fR to tell
which of these conditions actually occurred.
.PP
\fBTcl_ReadChars\fR translates the various end-of-line representations into
the canonical \fB\en\fR internal representation according to the current
end-of-line recognition mode.  End-of-line recognition and the various
platform-specific modes are described in the manual entry for the Tcl
\fBfconfigure\fR command.
.PP
As a performance optimization, when reading from a channel with the encoding
\fBbinary\fR, the bytes are not converted to UTF-8 as they are read.
Instead, they are stored in \fIreadObjPtr\fR's internal representation as a
byte-array object.  The string representation of this object will only be
constructed if it is needed (e.g., because of a call to
\fBTcl_GetStringFromObj\fR).  In this way, byte-oriented data can be read
from a channel, manipulated by calling \fBTcl_GetByteArrayFromObj\fR and
related functions, and then written to a channel without the expense of ever
converting to or from UTF-8.
.PP
\fBTcl_Read\fR is similar to \fBTcl_ReadChars\fR, except that it does not do
encoding conversions, regardless of the channel's encoding.  It is deprecated
and exists for backwards compatibility with non-internationalized Tcl
extensions.  It consumes bytes from \fIchannel\fR and stores them in
\fIreadBuf\fR, performing end-of-line translations on the way.  The return value
of \fBTcl_Read\fR is the number of bytes, up to \fIbytesToRead\fR, written in
\fIreadBuf\fR.  The buffer produced by \fBTcl_Read\fR is not null-terminated.
Its contents are valid from the zeroth position up to and excluding the
position indicated by the return value.  
.PP
\fBTcl_ReadRaw\fR is the same as \fBTcl_Read\fR but does not
compensate for stacking. While \fBTcl_Read\fR (and the other functions
in the API) always get their data from the topmost channel in the
stack the supplied channel is part of, \fBTcl_ReadRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the channel below into the transformation.

.SH "TCL_GETSOBJ AND TCL_GETS"
.PP
\fBTcl_GetsObj\fR consumes bytes from \fIchannel\fR, converting the bytes to
UTF-8 based on the channel's encoding, until a full line of input has been
seen.  If the channel's encoding is \fBbinary\fR, each byte read from the
channel is treated as an individual Unicode character.  All of the
characters of the line except for the terminating end-of-line character(s)
are appended to \fIlineObjPtr\fR's string representation.  The end-of-line
character(s) are read and discarded.
.PP
If a line was successfully read, the return value is greater than or equal
to zero and indicates the number of bytes stored in \fIlineObjPtr\fR.  If an
error occurs, \fBTcl_GetsObj\fR returns \-1 and records a POSIX error code
that can be retrieved with \fBTcl_GetErrno\fR.  \fBTcl_GetsObj\fR also
returns \-1 if the end of the file is reached; the \fBTcl_Eof\fR procedure
can be used to distinguish an error from an end-of-file condition.
.PP
If the channel is in nonblocking mode, the return value can also be \-1 if
no data was available or the data that was available did not contain an
end-of-line character.  When \-1 is returned, the \fBTcl_InputBlocked\fR
procedure may be invoked to determine if the channel is blocked because
of input unavailability.
.PP
\fBTcl_Gets\fR is the same as \fBTcl_GetsObj\fR except the resulting
characters are appended to the dynamic string given by
\fIlineRead\fR rather than a Tcl object.

.SH "TCL_UNGETS"
.PP
\fBTcl_Ungets\fR is used to add data to the input queue of a channel,
at either the head or tail of the queue.  The pointer \fIinput\fR points
to the data that is to be added.  The length of the input to add is given
by \fIinputLen\fR.  A non-zero value of \fIaddAtEnd\fR indicates that the
data is to be added at the end of queue; otherwise it will be added at the
head of the queue.  If \fIchannel\fR has a
.QW sticky
EOF set, no data will be
added to the input queue.  \fBTcl_Ungets\fR returns \fIinputLen\fR or
\-1 if an error occurs.

.SH "TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE"
.PP
\fBTcl_WriteChars\fR accepts \fIbytesToWrite\fR bytes of character data at
\fIcharBuf\fR.  The UTF-8 characters in the buffer are converted to the
channel's encoding and queued for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_WriteChars\fR expects \fIcharBuf\fR
to be null-terminated and it outputs everything up to the null.
.PP
Data queued for output may not appear on the output device immediately, due
to internal buffering.  If the data should appear immediately, call
\fBTcl_Flush\fR after the call to \fBTcl_WriteChars\fR, or set the 
\fB\-buffering\fR option on the channel to \fBnone\fR.  If you wish the data
to appear as soon as a complete line is accepted for output, set the
\fB\-buffering\fR option on the channel to \fBline\fR mode.
.PP
The return value of \fBTcl_WriteChars\fR is a count of how many bytes were
accepted for output to the channel.  This is either greater than zero to
indicate success or \-1 to indicate that an error occurred.  If an error
occurs, \fBTcl_WriteChars\fR records a POSIX error code that may be
retrieved with \fBTcl_GetErrno\fR.
.PP
Newline characters in the output data are translated to platform-specific
end-of-line sequences according to the \fB\-translation\fR option for the
channel.  This is done even if the channel has no encoding.
.PP
\fBTcl_WriteObj\fR is similar to \fBTcl_WriteChars\fR except it
accepts a Tcl object whose contents will be output to the channel.  The
UTF-8 characters in \fIwriteObjPtr\fR's string representation are converted
to the channel's encoding and queued for output to \fIchannel\fR.  
As a performance optimization, when writing to a channel with the encoding
\fBbinary\fR, UTF-8 characters are not converted as they are written.
Instead, the bytes in \fIwriteObjPtr\fR's internal representation as a
byte-array object are written to the channel.  The byte-array representation
of the object will be constructed if it is needed.  In this way,
byte-oriented data can be read from a channel, manipulated by calling
\fBTcl_GetByteArrayFromObj\fR and related functions, and then written to a
channel without the expense of ever converting to or from UTF-8.
.PP
\fBTcl_Write\fR is similar to \fBTcl_WriteChars\fR except that it does not do
encoding conversions, regardless of the channel's encoding.  It is
deprecated and exists for backwards compatibility with non-internationalized
Tcl extensions.  It accepts \fIbytesToWrite\fR bytes of data at
\fIbyteBuf\fR and queues them for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_Write\fR expects \fIbyteBuf\fR to be
null-terminated and it outputs everything up to the null.
.PP
\fBTcl_WriteRaw\fR is the same as \fBTcl_Write\fR but does not
compensate for stacking. While \fBTcl_Write\fR (and the other
functions in the API) always feed their input to the topmost channel
in the stack the supplied channel is part of, \fBTcl_WriteRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the transformation into the channel below
it.

.SH TCL_FLUSH
.PP
\fBTcl_Flush\fR causes all of the buffered output data for \fIchannel\fR
to be written to its underlying file or device as soon as possible.
If the channel is in blocking mode, the call does not return until
all the buffered data has been sent to the channel or some error occurred.
The call returns immediately if the channel is nonblocking; it starts
a background flush that will write the buffered data to the channel
eventually, as fast as the channel is able to absorb it.
.PP
The return value is normally \fBTCL_OK\fR.
If an error occurs, \fBTcl_Flush\fR returns \fBTCL_ERROR\fR and
records a POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.

.SH TCL_SEEK
.PP
\fBTcl_Seek\fR moves the access point in \fIchannel\fR where subsequent
data will be read or written. Buffered output is flushed to the channel and
buffered input is discarded, prior to the seek operation.
.PP
\fBTcl_Seek\fR normally returns the new access point.
If an error occurs, \fBTcl_Seek\fR returns \-1 and records a POSIX error
code that can be retrieved with \fBTcl_GetErrno\fR.
After an error, the access point may or may not have been moved.

.SH TCL_TELL
.PP
\fBTcl_Tell\fR returns the current access point for a channel. The returned
value is \-1 if the channel does not support seeking.

.SH TCL_TRUNCATECHANNEL
.PP
.VS 8.5
\fBTcl_TruncateChannel\fR truncates the file underlying \fIchannel\fR
to a given \fIlength\fR of bytes. It returns \fBTCL_OK\fR if the
operation succeeded, and \fBTCL_ERROR\fR otherwise.
.VE 8.5

.SH TCL_GETCHANNELOPTION
.PP
\fBTcl_GetChannelOption\fR retrieves, in \fIoptionValue\fR, the value of one of
the options currently in effect for a channel, or a list of all options and
their values.  The \fIchannel\fR argument identifies the channel for which
to query an option or retrieve all options and their values.
If \fIoptionName\fR is not NULL, it is the name of the
option to query; the option's value is copied to the Tcl dynamic string
denoted by \fIoptionValue\fR. If
\fIoptionName\fR is NULL, the function stores an alternating list of option
names and their values in \fIoptionValue\fR, using a series of calls to
\fBTcl_DStringAppendElement\fR. The various preexisting options and
their possible values are described in the manual entry for the Tcl
\fBfconfigure\fR command. Other options can be added by each channel type.
These channel type specific options are described in the manual entry for
the Tcl command that creates a channel of that type; for example, the
additional options for TCP based channels are described in the manual entry
for the Tcl \fBsocket\fR command.
The procedure normally returns \fBTCL_OK\fR. If an error occurs, it returns
\fBTCL_ERROR\fR and calls \fBTcl_SetErrno\fR to store an appropriate POSIX
error code.

.SH TCL_SETCHANNELOPTION
.PP
\fBTcl_SetChannelOption\fR sets a new value \fInewValue\fR
for an option \fIoptionName\fR on \fIchannel\fR.
The procedure normally returns \fBTCL_OK\fR.  If an error occurs,
it returns \fBTCL_ERROR\fR;  in addition, if \fIinterp\fR is non-NULL,
\fBTcl_SetChannelOption\fR leaves an error message in the interpreter's result.

.SH TCL_EOF
.PP
\fBTcl_Eof\fR returns a nonzero value if \fIchannel\fR encountered
an end of file during the last input operation.

.SH TCL_INPUTBLOCKED
.PP
\fBTcl_InputBlocked\fR returns a nonzero value if \fIchannel\fR is in
nonblocking mode and the last input operation returned less data than
requested because there was insufficient data available.
The call always returns zero if the channel is in blocking mode.

.SH TCL_INPUTBUFFERED
.PP
\fBTcl_InputBuffered\fR returns the number of bytes of input currently
buffered in the internal buffers for a channel. If the channel is not open
for reading, this function always returns zero.

.SH TCL_OUTPUTBUFFERED
\fBTcl_OutputBuffered\fR returns the number of bytes of output
currently buffered in the internal buffers for a channel. If the
channel is not open for writing, this function always returns zero.

.SH "PLATFORM ISSUES"
.PP
The handles returned from \fBTcl_GetChannelHandle\fR depend on the
platform and the channel type.  On Unix platforms, the handle is
always a Unix file descriptor as returned from the \fBopen\fR system
call.  On Windows platforms, the handle is a file \fBHANDLE\fR when
the channel was created with \fBTcl_OpenFileChannel\fR,
\fBTcl_OpenCommandChannel\fR, or \fBTcl_MakeFileChannel\fR.  Other
channel types may return a different type of handle on Windows
platforms.

.SH "SEE ALSO"
DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3)

.SH KEYWORDS
access point, blocking, buffered I/O, channel, channel driver, end of file,
flush, input, nonblocking, output, read, seek, write
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WriteRaw.3tcl                            0100644 0001750 0001750 00000110560 12566232342 024015  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1996-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\"
'\" RCS: @(#) $Id: OpenFileChnl.3,v 1.36 2007/12/13 15:22:31 dgp Exp $
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_OpenFileChannel 3 8.3 Tcl "Tcl Library Procedures"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx, Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw \- buffered I/O facilities using channels
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Channel
\fBTcl_OpenFileChannel\fR(\fIinterp, fileName, mode, permissions\fR)
.sp
Tcl_Channel
\fBTcl_OpenCommandChannel\fR(\fIinterp, argc, argv, flags\fR)
.sp
Tcl_Channel
\fBTcl_MakeFileChannel\fR(\fIhandle, readOrWrite\fR)
.sp
Tcl_Channel
\fBTcl_GetChannel\fR(\fIinterp, channelName, modePtr\fR)
.sp
int
\fBTcl_GetChannelNames\fR(\fIinterp\fR)
.sp
int
\fBTcl_GetChannelNamesEx\fR(\fIinterp, pattern\fR)
.sp
void
\fBTcl_RegisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_UnregisterChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_DetachChannel\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_IsStandardChannel\fR(\fIchannel\fR)
.sp
int
\fBTcl_Close\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_ReadChars\fR(\fIchannel, readObjPtr, charsToRead, appendFlag\fR)
.sp
int
\fBTcl_Read\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_GetsObj\fR(\fIchannel, lineObjPtr\fR)
.sp
int
\fBTcl_Gets\fR(\fIchannel, lineRead\fR)
.sp
int
\fBTcl_Ungets\fR(\fIchannel, input, inputLen, addAtEnd\fR)
.sp
int
\fBTcl_WriteObj\fR(\fIchannel, writeObjPtr\fR)
.sp
int
\fBTcl_WriteChars\fR(\fIchannel, charBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Write\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_ReadRaw\fR(\fIchannel, readBuf, bytesToRead\fR)
.sp
int
\fBTcl_WriteRaw\fR(\fIchannel, byteBuf, bytesToWrite\fR)
.sp
int
\fBTcl_Eof\fR(\fIchannel\fR)
.sp
int
\fBTcl_Flush\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBlocked\fR(\fIchannel\fR)
.sp
int
\fBTcl_InputBuffered\fR(\fIchannel\fR)
.sp
int
\fBTcl_OutputBuffered\fR(\fIchannel\fR)
.sp
Tcl_WideInt
\fBTcl_Seek\fR(\fIchannel, offset, seekMode\fR)
.sp
Tcl_WideInt
\fBTcl_Tell\fR(\fIchannel\fR)
.sp
.VS 8.5
int
\fBTcl_TruncateChannel\fR(\fIchannel, length\fR)
.VE 8.5
.sp
int
\fBTcl_GetChannelOption\fR(\fIinterp, channel, optionName, optionValue\fR)
.sp
int
\fBTcl_SetChannelOption\fR(\fIinterp, channel, optionName, newValue\fR)
.sp
.SH ARGUMENTS
.AS Tcl_DString *channelName in/out
.AP Tcl_Interp *interp in
Used for error reporting and to look up a channel registered in it.
.AP "const char" *fileName in
The name of a local or network file.
.AP "const char" *mode in
Specifies how the file is to be accessed.  May have any of the values
allowed for the \fImode\fR argument to the Tcl \fBopen\fR command.  
.AP int permissions in
POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.
.AP int argc in
The number of elements in \fIargv\fR.
.AP "const char" **argv in
Arguments for constructing a command pipeline.  These values have the same
meaning as the non-switch arguments to the Tcl \fBexec\fR command.
.AP int flags in
Specifies the disposition of the stdio handles in pipeline: OR-ed
combination of \fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, \fBTCL_STDERR\fR, and
\fBTCL_ENFORCE_MODE\fR. If \fBTCL_STDIN\fR is set, stdin for the first child
in the pipe is the pipe channel, otherwise it is the same as the standard
input of the invoking process; likewise for \fBTCL_STDOUT\fR and
\fBTCL_STDERR\fR. If \fBTCL_ENFORCE_MODE\fR is not set, then the pipe can
redirect stdio handles to override the stdio handles for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR and \fBTCL_STDERR\fR have been set.  If it
is set, then such redirections cause an error.
.AP ClientData handle in
Operating system specific handle for I/O to a file. For Unix this is a
file descriptor, for Windows it is a HANDLE.
.AP int readOrWrite in
OR-ed combination of \fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR to indicate
what operations are valid on \fIhandle\fR.
.AP "const char" *channelName in
The name of the channel. 
.AP int *modePtr out
Points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR denoting whether the channel is
open for reading and writing.
.AP "const char" *pattern in
The pattern to match on, passed to Tcl_StringMatch, or NULL.
.AP Tcl_Channel channel in
A Tcl channel for input or output.  Must have been the return value
from a procedure such as \fBTcl_OpenFileChannel\fR.
.AP Tcl_Obj *readObjPtr in/out
A pointer to a Tcl Object in which to store the characters read from the
channel.
.AP int charsToRead in
The number of characters to read from the channel.  If the channel's encoding 
is \fBbinary\fR, this is equivalent to the number of bytes to read from the 
channel.
.AP int appendFlag in
If non-zero, data read from the channel will be appended to the object.
Otherwise, the data will replace the existing contents of the object.
.AP char *readBuf out
A buffer in which to store the bytes read from the channel.
.AP int bytesToRead in
The number of bytes to read from the channel.  The buffer \fIreadBuf\fR must
be large enough to hold this many bytes.
.AP Tcl_Obj *lineObjPtr in/out
A pointer to a Tcl object in which to store the line read from the
channel.  The line read will be appended to the current value of the
object. 
.AP Tcl_DString *lineRead in/out
A pointer to a Tcl dynamic string in which to store the line read from the
channel.  Must have been initialized by the caller.  The line read will be
appended to any data already in the dynamic string.
.AP "const char" *input in
The input to add to a channel buffer.
.AP int inputLen in
Length of the input
.AP int addAtEnd in
Flag indicating whether the input should be added to the end or
beginning of the channel buffer.
.AP Tcl_Obj *writeObjPtr in
A pointer to a Tcl Object whose contents will be output to the channel.
.AP "const char" *charBuf in
A buffer containing the characters to output to the channel.
.AP "const char" *byteBuf in
A buffer containing the bytes to output to the channel.
.AP int bytesToWrite in
The number of bytes to consume from \fIcharBuf\fR or \fIbyteBuf\fR and
output to the channel.
.AP Tcl_WideInt offset in
How far to move the access point in the channel at which the next input or
output operation will be applied, measured in bytes from the position
given by \fIseekMode\fR.  May be either positive or negative.
.AP int seekMode in
Relative to which point to seek; used with \fIoffset\fR to calculate the new
access point for the channel. Legal values are \fBSEEK_SET\fR,
\fBSEEK_CUR\fR, and \fBSEEK_END\fR.
.AP Tcl_WideInt length in
The (non-negative) length to truncate the channel the channel to.
.AP "const char" *optionName in
The name of an option applicable to this channel, such as \fB\-blocking\fR.
May have any of the values accepted by the \fBfconfigure\fR command.
.AP Tcl_DString *optionValue in
Where to store the value of an option or a list of all options and their
values. Must have been initialized by the caller.
.AP "const char" *newValue in
New value for the option given by \fIoptionName\fR.
.BE

.SH DESCRIPTION
.PP
The Tcl channel mechanism provides a device-independent and
platform-independent mechanism for performing buffered input
and output operations on a variety of file, socket, and device
types.
The channel mechanism is extensible to new channel types, by
providing a low-level channel driver for the new type; the channel driver
interface is described in the manual entry for \fBTcl_CreateChannel\fR. The
channel mechanism provides a buffering scheme modeled after
Unix's standard I/O, and it also allows for nonblocking I/O on
channels.
.PP
The procedures described in this manual entry comprise the C APIs of the
generic layer of the channel architecture. For a description of the channel
driver architecture and how to implement channel drivers for new types of
channels, see the manual entry for \fBTcl_CreateChannel\fR.

.SH TCL_OPENFILECHANNEL
.PP
\fBTcl_OpenFileChannel\fR opens a file specified by \fIfileName\fR and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the \fBfopen\fR procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl \fBopen\fR command when opening a file.
If an error occurs while opening the channel, \fBTcl_OpenFileChannel\fR
returns NULL and records a POSIX error code that can be
retrieved with \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, \fBTcl_OpenFileChannel\fR
leaves an error message in \fIinterp\fR's result after any error.  
As of Tcl 8.4, the object-based API \fBTcl_FSOpenFileChannel\fR should 
be used in preference to \fBTcl_OpenFileChannel\fR wherever possible.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_OPENCOMMANDCHANNEL
.PP
\fBTcl_OpenCommandChannel\fR provides a C-level interface to the
functions of the \fBexec\fR and \fBopen\fR commands.
It creates a sequence of subprocesses specified
by the \fIargv\fR and \fIargc\fR arguments and returns a channel that can
be used to communicate with these subprocesses.
The \fIflags\fR argument indicates what sort of communication will
exist with the command pipeline.
.PP
If the \fBTCL_STDIN\fR flag is set then the standard input for the
first subprocess will be tied to the channel: writing to the channel
will provide input to the subprocess.  If \fBTCL_STDIN\fR is not set,
then standard input for the first subprocess will be the same as this
application's standard input.  If \fBTCL_STDOUT\fR is set then
standard output from the last subprocess can be read from the channel;
otherwise it goes to this application's standard output.  If
\fBTCL_STDERR\fR is set, standard error output for all subprocesses is
returned to the channel and results in an error when the channel is
closed; otherwise it goes to this application's standard error.  If
\fBTCL_ENFORCE_MODE\fR is not set, then \fIargc\fR and \fIargv\fR can
redirect the stdio handles to override \fBTCL_STDIN\fR,
\fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR; if it is set, then it is an
error for argc and argv to override stdio channels for which
\fBTCL_STDIN\fR, \fBTCL_STDOUT\fR, and \fBTCL_STDERR\fR have been set.
.PP
If an error occurs while opening the channel, \fBTcl_OpenCommandChannel\fR
returns NULL and records a POSIX error code that can be retrieved with
\fBTcl_GetErrno\fR.
In addition, \fBTcl_OpenCommandChannel\fR leaves an error message in
the interpreter's result if \fIinterp\fR is not NULL.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_MAKEFILECHANNEL
.PP
\fBTcl_MakeFileChannel\fR makes a \fBTcl_Channel\fR from an existing,
platform-specific, file handle.
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.

.SH TCL_GETCHANNEL
.PP
\fBTcl_GetChannel\fR returns a channel given the \fIchannelName\fR used to
create it with \fBTcl_CreateChannel\fR and a pointer to a Tcl interpreter in
\fIinterp\fR. If a channel by that name is not registered in that interpreter,
the procedure returns NULL. If the \fImodePtr\fR argument is not NULL, it
points at an integer variable that will receive an OR-ed combination of
\fBTCL_READABLE\fR and \fBTCL_WRITABLE\fR describing whether the channel is
open for reading and writing.
.PP
\fBTcl_GetChannelNames\fR and \fBTcl_GetChannelNamesEx\fR write the
names of the registered channels to the interpreter's result as a
list object.  \fBTcl_GetChannelNamesEx\fR will filter these names
according to the \fIpattern\fR.  If \fIpattern\fR is NULL, then it
will not do any filtering.  The return value is \fBTCL_OK\fR if no
errors occurred writing to the result, otherwise it is \fBTCL_ERROR\fR,
and the error message is left in the interpreter's result.

.SH TCL_REGISTERCHANNEL
.PP
\fBTcl_RegisterChannel\fR adds a channel to the set of channels accessible
in \fIinterp\fR. After this call, Tcl programs executing in that
interpreter can refer to the channel in input or output operations using
the name given in the call to \fBTcl_CreateChannel\fR.  After this call,
the channel becomes the property of the interpreter, and the caller should
not call \fBTcl_Close\fR for the channel; the channel will be closed
automatically when it is unregistered from the interpreter.
.PP
Code executing outside of any Tcl interpreter can call
\fBTcl_RegisterChannel\fR with \fIinterp\fR as NULL, to indicate that it
wishes to hold a reference to this channel. Subsequently, the channel can
be registered in a Tcl interpreter and it will only be closed when the
matching number of calls to \fBTcl_UnregisterChannel\fR have been made.
This allows code executing outside of any interpreter to safely hold a
reference to a channel that is also registered in a Tcl interpreter.
.PP
This procedure interacts with the code managing the standard
channels. If no standard channels were initialized before the first
call to \fBTcl_RegisterChannel\fR, they will get initialized by that
call. See \fBTcl_StandardChannels\fR for a general treatise about
standard channels and the behaviour of the Tcl library with regard to
them.

.SH TCL_UNREGISTERCHANNEL
.PP
\fBTcl_UnregisterChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
If this operation removed the last registration of the channel in any
interpreter, the channel is also closed and destroyed.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_UnregisterChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, it will now be closed.  \fBTcl_UnregisterChannel\fR
is very similar to \fBTcl_DetachChannel\fR except that it will also
close the channel if no further references to it exist.

.SH TCL_DETACHCHANNEL
.PP
\fBTcl_DetachChannel\fR removes a channel from the set of channels
accessible in \fIinterp\fR. After this call, Tcl programs will no longer be
able to use the channel's name to refer to the channel in that interpreter.
Beyond that, this command has no further effect.  It cannot be used on
the standard channels (stdout, stderr, stdin), and will return
\fBTCL_ERROR\fR if passed one of those channels.
.PP
Code not associated with a Tcl interpreter can call
\fBTcl_DetachChannel\fR with \fIinterp\fR as NULL, to indicate to Tcl
that it no longer holds a reference to that channel. If this is the last
reference to the channel, unlike \fBTcl_UnregisterChannel\fR, 
it will not be closed.

.SH TCL_ISSTANDARDCHANNEL
.PP
\fBTcl_IsStandardChannel\fR tests whether a channel is one of the
three standard channels, stdin, stdout or stderr.  If so, it returns
1, otherwise 0.
.PP
No attempt is made to check whether the given channel or the standard 
channels are initialized or otherwise valid.

.SH TCL_CLOSE
.PP
\fBTcl_Close\fR destroys the channel \fIchannel\fR, which must denote a
currently open channel. The channel should not be registered in any
interpreter when \fBTcl_Close\fR is called. Buffered output is flushed to
the channel's output device prior to destroying the channel, and any
buffered input is discarded.  If this is a blocking channel, the call does
not return until all buffered data is successfully sent to the channel's
output device.  If this is a nonblocking channel and there is buffered
output that cannot be written without blocking, the call returns
immediately; output is flushed in the background and the channel will be
closed once all of the buffered data has been output.  In this case errors
during flushing are not reported.
.PP
If the channel was closed successfully, \fBTcl_Close\fR returns \fBTCL_OK\fR.
If an error occurs, \fBTcl_Close\fR returns \fBTCL_ERROR\fR and records a
POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.
If the channel is being closed synchronously and an error occurs during
closing of the channel and \fIinterp\fR is not NULL, an error message is
left in the interpreter's result.
.PP
Note: it is not safe to call \fBTcl_Close\fR on a channel that has been
registered using \fBTcl_RegisterChannel\fR; see the documentation for
\fBTcl_RegisterChannel\fR, above, for details. If the channel has ever
been given as the \fBchan\fR argument in a call to
\fBTcl_RegisterChannel\fR, you should instead use
\fBTcl_UnregisterChannel\fR, which will internally call \fBTcl_Close\fR
when all calls to \fBTcl_RegisterChannel\fR have been matched by
corresponding calls to \fBTcl_UnregisterChannel\fR.

.SH "TCL_READCHARS AND TCL_READ"
.PP
\fBTcl_ReadChars\fR consumes bytes from \fIchannel\fR, converting the bytes
to UTF-8 based on the channel's encoding and storing the produced data in 
\fIreadObjPtr\fR's string representation.  The return value of
\fBTcl_ReadChars\fR is the number of characters, up to \fIcharsToRead\fR,
that were stored in \fIreadObjPtr\fR.  If an error occurs while reading, the
return value is \-1 and \fBTcl_ReadChars\fR records a POSIX error code that
can be retrieved with \fBTcl_GetErrno\fR.
.PP
Setting \fIcharsToRead\fR to \fB\-1\fR will cause the command to read
all characters currently available (non-blocking) or everything until
eof (blocking mode).
.PP
The return value may be smaller than the value to read, indicating that less
data than requested was available.  This is called a \fIshort read\fR.  In
blocking mode, this can only happen on an end-of-file.  In nonblocking mode,
a short read can also occur if there is not enough input currently
available:  \fBTcl_ReadChars\fR returns a short count rather than waiting
for more data.
.PP
If the channel is in blocking mode, a return value of zero indicates an
end-of-file condition.  If the channel is in nonblocking mode, a return
value of zero indicates either that no input is currently available or an
end-of-file condition.  Use \fBTcl_Eof\fR and \fBTcl_InputBlocked\fR to tell
which of these conditions actually occurred.
.PP
\fBTcl_ReadChars\fR translates the various end-of-line representations into
the canonical \fB\en\fR internal representation according to the current
end-of-line recognition mode.  End-of-line recognition and the various
platform-specific modes are described in the manual entry for the Tcl
\fBfconfigure\fR command.
.PP
As a performance optimization, when reading from a channel with the encoding
\fBbinary\fR, the bytes are not converted to UTF-8 as they are read.
Instead, they are stored in \fIreadObjPtr\fR's internal representation as a
byte-array object.  The string representation of this object will only be
constructed if it is needed (e.g., because of a call to
\fBTcl_GetStringFromObj\fR).  In this way, byte-oriented data can be read
from a channel, manipulated by calling \fBTcl_GetByteArrayFromObj\fR and
related functions, and then written to a channel without the expense of ever
converting to or from UTF-8.
.PP
\fBTcl_Read\fR is similar to \fBTcl_ReadChars\fR, except that it does not do
encoding conversions, regardless of the channel's encoding.  It is deprecated
and exists for backwards compatibility with non-internationalized Tcl
extensions.  It consumes bytes from \fIchannel\fR and stores them in
\fIreadBuf\fR, performing end-of-line translations on the way.  The return value
of \fBTcl_Read\fR is the number of bytes, up to \fIbytesToRead\fR, written in
\fIreadBuf\fR.  The buffer produced by \fBTcl_Read\fR is not null-terminated.
Its contents are valid from the zeroth position up to and excluding the
position indicated by the return value.  
.PP
\fBTcl_ReadRaw\fR is the same as \fBTcl_Read\fR but does not
compensate for stacking. While \fBTcl_Read\fR (and the other functions
in the API) always get their data from the topmost channel in the
stack the supplied channel is part of, \fBTcl_ReadRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the channel below into the transformation.

.SH "TCL_GETSOBJ AND TCL_GETS"
.PP
\fBTcl_GetsObj\fR consumes bytes from \fIchannel\fR, converting the bytes to
UTF-8 based on the channel's encoding, until a full line of input has been
seen.  If the channel's encoding is \fBbinary\fR, each byte read from the
channel is treated as an individual Unicode character.  All of the
characters of the line except for the terminating end-of-line character(s)
are appended to \fIlineObjPtr\fR's string representation.  The end-of-line
character(s) are read and discarded.
.PP
If a line was successfully read, the return value is greater than or equal
to zero and indicates the number of bytes stored in \fIlineObjPtr\fR.  If an
error occurs, \fBTcl_GetsObj\fR returns \-1 and records a POSIX error code
that can be retrieved with \fBTcl_GetErrno\fR.  \fBTcl_GetsObj\fR also
returns \-1 if the end of the file is reached; the \fBTcl_Eof\fR procedure
can be used to distinguish an error from an end-of-file condition.
.PP
If the channel is in nonblocking mode, the return value can also be \-1 if
no data was available or the data that was available did not contain an
end-of-line character.  When \-1 is returned, the \fBTcl_InputBlocked\fR
procedure may be invoked to determine if the channel is blocked because
of input unavailability.
.PP
\fBTcl_Gets\fR is the same as \fBTcl_GetsObj\fR except the resulting
characters are appended to the dynamic string given by
\fIlineRead\fR rather than a Tcl object.

.SH "TCL_UNGETS"
.PP
\fBTcl_Ungets\fR is used to add data to the input queue of a channel,
at either the head or tail of the queue.  The pointer \fIinput\fR points
to the data that is to be added.  The length of the input to add is given
by \fIinputLen\fR.  A non-zero value of \fIaddAtEnd\fR indicates that the
data is to be added at the end of queue; otherwise it will be added at the
head of the queue.  If \fIchannel\fR has a
.QW sticky
EOF set, no data will be
added to the input queue.  \fBTcl_Ungets\fR returns \fIinputLen\fR or
\-1 if an error occurs.

.SH "TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE"
.PP
\fBTcl_WriteChars\fR accepts \fIbytesToWrite\fR bytes of character data at
\fIcharBuf\fR.  The UTF-8 characters in the buffer are converted to the
channel's encoding and queued for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_WriteChars\fR expects \fIcharBuf\fR
to be null-terminated and it outputs everything up to the null.
.PP
Data queued for output may not appear on the output device immediately, due
to internal buffering.  If the data should appear immediately, call
\fBTcl_Flush\fR after the call to \fBTcl_WriteChars\fR, or set the 
\fB\-buffering\fR option on the channel to \fBnone\fR.  If you wish the data
to appear as soon as a complete line is accepted for output, set the
\fB\-buffering\fR option on the channel to \fBline\fR mode.
.PP
The return value of \fBTcl_WriteChars\fR is a count of how many bytes were
accepted for output to the channel.  This is either greater than zero to
indicate success or \-1 to indicate that an error occurred.  If an error
occurs, \fBTcl_WriteChars\fR records a POSIX error code that may be
retrieved with \fBTcl_GetErrno\fR.
.PP
Newline characters in the output data are translated to platform-specific
end-of-line sequences according to the \fB\-translation\fR option for the
channel.  This is done even if the channel has no encoding.
.PP
\fBTcl_WriteObj\fR is similar to \fBTcl_WriteChars\fR except it
accepts a Tcl object whose contents will be output to the channel.  The
UTF-8 characters in \fIwriteObjPtr\fR's string representation are converted
to the channel's encoding and queued for output to \fIchannel\fR.  
As a performance optimization, when writing to a channel with the encoding
\fBbinary\fR, UTF-8 characters are not converted as they are written.
Instead, the bytes in \fIwriteObjPtr\fR's internal representation as a
byte-array object are written to the channel.  The byte-array representation
of the object will be constructed if it is needed.  In this way,
byte-oriented data can be read from a channel, manipulated by calling
\fBTcl_GetByteArrayFromObj\fR and related functions, and then written to a
channel without the expense of ever converting to or from UTF-8.
.PP
\fBTcl_Write\fR is similar to \fBTcl_WriteChars\fR except that it does not do
encoding conversions, regardless of the channel's encoding.  It is
deprecated and exists for backwards compatibility with non-internationalized
Tcl extensions.  It accepts \fIbytesToWrite\fR bytes of data at
\fIbyteBuf\fR and queues them for output to \fIchannel\fR.  If
\fIbytesToWrite\fR is negative, \fBTcl_Write\fR expects \fIbyteBuf\fR to be
null-terminated and it outputs everything up to the null.
.PP
\fBTcl_WriteRaw\fR is the same as \fBTcl_Write\fR but does not
compensate for stacking. While \fBTcl_Write\fR (and the other
functions in the API) always feed their input to the topmost channel
in the stack the supplied channel is part of, \fBTcl_WriteRaw\fR does
not. Thus this function is \fBonly\fR usable for transformational
channel drivers, i.e. drivers used in the middle of a stack of
channels, to move data from the transformation into the channel below
it.

.SH TCL_FLUSH
.PP
\fBTcl_Flush\fR causes all of the buffered output data for \fIchannel\fR
to be written to its underlying file or device as soon as possible.
If the channel is in blocking mode, the call does not return until
all the buffered data has been sent to the channel or some error occurred.
The call returns immediately if the channel is nonblocking; it starts
a background flush that will write the buffered data to the channel
eventually, as fast as the channel is able to absorb it.
.PP
The return value is normally \fBTCL_OK\fR.
If an error occurs, \fBTcl_Flush\fR returns \fBTCL_ERROR\fR and
records a POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.

.SH TCL_SEEK
.PP
\fBTcl_Seek\fR moves the access point in \fIchannel\fR where subsequent
data will be read or written. Buffered output is flushed to the channel and
buffered input is discarded, prior to the seek operation.
.PP
\fBTcl_Seek\fR normally returns the new access point.
If an error occurs, \fBTcl_Seek\fR returns \-1 and records a POSIX error
code that can be retrieved with \fBTcl_GetErrno\fR.
After an error, the access point may or may not have been moved.

.SH TCL_TELL
.PP
\fBTcl_Tell\fR returns the current access point for a channel. The returned
value is \-1 if the channel does not support seeking.

.SH TCL_TRUNCATECHANNEL
.PP
.VS 8.5
\fBTcl_TruncateChannel\fR truncates the file underlying \fIchannel\fR
to a given \fIlength\fR of bytes. It returns \fBTCL_OK\fR if the
operation succeeded, and \fBTCL_ERROR\fR otherwise.
.VE 8.5

.SH TCL_GETCHANNELOPTION
.PP
\fBTcl_GetChannelOption\fR retrieves, in \fIoptionValue\fR, the value of one of
the options currently in effect for a channel, or a list of all options and
their values.  The \fIchannel\fR argument identifies the channel for which
to query an option or retrieve all options and their values.
If \fIoptionName\fR is not NULL, it is the name of the
option to query; the option's value is copied to the Tcl dynamic string
denoted by \fIoptionValue\fR. If
\fIoptionName\fR is NULL, the function stores an alternating list of option
names and their values in \fIoptionValue\fR, using a series of calls to
\fBTcl_DStringAppendElement\fR. The various preexisting options and
their possible values are described in the manual entry for the Tcl
\fBfconfigure\fR command. Other options can be added by each channel type.
These channel type specific options are described in the manual entry for
the Tcl command that creates a channel of that type; for example, the
additional options for TCP based channels are described in the manual entry
for the Tcl \fBsocket\fR command.
The procedure normally returns \fBTCL_OK\fR. If an error occurs, it returns
\fBTCL_ERROR\fR and calls \fBTcl_SetErrno\fR to store an appropriate POSIX
error code.

.SH TCL_SETCHANNELOPTION
.PP
\fBTcl_SetChannelOption\fR sets a new value \fInewValue\fR
for an option \fIoptionName\fR on \fIchannel\fR.
The procedure normally returns \fBTCL_OK\fR.  If an error occurs,
it returns \fBTCL_ERROR\fR;  in addition, if \fIinterp\fR is non-NULL,
\fBTcl_SetChannelOption\fR leaves an error message in the interpreter's result.

.SH TCL_EOF
.PP
\fBTcl_Eof\fR returns a nonzero value if \fIchannel\fR encountered
an end of file during the last input operation.

.SH TCL_INPUTBLOCKED
.PP
\fBTcl_InputBlocked\fR returns a nonzero value if \fIchannel\fR is in
nonblocking mode and the last input operation returned less data than
requested because there was insufficient data available.
The call always returns zero if the channel is in blocking mode.

.SH TCL_INPUTBUFFERED
.PP
\fBTcl_InputBuffered\fR returns the number of bytes of input currently
buffered in the internal buffers for a channel. If the channel is not open
for reading, this function always returns zero.

.SH TCL_OUTPUTBUFFERED
\fBTcl_OutputBuffered\fR returns the number of bytes of output
currently buffered in the internal buffers for a channel. If the
channel is not open for writing, this function always returns zero.

.SH "PLATFORM ISSUES"
.PP
The handles returned from \fBTcl_GetChannelHandle\fR depend on the
platform and the channel type.  On Unix platforms, the handle is
always a Unix file descriptor as returned from the \fBopen\fR system
call.  On Windows platforms, the handle is a file \fBHANDLE\fR when
the channel was created with \fBTcl_OpenFileChannel\fR,
\fBTcl_OpenCommandChannel\fR, or \fBTcl_MakeFileChannel\fR.  Other
channel types may return a different type of handle on Windows
platforms.

.SH "SEE ALSO"
DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3)

.SH KEYWORDS
access point, blocking, buffered I/O, channel, channel driver, end of file,
flush, input, nonblocking, output, read, seek, write
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_WrongNumArgs.3tcl                        0100644 0001750 0001750 00000021141 12566232354 024641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: WrongNumArgs.3,v 1.12 2007/12/13 15:22:32 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_WrongNumArgs 3 8.0 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_WrongNumArgs \- generate standard error message for wrong number of arguments
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_WrongNumArgs\fR(\fIinterp, objc, objv, message\fR)
.SH ARGUMENTS
.AS "Tcl_Obj *const" *message
.AP Tcl_Interp interp in
Interpreter in which error will be reported: error message gets stored
in its result object.
.AP int objc in
Number of leading arguments from \fIobjv\fR to include in error
message.
.AP "Tcl_Obj *const" objv[] in
Arguments to command that had the wrong number of arguments.
.AP "const char" *message in
Additional error information to print after leading arguments
from \fIobjv\fR.  This typically gives the acceptable syntax
of the command.  This argument may be NULL.
.BE

.SH DESCRIPTION
.PP
\fBTcl_WrongNumArgs\fR is a utility procedure that is invoked by
command procedures when they discover that they have received the
wrong number of arguments.  \fBTcl_WrongNumArgs\fR generates a
standard error message and stores it in the result object of
\fIinterp\fR.  The message includes the \fIobjc\fR initial
elements of \fIobjv\fR plus \fImessage\fR.  For example, if
\fIobjv\fR consists of the values \fBfoo\fR and \fBbar\fR,
\fIobjc\fR is 1, and \fImessage\fR is
.QW "\fBfileName count\fR"
then \fIinterp\fR's result object will be set to the following
string:
.CS
wrong # args: should be "foo fileName count"
.CE
If \fIobjc\fR is 2, the result will be set to the following string:
.CS
wrong # args: should be "foo bar fileName count"
.CE
\fIObjc\fR is usually 1, but may be 2 or more for commands like
\fBstring\fR and the Tk widget commands, which use the first argument
as a subcommand.  
.PP
Some of the objects in the \fIobjv\fR array may be abbreviations for
a subcommand.  The command
\fBTcl_GetIndexFromObj\fR will convert the abbreviated string object
into an \fIindexObject\fR.  If an error occurs in the parsing of the
subcommand we would like to use the full subcommand name rather than
the abbreviation.  If the \fBTcl_WrongNumArgs\fR command finds any
\fIindexObjects\fR in the \fIobjv\fR array it will use the full subcommand
name in the error message instead of the abbreviated name that was
originally passed in.  Using the above example, let us assume that
\fIbar\fR is actually an abbreviation for \fIbarfly\fR and the object
is now an indexObject because it was passed to
\fBTcl_GetIndexFromObj\fR.  In this case the error message would be:
.CS
wrong # args: should be "foo barfly fileName count"
.CE

.SH "SEE ALSO"
Tcl_GetIndexFromObj

.SH KEYWORDS
command, error message, wrong number of arguments
                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ANSIColor.3pm                          0100644 0001750 0001750 00000105534 12566207463 024061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ANSIColor 3pm"
.TH Term::ANSIColor 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ANSIColor \- Color screen output using ANSI escape sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Term::ANSIColor;
\&    print color \*(Aqbold blue\*(Aq;
\&    print "This text is bold blue.\en";
\&    print color \*(Aqreset\*(Aq;
\&    print "This text is normal.\en";
\&    print colored("Yellow on magenta.", \*(Aqyellow on_magenta\*(Aq), "\en";
\&    print "This text is normal.\en";
\&    print colored [\*(Aqyellow on_magenta\*(Aq], \*(AqYellow on magenta.\*(Aq, "\en";
\&    print colored [\*(Aqred on_bright_yellow\*(Aq], \*(AqRed on bright yellow.\*(Aq, "\en";
\&    print colored [\*(Aqbright_red on_black\*(Aq], \*(AqBright red on black.\*(Aq, "\en";
\&    print "\en";
\&
\&    # Map escape sequences back to color names.
\&    use Term::ANSIColor 1.04 qw(uncolor);
\&    my $names = uncolor(\*(Aq01;31\*(Aq);
\&    print join(q{ }, @{$names}), "\en";
\&
\&    # Strip all color escape sequences.
\&    use Term::ANSIColor 2.01 qw(colorstrip);
\&    print colorstrip \*(Aq\ee[1mThis is bold\ee[0m\*(Aq, "\en";
\&
\&    # Determine whether a color is valid.
\&    use Term::ANSIColor 2.02 qw(colorvalid);
\&    my $valid = colorvalid(\*(Aqblue bold\*(Aq, \*(Aqon_magenta\*(Aq);
\&    print "Color string is ", $valid ? "valid\en" : "invalid\en";
\&
\&    # Create new aliases for colors.
\&    use Term::ANSIColor 4.00 qw(coloralias);
\&    coloralias(\*(Aqalert\*(Aq, \*(Aqred\*(Aq);
\&    print "Alert is ", coloralias(\*(Aqalert\*(Aq), "\en";
\&    print colored("This is in red.", \*(Aqalert\*(Aq), "\en";
\&
\&    use Term::ANSIColor qw(:constants);
\&    print BOLD, BLUE, "This text is in bold blue.\en", RESET;
\&
\&    use Term::ANSIColor qw(:constants);
\&    {
\&        local $Term::ANSIColor::AUTORESET = 1;
\&        print BOLD BLUE "This text is in bold blue.\en";
\&        print "This text is normal.\en";
\&    }
\&
\&    use Term::ANSIColor 2.00 qw(:pushpop);
\&    print PUSHCOLOR RED ON_GREEN "This text is red on green.\en";
\&    print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\en";
\&    print RESET BRIGHT_BLUE "This text is just bright blue.\en";
\&    print POPCOLOR "Back to red on green.\en";
\&    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\en";
\&    print "This text is red on green.\en";
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print ON_BLUE "This text is red on blue.\en";
\&        print "This text is red on green.\en";
\&    }
\&    print POPCOLOR "Back to whatever we started as.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has two interfaces, one through \fIcolor()\fR and \fIcolored()\fR and the
other through constants.  It also offers the utility functions \fIuncolor()\fR,
\&\fIcolorstrip()\fR, \fIcolorvalid()\fR, and \fIcoloralias()\fR, which have to be explicitly
imported to be used (see \*(L"\s-1SYNOPSIS\*(R"\s0).
.PP
See \*(L"\s-1COMPATIBILITY\*(R"\s0 for the versions of Term::ANSIColor that introduced
particular features and the versions of Perl that included them.
.SS "Supported Colors"
.IX Subsection "Supported Colors"
Terminal emulators that support color divide into two types: ones that
support only eight colors, ones that support sixteen, and ones that
support 256.  This module provides the \s-1ANSI\s0 escape codes all of them.
These colors are referred to as \s-1ANSI\s0 colors 0 through 7 (normal), 8
through 15 (16\-color), and 16 through 255 (256\-color).
.PP
Unfortunately, interpretation of colors 0 through 7 often depends on
whether the emulator supports eight colors or sixteen colors.  Emulators
that only support eight colors (such as the Linux console) will display
colors 0 through 7 with normal brightness and ignore colors 8 through 15,
treating them the same as white.  Emulators that support 16 colors, such
as gnome-terminal, normally display colors 0 through 7 as dim or darker
versions and colors 8 through 15 as normal brightness.  On such emulators,
the \*(L"normal\*(R" white (color 7) usually is shown as pale grey, requiring
bright white (15) to be used to get a real white color.  Bright black
usually is a dark grey color, although some terminals display it as pure
black.  Some sixteen-color terminal emulators also treat normal yellow
(color 3) as orange or brown, and bright yellow (color 11) as yellow.
.PP
Following the normal convention of sixteen-color emulators, this module
provides a pair of attributes for each color.  For every normal color (0
through 7), the corresponding bright color (8 through 15) is obtained by
prepending the string \f(CW\*(C`bright_\*(C'\fR to the normal color name.  For example,
\&\f(CW\*(C`red\*(C'\fR is color 1 and \f(CW\*(C`bright_red\*(C'\fR is color 9.  The same applies for
background colors: \f(CW\*(C`on_red\*(C'\fR is the normal color and \f(CW\*(C`on_bright_red\*(C'\fR is
the bright color.  Capitalize these strings for the constant interface.
.PP
For 256\-color emulators, this module additionally provides \f(CW\*(C`ansi0\*(C'\fR
through \f(CW\*(C`ansi15\*(C'\fR, which are the same as colors 0 through 15 in
sixteen-color emulators but use the 256\-color escape syntax, \f(CW\*(C`grey0\*(C'\fR
through \f(CW\*(C`grey23\*(C'\fR ranging from nearly black to nearly white, and a set of
\&\s-1RGB\s0 colors.  The \s-1RGB\s0 colors are of the form \f(CW\*(C`rgb\f(CIRGB\f(CW\*(C'\fR where \fIR\fR, \fIG\fR,
and \fIB\fR are numbers from 0 to 5 giving the intensity of red, green, and
blue.  \f(CW\*(C`on_\*(C'\fR variants of all of these colors are also provided.  These
colors may be ignored completely on non\-256\-color terminals or may be
misinterpreted and produce random behavior.  Additional attributes such as
blink, italic, or bold may not work with the 256\-color palette.
.PP
There is unfortunately no way to know whether the current emulator
supports more than eight colors, which makes the choice of colors
difficult.  The most conservative choice is to use only the regular
colors, which are at least displayed on all emulators.  However, they will
appear dark in sixteen-color terminal emulators, including most common
emulators in \s-1UNIX X\s0 environments.  If you know the display is one of those
emulators, you may wish to use the bright variants instead.  Even better,
offer the user a way to configure the colors for a given application to
fit their terminal emulator.
.SS "Function Interface"
.IX Subsection "Function Interface"
The function interface uses attribute strings to describe the colors and
text attributes to assign to text.  The recognized non-color attributes
are clear, reset, bold, dark, faint, italic, underline, underscore, blink,
reverse, and concealed.  Clear and reset (reset to default attributes),
dark and faint (dim and saturated), and underline and underscore are
equivalent, so use whichever is the most intuitive to you.
.PP
Note that not all attributes are supported by all terminal types, and some
terminals may not support any of these sequences.  Dark and faint, italic,
blink, and concealed in particular are frequently not implemented.
.PP
The recognized normal foreground color attributes (colors 0 to 7) are:
.PP
.Vb 1
\&  black  red  green  yellow  blue  magenta  cyan  white
.Ve
.PP
The corresponding bright foreground color attributes (colors 8 to 15) are:
.PP
.Vb 2
\&  bright_black  bright_red      bright_green  bright_yellow
\&  bright_blue   bright_magenta  bright_cyan   bright_white
.Ve
.PP
The recognized normal background color attributes (colors 0 to 7) are:
.PP
.Vb 2
\&  on_black  on_red      on_green  on yellow
\&  on_blue   on_magenta  on_cyan   on_white
.Ve
.PP
The recognized bright background color attributes (colors 8 to 15) are:
.PP
.Vb 2
\&  on_bright_black  on_bright_red      on_bright_green  on_bright_yellow
\&  on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white
.Ve
.PP
For 256\-color terminals, the recognized foreground colors are:
.PP
.Vb 2
\&  ansi0 .. ansi15
\&  grey0 .. grey23
.Ve
.PP
plus \f(CW\*(C`rgb\f(CIRGB\f(CW\*(C'\fR for \fIR\fR, \fIG\fR, and \fIB\fR values from 0 to 5, such as
\&\f(CW\*(C`rgb000\*(C'\fR or \f(CW\*(C`rgb515\*(C'\fR.  Similarly, the recognized background colors are:
.PP
.Vb 2
\&  on_ansi0 .. on_ansi15
\&  on_grey0 .. on_grey23
.Ve
.PP
plus \f(CW\*(C`on_rgb\f(CIRGB\f(CW\*(C'\fR for for \fIR\fR, \fIG\fR, and \fIB\fR values from 0 to 5.
.PP
For any of the above listed attributes, case is not significant.
.PP
Attributes, once set, last until they are unset (by printing the attribute
\&\f(CW\*(C`clear\*(C'\fR or \f(CW\*(C`reset\*(C'\fR).  Be careful to do this, or otherwise your attribute
will last after your script is done running, and people get very annoyed
at having their prompt and typing changed to weird colors.
.IP "color(ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "color(ATTR[, ATTR ...])"
\&\fIcolor()\fR takes any number of strings as arguments and considers them to be
space-separated lists of attributes.  It then forms and returns the escape
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to.  This is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to.  \fIcolor()\fR
throws an exception if given an invalid attribute.
.IP "colored(\s-1STRING,\s0 ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "colored(STRING, ATTR[, ATTR ...])"
.PD 0
.IP "colored(\s-1ATTR\-REF,\s0 STRING[, \s-1STRING...\s0])" 4
.IX Item "colored(ATTR-REF, STRING[, STRING...])"
.PD
As an aid in resetting colors, \fIcolored()\fR takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.
.Sp
Normally, \fIcolored()\fR just puts attribute codes at the beginning and end of
the string, but if you set \f(CW$Term::ANSIColor::EACHLINE\fR to some string, that
string will be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset at the end of
each line.  This is often desirable if the output contains newlines and
you're using background colors, since a background color that persists
across a newline is often interpreted by the terminal as providing the
default background color for the next line.  Programs like pagers can also
be confused by attributes that span lines.  Normally you'll want to set
\&\f(CW$Term::ANSIColor::EACHLINE\fR to \f(CW"\en"\fR to use this feature.
.IP "uncolor(\s-1ESCAPE\s0)" 4
.IX Item "uncolor(ESCAPE)"
\&\fIuncolor()\fR performs the opposite translation as \fIcolor()\fR, turning escape
sequences into a list of strings corresponding to the attributes being set
by those sequences.
.IP "colorstrip(STRING[, \s-1STRING ...\s0])" 4
.IX Item "colorstrip(STRING[, STRING ...])"
\&\fIcolorstrip()\fR removes all color escape sequences from the provided strings,
returning the modified strings separately in array context or joined
together in scalar context.  Its arguments are not modified.
.IP "colorvalid(ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "colorvalid(ATTR[, ATTR ...])"
\&\fIcolorvalid()\fR takes attribute strings the same as \fIcolor()\fR and returns true
if all attributes are known and false otherwise.
.IP "coloralias(ALIAS[, \s-1ATTR\s0])" 4
.IX Item "coloralias(ALIAS[, ATTR])"
If \s-1ATTR\s0 is specified, \fIcoloralias()\fR sets up an alias of \s-1ALIAS\s0 for the
standard color \s-1ATTR. \s0 From that point forward, \s-1ALIAS\s0 can be passed into
\&\fIcolor()\fR, \fIcolored()\fR, and \fIcolorvalid()\fR and will have the same meaning as
\&\s-1ATTR. \s0 One possible use of this facility is to give more meaningful names
to the 256\-color \s-1RGB\s0 colors.  Only alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`_\*(C'\fR, and \f(CW\*(C`\-\*(C'\fR are
allowed in alias names.
.Sp
If \s-1ATTR\s0 is not specified, \fIcoloralias()\fR returns the standard color name to
which \s-1ALIAS\s0 is aliased, if any, or undef if \s-1ALIAS\s0 does not exist.
.Sp
This is the same facility used by the \s-1ANSI_COLORS_ALIASES\s0 environment
variable (see \*(L"\s-1ENVIRONMENT\*(R"\s0 below) but can be used at runtime, not just
when the module is loaded.
.Sp
Later invocations of \fIcoloralias()\fR with the same \s-1ALIAS\s0 will override
earlier aliases.  There is no way to remove an alias.
.Sp
Aliases have no effect on the return value of \fIuncolor()\fR.
.Sp
\&\fB\s-1WARNING\s0\fR: Aliases are global and affect all callers in the same process.
There is no way to set an alias limited to a particular block of code or a
particular object.
.SS "Constant Interface"
.IX Subsection "Constant Interface"
Alternately, if you import \f(CW\*(C`:constants\*(C'\fR, you can use the following
constants directly:
.PP
.Vb 3
\&  CLEAR           RESET             BOLD            DARK
\&  FAINT           ITALIC            UNDERLINE       UNDERSCORE
\&  BLINK           REVERSE           CONCEALED
\&
\&  BLACK           RED               GREEN           YELLOW
\&  BLUE            MAGENTA           CYAN            WHITE
\&  BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
\&  BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE
\&
\&  ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
\&  ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
\&  ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
\&  ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
.Ve
.PP
These are the same as color('attribute') and can be used if you prefer
typing:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text", RESET, "\en";
.Ve
.PP
to
.PP
.Vb 1
\&    print colored ("Text", \*(Aqbold blue on_white\*(Aq), "\en";
.Ve
.PP
(Note that the newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)
.PP
If you import \f(CW\*(C`:constants256\*(C'\fR, you can use the following constants
directly:
.PP
.Vb 2
\&  ANSI0 .. ANSI15
\&  GREY0 .. GREY23
\&
\&  RGBXYZ (for X, Y, and Z values from 0 to 5, like RGB000 or RGB515)
\&
\&  ON_ANSI0 .. ON_ANSI15
\&  ON_GREY0 .. ON_GREY23
\&
\&  ON_RGBXYZ (for X, Y, and Z values from 0 to 5)
.Ve
.PP
Note that \f(CW\*(C`:constants256\*(C'\fR does not include the other constants, so if you
want to mix both, you need to include \f(CW\*(C`:constants\*(C'\fR as well.  You may want
to explicitly import at least \f(CW\*(C`RESET\*(C'\fR, as in:
.PP
.Vb 1
\&    use Term::ANSIColor 4.00 qw(RESET :constants256);
.Ve
.PP
When using the constants, if you don't want to have to remember to add the
\&\f(CW\*(C`, RESET\*(C'\fR at the end of each print line, you can set
\&\f(CW$Term::ANSIColor::AUTORESET\fR to a true value.  Then, the display mode will
automatically be reset if there is no comma after the constant.  In other
words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
.PP
will reset the display mode afterward, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
.PP
will not.  If you are using background colors, you will probably want to
either use \fIsay()\fR (in newer versions of Perl) or print the newline with a
separate print statement to avoid confusing the terminal.
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set (see below), it takes precedence
over \f(CW$Term::ANSIColor::AUTORESET\fR, and the latter is ignored.
.PP
The subroutine interface has the advantage over the constants interface in
that only two subroutines are exported into your namespace, versus
thirty-eight in the constants interface.  On the flip side, the constants
interface has the advantage of better compile time error checking, since
misspelled names of colors or attributes in calls to \fIcolor()\fR and \fIcolored()\fR
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, pollute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, \s-1TMTOWTDI\s0 after all.
.SS "The Color Stack"
.IX Subsection "The Color Stack"
You can import \f(CW\*(C`:pushpop\*(C'\fR and maintain a stack of colors using \s-1PUSHCOLOR,
POPCOLOR,\s0 and \s-1LOCALCOLOR.  PUSHCOLOR\s0 takes the attribute string that
starts its argument and pushes it onto a stack of attributes.  \s-1POPCOLOR\s0
removes the top of the stack and restores the previous attributes set by
the argument of a prior \s-1PUSHCOLOR.  LOCALCOLOR\s0 surrounds its argument in a
\&\s-1PUSHCOLOR\s0 and \s-1POPCOLOR\s0 so that the color resets afterward.
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set, each sequence of color constants
will be implicitly preceded by \s-1LOCALCOLOR. \s0 In other words, the following:
.PP
.Vb 4
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print BLUE "Text\en";
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    print LOCALCOLOR BLUE "Text\en";
.Ve
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set, it takes precedence over
\&\f(CW$Term::ANSIColor::AUTORESET\fR, and the latter is ignored.
.PP
When using \s-1PUSHCOLOR, POPCOLOR,\s0 and \s-1LOCALCOLOR,\s0 it's particularly
important to not put commas between the constants.
.PP
.Vb 1
\&    print PUSHCOLOR BLUE "Text\en";
.Ve
.PP
will correctly push \s-1BLUE\s0 onto the top of the stack.
.PP
.Vb 1
\&    print PUSHCOLOR, BLUE, "Text\en";    # wrong!
.Ve
.PP
will not, and a subsequent pop won't restore the correct attributes.
\&\s-1PUSHCOLOR\s0 pushes the attributes set by its argument, which is normally a
string of color constants.  It can't ask the terminal what the current
attributes are.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Bad color mapping %s" 4
.el .IP "Bad color mapping \f(CW%s\fR" 4
.IX Item "Bad color mapping %s"
(W) The specified color mapping from \s-1ANSI_COLORS_ALIASES\s0 is not valid and
could not be parsed.  It was ignored.
.ie n .IP "Bad escape sequence %s" 4
.el .IP "Bad escape sequence \f(CW%s\fR" 4
.IX Item "Bad escape sequence %s"
(F) You passed an invalid \s-1ANSI\s0 escape sequence to \fIuncolor()\fR.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while strict subs in use"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
.Sp
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
.Sp
This will only show up under use strict (another good reason to run under
use strict).
.ie n .IP "Cannot alias standard color %s" 4
.el .IP "Cannot alias standard color \f(CW%s\fR" 4
.IX Item "Cannot alias standard color %s"
(F) The alias name passed to \fIcoloralias()\fR matches a standard color name.
Standard color names cannot be aliased.
.ie n .IP "Cannot alias standard color %s in %s" 4
.el .IP "Cannot alias standard color \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Cannot alias standard color %s in %s"
(W) The same, but in \s-1ANSI_COLORS_ALIASES. \s0 The color mapping was ignored.
.ie n .IP "Invalid alias name %s" 4
.el .IP "Invalid alias name \f(CW%s\fR" 4
.IX Item "Invalid alias name %s"
(F) You passed an invalid alias name to \fIcoloralias()\fR.  Alias names must
consist only of alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, and \f(CW\*(C`_\*(C'\fR.
.ie n .IP "Invalid alias name %s in %s" 4
.el .IP "Invalid alias name \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Invalid alias name %s in %s"
(W) You specified an invalid alias name on the left hand of the equal sign
in a color mapping in \s-1ANSI_COLORS_ALIASES. \s0 The color mapping was ignored.
.ie n .IP "Invalid attribute name %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
(F) You passed an invalid attribute name to \fIcolor()\fR, \fIcolored()\fR, or
\&\fIcoloralias()\fR.
.ie n .IP "Invalid attribute name %s in %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s in %s"
(W) You specified an invalid attribute name on the right hand of the equal
sign in a color mapping in \s-1ANSI_COLORS_ALIASES. \s0 The color mapping was
ignored.
.ie n .IP "Name ""%s"" used only once: possible typo" 4
.el .IP "Name ``%s'' used only once: possible typo" 4
.IX Item "Name %s used only once: possible typo"
(W) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
.Sp
It's probably better to always use commas after constant names in order to
force the next error.
.IP "No comma allowed after filehandle" 4
.IX Item "No comma allowed after filehandle"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
.Sp
Generating this fatal compile error is one of the main advantages of using
the constants interface, since you'll immediately know if you mistype a
color name.
.ie n .IP "No name for escape sequence %s" 4
.el .IP "No name for escape sequence \f(CW%s\fR" 4
.IX Item "No name for escape sequence %s"
(F) The \s-1ANSI\s0 escape sequence passed to \fIuncolor()\fR contains escapes which
aren't recognized and can't be translated to names.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1ANSI_COLORS_ALIASES\s0" 4
.IX Item "ANSI_COLORS_ALIASES"
This environment variable allows the user to specify custom color aliases
that will be understood by \fIcolor()\fR, \fIcolored()\fR, and \fIcolorvalid()\fR.  None of
the other functions will be affected, and no new color constants will be
created.  The custom colors are aliases for existing color names; no new
escape sequences can be introduced.  Only alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`_\*(C'\fR, and
\&\f(CW\*(C`\-\*(C'\fR are allowed in alias names.
.Sp
The format is:
.Sp
.Vb 1
\&    ANSI_COLORS_ALIASES=\*(Aqnewcolor1=oldcolor1,newcolor2=oldcolor2\*(Aq
.Ve
.Sp
Whitespace is ignored.
.Sp
For example the Solarized <http://ethanschoonover.com/solarized> colors
can be mapped with:
.Sp
.Vb 11
\&    ANSI_COLORS_ALIASES=\*(Aq\e
\&        base00=bright_yellow, on_base00=on_bright_yellow,\e
\&        base01=bright_green,  on_base01=on_bright_green, \e
\&        base02=black,         on_base02=on_black,        \e
\&        base03=bright_black,  on_base03=on_bright_black, \e
\&        base0=bright_blue,    on_base0=on_bright_blue,   \e
\&        base1=bright_cyan,    on_base1=on_bright_cyan,   \e
\&        base2=white,          on_base2=on_white,         \e
\&        base3=bright_white,   on_base3=on_bright_white,  \e
\&        orange=bright_red,    on_orange=on_bright_red,   \e
\&        violet=bright_magenta,on_violet=on_bright_magenta\*(Aq
.Ve
.Sp
This environment variable is read and applied when the Term::ANSIColor
module is loaded and is then subsequently ignored.  Changes to
\&\s-1ANSI_COLORS_ALIASES\s0 after the module is loaded will have no effect.  See
\&\fIcoloralias()\fR for an equivalent facility that can be used at runtime.
.IP "\s-1ANSI_COLORS_DISABLED\s0" 4
.IX Item "ANSI_COLORS_DISABLED"
If this environment variable is set to a true value, all of the functions
defined by this module (\fIcolor()\fR, \fIcolored()\fR, and all of the constants not
previously used in the program) will not output any escape sequences and
instead will just return the empty string or pass through the original
text as appropriate.  This is intended to support easy use of scripts
using this module on platforms that don't support \s-1ANSI\s0 escape sequences.
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
Term::ANSIColor was first included with Perl in Perl 5.6.0.
.PP
The \fIuncolor()\fR function and support for \s-1ANSI_COLORS_DISABLED\s0 were added in
Term::ANSIColor 1.04, included in Perl 5.8.0.
.PP
Support for dark was added in Term::ANSIColor 1.08, included in Perl
5.8.4.
.PP
The color stack, including the \f(CW\*(C`:pushpop\*(C'\fR import tag, \s-1PUSHCOLOR,
POPCOLOR, LOCALCOLOR,\s0 and the \f(CW$Term::ANSIColor::AUTOLOCAL\fR variable, was
added in Term::ANSIColor 2.00, included in Perl 5.10.1.
.PP
\&\fIcolorstrip()\fR was added in Term::ANSIColor 2.01 and \fIcolorvalid()\fR was added
in Term::ANSIColor 2.02, both included in Perl 5.11.0.
.PP
Support for colors 8 through 15 (the \f(CW\*(C`bright_\*(C'\fR variants) was added in
Term::ANSIColor 3.00, included in Perl 5.13.3.
.PP
Support for italic was added in Term::ANSIColor 3.02, included in Perl
5.17.1.
.PP
Support for colors 16 through 256 (the \f(CW\*(C`ansi\*(C'\fR, \f(CW\*(C`rgb\*(C'\fR, and \f(CW\*(C`grey\*(C'\fR
colors), the \f(CW\*(C`:constants256\*(C'\fR import tag, the \fIcoloralias()\fR function, and
support for the \s-1ANSI_COLORS_ALIASES\s0 environment variable were added in
Term::ANSIColor 4.00.
.PP
\&\f(CW$Term::ANSIColor::AUTOLOCAL\fR was changed to take precedence over
\&\f(CW$Term::ANSIColor::AUTORESET\fR, rather than the other way around, in
Term::ANSIColor 4.00.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
It would be nice if one could leave off the commas around the constants
entirely and just say:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en" RESET;
.Ve
.PP
but the syntax of Perl doesn't allow this.  You need a comma after the
string.  (Of course, you may consider it a bug that commas between all the
constants aren't required, in which case you may feel free to insert
commas unless you're using \f(CW$Term::ANSIColor::AUTORESET\fR or
\&\s-1PUSHCOLOR/POPCOLOR.\s0)
.PP
For easier debugging, you may prefer to always use the commas when not
setting \f(CW$Term::ANSIColor::AUTORESET\fR or \s-1PUSHCOLOR/POPCOLOR\s0 so that you'll
get a fatal compile error rather than a warning.
.PP
It's not possible to use this module to embed formatting and color
attributes using Perl formats.  They replace the escape character with a
space (as documented in \fIperlform\fR\|(1)), resulting in garbled output from
the unrecognized attribute.  Even if there were a way around that problem,
the format doesn't know that the non-printing escape sequence is
zero-length and would incorrectly format the output.  For formatted output
using color or other attributes, either use \fIsprintf()\fR instead or use
\&\fIformline()\fR and then add the color or other attributes after formatting and
before output.
.SH "NOTES"
.IX Header "NOTES"
The codes generated by this module are standard terminal control codes,
complying with \s-1ECMA\-048\s0 and \s-1ISO 6429 \s0(generally referred to as \*(L"\s-1ANSI\s0
color\*(R" for the color codes).  The non-color control codes (bold, dark,
italic, underline, and reverse) are part of the earlier \s-1ANSI X3.64\s0
standard for control sequences for video terminals and peripherals.
.PP
Note that not all displays are \s-1ISO\s0 6429\-compliant, or even X3.64\-compliant
(or are even attempting to be so).  This module will not work as expected
on displays that do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows \s-1NT\s0 or Windows 2000.  They
may just be ignored, or they may display as an \s-1ESC\s0 character followed by
some apparent garbage.
.PP
Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes and others have
helped me flesh it out:
.PP
.Vb 12
\&              clear    bold     faint   under    blink   reverse  conceal
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& xterm         yes      yes      no      yes      yes      yes      yes
\& linux         yes      yes      yes    bold      yes      yes      no
\& rxvt          yes      yes      no      yes  bold/black   yes      no
\& dtterm        yes      yes      yes     yes    reverse    yes      yes
\& teraterm      yes    reverse    no      yes    rev/red    yes      no
\& aixterm      kinda   normal     no      yes      no       yes      yes
\& PuTTY         yes     color     no      yes      no       yes      no
\& Windows       yes      no       no      no       no       yes      no
\& Cygwin SSH    yes      yes      no     color    color    color     yes
\& Terminal.app  yes      yes      no      yes      yes      yes      yes
.Ve
.PP
Windows is Windows telnet, Cygwin \s-1SSH\s0 is the OpenSSH implementation under
Cygwin on Windows \s-1NT,\s0 and Mac Terminal is the Terminal application in Mac
\&\s-1OS X. \s0 Where the entry is other than yes or no, that emulator displays the
given attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
.PP
Support for code 3 (italic) is rare and therefore not mentioned in that
table.  It is not believed to be fully supported by any of the terminals
listed, although it's displayed as green in the Linux console, but it is
reportedly supported by urxvt.
.PP
Note that codes 6 (rapid blink) and 9 (strike-through) are specified in
\&\s-1ANSI X3.64\s0 and \s-1ECMA\-048\s0 but are not commonly supported by most displays
and emulators and therefore aren't supported by this module at the present
time.  \s-1ECMA\-048\s0 also specifies a large number of other attributes,
including a sequence of attributes for font changes, Fraktur characters,
double-underlining, framing, circling, and overlining.  As none of these
attributes are widely supported or useful, they also aren't currently
supported by this module.
.PP
Most modern X terminal emulators support 256 colors.  Known to not support
those colors are aterm, rxvt, Terminal.app, and \s-1TTY/VC.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1ECMA\-048\s0 is available on-line (at least at the time of this writing) at
<http://www.ecma\-international.org/publications/standards/Ecma\-048.htm>.
.PP
\&\s-1ISO 6429\s0 is available from \s-1ISO\s0 for a charge; the author of this module
does not own a copy of it.  Since the source material for \s-1ISO 6429\s0 was
\&\s-1ECMA\-048\s0 and the latter is available for free, there seems little reason
to obtain the \s-1ISO\s0 standard.
.PP
The 256\-color control sequences are documented at
<http://www.xfree86.org/current/ctlseqs.html> (search for 256\-color).
.PP
The \s-1CPAN\s0 module Term::ExtendedColor provides a different and more
comprehensive interface for 256\-color emulators that may be more
convenient.
.PP
The current version of this module is always available from its web site
at <http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
the Perl core distribution as of 5.6.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original idea (using constants) by Zenin, reimplemented using subs by Russ
Allbery <rra@stanford.edu>, and then combined with the original idea by
Russ with input from Zenin.  256\-color support is based on work by Kurt
Starsinic.  Russ Allbery now maintains this module.
.PP
\&\s-1PUSHCOLOR, POPCOLOR,\s0 and \s-1LOCALCOLOR\s0 were contributed by openmethods.com
voice solutions.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1996 Zenin.  Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005,
2006, 2008, 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>.
Copyright 2012 Kurt Starsinic <kstarsinic@gmail.com>.  This program is
free software; you may redistribute it and/or modify it under the same
terms as Perl itself.
                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ANSIColor5.16.3pm                      0100644 0001750 0001750 00000061767 12566207441 024400  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ANSIColor 3pm"
.TH Term::ANSIColor 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ANSIColor \- Color screen output using ANSI escape sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Term::ANSIColor;
\&    print color \*(Aqbold blue\*(Aq;
\&    print "This text is bold blue.\en";
\&    print color \*(Aqreset\*(Aq;
\&    print "This text is normal.\en";
\&    print colored ("Yellow on magenta.", \*(Aqyellow on_magenta\*(Aq), "\en";
\&    print "This text is normal.\en";
\&    print colored [\*(Aqyellow on_magenta\*(Aq], \*(AqYellow on magenta.\*(Aq, "\en";
\&    print colored [\*(Aqred on_bright_yellow\*(Aq], \*(AqRed on bright yellow.\*(Aq, "\en";
\&    print colored [\*(Aqbright_red on_black\*(Aq], \*(AqBright red on black.\*(Aq, "\en";
\&    print "\en";
\&
\&    use Term::ANSIColor qw(uncolor);
\&    print uncolor (\*(Aq01;31\*(Aq), "\en";
\&
\&    use Term::ANSIColor qw(colorstrip);
\&    print colorstrip \*(Aq\ee[1mThis is bold\ee[0m\*(Aq, "\en";
\&
\&    use Term::ANSIColor qw(colorvalid);
\&    my $valid = colorvalid (\*(Aqblue bold\*(Aq, \*(Aqon_magenta\*(Aq);
\&    print "Color string is ", $valid ? "valid\en" : "invalid\en";
\&
\&    use Term::ANSIColor qw(:constants);
\&    print BOLD, BLUE, "This text is in bold blue.\en", RESET;
\&
\&    use Term::ANSIColor qw(:constants);
\&    {
\&        local $Term::ANSIColor::AUTORESET = 1;
\&        print BOLD BLUE "This text is in bold blue.\en";
\&        print "This text is normal.\en";
\&    }
\&
\&    use Term::ANSIColor qw(:pushpop);
\&    print PUSHCOLOR RED ON_GREEN "This text is red on green.\en";
\&    print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\en";
\&    print RESET BRIGHT_BLUE "This text is just bright blue.\en";
\&    print POPCOLOR "Back to red on green.\en";
\&    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\en";
\&    print "This text is red on green.\en";
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print ON_BLUE "This text is red on blue.\en";
\&        print "This text is red on green.\en";
\&    }
\&    print POPCOLOR "Back to whatever we started as.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has two interfaces, one through \fIcolor()\fR and \fIcolored()\fR and the
other through constants.  It also offers the utility functions \fIuncolor()\fR,
\&\fIcolorstrip()\fR, and \fIcolorvalid()\fR, which have to be explicitly imported to be
used (see \*(L"\s-1SYNOPSIS\s0\*(R").
.SS "Supported Colors"
.IX Subsection "Supported Colors"
Terminal emulators that support color divide into two types: ones that
support only eight colors, and ones that support sixteen.  This module
provides both the \s-1ANSI\s0 escape codes for the \*(L"normal\*(R" colors, supported by
both types, as well as the additional colors supported by sixteen-color
emulators.  These colors are referred to as \s-1ANSI\s0 colors 0 through 7
(normal) and 8 through 15.
.PP
Unfortunately, interpretation of colors 0 through 7 often depends on
whether the emulator supports eight colors or sixteen colors.  Emulators
that only support eight colors (such as the Linux console) will display
colors 0 through 7 with normal brightness and ignore colors 8 through 15,
treating them the same as white.  Emulators that support 16 colors, such
as gnome-terminal, normally display colors 0 through 7 as dim or darker
versions and colors 8 through 15 as normal brightness.  On such emulators,
the \*(L"normal\*(R" white (color 7) usually is shown as pale grey, requiring
bright white (15) to be used to get a real white color.  Bright black
usually is a dark grey color, although some terminals display it as pure
black.  Some sixteen-color terminal emulators also treat normal yellow
(color 3) as orange or brown, and bright yellow (color 11) as yellow.
.PP
Following the normal convention of sixteen-color emulators, this module
provides a pair of attributes for each color.  For every normal color (0
through 7), the corresponding bright color (8 through 15) is obtained by
prepending the string \f(CW\*(C`bright_\*(C'\fR to the normal color name.  For example,
\&\f(CW\*(C`red\*(C'\fR is color 1 and \f(CW\*(C`bright_red\*(C'\fR is color 9.  The same applies for
background colors: \f(CW\*(C`on_red\*(C'\fR is the normal color and \f(CW\*(C`on_bright_red\*(C'\fR is
the bright color.  Capitalize these strings for the constant interface.
.PP
There is unfortunately no way to know whether the current emulator
supports sixteen colors or not, which makes the choice of colors
difficult.  The most conservative choice is to use only the regular
colors, which are at least displayed on all emulators.  However, they will
appear dark in sixteen-color terminal emulators, including most common
emulators in \s-1UNIX\s0 X environments.  If you know the display is one of those
emulators, you may wish to use the bright variants instead.  Even better,
offer the user a way to configure the colors for a given application to
fit their terminal emulator.
.PP
Support for colors 8 through 15 (the \f(CW\*(C`bright_\*(C'\fR variants) was added in
Term::ANSIColor 3.0.
.SS "Function Interface"
.IX Subsection "Function Interface"
The function interface uses attribute strings to describe the colors and
text attributes to assign to text.  The recognized non-color attributes
are clear, reset, bold, dark, faint, underline, underscore, blink,
reverse, and concealed.  Clear and reset (reset to default attributes),
dark and faint (dim and saturated), and underline and underscore are
equivalent, so use whichever is the most intuitive to you.
.PP
Note that not all attributes are supported by all terminal types, and some
terminals may not support any of these sequences.  Dark and faint, blink,
and concealed in particular are frequently not implemented.
.PP
The recognized normal foreground color attributes (colors 0 to 7) are:
.PP
.Vb 1
\&  black  red  green  yellow  blue  magenta  cyan  white
.Ve
.PP
The corresponding bright foreground color attributes (colors 8 to 15) are:
.PP
.Vb 2
\&  bright_black  bright_red      bright_green  bright_yellow
\&  bright_blue   bright_magenta  bright_cyan   bright_white
.Ve
.PP
The recognized normal background color attributes (colors 0 to 7) are:
.PP
.Vb 2
\&  on_black  on_red      on_green  on yellow
\&  on_blue   on_magenta  on_cyan   on_white
.Ve
.PP
The recognized bright background color attributes (colors 8 to 15) are:
.PP
.Vb 2
\&  on_bright_black  on_bright_red      on_bright_green  on_bright_yellow
\&  on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white
.Ve
.PP
For any of the above listed attributes, case is not significant.
.PP
Attributes, once set, last until they are unset (by printing the attribute
\&\f(CW\*(C`clear\*(C'\fR or \f(CW\*(C`reset\*(C'\fR).  Be careful to do this, or otherwise your attribute
will last after your script is done running, and people get very annoyed
at having their prompt and typing changed to weird colors.
.IP "color(ATTR[, \s-1ATTR\s0 ...])" 4
.IX Item "color(ATTR[, ATTR ...])"
\&\fIcolor()\fR takes any number of strings as arguments and considers them to be
space-separated lists of attributes.  It then forms and returns the escape
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to.  This is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to.  \fIcolor()\fR
throws an exception if given an invalid attribute.
.IP "colored(\s-1STRING\s0, \s-1ATTRIBUTES\s0)" 4
.IX Item "colored(STRING, ATTRIBUTES)"
.PD 0
.IP "colored(\s-1ATTR\-REF\s0, STRING[, \s-1STRING\s0...])" 4
.IX Item "colored(ATTR-REF, STRING[, STRING...])"
.PD
As an aid in resetting colors, \fIcolored()\fR takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.
.Sp
Normally, \fIcolored()\fR just puts attribute codes at the beginning and end of
the string, but if you set \f(CW$Term::ANSIColor::EACHLINE\fR to some string, that
string will be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset at the end of
each line.  This is often desirable if the output contains newlines and
you're using background colors, since a background color that persists
across a newline is often interpreted by the terminal as providing the
default background color for the next line.  Programs like pagers can also
be confused by attributes that span lines.  Normally you'll want to set
\&\f(CW$Term::ANSIColor::EACHLINE\fR to \f(CW"\en"\fR to use this feature.
.IP "uncolor(\s-1ESCAPE\s0)" 4
.IX Item "uncolor(ESCAPE)"
\&\fIuncolor()\fR performs the opposite translation as \fIcolor()\fR, turning escape
sequences into a list of strings corresponding to the attributes being set
by those sequences.
.IP "colorstrip(STRING[, \s-1STRING\s0 ...])" 4
.IX Item "colorstrip(STRING[, STRING ...])"
\&\fIcolorstrip()\fR removes all color escape sequences from the provided strings,
returning the modified strings separately in array context or joined
together in scalar context.  Its arguments are not modified.
.IP "colorvalid(ATTR[, \s-1ATTR\s0 ...])" 4
.IX Item "colorvalid(ATTR[, ATTR ...])"
\&\fIcolorvalid()\fR takes attribute strings the same as \fIcolor()\fR and returns true
if all attributes are known and false otherwise.
.SS "Constant Interface"
.IX Subsection "Constant Interface"
Alternately, if you import \f(CW\*(C`:constants\*(C'\fR, you can use the following
constants directly:
.PP
.Vb 3
\&  CLEAR           RESET             BOLD            DARK
\&  FAINT           UNDERLINE         UNDERSCORE      BLINK
\&  REVERSE         CONCEALED
\&
\&  BLACK           RED               GREEN           YELLOW
\&  BLUE            MAGENTA           CYAN            WHITE
\&  BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
\&  BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE
\&
\&  ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
\&  ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
\&  ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
\&  ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
.Ve
.PP
These are the same as color('attribute') and can be used if you prefer
typing:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text", RESET, "\en";
.Ve
.PP
to
.PP
.Vb 1
\&    print colored ("Text", \*(Aqbold blue on_white\*(Aq), "\en";
.Ve
.PP
(Note that the newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)
.PP
When using the constants, if you don't want to have to remember to add the
\&\f(CW\*(C`, RESET\*(C'\fR at the end of each print line, you can set
\&\f(CW$Term::ANSIColor::AUTORESET\fR to a true value.  Then, the display mode will
automatically be reset if there is no comma after the constant.  In other
words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
.PP
will reset the display mode afterward, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
.PP
will not.  If you are using background colors, you will probably want to
print the newline with a separate print statement to avoid confusing the
terminal.
.PP
The subroutine interface has the advantage over the constants interface in
that only two subroutines are exported into your namespace, versus
thirty-eight in the constants interface.  On the flip side, the constants
interface has the advantage of better compile time error checking, since
misspelled names of colors or attributes in calls to \fIcolor()\fR and \fIcolored()\fR
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, pollute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, \s-1TMTOWTDI\s0 after all.
.SS "The Color Stack"
.IX Subsection "The Color Stack"
As of Term::ANSIColor 2.0, you can import \f(CW\*(C`:pushpop\*(C'\fR and maintain a stack
of colors using \s-1PUSHCOLOR\s0, \s-1POPCOLOR\s0, and \s-1LOCALCOLOR\s0.  \s-1PUSHCOLOR\s0 takes the
attribute string that starts its argument and pushes it onto a stack of
attributes.  \s-1POPCOLOR\s0 removes the top of the stack and restores the
previous attributes set by the argument of a prior \s-1PUSHCOLOR\s0.  \s-1LOCALCOLOR\s0
surrounds its argument in a \s-1PUSHCOLOR\s0 and \s-1POPCOLOR\s0 so that the color
resets afterward.
.PP
When using \s-1PUSHCOLOR\s0, \s-1POPCOLOR\s0, and \s-1LOCALCOLOR\s0, it's particularly
important to not put commas between the constants.
.PP
.Vb 1
\&    print PUSHCOLOR BLUE "Text\en";
.Ve
.PP
will correctly push \s-1BLUE\s0 onto the top of the stack.
.PP
.Vb 1
\&    print PUSHCOLOR, BLUE, "Text\en";    # wrong!
.Ve
.PP
will not, and a subsequent pop won't restore the correct attributes.
\&\s-1PUSHCOLOR\s0 pushes the attributes set by its argument, which is normally a
string of color constants.  It can't ask the terminal what the current
attributes are.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Bad escape sequence %s" 4
.el .IP "Bad escape sequence \f(CW%s\fR" 4
.IX Item "Bad escape sequence %s"
(F) You passed an invalid \s-1ANSI\s0 escape sequence to \fIuncolor()\fR.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while strict subs in use"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
.Sp
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
.Sp
This will only show up under use strict (another good reason to run under
use strict).
.ie n .IP "Invalid attribute name %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
(F) You passed an invalid attribute name to either \fIcolor()\fR or \fIcolored()\fR.
.ie n .IP "Name ""%s"" used only once: possible typo" 4
.el .IP "Name ``%s'' used only once: possible typo" 4
.IX Item "Name %s used only once: possible typo"
(W) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
.Sp
It's probably better to always use commas after constant names in order to
force the next error.
.IP "No comma allowed after filehandle" 4
.IX Item "No comma allowed after filehandle"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
.Sp
Generating this fatal compile error is one of the main advantages of using
the constants interface, since you'll immediately know if you mistype a
color name.
.ie n .IP "No name for escape sequence %s" 4
.el .IP "No name for escape sequence \f(CW%s\fR" 4
.IX Item "No name for escape sequence %s"
(F) The \s-1ANSI\s0 escape sequence passed to \fIuncolor()\fR contains escapes which
aren't recognized and can't be translated to names.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1ANSI_COLORS_DISABLED\s0" 4
.IX Item "ANSI_COLORS_DISABLED"
If this environment variable is set, all of the functions defined by this
module (\fIcolor()\fR, \fIcolored()\fR, and all of the constants not previously used
in the program) will not output any escape sequences and instead will just
return the empty string or pass through the original text as appropriate.
This is intended to support easy use of scripts using this module on
platforms that don't support \s-1ANSI\s0 escape sequences.
.Sp
For it to have its proper effect, this environment variable must be set
before any color constants are used in the program.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
It would be nice if one could leave off the commas around the constants
entirely and just say:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en" RESET;
.Ve
.PP
but the syntax of Perl doesn't allow this.  You need a comma after the
string.  (Of course, you may consider it a bug that commas between all the
constants aren't required, in which case you may feel free to insert
commas unless you're using \f(CW$Term::ANSIColor::AUTORESET\fR or
\&\s-1PUSHCOLOR/POPCOLOR\s0.)
.PP
For easier debugging, you may prefer to always use the commas when not
setting \f(CW$Term::ANSIColor::AUTORESET\fR or \s-1PUSHCOLOR/POPCOLOR\s0 so that you'll
get a fatal compile error rather than a warning.
.PP
It's not possible to use this module to embed formatting and color
attributes using Perl formats.  They replace the escape character with a
space (as documented in \fIperlform\fR\|(1)), resulting in garbled output from
the unrecognized attribute.  Even if there were a way around that problem,
the format doesn't know that the non-printing escape sequence is
zero-length and would incorrectly format the output.  For formatted output
using color or other attributes, either use \fIsprintf()\fR instead or use
\&\fIformline()\fR and then add the color or other attributes after formatting and
before output.
.SH "NOTES"
.IX Header "NOTES"
The codes generated by this module are standard terminal control codes,
complying with \s-1ECMA\-048\s0 and \s-1ISO\s0 6429 (generally referred to as \*(L"\s-1ANSI\s0
color\*(R" for the color codes).  The non-color control codes (bold, dark,
italic, underline, and reverse) are part of the earlier \s-1ANSI\s0 X3.64
standard for control sequences for video terminals and peripherals.
.PP
Note that not all displays are \s-1ISO\s0 6429\-compliant, or even X3.64\-compliant
(or are even attempting to be so).  This module will not work as expected
on displays that do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows \s-1NT\s0 or Windows 2000.  They
may just be ignored, or they may display as an \s-1ESC\s0 character followed by
some apparent garbage.
.PP
Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes and others have
helped me flesh it out:
.PP
.Vb 12
\&              clear    bold     faint   under    blink   reverse  conceal
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& xterm         yes      yes      no      yes      yes      yes      yes
\& linux         yes      yes      yes    bold      yes      yes      no
\& rxvt          yes      yes      no      yes  bold/black   yes      no
\& dtterm        yes      yes      yes     yes    reverse    yes      yes
\& teraterm      yes    reverse    no      yes    rev/red    yes      no
\& aixterm      kinda   normal     no      yes      no       yes      yes
\& PuTTY         yes     color     no      yes      no       yes      no
\& Windows       yes      no       no      no       no       yes      no
\& Cygwin SSH    yes      yes      no     color    color    color     yes
\& Mac Terminal  yes      yes      no      yes      yes      yes      yes
.Ve
.PP
Windows is Windows telnet, Cygwin \s-1SSH\s0 is the OpenSSH implementation under
Cygwin on Windows \s-1NT\s0, and Mac Terminal is the Terminal application in Mac
\&\s-1OS\s0 X.  Where the entry is other than yes or no, that emulator displays the
given attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
.PP
Note that codes 3 (italic), 6 (rapid blink), and 9 (strike-through) are
specified in \s-1ANSI\s0 X3.64 and \s-1ECMA\-048\s0 but are not commonly supported by
most displays and emulators and therefore aren't supported by this module
at the present time.  \s-1ECMA\-048\s0 also specifies a large number of other
attributes, including a sequence of attributes for font changes, Fraktur
characters, double-underlining, framing, circling, and overlining.  As
none of these attributes are widely supported or useful, they also aren't
currently supported by this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1ECMA\-048\s0 is available on-line (at least at the time of this writing) at
http://www.ecma\-international.org/publications/standards/Ecma\-048.htm <http://www.ecma-international.org/publications/standards/Ecma-048.htm>.
.PP
\&\s-1ISO\s0 6429 is available from \s-1ISO\s0 for a charge; the author of this module
does not own a copy of it.  Since the source material for \s-1ISO\s0 6429 was
\&\s-1ECMA\-048\s0 and the latter is available for free, there seems little reason
to obtain the \s-1ISO\s0 standard.
.PP
The current version of this module is always available from its web site
at <http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
the Perl core distribution as of 5.6.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original idea (using constants) by Zenin, reimplemented using subs by Russ
Allbery <rra@stanford.edu>, and then combined with the original idea by
Russ with input from Zenin.  Russ Allbery now maintains this module.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010,
2011 Russ Allbery <rra@stanford.edu> and Zenin.  This program is free
software; you may redistribute it and/or modify it under the same terms as
Perl itself.
.PP
\&\s-1PUSHCOLOR\s0, \s-1POPCOLOR\s0, and \s-1LOCALCOLOR\s0 were contributed by openmethods.com
voice solutions.
         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ANSIColor5.18.3pm                      0100644 0001750 0001750 00000105534 12566207463 024375  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ANSIColor 3pm"
.TH Term::ANSIColor 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ANSIColor \- Color screen output using ANSI escape sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Term::ANSIColor;
\&    print color \*(Aqbold blue\*(Aq;
\&    print "This text is bold blue.\en";
\&    print color \*(Aqreset\*(Aq;
\&    print "This text is normal.\en";
\&    print colored("Yellow on magenta.", \*(Aqyellow on_magenta\*(Aq), "\en";
\&    print "This text is normal.\en";
\&    print colored [\*(Aqyellow on_magenta\*(Aq], \*(AqYellow on magenta.\*(Aq, "\en";
\&    print colored [\*(Aqred on_bright_yellow\*(Aq], \*(AqRed on bright yellow.\*(Aq, "\en";
\&    print colored [\*(Aqbright_red on_black\*(Aq], \*(AqBright red on black.\*(Aq, "\en";
\&    print "\en";
\&
\&    # Map escape sequences back to color names.
\&    use Term::ANSIColor 1.04 qw(uncolor);
\&    my $names = uncolor(\*(Aq01;31\*(Aq);
\&    print join(q{ }, @{$names}), "\en";
\&
\&    # Strip all color escape sequences.
\&    use Term::ANSIColor 2.01 qw(colorstrip);
\&    print colorstrip \*(Aq\ee[1mThis is bold\ee[0m\*(Aq, "\en";
\&
\&    # Determine whether a color is valid.
\&    use Term::ANSIColor 2.02 qw(colorvalid);
\&    my $valid = colorvalid(\*(Aqblue bold\*(Aq, \*(Aqon_magenta\*(Aq);
\&    print "Color string is ", $valid ? "valid\en" : "invalid\en";
\&
\&    # Create new aliases for colors.
\&    use Term::ANSIColor 4.00 qw(coloralias);
\&    coloralias(\*(Aqalert\*(Aq, \*(Aqred\*(Aq);
\&    print "Alert is ", coloralias(\*(Aqalert\*(Aq), "\en";
\&    print colored("This is in red.", \*(Aqalert\*(Aq), "\en";
\&
\&    use Term::ANSIColor qw(:constants);
\&    print BOLD, BLUE, "This text is in bold blue.\en", RESET;
\&
\&    use Term::ANSIColor qw(:constants);
\&    {
\&        local $Term::ANSIColor::AUTORESET = 1;
\&        print BOLD BLUE "This text is in bold blue.\en";
\&        print "This text is normal.\en";
\&    }
\&
\&    use Term::ANSIColor 2.00 qw(:pushpop);
\&    print PUSHCOLOR RED ON_GREEN "This text is red on green.\en";
\&    print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\en";
\&    print RESET BRIGHT_BLUE "This text is just bright blue.\en";
\&    print POPCOLOR "Back to red on green.\en";
\&    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\en";
\&    print "This text is red on green.\en";
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print ON_BLUE "This text is red on blue.\en";
\&        print "This text is red on green.\en";
\&    }
\&    print POPCOLOR "Back to whatever we started as.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has two interfaces, one through \fIcolor()\fR and \fIcolored()\fR and the
other through constants.  It also offers the utility functions \fIuncolor()\fR,
\&\fIcolorstrip()\fR, \fIcolorvalid()\fR, and \fIcoloralias()\fR, which have to be explicitly
imported to be used (see \*(L"\s-1SYNOPSIS\*(R"\s0).
.PP
See \*(L"\s-1COMPATIBILITY\*(R"\s0 for the versions of Term::ANSIColor that introduced
particular features and the versions of Perl that included them.
.SS "Supported Colors"
.IX Subsection "Supported Colors"
Terminal emulators that support color divide into two types: ones that
support only eight colors, ones that support sixteen, and ones that
support 256.  This module provides the \s-1ANSI\s0 escape codes all of them.
These colors are referred to as \s-1ANSI\s0 colors 0 through 7 (normal), 8
through 15 (16\-color), and 16 through 255 (256\-color).
.PP
Unfortunately, interpretation of colors 0 through 7 often depends on
whether the emulator supports eight colors or sixteen colors.  Emulators
that only support eight colors (such as the Linux console) will display
colors 0 through 7 with normal brightness and ignore colors 8 through 15,
treating them the same as white.  Emulators that support 16 colors, such
as gnome-terminal, normally display colors 0 through 7 as dim or darker
versions and colors 8 through 15 as normal brightness.  On such emulators,
the \*(L"normal\*(R" white (color 7) usually is shown as pale grey, requiring
bright white (15) to be used to get a real white color.  Bright black
usually is a dark grey color, although some terminals display it as pure
black.  Some sixteen-color terminal emulators also treat normal yellow
(color 3) as orange or brown, and bright yellow (color 11) as yellow.
.PP
Following the normal convention of sixteen-color emulators, this module
provides a pair of attributes for each color.  For every normal color (0
through 7), the corresponding bright color (8 through 15) is obtained by
prepending the string \f(CW\*(C`bright_\*(C'\fR to the normal color name.  For example,
\&\f(CW\*(C`red\*(C'\fR is color 1 and \f(CW\*(C`bright_red\*(C'\fR is color 9.  The same applies for
background colors: \f(CW\*(C`on_red\*(C'\fR is the normal color and \f(CW\*(C`on_bright_red\*(C'\fR is
the bright color.  Capitalize these strings for the constant interface.
.PP
For 256\-color emulators, this module additionally provides \f(CW\*(C`ansi0\*(C'\fR
through \f(CW\*(C`ansi15\*(C'\fR, which are the same as colors 0 through 15 in
sixteen-color emulators but use the 256\-color escape syntax, \f(CW\*(C`grey0\*(C'\fR
through \f(CW\*(C`grey23\*(C'\fR ranging from nearly black to nearly white, and a set of
\&\s-1RGB\s0 colors.  The \s-1RGB\s0 colors are of the form \f(CW\*(C`rgb\f(CIRGB\f(CW\*(C'\fR where \fIR\fR, \fIG\fR,
and \fIB\fR are numbers from 0 to 5 giving the intensity of red, green, and
blue.  \f(CW\*(C`on_\*(C'\fR variants of all of these colors are also provided.  These
colors may be ignored completely on non\-256\-color terminals or may be
misinterpreted and produce random behavior.  Additional attributes such as
blink, italic, or bold may not work with the 256\-color palette.
.PP
There is unfortunately no way to know whether the current emulator
supports more than eight colors, which makes the choice of colors
difficult.  The most conservative choice is to use only the regular
colors, which are at least displayed on all emulators.  However, they will
appear dark in sixteen-color terminal emulators, including most common
emulators in \s-1UNIX X\s0 environments.  If you know the display is one of those
emulators, you may wish to use the bright variants instead.  Even better,
offer the user a way to configure the colors for a given application to
fit their terminal emulator.
.SS "Function Interface"
.IX Subsection "Function Interface"
The function interface uses attribute strings to describe the colors and
text attributes to assign to text.  The recognized non-color attributes
are clear, reset, bold, dark, faint, italic, underline, underscore, blink,
reverse, and concealed.  Clear and reset (reset to default attributes),
dark and faint (dim and saturated), and underline and underscore are
equivalent, so use whichever is the most intuitive to you.
.PP
Note that not all attributes are supported by all terminal types, and some
terminals may not support any of these sequences.  Dark and faint, italic,
blink, and concealed in particular are frequently not implemented.
.PP
The recognized normal foreground color attributes (colors 0 to 7) are:
.PP
.Vb 1
\&  black  red  green  yellow  blue  magenta  cyan  white
.Ve
.PP
The corresponding bright foreground color attributes (colors 8 to 15) are:
.PP
.Vb 2
\&  bright_black  bright_red      bright_green  bright_yellow
\&  bright_blue   bright_magenta  bright_cyan   bright_white
.Ve
.PP
The recognized normal background color attributes (colors 0 to 7) are:
.PP
.Vb 2
\&  on_black  on_red      on_green  on yellow
\&  on_blue   on_magenta  on_cyan   on_white
.Ve
.PP
The recognized bright background color attributes (colors 8 to 15) are:
.PP
.Vb 2
\&  on_bright_black  on_bright_red      on_bright_green  on_bright_yellow
\&  on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white
.Ve
.PP
For 256\-color terminals, the recognized foreground colors are:
.PP
.Vb 2
\&  ansi0 .. ansi15
\&  grey0 .. grey23
.Ve
.PP
plus \f(CW\*(C`rgb\f(CIRGB\f(CW\*(C'\fR for \fIR\fR, \fIG\fR, and \fIB\fR values from 0 to 5, such as
\&\f(CW\*(C`rgb000\*(C'\fR or \f(CW\*(C`rgb515\*(C'\fR.  Similarly, the recognized background colors are:
.PP
.Vb 2
\&  on_ansi0 .. on_ansi15
\&  on_grey0 .. on_grey23
.Ve
.PP
plus \f(CW\*(C`on_rgb\f(CIRGB\f(CW\*(C'\fR for for \fIR\fR, \fIG\fR, and \fIB\fR values from 0 to 5.
.PP
For any of the above listed attributes, case is not significant.
.PP
Attributes, once set, last until they are unset (by printing the attribute
\&\f(CW\*(C`clear\*(C'\fR or \f(CW\*(C`reset\*(C'\fR).  Be careful to do this, or otherwise your attribute
will last after your script is done running, and people get very annoyed
at having their prompt and typing changed to weird colors.
.IP "color(ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "color(ATTR[, ATTR ...])"
\&\fIcolor()\fR takes any number of strings as arguments and considers them to be
space-separated lists of attributes.  It then forms and returns the escape
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to.  This is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to.  \fIcolor()\fR
throws an exception if given an invalid attribute.
.IP "colored(\s-1STRING,\s0 ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "colored(STRING, ATTR[, ATTR ...])"
.PD 0
.IP "colored(\s-1ATTR\-REF,\s0 STRING[, \s-1STRING...\s0])" 4
.IX Item "colored(ATTR-REF, STRING[, STRING...])"
.PD
As an aid in resetting colors, \fIcolored()\fR takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.
.Sp
Normally, \fIcolored()\fR just puts attribute codes at the beginning and end of
the string, but if you set \f(CW$Term::ANSIColor::EACHLINE\fR to some string, that
string will be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset at the end of
each line.  This is often desirable if the output contains newlines and
you're using background colors, since a background color that persists
across a newline is often interpreted by the terminal as providing the
default background color for the next line.  Programs like pagers can also
be confused by attributes that span lines.  Normally you'll want to set
\&\f(CW$Term::ANSIColor::EACHLINE\fR to \f(CW"\en"\fR to use this feature.
.IP "uncolor(\s-1ESCAPE\s0)" 4
.IX Item "uncolor(ESCAPE)"
\&\fIuncolor()\fR performs the opposite translation as \fIcolor()\fR, turning escape
sequences into a list of strings corresponding to the attributes being set
by those sequences.
.IP "colorstrip(STRING[, \s-1STRING ...\s0])" 4
.IX Item "colorstrip(STRING[, STRING ...])"
\&\fIcolorstrip()\fR removes all color escape sequences from the provided strings,
returning the modified strings separately in array context or joined
together in scalar context.  Its arguments are not modified.
.IP "colorvalid(ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "colorvalid(ATTR[, ATTR ...])"
\&\fIcolorvalid()\fR takes attribute strings the same as \fIcolor()\fR and returns true
if all attributes are known and false otherwise.
.IP "coloralias(ALIAS[, \s-1ATTR\s0])" 4
.IX Item "coloralias(ALIAS[, ATTR])"
If \s-1ATTR\s0 is specified, \fIcoloralias()\fR sets up an alias of \s-1ALIAS\s0 for the
standard color \s-1ATTR. \s0 From that point forward, \s-1ALIAS\s0 can be passed into
\&\fIcolor()\fR, \fIcolored()\fR, and \fIcolorvalid()\fR and will have the same meaning as
\&\s-1ATTR. \s0 One possible use of this facility is to give more meaningful names
to the 256\-color \s-1RGB\s0 colors.  Only alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`_\*(C'\fR, and \f(CW\*(C`\-\*(C'\fR are
allowed in alias names.
.Sp
If \s-1ATTR\s0 is not specified, \fIcoloralias()\fR returns the standard color name to
which \s-1ALIAS\s0 is aliased, if any, or undef if \s-1ALIAS\s0 does not exist.
.Sp
This is the same facility used by the \s-1ANSI_COLORS_ALIASES\s0 environment
variable (see \*(L"\s-1ENVIRONMENT\*(R"\s0 below) but can be used at runtime, not just
when the module is loaded.
.Sp
Later invocations of \fIcoloralias()\fR with the same \s-1ALIAS\s0 will override
earlier aliases.  There is no way to remove an alias.
.Sp
Aliases have no effect on the return value of \fIuncolor()\fR.
.Sp
\&\fB\s-1WARNING\s0\fR: Aliases are global and affect all callers in the same process.
There is no way to set an alias limited to a particular block of code or a
particular object.
.SS "Constant Interface"
.IX Subsection "Constant Interface"
Alternately, if you import \f(CW\*(C`:constants\*(C'\fR, you can use the following
constants directly:
.PP
.Vb 3
\&  CLEAR           RESET             BOLD            DARK
\&  FAINT           ITALIC            UNDERLINE       UNDERSCORE
\&  BLINK           REVERSE           CONCEALED
\&
\&  BLACK           RED               GREEN           YELLOW
\&  BLUE            MAGENTA           CYAN            WHITE
\&  BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
\&  BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE
\&
\&  ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
\&  ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
\&  ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
\&  ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
.Ve
.PP
These are the same as color('attribute') and can be used if you prefer
typing:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text", RESET, "\en";
.Ve
.PP
to
.PP
.Vb 1
\&    print colored ("Text", \*(Aqbold blue on_white\*(Aq), "\en";
.Ve
.PP
(Note that the newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)
.PP
If you import \f(CW\*(C`:constants256\*(C'\fR, you can use the following constants
directly:
.PP
.Vb 2
\&  ANSI0 .. ANSI15
\&  GREY0 .. GREY23
\&
\&  RGBXYZ (for X, Y, and Z values from 0 to 5, like RGB000 or RGB515)
\&
\&  ON_ANSI0 .. ON_ANSI15
\&  ON_GREY0 .. ON_GREY23
\&
\&  ON_RGBXYZ (for X, Y, and Z values from 0 to 5)
.Ve
.PP
Note that \f(CW\*(C`:constants256\*(C'\fR does not include the other constants, so if you
want to mix both, you need to include \f(CW\*(C`:constants\*(C'\fR as well.  You may want
to explicitly import at least \f(CW\*(C`RESET\*(C'\fR, as in:
.PP
.Vb 1
\&    use Term::ANSIColor 4.00 qw(RESET :constants256);
.Ve
.PP
When using the constants, if you don't want to have to remember to add the
\&\f(CW\*(C`, RESET\*(C'\fR at the end of each print line, you can set
\&\f(CW$Term::ANSIColor::AUTORESET\fR to a true value.  Then, the display mode will
automatically be reset if there is no comma after the constant.  In other
words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
.PP
will reset the display mode afterward, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
.PP
will not.  If you are using background colors, you will probably want to
either use \fIsay()\fR (in newer versions of Perl) or print the newline with a
separate print statement to avoid confusing the terminal.
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set (see below), it takes precedence
over \f(CW$Term::ANSIColor::AUTORESET\fR, and the latter is ignored.
.PP
The subroutine interface has the advantage over the constants interface in
that only two subroutines are exported into your namespace, versus
thirty-eight in the constants interface.  On the flip side, the constants
interface has the advantage of better compile time error checking, since
misspelled names of colors or attributes in calls to \fIcolor()\fR and \fIcolored()\fR
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, pollute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, \s-1TMTOWTDI\s0 after all.
.SS "The Color Stack"
.IX Subsection "The Color Stack"
You can import \f(CW\*(C`:pushpop\*(C'\fR and maintain a stack of colors using \s-1PUSHCOLOR,
POPCOLOR,\s0 and \s-1LOCALCOLOR.  PUSHCOLOR\s0 takes the attribute string that
starts its argument and pushes it onto a stack of attributes.  \s-1POPCOLOR\s0
removes the top of the stack and restores the previous attributes set by
the argument of a prior \s-1PUSHCOLOR.  LOCALCOLOR\s0 surrounds its argument in a
\&\s-1PUSHCOLOR\s0 and \s-1POPCOLOR\s0 so that the color resets afterward.
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set, each sequence of color constants
will be implicitly preceded by \s-1LOCALCOLOR. \s0 In other words, the following:
.PP
.Vb 4
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print BLUE "Text\en";
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    print LOCALCOLOR BLUE "Text\en";
.Ve
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set, it takes precedence over
\&\f(CW$Term::ANSIColor::AUTORESET\fR, and the latter is ignored.
.PP
When using \s-1PUSHCOLOR, POPCOLOR,\s0 and \s-1LOCALCOLOR,\s0 it's particularly
important to not put commas between the constants.
.PP
.Vb 1
\&    print PUSHCOLOR BLUE "Text\en";
.Ve
.PP
will correctly push \s-1BLUE\s0 onto the top of the stack.
.PP
.Vb 1
\&    print PUSHCOLOR, BLUE, "Text\en";    # wrong!
.Ve
.PP
will not, and a subsequent pop won't restore the correct attributes.
\&\s-1PUSHCOLOR\s0 pushes the attributes set by its argument, which is normally a
string of color constants.  It can't ask the terminal what the current
attributes are.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Bad color mapping %s" 4
.el .IP "Bad color mapping \f(CW%s\fR" 4
.IX Item "Bad color mapping %s"
(W) The specified color mapping from \s-1ANSI_COLORS_ALIASES\s0 is not valid and
could not be parsed.  It was ignored.
.ie n .IP "Bad escape sequence %s" 4
.el .IP "Bad escape sequence \f(CW%s\fR" 4
.IX Item "Bad escape sequence %s"
(F) You passed an invalid \s-1ANSI\s0 escape sequence to \fIuncolor()\fR.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while strict subs in use"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
.Sp
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
.Sp
This will only show up under use strict (another good reason to run under
use strict).
.ie n .IP "Cannot alias standard color %s" 4
.el .IP "Cannot alias standard color \f(CW%s\fR" 4
.IX Item "Cannot alias standard color %s"
(F) The alias name passed to \fIcoloralias()\fR matches a standard color name.
Standard color names cannot be aliased.
.ie n .IP "Cannot alias standard color %s in %s" 4
.el .IP "Cannot alias standard color \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Cannot alias standard color %s in %s"
(W) The same, but in \s-1ANSI_COLORS_ALIASES. \s0 The color mapping was ignored.
.ie n .IP "Invalid alias name %s" 4
.el .IP "Invalid alias name \f(CW%s\fR" 4
.IX Item "Invalid alias name %s"
(F) You passed an invalid alias name to \fIcoloralias()\fR.  Alias names must
consist only of alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, and \f(CW\*(C`_\*(C'\fR.
.ie n .IP "Invalid alias name %s in %s" 4
.el .IP "Invalid alias name \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Invalid alias name %s in %s"
(W) You specified an invalid alias name on the left hand of the equal sign
in a color mapping in \s-1ANSI_COLORS_ALIASES. \s0 The color mapping was ignored.
.ie n .IP "Invalid attribute name %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
(F) You passed an invalid attribute name to \fIcolor()\fR, \fIcolored()\fR, or
\&\fIcoloralias()\fR.
.ie n .IP "Invalid attribute name %s in %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR in \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s in %s"
(W) You specified an invalid attribute name on the right hand of the equal
sign in a color mapping in \s-1ANSI_COLORS_ALIASES. \s0 The color mapping was
ignored.
.ie n .IP "Name ""%s"" used only once: possible typo" 4
.el .IP "Name ``%s'' used only once: possible typo" 4
.IX Item "Name %s used only once: possible typo"
(W) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
.Sp
It's probably better to always use commas after constant names in order to
force the next error.
.IP "No comma allowed after filehandle" 4
.IX Item "No comma allowed after filehandle"
(F) You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
.Sp
Generating this fatal compile error is one of the main advantages of using
the constants interface, since you'll immediately know if you mistype a
color name.
.ie n .IP "No name for escape sequence %s" 4
.el .IP "No name for escape sequence \f(CW%s\fR" 4
.IX Item "No name for escape sequence %s"
(F) The \s-1ANSI\s0 escape sequence passed to \fIuncolor()\fR contains escapes which
aren't recognized and can't be translated to names.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1ANSI_COLORS_ALIASES\s0" 4
.IX Item "ANSI_COLORS_ALIASES"
This environment variable allows the user to specify custom color aliases
that will be understood by \fIcolor()\fR, \fIcolored()\fR, and \fIcolorvalid()\fR.  None of
the other functions will be affected, and no new color constants will be
created.  The custom colors are aliases for existing color names; no new
escape sequences can be introduced.  Only alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`_\*(C'\fR, and
\&\f(CW\*(C`\-\*(C'\fR are allowed in alias names.
.Sp
The format is:
.Sp
.Vb 1
\&    ANSI_COLORS_ALIASES=\*(Aqnewcolor1=oldcolor1,newcolor2=oldcolor2\*(Aq
.Ve
.Sp
Whitespace is ignored.
.Sp
For example the Solarized <http://ethanschoonover.com/solarized> colors
can be mapped with:
.Sp
.Vb 11
\&    ANSI_COLORS_ALIASES=\*(Aq\e
\&        base00=bright_yellow, on_base00=on_bright_yellow,\e
\&        base01=bright_green,  on_base01=on_bright_green, \e
\&        base02=black,         on_base02=on_black,        \e
\&        base03=bright_black,  on_base03=on_bright_black, \e
\&        base0=bright_blue,    on_base0=on_bright_blue,   \e
\&        base1=bright_cyan,    on_base1=on_bright_cyan,   \e
\&        base2=white,          on_base2=on_white,         \e
\&        base3=bright_white,   on_base3=on_bright_white,  \e
\&        orange=bright_red,    on_orange=on_bright_red,   \e
\&        violet=bright_magenta,on_violet=on_bright_magenta\*(Aq
.Ve
.Sp
This environment variable is read and applied when the Term::ANSIColor
module is loaded and is then subsequently ignored.  Changes to
\&\s-1ANSI_COLORS_ALIASES\s0 after the module is loaded will have no effect.  See
\&\fIcoloralias()\fR for an equivalent facility that can be used at runtime.
.IP "\s-1ANSI_COLORS_DISABLED\s0" 4
.IX Item "ANSI_COLORS_DISABLED"
If this environment variable is set to a true value, all of the functions
defined by this module (\fIcolor()\fR, \fIcolored()\fR, and all of the constants not
previously used in the program) will not output any escape sequences and
instead will just return the empty string or pass through the original
text as appropriate.  This is intended to support easy use of scripts
using this module on platforms that don't support \s-1ANSI\s0 escape sequences.
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
Term::ANSIColor was first included with Perl in Perl 5.6.0.
.PP
The \fIuncolor()\fR function and support for \s-1ANSI_COLORS_DISABLED\s0 were added in
Term::ANSIColor 1.04, included in Perl 5.8.0.
.PP
Support for dark was added in Term::ANSIColor 1.08, included in Perl
5.8.4.
.PP
The color stack, including the \f(CW\*(C`:pushpop\*(C'\fR import tag, \s-1PUSHCOLOR,
POPCOLOR, LOCALCOLOR,\s0 and the \f(CW$Term::ANSIColor::AUTOLOCAL\fR variable, was
added in Term::ANSIColor 2.00, included in Perl 5.10.1.
.PP
\&\fIcolorstrip()\fR was added in Term::ANSIColor 2.01 and \fIcolorvalid()\fR was added
in Term::ANSIColor 2.02, both included in Perl 5.11.0.
.PP
Support for colors 8 through 15 (the \f(CW\*(C`bright_\*(C'\fR variants) was added in
Term::ANSIColor 3.00, included in Perl 5.13.3.
.PP
Support for italic was added in Term::ANSIColor 3.02, included in Perl
5.17.1.
.PP
Support for colors 16 through 256 (the \f(CW\*(C`ansi\*(C'\fR, \f(CW\*(C`rgb\*(C'\fR, and \f(CW\*(C`grey\*(C'\fR
colors), the \f(CW\*(C`:constants256\*(C'\fR import tag, the \fIcoloralias()\fR function, and
support for the \s-1ANSI_COLORS_ALIASES\s0 environment variable were added in
Term::ANSIColor 4.00.
.PP
\&\f(CW$Term::ANSIColor::AUTOLOCAL\fR was changed to take precedence over
\&\f(CW$Term::ANSIColor::AUTORESET\fR, rather than the other way around, in
Term::ANSIColor 4.00.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
It would be nice if one could leave off the commas around the constants
entirely and just say:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en" RESET;
.Ve
.PP
but the syntax of Perl doesn't allow this.  You need a comma after the
string.  (Of course, you may consider it a bug that commas between all the
constants aren't required, in which case you may feel free to insert
commas unless you're using \f(CW$Term::ANSIColor::AUTORESET\fR or
\&\s-1PUSHCOLOR/POPCOLOR.\s0)
.PP
For easier debugging, you may prefer to always use the commas when not
setting \f(CW$Term::ANSIColor::AUTORESET\fR or \s-1PUSHCOLOR/POPCOLOR\s0 so that you'll
get a fatal compile error rather than a warning.
.PP
It's not possible to use this module to embed formatting and color
attributes using Perl formats.  They replace the escape character with a
space (as documented in \fIperlform\fR\|(1)), resulting in garbled output from
the unrecognized attribute.  Even if there were a way around that problem,
the format doesn't know that the non-printing escape sequence is
zero-length and would incorrectly format the output.  For formatted output
using color or other attributes, either use \fIsprintf()\fR instead or use
\&\fIformline()\fR and then add the color or other attributes after formatting and
before output.
.SH "NOTES"
.IX Header "NOTES"
The codes generated by this module are standard terminal control codes,
complying with \s-1ECMA\-048\s0 and \s-1ISO 6429 \s0(generally referred to as \*(L"\s-1ANSI\s0
color\*(R" for the color codes).  The non-color control codes (bold, dark,
italic, underline, and reverse) are part of the earlier \s-1ANSI X3.64\s0
standard for control sequences for video terminals and peripherals.
.PP
Note that not all displays are \s-1ISO\s0 6429\-compliant, or even X3.64\-compliant
(or are even attempting to be so).  This module will not work as expected
on displays that do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows \s-1NT\s0 or Windows 2000.  They
may just be ignored, or they may display as an \s-1ESC\s0 character followed by
some apparent garbage.
.PP
Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes and others have
helped me flesh it out:
.PP
.Vb 12
\&              clear    bold     faint   under    blink   reverse  conceal
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& xterm         yes      yes      no      yes      yes      yes      yes
\& linux         yes      yes      yes    bold      yes      yes      no
\& rxvt          yes      yes      no      yes  bold/black   yes      no
\& dtterm        yes      yes      yes     yes    reverse    yes      yes
\& teraterm      yes    reverse    no      yes    rev/red    yes      no
\& aixterm      kinda   normal     no      yes      no       yes      yes
\& PuTTY         yes     color     no      yes      no       yes      no
\& Windows       yes      no       no      no       no       yes      no
\& Cygwin SSH    yes      yes      no     color    color    color     yes
\& Terminal.app  yes      yes      no      yes      yes      yes      yes
.Ve
.PP
Windows is Windows telnet, Cygwin \s-1SSH\s0 is the OpenSSH implementation under
Cygwin on Windows \s-1NT,\s0 and Mac Terminal is the Terminal application in Mac
\&\s-1OS X. \s0 Where the entry is other than yes or no, that emulator displays the
given attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
.PP
Support for code 3 (italic) is rare and therefore not mentioned in that
table.  It is not believed to be fully supported by any of the terminals
listed, although it's displayed as green in the Linux console, but it is
reportedly supported by urxvt.
.PP
Note that codes 6 (rapid blink) and 9 (strike-through) are specified in
\&\s-1ANSI X3.64\s0 and \s-1ECMA\-048\s0 but are not commonly supported by most displays
and emulators and therefore aren't supported by this module at the present
time.  \s-1ECMA\-048\s0 also specifies a large number of other attributes,
including a sequence of attributes for font changes, Fraktur characters,
double-underlining, framing, circling, and overlining.  As none of these
attributes are widely supported or useful, they also aren't currently
supported by this module.
.PP
Most modern X terminal emulators support 256 colors.  Known to not support
those colors are aterm, rxvt, Terminal.app, and \s-1TTY/VC.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1ECMA\-048\s0 is available on-line (at least at the time of this writing) at
<http://www.ecma\-international.org/publications/standards/Ecma\-048.htm>.
.PP
\&\s-1ISO 6429\s0 is available from \s-1ISO\s0 for a charge; the author of this module
does not own a copy of it.  Since the source material for \s-1ISO 6429\s0 was
\&\s-1ECMA\-048\s0 and the latter is available for free, there seems little reason
to obtain the \s-1ISO\s0 standard.
.PP
The 256\-color control sequences are documented at
<http://www.xfree86.org/current/ctlseqs.html> (search for 256\-color).
.PP
The \s-1CPAN\s0 module Term::ExtendedColor provides a different and more
comprehensive interface for 256\-color emulators that may be more
convenient.
.PP
The current version of this module is always available from its web site
at <http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
the Perl core distribution as of 5.6.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original idea (using constants) by Zenin, reimplemented using subs by Russ
Allbery <rra@stanford.edu>, and then combined with the original idea by
Russ with input from Zenin.  256\-color support is based on work by Kurt
Starsinic.  Russ Allbery now maintains this module.
.PP
\&\s-1PUSHCOLOR, POPCOLOR,\s0 and \s-1LOCALCOLOR\s0 were contributed by openmethods.com
voice solutions.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1996 Zenin.  Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005,
2006, 2008, 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>.
Copyright 2012 Kurt Starsinic <kstarsinic@gmail.com>.  This program is
free software; you may redistribute it and/or modify it under the same
terms as Perl itself.
                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::Cap.3pm                                0100644 0001750 0001750 00000027274 12566207463 023037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Cap 3pm"
.TH Term::Cap 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Cap \- Perl termcap interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    require Term::Cap;
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&    $terminal\->Trequire(qw/ce ku kd/);
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count, $FH);
\&    $terminal\->Tpad($string, $count, $FH);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are low-level functions to extract and use capabilities from
a terminal capability (termcap) database.
.PP
More information on the terminal capabilities will be found in the
termcap manpage on most Unix-like systems.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
The output strings for \fBTputs\fR are cached for counts of 1 for performance.
\&\fBTgoto\fR and \fBTpad\fR do not cache.  \f(CW\*(C`$self\->{_xx}\*(C'\fR is the raw termcap
data and \f(CW\*(C`$self\->{xx}\*(C'\fR is the cached version.
.PP
.Vb 1
\&    print $terminal\->Tpad($self\->{_xx}, 1);
.Ve
.PP
\&\fBTgoto\fR, \fBTputs\fR, and \fBTpad\fR return the string and will also
output the string to \f(CW$FH\fR if specified.
.IP "\fBTgetent\fR" 4
.IX Item "Tgetent"
Returns a blessed object reference which the user can
then use to send the control strings to the terminal using \fBTputs\fR
and \fBTgoto\fR.
.Sp
The function extracts the entry of the specified terminal
type \fI\s-1TERM\s0\fR (defaults to the environment variable \fI\s-1TERM\s0\fR) from the
database.
.Sp
It will look in the environment for a \fI\s-1TERMCAP\s0\fR variable.  If
found, and the value does not begin with a slash, and the terminal
type name is the same as the environment string \fI\s-1TERM\s0\fR, the
\&\fI\s-1TERMCAP\s0\fR string is used instead of reading a termcap file.  If
it does begin with a slash, the string is used as a path name of
the termcap file to search.  If \fI\s-1TERMCAP\s0\fR does not begin with a
slash and name is different from \fI\s-1TERM\s0\fR, \fBTgetent\fR searches the
files \fI\f(CI$HOME\fI/.termcap\fR, \fI/etc/termcap\fR, and \fI/usr/share/misc/termcap\fR,
in that order, unless the environment variable \fI\s-1TERMPATH\s0\fR exists,
in which case it specifies a list of file pathnames (separated by
spaces or colons) to be searched \fBinstead\fR.  Whenever multiple
files are searched and a tc field occurs in the requested entry,
the entry it names must be found in the same file or one of the
succeeding files.  If there is a \f(CW\*(C`:tc=...:\*(C'\fR in the \fI\s-1TERMCAP\s0\fR
environment variable string it will continue the search in the
files as above.
.Sp
The extracted termcap entry is available in the object
as \f(CW\*(C`$self\->{TERMCAP}\*(C'\fR.
.Sp
It takes a hash reference as an argument with two optional keys:
.RS 4
.IP "\s-1OSPEED\s0" 2
.IX Item "OSPEED"
The terminal output bit rate (often mistakenly called the baud rate)
for this terminal \- if not set a warning will be generated
and it will be defaulted to 9600.  \fI\s-1OSPEED\s0\fR can be be specified as
either a \s-1POSIX\s0 termios/SYSV termio speeds (where 9600 equals 9600) or
an old DSD-style speed ( where 13 equals 9600).
.IP "\s-1TERM\s0" 2
.IX Item "TERM"
The terminal type whose termcap entry will be used \- if not supplied it will
default to \f(CW$ENV\fR{\s-1TERM\s0}: if that is not set then \fBTgetent\fR will croak.
.RE
.RS 4
.Sp
It calls \f(CW\*(C`croak\*(C'\fR on failure.
.RE
.IP "\fBTpad\fR" 4
.IX Item "Tpad"
Outputs a literal string with appropriate padding for the current terminal.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$string\fB\fR" 2
.el .IP "\fB\f(CB$string\fB\fR" 2
.IX Item "$string"
The literal string to be output.  If it starts with a number and an optional
\&'*' then the padding will be increased by an amount relative to this number,
if the '*' is present then this amount will me multiplied by \f(CW$cnt\fR.  This part
of \f(CW$string\fR is removed before output/
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
Will be used to modify the padding applied to string as described above.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The padded \f(CW$string\fR is returned.
.RE
.IP "\fBTputs\fR" 4
.IX Item "Tputs"
Output the string for the given capability padded as appropriate without
any parameter substitution.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The capability whose string is to be output.
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
A count passed to Tpad to modify the padding applied to the output string.
If \f(CW$cnt\fR is zero or one then the resulting string will be cached.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The appropriate string for the capability will be returned.
.RE
.IP "\fBTgoto\fR" 4
.IX Item "Tgoto"
\&\fBTgoto\fR decodes a cursor addressing string with the given parameters.
.Sp
There are four arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The name of the capability to be output.
.ie n .IP "\fB\fB$col\fB\fR" 2
.el .IP "\fB\f(CB$col\fB\fR" 2
.IX Item "$col"
The first value to be substituted in the output string ( usually the column
in a cursor addressing capability )
.ie n .IP "\fB\fB$row\fB\fR" 2
.el .IP "\fB\f(CB$row\fB\fR" 2
.IX Item "$row"
The second value to be substituted in the output string (usually the row
in cursor addressing capabilities)
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) to which the output string will be
printed.
.RE
.RS 4
.Sp
Substitutions are made with \f(CW$col\fR and \f(CW$row\fR in the output string with the
following \fIsprintf()\fR line formats:
.Sp
.Vb 6
\& %%   output \`%\*(Aq
\& %d   output value as in printf %d
\& %2   output value as in printf %2d
\& %3   output value as in printf %3d
\& %.   output value as in printf %c
\& %+x  add x to value, then do %.
\&
\& %>xy if value > x then add y, no output
\& %r   reverse order of two parameters, no output
\& %i   increment by one, no output
\& %B   BCD (16*(value/10)) + (value%10), no output
\&
\& %n   exclusive\-or all parameters with 0140 (Datamedia 2500)
\& %D   Reverse coding (value \- 2*(value%16)), no output (Delta Data)
.Ve
.Sp
The output string will be returned.
.RE
.IP "\fBTrequire\fR" 4
.IX Item "Trequire"
Takes a list of capabilities as an argument and will croak if one is not
found.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&    use Term::Cap;
\&
\&    # Get terminal output speed
\&    require POSIX;
\&    my $termios = new POSIX::Termios;
\&    $termios\->getattr;
\&    my $ospeed = $termios\->getospeed;
\&
\&    # Old\-style ioctl code to get ospeed:
\&    #     require \*(Aqioctl.pl\*(Aq;
\&    #     ioctl(TTY,$TIOCGETP,$sgtty);
\&    #     ($ispeed,$ospeed) = unpack(\*(Aqcc\*(Aq,$sgtty);
\&
\&    # allocate and initialize a terminal structure
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&
\&    # require certain capabilities to be available
\&    $terminal\->Trequire(qw/ce ku kd/);
\&
\&    # Output Routines, if $FH is undefined these just return the string
\&
\&    # Tgoto does the % expansion stuff with the given args
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&
\&    # Tputs doesn\*(Aqt do any % expansion.
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count = 1, $FH);
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Please see the \s-1README\s0 file in distribution.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is part of the core Perl distribution and is also maintained
for \s-1CPAN\s0 by Jonathan Stowe <jns@gellyfish.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fItermcap\fR\|(5)
                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::Cap5.16.3pm                            0100644 0001750 0001750 00000026753 12566207441 023346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Cap 3pm"
.TH Term::Cap 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Cap \- Perl termcap interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    require Term::Cap;
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&    $terminal\->Trequire(qw/ce ku kd/);
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count, $FH);
\&    $terminal\->Tpad($string, $count, $FH);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are low-level functions to extract and use capabilities from
a terminal capability (termcap) database.
.PP
More information on the terminal capabilities will be found in the
termcap manpage on most Unix-like systems.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
The output strings for \fBTputs\fR are cached for counts of 1 for performance.
\&\fBTgoto\fR and \fBTpad\fR do not cache.  \f(CW\*(C`$self\->{_xx}\*(C'\fR is the raw termcap
data and \f(CW\*(C`$self\->{xx}\*(C'\fR is the cached version.
.PP
.Vb 1
\&    print $terminal\->Tpad($self\->{_xx}, 1);
.Ve
.PP
\&\fBTgoto\fR, \fBTputs\fR, and \fBTpad\fR return the string and will also
output the string to \f(CW$FH\fR if specified.
.IP "\fBTgetent\fR" 4
.IX Item "Tgetent"
Returns a blessed object reference which the user can
then use to send the control strings to the terminal using \fBTputs\fR
and \fBTgoto\fR.
.Sp
The function extracts the entry of the specified terminal
type \fI\s-1TERM\s0\fR (defaults to the environment variable \fI\s-1TERM\s0\fR) from the
database.
.Sp
It will look in the environment for a \fI\s-1TERMCAP\s0\fR variable.  If
found, and the value does not begin with a slash, and the terminal
type name is the same as the environment string \fI\s-1TERM\s0\fR, the
\&\fI\s-1TERMCAP\s0\fR string is used instead of reading a termcap file.  If
it does begin with a slash, the string is used as a path name of
the termcap file to search.  If \fI\s-1TERMCAP\s0\fR does not begin with a
slash and name is different from \fI\s-1TERM\s0\fR, \fBTgetent\fR searches the
files \fI\f(CI$HOME\fI/.termcap\fR, \fI/etc/termcap\fR, and \fI/usr/share/misc/termcap\fR,
in that order, unless the environment variable \fI\s-1TERMPATH\s0\fR exists,
in which case it specifies a list of file pathnames (separated by
spaces or colons) to be searched \fBinstead\fR.  Whenever multiple
files are searched and a tc field occurs in the requested entry,
the entry it names must be found in the same file or one of the
succeeding files.  If there is a \f(CW\*(C`:tc=...:\*(C'\fR in the \fI\s-1TERMCAP\s0\fR
environment variable string it will continue the search in the
files as above.
.Sp
The extracted termcap entry is available in the object
as \f(CW\*(C`$self\->{TERMCAP}\*(C'\fR.
.Sp
It takes a hash reference as an argument with two optional keys:
.RS 4
.IP "\s-1OSPEED\s0" 2
.IX Item "OSPEED"
The terminal output bit rate (often mistakenly called the baud rate)
for this terminal \- if not set a warning will be generated
and it will be defaulted to 9600.  \fI\s-1OSPEED\s0\fR can be be specified as
either a \s-1POSIX\s0 termios/SYSV termio speeds (where 9600 equals 9600) or
an old DSD-style speed ( where 13 equals 9600).
.IP "\s-1TERM\s0" 2
.IX Item "TERM"
The terminal type whose termcap entry will be used \- if not supplied it will
default to \f(CW$ENV\fR{\s-1TERM\s0}: if that is not set then \fBTgetent\fR will croak.
.RE
.RS 4
.Sp
It calls \f(CW\*(C`croak\*(C'\fR on failure.
.RE
.IP "\fBTpad\fR" 4
.IX Item "Tpad"
Outputs a literal string with appropriate padding for the current terminal.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$string\fB\fR" 2
.el .IP "\fB\f(CB$string\fB\fR" 2
.IX Item "$string"
The literal string to be output.  If it starts with a number and an optional
\&'*' then the padding will be increased by an amount relative to this number,
if the '*' is present then this amount will me multiplied by \f(CW$cnt\fR.  This part
of \f(CW$string\fR is removed before output/
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
Will be used to modify the padding applied to string as described above.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The padded \f(CW$string\fR is returned.
.RE
.IP "\fBTputs\fR" 4
.IX Item "Tputs"
Output the string for the given capability padded as appropriate without
any parameter substitution.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The capability whose string is to be output.
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
A count passed to Tpad to modify the padding applied to the output string.
If \f(CW$cnt\fR is zero or one then the resulting string will be cached.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The appropriate string for the capability will be returned.
.RE
.IP "\fBTgoto\fR" 4
.IX Item "Tgoto"
\&\fBTgoto\fR decodes a cursor addressing string with the given parameters.
.Sp
There are four arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The name of the capability to be output.
.ie n .IP "\fB\fB$col\fB\fR" 2
.el .IP "\fB\f(CB$col\fB\fR" 2
.IX Item "$col"
The first value to be substituted in the output string ( usually the column
in a cursor addressing capability )
.ie n .IP "\fB\fB$row\fB\fR" 2
.el .IP "\fB\f(CB$row\fB\fR" 2
.IX Item "$row"
The second value to be substituted in the output string (usually the row
in cursor addressing capabilities)
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) to which the output string will be
printed.
.RE
.RS 4
.Sp
Substitutions are made with \f(CW$col\fR and \f(CW$row\fR in the output string with the
following \fIsprintf()\fR line formats:
.Sp
.Vb 6
\& %%   output \`%\*(Aq
\& %d   output value as in printf %d
\& %2   output value as in printf %2d
\& %3   output value as in printf %3d
\& %.   output value as in printf %c
\& %+x  add x to value, then do %.
\&
\& %>xy if value > x then add y, no output
\& %r   reverse order of two parameters, no output
\& %i   increment by one, no output
\& %B   BCD (16*(value/10)) + (value%10), no output
\&
\& %n   exclusive\-or all parameters with 0140 (Datamedia 2500)
\& %D   Reverse coding (value \- 2*(value%16)), no output (Delta Data)
.Ve
.Sp
The output string will be returned.
.RE
.IP "\fBTrequire\fR" 4
.IX Item "Trequire"
Takes a list of capabilities as an argument and will croak if one is not
found.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&    use Term::Cap;
\&
\&    # Get terminal output speed
\&    require POSIX;
\&    my $termios = new POSIX::Termios;
\&    $termios\->getattr;
\&    my $ospeed = $termios\->getospeed;
\&
\&    # Old\-style ioctl code to get ospeed:
\&    #     require \*(Aqioctl.pl\*(Aq;
\&    #     ioctl(TTY,$TIOCGETP,$sgtty);
\&    #     ($ispeed,$ospeed) = unpack(\*(Aqcc\*(Aq,$sgtty);
\&
\&    # allocate and initialize a terminal structure
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&
\&    # require certain capabilities to be available
\&    $terminal\->Trequire(qw/ce ku kd/);
\&
\&    # Output Routines, if $FH is undefined these just return the string
\&
\&    # Tgoto does the % expansion stuff with the given args
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&
\&    # Tputs doesn\*(Aqt do any % expansion.
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count = 1, $FH);
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Please see the \s-1README\s0 file in distribution.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is part of the core Perl distribution and is also maintained
for \s-1CPAN\s0 by Jonathan Stowe <jns@gellyfish.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fItermcap\fR\|(5)
                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::Cap5.18.3pm                            0100644 0001750 0001750 00000027274 12566207463 023353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Cap 3pm"
.TH Term::Cap 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Cap \- Perl termcap interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    require Term::Cap;
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&    $terminal\->Trequire(qw/ce ku kd/);
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count, $FH);
\&    $terminal\->Tpad($string, $count, $FH);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are low-level functions to extract and use capabilities from
a terminal capability (termcap) database.
.PP
More information on the terminal capabilities will be found in the
termcap manpage on most Unix-like systems.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
The output strings for \fBTputs\fR are cached for counts of 1 for performance.
\&\fBTgoto\fR and \fBTpad\fR do not cache.  \f(CW\*(C`$self\->{_xx}\*(C'\fR is the raw termcap
data and \f(CW\*(C`$self\->{xx}\*(C'\fR is the cached version.
.PP
.Vb 1
\&    print $terminal\->Tpad($self\->{_xx}, 1);
.Ve
.PP
\&\fBTgoto\fR, \fBTputs\fR, and \fBTpad\fR return the string and will also
output the string to \f(CW$FH\fR if specified.
.IP "\fBTgetent\fR" 4
.IX Item "Tgetent"
Returns a blessed object reference which the user can
then use to send the control strings to the terminal using \fBTputs\fR
and \fBTgoto\fR.
.Sp
The function extracts the entry of the specified terminal
type \fI\s-1TERM\s0\fR (defaults to the environment variable \fI\s-1TERM\s0\fR) from the
database.
.Sp
It will look in the environment for a \fI\s-1TERMCAP\s0\fR variable.  If
found, and the value does not begin with a slash, and the terminal
type name is the same as the environment string \fI\s-1TERM\s0\fR, the
\&\fI\s-1TERMCAP\s0\fR string is used instead of reading a termcap file.  If
it does begin with a slash, the string is used as a path name of
the termcap file to search.  If \fI\s-1TERMCAP\s0\fR does not begin with a
slash and name is different from \fI\s-1TERM\s0\fR, \fBTgetent\fR searches the
files \fI\f(CI$HOME\fI/.termcap\fR, \fI/etc/termcap\fR, and \fI/usr/share/misc/termcap\fR,
in that order, unless the environment variable \fI\s-1TERMPATH\s0\fR exists,
in which case it specifies a list of file pathnames (separated by
spaces or colons) to be searched \fBinstead\fR.  Whenever multiple
files are searched and a tc field occurs in the requested entry,
the entry it names must be found in the same file or one of the
succeeding files.  If there is a \f(CW\*(C`:tc=...:\*(C'\fR in the \fI\s-1TERMCAP\s0\fR
environment variable string it will continue the search in the
files as above.
.Sp
The extracted termcap entry is available in the object
as \f(CW\*(C`$self\->{TERMCAP}\*(C'\fR.
.Sp
It takes a hash reference as an argument with two optional keys:
.RS 4
.IP "\s-1OSPEED\s0" 2
.IX Item "OSPEED"
The terminal output bit rate (often mistakenly called the baud rate)
for this terminal \- if not set a warning will be generated
and it will be defaulted to 9600.  \fI\s-1OSPEED\s0\fR can be be specified as
either a \s-1POSIX\s0 termios/SYSV termio speeds (where 9600 equals 9600) or
an old DSD-style speed ( where 13 equals 9600).
.IP "\s-1TERM\s0" 2
.IX Item "TERM"
The terminal type whose termcap entry will be used \- if not supplied it will
default to \f(CW$ENV\fR{\s-1TERM\s0}: if that is not set then \fBTgetent\fR will croak.
.RE
.RS 4
.Sp
It calls \f(CW\*(C`croak\*(C'\fR on failure.
.RE
.IP "\fBTpad\fR" 4
.IX Item "Tpad"
Outputs a literal string with appropriate padding for the current terminal.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$string\fB\fR" 2
.el .IP "\fB\f(CB$string\fB\fR" 2
.IX Item "$string"
The literal string to be output.  If it starts with a number and an optional
\&'*' then the padding will be increased by an amount relative to this number,
if the '*' is present then this amount will me multiplied by \f(CW$cnt\fR.  This part
of \f(CW$string\fR is removed before output/
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
Will be used to modify the padding applied to string as described above.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The padded \f(CW$string\fR is returned.
.RE
.IP "\fBTputs\fR" 4
.IX Item "Tputs"
Output the string for the given capability padded as appropriate without
any parameter substitution.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The capability whose string is to be output.
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
A count passed to Tpad to modify the padding applied to the output string.
If \f(CW$cnt\fR is zero or one then the resulting string will be cached.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) that output will be printed to.
.RE
.RS 4
.Sp
The appropriate string for the capability will be returned.
.RE
.IP "\fBTgoto\fR" 4
.IX Item "Tgoto"
\&\fBTgoto\fR decodes a cursor addressing string with the given parameters.
.Sp
There are four arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
The name of the capability to be output.
.ie n .IP "\fB\fB$col\fB\fR" 2
.el .IP "\fB\f(CB$col\fB\fR" 2
.IX Item "$col"
The first value to be substituted in the output string ( usually the column
in a cursor addressing capability )
.ie n .IP "\fB\fB$row\fB\fR" 2
.el .IP "\fB\f(CB$row\fB\fR" 2
.IX Item "$row"
The second value to be substituted in the output string (usually the row
in cursor addressing capabilities)
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optional filehandle (or IO::Handle ) to which the output string will be
printed.
.RE
.RS 4
.Sp
Substitutions are made with \f(CW$col\fR and \f(CW$row\fR in the output string with the
following \fIsprintf()\fR line formats:
.Sp
.Vb 6
\& %%   output \`%\*(Aq
\& %d   output value as in printf %d
\& %2   output value as in printf %2d
\& %3   output value as in printf %3d
\& %.   output value as in printf %c
\& %+x  add x to value, then do %.
\&
\& %>xy if value > x then add y, no output
\& %r   reverse order of two parameters, no output
\& %i   increment by one, no output
\& %B   BCD (16*(value/10)) + (value%10), no output
\&
\& %n   exclusive\-or all parameters with 0140 (Datamedia 2500)
\& %D   Reverse coding (value \- 2*(value%16)), no output (Delta Data)
.Ve
.Sp
The output string will be returned.
.RE
.IP "\fBTrequire\fR" 4
.IX Item "Trequire"
Takes a list of capabilities as an argument and will croak if one is not
found.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&    use Term::Cap;
\&
\&    # Get terminal output speed
\&    require POSIX;
\&    my $termios = new POSIX::Termios;
\&    $termios\->getattr;
\&    my $ospeed = $termios\->getospeed;
\&
\&    # Old\-style ioctl code to get ospeed:
\&    #     require \*(Aqioctl.pl\*(Aq;
\&    #     ioctl(TTY,$TIOCGETP,$sgtty);
\&    #     ($ispeed,$ospeed) = unpack(\*(Aqcc\*(Aq,$sgtty);
\&
\&    # allocate and initialize a terminal structure
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&
\&    # require certain capabilities to be available
\&    $terminal\->Trequire(qw/ce ku kd/);
\&
\&    # Output Routines, if $FH is undefined these just return the string
\&
\&    # Tgoto does the % expansion stuff with the given args
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&
\&    # Tputs doesn\*(Aqt do any % expansion.
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count = 1, $FH);
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Please see the \s-1README\s0 file in distribution.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is part of the core Perl distribution and is also maintained
for \s-1CPAN\s0 by Jonathan Stowe <jns@gellyfish.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fItermcap\fR\|(5)
                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::Complete.3pm                           0100644 0001750 0001750 00000012155 12566207463 024074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Complete 3pm"
.TH Term::Complete 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Complete \- Perl word completion module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $input = Complete(\*(Aqprompt_string\*(Aq, \e@completion_list);
\&    $input = Complete(\*(Aqprompt_string\*(Aq, @completion_list);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This routine provides word completion on the list of words in
the array (or array ref).
.PP
The tty driver is put into raw mode and restored using an operating
system specific command, in UNIX-like environments \f(CW\*(C`stty\*(C'\fR.
.PP
The following command characters are defined:
.IP "<tab>" 4
.IX Item "<tab>"
Attempts word completion.
Cannot be changed.
.IP "^D" 4
.IX Item "^D"
Prints completion list.
Defined by \fI\f(CI$Term::Complete::complete\fI\fR.
.IP "^U" 4
.IX Item "^U"
Erases the current input.
Defined by \fI\f(CI$Term::Complete::kill\fI\fR.
.IP "<del>, <bs>" 4
.IX Item "<del>, <bs>"
Erases one character.
Defined by \fI\f(CI$Term::Complete::erase1\fI\fR and \fI\f(CI$Term::Complete::erase2\fI\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Bell sounds when word completion fails.
.SH "BUGS"
.IX Header "BUGS"
The completion character <tab> cannot be changed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Wayne Thompson
                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::Complete5.16.3pm                       0100644 0001750 0001750 00000011634 12566207441 024403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Complete 3pm"
.TH Term::Complete 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Complete \- Perl word completion module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $input = Complete(\*(Aqprompt_string\*(Aq, \e@completion_list);
\&    $input = Complete(\*(Aqprompt_string\*(Aq, @completion_list);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This routine provides word completion on the list of words in
the array (or array ref).
.PP
The tty driver is put into raw mode and restored using an operating
system specific command, in UNIX-like environments \f(CW\*(C`stty\*(C'\fR.
.PP
The following command characters are defined:
.IP "<tab>" 4
.IX Item "<tab>"
Attempts word completion.
Cannot be changed.
.IP "^D" 4
.IX Item "^D"
Prints completion list.
Defined by \fI\f(CI$Term::Complete::complete\fI\fR.
.IP "^U" 4
.IX Item "^U"
Erases the current input.
Defined by \fI\f(CI$Term::Complete::kill\fI\fR.
.IP "<del>, <bs>" 4
.IX Item "<del>, <bs>"
Erases one character.
Defined by \fI\f(CI$Term::Complete::erase1\fI\fR and \fI\f(CI$Term::Complete::erase2\fI\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Bell sounds when word completion fails.
.SH "BUGS"
.IX Header "BUGS"
The completion character <tab> cannot be changed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Wayne Thompson
                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::Complete5.18.3pm                       0100644 0001750 0001750 00000012155 12566207463 024410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Complete 3pm"
.TH Term::Complete 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Complete \- Perl word completion module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $input = Complete(\*(Aqprompt_string\*(Aq, \e@completion_list);
\&    $input = Complete(\*(Aqprompt_string\*(Aq, @completion_list);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This routine provides word completion on the list of words in
the array (or array ref).
.PP
The tty driver is put into raw mode and restored using an operating
system specific command, in UNIX-like environments \f(CW\*(C`stty\*(C'\fR.
.PP
The following command characters are defined:
.IP "<tab>" 4
.IX Item "<tab>"
Attempts word completion.
Cannot be changed.
.IP "^D" 4
.IX Item "^D"
Prints completion list.
Defined by \fI\f(CI$Term::Complete::complete\fI\fR.
.IP "^U" 4
.IX Item "^U"
Erases the current input.
Defined by \fI\f(CI$Term::Complete::kill\fI\fR.
.IP "<del>, <bs>" 4
.IX Item "<del>, <bs>"
Erases one character.
Defined by \fI\f(CI$Term::Complete::erase1\fI\fR and \fI\f(CI$Term::Complete::erase2\fI\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Bell sounds when word completion fails.
.SH "BUGS"
.IX Header "BUGS"
The completion character <tab> cannot be changed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Wayne Thompson
                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ReadKey.3pm                            0100644 0001750 0001750 00000032623 12566242632 023647  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ReadKey 3"
.TH ReadKey 3 "2013-10-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadKey \- A perl module for simple terminal control
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&        use Term::ReadKey;
\&        ReadMode 4; # Turn off controls keys
\&        while (not defined ($key = ReadKey(\-1))) {
\&                # No key yet
\&        }
\&        print "Get key $key\en";
\&        ReadMode 0; # Reset tty mode before exiting
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ReadKey is a compiled perl module dedicated to providing simple
control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
non-blocking reads, if the architecture allows, and some generalized handy
functions for working with terminals. One of the main goals is to have the
functions as portable as possible, so you can just plug in \*(L"use
Term::ReadKey\*(R" on any architecture and have a good likelihood of it working.
.PP
Version 2.30.01:
Added handling of arrows, page up/down, home/end, insert/delete keys 
under Win32. These keys emit xterm-compatible sequences.
Works with Term::ReadLine::Perl.
.IP "ReadMode \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadMode MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 8
\&    0    Restore original settings.
\&    1    Change to cooked mode.
\&    2    Change to cooked mode with echo off. 
\&          (Good for passwords)
\&    3    Change to cbreak mode.
\&    4    Change to raw mode.
\&    5    Change to ultra\-raw mode. 
\&          (LF to CR/LF translation turned off) 
\&          
\&    Or, you may use the synonyms:
\&    
\&    restore
\&    normal
\&    noecho
\&    cbreak
\&    raw
\&    ultra\-raw
.Ve
.Sp
These functions are automatically applied to the \s-1STDIN\s0 handle if no
other handle is supplied. Modes 0 and 5 have some special properties
worth mentioning: not only will mode 0 restore original settings, but it
cause the next ReadMode call to save a new set of default settings. Mode
5 is similar to mode 4, except no \s-1CR/LF\s0 translation is performed, and if
possible, parity will be disabled (only if not being used by the terminal,
however. It is no different from mode 4 under Windows.)
.Sp
If you are executing another program that may be changing the terminal mode,
you will either want to say
.Sp
.Vb 3
\&    ReadMode 1
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which resets the settings after the program has run, or:
.Sp
.Vb 4
\&    $somemode=1;
\&    ReadMode 0;
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which records any changes the program may have made, before resetting the
mode.
.IP "ReadKey \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadKey MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using getc
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
(If the filehandle is not supplied, it will default to \s-1STDIN.\s0) If there is
nothing waiting in the buffer during a non-blocked read, then undef will be
returned. Note that if the \s-1OS\s0 does not provide any known mechanism for
non-blocking reads, then a \f(CW\*(C`ReadKey \-1\*(C'\fR can die with a fatal error. This
will hopefully not be common.
.Sp
If \s-1MODE\s0 is greater then zero, then ReadKey will use it as a timeout value in
seconds (fractional seconds are allowed), and won't return \f(CW\*(C`undef\*(C'\fR until
that time expires. (Note, again, that some \s-1OS\s0's may not support this timeout
behaviour.) If \s-1MODE\s0 is less then zero, then this is treated as a timeout
of zero, and thus will return immediately if no character is waiting. A \s-1MODE\s0
of zero, however, will act like a normal getc.
.Sp
There are currently some limitations with this call under Windows. It may be
possible that non-blocking reads will fail when reading repeating keys from
more then one console.
.IP "ReadLine \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadLine MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using scalar(<FileHandle>)
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
If there is nothing waiting in the buffer during a non-blocked read, then
undef will be returned. Note that if the \s-1OS\s0 does not provide any known
mechanism for non-blocking reads, then a \f(CW\*(C`ReadLine 1\*(C'\fR can die with a fatal
error. This will hopefully not be common. Note that a non-blocking test is
only performed for the first character in the line, not the entire line.
This call will probably \fBnot\fR do what you assume, especially with
ReadMode's higher then 1. For example, pressing Space and then Backspace
would appear to leave you where you started, but any timeouts would now
be suspended.
.Sp
This call is currently not available under Windows.
.IP "GetTerminalSize [Filehandle]" 8
.IX Item "GetTerminalSize [Filehandle]"
Returns either an empty array if this operation is unsupported, or a four
element array containing: the width of the terminal in characters, the
height of the terminal in character, the width in pixels, and the height in
pixels. (The pixel size will only be valid in some environments.)
.Sp
Under Windows, this function must be called with an \*(L"output\*(R" filehandle,
such as \s-1STDOUT,\s0 or a handle opened to \s-1CONOUT$.\s0
.IP "SetTerminalSize \s-1WIDTH,HEIGHT,XPIX,YPIX\s0 [, Filehandle]" 8
.IX Item "SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]"
Return \-1 on failure, 0 otherwise. Note that this terminal size is only for
\&\fBinformative\fR value, and changing the size via this mechanism will \fBnot\fR
change the size of the screen. For example, XTerm uses a call like this when
it resizes the screen. If any of the new measurements vary from the old, the
\&\s-1OS\s0 will probably send a \s-1SIGWINCH\s0 signal to anything reading that tty or pty.
.Sp
This call does not work under Windows.
.IP "GetSpeeds [, Filehandle]" 8
.IX Item "GetSpeeds [, Filehandle]"
Returns either an empty array if the operation is unsupported, or a two
value array containing the terminal in and out speeds, in \fBdecimal\fR. E.g,
an in speed of 9600 baud and an out speed of 4800 baud would be returned as
(9600,4800). Note that currently the in and out speeds will always be
identical in some \s-1OS\s0's. No speeds are reported under Windows.
.IP "GetControlChars [, Filehandle]" 8
.IX Item "GetControlChars [, Filehandle]"
Returns an array containing key/value pairs suitable for a hash. The pairs
consist of a key, the name of the control character/signal, and the value
of that character, as a single character. This call does nothing under Windows.
.Sp
Each key will be an entry from the following list:
.Sp
.Vb 10
\&        DISCARD
\&        DSUSPEND
\&        EOF
\&        EOL
\&        EOL2
\&        ERASE
\&        ERASEWORD
\&        INTERRUPT
\&        KILL
\&        MIN
\&        QUIT
\&        QUOTENEXT
\&        REPRINT
\&        START
\&        STATUS
\&        STOP
\&        SUSPEND
\&        SWITCH
\&        TIME
.Ve
.Sp
Thus, the following will always return the current interrupt character,
regardless of platform.
.Sp
.Vb 2
\&        %keys = GetControlChars;
\&        $int = $keys{INTERRUPT};
.Ve
.IP "SetControlChars [, Filehandle]" 8
.IX Item "SetControlChars [, Filehandle]"
Takes an array containing key/value pairs, as a hash will produce. The pairs
should consist of a key that is the name of a legal control
character/signal, and the value should be either a single character, or a
number in the range 0\-255. SetControlChars will die with a runtime error if
an invalid character name is passed or there is an error changing the
settings. The list of valid names is easily available via
.Sp
.Vb 2
\&        %cchars = GetControlChars();
\&        @cnames = keys %cchars;
.Ve
.Sp
This call does nothing under Windows.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kenneth Albanowski <kjahds@kjahds.com>
.PP
Currently maintained by Jonathan Stowe <jns@gellyfish.co.uk>
.IP "\s-1SUPPORT\s0" 4
.IX Item "SUPPORT"
The code is maintained at
.Sp
.Vb 1
\&     https://github.com/jonathanstowe/TermReadKey
.Ve
.Sp
Please feel free to fork and suggest patches.
.IP "\s-1LICENSE\s0" 4
.IX Item "LICENSE"
Prior to the 2.31 release the license statement was:
.Sp
.Vb 2
\& Copyright (C) 1994\-1999 Kenneth Albanowski.
\&                2001\-2005 Jonathan Stowe and others
\&
\&                 Unlimited distribution and/or modification is allowed as long as this
\&                  copyright notice remains intact.
.Ve
.Sp
And was only stated in the \s-1README\s0 file.
.Sp
Because I believe the original author's intent was to be more open than the
other commonly used licenses I would like to leave that in place. However if
you or your lawyers require something with some more words you can optionally
choose to license this under the standard Perl license:
.Sp
.Vb 4
\&      This module is free software; you can redistribute it and/or modify it
\&      under the terms of the Artistic License. For details, see the full
\&      text of the license in the file "Artistic" that should have been provided
\&      with the version of perl you are using.
\&
\&      This program is distributed in the hope that it will be useful, but
\&      without any warranty; without even the implied warranty of merchantability
\&      or fitness for a particular purpose.
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 213:" 4
.IX Item "Around line 213:"
\&'=item' outside of any '=over'
.Sp
=over without closing =back
                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ReadKey5.16.3pm                        0100644 0001750 0001750 00000026657 12566242626 024176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ReadKey 3"
.TH ReadKey 3 "2005-01-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadKey \- A perl module for simple terminal control
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&        use Term::ReadKey;
\&        ReadMode 4; # Turn off controls keys
\&        while (not defined ($key = ReadKey(\-1))) {
\&                # No key yet
\&        }
\&        print "Get key $key\en";
\&        ReadMode 0; # Reset tty mode before exiting
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ReadKey is a compiled perl module dedicated to providing simple
control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
non-blocking reads, if the architecture allows, and some generalized handy
functions for working with terminals. One of the main goals is to have the
functions as portable as possible, so you can just plug in \*(L"use
Term::ReadKey\*(R" on any architecture and have a good likelyhood of it working.
.IP "ReadMode \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadMode MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 8
\&    0    Restore original settings.
\&    1    Change to cooked mode.
\&    2    Change to cooked mode with echo off. 
\&          (Good for passwords)
\&    3    Change to cbreak mode.
\&    4    Change to raw mode.
\&    5    Change to ultra\-raw mode. 
\&          (LF to CR/LF translation turned off) 
\&          
\&    Or, you may use the synonyms:
\&    
\&    restore
\&    normal
\&    noecho
\&    cbreak
\&    raw
\&    ultra\-raw
.Ve
.Sp
These functions are automatically applied to the \s-1STDIN\s0 handle if no
other handle is supplied. Modes 0 and 5 have some special properties
worth mentioning: not only will mode 0 restore original settings, but it
cause the next ReadMode call to save a new set of default settings. Mode
5 is similar to mode 4, except no \s-1CR/LF\s0 translation is performed, and if
possible, parity will be disabled (only if not being used by the terminal,
however. It is no different from mode 4 under Windows.)
.Sp
If you are executing another program that may be changing the terminal mode,
you will either want to say
.Sp
.Vb 3
\&    ReadMode 1
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which resets the settings after the program has run, or:
.Sp
.Vb 4
\&    $somemode=1;
\&    ReadMode 0;
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which records any changes the program may have made, before resetting the
mode.
.IP "ReadKey \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadKey MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using getc
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
(If the filehandle is not supplied, it will default to \s-1STDIN\s0.) If there is
nothing waiting in the buffer during a non-blocked read, then undef will be
returned. Note that if the \s-1OS\s0 does not provide any known mechanism for
non-blocking reads, then a \f(CW\*(C`ReadKey \-1\*(C'\fR can die with a fatal error. This
will hopefully not be common.
.Sp
If \s-1MODE\s0 is greater then zero, then ReadKey will use it as a timeout value in
seconds (fractional seconds are allowed), and won't return \f(CW\*(C`undef\*(C'\fR until
that time expires. (Note, again, that some \s-1OS\s0's may not support this timeout
behaviour.) If \s-1MODE\s0 is less then zero, then this is treated as a timeout
of zero, and thus will return immediately if no character is waiting. A \s-1MODE\s0
of zero, however, will act like a normal getc.
.Sp
There are currently some limitations with this call under Windows. It may be
possible that non-blocking reads will fail when reading repeating keys from
more then one console.
.IP "ReadLine \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadLine MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using scalar(<FileHandle>)
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
If there is nothing waiting in the buffer during a non-blocked read, then
undef will be returned. Note that if the \s-1OS\s0 does not provide any known
mechanism for non-blocking reads, then a \f(CW\*(C`ReadLine 1\*(C'\fR can die with a fatal
error. This will hopefully not be common. Note that a non-blocking test is
only performed for the first character in the line, not the entire line.
This call will probably \fBnot\fR do what you assume, especially with
ReadMode's higher then 1. For example, pressing Space and then Backspace
would appear to leave you where you started, but any timeouts would now
be suspended.
.Sp
This call is currently not available under Windows.
.IP "GetTerminalSize [Filehandle]" 8
.IX Item "GetTerminalSize [Filehandle]"
Returns either an empty array if this operation is unsupported, or a four
element array containing: the width of the terminal in characters, the
height of the terminal in character, the width in pixels, and the height in
pixels. (The pixel size will only be valid in some environments.)
.Sp
Under Windows, this function must be called with an \*(L"output\*(R" filehandle,
such as \s-1STDOUT\s0, or a handle opened to \s-1CONOUT$\s0.
.IP "SetTerminalSize \s-1WIDTH\s0,HEIGHT,XPIX,YPIX [, Filehandle]" 8
.IX Item "SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]"
Return \-1 on failure, 0 otherwise. Note that this terminal size is only for
\&\fBinformative\fR value, and changing the size via this mechanism will \fBnot\fR
change the size of the screen. For example, XTerm uses a call like this when
it resizes the screen. If any of the new measurements vary from the old, the
\&\s-1OS\s0 will probably send a \s-1SIGWINCH\s0 signal to anything reading that tty or pty.
.Sp
This call does not work under Windows.
.IP "GetSpeeds [, Filehandle]" 8
.IX Item "GetSpeeds [, Filehandle]"
Returns either an empty array if the operation is unsupported, or a two
value array containing the terminal in and out speeds, in \fBdecimal\fR. E.g,
an in speed of 9600 baud and an out speed of 4800 baud would be returned as
(9600,4800). Note that currently the in and out speeds will always be
identical in some \s-1OS\s0's. No speeds are reported under Windows.
.IP "GetControlChars [, Filehandle]" 8
.IX Item "GetControlChars [, Filehandle]"
Returns an array containing key/value pairs suitable for a hash. The pairs
consist of a key, the name of the control character/signal, and the value
of that character, as a single character. This call does nothing under Windows.
.Sp
Each key will be an entry from the following list:
.Sp
.Vb 10
\&        DISCARD
\&        DSUSPEND
\&        EOF
\&        EOL
\&        EOL2
\&        ERASE
\&        ERASEWORD
\&        INTERRUPT
\&        KILL
\&        MIN
\&        QUIT
\&        QUOTENEXT
\&        REPRINT
\&        START
\&        STATUS
\&        STOP
\&        SUSPEND
\&        SWITCH
\&        TIME
.Ve
.Sp
Thus, the following will always return the current interrupt character,
regardless of platform.
.Sp
.Vb 2
\&        %keys = GetControlChars;
\&        $int = $keys{INTERRUPT};
.Ve
.IP "SetControlChars [, Filehandle]" 8
.IX Item "SetControlChars [, Filehandle]"
Takes an array containing key/value pairs, as a hash will produce. The pairs
should consist of a key that is the name of a legal control
character/signal, and the value should be either a single character, or a
number in the range 0\-255. SetControlChars will die with a runtime error if
an invalid character name is passed or there is an error changing the
settings. The list of valid names is easily available via
.Sp
.Vb 2
\&        %cchars = GetControlChars();
\&        @cnames = keys %cchars;
.Ve
.Sp
This call does nothing under Windows.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kenneth Albanowski <kjahds@kjahds.com>
.PP
Currently maintained by Jonathan Stowe <jns@gellyfish.com>
                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ReadKey5.18.3pm                        0100644 0001750 0001750 00000032623 12566242632 024163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ReadKey 3"
.TH ReadKey 3 "2013-10-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadKey \- A perl module for simple terminal control
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&        use Term::ReadKey;
\&        ReadMode 4; # Turn off controls keys
\&        while (not defined ($key = ReadKey(\-1))) {
\&                # No key yet
\&        }
\&        print "Get key $key\en";
\&        ReadMode 0; # Reset tty mode before exiting
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ReadKey is a compiled perl module dedicated to providing simple
control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
non-blocking reads, if the architecture allows, and some generalized handy
functions for working with terminals. One of the main goals is to have the
functions as portable as possible, so you can just plug in \*(L"use
Term::ReadKey\*(R" on any architecture and have a good likelihood of it working.
.PP
Version 2.30.01:
Added handling of arrows, page up/down, home/end, insert/delete keys 
under Win32. These keys emit xterm-compatible sequences.
Works with Term::ReadLine::Perl.
.IP "ReadMode \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadMode MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 8
\&    0    Restore original settings.
\&    1    Change to cooked mode.
\&    2    Change to cooked mode with echo off. 
\&          (Good for passwords)
\&    3    Change to cbreak mode.
\&    4    Change to raw mode.
\&    5    Change to ultra\-raw mode. 
\&          (LF to CR/LF translation turned off) 
\&          
\&    Or, you may use the synonyms:
\&    
\&    restore
\&    normal
\&    noecho
\&    cbreak
\&    raw
\&    ultra\-raw
.Ve
.Sp
These functions are automatically applied to the \s-1STDIN\s0 handle if no
other handle is supplied. Modes 0 and 5 have some special properties
worth mentioning: not only will mode 0 restore original settings, but it
cause the next ReadMode call to save a new set of default settings. Mode
5 is similar to mode 4, except no \s-1CR/LF\s0 translation is performed, and if
possible, parity will be disabled (only if not being used by the terminal,
however. It is no different from mode 4 under Windows.)
.Sp
If you are executing another program that may be changing the terminal mode,
you will either want to say
.Sp
.Vb 3
\&    ReadMode 1
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which resets the settings after the program has run, or:
.Sp
.Vb 4
\&    $somemode=1;
\&    ReadMode 0;
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which records any changes the program may have made, before resetting the
mode.
.IP "ReadKey \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadKey MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using getc
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
(If the filehandle is not supplied, it will default to \s-1STDIN.\s0) If there is
nothing waiting in the buffer during a non-blocked read, then undef will be
returned. Note that if the \s-1OS\s0 does not provide any known mechanism for
non-blocking reads, then a \f(CW\*(C`ReadKey \-1\*(C'\fR can die with a fatal error. This
will hopefully not be common.
.Sp
If \s-1MODE\s0 is greater then zero, then ReadKey will use it as a timeout value in
seconds (fractional seconds are allowed), and won't return \f(CW\*(C`undef\*(C'\fR until
that time expires. (Note, again, that some \s-1OS\s0's may not support this timeout
behaviour.) If \s-1MODE\s0 is less then zero, then this is treated as a timeout
of zero, and thus will return immediately if no character is waiting. A \s-1MODE\s0
of zero, however, will act like a normal getc.
.Sp
There are currently some limitations with this call under Windows. It may be
possible that non-blocking reads will fail when reading repeating keys from
more then one console.
.IP "ReadLine \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadLine MODE [, Filehandle]"
Takes an integer argument, which can currently be one of the following 
values:
.Sp
.Vb 3
\&    0    Perform a normal read using scalar(<FileHandle>)
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
If there is nothing waiting in the buffer during a non-blocked read, then
undef will be returned. Note that if the \s-1OS\s0 does not provide any known
mechanism for non-blocking reads, then a \f(CW\*(C`ReadLine 1\*(C'\fR can die with a fatal
error. This will hopefully not be common. Note that a non-blocking test is
only performed for the first character in the line, not the entire line.
This call will probably \fBnot\fR do what you assume, especially with
ReadMode's higher then 1. For example, pressing Space and then Backspace
would appear to leave you where you started, but any timeouts would now
be suspended.
.Sp
This call is currently not available under Windows.
.IP "GetTerminalSize [Filehandle]" 8
.IX Item "GetTerminalSize [Filehandle]"
Returns either an empty array if this operation is unsupported, or a four
element array containing: the width of the terminal in characters, the
height of the terminal in character, the width in pixels, and the height in
pixels. (The pixel size will only be valid in some environments.)
.Sp
Under Windows, this function must be called with an \*(L"output\*(R" filehandle,
such as \s-1STDOUT,\s0 or a handle opened to \s-1CONOUT$.\s0
.IP "SetTerminalSize \s-1WIDTH,HEIGHT,XPIX,YPIX\s0 [, Filehandle]" 8
.IX Item "SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]"
Return \-1 on failure, 0 otherwise. Note that this terminal size is only for
\&\fBinformative\fR value, and changing the size via this mechanism will \fBnot\fR
change the size of the screen. For example, XTerm uses a call like this when
it resizes the screen. If any of the new measurements vary from the old, the
\&\s-1OS\s0 will probably send a \s-1SIGWINCH\s0 signal to anything reading that tty or pty.
.Sp
This call does not work under Windows.
.IP "GetSpeeds [, Filehandle]" 8
.IX Item "GetSpeeds [, Filehandle]"
Returns either an empty array if the operation is unsupported, or a two
value array containing the terminal in and out speeds, in \fBdecimal\fR. E.g,
an in speed of 9600 baud and an out speed of 4800 baud would be returned as
(9600,4800). Note that currently the in and out speeds will always be
identical in some \s-1OS\s0's. No speeds are reported under Windows.
.IP "GetControlChars [, Filehandle]" 8
.IX Item "GetControlChars [, Filehandle]"
Returns an array containing key/value pairs suitable for a hash. The pairs
consist of a key, the name of the control character/signal, and the value
of that character, as a single character. This call does nothing under Windows.
.Sp
Each key will be an entry from the following list:
.Sp
.Vb 10
\&        DISCARD
\&        DSUSPEND
\&        EOF
\&        EOL
\&        EOL2
\&        ERASE
\&        ERASEWORD
\&        INTERRUPT
\&        KILL
\&        MIN
\&        QUIT
\&        QUOTENEXT
\&        REPRINT
\&        START
\&        STATUS
\&        STOP
\&        SUSPEND
\&        SWITCH
\&        TIME
.Ve
.Sp
Thus, the following will always return the current interrupt character,
regardless of platform.
.Sp
.Vb 2
\&        %keys = GetControlChars;
\&        $int = $keys{INTERRUPT};
.Ve
.IP "SetControlChars [, Filehandle]" 8
.IX Item "SetControlChars [, Filehandle]"
Takes an array containing key/value pairs, as a hash will produce. The pairs
should consist of a key that is the name of a legal control
character/signal, and the value should be either a single character, or a
number in the range 0\-255. SetControlChars will die with a runtime error if
an invalid character name is passed or there is an error changing the
settings. The list of valid names is easily available via
.Sp
.Vb 2
\&        %cchars = GetControlChars();
\&        @cnames = keys %cchars;
.Ve
.Sp
This call does nothing under Windows.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kenneth Albanowski <kjahds@kjahds.com>
.PP
Currently maintained by Jonathan Stowe <jns@gellyfish.co.uk>
.IP "\s-1SUPPORT\s0" 4
.IX Item "SUPPORT"
The code is maintained at
.Sp
.Vb 1
\&     https://github.com/jonathanstowe/TermReadKey
.Ve
.Sp
Please feel free to fork and suggest patches.
.IP "\s-1LICENSE\s0" 4
.IX Item "LICENSE"
Prior to the 2.31 release the license statement was:
.Sp
.Vb 2
\& Copyright (C) 1994\-1999 Kenneth Albanowski.
\&                2001\-2005 Jonathan Stowe and others
\&
\&                 Unlimited distribution and/or modification is allowed as long as this
\&                  copyright notice remains intact.
.Ve
.Sp
And was only stated in the \s-1README\s0 file.
.Sp
Because I believe the original author's intent was to be more open than the
other commonly used licenses I would like to leave that in place. However if
you or your lawyers require something with some more words you can optionally
choose to license this under the standard Perl license:
.Sp
.Vb 4
\&      This module is free software; you can redistribute it and/or modify it
\&      under the terms of the Artistic License. For details, see the full
\&      text of the license in the file "Artistic" that should have been provided
\&      with the version of perl you are using.
\&
\&      This program is distributed in the hope that it will be useful, but
\&      without any warranty; without even the implied warranty of merchantability
\&      or fitness for a particular purpose.
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 213:" 4
.IX Item "Around line 213:"
\&'=item' outside of any '=over'
.Sp
=over without closing =back
                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ReadLine.3pm                           0100644 0001750 0001750 00000027312 12566207463 024010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ReadLine 3pm"
.TH Term::ReadLine 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadLine \- Perl interface to various "readline" packages.
If no real package is found, substitutes stubs instead of basic functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Term::ReadLine;
\&  my $term = Term::ReadLine\->new(\*(AqSimple Perl calc\*(Aq);
\&  my $prompt = "Enter your arithmetic expression: ";
\&  my $OUT = $term\->OUT || \e*STDOUT;
\&  while ( defined ($_ = $term\->readline($prompt)) ) {
\&    my $res = eval($_);
\&    warn $@ if $@;
\&    print $OUT $res, "\en" unless $@;
\&    $term\->addhistory($_) if /\eS/;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package is just a front end to some other packages. It's a stub to
set up a common interface to the various ReadLine implementations found on
\&\s-1CPAN \s0(under the \f(CW\*(C`Term::ReadLine::*\*(C'\fR namespace).
.SH "Minimal set of supported functions"
.IX Header "Minimal set of supported functions"
All the supported functions should be called as methods, i.e., either as
.PP
.Vb 1
\&  $term = Term::ReadLine\->new(\*(Aqname\*(Aq);
.Ve
.PP
or as
.PP
.Vb 1
\&  $term\->addhistory(\*(Aqrow\*(Aq);
.Ve
.PP
where \f(CW$term\fR is a return value of Term::ReadLine\->\fInew()\fR.
.ie n .IP """ReadLine""" 12
.el .IP "\f(CWReadLine\fR" 12
.IX Item "ReadLine"
returns the actual package that executes the commands. Among possible
values are \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR, \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR,
\&\f(CW\*(C`Term::ReadLine::Stub\*(C'\fR.
.ie n .IP """new""" 12
.el .IP "\f(CWnew\fR" 12
.IX Item "new"
returns the handle for subsequent calls to following
functions. Argument is the name of the application. Optionally can be
followed by two arguments for \f(CW\*(C`IN\*(C'\fR and \f(CW\*(C`OUT\*(C'\fR filehandles. These
arguments should be globs.
.ie n .IP """readline""" 12
.el .IP "\f(CWreadline\fR" 12
.IX Item "readline"
gets an input line, \fIpossibly\fR with actual \f(CW\*(C`readline\*(C'\fR
support. Trailing newline is removed. Returns \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`EOF\*(C'\fR.
.ie n .IP """addhistory""" 12
.el .IP "\f(CWaddhistory\fR" 12
.IX Item "addhistory"
adds the line to the history of input, from where it can be used if
the actual \f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """IN"", ""OUT""" 12
.el .IP "\f(CWIN\fR, \f(CWOUT\fR" 12
.IX Item "IN, OUT"
return the filehandles for input and output or \f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`readline\*(C'\fR
input and output cannot be used for Perl.
.ie n .IP """MinLine""" 12
.el .IP "\f(CWMinLine\fR" 12
.IX Item "MinLine"
If argument is specified, it is an advice on minimal size of line to
be included into history.  \f(CW\*(C`undef\*(C'\fR means do not include anything into
history. Returns the old value.
.ie n .IP """findConsole""" 12
.el .IP "\f(CWfindConsole\fR" 12
.IX Item "findConsole"
returns an array with two strings that give most appropriate names for
files for input and output using conventions \f(CW"<$in"\fR, \f(CW">out"\fR.
.IP "Attribs" 12
.IX Item "Attribs"
returns a reference to a hash which describes internal configuration
of the package. Names of keys in this hash conform to standard
conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.ie n .IP """Features""" 12
.el .IP "\f(CWFeatures\fR" 12
.IX Item "Features"
Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: \f(CW\*(C`appname\*(C'\fR should be present if the first argument
to \f(CW\*(C`new\*(C'\fR is recognized, and \f(CW\*(C`minline\*(C'\fR should be present if
\&\f(CW\*(C`MinLine\*(C'\fR method is not dummy.  \f(CW\*(C`autohistory\*(C'\fR should be present if
lines are put into history automatically (maybe subject to
\&\f(CW\*(C`MinLine\*(C'\fR), and \f(CW\*(C`addhistory\*(C'\fR if \f(CW\*(C`addhistory\*(C'\fR method is not dummy.
.Sp
If \f(CW\*(C`Features\*(C'\fR method reports a feature \f(CW\*(C`attribs\*(C'\fR as present, the
method \f(CW\*(C`Attribs\*(C'\fR is not dummy.
.SH "Additional supported functions"
.IX Header "Additional supported functions"
Actually \f(CW\*(C`Term::ReadLine\*(C'\fR can use some other package, that will
support a richer set of commands.
.PP
All these commands are callable via method interface and have names
which conform to standard conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
The stub package included with the perl distribution allows some
additional methods:
.ie n .IP """tkRunning""" 12
.el .IP "\f(CWtkRunning\fR" 12
.IX Item "tkRunning"
makes Tk event loop run when waiting for user input (i.e., during
\&\f(CW\*(C`readline\*(C'\fR method).
.ie n .IP """event_loop""" 12
.el .IP "\f(CWevent_loop\fR" 12
.IX Item "event_loop"
Registers call-backs to wait for user input (i.e., during \f(CW\*(C`readline\*(C'\fR
method).  This supersedes tkRunning.
.Sp
The first call-back registered is the call back for waiting.  It is
expected that the callback will call the current event loop until
there is something waiting to get on the input filehandle.  The parameter
passed in is the return value of the second call back.
.Sp
The second call-back registered is the call back for registration.  The
input filehandle (often \s-1STDIN,\s0 but not necessarily) will be passed in.
.Sp
For example, with AnyEvent:
.Sp
.Vb 10
\&  $term\->event_loop(sub {
\&    my $data = shift;
\&    $data\->[1] = AE::cv();
\&    $data\->[1]\->recv();
\&  }, sub {
\&    my $fh = shift;
\&    my $data = [];
\&    $data\->[0] = AE::io($fh, 0, sub { $data\->[1]\->send() });
\&    $data;
\&  });
.Ve
.Sp
The second call-back is optional if the call back is registered prior to
the call to \f(CW$term\fR\->readline.
.Sp
Deregistration is done in this case by calling event_loop with \f(CW\*(C`undef\*(C'\fR
as its parameter:
.Sp
.Vb 1
\&    $term\->event_loop(undef);
.Ve
.Sp
This will cause the data array ref to be removed, allowing normal garbage
collection to clean it up.  With AnyEvent, that will cause \f(CW$data\fR\->[0] to
be cleaned up, and AnyEvent will automatically cancel the watcher at that
time.  If another loop requires more than that to clean up a file watcher,
that will be up to the caller to handle.
.ie n .IP """ornaments""" 12
.el .IP "\f(CWornaments\fR" 12
.IX Item "ornaments"
makes the command line stand out by using termcap data.  The argument
to \f(CW\*(C`ornaments\*(C'\fR should be 0, 1, or a string of a form
\&\f(CW"aa,bb,cc,dd"\fR.  Four components of this string should be names of
\&\fIterminal capacities\fR, first two will be issued to make the prompt
standout, last two to make the input line standout.
.ie n .IP """newTTY""" 12
.el .IP "\f(CWnewTTY\fR" 12
.IX Item "newTTY"
takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.
.PP
One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding \f(CW\*(C`Features\*(C'\fR.
.SH "EXPORTS"
.IX Header "EXPORTS"
None
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`PERL_RL\*(C'\fR governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value
is true, it should be tail of the name of the package to use, such as
\&\f(CW\*(C`Perl\*(C'\fR or \f(CW\*(C`Gnu\*(C'\fR.
.PP
As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to
be \f(CW\*(C`o=0\*(C'\fR or \f(CW\*(C`ornaments=0\*(C'\fR.  The head should be as described above, say
.PP
If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.
.PP
.Vb 2
\&  export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
\&  export "PERL_RL= o=0"     # Use best available ReadLine sans ornaments
.Ve
.PP
(Note that processing of \f(CW\*(C`PERL_RL\*(C'\fR for ornaments is in the discretion of the 
particular used \f(CW\*(C`Term::ReadLine::*\*(C'\fR package).
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ReadLine5.16.3pm                       0100644 0001750 0001750 00000026771 12566207441 024326  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ReadLine 3pm"
.TH Term::ReadLine 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadLine \- Perl interface to various "readline" packages.
If no real package is found, substitutes stubs instead of basic functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Term::ReadLine;
\&  my $term = Term::ReadLine\->new(\*(AqSimple Perl calc\*(Aq);
\&  my $prompt = "Enter your arithmetic expression: ";
\&  my $OUT = $term\->OUT || \e*STDOUT;
\&  while ( defined ($_ = $term\->readline($prompt)) ) {
\&    my $res = eval($_);
\&    warn $@ if $@;
\&    print $OUT $res, "\en" unless $@;
\&    $term\->addhistory($_) if /\eS/;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package is just a front end to some other packages. It's a stub to
set up a common interface to the various ReadLine implementations found on
\&\s-1CPAN\s0 (under the \f(CW\*(C`Term::ReadLine::*\*(C'\fR namespace).
.SH "Minimal set of supported functions"
.IX Header "Minimal set of supported functions"
All the supported functions should be called as methods, i.e., either as
.PP
.Vb 1
\&  $term = Term::ReadLine\->new(\*(Aqname\*(Aq);
.Ve
.PP
or as
.PP
.Vb 1
\&  $term\->addhistory(\*(Aqrow\*(Aq);
.Ve
.PP
where \f(CW$term\fR is a return value of Term::ReadLine\->\fInew()\fR.
.ie n .IP """ReadLine""" 12
.el .IP "\f(CWReadLine\fR" 12
.IX Item "ReadLine"
returns the actual package that executes the commands. Among possible
values are \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR, \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR,
\&\f(CW\*(C`Term::ReadLine::Stub\*(C'\fR.
.ie n .IP """new""" 12
.el .IP "\f(CWnew\fR" 12
.IX Item "new"
returns the handle for subsequent calls to following
functions. Argument is the name of the application. Optionally can be
followed by two arguments for \f(CW\*(C`IN\*(C'\fR and \f(CW\*(C`OUT\*(C'\fR filehandles. These
arguments should be globs.
.ie n .IP """readline""" 12
.el .IP "\f(CWreadline\fR" 12
.IX Item "readline"
gets an input line, \fIpossibly\fR with actual \f(CW\*(C`readline\*(C'\fR
support. Trailing newline is removed. Returns \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`EOF\*(C'\fR.
.ie n .IP """addhistory""" 12
.el .IP "\f(CWaddhistory\fR" 12
.IX Item "addhistory"
adds the line to the history of input, from where it can be used if
the actual \f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """IN"", ""OUT""" 12
.el .IP "\f(CWIN\fR, \f(CWOUT\fR" 12
.IX Item "IN, OUT"
return the filehandles for input and output or \f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`readline\*(C'\fR
input and output cannot be used for Perl.
.ie n .IP """MinLine""" 12
.el .IP "\f(CWMinLine\fR" 12
.IX Item "MinLine"
If argument is specified, it is an advice on minimal size of line to
be included into history.  \f(CW\*(C`undef\*(C'\fR means do not include anything into
history. Returns the old value.
.ie n .IP """findConsole""" 12
.el .IP "\f(CWfindConsole\fR" 12
.IX Item "findConsole"
returns an array with two strings that give most appropriate names for
files for input and output using conventions \f(CW"<$in"\fR, \f(CW">out"\fR.
.IP "Attribs" 12
.IX Item "Attribs"
returns a reference to a hash which describes internal configuration
of the package. Names of keys in this hash conform to standard
conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.ie n .IP """Features""" 12
.el .IP "\f(CWFeatures\fR" 12
.IX Item "Features"
Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: \f(CW\*(C`appname\*(C'\fR should be present if the first argument
to \f(CW\*(C`new\*(C'\fR is recognized, and \f(CW\*(C`minline\*(C'\fR should be present if
\&\f(CW\*(C`MinLine\*(C'\fR method is not dummy.  \f(CW\*(C`autohistory\*(C'\fR should be present if
lines are put into history automatically (maybe subject to
\&\f(CW\*(C`MinLine\*(C'\fR), and \f(CW\*(C`addhistory\*(C'\fR if \f(CW\*(C`addhistory\*(C'\fR method is not dummy.
.Sp
If \f(CW\*(C`Features\*(C'\fR method reports a feature \f(CW\*(C`attribs\*(C'\fR as present, the
method \f(CW\*(C`Attribs\*(C'\fR is not dummy.
.SH "Additional supported functions"
.IX Header "Additional supported functions"
Actually \f(CW\*(C`Term::ReadLine\*(C'\fR can use some other package, that will
support a richer set of commands.
.PP
All these commands are callable via method interface and have names
which conform to standard conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
The stub package included with the perl distribution allows some
additional methods:
.ie n .IP """tkRunning""" 12
.el .IP "\f(CWtkRunning\fR" 12
.IX Item "tkRunning"
makes Tk event loop run when waiting for user input (i.e., during
\&\f(CW\*(C`readline\*(C'\fR method).
.ie n .IP """event_loop""" 12
.el .IP "\f(CWevent_loop\fR" 12
.IX Item "event_loop"
Registers call-backs to wait for user input (i.e., during \f(CW\*(C`readline\*(C'\fR
method).  This supercedes tkRunning.
.Sp
The first call-back registered is the call back for waiting.  It is
expected that the callback will call the current event loop until
there is something waiting to get on the input filehandle.  The parameter
passed in is the return value of the second call back.
.Sp
The second call-back registered is the call back for registration.  The
input filehandle (often \s-1STDIN\s0, but not necessarily) will be passed in.
.Sp
For example, with AnyEvent:
.Sp
.Vb 10
\&  $term\->event_loop(sub {
\&    my $data = shift;
\&    $data\->[1] = AE::cv();
\&    $data\->[1]\->recv();
\&  }, sub {
\&    my $fh = shift;
\&    my $data = [];
\&    $data\->[0] = AE::io($fh, 0, sub { $data\->[1]\->send() });
\&    $data;
\&  });
.Ve
.Sp
The second call-back is optional if the call back is registered prior to
the call to \f(CW$term\fR\->readline.
.Sp
Deregistration is done in this case by calling event_loop with \f(CW\*(C`undef\*(C'\fR
as its parameter:
.Sp
.Vb 1
\&    $term\->event_loop(undef);
.Ve
.Sp
This will cause the data array ref to be removed, allowing normal garbage
collection to clean it up.  With AnyEvent, that will cause \f(CW$data\fR\->[0] to
be cleaned up, and AnyEvent will automatically cancel the watcher at that
time.  If another loop requires more than that to clean up a file watcher,
that will be up to the caller to handle.
.ie n .IP """ornaments""" 12
.el .IP "\f(CWornaments\fR" 12
.IX Item "ornaments"
makes the command line stand out by using termcap data.  The argument
to \f(CW\*(C`ornaments\*(C'\fR should be 0, 1, or a string of a form
\&\f(CW"aa,bb,cc,dd"\fR.  Four components of this string should be names of
\&\fIterminal capacities\fR, first two will be issued to make the prompt
standout, last two to make the input line standout.
.ie n .IP """newTTY""" 12
.el .IP "\f(CWnewTTY\fR" 12
.IX Item "newTTY"
takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.
.PP
One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding \f(CW\*(C`Features\*(C'\fR.
.SH "EXPORTS"
.IX Header "EXPORTS"
None
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`PERL_RL\*(C'\fR governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value
is true, it should be tail of the name of the package to use, such as
\&\f(CW\*(C`Perl\*(C'\fR or \f(CW\*(C`Gnu\*(C'\fR.
.PP
As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to
be \f(CW\*(C`o=0\*(C'\fR or \f(CW\*(C`ornaments=0\*(C'\fR.  The head should be as described above, say
.PP
If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.
.PP
.Vb 2
\&  export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
\&  export "PERL_RL= o=0"     # Use best available ReadLine sans ornaments
.Ve
.PP
(Note that processing of \f(CW\*(C`PERL_RL\*(C'\fR for ornaments is in the discretion of the 
particular used \f(CW\*(C`Term::ReadLine::*\*(C'\fR package).
       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::ReadLine5.18.3pm                       0100644 0001750 0001750 00000027312 12566207463 024324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ReadLine 3pm"
.TH Term::ReadLine 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadLine \- Perl interface to various "readline" packages.
If no real package is found, substitutes stubs instead of basic functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Term::ReadLine;
\&  my $term = Term::ReadLine\->new(\*(AqSimple Perl calc\*(Aq);
\&  my $prompt = "Enter your arithmetic expression: ";
\&  my $OUT = $term\->OUT || \e*STDOUT;
\&  while ( defined ($_ = $term\->readline($prompt)) ) {
\&    my $res = eval($_);
\&    warn $@ if $@;
\&    print $OUT $res, "\en" unless $@;
\&    $term\->addhistory($_) if /\eS/;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package is just a front end to some other packages. It's a stub to
set up a common interface to the various ReadLine implementations found on
\&\s-1CPAN \s0(under the \f(CW\*(C`Term::ReadLine::*\*(C'\fR namespace).
.SH "Minimal set of supported functions"
.IX Header "Minimal set of supported functions"
All the supported functions should be called as methods, i.e., either as
.PP
.Vb 1
\&  $term = Term::ReadLine\->new(\*(Aqname\*(Aq);
.Ve
.PP
or as
.PP
.Vb 1
\&  $term\->addhistory(\*(Aqrow\*(Aq);
.Ve
.PP
where \f(CW$term\fR is a return value of Term::ReadLine\->\fInew()\fR.
.ie n .IP """ReadLine""" 12
.el .IP "\f(CWReadLine\fR" 12
.IX Item "ReadLine"
returns the actual package that executes the commands. Among possible
values are \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR, \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR,
\&\f(CW\*(C`Term::ReadLine::Stub\*(C'\fR.
.ie n .IP """new""" 12
.el .IP "\f(CWnew\fR" 12
.IX Item "new"
returns the handle for subsequent calls to following
functions. Argument is the name of the application. Optionally can be
followed by two arguments for \f(CW\*(C`IN\*(C'\fR and \f(CW\*(C`OUT\*(C'\fR filehandles. These
arguments should be globs.
.ie n .IP """readline""" 12
.el .IP "\f(CWreadline\fR" 12
.IX Item "readline"
gets an input line, \fIpossibly\fR with actual \f(CW\*(C`readline\*(C'\fR
support. Trailing newline is removed. Returns \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`EOF\*(C'\fR.
.ie n .IP """addhistory""" 12
.el .IP "\f(CWaddhistory\fR" 12
.IX Item "addhistory"
adds the line to the history of input, from where it can be used if
the actual \f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """IN"", ""OUT""" 12
.el .IP "\f(CWIN\fR, \f(CWOUT\fR" 12
.IX Item "IN, OUT"
return the filehandles for input and output or \f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`readline\*(C'\fR
input and output cannot be used for Perl.
.ie n .IP """MinLine""" 12
.el .IP "\f(CWMinLine\fR" 12
.IX Item "MinLine"
If argument is specified, it is an advice on minimal size of line to
be included into history.  \f(CW\*(C`undef\*(C'\fR means do not include anything into
history. Returns the old value.
.ie n .IP """findConsole""" 12
.el .IP "\f(CWfindConsole\fR" 12
.IX Item "findConsole"
returns an array with two strings that give most appropriate names for
files for input and output using conventions \f(CW"<$in"\fR, \f(CW">out"\fR.
.IP "Attribs" 12
.IX Item "Attribs"
returns a reference to a hash which describes internal configuration
of the package. Names of keys in this hash conform to standard
conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.ie n .IP """Features""" 12
.el .IP "\f(CWFeatures\fR" 12
.IX Item "Features"
Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: \f(CW\*(C`appname\*(C'\fR should be present if the first argument
to \f(CW\*(C`new\*(C'\fR is recognized, and \f(CW\*(C`minline\*(C'\fR should be present if
\&\f(CW\*(C`MinLine\*(C'\fR method is not dummy.  \f(CW\*(C`autohistory\*(C'\fR should be present if
lines are put into history automatically (maybe subject to
\&\f(CW\*(C`MinLine\*(C'\fR), and \f(CW\*(C`addhistory\*(C'\fR if \f(CW\*(C`addhistory\*(C'\fR method is not dummy.
.Sp
If \f(CW\*(C`Features\*(C'\fR method reports a feature \f(CW\*(C`attribs\*(C'\fR as present, the
method \f(CW\*(C`Attribs\*(C'\fR is not dummy.
.SH "Additional supported functions"
.IX Header "Additional supported functions"
Actually \f(CW\*(C`Term::ReadLine\*(C'\fR can use some other package, that will
support a richer set of commands.
.PP
All these commands are callable via method interface and have names
which conform to standard conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
The stub package included with the perl distribution allows some
additional methods:
.ie n .IP """tkRunning""" 12
.el .IP "\f(CWtkRunning\fR" 12
.IX Item "tkRunning"
makes Tk event loop run when waiting for user input (i.e., during
\&\f(CW\*(C`readline\*(C'\fR method).
.ie n .IP """event_loop""" 12
.el .IP "\f(CWevent_loop\fR" 12
.IX Item "event_loop"
Registers call-backs to wait for user input (i.e., during \f(CW\*(C`readline\*(C'\fR
method).  This supersedes tkRunning.
.Sp
The first call-back registered is the call back for waiting.  It is
expected that the callback will call the current event loop until
there is something waiting to get on the input filehandle.  The parameter
passed in is the return value of the second call back.
.Sp
The second call-back registered is the call back for registration.  The
input filehandle (often \s-1STDIN,\s0 but not necessarily) will be passed in.
.Sp
For example, with AnyEvent:
.Sp
.Vb 10
\&  $term\->event_loop(sub {
\&    my $data = shift;
\&    $data\->[1] = AE::cv();
\&    $data\->[1]\->recv();
\&  }, sub {
\&    my $fh = shift;
\&    my $data = [];
\&    $data\->[0] = AE::io($fh, 0, sub { $data\->[1]\->send() });
\&    $data;
\&  });
.Ve
.Sp
The second call-back is optional if the call back is registered prior to
the call to \f(CW$term\fR\->readline.
.Sp
Deregistration is done in this case by calling event_loop with \f(CW\*(C`undef\*(C'\fR
as its parameter:
.Sp
.Vb 1
\&    $term\->event_loop(undef);
.Ve
.Sp
This will cause the data array ref to be removed, allowing normal garbage
collection to clean it up.  With AnyEvent, that will cause \f(CW$data\fR\->[0] to
be cleaned up, and AnyEvent will automatically cancel the watcher at that
time.  If another loop requires more than that to clean up a file watcher,
that will be up to the caller to handle.
.ie n .IP """ornaments""" 12
.el .IP "\f(CWornaments\fR" 12
.IX Item "ornaments"
makes the command line stand out by using termcap data.  The argument
to \f(CW\*(C`ornaments\*(C'\fR should be 0, 1, or a string of a form
\&\f(CW"aa,bb,cc,dd"\fR.  Four components of this string should be names of
\&\fIterminal capacities\fR, first two will be issued to make the prompt
standout, last two to make the input line standout.
.ie n .IP """newTTY""" 12
.el .IP "\f(CWnewTTY\fR" 12
.IX Item "newTTY"
takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.
.PP
One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding \f(CW\*(C`Features\*(C'\fR.
.SH "EXPORTS"
.IX Header "EXPORTS"
None
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`PERL_RL\*(C'\fR governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value
is true, it should be tail of the name of the package to use, such as
\&\f(CW\*(C`Perl\*(C'\fR or \f(CW\*(C`Gnu\*(C'\fR.
.PP
As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to
be \f(CW\*(C`o=0\*(C'\fR or \f(CW\*(C`ornaments=0\*(C'\fR.  The head should be as described above, say
.PP
If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.
.PP
.Vb 2
\&  export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
\&  export "PERL_RL= o=0"     # Use best available ReadLine sans ornaments
.Ve
.PP
(Note that processing of \f(CW\*(C`PERL_RL\*(C'\fR for ornaments is in the discretion of the 
particular used \f(CW\*(C`Term::ReadLine::*\*(C'\fR package).
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::UI.3pm                                 0100644 0001750 0001750 00000043567 12566207463 022654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::UI 3pm"
.TH Term::UI 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::UI \- Term::ReadLine UI made easy
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Term::UI;
\&    use Term::ReadLine;
\&
\&    my $term = Term::ReadLine\->new(\*(Aqbrand\*(Aq);
\&
\&    my $reply = $term\->get_reply(
\&                    prompt => \*(AqWhat is your favourite colour?\*(Aq,
\&                    choices => [qw|blue red green|],
\&                    default => \*(Aqblue\*(Aq,
\&    );
\&
\&    my $bool = $term\->ask_yn(
\&                        prompt => \*(AqDo you like cookies?\*(Aq,
\&                        default => \*(Aqy\*(Aq,
\&                );
\&
\&
\&    my $string = q[some_command \-option \-\-no\-foo \-\-quux=\*(Aqthis thing\*(Aq];
\&
\&    my ($options,$munged_input) = $term\->parse_options($string);
\&
\&
\&    ### don\*(Aqt have Term::UI issue warnings \-\- default is \*(Aq1\*(Aq
\&    $Term::UI::VERBOSE = 0;
\&
\&    ### always pick the default (good for non\-interactive terms)
\&    ### \-\- default is \*(Aq0\*(Aq
\&    $Term::UI::AUTOREPLY = 1;
\&
\&    ### Retrieve the entire session as a printable string:
\&    $hist = Term::UI::History\->history_as_string;
\&    $hist = $term\->history_as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Term::UI\*(C'\fR is a transparent way of eliminating the overhead of having
to format a question and then validate the reply, informing the user
if the answer was not proper and re-issuing the question.
.PP
Simply give it the question you want to ask, optionally with choices
the user can pick from and a default and \f(CW\*(C`Term::UI\*(C'\fR will \s-1DWYM.\s0
.PP
For asking a yes or no question, there's even a shortcut.
.SH "HOW IT WORKS"
.IX Header "HOW IT WORKS"
\&\f(CW\*(C`Term::UI\*(C'\fR places itself at the back of the \f(CW\*(C`Term::ReadLine\*(C'\fR
\&\f(CW@ISA\fR array, so you can call its functions through your term object.
.PP
\&\f(CW\*(C`Term::UI\*(C'\fR uses \f(CW\*(C`Term::UI::History\*(C'\fR to record all interactions
with the commandline. You can retrieve this history, or alter
the filehandle the interaction is printed to. See the
\&\f(CW\*(C`Term::UI::History\*(C'\fR manpage or the \f(CW\*(C`SYNOPSIS\*(C'\fR for details.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$reply = $term\->get_reply( prompt => 'question?', [choices => \e@list, default => $list[0], multi => \s-1BOOL,\s0 print_me => ""extra text to print & record"", allow => $ref] );"
.el .SS "\f(CW$reply\fP = \f(CW$term\fP\->get_reply( prompt => 'question?', [choices => \e@list, default => \f(CW$list\fP[0], multi => \s-1BOOL,\s0 print_me => ``extra text to print & record'', allow => \f(CW$ref\fP] );"
.IX Subsection "$reply = $term->get_reply( prompt => 'question?', [choices => @list, default => $list[0], multi => BOOL, print_me => extra text to print & record, allow => $ref] );"
\&\f(CW\*(C`get_reply\*(C'\fR asks a user a question, and then returns the reply to the
caller. If the answer is invalid (more on that below), the question will
be reposed, until a satisfactory answer has been entered.
.PP
You have the option of providing a list of choices the user can pick from
using the \f(CW\*(C`choices\*(C'\fR argument. If the answer is not in the list of choices
presented, the question will be reposed.
.PP
If you provide a \f(CW\*(C`default\*(C'\fR  answer, this will be returned when either
\&\f(CW$AUTOREPLY\fR is set to true, (see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section further
below), or when the user just hits \f(CW\*(C`enter\*(C'\fR.
.PP
You can indicate that the user is allowed to enter multiple answers by
toggling the \f(CW\*(C`multi\*(C'\fR flag. Note that a list of answers will then be
returned to you, rather than a simple string.
.PP
By specifying an \f(CW\*(C`allow\*(C'\fR hander, you can yourself validate the answer
a user gives. This can be any of the types that the Params::Check \f(CW\*(C`allow\*(C'\fR
function allows, so please refer to that manpage for details.
.PP
Finally, you have the option of adding a \f(CW\*(C`print_me\*(C'\fR argument, which is
simply printed before the prompt. It's printed to the same file handle
as the rest of the questions, so you can use this to keep track of a
full session of Q&A with the user, and retrieve it later using the
\&\f(CW\*(C`Term::UI\->history_as_string\*(C'\fR function.
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section for samples of how to use this function.
.ie n .SS "$bool = $term\->ask_yn( prompt => ""your question"", [default => (y|1,n|0), print_me => ""extra text to print & record""] )"
.el .SS "\f(CW$bool\fP = \f(CW$term\fP\->ask_yn( prompt => ``your question'', [default => (y|1,n|0), print_me => ``extra text to print & record''] )"
.IX Subsection "$bool = $term->ask_yn( prompt => your question, [default => (y|1,n|0), print_me => extra text to print & record] )"
Asks a simple \f(CW\*(C`yes\*(C'\fR or \f(CW\*(C`no\*(C'\fR question to the user, returning a boolean
indicating \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR to the caller.
.PP
The \f(CW\*(C`default\*(C'\fR answer will automatically returned, if the user hits
\&\f(CW\*(C`enter\*(C'\fR or if \f(CW$AUTOREPLY\fR is set to true. See the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR
section further below.
.PP
Also, you have the option of adding a \f(CW\*(C`print_me\*(C'\fR argument, which is
simply printed before the prompt. It's printed to the same file handle
as the rest of the questions, so you can use this to keep track of a
full session of Q&A with the user, and retrieve it later using the
\&\f(CW\*(C`Term::UI\->history_as_string\*(C'\fR function.
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section for samples of how to use this function.
.ie n .SS "($opts, $munged) = $term\->parse_options( \s-1STRING \s0);"
.el .SS "($opts, \f(CW$munged\fP) = \f(CW$term\fP\->parse_options( \s-1STRING \s0);"
.IX Subsection "($opts, $munged) = $term->parse_options( STRING );"
\&\f(CW\*(C`parse_options\*(C'\fR will convert all options given from an input string
to a hash reference. If called in list context it will also return
the part of the input string that it found no options in.
.PP
Consider this example:
.PP
.Vb 2
\&    my $str =   q[command \-\-no\-foo \-\-baz \-\-bar=0 \-\-quux=bleh ] .
\&                q[\-\-option="some\*(Aqthing" \-one\-dash \-single=blah\*(Aq arg];
\&
\&    my ($options,$munged) =  $term\->parse_options($str);
\&
\&    ### $options would contain: ###
\&    $options = {
\&                \*(Aqfoo\*(Aq       => 0,
\&                \*(Aqbar\*(Aq       => 0,
\&                \*(Aqone\-dash\*(Aq  => 1,
\&                \*(Aqbaz\*(Aq       => 1,
\&                \*(Aqquux\*(Aq      => \*(Aqbleh\*(Aq,
\&                \*(Aqsingle\*(Aq    => \*(Aqblah\e\*(Aq\*(Aq,
\&                \*(Aqoption\*(Aq    => \*(Aqsome\e\*(Aqthing\*(Aq
\&    };
\&
\&    ### and this is the munged version of the input string,
\&    ### ie what\*(Aqs left of the input minus the options
\&    $munged = \*(Aqcommand arg\*(Aq;
.Ve
.PP
As you can see, you can either use a single or a double \f(CW\*(C`\-\*(C'\fR to
indicate an option.
If you prefix an option with \f(CW\*(C`no\-\*(C'\fR and do not give it a value, it
will be set to 0.
If it has no prefix and no value, it will be set to 1.
Otherwise, it will be set to its value. Note also that it can deal
fine with single/double quoting issues.
.ie n .SS "$str = $term\->history_as_string"
.el .SS "\f(CW$str\fP = \f(CW$term\fP\->history_as_string"
.IX Subsection "$str = $term->history_as_string"
Convenience wrapper around \f(CW\*(C`Term::UI::History\->history_as_string\*(C'\fR.
.PP
Consult the \f(CW\*(C`Term::UI::History\*(C'\fR man page for details.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
The behaviour of Term::UI can be altered by changing the following
global variables:
.ie n .SS "$Term::UI::VERBOSE"
.el .SS "\f(CW$Term::UI::VERBOSE\fP"
.IX Subsection "$Term::UI::VERBOSE"
This controls whether Term::UI will issue warnings and explanations
as to why certain things may have failed. If you set it to 0,
Term::UI will not output any warnings.
The default is 1;
.ie n .SS "$Term::UI::AUTOREPLY"
.el .SS "\f(CW$Term::UI::AUTOREPLY\fP"
.IX Subsection "$Term::UI::AUTOREPLY"
This will make every question be answered by the default, and warn if
there was no default provided. This is particularly useful if your
program is run in non-interactive mode.
The default is 0;
.ie n .SS "$Term::UI::INVALID"
.el .SS "\f(CW$Term::UI::INVALID\fP"
.IX Subsection "$Term::UI::INVALID"
This holds the string that will be printed when the user makes an
invalid choice.
You can override this string from your program if you, for example,
wish to do localization.
The default is \f(CW\*(C`Invalid selection, please try again: \*(C'\fR
.ie n .SS "$Term::UI::History::HISTORY_FH"
.el .SS "\f(CW$Term::UI::History::HISTORY_FH\fP"
.IX Subsection "$Term::UI::History::HISTORY_FH"
This is the filehandle all the print statements from this module
are being sent to. Please consult the \f(CW\*(C`Term::UI::History\*(C'\fR manpage
for details.
.PP
This defaults to \f(CW*STDOUT\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Basic get_reply sample"
.IX Subsection "Basic get_reply sample"
.Vb 2
\&    ### ask a user (with an open question) for their favourite colour
\&    $reply = $term\->get_reply( prompt => \*(AqYour favourite colour? );
.Ve
.PP
which would look like:
.PP
.Vb 1
\&    Your favourite colour?
.Ve
.PP
and \f(CW$reply\fR would hold the text the user typed.
.SS "get_reply with choices"
.IX Subsection "get_reply with choices"
.Vb 4
\&    ### now provide a list of choices, so the user has to pick one
\&    $reply = $term\->get_reply(
\&                prompt  => \*(AqYour favourite colour?\*(Aq,
\&                choices => [qw|red green blue|] );
.Ve
.PP
which would look like:
.PP
.Vb 3
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colour?
.Ve
.PP
\&\f(CW$reply\fR will hold one of the choices presented. \f(CW\*(C`Term::UI\*(C'\fR will repose
the question if the user attempts to enter an answer that's not in the
list of choices. The string presented is held in the \f(CW$Term::UI::INVALID\fR
variable (see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section for details.
.SS "get_reply with choices and default"
.IX Subsection "get_reply with choices and default"
.Vb 5
\&    ### provide a sensible default option \-\- everyone loves blue!
\&    $reply = $term\->get_reply(
\&                prompt  => \*(AqYour favourite colour?\*(Aq,
\&                choices => [qw|red green blue|],
\&                default => \*(Aqblue\*(Aq );
.Ve
.PP
which would look like:
.PP
.Vb 3
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colour? [3]:
.Ve
.PP
Note the default answer after the prompt. A user can now just hit \f(CW\*(C`enter\*(C'\fR
(or set \f(CW$Term::UI::AUTOREPLY\fR \*(-- see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section) and
the sensible answer 'blue' will be returned.
.SS "get_reply using print_me & multi"
.IX Subsection "get_reply using print_me & multi"
.Vb 7
\&    ### allow the user to pick more than one colour and add an
\&    ### introduction text
\&    @reply = $term\->get_reply(
\&                print_me    => \*(AqTell us what colours you like\*(Aq,
\&                prompt      => \*(AqYour favourite colours?\*(Aq,
\&                choices     => [qw|red green blue|],
\&                multi       => 1 );
.Ve
.PP
which would look like:
.PP
.Vb 4
\&    Tell us what colours you like
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colours?
.Ve
.PP
An answer of \f(CW\*(C`3 2 1\*(C'\fR would fill \f(CW@reply\fR with \f(CW\*(C`blue green red\*(C'\fR
.SS "get_reply & allow"
.IX Subsection "get_reply & allow"
.Vb 6
\&    ### pose an open question, but do a custom verification on
\&    ### the answer, which will only exit the question loop, if
\&    ### the answer matches the allow handler.
\&    $reply = $term\->get_reply(
\&                prompt  => "What is the magic number?",
\&                allow   => 42 );
.Ve
.PP
Unless the user now enters \f(CW42\fR, the question will be reposed over
and over again. You can use more sophisticated \f(CW\*(C`allow\*(C'\fR handlers (even
subroutines can be used). The \f(CW\*(C`allow\*(C'\fR handler is implemented using
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow\*(C'\fR function. Check its manpage for details.
.SS "an elaborate ask_yn sample"
.IX Subsection "an elaborate ask_yn sample"
.Vb 5
\&    ### ask a user if he likes cookies. Default to a sensible \*(Aqyes\*(Aq
\&    ### and inform him first what cookies are.
\&    $bool = $term\->ask_yn( prompt   => \*(AqDo you like cookies?\*(Aq,
\&                           default  => \*(Aqy\*(Aq,
\&                           print_me => \*(AqCookies are LOVELY!!!\*(Aq );
.Ve
.PP
would print:
.PP
.Vb 2
\&    Cookies are LOVELY!!!
\&    Do you like cookies? [Y/n]:
.Ve
.PP
If a user then simply hits \f(CW\*(C`enter\*(C'\fR, agreeing with the default,
\&\f(CW$bool\fR would be set to \f(CW\*(C`true\*(C'\fR. (Simply hitting 'y' would also
return \f(CW\*(C`true\*(C'\fR. Hitting 'n' would return \f(CW\*(C`false\*(C'\fR)
.PP
We could later retrieve this interaction by printing out the Q&A
history as follows:
.PP
.Vb 1
\&    print $term\->history_as_string;
.Ve
.PP
which would then print:
.PP
.Vb 2
\&    Cookies are LOVELY!!!
\&    Do you like cookies? [Y/n]:  y
.Ve
.PP
There's a chance we're doing this non-interactively, because a console
is missing, the user indicated he just wanted the defaults, etc.
.PP
In this case, simply setting \f(CW$Term::UI::AUTOREPLY\fR to true, will
return from every question with the default answer set for the question.
Do note that if \f(CW\*(C`AUTOREPLY\*(C'\fR is true, and no default is set, \f(CW\*(C`Term::UI\*(C'\fR
will warn about this and return \f(CW\*(C`undef\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Params::Check\*(C'\fR, \f(CW\*(C`Term::ReadLine\*(C'\fR, \f(CW\*(C`Term::UI::History\*(C'\fR
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-term\-ui@rt.cpan.org<gt>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::UI5.16.3pm                             0100644 0001750 0001750 00000043246 12566207441 023154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::UI 3pm"
.TH Term::UI 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::UI \- Term::ReadLine UI made easy
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Term::UI;
\&    use Term::ReadLine;
\&
\&    my $term = Term::ReadLine\->new(\*(Aqbrand\*(Aq);
\&
\&    my $reply = $term\->get_reply(
\&                    prompt => \*(AqWhat is your favourite colour?\*(Aq,
\&                    choices => [qw|blue red green|],
\&                    default => \*(Aqblue\*(Aq,
\&    );
\&
\&    my $bool = $term\->ask_yn(
\&                        prompt => \*(AqDo you like cookies?\*(Aq,
\&                        default => \*(Aqy\*(Aq,
\&                );
\&
\&
\&    my $string = q[some_command \-option \-\-no\-foo \-\-quux=\*(Aqthis thing\*(Aq];
\&
\&    my ($options,$munged_input) = $term\->parse_options($string);
\&
\&
\&    ### don\*(Aqt have Term::UI issue warnings \-\- default is \*(Aq1\*(Aq
\&    $Term::UI::VERBOSE = 0;
\&
\&    ### always pick the default (good for non\-interactive terms)
\&    ### \-\- default is \*(Aq0\*(Aq
\&    $Term::UI::AUTOREPLY = 1;
\&
\&    ### Retrieve the entire session as a printable string:
\&    $hist = Term::UI::History\->history_as_string;
\&    $hist = $term\->history_as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Term::UI\*(C'\fR is a transparent way of eliminating the overhead of having
to format a question and then validate the reply, informing the user
if the answer was not proper and re-issuing the question.
.PP
Simply give it the question you want to ask, optionally with choices
the user can pick from and a default and \f(CW\*(C`Term::UI\*(C'\fR will \s-1DWYM\s0.
.PP
For asking a yes or no question, there's even a shortcut.
.SH "HOW IT WORKS"
.IX Header "HOW IT WORKS"
\&\f(CW\*(C`Term::UI\*(C'\fR places itself at the back of the \f(CW\*(C`Term::ReadLine\*(C'\fR
\&\f(CW@ISA\fR array, so you can call its functions through your term object.
.PP
\&\f(CW\*(C`Term::UI\*(C'\fR uses \f(CW\*(C`Term::UI::History\*(C'\fR to record all interactions
with the commandline. You can retrieve this history, or alter
the filehandle the interaction is printed to. See the
\&\f(CW\*(C`Term::UI::History\*(C'\fR manpage or the \f(CW\*(C`SYNOPSIS\*(C'\fR for details.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$reply = $term\->get_reply( prompt => 'question?', [choices => \e@list, default => $list[0], multi => \s-1BOOL\s0, print_me => ""extra text to print & record"", allow => $ref] );"
.el .SS "\f(CW$reply\fP = \f(CW$term\fP\->get_reply( prompt => 'question?', [choices => \e@list, default => \f(CW$list\fP[0], multi => \s-1BOOL\s0, print_me => ``extra text to print & record'', allow => \f(CW$ref\fP] );"
.IX Subsection "$reply = $term->get_reply( prompt => 'question?', [choices => @list, default => $list[0], multi => BOOL, print_me => extra text to print & record, allow => $ref] );"
\&\f(CW\*(C`get_reply\*(C'\fR asks a user a question, and then returns the reply to the
caller. If the answer is invalid (more on that below), the question will
be reposed, until a satisfactory answer has been entered.
.PP
You have the option of providing a list of choices the user can pick from
using the \f(CW\*(C`choices\*(C'\fR argument. If the answer is not in the list of choices
presented, the question will be reposed.
.PP
If you provide a \f(CW\*(C`default\*(C'\fR  answer, this will be returned when either
\&\f(CW$AUTOREPLY\fR is set to true, (see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section further
below), or when the user just hits \f(CW\*(C`enter\*(C'\fR.
.PP
You can indicate that the user is allowed to enter multiple answers by
toggling the \f(CW\*(C`multi\*(C'\fR flag. Note that a list of answers will then be
returned to you, rather than a simple string.
.PP
By specifying an \f(CW\*(C`allow\*(C'\fR hander, you can yourself validate the answer
a user gives. This can be any of the types that the Params::Check \f(CW\*(C`allow\*(C'\fR
function allows, so please refer to that manpage for details.
.PP
Finally, you have the option of adding a \f(CW\*(C`print_me\*(C'\fR argument, which is
simply printed before the prompt. It's printed to the same file handle
as the rest of the questions, so you can use this to keep track of a
full session of Q&A with the user, and retrieve it later using the
\&\f(CW\*(C`Term::UI\->history_as_string\*(C'\fR function.
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section for samples of how to use this function.
.ie n .SS "$bool = $term\->ask_yn( prompt => ""your question"", [default => (y|1,n|0), print_me => ""extra text to print & record""] )"
.el .SS "\f(CW$bool\fP = \f(CW$term\fP\->ask_yn( prompt => ``your question'', [default => (y|1,n|0), print_me => ``extra text to print & record''] )"
.IX Subsection "$bool = $term->ask_yn( prompt => your question, [default => (y|1,n|0), print_me => extra text to print & record] )"
Asks a simple \f(CW\*(C`yes\*(C'\fR or \f(CW\*(C`no\*(C'\fR question to the user, returning a boolean
indicating \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR to the caller.
.PP
The \f(CW\*(C`default\*(C'\fR answer will automatically returned, if the user hits
\&\f(CW\*(C`enter\*(C'\fR or if \f(CW$AUTOREPLY\fR is set to true. See the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR
section further below.
.PP
Also, you have the option of adding a \f(CW\*(C`print_me\*(C'\fR argument, which is
simply printed before the prompt. It's printed to the same file handle
as the rest of the questions, so you can use this to keep track of a
full session of Q&A with the user, and retrieve it later using the
\&\f(CW\*(C`Term::UI\->history_as_string\*(C'\fR function.
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section for samples of how to use this function.
.ie n .SS "($opts, $munged) = $term\->parse_options( \s-1STRING\s0 );"
.el .SS "($opts, \f(CW$munged\fP) = \f(CW$term\fP\->parse_options( \s-1STRING\s0 );"
.IX Subsection "($opts, $munged) = $term->parse_options( STRING );"
\&\f(CW\*(C`parse_options\*(C'\fR will convert all options given from an input string
to a hash reference. If called in list context it will also return
the part of the input string that it found no options in.
.PP
Consider this example:
.PP
.Vb 2
\&    my $str =   q[command \-\-no\-foo \-\-baz \-\-bar=0 \-\-quux=bleh ] .
\&                q[\-\-option="some\*(Aqthing" \-one\-dash \-single=blah\*(Aq arg];
\&
\&    my ($options,$munged) =  $term\->parse_options($str);
\&
\&    ### $options would contain: ###
\&    $options = {
\&                \*(Aqfoo\*(Aq       => 0,
\&                \*(Aqbar\*(Aq       => 0,
\&                \*(Aqone\-dash\*(Aq  => 1,
\&                \*(Aqbaz\*(Aq       => 1,
\&                \*(Aqquux\*(Aq      => \*(Aqbleh\*(Aq,
\&                \*(Aqsingle\*(Aq    => \*(Aqblah\e\*(Aq\*(Aq,
\&                \*(Aqoption\*(Aq    => \*(Aqsome\e\*(Aqthing\*(Aq
\&    };
\&
\&    ### and this is the munged version of the input string,
\&    ### ie what\*(Aqs left of the input minus the options
\&    $munged = \*(Aqcommand arg\*(Aq;
.Ve
.PP
As you can see, you can either use a single or a double \f(CW\*(C`\-\*(C'\fR to
indicate an option.
If you prefix an option with \f(CW\*(C`no\-\*(C'\fR and do not give it a value, it
will be set to 0.
If it has no prefix and no value, it will be set to 1.
Otherwise, it will be set to its value. Note also that it can deal
fine with single/double quoting issues.
.ie n .SS "$str = $term\->history_as_string"
.el .SS "\f(CW$str\fP = \f(CW$term\fP\->history_as_string"
.IX Subsection "$str = $term->history_as_string"
Convenience wrapper around \f(CW\*(C`Term::UI::History\->history_as_string\*(C'\fR.
.PP
Consult the \f(CW\*(C`Term::UI::History\*(C'\fR man page for details.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
The behaviour of Term::UI can be altered by changing the following
global variables:
.ie n .SS "$Term::UI::VERBOSE"
.el .SS "\f(CW$Term::UI::VERBOSE\fP"
.IX Subsection "$Term::UI::VERBOSE"
This controls whether Term::UI will issue warnings and explanations
as to why certain things may have failed. If you set it to 0,
Term::UI will not output any warnings.
The default is 1;
.ie n .SS "$Term::UI::AUTOREPLY"
.el .SS "\f(CW$Term::UI::AUTOREPLY\fP"
.IX Subsection "$Term::UI::AUTOREPLY"
This will make every question be answered by the default, and warn if
there was no default provided. This is particularly useful if your
program is run in non-interactive mode.
The default is 0;
.ie n .SS "$Term::UI::INVALID"
.el .SS "\f(CW$Term::UI::INVALID\fP"
.IX Subsection "$Term::UI::INVALID"
This holds the string that will be printed when the user makes an
invalid choice.
You can override this string from your program if you, for example,
wish to do localization.
The default is \f(CW\*(C`Invalid selection, please try again: \*(C'\fR
.ie n .SS "$Term::UI::History::HISTORY_FH"
.el .SS "\f(CW$Term::UI::History::HISTORY_FH\fP"
.IX Subsection "$Term::UI::History::HISTORY_FH"
This is the filehandle all the print statements from this module
are being sent to. Please consult the \f(CW\*(C`Term::UI::History\*(C'\fR manpage
for details.
.PP
This defaults to \f(CW*STDOUT\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Basic get_reply sample"
.IX Subsection "Basic get_reply sample"
.Vb 2
\&    ### ask a user (with an open question) for their favourite colour
\&    $reply = $term\->get_reply( prompt => \*(AqYour favourite colour? );
.Ve
.PP
which would look like:
.PP
.Vb 1
\&    Your favourite colour?
.Ve
.PP
and \f(CW$reply\fR would hold the text the user typed.
.SS "get_reply with choices"
.IX Subsection "get_reply with choices"
.Vb 4
\&    ### now provide a list of choices, so the user has to pick one
\&    $reply = $term\->get_reply(
\&                prompt  => \*(AqYour favourite colour?\*(Aq,
\&                choices => [qw|red green blue|] );
.Ve
.PP
which would look like:
.PP
.Vb 3
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colour?
.Ve
.PP
\&\f(CW$reply\fR will hold one of the choices presented. \f(CW\*(C`Term::UI\*(C'\fR will repose
the question if the user attempts to enter an answer that's not in the
list of choices. The string presented is held in the \f(CW$Term::UI::INVALID\fR
variable (see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section for details.
.SS "get_reply with choices and default"
.IX Subsection "get_reply with choices and default"
.Vb 5
\&    ### provide a sensible default option \-\- everyone loves blue!
\&    $reply = $term\->get_reply(
\&                prompt  => \*(AqYour favourite colour?\*(Aq,
\&                choices => [qw|red green blue|],
\&                default => \*(Aqblue\*(Aq );
.Ve
.PP
which would look like:
.PP
.Vb 3
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colour? [3]:
.Ve
.PP
Note the default answer after the prompt. A user can now just hit \f(CW\*(C`enter\*(C'\fR
(or set \f(CW$Term::UI::AUTOREPLY\fR \*(-- see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section) and
the sensible answer 'blue' will be returned.
.SS "get_reply using print_me & multi"
.IX Subsection "get_reply using print_me & multi"
.Vb 7
\&    ### allow the user to pick more than one colour and add an
\&    ### introduction text
\&    @reply = $term\->get_reply(
\&                print_me    => \*(AqTell us what colours you like\*(Aq,
\&                prompt      => \*(AqYour favourite colours?\*(Aq,
\&                choices     => [qw|red green blue|],
\&                multi       => 1 );
.Ve
.PP
which would look like:
.PP
.Vb 4
\&    Tell us what colours you like
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colours?
.Ve
.PP
An answer of \f(CW\*(C`3 2 1\*(C'\fR would fill \f(CW@reply\fR with \f(CW\*(C`blue green red\*(C'\fR
.SS "get_reply & allow"
.IX Subsection "get_reply & allow"
.Vb 6
\&    ### pose an open question, but do a custom verification on
\&    ### the answer, which will only exit the question loop, if
\&    ### the answer matches the allow handler.
\&    $reply = $term\->get_reply(
\&                prompt  => "What is the magic number?",
\&                allow   => 42 );
.Ve
.PP
Unless the user now enters \f(CW42\fR, the question will be reposed over
and over again. You can use more sophisticated \f(CW\*(C`allow\*(C'\fR handlers (even
subroutines can be used). The \f(CW\*(C`allow\*(C'\fR handler is implemented using
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow\*(C'\fR function. Check its manpage for details.
.SS "an elaborate ask_yn sample"
.IX Subsection "an elaborate ask_yn sample"
.Vb 5
\&    ### ask a user if he likes cookies. Default to a sensible \*(Aqyes\*(Aq
\&    ### and inform him first what cookies are.
\&    $bool = $term\->ask_yn( prompt   => \*(AqDo you like cookies?\*(Aq,
\&                           default  => \*(Aqy\*(Aq,
\&                           print_me => \*(AqCookies are LOVELY!!!\*(Aq );
.Ve
.PP
would print:
.PP
.Vb 2
\&    Cookies are LOVELY!!!
\&    Do you like cookies? [Y/n]:
.Ve
.PP
If a user then simply hits \f(CW\*(C`enter\*(C'\fR, agreeing with the default,
\&\f(CW$bool\fR would be set to \f(CW\*(C`true\*(C'\fR. (Simply hitting 'y' would also
return \f(CW\*(C`true\*(C'\fR. Hitting 'n' would return \f(CW\*(C`false\*(C'\fR)
.PP
We could later retrieve this interaction by printing out the Q&A
history as follows:
.PP
.Vb 1
\&    print $term\->history_as_string;
.Ve
.PP
which would then print:
.PP
.Vb 2
\&    Cookies are LOVELY!!!
\&    Do you like cookies? [Y/n]:  y
.Ve
.PP
There's a chance we're doing this non-interactively, because a console
is missing, the user indicated he just wanted the defaults, etc.
.PP
In this case, simply setting \f(CW$Term::UI::AUTOREPLY\fR to true, will
return from every question with the default answer set for the question.
Do note that if \f(CW\*(C`AUTOREPLY\*(C'\fR is true, and no default is set, \f(CW\*(C`Term::UI\*(C'\fR
will warn about this and return \f(CW\*(C`undef\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Params::Check\*(C'\fR, \f(CW\*(C`Term::ReadLine\*(C'\fR, \f(CW\*(C`Term::UI::History\*(C'\fR
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-term\-ui@rt.cpan.org<gt>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::UI5.18.3pm                             0100644 0001750 0001750 00000043567 12566207463 023170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::UI 3pm"
.TH Term::UI 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::UI \- Term::ReadLine UI made easy
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Term::UI;
\&    use Term::ReadLine;
\&
\&    my $term = Term::ReadLine\->new(\*(Aqbrand\*(Aq);
\&
\&    my $reply = $term\->get_reply(
\&                    prompt => \*(AqWhat is your favourite colour?\*(Aq,
\&                    choices => [qw|blue red green|],
\&                    default => \*(Aqblue\*(Aq,
\&    );
\&
\&    my $bool = $term\->ask_yn(
\&                        prompt => \*(AqDo you like cookies?\*(Aq,
\&                        default => \*(Aqy\*(Aq,
\&                );
\&
\&
\&    my $string = q[some_command \-option \-\-no\-foo \-\-quux=\*(Aqthis thing\*(Aq];
\&
\&    my ($options,$munged_input) = $term\->parse_options($string);
\&
\&
\&    ### don\*(Aqt have Term::UI issue warnings \-\- default is \*(Aq1\*(Aq
\&    $Term::UI::VERBOSE = 0;
\&
\&    ### always pick the default (good for non\-interactive terms)
\&    ### \-\- default is \*(Aq0\*(Aq
\&    $Term::UI::AUTOREPLY = 1;
\&
\&    ### Retrieve the entire session as a printable string:
\&    $hist = Term::UI::History\->history_as_string;
\&    $hist = $term\->history_as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Term::UI\*(C'\fR is a transparent way of eliminating the overhead of having
to format a question and then validate the reply, informing the user
if the answer was not proper and re-issuing the question.
.PP
Simply give it the question you want to ask, optionally with choices
the user can pick from and a default and \f(CW\*(C`Term::UI\*(C'\fR will \s-1DWYM.\s0
.PP
For asking a yes or no question, there's even a shortcut.
.SH "HOW IT WORKS"
.IX Header "HOW IT WORKS"
\&\f(CW\*(C`Term::UI\*(C'\fR places itself at the back of the \f(CW\*(C`Term::ReadLine\*(C'\fR
\&\f(CW@ISA\fR array, so you can call its functions through your term object.
.PP
\&\f(CW\*(C`Term::UI\*(C'\fR uses \f(CW\*(C`Term::UI::History\*(C'\fR to record all interactions
with the commandline. You can retrieve this history, or alter
the filehandle the interaction is printed to. See the
\&\f(CW\*(C`Term::UI::History\*(C'\fR manpage or the \f(CW\*(C`SYNOPSIS\*(C'\fR for details.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$reply = $term\->get_reply( prompt => 'question?', [choices => \e@list, default => $list[0], multi => \s-1BOOL,\s0 print_me => ""extra text to print & record"", allow => $ref] );"
.el .SS "\f(CW$reply\fP = \f(CW$term\fP\->get_reply( prompt => 'question?', [choices => \e@list, default => \f(CW$list\fP[0], multi => \s-1BOOL,\s0 print_me => ``extra text to print & record'', allow => \f(CW$ref\fP] );"
.IX Subsection "$reply = $term->get_reply( prompt => 'question?', [choices => @list, default => $list[0], multi => BOOL, print_me => extra text to print & record, allow => $ref] );"
\&\f(CW\*(C`get_reply\*(C'\fR asks a user a question, and then returns the reply to the
caller. If the answer is invalid (more on that below), the question will
be reposed, until a satisfactory answer has been entered.
.PP
You have the option of providing a list of choices the user can pick from
using the \f(CW\*(C`choices\*(C'\fR argument. If the answer is not in the list of choices
presented, the question will be reposed.
.PP
If you provide a \f(CW\*(C`default\*(C'\fR  answer, this will be returned when either
\&\f(CW$AUTOREPLY\fR is set to true, (see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section further
below), or when the user just hits \f(CW\*(C`enter\*(C'\fR.
.PP
You can indicate that the user is allowed to enter multiple answers by
toggling the \f(CW\*(C`multi\*(C'\fR flag. Note that a list of answers will then be
returned to you, rather than a simple string.
.PP
By specifying an \f(CW\*(C`allow\*(C'\fR hander, you can yourself validate the answer
a user gives. This can be any of the types that the Params::Check \f(CW\*(C`allow\*(C'\fR
function allows, so please refer to that manpage for details.
.PP
Finally, you have the option of adding a \f(CW\*(C`print_me\*(C'\fR argument, which is
simply printed before the prompt. It's printed to the same file handle
as the rest of the questions, so you can use this to keep track of a
full session of Q&A with the user, and retrieve it later using the
\&\f(CW\*(C`Term::UI\->history_as_string\*(C'\fR function.
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section for samples of how to use this function.
.ie n .SS "$bool = $term\->ask_yn( prompt => ""your question"", [default => (y|1,n|0), print_me => ""extra text to print & record""] )"
.el .SS "\f(CW$bool\fP = \f(CW$term\fP\->ask_yn( prompt => ``your question'', [default => (y|1,n|0), print_me => ``extra text to print & record''] )"
.IX Subsection "$bool = $term->ask_yn( prompt => your question, [default => (y|1,n|0), print_me => extra text to print & record] )"
Asks a simple \f(CW\*(C`yes\*(C'\fR or \f(CW\*(C`no\*(C'\fR question to the user, returning a boolean
indicating \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR to the caller.
.PP
The \f(CW\*(C`default\*(C'\fR answer will automatically returned, if the user hits
\&\f(CW\*(C`enter\*(C'\fR or if \f(CW$AUTOREPLY\fR is set to true. See the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR
section further below.
.PP
Also, you have the option of adding a \f(CW\*(C`print_me\*(C'\fR argument, which is
simply printed before the prompt. It's printed to the same file handle
as the rest of the questions, so you can use this to keep track of a
full session of Q&A with the user, and retrieve it later using the
\&\f(CW\*(C`Term::UI\->history_as_string\*(C'\fR function.
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section for samples of how to use this function.
.ie n .SS "($opts, $munged) = $term\->parse_options( \s-1STRING \s0);"
.el .SS "($opts, \f(CW$munged\fP) = \f(CW$term\fP\->parse_options( \s-1STRING \s0);"
.IX Subsection "($opts, $munged) = $term->parse_options( STRING );"
\&\f(CW\*(C`parse_options\*(C'\fR will convert all options given from an input string
to a hash reference. If called in list context it will also return
the part of the input string that it found no options in.
.PP
Consider this example:
.PP
.Vb 2
\&    my $str =   q[command \-\-no\-foo \-\-baz \-\-bar=0 \-\-quux=bleh ] .
\&                q[\-\-option="some\*(Aqthing" \-one\-dash \-single=blah\*(Aq arg];
\&
\&    my ($options,$munged) =  $term\->parse_options($str);
\&
\&    ### $options would contain: ###
\&    $options = {
\&                \*(Aqfoo\*(Aq       => 0,
\&                \*(Aqbar\*(Aq       => 0,
\&                \*(Aqone\-dash\*(Aq  => 1,
\&                \*(Aqbaz\*(Aq       => 1,
\&                \*(Aqquux\*(Aq      => \*(Aqbleh\*(Aq,
\&                \*(Aqsingle\*(Aq    => \*(Aqblah\e\*(Aq\*(Aq,
\&                \*(Aqoption\*(Aq    => \*(Aqsome\e\*(Aqthing\*(Aq
\&    };
\&
\&    ### and this is the munged version of the input string,
\&    ### ie what\*(Aqs left of the input minus the options
\&    $munged = \*(Aqcommand arg\*(Aq;
.Ve
.PP
As you can see, you can either use a single or a double \f(CW\*(C`\-\*(C'\fR to
indicate an option.
If you prefix an option with \f(CW\*(C`no\-\*(C'\fR and do not give it a value, it
will be set to 0.
If it has no prefix and no value, it will be set to 1.
Otherwise, it will be set to its value. Note also that it can deal
fine with single/double quoting issues.
.ie n .SS "$str = $term\->history_as_string"
.el .SS "\f(CW$str\fP = \f(CW$term\fP\->history_as_string"
.IX Subsection "$str = $term->history_as_string"
Convenience wrapper around \f(CW\*(C`Term::UI::History\->history_as_string\*(C'\fR.
.PP
Consult the \f(CW\*(C`Term::UI::History\*(C'\fR man page for details.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
The behaviour of Term::UI can be altered by changing the following
global variables:
.ie n .SS "$Term::UI::VERBOSE"
.el .SS "\f(CW$Term::UI::VERBOSE\fP"
.IX Subsection "$Term::UI::VERBOSE"
This controls whether Term::UI will issue warnings and explanations
as to why certain things may have failed. If you set it to 0,
Term::UI will not output any warnings.
The default is 1;
.ie n .SS "$Term::UI::AUTOREPLY"
.el .SS "\f(CW$Term::UI::AUTOREPLY\fP"
.IX Subsection "$Term::UI::AUTOREPLY"
This will make every question be answered by the default, and warn if
there was no default provided. This is particularly useful if your
program is run in non-interactive mode.
The default is 0;
.ie n .SS "$Term::UI::INVALID"
.el .SS "\f(CW$Term::UI::INVALID\fP"
.IX Subsection "$Term::UI::INVALID"
This holds the string that will be printed when the user makes an
invalid choice.
You can override this string from your program if you, for example,
wish to do localization.
The default is \f(CW\*(C`Invalid selection, please try again: \*(C'\fR
.ie n .SS "$Term::UI::History::HISTORY_FH"
.el .SS "\f(CW$Term::UI::History::HISTORY_FH\fP"
.IX Subsection "$Term::UI::History::HISTORY_FH"
This is the filehandle all the print statements from this module
are being sent to. Please consult the \f(CW\*(C`Term::UI::History\*(C'\fR manpage
for details.
.PP
This defaults to \f(CW*STDOUT\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Basic get_reply sample"
.IX Subsection "Basic get_reply sample"
.Vb 2
\&    ### ask a user (with an open question) for their favourite colour
\&    $reply = $term\->get_reply( prompt => \*(AqYour favourite colour? );
.Ve
.PP
which would look like:
.PP
.Vb 1
\&    Your favourite colour?
.Ve
.PP
and \f(CW$reply\fR would hold the text the user typed.
.SS "get_reply with choices"
.IX Subsection "get_reply with choices"
.Vb 4
\&    ### now provide a list of choices, so the user has to pick one
\&    $reply = $term\->get_reply(
\&                prompt  => \*(AqYour favourite colour?\*(Aq,
\&                choices => [qw|red green blue|] );
.Ve
.PP
which would look like:
.PP
.Vb 3
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colour?
.Ve
.PP
\&\f(CW$reply\fR will hold one of the choices presented. \f(CW\*(C`Term::UI\*(C'\fR will repose
the question if the user attempts to enter an answer that's not in the
list of choices. The string presented is held in the \f(CW$Term::UI::INVALID\fR
variable (see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section for details.
.SS "get_reply with choices and default"
.IX Subsection "get_reply with choices and default"
.Vb 5
\&    ### provide a sensible default option \-\- everyone loves blue!
\&    $reply = $term\->get_reply(
\&                prompt  => \*(AqYour favourite colour?\*(Aq,
\&                choices => [qw|red green blue|],
\&                default => \*(Aqblue\*(Aq );
.Ve
.PP
which would look like:
.PP
.Vb 3
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colour? [3]:
.Ve
.PP
Note the default answer after the prompt. A user can now just hit \f(CW\*(C`enter\*(C'\fR
(or set \f(CW$Term::UI::AUTOREPLY\fR \*(-- see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section) and
the sensible answer 'blue' will be returned.
.SS "get_reply using print_me & multi"
.IX Subsection "get_reply using print_me & multi"
.Vb 7
\&    ### allow the user to pick more than one colour and add an
\&    ### introduction text
\&    @reply = $term\->get_reply(
\&                print_me    => \*(AqTell us what colours you like\*(Aq,
\&                prompt      => \*(AqYour favourite colours?\*(Aq,
\&                choices     => [qw|red green blue|],
\&                multi       => 1 );
.Ve
.PP
which would look like:
.PP
.Vb 4
\&    Tell us what colours you like
\&      1> red
\&      2> green
\&      3> blue
\&
\&    Your favourite colours?
.Ve
.PP
An answer of \f(CW\*(C`3 2 1\*(C'\fR would fill \f(CW@reply\fR with \f(CW\*(C`blue green red\*(C'\fR
.SS "get_reply & allow"
.IX Subsection "get_reply & allow"
.Vb 6
\&    ### pose an open question, but do a custom verification on
\&    ### the answer, which will only exit the question loop, if
\&    ### the answer matches the allow handler.
\&    $reply = $term\->get_reply(
\&                prompt  => "What is the magic number?",
\&                allow   => 42 );
.Ve
.PP
Unless the user now enters \f(CW42\fR, the question will be reposed over
and over again. You can use more sophisticated \f(CW\*(C`allow\*(C'\fR handlers (even
subroutines can be used). The \f(CW\*(C`allow\*(C'\fR handler is implemented using
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow\*(C'\fR function. Check its manpage for details.
.SS "an elaborate ask_yn sample"
.IX Subsection "an elaborate ask_yn sample"
.Vb 5
\&    ### ask a user if he likes cookies. Default to a sensible \*(Aqyes\*(Aq
\&    ### and inform him first what cookies are.
\&    $bool = $term\->ask_yn( prompt   => \*(AqDo you like cookies?\*(Aq,
\&                           default  => \*(Aqy\*(Aq,
\&                           print_me => \*(AqCookies are LOVELY!!!\*(Aq );
.Ve
.PP
would print:
.PP
.Vb 2
\&    Cookies are LOVELY!!!
\&    Do you like cookies? [Y/n]:
.Ve
.PP
If a user then simply hits \f(CW\*(C`enter\*(C'\fR, agreeing with the default,
\&\f(CW$bool\fR would be set to \f(CW\*(C`true\*(C'\fR. (Simply hitting 'y' would also
return \f(CW\*(C`true\*(C'\fR. Hitting 'n' would return \f(CW\*(C`false\*(C'\fR)
.PP
We could later retrieve this interaction by printing out the Q&A
history as follows:
.PP
.Vb 1
\&    print $term\->history_as_string;
.Ve
.PP
which would then print:
.PP
.Vb 2
\&    Cookies are LOVELY!!!
\&    Do you like cookies? [Y/n]:  y
.Ve
.PP
There's a chance we're doing this non-interactively, because a console
is missing, the user indicated he just wanted the defaults, etc.
.PP
In this case, simply setting \f(CW$Term::UI::AUTOREPLY\fR to true, will
return from every question with the default answer set for the question.
Do note that if \f(CW\*(C`AUTOREPLY\*(C'\fR is true, and no default is set, \f(CW\*(C`Term::UI\*(C'\fR
will warn about this and return \f(CW\*(C`undef\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Params::Check\*(C'\fR, \f(CW\*(C`Term::ReadLine\*(C'\fR, \f(CW\*(C`Term::UI::History\*(C'\fR
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-term\-ui@rt.cpan.org<gt>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::UI::History.3pm                        0100644 0001750 0001750 00000013533 12566207463 024410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::UI::History 3pm"
.TH Term::UI::History 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::UI::History \- history function
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Term::UI::History qw[history];
\&
\&    history("Some message");
\&
\&    ### retrieve the history in printable form
\&    $hist  = Term::UI::History\->history_as_string;
\&
\&    ### redirect output
\&    local $Term::UI::History::HISTORY_FH = \e*STDERR;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the \f(CW\*(C`history\*(C'\fR function for \f(CW\*(C`Term::UI\*(C'\fR,
printing and saving all the \f(CW\*(C`UI\*(C'\fR interaction.
.PP
Refer to the \f(CW\*(C`Term::UI\*(C'\fR manpage for details on usage from
\&\f(CW\*(C`Term::UI\*(C'\fR.
.PP
This module subclasses \f(CW\*(C`Log::Message::Simple\*(C'\fR. Refer to its
manpage for additional functionality available via this package.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "history(""message string"" [,VERBOSE])"
.el .SS "history(``message string'' [,VERBOSE])"
.IX Subsection "history(message string [,VERBOSE])"
Records a message on the stack, and prints it to \f(CW\*(C`STDOUT\*(C'\fR
(or actually \f(CW$HISTORY_FH\fR, see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section
below), if the \f(CW\*(C`VERBOSE\*(C'\fR option is true.
.PP
The \f(CW\*(C`VERBOSE\*(C'\fR option defaults to true.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .IP "$HISTORY_FH" 4
.el .IP "\f(CW$HISTORY_FH\fR" 4
.IX Item "$HISTORY_FH"
This is the filehandle all the messages sent to \f(CW\*(C`history()\*(C'\fR are being
printed. This defaults to \f(CW*STDOUT\fR.
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Log::Message::Simple\*(C'\fR, \f(CW\*(C`Term::UI\*(C'\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by
Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is
copyright (c) 2005 Jos Boumans <kane@cpan.org>.
All rights reserved.
.PP
This library is free software;
you may redistribute and/or modify it under the same
terms as Perl itself.
                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::UI::History5.16.3pm                    0100644 0001750 0001750 00000013212 12566207441 024710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::UI::History 3pm"
.TH Term::UI::History 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::UI::History \- history function
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Term::UI::History qw[history];
\&
\&    history("Some message");
\&
\&    ### retrieve the history in printable form
\&    $hist  = Term::UI::History\->history_as_string;
\&
\&    ### redirect output
\&    local $Term::UI::History::HISTORY_FH = \e*STDERR;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the \f(CW\*(C`history\*(C'\fR function for \f(CW\*(C`Term::UI\*(C'\fR,
printing and saving all the \f(CW\*(C`UI\*(C'\fR interaction.
.PP
Refer to the \f(CW\*(C`Term::UI\*(C'\fR manpage for details on usage from
\&\f(CW\*(C`Term::UI\*(C'\fR.
.PP
This module subclasses \f(CW\*(C`Log::Message::Simple\*(C'\fR. Refer to its
manpage for additional functionality available via this package.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "history(""message string"" [,VERBOSE])"
.el .SS "history(``message string'' [,VERBOSE])"
.IX Subsection "history(message string [,VERBOSE])"
Records a message on the stack, and prints it to \f(CW\*(C`STDOUT\*(C'\fR
(or actually \f(CW$HISTORY_FH\fR, see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section
below), if the \f(CW\*(C`VERBOSE\*(C'\fR option is true.
.PP
The \f(CW\*(C`VERBOSE\*(C'\fR option defaults to true.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .IP "$HISTORY_FH" 4
.el .IP "\f(CW$HISTORY_FH\fR" 4
.IX Item "$HISTORY_FH"
This is the filehandle all the messages sent to \f(CW\*(C`history()\*(C'\fR are being
printed. This defaults to \f(CW*STDOUT\fR.
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Log::Message::Simple\*(C'\fR, \f(CW\*(C`Term::UI\*(C'\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by
Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is
copyright (c) 2005 Jos Boumans <kane@cpan.org>.
All rights reserved.
.PP
This library is free software;
you may redistribute and/or modify it under the same
terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Term::UI::History5.18.3pm                    0100644 0001750 0001750 00000013533 12566207463 024724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::UI::History 3pm"
.TH Term::UI::History 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::UI::History \- history function
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Term::UI::History qw[history];
\&
\&    history("Some message");
\&
\&    ### retrieve the history in printable form
\&    $hist  = Term::UI::History\->history_as_string;
\&
\&    ### redirect output
\&    local $Term::UI::History::HISTORY_FH = \e*STDERR;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the \f(CW\*(C`history\*(C'\fR function for \f(CW\*(C`Term::UI\*(C'\fR,
printing and saving all the \f(CW\*(C`UI\*(C'\fR interaction.
.PP
Refer to the \f(CW\*(C`Term::UI\*(C'\fR manpage for details on usage from
\&\f(CW\*(C`Term::UI\*(C'\fR.
.PP
This module subclasses \f(CW\*(C`Log::Message::Simple\*(C'\fR. Refer to its
manpage for additional functionality available via this package.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "history(""message string"" [,VERBOSE])"
.el .SS "history(``message string'' [,VERBOSE])"
.IX Subsection "history(message string [,VERBOSE])"
Records a message on the stack, and prints it to \f(CW\*(C`STDOUT\*(C'\fR
(or actually \f(CW$HISTORY_FH\fR, see the \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section
below), if the \f(CW\*(C`VERBOSE\*(C'\fR option is true.
.PP
The \f(CW\*(C`VERBOSE\*(C'\fR option defaults to true.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .IP "$HISTORY_FH" 4
.el .IP "\f(CW$HISTORY_FH\fR" 4
.IX Item "$HISTORY_FH"
This is the filehandle all the messages sent to \f(CW\*(C`history()\*(C'\fR are being
printed. This defaults to \f(CW*STDOUT\fR.
.SH "See Also"
.IX Header "See Also"
\&\f(CW\*(C`Log::Message::Simple\*(C'\fR, \f(CW\*(C`Term::UI\*(C'\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by
Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is
copyright (c) 2005 Jos Boumans <kane@cpan.org>.
All rights reserved.
.PP
This library is free software;
you may redistribute and/or modify it under the same
terms as Perl itself.
                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test.3pm                                     0100644 0001750 0001750 00000056041 12566207463 022231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test 3pm"
.TH Test 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test \- provides a simple framework for writing test scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use strict;
\&  use Test;
\&
\&  # use a BEGIN block so we print our plan before MyModule is loaded
\&  BEGIN { plan tests => 14, todo => [3,4] }
\&
\&  # load your module...
\&  use MyModule;
\&
\&  # Helpful notes.  All note\-lines must start with a "#".
\&  print "# I\*(Aqm testing MyModule version $MyModule::VERSION\en";
\&
\&  ok(0); # failure
\&  ok(1); # success
\&
\&  ok(0); # ok, expected failure (see todo list, above)
\&  ok(1); # surprise success!
\&
\&  ok(0,1);             # failure: \*(Aq0\*(Aq ne \*(Aq1\*(Aq
\&  ok(\*(Aqbroke\*(Aq,\*(Aqfixed\*(Aq); # failure: \*(Aqbroke\*(Aq ne \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,\*(Aqfixed\*(Aq); # success: \*(Aqfixed\*(Aq eq \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,qr/x/);   # success: \*(Aqfixed\*(Aq =~ qr/x/
\&
\&  ok(sub { 1+1 }, 2);  # success: \*(Aq2\*(Aq eq \*(Aq2\*(Aq
\&  ok(sub { 1+1 }, 3);  # failure: \*(Aq2\*(Aq ne \*(Aq3\*(Aq
\&
\&  my @list = (0,0);
\&  ok @list, 3, "\e@list=".join(\*(Aq,\*(Aq,@list);      #extra notes
\&  ok \*(Aqsegmentation fault\*(Aq, \*(Aq/(?i)success/\*(Aq;    #regex match
\&
\&  skip(
\&    $^O =~ m/MSWin/ ? "Skip if MSWin" : 0,  # whether to skip
\&    $foo, $bar  # arguments just like for ok(...)
\&  );
\&  skip(
\&    $^O =~ m/MSWin/ ? 0 : "Skip unless MSWin",  # whether to skip
\&    $foo, $bar  # arguments just like for ok(...)
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module simplifies the task of writing test files for Perl modules,
such that their output is in the format that
Test::Harness expects to see.
.SH "QUICK START GUIDE"
.IX Header "QUICK START GUIDE"
To write a test for your new (and probably not even done) module, create
a new file called \fIt/test.t\fR (in a new \fIt\fR directory). If you have
multiple test files, to test the \*(L"foo\*(R", \*(L"bar\*(R", and \*(L"baz\*(R" feature sets,
then feel free to call your files \fIt/foo.t\fR, \fIt/bar.t\fR, and
\&\fIt/baz.t\fR
.SS "Functions"
.IX Subsection "Functions"
This module defines three public functions, \f(CW\*(C`plan(...)\*(C'\fR, \f(CW\*(C`ok(...)\*(C'\fR,
and \f(CW\*(C`skip(...)\*(C'\fR.  By default, all three are exported by
the \f(CW\*(C`use Test;\*(C'\fR statement.
.ie n .IP """plan(...)""" 4
.el .IP "\f(CWplan(...)\fR" 4
.IX Item "plan(...)"
.Vb 1
\&     BEGIN { plan %theplan; }
.Ve
.Sp
This should be the first thing you call in your test script.  It
declares your testing plan, how many there will be, if any of them
should be allowed to fail, and so on.
.Sp
Typical usage is just:
.Sp
.Vb 2
\&     use Test;
\&     BEGIN { plan tests => 23 }
.Ve
.Sp
These are the things that you can put in the parameters to plan:
.RS 4
.ie n .IP """tests => \f(CInumber\f(CW""" 4
.el .IP "\f(CWtests => \f(CInumber\f(CW\fR" 4
.IX Item "tests => number"
The number of tests in your script.
This means all \fIok()\fR and \fIskip()\fR calls.
.ie n .IP """todo => [\f(CI1,5,14\f(CW]""" 4
.el .IP "\f(CWtodo => [\f(CI1,5,14\f(CW]\fR" 4
.IX Item "todo => [1,5,14]"
A reference to a list of tests which are allowed to fail.
See \*(L"\s-1TODO TESTS\*(R"\s0.
.ie n .IP """onfail => sub { ... }""" 4
.el .IP "\f(CWonfail => sub { ... }\fR" 4
.IX Item "onfail => sub { ... }"
.PD 0
.ie n .IP """onfail => \e&some_sub""" 4
.el .IP "\f(CWonfail => \e&some_sub\fR" 4
.IX Item "onfail => &some_sub"
.PD
A subroutine reference to be run at the end of the test script, if
any of the tests fail.  See \*(L"\s-1ONFAIL\*(R"\s0.
.RE
.RS 4
.Sp
You must call \f(CW\*(C`plan(...)\*(C'\fR once and only once.  You should call it
in a \f(CW\*(C`BEGIN {...}\*(C'\fR block, like so:
.Sp
.Vb 1
\&     BEGIN { plan tests => 23 }
.Ve
.RE
.ie n .IP """ok(...)""" 4
.el .IP "\f(CWok(...)\fR" 4
.IX Item "ok(...)"
.Vb 3
\&  ok(1 + 1 == 2);
\&  ok($have, $expect);
\&  ok($have, $expect, $diagnostics);
.Ve
.Sp
This function is the reason for \f(CW\*(C`Test\*(C'\fR's existence.  It's
the basic function that
handles printing "\f(CW\*(C`ok\*(C'\fR\*(L" or \*(R"\f(CW\*(C`not ok\*(C'\fR", along with the
current test number.  (That's what \f(CW\*(C`Test::Harness\*(C'\fR wants to see.)
.Sp
In its most basic usage, \f(CW\*(C`ok(...)\*(C'\fR simply takes a single scalar
expression.  If its value is true, the test passes; if false,
the test fails.  Examples:
.Sp
.Vb 1
\&    # Examples of ok(scalar)
\&
\&    ok( 1 + 1 == 2 );           # ok if 1 + 1 == 2
\&    ok( $foo =~ /bar/ );        # ok if $foo contains \*(Aqbar\*(Aq
\&    ok( baz($x + $y) eq \*(AqArmondo\*(Aq );    # ok if baz($x + $y) returns
\&                                        # \*(AqArmondo\*(Aq
\&    ok( @a == @b );             # ok if @a and @b are the same length
.Ve
.Sp
The expression is evaluated in scalar context.  So the following will
work:
.Sp
.Vb 3
\&    ok( @stuff );                       # ok if @stuff has any elements
\&    ok( !grep !defined $_, @stuff );    # ok if everything in @stuff is
\&                                        # defined.
.Ve
.Sp
A special case is if the expression is a subroutine reference (in either
\&\f(CW\*(C`sub {...}\*(C'\fR syntax or \f(CW\*(C`\e&foo\*(C'\fR syntax).  In
that case, it is executed and its value (true or false) determines if
the test passes or fails.  For example,
.Sp
.Vb 5
\&    ok( sub {   # See whether sleep works at least passably
\&      my $start_time = time;
\&      sleep 5;
\&      time() \- $start_time  >= 4
\&    });
.Ve
.Sp
In its two-argument form, \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR compares the two
scalar values to see if they match.  They match if both are undefined,
or if \fIarg2\fR is a regex that matches \fIarg1\fR, or if they compare equal
with \f(CW\*(C`eq\*(C'\fR.
.Sp
.Vb 1
\&    # Example of ok(scalar, scalar)
\&
\&    ok( "this", "that" );               # not ok, \*(Aqthis\*(Aq ne \*(Aqthat\*(Aq
\&    ok( "", undef );                    # not ok, "" is defined
.Ve
.Sp
The second argument is considered a regex if it is either a regex
object or a string that looks like a regex.  Regex objects are
constructed with the qr// operator in recent versions of perl.  A
string is considered to look like a regex if its first and last
characters are \*(L"/\*(R", or if the first character is \*(L"m\*(R"
and its second and last characters are both the
same non-alphanumeric non-whitespace character.  These regexp
.Sp
Regex examples:
.Sp
.Vb 4
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/Jaff/\*(Aq );    # ok, \*(AqJaffO\*(Aq =~ /Jaff/
\&    ok( \*(AqJaffO\*(Aq, \*(Aqm|Jaff|\*(Aq );   # ok, \*(AqJaffO\*(Aq =~ m|Jaff|
\&    ok( \*(AqJaffO\*(Aq, qr/Jaff/ );    # ok, \*(AqJaffO\*(Aq =~ qr/Jaff/;
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/(?i)jaff/ ); # ok, \*(AqJaffO\*(Aq =~ /jaff/i;
.Ve
.Sp
If either (or both!) is a subroutine reference, it is run and used
as the value for comparing.  For example:
.Sp
.Vb 10
\&    ok sub {
\&        open(OUT, ">x.dat") || die $!;
\&        print OUT "\ex{e000}";
\&        close OUT;
\&        my $bytecount = \-s \*(Aqx.dat\*(Aq;
\&        unlink \*(Aqx.dat\*(Aq or warn "Can\*(Aqt unlink : $!";
\&        return $bytecount;
\&      },
\&      4
\&    ;
.Ve
.Sp
The above test passes two values to \f(CW\*(C`ok(arg1, arg2)\*(C'\fR \*(-- the first 
a coderef, and the second is the number 4.  Before \f(CW\*(C`ok\*(C'\fR compares them,
it calls the coderef, and uses its return value as the real value of
this parameter. Assuming that \f(CW$bytecount\fR returns 4, \f(CW\*(C`ok\*(C'\fR ends up
testing \f(CW\*(C`4 eq 4\*(C'\fR.  Since that's true, this test passes.
.Sp
Finally, you can append an optional third argument, in
\&\f(CW\*(C`ok(\f(CIarg1\f(CW,\f(CIarg2\f(CW, \f(CInote\f(CW)\*(C'\fR, where \fInote\fR is a string value that
will be printed if the test fails.  This should be some useful
information about the test, pertaining to why it failed, and/or
a description of the test.  For example:
.Sp
.Vb 4
\&    ok( grep($_ eq \*(Aqsomething unique\*(Aq, @stuff), 1,
\&        "Something that should be unique isn\*(Aqt!\en".
\&        \*(Aq@stuff = \*(Aq.join \*(Aq, \*(Aq, @stuff
\&      );
.Ve
.Sp
Unfortunately, a note cannot be used with the single argument
style of \f(CW\*(C`ok()\*(C'\fR.  That is, if you try \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CInote\f(CW)\*(C'\fR, then
\&\f(CW\*(C`Test\*(C'\fR will interpret this as \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR, and probably
end up testing \f(CW\*(C`\f(CIarg1\f(CW eq \f(CIarg2\f(CW\*(C'\fR \*(-- and that's not what you want!
.Sp
All of the above special cases can occasionally cause some
problems.  See \*(L"\s-1BUGS\s0 and \s-1CAVEATS\*(R"\s0.
.ie n .IP """skip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)""" 4
.el .IP "\f(CWskip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)\fR" 4
.IX Item "skip(skip_if_true, args...)"
This is used for tests that under some conditions can be skipped.  It's
basically equivalent to:
.Sp
.Vb 5
\&  if( $skip_if_true ) {
\&    ok(1);
\&  } else {
\&    ok( args... );
\&  }
.Ve
.Sp
\&...except that the \f(CWok(1)\fR emits not just "\f(CW\*(C`ok \f(CItestnum\f(CW\*(C'\fR\*(L" but
actually \*(R"\f(CW\*(C`ok \f(CItestnum\f(CW # \f(CIskip_if_true_value\f(CW\*(C'\fR".
.Sp
The arguments after the \fIskip_if_true\fR are what is fed to \f(CW\*(C`ok(...)\*(C'\fR if
this test isn't skipped.
.Sp
Example usage:
.Sp
.Vb 2
\&  my $if_MSWin =
\&    $^O =~ m/MSWin/ ? \*(AqSkip if under MSWin\*(Aq : \*(Aq\*(Aq;
\&
\&  # A test to be skipped if under MSWin (i.e., run except under MSWin)
\&  skip($if_MSWin, thing($foo), thing($bar) );
.Ve
.Sp
Or, going the other way:
.Sp
.Vb 2
\&  my $unless_MSWin =
\&    $^O =~ m/MSWin/ ? \*(Aq\*(Aq : \*(AqSkip unless under MSWin\*(Aq;
\&
\&  # A test to be skipped unless under MSWin (i.e., run only under MSWin)
\&  skip($unless_MSWin, thing($foo), thing($bar) );
.Ve
.Sp
The tricky thing to remember is that the first parameter is true if
you want to \fIskip\fR the test, not \fIrun\fR it; and it also doubles as a
note about why it's being skipped. So in the first codeblock above, read
the code as "skip if MSWin \*(-- (otherwise) test whether \f(CW\*(C`thing($foo)\*(C'\fR is
\&\f(CW\*(C`thing($bar)\*(C'\fR\*(L" or for the second case, \*(R"skip unless MSWin...".
.Sp
Also, when your \fIskip_if_reason\fR string is true, it really should (for
backwards compatibility with older Test.pm versions) start with the
string \*(L"Skip\*(R", as shown in the above examples.
.Sp
Note that in the above cases, \f(CW\*(C`thing($foo)\*(C'\fR and \f(CW\*(C`thing($bar)\*(C'\fR
\&\fIare\fR evaluated \*(-- but as long as the \f(CW\*(C`skip_if_true\*(C'\fR is true,
then we \f(CW\*(C`skip(...)\*(C'\fR just tosses out their value (i.e., not
bothering to treat them like values to \f(CW\*(C`ok(...)\*(C'\fR.  But if
you need to \fInot\fR eval the arguments when skipping the
test, use
this format:
.Sp
.Vb 7
\&  skip( $unless_MSWin,
\&    sub {
\&      # This code returns true if the test passes.
\&      # (But it doesn\*(Aqt even get called if the test is skipped.)
\&      thing($foo) eq thing($bar)
\&    }
\&  );
.Ve
.Sp
or even this, which is basically equivalent:
.Sp
.Vb 3
\&  skip( $unless_MSWin,
\&    sub { thing($foo) }, sub { thing($bar) }
\&  );
.Ve
.Sp
That is, both are like this:
.Sp
.Vb 7
\&  if( $unless_MSWin ) {
\&    ok(1);  # but it actually appends "# $unless_MSWin"
\&            #  so that Test::Harness can tell it\*(Aqs a skip
\&  } else {
\&    # Not skipping, so actually call and evaluate...
\&    ok( sub { thing($foo) }, sub { thing($bar) } );
\&  }
.Ve
.SH "TEST TYPES"
.IX Header "TEST TYPES"
.IP "\(bu" 4
\&\s-1NORMAL TESTS\s0
.Sp
These tests are expected to succeed.  Usually, most or all of your tests
are in this category.  If a normal test doesn't succeed, then that
means that something is \fIwrong\fR.
.IP "\(bu" 4
\&\s-1SKIPPED TESTS\s0
.Sp
The \f(CW\*(C`skip(...)\*(C'\fR function is for tests that might or might not be
possible to run, depending
on the availability of platform-specific features.  The first argument
should evaluate to true (think \*(L"yes, please skip\*(R") if the required
feature is \fInot\fR available.  After the first argument, \f(CW\*(C`skip(...)\*(C'\fR works
exactly the same way as \f(CW\*(C`ok(...)\*(C'\fR does.
.IP "\(bu" 4
\&\s-1TODO TESTS\s0
.Sp
\&\s-1TODO\s0 tests are designed for maintaining an \fBexecutable \s-1TODO\s0 list\fR.
These tests are \fIexpected to fail.\fR  If a \s-1TODO\s0 test does succeed,
then the feature in question shouldn't be on the \s-1TODO\s0 list, now
should it?
.Sp
Packages should \s-1NOT\s0 be released with succeeding \s-1TODO\s0 tests.  As soon
as a \s-1TODO\s0 test starts working, it should be promoted to a normal test,
and the newly working feature should be documented in the release
notes or in the change log.
.SH "ONFAIL"
.IX Header "ONFAIL"
.Vb 1
\&  BEGIN { plan test => 4, onfail => sub { warn "CALL 911!" } }
.Ve
.PP
Although test failures should be enough, extra diagnostics can be
triggered at the end of a test run.  \f(CW\*(C`onfail\*(C'\fR is passed an array ref
of hash refs that describe each test failure.  Each hash will contain
at least the following fields: \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`repetition\*(C'\fR, and
\&\f(CW\*(C`result\*(C'\fR.  (You shouldn't rely on any other fields being present.)  If the test
had an expected value or a diagnostic (or \*(L"note\*(R") string, these will also be
included.
.PP
The \fIoptional\fR \f(CW\*(C`onfail\*(C'\fR hook might be used simply to print out the
version of your package and/or how to report problems.  It might also
be used to generate extremely sophisticated diagnostics for a
particularly bizarre test failure.  However it's not a panacea.  Core
dumps or other unrecoverable errors prevent the \f(CW\*(C`onfail\*(C'\fR hook from
running.  (It is run inside an \f(CW\*(C`END\*(C'\fR block.)  Besides, \f(CW\*(C`onfail\*(C'\fR is
probably over-kill in most cases.  (Your test code should be simpler
than the code it is testing, yes?)
.SH "BUGS and CAVEATS"
.IX Header "BUGS and CAVEATS"
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fR's special handing of strings which look like they might be
regexes can also cause unexpected behavior.  An innocent:
.Sp
.Vb 1
\&    ok( $fileglob, \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.Sp
will fail, since Test.pm considers the second argument to be a regex!
The best bet is to use the one-argument form:
.Sp
.Vb 1
\&    ok( $fileglob eq \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fR's use of string \f(CW\*(C`eq\*(C'\fR can sometimes cause odd problems
when comparing
numbers, especially if you're casting a string to a number:
.Sp
.Vb 2
\&    $foo = "1.0";
\&    ok( $foo, 1 );      # not ok, "1.0" ne 1
.Ve
.Sp
Your best bet is to use the single argument form:
.Sp
.Vb 1
\&    ok( $foo == 1 );    # ok "1.0" == 1
.Ve
.IP "\(bu" 4
As you may have inferred from the above documentation and examples,
\&\f(CW\*(C`ok\*(C'\fR's prototype is \f(CW\*(C`($;$$)\*(C'\fR (and, incidentally, \f(CW\*(C`skip\*(C'\fR's is
\&\f(CW\*(C`($;$$$)\*(C'\fR). This means, for example, that you can do \f(CW\*(C`ok @foo, @bar\*(C'\fR
to compare the \fIsize\fR of the two arrays. But don't be fooled into
thinking that \f(CW\*(C`ok @foo, @bar\*(C'\fR means a comparison of the contents of two
arrays \*(-- you're comparing \fIjust\fR the number of elements of each. It's
so easy to make that mistake in reading \f(CW\*(C`ok @foo, @bar\*(C'\fR that you might
want to be very explicit about it, and instead write \f(CW\*(C`ok scalar(@foo),
scalar(@bar)\*(C'\fR.
.IP "\(bu" 4
This almost definitely doesn't do what you expect:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq);
.Ve
.Sp
Why?  Because \f(CW\*(C`can\*(C'\fR returns a coderef to mean \*(L"yes it can (and the
method is this...)\*(R", and then \f(CW\*(C`ok\*(C'\fR sees a coderef and thinks you're
passing a function that you want it to call and consider the truth of
the result of!  I.e., just like:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq)\->();
.Ve
.Sp
What you probably want instead is this:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq) && 1;
.Ve
.Sp
If the \f(CW\*(C`can\*(C'\fR returns false, then that is passed to \f(CW\*(C`ok\*(C'\fR.  If it
returns true, then the larger expression \f(CW\*(C`$thingy\->can(\*(Aqsome_method\*(Aq)\ &&\ 1\*(C'\fR returns 1, which \f(CW\*(C`ok\*(C'\fR sees as
a simple signal of success, as you would expect.
.IP "\(bu" 4
The syntax for \f(CW\*(C`skip\*(C'\fR is about the only way it can be, but it's still
quite confusing.  Just start with the above examples and you'll
be okay.
.Sp
Moreover, users may expect this:
.Sp
.Vb 1
\&  skip $unless_mswin, foo($bar), baz($quux);
.Ve
.Sp
to not evaluate \f(CW\*(C`foo($bar)\*(C'\fR and \f(CW\*(C`baz($quux)\*(C'\fR when the test is being
skipped.  But in reality, they \fIare\fR evaluated, but \f(CW\*(C`skip\*(C'\fR just won't
bother comparing them if \f(CW$unless_mswin\fR is true.
.Sp
You could do this:
.Sp
.Vb 1
\&  skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};
.Ve
.Sp
But that's not terribly pretty.  You may find it simpler or clearer in
the long run to just do things like this:
.Sp
.Vb 10
\&  if( $^O =~ m/MSWin/ ) {
\&    print "# Yay, we\*(Aqre under $^O\en";
\&    ok foo($bar), baz($quux);
\&    ok thing($whatever), baz($stuff);
\&    ok blorp($quux, $whatever);
\&    ok foo($barzbarz), thang($quux);
\&  } else {
\&    print "# Feh, we\*(Aqre under $^O.  Watch me skip some tests...\en";
\&    for(1 .. 4) { skip "Skip unless under MSWin" }
\&  }
.Ve
.Sp
But be quite sure that \f(CW\*(C`ok\*(C'\fR is called exactly as many times in the
first block as \f(CW\*(C`skip\*(C'\fR is called in the second block.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR environment variable is set, it will be used as a
command for comparing unexpected multiline results.  If you have \s-1GNU\s0
diff installed, you might want to set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR to \f(CW\*(C`diff \-u\*(C'\fR.
If you don't have a suitable program, you might install the
\&\f(CW\*(C`Text::Diff\*(C'\fR module and then set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR to be \f(CW\*(C`perl
\&\-MText::Diff \-e \*(Aqprint diff(@ARGV)\*(Aq\*(C'\fR.  If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR isn't set
but the \f(CW\*(C`Algorithm::Diff\*(C'\fR module is available, then it will be used
to show the differences in multiline results.
.SH "NOTE"
.IX Header "NOTE"
A past developer of this module once said that it was no longer being
actively developed.  However, rumors of its demise were greatly
exaggerated.  Feedback and suggestions are quite welcome.
.PP
Be aware that the main value of this module is its simplicity.  Note
that there are already more ambitious modules out there, such as
Test::More and Test::Unit.
.PP
Some earlier versions of this module had docs with some confusing
typos in the description of \f(CW\*(C`skip(...)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness
.PP
Test::Simple, Test::More, Devel::Cover
.PP
Test::Builder for building your own testing library.
.PP
Test::Unit is an interesting XUnit-style testing library.
.PP
Test::Inline and SelfTest let you embed tests in code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 1998\-2000 Joshua Nathaniel Pritikin.
.PP
Copyright (c) 2001\-2002 Michael G. Schwern.
.PP
Copyright (c) 2002\-2004 Sean M. Burke.
.PP
Current maintainer: Jesse Vincent. <jesse@bestpractical.com>
.PP
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty.  It may be used, redistributed and/or modified
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test5.16.3pm                                 0100644 0001750 0001750 00000055554 12566207441 022547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test 3pm"
.TH Test 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test \- provides a simple framework for writing test scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use strict;
\&  use Test;
\&
\&  # use a BEGIN block so we print our plan before MyModule is loaded
\&  BEGIN { plan tests => 14, todo => [3,4] }
\&
\&  # load your module...
\&  use MyModule;
\&
\&  # Helpful notes.  All note\-lines must start with a "#".
\&  print "# I\*(Aqm testing MyModule version $MyModule::VERSION\en";
\&
\&  ok(0); # failure
\&  ok(1); # success
\&
\&  ok(0); # ok, expected failure (see todo list, above)
\&  ok(1); # surprise success!
\&
\&  ok(0,1);             # failure: \*(Aq0\*(Aq ne \*(Aq1\*(Aq
\&  ok(\*(Aqbroke\*(Aq,\*(Aqfixed\*(Aq); # failure: \*(Aqbroke\*(Aq ne \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,\*(Aqfixed\*(Aq); # success: \*(Aqfixed\*(Aq eq \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,qr/x/);   # success: \*(Aqfixed\*(Aq =~ qr/x/
\&
\&  ok(sub { 1+1 }, 2);  # success: \*(Aq2\*(Aq eq \*(Aq2\*(Aq
\&  ok(sub { 1+1 }, 3);  # failure: \*(Aq2\*(Aq ne \*(Aq3\*(Aq
\&
\&  my @list = (0,0);
\&  ok @list, 3, "\e@list=".join(\*(Aq,\*(Aq,@list);      #extra notes
\&  ok \*(Aqsegmentation fault\*(Aq, \*(Aq/(?i)success/\*(Aq;    #regex match
\&
\&  skip(
\&    $^O =~ m/MSWin/ ? "Skip if MSWin" : 0,  # whether to skip
\&    $foo, $bar  # arguments just like for ok(...)
\&  );
\&  skip(
\&    $^O =~ m/MSWin/ ? 0 : "Skip unless MSWin",  # whether to skip
\&    $foo, $bar  # arguments just like for ok(...)
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module simplifies the task of writing test files for Perl modules,
such that their output is in the format that
Test::Harness expects to see.
.SH "QUICK START GUIDE"
.IX Header "QUICK START GUIDE"
To write a test for your new (and probably not even done) module, create
a new file called \fIt/test.t\fR (in a new \fIt\fR directory). If you have
multiple test files, to test the \*(L"foo\*(R", \*(L"bar\*(R", and \*(L"baz\*(R" feature sets,
then feel free to call your files \fIt/foo.t\fR, \fIt/bar.t\fR, and
\&\fIt/baz.t\fR
.SS "Functions"
.IX Subsection "Functions"
This module defines three public functions, \f(CW\*(C`plan(...)\*(C'\fR, \f(CW\*(C`ok(...)\*(C'\fR,
and \f(CW\*(C`skip(...)\*(C'\fR.  By default, all three are exported by
the \f(CW\*(C`use Test;\*(C'\fR statement.
.ie n .IP """plan(...)""" 4
.el .IP "\f(CWplan(...)\fR" 4
.IX Item "plan(...)"
.Vb 1
\&     BEGIN { plan %theplan; }
.Ve
.Sp
This should be the first thing you call in your test script.  It
declares your testing plan, how many there will be, if any of them
should be allowed to fail, and so on.
.Sp
Typical usage is just:
.Sp
.Vb 2
\&     use Test;
\&     BEGIN { plan tests => 23 }
.Ve
.Sp
These are the things that you can put in the parameters to plan:
.RS 4
.ie n .IP """tests => \f(CInumber\f(CW""" 4
.el .IP "\f(CWtests => \f(CInumber\f(CW\fR" 4
.IX Item "tests => number"
The number of tests in your script.
This means all \fIok()\fR and \fIskip()\fR calls.
.ie n .IP """todo => [\f(CI1,5,14\f(CW]""" 4
.el .IP "\f(CWtodo => [\f(CI1,5,14\f(CW]\fR" 4
.IX Item "todo => [1,5,14]"
A reference to a list of tests which are allowed to fail.
See \*(L"\s-1TODO\s0 \s-1TESTS\s0\*(R".
.ie n .IP """onfail => sub { ... }""" 4
.el .IP "\f(CWonfail => sub { ... }\fR" 4
.IX Item "onfail => sub { ... }"
.PD 0
.ie n .IP """onfail => \e&some_sub""" 4
.el .IP "\f(CWonfail => \e&some_sub\fR" 4
.IX Item "onfail => &some_sub"
.PD
A subroutine reference to be run at the end of the test script, if
any of the tests fail.  See \*(L"\s-1ONFAIL\s0\*(R".
.RE
.RS 4
.Sp
You must call \f(CW\*(C`plan(...)\*(C'\fR once and only once.  You should call it
in a \f(CW\*(C`BEGIN {...}\*(C'\fR block, like so:
.Sp
.Vb 1
\&     BEGIN { plan tests => 23 }
.Ve
.RE
.ie n .IP """ok(...)""" 4
.el .IP "\f(CWok(...)\fR" 4
.IX Item "ok(...)"
.Vb 3
\&  ok(1 + 1 == 2);
\&  ok($have, $expect);
\&  ok($have, $expect, $diagnostics);
.Ve
.Sp
This function is the reason for \f(CW\*(C`Test\*(C'\fR's existence.  It's
the basic function that
handles printing "\f(CW\*(C`ok\*(C'\fR\*(L" or \*(R"\f(CW\*(C`not ok\*(C'\fR", along with the
current test number.  (That's what \f(CW\*(C`Test::Harness\*(C'\fR wants to see.)
.Sp
In its most basic usage, \f(CW\*(C`ok(...)\*(C'\fR simply takes a single scalar
expression.  If its value is true, the test passes; if false,
the test fails.  Examples:
.Sp
.Vb 1
\&    # Examples of ok(scalar)
\&
\&    ok( 1 + 1 == 2 );           # ok if 1 + 1 == 2
\&    ok( $foo =~ /bar/ );        # ok if $foo contains \*(Aqbar\*(Aq
\&    ok( baz($x + $y) eq \*(AqArmondo\*(Aq );    # ok if baz($x + $y) returns
\&                                        # \*(AqArmondo\*(Aq
\&    ok( @a == @b );             # ok if @a and @b are the same length
.Ve
.Sp
The expression is evaluated in scalar context.  So the following will
work:
.Sp
.Vb 3
\&    ok( @stuff );                       # ok if @stuff has any elements
\&    ok( !grep !defined $_, @stuff );    # ok if everything in @stuff is
\&                                        # defined.
.Ve
.Sp
A special case is if the expression is a subroutine reference (in either
\&\f(CW\*(C`sub {...}\*(C'\fR syntax or \f(CW\*(C`\e&foo\*(C'\fR syntax).  In
that case, it is executed and its value (true or false) determines if
the test passes or fails.  For example,
.Sp
.Vb 5
\&    ok( sub {   # See whether sleep works at least passably
\&      my $start_time = time;
\&      sleep 5;
\&      time() \- $start_time  >= 4
\&    });
.Ve
.Sp
In its two-argument form, \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR compares the two
scalar values to see if they match.  They match if both are undefined,
or if \fIarg2\fR is a regex that matches \fIarg1\fR, or if they compare equal
with \f(CW\*(C`eq\*(C'\fR.
.Sp
.Vb 1
\&    # Example of ok(scalar, scalar)
\&
\&    ok( "this", "that" );               # not ok, \*(Aqthis\*(Aq ne \*(Aqthat\*(Aq
\&    ok( "", undef );                    # not ok, "" is defined
.Ve
.Sp
The second argument is considered a regex if it is either a regex
object or a string that looks like a regex.  Regex objects are
constructed with the qr// operator in recent versions of perl.  A
string is considered to look like a regex if its first and last
characters are \*(L"/\*(R", or if the first character is \*(L"m\*(R"
and its second and last characters are both the
same non-alphanumeric non-whitespace character.  These regexp
.Sp
Regex examples:
.Sp
.Vb 4
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/Jaff/\*(Aq );    # ok, \*(AqJaffO\*(Aq =~ /Jaff/
\&    ok( \*(AqJaffO\*(Aq, \*(Aqm|Jaff|\*(Aq );   # ok, \*(AqJaffO\*(Aq =~ m|Jaff|
\&    ok( \*(AqJaffO\*(Aq, qr/Jaff/ );    # ok, \*(AqJaffO\*(Aq =~ qr/Jaff/;
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/(?i)jaff/ ); # ok, \*(AqJaffO\*(Aq =~ /jaff/i;
.Ve
.Sp
If either (or both!) is a subroutine reference, it is run and used
as the value for comparing.  For example:
.Sp
.Vb 10
\&    ok sub {
\&        open(OUT, ">x.dat") || die $!;
\&        print OUT "\ex{e000}";
\&        close OUT;
\&        my $bytecount = \-s \*(Aqx.dat\*(Aq;
\&        unlink \*(Aqx.dat\*(Aq or warn "Can\*(Aqt unlink : $!";
\&        return $bytecount;
\&      },
\&      4
\&    ;
.Ve
.Sp
The above test passes two values to \f(CW\*(C`ok(arg1, arg2)\*(C'\fR \*(-- the first 
a coderef, and the second is the number 4.  Before \f(CW\*(C`ok\*(C'\fR compares them,
it calls the coderef, and uses its return value as the real value of
this parameter. Assuming that \f(CW$bytecount\fR returns 4, \f(CW\*(C`ok\*(C'\fR ends up
testing \f(CW\*(C`4 eq 4\*(C'\fR.  Since that's true, this test passes.
.Sp
Finally, you can append an optional third argument, in
\&\f(CW\*(C`ok(\f(CIarg1\f(CW,\f(CIarg2\f(CW, \f(CInote\f(CW)\*(C'\fR, where \fInote\fR is a string value that
will be printed if the test fails.  This should be some useful
information about the test, pertaining to why it failed, and/or
a description of the test.  For example:
.Sp
.Vb 4
\&    ok( grep($_ eq \*(Aqsomething unique\*(Aq, @stuff), 1,
\&        "Something that should be unique isn\*(Aqt!\en".
\&        \*(Aq@stuff = \*(Aq.join \*(Aq, \*(Aq, @stuff
\&      );
.Ve
.Sp
Unfortunately, a note cannot be used with the single argument
style of \f(CW\*(C`ok()\*(C'\fR.  That is, if you try \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CInote\f(CW)\*(C'\fR, then
\&\f(CW\*(C`Test\*(C'\fR will interpret this as \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR, and probably
end up testing \f(CW\*(C`\f(CIarg1\f(CW eq \f(CIarg2\f(CW\*(C'\fR \*(-- and that's not what you want!
.Sp
All of the above special cases can occasionally cause some
problems.  See \*(L"\s-1BUGS\s0 and \s-1CAVEATS\s0\*(R".
.ie n .IP """skip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)""" 4
.el .IP "\f(CWskip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)\fR" 4
.IX Item "skip(skip_if_true, args...)"
This is used for tests that under some conditions can be skipped.  It's
basically equivalent to:
.Sp
.Vb 5
\&  if( $skip_if_true ) {
\&    ok(1);
\&  } else {
\&    ok( args... );
\&  }
.Ve
.Sp
\&...except that the \f(CWok(1)\fR emits not just "\f(CW\*(C`ok \f(CItestnum\f(CW\*(C'\fR\*(L" but
actually \*(R"\f(CW\*(C`ok \f(CItestnum\f(CW # \f(CIskip_if_true_value\f(CW\*(C'\fR".
.Sp
The arguments after the \fIskip_if_true\fR are what is fed to \f(CW\*(C`ok(...)\*(C'\fR if
this test isn't skipped.
.Sp
Example usage:
.Sp
.Vb 2
\&  my $if_MSWin =
\&    $^O =~ m/MSWin/ ? \*(AqSkip if under MSWin\*(Aq : \*(Aq\*(Aq;
\&
\&  # A test to be skipped if under MSWin (i.e., run except under MSWin)
\&  skip($if_MSWin, thing($foo), thing($bar) );
.Ve
.Sp
Or, going the other way:
.Sp
.Vb 2
\&  my $unless_MSWin =
\&    $^O =~ m/MSWin/ ? \*(Aq\*(Aq : \*(AqSkip unless under MSWin\*(Aq;
\&
\&  # A test to be skipped unless under MSWin (i.e., run only under MSWin)
\&  skip($unless_MSWin, thing($foo), thing($bar) );
.Ve
.Sp
The tricky thing to remember is that the first parameter is true if
you want to \fIskip\fR the test, not \fIrun\fR it; and it also doubles as a
note about why it's being skipped. So in the first codeblock above, read
the code as "skip if MSWin \*(-- (otherwise) test whether \f(CW\*(C`thing($foo)\*(C'\fR is
\&\f(CW\*(C`thing($bar)\*(C'\fR\*(L" or for the second case, \*(R"skip unless MSWin...".
.Sp
Also, when your \fIskip_if_reason\fR string is true, it really should (for
backwards compatibility with older Test.pm versions) start with the
string \*(L"Skip\*(R", as shown in the above examples.
.Sp
Note that in the above cases, \f(CW\*(C`thing($foo)\*(C'\fR and \f(CW\*(C`thing($bar)\*(C'\fR
\&\fIare\fR evaluated \*(-- but as long as the \f(CW\*(C`skip_if_true\*(C'\fR is true,
then we \f(CW\*(C`skip(...)\*(C'\fR just tosses out their value (i.e., not
bothering to treat them like values to \f(CW\*(C`ok(...)\*(C'\fR.  But if
you need to \fInot\fR eval the arguments when skipping the
test, use
this format:
.Sp
.Vb 7
\&  skip( $unless_MSWin,
\&    sub {
\&      # This code returns true if the test passes.
\&      # (But it doesn\*(Aqt even get called if the test is skipped.)
\&      thing($foo) eq thing($bar)
\&    }
\&  );
.Ve
.Sp
or even this, which is basically equivalent:
.Sp
.Vb 3
\&  skip( $unless_MSWin,
\&    sub { thing($foo) }, sub { thing($bar) }
\&  );
.Ve
.Sp
That is, both are like this:
.Sp
.Vb 7
\&  if( $unless_MSWin ) {
\&    ok(1);  # but it actually appends "# $unless_MSWin"
\&            #  so that Test::Harness can tell it\*(Aqs a skip
\&  } else {
\&    # Not skipping, so actually call and evaluate...
\&    ok( sub { thing($foo) }, sub { thing($bar) } );
\&  }
.Ve
.SH "TEST TYPES"
.IX Header "TEST TYPES"
.IP "\(bu" 4
\&\s-1NORMAL\s0 \s-1TESTS\s0
.Sp
These tests are expected to succeed.  Usually, most or all of your tests
are in this category.  If a normal test doesn't succeed, then that
means that something is \fIwrong\fR.
.IP "\(bu" 4
\&\s-1SKIPPED\s0 \s-1TESTS\s0
.Sp
The \f(CW\*(C`skip(...)\*(C'\fR function is for tests that might or might not be
possible to run, depending
on the availability of platform-specific features.  The first argument
should evaluate to true (think \*(L"yes, please skip\*(R") if the required
feature is \fInot\fR available.  After the first argument, \f(CW\*(C`skip(...)\*(C'\fR works
exactly the same way as \f(CW\*(C`ok(...)\*(C'\fR does.
.IP "\(bu" 4
\&\s-1TODO\s0 \s-1TESTS\s0
.Sp
\&\s-1TODO\s0 tests are designed for maintaining an \fBexecutable \s-1TODO\s0 list\fR.
These tests are \fIexpected to fail.\fR  If a \s-1TODO\s0 test does succeed,
then the feature in question shouldn't be on the \s-1TODO\s0 list, now
should it?
.Sp
Packages should \s-1NOT\s0 be released with succeeding \s-1TODO\s0 tests.  As soon
as a \s-1TODO\s0 test starts working, it should be promoted to a normal test,
and the newly working feature should be documented in the release
notes or in the change log.
.SH "ONFAIL"
.IX Header "ONFAIL"
.Vb 1
\&  BEGIN { plan test => 4, onfail => sub { warn "CALL 911!" } }
.Ve
.PP
Although test failures should be enough, extra diagnostics can be
triggered at the end of a test run.  \f(CW\*(C`onfail\*(C'\fR is passed an array ref
of hash refs that describe each test failure.  Each hash will contain
at least the following fields: \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`repetition\*(C'\fR, and
\&\f(CW\*(C`result\*(C'\fR.  (You shouldn't rely on any other fields being present.)  If the test
had an expected value or a diagnostic (or \*(L"note\*(R") string, these will also be
included.
.PP
The \fIoptional\fR \f(CW\*(C`onfail\*(C'\fR hook might be used simply to print out the
version of your package and/or how to report problems.  It might also
be used to generate extremely sophisticated diagnostics for a
particularly bizarre test failure.  However it's not a panacea.  Core
dumps or other unrecoverable errors prevent the \f(CW\*(C`onfail\*(C'\fR hook from
running.  (It is run inside an \f(CW\*(C`END\*(C'\fR block.)  Besides, \f(CW\*(C`onfail\*(C'\fR is
probably over-kill in most cases.  (Your test code should be simpler
than the code it is testing, yes?)
.SH "BUGS and CAVEATS"
.IX Header "BUGS and CAVEATS"
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fR's special handing of strings which look like they might be
regexes can also cause unexpected behavior.  An innocent:
.Sp
.Vb 1
\&    ok( $fileglob, \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.Sp
will fail, since Test.pm considers the second argument to be a regex!
The best bet is to use the one-argument form:
.Sp
.Vb 1
\&    ok( $fileglob eq \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fR's use of string \f(CW\*(C`eq\*(C'\fR can sometimes cause odd problems
when comparing
numbers, especially if you're casting a string to a number:
.Sp
.Vb 2
\&    $foo = "1.0";
\&    ok( $foo, 1 );      # not ok, "1.0" ne 1
.Ve
.Sp
Your best bet is to use the single argument form:
.Sp
.Vb 1
\&    ok( $foo == 1 );    # ok "1.0" == 1
.Ve
.IP "\(bu" 4
As you may have inferred from the above documentation and examples,
\&\f(CW\*(C`ok\*(C'\fR's prototype is \f(CW\*(C`($;$$)\*(C'\fR (and, incidentally, \f(CW\*(C`skip\*(C'\fR's is
\&\f(CW\*(C`($;$$$)\*(C'\fR). This means, for example, that you can do \f(CW\*(C`ok @foo, @bar\*(C'\fR
to compare the \fIsize\fR of the two arrays. But don't be fooled into
thinking that \f(CW\*(C`ok @foo, @bar\*(C'\fR means a comparison of the contents of two
arrays \*(-- you're comparing \fIjust\fR the number of elements of each. It's
so easy to make that mistake in reading \f(CW\*(C`ok @foo, @bar\*(C'\fR that you might
want to be very explicit about it, and instead write \f(CW\*(C`ok scalar(@foo),
scalar(@bar)\*(C'\fR.
.IP "\(bu" 4
This almost definitely doesn't do what you expect:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq);
.Ve
.Sp
Why?  Because \f(CW\*(C`can\*(C'\fR returns a coderef to mean \*(L"yes it can (and the
method is this...)\*(R", and then \f(CW\*(C`ok\*(C'\fR sees a coderef and thinks you're
passing a function that you want it to call and consider the truth of
the result of!  I.e., just like:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq)\->();
.Ve
.Sp
What you probably want instead is this:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq) && 1;
.Ve
.Sp
If the \f(CW\*(C`can\*(C'\fR returns false, then that is passed to \f(CW\*(C`ok\*(C'\fR.  If it
returns true, then the larger expression \f(CW\*(C`$thingy\->can(\*(Aqsome_method\*(Aq)\ &&\ 1\*(C'\fR returns 1, which \f(CW\*(C`ok\*(C'\fR sees as
a simple signal of success, as you would expect.
.IP "\(bu" 4
The syntax for \f(CW\*(C`skip\*(C'\fR is about the only way it can be, but it's still
quite confusing.  Just start with the above examples and you'll
be okay.
.Sp
Moreover, users may expect this:
.Sp
.Vb 1
\&  skip $unless_mswin, foo($bar), baz($quux);
.Ve
.Sp
to not evaluate \f(CW\*(C`foo($bar)\*(C'\fR and \f(CW\*(C`baz($quux)\*(C'\fR when the test is being
skipped.  But in reality, they \fIare\fR evaluated, but \f(CW\*(C`skip\*(C'\fR just won't
bother comparing them if \f(CW$unless_mswin\fR is true.
.Sp
You could do this:
.Sp
.Vb 1
\&  skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};
.Ve
.Sp
But that's not terribly pretty.  You may find it simpler or clearer in
the long run to just do things like this:
.Sp
.Vb 10
\&  if( $^O =~ m/MSWin/ ) {
\&    print "# Yay, we\*(Aqre under $^O\en";
\&    ok foo($bar), baz($quux);
\&    ok thing($whatever), baz($stuff);
\&    ok blorp($quux, $whatever);
\&    ok foo($barzbarz), thang($quux);
\&  } else {
\&    print "# Feh, we\*(Aqre under $^O.  Watch me skip some tests...\en";
\&    for(1 .. 4) { skip "Skip unless under MSWin" }
\&  }
.Ve
.Sp
But be quite sure that \f(CW\*(C`ok\*(C'\fR is called exactly as many times in the
first block as \f(CW\*(C`skip\*(C'\fR is called in the second block.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR environment variable is set, it will be used as a
command for comparing unexpected multiline results.  If you have \s-1GNU\s0
diff installed, you might want to set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR to \f(CW\*(C`diff \-u\*(C'\fR.
If you don't have a suitable program, you might install the
\&\f(CW\*(C`Text::Diff\*(C'\fR module and then set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR to be \f(CW\*(C`perl
\&\-MText::Diff \-e \*(Aqprint diff(@ARGV)\*(Aq\*(C'\fR.  If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR isn't set
but the \f(CW\*(C`Algorithm::Diff\*(C'\fR module is available, then it will be used
to show the differences in multiline results.
.SH "NOTE"
.IX Header "NOTE"
A past developer of this module once said that it was no longer being
actively developed.  However, rumors of its demise were greatly
exaggerated.  Feedback and suggestions are quite welcome.
.PP
Be aware that the main value of this module is its simplicity.  Note
that there are already more ambitious modules out there, such as
Test::More and Test::Unit.
.PP
Some earlier versions of this module had docs with some confusing
typos in the description of \f(CW\*(C`skip(...)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness
.PP
Test::Simple, Test::More, Devel::Cover
.PP
Test::Builder for building your own testing library.
.PP
Test::Unit is an interesting XUnit-style testing library.
.PP
Test::Inline and SelfTest let you embed tests in code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 1998\-2000 Joshua Nathaniel Pritikin.
.PP
Copyright (c) 2001\-2002 Michael G. Schwern.
.PP
Copyright (c) 2002\-2004 Sean M. Burke.
.PP
Current maintainer: Jesse Vincent. <jesse@bestpractical.com>
.PP
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty.  It may be used, redistributed and/or modified
under the same terms as Perl itself.
                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test5.18.3pm                                 0100644 0001750 0001750 00000056041 12566207463 022545  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test 3pm"
.TH Test 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test \- provides a simple framework for writing test scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use strict;
\&  use Test;
\&
\&  # use a BEGIN block so we print our plan before MyModule is loaded
\&  BEGIN { plan tests => 14, todo => [3,4] }
\&
\&  # load your module...
\&  use MyModule;
\&
\&  # Helpful notes.  All note\-lines must start with a "#".
\&  print "# I\*(Aqm testing MyModule version $MyModule::VERSION\en";
\&
\&  ok(0); # failure
\&  ok(1); # success
\&
\&  ok(0); # ok, expected failure (see todo list, above)
\&  ok(1); # surprise success!
\&
\&  ok(0,1);             # failure: \*(Aq0\*(Aq ne \*(Aq1\*(Aq
\&  ok(\*(Aqbroke\*(Aq,\*(Aqfixed\*(Aq); # failure: \*(Aqbroke\*(Aq ne \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,\*(Aqfixed\*(Aq); # success: \*(Aqfixed\*(Aq eq \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,qr/x/);   # success: \*(Aqfixed\*(Aq =~ qr/x/
\&
\&  ok(sub { 1+1 }, 2);  # success: \*(Aq2\*(Aq eq \*(Aq2\*(Aq
\&  ok(sub { 1+1 }, 3);  # failure: \*(Aq2\*(Aq ne \*(Aq3\*(Aq
\&
\&  my @list = (0,0);
\&  ok @list, 3, "\e@list=".join(\*(Aq,\*(Aq,@list);      #extra notes
\&  ok \*(Aqsegmentation fault\*(Aq, \*(Aq/(?i)success/\*(Aq;    #regex match
\&
\&  skip(
\&    $^O =~ m/MSWin/ ? "Skip if MSWin" : 0,  # whether to skip
\&    $foo, $bar  # arguments just like for ok(...)
\&  );
\&  skip(
\&    $^O =~ m/MSWin/ ? 0 : "Skip unless MSWin",  # whether to skip
\&    $foo, $bar  # arguments just like for ok(...)
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module simplifies the task of writing test files for Perl modules,
such that their output is in the format that
Test::Harness expects to see.
.SH "QUICK START GUIDE"
.IX Header "QUICK START GUIDE"
To write a test for your new (and probably not even done) module, create
a new file called \fIt/test.t\fR (in a new \fIt\fR directory). If you have
multiple test files, to test the \*(L"foo\*(R", \*(L"bar\*(R", and \*(L"baz\*(R" feature sets,
then feel free to call your files \fIt/foo.t\fR, \fIt/bar.t\fR, and
\&\fIt/baz.t\fR
.SS "Functions"
.IX Subsection "Functions"
This module defines three public functions, \f(CW\*(C`plan(...)\*(C'\fR, \f(CW\*(C`ok(...)\*(C'\fR,
and \f(CW\*(C`skip(...)\*(C'\fR.  By default, all three are exported by
the \f(CW\*(C`use Test;\*(C'\fR statement.
.ie n .IP """plan(...)""" 4
.el .IP "\f(CWplan(...)\fR" 4
.IX Item "plan(...)"
.Vb 1
\&     BEGIN { plan %theplan; }
.Ve
.Sp
This should be the first thing you call in your test script.  It
declares your testing plan, how many there will be, if any of them
should be allowed to fail, and so on.
.Sp
Typical usage is just:
.Sp
.Vb 2
\&     use Test;
\&     BEGIN { plan tests => 23 }
.Ve
.Sp
These are the things that you can put in the parameters to plan:
.RS 4
.ie n .IP """tests => \f(CInumber\f(CW""" 4
.el .IP "\f(CWtests => \f(CInumber\f(CW\fR" 4
.IX Item "tests => number"
The number of tests in your script.
This means all \fIok()\fR and \fIskip()\fR calls.
.ie n .IP """todo => [\f(CI1,5,14\f(CW]""" 4
.el .IP "\f(CWtodo => [\f(CI1,5,14\f(CW]\fR" 4
.IX Item "todo => [1,5,14]"
A reference to a list of tests which are allowed to fail.
See \*(L"\s-1TODO TESTS\*(R"\s0.
.ie n .IP """onfail => sub { ... }""" 4
.el .IP "\f(CWonfail => sub { ... }\fR" 4
.IX Item "onfail => sub { ... }"
.PD 0
.ie n .IP """onfail => \e&some_sub""" 4
.el .IP "\f(CWonfail => \e&some_sub\fR" 4
.IX Item "onfail => &some_sub"
.PD
A subroutine reference to be run at the end of the test script, if
any of the tests fail.  See \*(L"\s-1ONFAIL\*(R"\s0.
.RE
.RS 4
.Sp
You must call \f(CW\*(C`plan(...)\*(C'\fR once and only once.  You should call it
in a \f(CW\*(C`BEGIN {...}\*(C'\fR block, like so:
.Sp
.Vb 1
\&     BEGIN { plan tests => 23 }
.Ve
.RE
.ie n .IP """ok(...)""" 4
.el .IP "\f(CWok(...)\fR" 4
.IX Item "ok(...)"
.Vb 3
\&  ok(1 + 1 == 2);
\&  ok($have, $expect);
\&  ok($have, $expect, $diagnostics);
.Ve
.Sp
This function is the reason for \f(CW\*(C`Test\*(C'\fR's existence.  It's
the basic function that
handles printing "\f(CW\*(C`ok\*(C'\fR\*(L" or \*(R"\f(CW\*(C`not ok\*(C'\fR", along with the
current test number.  (That's what \f(CW\*(C`Test::Harness\*(C'\fR wants to see.)
.Sp
In its most basic usage, \f(CW\*(C`ok(...)\*(C'\fR simply takes a single scalar
expression.  If its value is true, the test passes; if false,
the test fails.  Examples:
.Sp
.Vb 1
\&    # Examples of ok(scalar)
\&
\&    ok( 1 + 1 == 2 );           # ok if 1 + 1 == 2
\&    ok( $foo =~ /bar/ );        # ok if $foo contains \*(Aqbar\*(Aq
\&    ok( baz($x + $y) eq \*(AqArmondo\*(Aq );    # ok if baz($x + $y) returns
\&                                        # \*(AqArmondo\*(Aq
\&    ok( @a == @b );             # ok if @a and @b are the same length
.Ve
.Sp
The expression is evaluated in scalar context.  So the following will
work:
.Sp
.Vb 3
\&    ok( @stuff );                       # ok if @stuff has any elements
\&    ok( !grep !defined $_, @stuff );    # ok if everything in @stuff is
\&                                        # defined.
.Ve
.Sp
A special case is if the expression is a subroutine reference (in either
\&\f(CW\*(C`sub {...}\*(C'\fR syntax or \f(CW\*(C`\e&foo\*(C'\fR syntax).  In
that case, it is executed and its value (true or false) determines if
the test passes or fails.  For example,
.Sp
.Vb 5
\&    ok( sub {   # See whether sleep works at least passably
\&      my $start_time = time;
\&      sleep 5;
\&      time() \- $start_time  >= 4
\&    });
.Ve
.Sp
In its two-argument form, \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR compares the two
scalar values to see if they match.  They match if both are undefined,
or if \fIarg2\fR is a regex that matches \fIarg1\fR, or if they compare equal
with \f(CW\*(C`eq\*(C'\fR.
.Sp
.Vb 1
\&    # Example of ok(scalar, scalar)
\&
\&    ok( "this", "that" );               # not ok, \*(Aqthis\*(Aq ne \*(Aqthat\*(Aq
\&    ok( "", undef );                    # not ok, "" is defined
.Ve
.Sp
The second argument is considered a regex if it is either a regex
object or a string that looks like a regex.  Regex objects are
constructed with the qr// operator in recent versions of perl.  A
string is considered to look like a regex if its first and last
characters are \*(L"/\*(R", or if the first character is \*(L"m\*(R"
and its second and last characters are both the
same non-alphanumeric non-whitespace character.  These regexp
.Sp
Regex examples:
.Sp
.Vb 4
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/Jaff/\*(Aq );    # ok, \*(AqJaffO\*(Aq =~ /Jaff/
\&    ok( \*(AqJaffO\*(Aq, \*(Aqm|Jaff|\*(Aq );   # ok, \*(AqJaffO\*(Aq =~ m|Jaff|
\&    ok( \*(AqJaffO\*(Aq, qr/Jaff/ );    # ok, \*(AqJaffO\*(Aq =~ qr/Jaff/;
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/(?i)jaff/ ); # ok, \*(AqJaffO\*(Aq =~ /jaff/i;
.Ve
.Sp
If either (or both!) is a subroutine reference, it is run and used
as the value for comparing.  For example:
.Sp
.Vb 10
\&    ok sub {
\&        open(OUT, ">x.dat") || die $!;
\&        print OUT "\ex{e000}";
\&        close OUT;
\&        my $bytecount = \-s \*(Aqx.dat\*(Aq;
\&        unlink \*(Aqx.dat\*(Aq or warn "Can\*(Aqt unlink : $!";
\&        return $bytecount;
\&      },
\&      4
\&    ;
.Ve
.Sp
The above test passes two values to \f(CW\*(C`ok(arg1, arg2)\*(C'\fR \*(-- the first 
a coderef, and the second is the number 4.  Before \f(CW\*(C`ok\*(C'\fR compares them,
it calls the coderef, and uses its return value as the real value of
this parameter. Assuming that \f(CW$bytecount\fR returns 4, \f(CW\*(C`ok\*(C'\fR ends up
testing \f(CW\*(C`4 eq 4\*(C'\fR.  Since that's true, this test passes.
.Sp
Finally, you can append an optional third argument, in
\&\f(CW\*(C`ok(\f(CIarg1\f(CW,\f(CIarg2\f(CW, \f(CInote\f(CW)\*(C'\fR, where \fInote\fR is a string value that
will be printed if the test fails.  This should be some useful
information about the test, pertaining to why it failed, and/or
a description of the test.  For example:
.Sp
.Vb 4
\&    ok( grep($_ eq \*(Aqsomething unique\*(Aq, @stuff), 1,
\&        "Something that should be unique isn\*(Aqt!\en".
\&        \*(Aq@stuff = \*(Aq.join \*(Aq, \*(Aq, @stuff
\&      );
.Ve
.Sp
Unfortunately, a note cannot be used with the single argument
style of \f(CW\*(C`ok()\*(C'\fR.  That is, if you try \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CInote\f(CW)\*(C'\fR, then
\&\f(CW\*(C`Test\*(C'\fR will interpret this as \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR, and probably
end up testing \f(CW\*(C`\f(CIarg1\f(CW eq \f(CIarg2\f(CW\*(C'\fR \*(-- and that's not what you want!
.Sp
All of the above special cases can occasionally cause some
problems.  See \*(L"\s-1BUGS\s0 and \s-1CAVEATS\*(R"\s0.
.ie n .IP """skip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)""" 4
.el .IP "\f(CWskip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)\fR" 4
.IX Item "skip(skip_if_true, args...)"
This is used for tests that under some conditions can be skipped.  It's
basically equivalent to:
.Sp
.Vb 5
\&  if( $skip_if_true ) {
\&    ok(1);
\&  } else {
\&    ok( args... );
\&  }
.Ve
.Sp
\&...except that the \f(CWok(1)\fR emits not just "\f(CW\*(C`ok \f(CItestnum\f(CW\*(C'\fR\*(L" but
actually \*(R"\f(CW\*(C`ok \f(CItestnum\f(CW # \f(CIskip_if_true_value\f(CW\*(C'\fR".
.Sp
The arguments after the \fIskip_if_true\fR are what is fed to \f(CW\*(C`ok(...)\*(C'\fR if
this test isn't skipped.
.Sp
Example usage:
.Sp
.Vb 2
\&  my $if_MSWin =
\&    $^O =~ m/MSWin/ ? \*(AqSkip if under MSWin\*(Aq : \*(Aq\*(Aq;
\&
\&  # A test to be skipped if under MSWin (i.e., run except under MSWin)
\&  skip($if_MSWin, thing($foo), thing($bar) );
.Ve
.Sp
Or, going the other way:
.Sp
.Vb 2
\&  my $unless_MSWin =
\&    $^O =~ m/MSWin/ ? \*(Aq\*(Aq : \*(AqSkip unless under MSWin\*(Aq;
\&
\&  # A test to be skipped unless under MSWin (i.e., run only under MSWin)
\&  skip($unless_MSWin, thing($foo), thing($bar) );
.Ve
.Sp
The tricky thing to remember is that the first parameter is true if
you want to \fIskip\fR the test, not \fIrun\fR it; and it also doubles as a
note about why it's being skipped. So in the first codeblock above, read
the code as "skip if MSWin \*(-- (otherwise) test whether \f(CW\*(C`thing($foo)\*(C'\fR is
\&\f(CW\*(C`thing($bar)\*(C'\fR\*(L" or for the second case, \*(R"skip unless MSWin...".
.Sp
Also, when your \fIskip_if_reason\fR string is true, it really should (for
backwards compatibility with older Test.pm versions) start with the
string \*(L"Skip\*(R", as shown in the above examples.
.Sp
Note that in the above cases, \f(CW\*(C`thing($foo)\*(C'\fR and \f(CW\*(C`thing($bar)\*(C'\fR
\&\fIare\fR evaluated \*(-- but as long as the \f(CW\*(C`skip_if_true\*(C'\fR is true,
then we \f(CW\*(C`skip(...)\*(C'\fR just tosses out their value (i.e., not
bothering to treat them like values to \f(CW\*(C`ok(...)\*(C'\fR.  But if
you need to \fInot\fR eval the arguments when skipping the
test, use
this format:
.Sp
.Vb 7
\&  skip( $unless_MSWin,
\&    sub {
\&      # This code returns true if the test passes.
\&      # (But it doesn\*(Aqt even get called if the test is skipped.)
\&      thing($foo) eq thing($bar)
\&    }
\&  );
.Ve
.Sp
or even this, which is basically equivalent:
.Sp
.Vb 3
\&  skip( $unless_MSWin,
\&    sub { thing($foo) }, sub { thing($bar) }
\&  );
.Ve
.Sp
That is, both are like this:
.Sp
.Vb 7
\&  if( $unless_MSWin ) {
\&    ok(1);  # but it actually appends "# $unless_MSWin"
\&            #  so that Test::Harness can tell it\*(Aqs a skip
\&  } else {
\&    # Not skipping, so actually call and evaluate...
\&    ok( sub { thing($foo) }, sub { thing($bar) } );
\&  }
.Ve
.SH "TEST TYPES"
.IX Header "TEST TYPES"
.IP "\(bu" 4
\&\s-1NORMAL TESTS\s0
.Sp
These tests are expected to succeed.  Usually, most or all of your tests
are in this category.  If a normal test doesn't succeed, then that
means that something is \fIwrong\fR.
.IP "\(bu" 4
\&\s-1SKIPPED TESTS\s0
.Sp
The \f(CW\*(C`skip(...)\*(C'\fR function is for tests that might or might not be
possible to run, depending
on the availability of platform-specific features.  The first argument
should evaluate to true (think \*(L"yes, please skip\*(R") if the required
feature is \fInot\fR available.  After the first argument, \f(CW\*(C`skip(...)\*(C'\fR works
exactly the same way as \f(CW\*(C`ok(...)\*(C'\fR does.
.IP "\(bu" 4
\&\s-1TODO TESTS\s0
.Sp
\&\s-1TODO\s0 tests are designed for maintaining an \fBexecutable \s-1TODO\s0 list\fR.
These tests are \fIexpected to fail.\fR  If a \s-1TODO\s0 test does succeed,
then the feature in question shouldn't be on the \s-1TODO\s0 list, now
should it?
.Sp
Packages should \s-1NOT\s0 be released with succeeding \s-1TODO\s0 tests.  As soon
as a \s-1TODO\s0 test starts working, it should be promoted to a normal test,
and the newly working feature should be documented in the release
notes or in the change log.
.SH "ONFAIL"
.IX Header "ONFAIL"
.Vb 1
\&  BEGIN { plan test => 4, onfail => sub { warn "CALL 911!" } }
.Ve
.PP
Although test failures should be enough, extra diagnostics can be
triggered at the end of a test run.  \f(CW\*(C`onfail\*(C'\fR is passed an array ref
of hash refs that describe each test failure.  Each hash will contain
at least the following fields: \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`repetition\*(C'\fR, and
\&\f(CW\*(C`result\*(C'\fR.  (You shouldn't rely on any other fields being present.)  If the test
had an expected value or a diagnostic (or \*(L"note\*(R") string, these will also be
included.
.PP
The \fIoptional\fR \f(CW\*(C`onfail\*(C'\fR hook might be used simply to print out the
version of your package and/or how to report problems.  It might also
be used to generate extremely sophisticated diagnostics for a
particularly bizarre test failure.  However it's not a panacea.  Core
dumps or other unrecoverable errors prevent the \f(CW\*(C`onfail\*(C'\fR hook from
running.  (It is run inside an \f(CW\*(C`END\*(C'\fR block.)  Besides, \f(CW\*(C`onfail\*(C'\fR is
probably over-kill in most cases.  (Your test code should be simpler
than the code it is testing, yes?)
.SH "BUGS and CAVEATS"
.IX Header "BUGS and CAVEATS"
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fR's special handing of strings which look like they might be
regexes can also cause unexpected behavior.  An innocent:
.Sp
.Vb 1
\&    ok( $fileglob, \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.Sp
will fail, since Test.pm considers the second argument to be a regex!
The best bet is to use the one-argument form:
.Sp
.Vb 1
\&    ok( $fileglob eq \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fR's use of string \f(CW\*(C`eq\*(C'\fR can sometimes cause odd problems
when comparing
numbers, especially if you're casting a string to a number:
.Sp
.Vb 2
\&    $foo = "1.0";
\&    ok( $foo, 1 );      # not ok, "1.0" ne 1
.Ve
.Sp
Your best bet is to use the single argument form:
.Sp
.Vb 1
\&    ok( $foo == 1 );    # ok "1.0" == 1
.Ve
.IP "\(bu" 4
As you may have inferred from the above documentation and examples,
\&\f(CW\*(C`ok\*(C'\fR's prototype is \f(CW\*(C`($;$$)\*(C'\fR (and, incidentally, \f(CW\*(C`skip\*(C'\fR's is
\&\f(CW\*(C`($;$$$)\*(C'\fR). This means, for example, that you can do \f(CW\*(C`ok @foo, @bar\*(C'\fR
to compare the \fIsize\fR of the two arrays. But don't be fooled into
thinking that \f(CW\*(C`ok @foo, @bar\*(C'\fR means a comparison of the contents of two
arrays \*(-- you're comparing \fIjust\fR the number of elements of each. It's
so easy to make that mistake in reading \f(CW\*(C`ok @foo, @bar\*(C'\fR that you might
want to be very explicit about it, and instead write \f(CW\*(C`ok scalar(@foo),
scalar(@bar)\*(C'\fR.
.IP "\(bu" 4
This almost definitely doesn't do what you expect:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq);
.Ve
.Sp
Why?  Because \f(CW\*(C`can\*(C'\fR returns a coderef to mean \*(L"yes it can (and the
method is this...)\*(R", and then \f(CW\*(C`ok\*(C'\fR sees a coderef and thinks you're
passing a function that you want it to call and consider the truth of
the result of!  I.e., just like:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq)\->();
.Ve
.Sp
What you probably want instead is this:
.Sp
.Vb 1
\&     ok $thingy\->can(\*(Aqsome_method\*(Aq) && 1;
.Ve
.Sp
If the \f(CW\*(C`can\*(C'\fR returns false, then that is passed to \f(CW\*(C`ok\*(C'\fR.  If it
returns true, then the larger expression \f(CW\*(C`$thingy\->can(\*(Aqsome_method\*(Aq)\ &&\ 1\*(C'\fR returns 1, which \f(CW\*(C`ok\*(C'\fR sees as
a simple signal of success, as you would expect.
.IP "\(bu" 4
The syntax for \f(CW\*(C`skip\*(C'\fR is about the only way it can be, but it's still
quite confusing.  Just start with the above examples and you'll
be okay.
.Sp
Moreover, users may expect this:
.Sp
.Vb 1
\&  skip $unless_mswin, foo($bar), baz($quux);
.Ve
.Sp
to not evaluate \f(CW\*(C`foo($bar)\*(C'\fR and \f(CW\*(C`baz($quux)\*(C'\fR when the test is being
skipped.  But in reality, they \fIare\fR evaluated, but \f(CW\*(C`skip\*(C'\fR just won't
bother comparing them if \f(CW$unless_mswin\fR is true.
.Sp
You could do this:
.Sp
.Vb 1
\&  skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};
.Ve
.Sp
But that's not terribly pretty.  You may find it simpler or clearer in
the long run to just do things like this:
.Sp
.Vb 10
\&  if( $^O =~ m/MSWin/ ) {
\&    print "# Yay, we\*(Aqre under $^O\en";
\&    ok foo($bar), baz($quux);
\&    ok thing($whatever), baz($stuff);
\&    ok blorp($quux, $whatever);
\&    ok foo($barzbarz), thang($quux);
\&  } else {
\&    print "# Feh, we\*(Aqre under $^O.  Watch me skip some tests...\en";
\&    for(1 .. 4) { skip "Skip unless under MSWin" }
\&  }
.Ve
.Sp
But be quite sure that \f(CW\*(C`ok\*(C'\fR is called exactly as many times in the
first block as \f(CW\*(C`skip\*(C'\fR is called in the second block.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR environment variable is set, it will be used as a
command for comparing unexpected multiline results.  If you have \s-1GNU\s0
diff installed, you might want to set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR to \f(CW\*(C`diff \-u\*(C'\fR.
If you don't have a suitable program, you might install the
\&\f(CW\*(C`Text::Diff\*(C'\fR module and then set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR to be \f(CW\*(C`perl
\&\-MText::Diff \-e \*(Aqprint diff(@ARGV)\*(Aq\*(C'\fR.  If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR isn't set
but the \f(CW\*(C`Algorithm::Diff\*(C'\fR module is available, then it will be used
to show the differences in multiline results.
.SH "NOTE"
.IX Header "NOTE"
A past developer of this module once said that it was no longer being
actively developed.  However, rumors of its demise were greatly
exaggerated.  Feedback and suggestions are quite welcome.
.PP
Be aware that the main value of this module is its simplicity.  Note
that there are already more ambitious modules out there, such as
Test::More and Test::Unit.
.PP
Some earlier versions of this module had docs with some confusing
typos in the description of \f(CW\*(C`skip(...)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness
.PP
Test::Simple, Test::More, Devel::Cover
.PP
Test::Builder for building your own testing library.
.PP
Test::Unit is an interesting XUnit-style testing library.
.PP
Test::Inline and SelfTest let you embed tests in code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 1998\-2000 Joshua Nathaniel Pritikin.
.PP
Copyright (c) 2001\-2002 Michael G. Schwern.
.PP
Copyright (c) 2002\-2004 Sean M. Burke.
.PP
Current maintainer: Jesse Vincent. <jesse@bestpractical.com>
.PP
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty.  It may be used, redistributed and/or modified
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder.3pm                            0100644 0001750 0001750 00000073426 12566207463 023732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder 3pm"
.TH Test::Builder 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder \- Backend for building test libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package My::Test::Module;
\&  use base \*(AqTest::Builder::Module\*(Aq;
\&
\&  my $CLASS = _\|_PACKAGE_\|_;
\&
\&  sub ok {
\&      my($test, $name) = @_;
\&      my $tb = $CLASS\->builder;
\&
\&      $tb\->ok($test, $name);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::Simple and Test::More have proven to be popular testing modules,
but they're not always flexible enough.  Test::Builder provides a
building block upon which to write your own test libraries \fIwhich can
work together\fR.
.SS "Construction"
.IX Subsection "Construction"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  my $Test = Test::Builder\->new;
.Ve
.Sp
Returns a Test::Builder object representing the current state of the
test.
.Sp
Since you only run one test per program \f(CW\*(C`new\*(C'\fR always returns the same
Test::Builder object.  No matter how many times you call \f(CW\*(C`new()\*(C'\fR, you're
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.
.Sp
If you want a completely new Test::Builder object different from the
singleton, use \f(CW\*(C`create\*(C'\fR.
.IP "\fBcreate\fR" 4
.IX Item "create"
.Vb 1
\&  my $Test = Test::Builder\->create;
.Ve
.Sp
Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of \f(CW\*(C`new()\*(C'\fR if you're testing
a Test::Builder based module, but otherwise you probably want \f(CW\*(C`new\*(C'\fR.
.Sp
\&\fB\s-1NOTE\s0\fR: the implementation is not complete.  \f(CW\*(C`level\*(C'\fR, for example, is
still shared amongst \fBall\fR Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.
.IP "\fBchild\fR" 4
.IX Item "child"
.Vb 5
\&  my $child = $builder\->child($name_of_child);
\&  $child\->plan( tests => 4 );
\&  $child\->ok(some_code());
\&  ...
\&  $child\->finalize;
.Ve
.Sp
Returns a new instance of \f(CW\*(C`Test::Builder\*(C'\fR.  Any output from this child will
be indented four spaces more than the parent's indentation.  When done, the
\&\f(CW\*(C`finalize\*(C'\fR method \fImust\fR be called explicitly.
.Sp
Trying to create a new child with a previous child still active (i.e.,
\&\f(CW\*(C`finalize\*(C'\fR not called) will \f(CW\*(C`croak\*(C'\fR.
.Sp
Trying to run a test when you have an open child will also \f(CW\*(C`croak\*(C'\fR and cause
the test suite to fail.
.IP "\fBsubtest\fR" 4
.IX Item "subtest"
.Vb 1
\&    $builder\->subtest($name, \e&subtests);
.Ve
.Sp
See documentation of \f(CW\*(C`subtest\*(C'\fR in Test::More.
.IP "\fBfinalize\fR" 4
.IX Item "finalize"
.Vb 1
\&  my $ok = $child\->finalize;
.Ve
.Sp
When your child is done running tests, you must call \f(CW\*(C`finalize\*(C'\fR to clean up
and tell the parent your pass/fail status.
.Sp
Calling finalize on a child with open children will \f(CW\*(C`croak\*(C'\fR.
.Sp
If the child falls out of scope before \f(CW\*(C`finalize\*(C'\fR is called, a failure
diagnostic will be issued and the child is considered to have failed.
.Sp
No attempt to call methods on a child after \f(CW\*(C`finalize\*(C'\fR is called is
guaranteed to succeed.
.Sp
Calling this on the root builder is a no-op.
.IP "\fBparent\fR" 4
.IX Item "parent"
.Vb 3
\& if ( my $parent = $builder\->parent ) {
\&     ...
\& }
.Ve
.Sp
Returns the parent \f(CW\*(C`Test::Builder\*(C'\fR instance, if any.  Only used with child
builders for nested \s-1TAP.\s0
.IP "\fBname\fR" 4
.IX Item "name"
.Vb 1
\& diag $builder\->name;
.Ve
.Sp
Returns the name of the current builder.  Top level builders default to \f(CW$0\fR
(the name of the executable).  Child builders are named via the \f(CW\*(C`child\*(C'\fR
method.  If no name is supplied, will be named \*(L"Child of \f(CW$parent\fR\->name\*(R".
.IP "\fBreset\fR" 4
.IX Item "reset"
.Vb 1
\&  $Test\->reset;
.Ve
.Sp
Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.
.SS "Setting up tests"
.IX Subsection "Setting up tests"
These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.
.IP "\fBplan\fR" 4
.IX Item "plan"
.Vb 3
\&  $Test\->plan(\*(Aqno_plan\*(Aq);
\&  $Test\->plan( skip_all => $reason );
\&  $Test\->plan( tests => $num_tests );
.Ve
.Sp
A convenient way to set up your tests.  Call this and Test::Builder
will print the appropriate headers and take the appropriate actions.
.Sp
If you call \f(CW\*(C`plan()\*(C'\fR, don't call any of the other methods below.
.Sp
If a child calls \*(L"skip_all\*(R" in the plan, a \f(CW\*(C`Test::Builder::Exception\*(C'\fR is
thrown.  Trap this error, call \f(CW\*(C`finalize()\*(C'\fR and don't run any more tests on
the child.
.Sp
.Vb 7
\& my $child = $Test\->child(\*(Aqsome child\*(Aq);
\& eval { $child\->plan( $condition ? ( skip_all => $reason ) : ( tests => 3 )  ) };
\& if ( eval { $@\->isa(\*(AqTest::Builder::Exception\*(Aq) } ) {
\&    $child\->finalize;
\&    return;
\& }
\& # run your tests
.Ve
.IP "\fBexpected_tests\fR" 4
.IX Item "expected_tests"
.Vb 2
\&    my $max = $Test\->expected_tests;
\&    $Test\->expected_tests($max);
.Ve
.Sp
Gets/sets the number of tests we expect this test to run and prints out
the appropriate headers.
.IP "\fBno_plan\fR" 4
.IX Item "no_plan"
.Vb 1
\&  $Test\->no_plan;
.Ve
.Sp
Declares that this test will run an indeterminate number of tests.
.IP "\fBdone_testing\fR" 4
.IX Item "done_testing"
.Vb 2
\&  $Test\->done_testing();
\&  $Test\->done_testing($num_tests);
.Ve
.Sp
Declares that you are done testing, no more tests will be run after this point.
.Sp
If a plan has not yet been output, it will do so.
.Sp
\&\f(CW$num_tests\fR is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If \f(CW\*(C`no_plan\*(C'\fR was declared,
this will override.
.Sp
If \f(CW\*(C`done_testing()\*(C'\fR is called twice, the second call will issue a
failing test.
.Sp
If \f(CW$num_tests\fR is omitted, the number of tests run will be used, like
no_plan.
.Sp
\&\f(CW\*(C`done_testing()\*(C'\fR is, in effect, used when you'd want to use \f(CW\*(C`no_plan\*(C'\fR, but
safer. You'd use it like so:
.Sp
.Vb 2
\&    $Test\->ok($a == $b);
\&    $Test\->done_testing();
.Ve
.Sp
Or to plan a variable number of tests:
.Sp
.Vb 4
\&    for my $test (@tests) {
\&        $Test\->ok($test);
\&    }
\&    $Test\->done_testing(@tests);
.Ve
.IP "\fBhas_plan\fR" 4
.IX Item "has_plan"
.Vb 1
\&  $plan = $Test\->has_plan
.Ve
.Sp
Find out whether a plan has been defined. \f(CW$plan\fR is either \f(CW\*(C`undef\*(C'\fR (no plan
has been set), \f(CW\*(C`no_plan\*(C'\fR (indeterminate # of tests) or an integer (the number
of expected tests).
.IP "\fBskip_all\fR" 4
.IX Item "skip_all"
.Vb 2
\&  $Test\->skip_all;
\&  $Test\->skip_all($reason);
.Ve
.Sp
Skips all the tests, using the given \f(CW$reason\fR.  Exits immediately with 0.
.IP "\fBexported_to\fR" 4
.IX Item "exported_to"
.Vb 2
\&  my $pack = $Test\->exported_to;
\&  $Test\->exported_to($pack);
.Ve
.Sp
Tells Test::Builder what package you exported your functions to.
.Sp
This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.
.SS "Running tests"
.IX Subsection "Running tests"
These actually run the tests, analogous to the functions in Test::More.
.PP
They all return true if the test passed, false if the test failed.
.PP
\&\f(CW$name\fR is always optional.
.IP "\fBok\fR" 4
.IX Item "ok"
.Vb 1
\&  $Test\->ok($test, $name);
.Ve
.Sp
Your basic test.  Pass if \f(CW$test\fR is true, fail if \f(CW$test\fR is false.  Just
like Test::Simple's \f(CW\*(C`ok()\*(C'\fR.
.IP "\fBis_eq\fR" 4
.IX Item "is_eq"
.Vb 1
\&  $Test\->is_eq($got, $expected, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`is()\*(C'\fR.  Checks if \f(CW\*(C`$got eq $expected\*(C'\fR.  This is the
string version.
.Sp
\&\f(CW\*(C`undef\*(C'\fR only ever matches another \f(CW\*(C`undef\*(C'\fR.
.IP "\fBis_num\fR" 4
.IX Item "is_num"
.Vb 1
\&  $Test\->is_num($got, $expected, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`is()\*(C'\fR.  Checks if \f(CW\*(C`$got == $expected\*(C'\fR.  This is the
numeric version.
.Sp
\&\f(CW\*(C`undef\*(C'\fR only ever matches another \f(CW\*(C`undef\*(C'\fR.
.IP "\fBisnt_eq\fR" 4
.IX Item "isnt_eq"
.Vb 1
\&  $Test\->isnt_eq($got, $dont_expect, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`isnt()\*(C'\fR.  Checks if \f(CW\*(C`$got ne $dont_expect\*(C'\fR.  This is
the string version.
.IP "\fBisnt_num\fR" 4
.IX Item "isnt_num"
.Vb 1
\&  $Test\->isnt_num($got, $dont_expect, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`isnt()\*(C'\fR.  Checks if \f(CW\*(C`$got ne $dont_expect\*(C'\fR.  This is
the numeric version.
.IP "\fBlike\fR" 4
.IX Item "like"
.Vb 2
\&  $Test\->like($this, qr/$regex/, $name);
\&  $Test\->like($this, \*(Aq/$regex/\*(Aq, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`like()\*(C'\fR.  Checks if \f(CW$this\fR matches the given \f(CW$regex\fR.
.IP "\fBunlike\fR" 4
.IX Item "unlike"
.Vb 2
\&  $Test\->unlike($this, qr/$regex/, $name);
\&  $Test\->unlike($this, \*(Aq/$regex/\*(Aq, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`unlike()\*(C'\fR.  Checks if \f(CW$this\fR \fBdoes not match\fR the
given \f(CW$regex\fR.
.IP "\fBcmp_ok\fR" 4
.IX Item "cmp_ok"
.Vb 1
\&  $Test\->cmp_ok($this, $type, $that, $name);
.Ve
.Sp
Works just like Test::More's \f(CW\*(C`cmp_ok()\*(C'\fR.
.Sp
.Vb 1
\&    $Test\->cmp_ok($big_num, \*(Aq!=\*(Aq, $other_big_num);
.Ve
.SS "Other Testing Methods"
.IX Subsection "Other Testing Methods"
These are methods which are used in the course of writing a test but are not themselves tests.
.IP "\fB\s-1BAIL_OUT\s0\fR" 4
.IX Item "BAIL_OUT"
.Vb 1
\&    $Test\->BAIL_OUT($reason);
.Ve
.Sp
Indicates to the Test::Harness that things are going so badly all
testing should terminate.  This includes running any additional test
scripts.
.Sp
It will exit with 255.
.IP "\fBskip\fR" 4
.IX Item "skip"
.Vb 2
\&    $Test\->skip;
\&    $Test\->skip($why);
.Ve
.Sp
Skips the current test, reporting \f(CW$why\fR.
.IP "\fBtodo_skip\fR" 4
.IX Item "todo_skip"
.Vb 2
\&  $Test\->todo_skip;
\&  $Test\->todo_skip($why);
.Ve
.Sp
Like \f(CW\*(C`skip()\*(C'\fR, only it will declare the test as failing and \s-1TODO. \s0 Similar
to
.Sp
.Vb 1
\&    print "not ok $tnum # TODO $why\en";
.Ve
.SS "Test building utility methods"
.IX Subsection "Test building utility methods"
These methods are useful when writing your own test methods.
.IP "\fBmaybe_regex\fR" 4
.IX Item "maybe_regex"
.Vb 2
\&  $Test\->maybe_regex(qr/$regex/);
\&  $Test\->maybe_regex(\*(Aq/$regex/\*(Aq);
.Ve
.Sp
This method used to be useful back when Test::Builder worked on Perls
before 5.6 which didn't have qr//.  Now its pretty useless.
.Sp
Convenience method for building testing functions that take regular
expressions as arguments.
.Sp
Takes a quoted regular expression produced by \f(CW\*(C`qr//\*(C'\fR, or a string
representing a regular expression.
.Sp
Returns a Perl value which may be used instead of the corresponding
regular expression, or \f(CW\*(C`undef\*(C'\fR if its argument is not recognised.
.Sp
For example, a version of \f(CW\*(C`like()\*(C'\fR, sans the useful diagnostic messages,
could be written as:
.Sp
.Vb 7
\&  sub laconic_like {
\&      my ($self, $this, $regex, $name) = @_;
\&      my $usable_regex = $self\->maybe_regex($regex);
\&      die "expecting regex, found \*(Aq$regex\*(Aq\en"
\&          unless $usable_regex;
\&      $self\->ok($this =~ m/$usable_regex/, $name);
\&  }
.Ve
.IP "\fBis_fh\fR" 4
.IX Item "is_fh"
.Vb 1
\&    my $is_fh = $Test\->is_fh($thing);
.Ve
.Sp
Determines if the given \f(CW$thing\fR can be used as a filehandle.
.SS "Test style"
.IX Subsection "Test style"
.IP "\fBlevel\fR" 4
.IX Item "level"
.Vb 1
\&    $Test\->level($how_high);
.Ve
.Sp
How far up the call stack should \f(CW$Test\fR look when reporting where the
test failed.
.Sp
Defaults to 1.
.Sp
Setting \f(CW$Test::Builder::Level\fR overrides.  This is typically useful
localized:
.Sp
.Vb 2
\&    sub my_ok {
\&        my $test = shift;
\&
\&        local $Test::Builder::Level = $Test::Builder::Level + 1;
\&        $TB\->ok($test);
\&    }
.Ve
.Sp
To be polite to other functions wrapping your own you usually want to increment \f(CW$Level\fR rather than set it to a constant.
.IP "\fBuse_numbers\fR" 4
.IX Item "use_numbers"
.Vb 1
\&    $Test\->use_numbers($on_or_off);
.Ve
.Sp
Whether or not the test should output numbers.  That is, this if true:
.Sp
.Vb 3
\&  ok 1
\&  ok 2
\&  ok 3
.Ve
.Sp
or this if false
.Sp
.Vb 3
\&  ok
\&  ok
\&  ok
.Ve
.Sp
Most useful when you can't depend on the test output order, such as
when threads or forking is involved.
.Sp
Defaults to on.
.IP "\fBno_diag\fR" 4
.IX Item "no_diag"
.Vb 1
\&    $Test\->no_diag($no_diag);
.Ve
.Sp
If set true no diagnostics will be printed.  This includes calls to
\&\f(CW\*(C`diag()\*(C'\fR.
.IP "\fBno_ending\fR" 4
.IX Item "no_ending"
.Vb 1
\&    $Test\->no_ending($no_ending);
.Ve
.Sp
Normally, Test::Builder does some extra diagnostics when the test
ends.  It also changes the exit code as described below.
.Sp
If this is true, none of that will be done.
.IP "\fBno_header\fR" 4
.IX Item "no_header"
.Vb 1
\&    $Test\->no_header($no_header);
.Ve
.Sp
If set to true, no \*(L"1..N\*(R" header will be printed.
.SS "Output"
.IX Subsection "Output"
Controlling where the test output goes.
.PP
It's ok for your test to change where \s-1STDOUT\s0 and \s-1STDERR\s0 point to,
Test::Builder's default output settings will not be affected.
.IP "\fBdiag\fR" 4
.IX Item "diag"
.Vb 1
\&    $Test\->diag(@msgs);
.Ve
.Sp
Prints out the given \f(CW@msgs\fR.  Like \f(CW\*(C`print\*(C'\fR, arguments are simply
appended together.
.Sp
Normally, it uses the \f(CW\*(C`failure_output()\*(C'\fR handle, but if this is for a
\&\s-1TODO\s0 test, the \f(CW\*(C`todo_output()\*(C'\fR handle is used.
.Sp
Output will be indented and marked with a # so as not to interfere
with test output.  A newline will be put on the end if there isn't one
already.
.Sp
We encourage using this rather than calling print directly.
.Sp
Returns false.  Why?  Because \f(CW\*(C`diag()\*(C'\fR is often used in conjunction with
a failing test (\f(CW\*(C`ok() || diag()\*(C'\fR) it \*(L"passes through\*(R" the failure.
.Sp
.Vb 1
\&    return ok(...) || diag(...);
.Ve
.IP "\fBnote\fR" 4
.IX Item "note"
.Vb 1
\&    $Test\->note(@msgs);
.Ve
.Sp
Like \f(CW\*(C`diag()\*(C'\fR, but it prints to the \f(CW\*(C`output()\*(C'\fR handle so it will not
normally be seen by the user except in verbose mode.
.IP "\fBexplain\fR" 4
.IX Item "explain"
.Vb 1
\&    my @dump = $Test\->explain(@msgs);
.Ve
.Sp
Will dump the contents of any references in a human readable format.
Handy for things like...
.Sp
.Vb 1
\&    is_deeply($have, $want) || diag explain $have;
.Ve
.Sp
or
.Sp
.Vb 1
\&    is_deeply($have, $want) || note explain $have;
.Ve
.IP "\fBoutput\fR" 4
.IX Item "output"
.PD 0
.IP "\fBfailure_output\fR" 4
.IX Item "failure_output"
.IP "\fBtodo_output\fR" 4
.IX Item "todo_output"
.PD
.Vb 4
\&    my $filehandle = $Test\->output;
\&    $Test\->output($filehandle);
\&    $Test\->output($filename);
\&    $Test\->output(\e$scalar);
.Ve
.Sp
These methods control where Test::Builder will print its output.
They take either an open \f(CW$filehandle\fR, a \f(CW$filename\fR to open and write to
or a \f(CW$scalar\fR reference to append to.  It will always return a \f(CW$filehandle\fR.
.Sp
\&\fBoutput\fR is where normal \*(L"ok/not ok\*(R" test output goes.
.Sp
Defaults to \s-1STDOUT.\s0
.Sp
\&\fBfailure_output\fR is where diagnostic output on test failures and
\&\f(CW\*(C`diag()\*(C'\fR goes.  It is normally not read by Test::Harness and instead is
displayed to the user.
.Sp
Defaults to \s-1STDERR.\s0
.Sp
\&\f(CW\*(C`todo_output\*(C'\fR is used instead of \f(CW\*(C`failure_output()\*(C'\fR for the
diagnostics of a failing \s-1TODO\s0 test.  These will not be seen by the
user.
.Sp
Defaults to \s-1STDOUT.\s0
.IP "reset_outputs" 4
.IX Item "reset_outputs"
.Vb 1
\&  $tb\->reset_outputs;
.Ve
.Sp
Resets all the output filehandles back to their defaults.
.IP "carp" 4
.IX Item "carp"
.Vb 1
\&  $tb\->carp(@message);
.Ve
.Sp
Warns with \f(CW@message\fR but the message will appear to come from the
point where the original test function was called (\f(CW\*(C`$tb\->caller\*(C'\fR).
.IP "croak" 4
.IX Item "croak"
.Vb 1
\&  $tb\->croak(@message);
.Ve
.Sp
Dies with \f(CW@message\fR but the message will appear to come from the
point where the original test function was called (\f(CW\*(C`$tb\->caller\*(C'\fR).
.SS "Test Status and Info"
.IX Subsection "Test Status and Info"
.IP "\fBcurrent_test\fR" 4
.IX Item "current_test"
.Vb 2
\&    my $curr_test = $Test\->current_test;
\&    $Test\->current_test($num);
.Ve
.Sp
Gets/sets the current test number we're on.  You usually shouldn't
have to set this.
.Sp
If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.
.IP "\fBis_passing\fR" 4
.IX Item "is_passing"
.Vb 1
\&   my $ok = $builder\->is_passing;
.Ve
.Sp
Indicates if the test suite is currently passing.
.Sp
More formally, it will be false if anything has happened which makes
it impossible for the test suite to pass.  True otherwise.
.Sp
For example, if no tests have run \f(CW\*(C`is_passing()\*(C'\fR will be true because
even though a suite with no tests is a failure you can add a passing
test to it and start passing.
.Sp
Don't think about it too much.
.IP "\fBsummary\fR" 4
.IX Item "summary"
.Vb 1
\&    my @tests = $Test\->summary;
.Ve
.Sp
A simple summary of the tests so far.  True for pass, false for fail.
This is a logical pass/fail, so todos are passes.
.Sp
Of course, test #1 is \f(CW$tests\fR[0], etc...
.IP "\fBdetails\fR" 4
.IX Item "details"
.Vb 1
\&    my @tests = $Test\->details;
.Ve
.Sp
Like \f(CW\*(C`summary()\*(C'\fR, but with a lot more detail.
.Sp
.Vb 7
\&    $tests[$test_num \- 1] = 
\&            { \*(Aqok\*(Aq       => is the test considered a pass?
\&              actual_ok  => did it literally say \*(Aqok\*(Aq?
\&              name       => name of the test (if any)
\&              type       => type of test (if any, see below).
\&              reason     => reason for the above (if any)
\&            };
.Ve
.Sp
\&'ok' is true if Test::Harness will consider the test to be a pass.
.Sp
\&'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.
.Sp
\&'name' is the name of the test.
.Sp
\&'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:
.Sp
.Vb 4
\&    skip        see skip()
\&    todo        see todo()
\&    todo_skip   see todo_skip()
\&    unknown     see below
.Ve
.Sp
Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when \f(CW\*(C`current_test()\*(C'\fR is changed.
In these cases, Test::Builder doesn't know the result of the test, so
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left \f(CW\*(C`undef\*(C'\fR.
.Sp
For example \*(L"not ok 23 \- hole count # \s-1TODO\s0 insufficient donuts\*(R" would
result in this structure:
.Sp
.Vb 7
\&    $tests[22] =    # 23 \- 1, since arrays start from 0.
\&      { ok        => 1,   # logically, the test passed since its todo
\&        actual_ok => 0,   # in absolute terms, it failed
\&        name      => \*(Aqhole count\*(Aq,
\&        type      => \*(Aqtodo\*(Aq,
\&        reason    => \*(Aqinsufficient donuts\*(Aq
\&      };
.Ve
.IP "\fBtodo\fR" 4
.IX Item "todo"
.Vb 2
\&    my $todo_reason = $Test\->todo;
\&    my $todo_reason = $Test\->todo($pack);
.Ve
.Sp
If the current tests are considered \*(L"\s-1TODO\*(R"\s0 it will return the reason,
if any.  This reason can come from a \f(CW$TODO\fR variable or the last call
to \f(CW\*(C`todo_start()\*(C'\fR.
.Sp
Since a \s-1TODO\s0 test does not need a reason, this function can return an
empty string even when inside a \s-1TODO\s0 block.  Use \f(CW\*(C`$Test\->in_todo\*(C'\fR
to determine if you are currently inside a \s-1TODO\s0 block.
.Sp
\&\f(CW\*(C`todo()\*(C'\fR is about finding the right package to look for \f(CW$TODO\fR in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on \f(CW\*(C`$Level + 1\*(C'\fR, since \f(CW\*(C`todo()\*(C'\fR is usually called inside
a test function.  As a last resort it will use \f(CW\*(C`exported_to()\*(C'\fR.
.Sp
Sometimes there is some confusion about where \fItodo()\fR should be looking
for the \f(CW$TODO\fR variable.  If you want to be sure, tell it explicitly
what \f(CW$pack\fR to use.
.IP "\fBfind_TODO\fR" 4
.IX Item "find_TODO"
.Vb 2
\&    my $todo_reason = $Test\->find_TODO();
\&    my $todo_reason = $Test\->find_TODO($pack);
.Ve
.Sp
Like \f(CW\*(C`todo()\*(C'\fR but only returns the value of \f(CW$TODO\fR ignoring
\&\f(CW\*(C`todo_start()\*(C'\fR.
.Sp
Can also be used to set \f(CW$TODO\fR to a new value while returning the
old value:
.Sp
.Vb 1
\&    my $old_reason = $Test\->find_TODO($pack, 1, $new_reason);
.Ve
.IP "\fBin_todo\fR" 4
.IX Item "in_todo"
.Vb 1
\&    my $in_todo = $Test\->in_todo;
.Ve
.Sp
Returns true if the test is currently inside a \s-1TODO\s0 block.
.IP "\fBtodo_start\fR" 4
.IX Item "todo_start"
.Vb 2
\&    $Test\->todo_start();
\&    $Test\->todo_start($message);
.Ve
.Sp
This method allows you declare all subsequent tests as \s-1TODO\s0 tests, up until
the \f(CW\*(C`todo_end\*(C'\fR method has been called.
.Sp
The \f(CW\*(C`TODO:\*(C'\fR and \f(CW$TODO\fR syntax is generally pretty good about figuring out
whether or not we're in a \s-1TODO\s0 test.  However, often we find that this is not
possible to determine (such as when we want to use \f(CW$TODO\fR but
the tests are being executed in other packages which can't be inferred
beforehand).
.Sp
Note that you can use this to nest \*(L"todo\*(R" tests
.Sp
.Vb 6
\& $Test\->todo_start(\*(Aqworking on this\*(Aq);
\& # lots of code
\& $Test\->todo_start(\*(Aqworking on that\*(Aq);
\& # more code
\& $Test\->todo_end;
\& $Test\->todo_end;
.Ve
.Sp
This is generally not recommended, but large testing systems often have weird
internal needs.
.Sp
We've tried to make this also work with the \s-1TODO:\s0 syntax, but it's not
guaranteed and its use is also discouraged:
.Sp
.Vb 9
\& TODO: {
\&     local $TODO = \*(AqWe have work to do!\*(Aq;
\&     $Test\->todo_start(\*(Aqworking on this\*(Aq);
\&     # lots of code
\&     $Test\->todo_start(\*(Aqworking on that\*(Aq);
\&     # more code
\&     $Test\->todo_end;
\&     $Test\->todo_end;
\& }
.Ve
.Sp
Pick one style or another of \*(L"\s-1TODO\*(R"\s0 to be on the safe side.
.ie n .IP """todo_end""" 4
.el .IP "\f(CWtodo_end\fR" 4
.IX Item "todo_end"
.Vb 1
\& $Test\->todo_end;
.Ve
.Sp
Stops running tests as \*(L"\s-1TODO\*(R"\s0 tests.  This method is fatal if called without a
preceding \f(CW\*(C`todo_start\*(C'\fR method call.
.IP "\fBcaller\fR" 4
.IX Item "caller"
.Vb 3
\&    my $package = $Test\->caller;
\&    my($pack, $file, $line) = $Test\->caller;
\&    my($pack, $file, $line) = $Test\->caller($height);
.Ve
.Sp
Like the normal \f(CW\*(C`caller()\*(C'\fR, except it reports according to your \f(CW\*(C`level()\*(C'\fR.
.Sp
\&\f(CW$height\fR will be added to the \f(CW\*(C`level()\*(C'\fR.
.Sp
If \f(CW\*(C`caller()\*(C'\fR winds up off the top of the stack it report the highest context.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.
.PP
So the exit codes are...
.PP
.Vb 3
\&    0                   all tests successful
\&    255                 test died or all passed but wrong # of tests run
\&    any other number    how many failed (including missing or extras)
.Ve
.PP
If you fail more than 254 tests, it will be reported as 254.
.SH "THREADS"
.IX Header "THREADS"
In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
number is shared amongst all threads.  This means if one thread sets
the test number using \f(CW\*(C`current_test()\*(C'\fR they will all be effected.
.PP
While versions earlier than 5.8.1 had threads they contain too many
bugs to support.
.PP
Test::Builder is only thread-aware if threads.pm is loaded \fIbefore\fR
Test::Builder.
.SH "MEMORY"
.IX Header "MEMORY"
An informative hash, accessible via \f(CW\*(C`<details()\*(C'\fR>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.
.PP
In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing \*(L"normal\*(R" (code) compares and
triggering \fIfail()\fR should anything go unexpected.
.PP
Future versions of Test::Builder will have a way to turn history off.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
\&\s-1CPAN\s0 can provide the best examples.  Test::Simple, Test::More,
Test::Exception and Test::Differences all use Test::Builder.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Simple, Test::More, Test::Harness
.SH "AUTHORS"
.IX Header "AUTHORS"
Original code by chromatic, maintained by Michael G Schwern
<schwern@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by chromatic <chromatic@wgz.org> and
                       Michael G Schwern <schwern@pobox.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder5.16.3pm                        0100644 0001750 0001750 00000073105 12566207441 024232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder 3pm"
.TH Test::Builder 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder \- Backend for building test libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package My::Test::Module;
\&  use base \*(AqTest::Builder::Module\*(Aq;
\&
\&  my $CLASS = _\|_PACKAGE_\|_;
\&
\&  sub ok {
\&      my($test, $name) = @_;
\&      my $tb = $CLASS\->builder;
\&
\&      $tb\->ok($test, $name);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::Simple and Test::More have proven to be popular testing modules,
but they're not always flexible enough.  Test::Builder provides a
building block upon which to write your own test libraries \fIwhich can
work together\fR.
.SS "Construction"
.IX Subsection "Construction"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  my $Test = Test::Builder\->new;
.Ve
.Sp
Returns a Test::Builder object representing the current state of the
test.
.Sp
Since you only run one test per program \f(CW\*(C`new\*(C'\fR always returns the same
Test::Builder object.  No matter how many times you call \f(CW\*(C`new()\*(C'\fR, you're
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.
.Sp
If you want a completely new Test::Builder object different from the
singleton, use \f(CW\*(C`create\*(C'\fR.
.IP "\fBcreate\fR" 4
.IX Item "create"
.Vb 1
\&  my $Test = Test::Builder\->create;
.Ve
.Sp
Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of \f(CW\*(C`new()\*(C'\fR if you're testing
a Test::Builder based module, but otherwise you probably want \f(CW\*(C`new\*(C'\fR.
.Sp
\&\fB\s-1NOTE\s0\fR: the implementation is not complete.  \f(CW\*(C`level\*(C'\fR, for example, is
still shared amongst \fBall\fR Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.
.IP "\fBchild\fR" 4
.IX Item "child"
.Vb 5
\&  my $child = $builder\->child($name_of_child);
\&  $child\->plan( tests => 4 );
\&  $child\->ok(some_code());
\&  ...
\&  $child\->finalize;
.Ve
.Sp
Returns a new instance of \f(CW\*(C`Test::Builder\*(C'\fR.  Any output from this child will
be indented four spaces more than the parent's indentation.  When done, the
\&\f(CW\*(C`finalize\*(C'\fR method \fImust\fR be called explicitly.
.Sp
Trying to create a new child with a previous child still active (i.e.,
\&\f(CW\*(C`finalize\*(C'\fR not called) will \f(CW\*(C`croak\*(C'\fR.
.Sp
Trying to run a test when you have an open child will also \f(CW\*(C`croak\*(C'\fR and cause
the test suite to fail.
.IP "\fBsubtest\fR" 4
.IX Item "subtest"
.Vb 1
\&    $builder\->subtest($name, \e&subtests);
.Ve
.Sp
See documentation of \f(CW\*(C`subtest\*(C'\fR in Test::More.
.IP "\fBfinalize\fR" 4
.IX Item "finalize"
.Vb 1
\&  my $ok = $child\->finalize;
.Ve
.Sp
When your child is done running tests, you must call \f(CW\*(C`finalize\*(C'\fR to clean up
and tell the parent your pass/fail status.
.Sp
Calling finalize on a child with open children will \f(CW\*(C`croak\*(C'\fR.
.Sp
If the child falls out of scope before \f(CW\*(C`finalize\*(C'\fR is called, a failure
diagnostic will be issued and the child is considered to have failed.
.Sp
No attempt to call methods on a child after \f(CW\*(C`finalize\*(C'\fR is called is
guaranteed to succeed.
.Sp
Calling this on the root builder is a no-op.
.IP "\fBparent\fR" 4
.IX Item "parent"
.Vb 3
\& if ( my $parent = $builder\->parent ) {
\&     ...
\& }
.Ve
.Sp
Returns the parent \f(CW\*(C`Test::Builder\*(C'\fR instance, if any.  Only used with child
builders for nested \s-1TAP\s0.
.IP "\fBname\fR" 4
.IX Item "name"
.Vb 1
\& diag $builder\->name;
.Ve
.Sp
Returns the name of the current builder.  Top level builders default to \f(CW$0\fR
(the name of the executable).  Child builders are named via the \f(CW\*(C`child\*(C'\fR
method.  If no name is supplied, will be named \*(L"Child of \f(CW$parent\fR\->name\*(R".
.IP "\fBreset\fR" 4
.IX Item "reset"
.Vb 1
\&  $Test\->reset;
.Ve
.Sp
Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.
.SS "Setting up tests"
.IX Subsection "Setting up tests"
These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.
.IP "\fBplan\fR" 4
.IX Item "plan"
.Vb 3
\&  $Test\->plan(\*(Aqno_plan\*(Aq);
\&  $Test\->plan( skip_all => $reason );
\&  $Test\->plan( tests => $num_tests );
.Ve
.Sp
A convenient way to set up your tests.  Call this and Test::Builder
will print the appropriate headers and take the appropriate actions.
.Sp
If you call \f(CW\*(C`plan()\*(C'\fR, don't call any of the other methods below.
.Sp
If a child calls \*(L"skip_all\*(R" in the plan, a \f(CW\*(C`Test::Builder::Exception\*(C'\fR is
thrown.  Trap this error, call \f(CW\*(C`finalize()\*(C'\fR and don't run any more tests on
the child.
.Sp
.Vb 7
\& my $child = $Test\->child(\*(Aqsome child\*(Aq);
\& eval { $child\->plan( $condition ? ( skip_all => $reason ) : ( tests => 3 )  ) };
\& if ( eval { $@\->isa(\*(AqTest::Builder::Exception\*(Aq) } ) {
\&    $child\->finalize;
\&    return;
\& }
\& # run your tests
.Ve
.IP "\fBexpected_tests\fR" 4
.IX Item "expected_tests"
.Vb 2
\&    my $max = $Test\->expected_tests;
\&    $Test\->expected_tests($max);
.Ve
.Sp
Gets/sets the number of tests we expect this test to run and prints out
the appropriate headers.
.IP "\fBno_plan\fR" 4
.IX Item "no_plan"
.Vb 1
\&  $Test\->no_plan;
.Ve
.Sp
Declares that this test will run an indeterminate number of tests.
.IP "\fBdone_testing\fR" 4
.IX Item "done_testing"
.Vb 2
\&  $Test\->done_testing();
\&  $Test\->done_testing($num_tests);
.Ve
.Sp
Declares that you are done testing, no more tests will be run after this point.
.Sp
If a plan has not yet been output, it will do so.
.Sp
\&\f(CW$num_tests\fR is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If \f(CW\*(C`no_plan\*(C'\fR was declared,
this will override.
.Sp
If \f(CW\*(C`done_testing()\*(C'\fR is called twice, the second call will issue a
failing test.
.Sp
If \f(CW$num_tests\fR is omitted, the number of tests run will be used, like
no_plan.
.Sp
\&\f(CW\*(C`done_testing()\*(C'\fR is, in effect, used when you'd want to use \f(CW\*(C`no_plan\*(C'\fR, but
safer. You'd use it like so:
.Sp
.Vb 2
\&    $Test\->ok($a == $b);
\&    $Test\->done_testing();
.Ve
.Sp
Or to plan a variable number of tests:
.Sp
.Vb 4
\&    for my $test (@tests) {
\&        $Test\->ok($test);
\&    }
\&    $Test\->done_testing(@tests);
.Ve
.IP "\fBhas_plan\fR" 4
.IX Item "has_plan"
.Vb 1
\&  $plan = $Test\->has_plan
.Ve
.Sp
Find out whether a plan has been defined. \f(CW$plan\fR is either \f(CW\*(C`undef\*(C'\fR (no plan
has been set), \f(CW\*(C`no_plan\*(C'\fR (indeterminate # of tests) or an integer (the number
of expected tests).
.IP "\fBskip_all\fR" 4
.IX Item "skip_all"
.Vb 2
\&  $Test\->skip_all;
\&  $Test\->skip_all($reason);
.Ve
.Sp
Skips all the tests, using the given \f(CW$reason\fR.  Exits immediately with 0.
.IP "\fBexported_to\fR" 4
.IX Item "exported_to"
.Vb 2
\&  my $pack = $Test\->exported_to;
\&  $Test\->exported_to($pack);
.Ve
.Sp
Tells Test::Builder what package you exported your functions to.
.Sp
This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.
.SS "Running tests"
.IX Subsection "Running tests"
These actually run the tests, analogous to the functions in Test::More.
.PP
They all return true if the test passed, false if the test failed.
.PP
\&\f(CW$name\fR is always optional.
.IP "\fBok\fR" 4
.IX Item "ok"
.Vb 1
\&  $Test\->ok($test, $name);
.Ve
.Sp
Your basic test.  Pass if \f(CW$test\fR is true, fail if \f(CW$test\fR is false.  Just
like Test::Simple's \f(CW\*(C`ok()\*(C'\fR.
.IP "\fBis_eq\fR" 4
.IX Item "is_eq"
.Vb 1
\&  $Test\->is_eq($got, $expected, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`is()\*(C'\fR.  Checks if \f(CW\*(C`$got eq $expected\*(C'\fR.  This is the
string version.
.Sp
\&\f(CW\*(C`undef\*(C'\fR only ever matches another \f(CW\*(C`undef\*(C'\fR.
.IP "\fBis_num\fR" 4
.IX Item "is_num"
.Vb 1
\&  $Test\->is_num($got, $expected, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`is()\*(C'\fR.  Checks if \f(CW\*(C`$got == $expected\*(C'\fR.  This is the
numeric version.
.Sp
\&\f(CW\*(C`undef\*(C'\fR only ever matches another \f(CW\*(C`undef\*(C'\fR.
.IP "\fBisnt_eq\fR" 4
.IX Item "isnt_eq"
.Vb 1
\&  $Test\->isnt_eq($got, $dont_expect, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`isnt()\*(C'\fR.  Checks if \f(CW\*(C`$got ne $dont_expect\*(C'\fR.  This is
the string version.
.IP "\fBisnt_num\fR" 4
.IX Item "isnt_num"
.Vb 1
\&  $Test\->isnt_num($got, $dont_expect, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`isnt()\*(C'\fR.  Checks if \f(CW\*(C`$got ne $dont_expect\*(C'\fR.  This is
the numeric version.
.IP "\fBlike\fR" 4
.IX Item "like"
.Vb 2
\&  $Test\->like($this, qr/$regex/, $name);
\&  $Test\->like($this, \*(Aq/$regex/\*(Aq, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`like()\*(C'\fR.  Checks if \f(CW$this\fR matches the given \f(CW$regex\fR.
.IP "\fBunlike\fR" 4
.IX Item "unlike"
.Vb 2
\&  $Test\->unlike($this, qr/$regex/, $name);
\&  $Test\->unlike($this, \*(Aq/$regex/\*(Aq, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`unlike()\*(C'\fR.  Checks if \f(CW$this\fR \fBdoes not match\fR the
given \f(CW$regex\fR.
.IP "\fBcmp_ok\fR" 4
.IX Item "cmp_ok"
.Vb 1
\&  $Test\->cmp_ok($this, $type, $that, $name);
.Ve
.Sp
Works just like Test::More's \f(CW\*(C`cmp_ok()\*(C'\fR.
.Sp
.Vb 1
\&    $Test\->cmp_ok($big_num, \*(Aq!=\*(Aq, $other_big_num);
.Ve
.SS "Other Testing Methods"
.IX Subsection "Other Testing Methods"
These are methods which are used in the course of writing a test but are not themselves tests.
.IP "\fB\s-1BAIL_OUT\s0\fR" 4
.IX Item "BAIL_OUT"
.Vb 1
\&    $Test\->BAIL_OUT($reason);
.Ve
.Sp
Indicates to the Test::Harness that things are going so badly all
testing should terminate.  This includes running any additional test
scripts.
.Sp
It will exit with 255.
.IP "\fBskip\fR" 4
.IX Item "skip"
.Vb 2
\&    $Test\->skip;
\&    $Test\->skip($why);
.Ve
.Sp
Skips the current test, reporting \f(CW$why\fR.
.IP "\fBtodo_skip\fR" 4
.IX Item "todo_skip"
.Vb 2
\&  $Test\->todo_skip;
\&  $Test\->todo_skip($why);
.Ve
.Sp
Like \f(CW\*(C`skip()\*(C'\fR, only it will declare the test as failing and \s-1TODO\s0.  Similar
to
.Sp
.Vb 1
\&    print "not ok $tnum # TODO $why\en";
.Ve
.SS "Test building utility methods"
.IX Subsection "Test building utility methods"
These methods are useful when writing your own test methods.
.IP "\fBmaybe_regex\fR" 4
.IX Item "maybe_regex"
.Vb 2
\&  $Test\->maybe_regex(qr/$regex/);
\&  $Test\->maybe_regex(\*(Aq/$regex/\*(Aq);
.Ve
.Sp
This method used to be useful back when Test::Builder worked on Perls
before 5.6 which didn't have qr//.  Now its pretty useless.
.Sp
Convenience method for building testing functions that take regular
expressions as arguments.
.Sp
Takes a quoted regular expression produced by \f(CW\*(C`qr//\*(C'\fR, or a string
representing a regular expression.
.Sp
Returns a Perl value which may be used instead of the corresponding
regular expression, or \f(CW\*(C`undef\*(C'\fR if its argument is not recognised.
.Sp
For example, a version of \f(CW\*(C`like()\*(C'\fR, sans the useful diagnostic messages,
could be written as:
.Sp
.Vb 7
\&  sub laconic_like {
\&      my ($self, $this, $regex, $name) = @_;
\&      my $usable_regex = $self\->maybe_regex($regex);
\&      die "expecting regex, found \*(Aq$regex\*(Aq\en"
\&          unless $usable_regex;
\&      $self\->ok($this =~ m/$usable_regex/, $name);
\&  }
.Ve
.IP "\fBis_fh\fR" 4
.IX Item "is_fh"
.Vb 1
\&    my $is_fh = $Test\->is_fh($thing);
.Ve
.Sp
Determines if the given \f(CW$thing\fR can be used as a filehandle.
.SS "Test style"
.IX Subsection "Test style"
.IP "\fBlevel\fR" 4
.IX Item "level"
.Vb 1
\&    $Test\->level($how_high);
.Ve
.Sp
How far up the call stack should \f(CW$Test\fR look when reporting where the
test failed.
.Sp
Defaults to 1.
.Sp
Setting \f(CW$Test::Builder::Level\fR overrides.  This is typically useful
localized:
.Sp
.Vb 2
\&    sub my_ok {
\&        my $test = shift;
\&
\&        local $Test::Builder::Level = $Test::Builder::Level + 1;
\&        $TB\->ok($test);
\&    }
.Ve
.Sp
To be polite to other functions wrapping your own you usually want to increment \f(CW$Level\fR rather than set it to a constant.
.IP "\fBuse_numbers\fR" 4
.IX Item "use_numbers"
.Vb 1
\&    $Test\->use_numbers($on_or_off);
.Ve
.Sp
Whether or not the test should output numbers.  That is, this if true:
.Sp
.Vb 3
\&  ok 1
\&  ok 2
\&  ok 3
.Ve
.Sp
or this if false
.Sp
.Vb 3
\&  ok
\&  ok
\&  ok
.Ve
.Sp
Most useful when you can't depend on the test output order, such as
when threads or forking is involved.
.Sp
Defaults to on.
.IP "\fBno_diag\fR" 4
.IX Item "no_diag"
.Vb 1
\&    $Test\->no_diag($no_diag);
.Ve
.Sp
If set true no diagnostics will be printed.  This includes calls to
\&\f(CW\*(C`diag()\*(C'\fR.
.IP "\fBno_ending\fR" 4
.IX Item "no_ending"
.Vb 1
\&    $Test\->no_ending($no_ending);
.Ve
.Sp
Normally, Test::Builder does some extra diagnostics when the test
ends.  It also changes the exit code as described below.
.Sp
If this is true, none of that will be done.
.IP "\fBno_header\fR" 4
.IX Item "no_header"
.Vb 1
\&    $Test\->no_header($no_header);
.Ve
.Sp
If set to true, no \*(L"1..N\*(R" header will be printed.
.SS "Output"
.IX Subsection "Output"
Controlling where the test output goes.
.PP
It's ok for your test to change where \s-1STDOUT\s0 and \s-1STDERR\s0 point to,
Test::Builder's default output settings will not be affected.
.IP "\fBdiag\fR" 4
.IX Item "diag"
.Vb 1
\&    $Test\->diag(@msgs);
.Ve
.Sp
Prints out the given \f(CW@msgs\fR.  Like \f(CW\*(C`print\*(C'\fR, arguments are simply
appended together.
.Sp
Normally, it uses the \f(CW\*(C`failure_output()\*(C'\fR handle, but if this is for a
\&\s-1TODO\s0 test, the \f(CW\*(C`todo_output()\*(C'\fR handle is used.
.Sp
Output will be indented and marked with a # so as not to interfere
with test output.  A newline will be put on the end if there isn't one
already.
.Sp
We encourage using this rather than calling print directly.
.Sp
Returns false.  Why?  Because \f(CW\*(C`diag()\*(C'\fR is often used in conjunction with
a failing test (\f(CW\*(C`ok() || diag()\*(C'\fR) it \*(L"passes through\*(R" the failure.
.Sp
.Vb 1
\&    return ok(...) || diag(...);
.Ve
.IP "\fBnote\fR" 4
.IX Item "note"
.Vb 1
\&    $Test\->note(@msgs);
.Ve
.Sp
Like \f(CW\*(C`diag()\*(C'\fR, but it prints to the \f(CW\*(C`output()\*(C'\fR handle so it will not
normally be seen by the user except in verbose mode.
.IP "\fBexplain\fR" 4
.IX Item "explain"
.Vb 1
\&    my @dump = $Test\->explain(@msgs);
.Ve
.Sp
Will dump the contents of any references in a human readable format.
Handy for things like...
.Sp
.Vb 1
\&    is_deeply($have, $want) || diag explain $have;
.Ve
.Sp
or
.Sp
.Vb 1
\&    is_deeply($have, $want) || note explain $have;
.Ve
.IP "\fBoutput\fR" 4
.IX Item "output"
.PD 0
.IP "\fBfailure_output\fR" 4
.IX Item "failure_output"
.IP "\fBtodo_output\fR" 4
.IX Item "todo_output"
.PD
.Vb 4
\&    my $filehandle = $Test\->output;
\&    $Test\->output($filehandle);
\&    $Test\->output($filename);
\&    $Test\->output(\e$scalar);
.Ve
.Sp
These methods control where Test::Builder will print its output.
They take either an open \f(CW$filehandle\fR, a \f(CW$filename\fR to open and write to
or a \f(CW$scalar\fR reference to append to.  It will always return a \f(CW$filehandle\fR.
.Sp
\&\fBoutput\fR is where normal \*(L"ok/not ok\*(R" test output goes.
.Sp
Defaults to \s-1STDOUT\s0.
.Sp
\&\fBfailure_output\fR is where diagnostic output on test failures and
\&\f(CW\*(C`diag()\*(C'\fR goes.  It is normally not read by Test::Harness and instead is
displayed to the user.
.Sp
Defaults to \s-1STDERR\s0.
.Sp
\&\f(CW\*(C`todo_output\*(C'\fR is used instead of \f(CW\*(C`failure_output()\*(C'\fR for the
diagnostics of a failing \s-1TODO\s0 test.  These will not be seen by the
user.
.Sp
Defaults to \s-1STDOUT\s0.
.IP "reset_outputs" 4
.IX Item "reset_outputs"
.Vb 1
\&  $tb\->reset_outputs;
.Ve
.Sp
Resets all the output filehandles back to their defaults.
.IP "carp" 4
.IX Item "carp"
.Vb 1
\&  $tb\->carp(@message);
.Ve
.Sp
Warns with \f(CW@message\fR but the message will appear to come from the
point where the original test function was called (\f(CW\*(C`$tb\->caller\*(C'\fR).
.IP "croak" 4
.IX Item "croak"
.Vb 1
\&  $tb\->croak(@message);
.Ve
.Sp
Dies with \f(CW@message\fR but the message will appear to come from the
point where the original test function was called (\f(CW\*(C`$tb\->caller\*(C'\fR).
.SS "Test Status and Info"
.IX Subsection "Test Status and Info"
.IP "\fBcurrent_test\fR" 4
.IX Item "current_test"
.Vb 2
\&    my $curr_test = $Test\->current_test;
\&    $Test\->current_test($num);
.Ve
.Sp
Gets/sets the current test number we're on.  You usually shouldn't
have to set this.
.Sp
If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.
.IP "\fBis_passing\fR" 4
.IX Item "is_passing"
.Vb 1
\&   my $ok = $builder\->is_passing;
.Ve
.Sp
Indicates if the test suite is currently passing.
.Sp
More formally, it will be false if anything has happened which makes
it impossible for the test suite to pass.  True otherwise.
.Sp
For example, if no tests have run \f(CW\*(C`is_passing()\*(C'\fR will be true because
even though a suite with no tests is a failure you can add a passing
test to it and start passing.
.Sp
Don't think about it too much.
.IP "\fBsummary\fR" 4
.IX Item "summary"
.Vb 1
\&    my @tests = $Test\->summary;
.Ve
.Sp
A simple summary of the tests so far.  True for pass, false for fail.
This is a logical pass/fail, so todos are passes.
.Sp
Of course, test #1 is \f(CW$tests\fR[0], etc...
.IP "\fBdetails\fR" 4
.IX Item "details"
.Vb 1
\&    my @tests = $Test\->details;
.Ve
.Sp
Like \f(CW\*(C`summary()\*(C'\fR, but with a lot more detail.
.Sp
.Vb 7
\&    $tests[$test_num \- 1] = 
\&            { \*(Aqok\*(Aq       => is the test considered a pass?
\&              actual_ok  => did it literally say \*(Aqok\*(Aq?
\&              name       => name of the test (if any)
\&              type       => type of test (if any, see below).
\&              reason     => reason for the above (if any)
\&            };
.Ve
.Sp
\&'ok' is true if Test::Harness will consider the test to be a pass.
.Sp
\&'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.
.Sp
\&'name' is the name of the test.
.Sp
\&'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:
.Sp
.Vb 4
\&    skip        see skip()
\&    todo        see todo()
\&    todo_skip   see todo_skip()
\&    unknown     see below
.Ve
.Sp
Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when \f(CW\*(C`current_test()\*(C'\fR is changed.
In these cases, Test::Builder doesn't know the result of the test, so
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left \f(CW\*(C`undef\*(C'\fR.
.Sp
For example \*(L"not ok 23 \- hole count # \s-1TODO\s0 insufficient donuts\*(R" would
result in this structure:
.Sp
.Vb 7
\&    $tests[22] =    # 23 \- 1, since arrays start from 0.
\&      { ok        => 1,   # logically, the test passed since its todo
\&        actual_ok => 0,   # in absolute terms, it failed
\&        name      => \*(Aqhole count\*(Aq,
\&        type      => \*(Aqtodo\*(Aq,
\&        reason    => \*(Aqinsufficient donuts\*(Aq
\&      };
.Ve
.IP "\fBtodo\fR" 4
.IX Item "todo"
.Vb 2
\&    my $todo_reason = $Test\->todo;
\&    my $todo_reason = $Test\->todo($pack);
.Ve
.Sp
If the current tests are considered \*(L"\s-1TODO\s0\*(R" it will return the reason,
if any.  This reason can come from a \f(CW$TODO\fR variable or the last call
to \f(CW\*(C`todo_start()\*(C'\fR.
.Sp
Since a \s-1TODO\s0 test does not need a reason, this function can return an
empty string even when inside a \s-1TODO\s0 block.  Use \f(CW\*(C`$Test\->in_todo\*(C'\fR
to determine if you are currently inside a \s-1TODO\s0 block.
.Sp
\&\f(CW\*(C`todo()\*(C'\fR is about finding the right package to look for \f(CW$TODO\fR in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on \f(CW\*(C`$Level + 1\*(C'\fR, since \f(CW\*(C`todo()\*(C'\fR is usually called inside
a test function.  As a last resort it will use \f(CW\*(C`exported_to()\*(C'\fR.
.Sp
Sometimes there is some confusion about where \fItodo()\fR should be looking
for the \f(CW$TODO\fR variable.  If you want to be sure, tell it explicitly
what \f(CW$pack\fR to use.
.IP "\fBfind_TODO\fR" 4
.IX Item "find_TODO"
.Vb 2
\&    my $todo_reason = $Test\->find_TODO();
\&    my $todo_reason = $Test\->find_TODO($pack);
.Ve
.Sp
Like \f(CW\*(C`todo()\*(C'\fR but only returns the value of \f(CW$TODO\fR ignoring
\&\f(CW\*(C`todo_start()\*(C'\fR.
.Sp
Can also be used to set \f(CW$TODO\fR to a new value while returning the
old value:
.Sp
.Vb 1
\&    my $old_reason = $Test\->find_TODO($pack, 1, $new_reason);
.Ve
.IP "\fBin_todo\fR" 4
.IX Item "in_todo"
.Vb 1
\&    my $in_todo = $Test\->in_todo;
.Ve
.Sp
Returns true if the test is currently inside a \s-1TODO\s0 block.
.IP "\fBtodo_start\fR" 4
.IX Item "todo_start"
.Vb 2
\&    $Test\->todo_start();
\&    $Test\->todo_start($message);
.Ve
.Sp
This method allows you declare all subsequent tests as \s-1TODO\s0 tests, up until
the \f(CW\*(C`todo_end\*(C'\fR method has been called.
.Sp
The \f(CW\*(C`TODO:\*(C'\fR and \f(CW$TODO\fR syntax is generally pretty good about figuring out
whether or not we're in a \s-1TODO\s0 test.  However, often we find that this is not
possible to determine (such as when we want to use \f(CW$TODO\fR but
the tests are being executed in other packages which can't be inferred
beforehand).
.Sp
Note that you can use this to nest \*(L"todo\*(R" tests
.Sp
.Vb 6
\& $Test\->todo_start(\*(Aqworking on this\*(Aq);
\& # lots of code
\& $Test\->todo_start(\*(Aqworking on that\*(Aq);
\& # more code
\& $Test\->todo_end;
\& $Test\->todo_end;
.Ve
.Sp
This is generally not recommended, but large testing systems often have weird
internal needs.
.Sp
We've tried to make this also work with the \s-1TODO:\s0 syntax, but it's not
guaranteed and its use is also discouraged:
.Sp
.Vb 9
\& TODO: {
\&     local $TODO = \*(AqWe have work to do!\*(Aq;
\&     $Test\->todo_start(\*(Aqworking on this\*(Aq);
\&     # lots of code
\&     $Test\->todo_start(\*(Aqworking on that\*(Aq);
\&     # more code
\&     $Test\->todo_end;
\&     $Test\->todo_end;
\& }
.Ve
.Sp
Pick one style or another of \*(L"\s-1TODO\s0\*(R" to be on the safe side.
.ie n .IP """todo_end""" 4
.el .IP "\f(CWtodo_end\fR" 4
.IX Item "todo_end"
.Vb 1
\& $Test\->todo_end;
.Ve
.Sp
Stops running tests as \*(L"\s-1TODO\s0\*(R" tests.  This method is fatal if called without a
preceding \f(CW\*(C`todo_start\*(C'\fR method call.
.IP "\fBcaller\fR" 4
.IX Item "caller"
.Vb 3
\&    my $package = $Test\->caller;
\&    my($pack, $file, $line) = $Test\->caller;
\&    my($pack, $file, $line) = $Test\->caller($height);
.Ve
.Sp
Like the normal \f(CW\*(C`caller()\*(C'\fR, except it reports according to your \f(CW\*(C`level()\*(C'\fR.
.Sp
\&\f(CW$height\fR will be added to the \f(CW\*(C`level()\*(C'\fR.
.Sp
If \f(CW\*(C`caller()\*(C'\fR winds up off the top of the stack it report the highest context.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.
.PP
So the exit codes are...
.PP
.Vb 3
\&    0                   all tests successful
\&    255                 test died or all passed but wrong # of tests run
\&    any other number    how many failed (including missing or extras)
.Ve
.PP
If you fail more than 254 tests, it will be reported as 254.
.SH "THREADS"
.IX Header "THREADS"
In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
number is shared amongst all threads.  This means if one thread sets
the test number using \f(CW\*(C`current_test()\*(C'\fR they will all be effected.
.PP
While versions earlier than 5.8.1 had threads they contain too many
bugs to support.
.PP
Test::Builder is only thread-aware if threads.pm is loaded \fIbefore\fR
Test::Builder.
.SH "MEMORY"
.IX Header "MEMORY"
An informative hash, accessible via \f(CW\*(C`<details()\*(C'\fR>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.
.PP
In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing \*(L"normal\*(R" (code) compares and
triggering \fIfail()\fR should anything go unexpected.
.PP
Future versions of Test::Builder will have a way to turn history off.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
\&\s-1CPAN\s0 can provide the best examples.  Test::Simple, Test::More,
Test::Exception and Test::Differences all use Test::Builder.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Simple, Test::More, Test::Harness
.SH "AUTHORS"
.IX Header "AUTHORS"
Original code by chromatic, maintained by Michael G Schwern
<schwern@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by chromatic <chromatic@wgz.org> and
                       Michael G Schwern <schwern@pobox.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder5.18.3pm                        0100644 0001750 0001750 00000073426 12566207463 024246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder 3pm"
.TH Test::Builder 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder \- Backend for building test libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package My::Test::Module;
\&  use base \*(AqTest::Builder::Module\*(Aq;
\&
\&  my $CLASS = _\|_PACKAGE_\|_;
\&
\&  sub ok {
\&      my($test, $name) = @_;
\&      my $tb = $CLASS\->builder;
\&
\&      $tb\->ok($test, $name);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::Simple and Test::More have proven to be popular testing modules,
but they're not always flexible enough.  Test::Builder provides a
building block upon which to write your own test libraries \fIwhich can
work together\fR.
.SS "Construction"
.IX Subsection "Construction"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  my $Test = Test::Builder\->new;
.Ve
.Sp
Returns a Test::Builder object representing the current state of the
test.
.Sp
Since you only run one test per program \f(CW\*(C`new\*(C'\fR always returns the same
Test::Builder object.  No matter how many times you call \f(CW\*(C`new()\*(C'\fR, you're
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.
.Sp
If you want a completely new Test::Builder object different from the
singleton, use \f(CW\*(C`create\*(C'\fR.
.IP "\fBcreate\fR" 4
.IX Item "create"
.Vb 1
\&  my $Test = Test::Builder\->create;
.Ve
.Sp
Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of \f(CW\*(C`new()\*(C'\fR if you're testing
a Test::Builder based module, but otherwise you probably want \f(CW\*(C`new\*(C'\fR.
.Sp
\&\fB\s-1NOTE\s0\fR: the implementation is not complete.  \f(CW\*(C`level\*(C'\fR, for example, is
still shared amongst \fBall\fR Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.
.IP "\fBchild\fR" 4
.IX Item "child"
.Vb 5
\&  my $child = $builder\->child($name_of_child);
\&  $child\->plan( tests => 4 );
\&  $child\->ok(some_code());
\&  ...
\&  $child\->finalize;
.Ve
.Sp
Returns a new instance of \f(CW\*(C`Test::Builder\*(C'\fR.  Any output from this child will
be indented four spaces more than the parent's indentation.  When done, the
\&\f(CW\*(C`finalize\*(C'\fR method \fImust\fR be called explicitly.
.Sp
Trying to create a new child with a previous child still active (i.e.,
\&\f(CW\*(C`finalize\*(C'\fR not called) will \f(CW\*(C`croak\*(C'\fR.
.Sp
Trying to run a test when you have an open child will also \f(CW\*(C`croak\*(C'\fR and cause
the test suite to fail.
.IP "\fBsubtest\fR" 4
.IX Item "subtest"
.Vb 1
\&    $builder\->subtest($name, \e&subtests);
.Ve
.Sp
See documentation of \f(CW\*(C`subtest\*(C'\fR in Test::More.
.IP "\fBfinalize\fR" 4
.IX Item "finalize"
.Vb 1
\&  my $ok = $child\->finalize;
.Ve
.Sp
When your child is done running tests, you must call \f(CW\*(C`finalize\*(C'\fR to clean up
and tell the parent your pass/fail status.
.Sp
Calling finalize on a child with open children will \f(CW\*(C`croak\*(C'\fR.
.Sp
If the child falls out of scope before \f(CW\*(C`finalize\*(C'\fR is called, a failure
diagnostic will be issued and the child is considered to have failed.
.Sp
No attempt to call methods on a child after \f(CW\*(C`finalize\*(C'\fR is called is
guaranteed to succeed.
.Sp
Calling this on the root builder is a no-op.
.IP "\fBparent\fR" 4
.IX Item "parent"
.Vb 3
\& if ( my $parent = $builder\->parent ) {
\&     ...
\& }
.Ve
.Sp
Returns the parent \f(CW\*(C`Test::Builder\*(C'\fR instance, if any.  Only used with child
builders for nested \s-1TAP.\s0
.IP "\fBname\fR" 4
.IX Item "name"
.Vb 1
\& diag $builder\->name;
.Ve
.Sp
Returns the name of the current builder.  Top level builders default to \f(CW$0\fR
(the name of the executable).  Child builders are named via the \f(CW\*(C`child\*(C'\fR
method.  If no name is supplied, will be named \*(L"Child of \f(CW$parent\fR\->name\*(R".
.IP "\fBreset\fR" 4
.IX Item "reset"
.Vb 1
\&  $Test\->reset;
.Ve
.Sp
Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.
.SS "Setting up tests"
.IX Subsection "Setting up tests"
These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.
.IP "\fBplan\fR" 4
.IX Item "plan"
.Vb 3
\&  $Test\->plan(\*(Aqno_plan\*(Aq);
\&  $Test\->plan( skip_all => $reason );
\&  $Test\->plan( tests => $num_tests );
.Ve
.Sp
A convenient way to set up your tests.  Call this and Test::Builder
will print the appropriate headers and take the appropriate actions.
.Sp
If you call \f(CW\*(C`plan()\*(C'\fR, don't call any of the other methods below.
.Sp
If a child calls \*(L"skip_all\*(R" in the plan, a \f(CW\*(C`Test::Builder::Exception\*(C'\fR is
thrown.  Trap this error, call \f(CW\*(C`finalize()\*(C'\fR and don't run any more tests on
the child.
.Sp
.Vb 7
\& my $child = $Test\->child(\*(Aqsome child\*(Aq);
\& eval { $child\->plan( $condition ? ( skip_all => $reason ) : ( tests => 3 )  ) };
\& if ( eval { $@\->isa(\*(AqTest::Builder::Exception\*(Aq) } ) {
\&    $child\->finalize;
\&    return;
\& }
\& # run your tests
.Ve
.IP "\fBexpected_tests\fR" 4
.IX Item "expected_tests"
.Vb 2
\&    my $max = $Test\->expected_tests;
\&    $Test\->expected_tests($max);
.Ve
.Sp
Gets/sets the number of tests we expect this test to run and prints out
the appropriate headers.
.IP "\fBno_plan\fR" 4
.IX Item "no_plan"
.Vb 1
\&  $Test\->no_plan;
.Ve
.Sp
Declares that this test will run an indeterminate number of tests.
.IP "\fBdone_testing\fR" 4
.IX Item "done_testing"
.Vb 2
\&  $Test\->done_testing();
\&  $Test\->done_testing($num_tests);
.Ve
.Sp
Declares that you are done testing, no more tests will be run after this point.
.Sp
If a plan has not yet been output, it will do so.
.Sp
\&\f(CW$num_tests\fR is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If \f(CW\*(C`no_plan\*(C'\fR was declared,
this will override.
.Sp
If \f(CW\*(C`done_testing()\*(C'\fR is called twice, the second call will issue a
failing test.
.Sp
If \f(CW$num_tests\fR is omitted, the number of tests run will be used, like
no_plan.
.Sp
\&\f(CW\*(C`done_testing()\*(C'\fR is, in effect, used when you'd want to use \f(CW\*(C`no_plan\*(C'\fR, but
safer. You'd use it like so:
.Sp
.Vb 2
\&    $Test\->ok($a == $b);
\&    $Test\->done_testing();
.Ve
.Sp
Or to plan a variable number of tests:
.Sp
.Vb 4
\&    for my $test (@tests) {
\&        $Test\->ok($test);
\&    }
\&    $Test\->done_testing(@tests);
.Ve
.IP "\fBhas_plan\fR" 4
.IX Item "has_plan"
.Vb 1
\&  $plan = $Test\->has_plan
.Ve
.Sp
Find out whether a plan has been defined. \f(CW$plan\fR is either \f(CW\*(C`undef\*(C'\fR (no plan
has been set), \f(CW\*(C`no_plan\*(C'\fR (indeterminate # of tests) or an integer (the number
of expected tests).
.IP "\fBskip_all\fR" 4
.IX Item "skip_all"
.Vb 2
\&  $Test\->skip_all;
\&  $Test\->skip_all($reason);
.Ve
.Sp
Skips all the tests, using the given \f(CW$reason\fR.  Exits immediately with 0.
.IP "\fBexported_to\fR" 4
.IX Item "exported_to"
.Vb 2
\&  my $pack = $Test\->exported_to;
\&  $Test\->exported_to($pack);
.Ve
.Sp
Tells Test::Builder what package you exported your functions to.
.Sp
This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.
.SS "Running tests"
.IX Subsection "Running tests"
These actually run the tests, analogous to the functions in Test::More.
.PP
They all return true if the test passed, false if the test failed.
.PP
\&\f(CW$name\fR is always optional.
.IP "\fBok\fR" 4
.IX Item "ok"
.Vb 1
\&  $Test\->ok($test, $name);
.Ve
.Sp
Your basic test.  Pass if \f(CW$test\fR is true, fail if \f(CW$test\fR is false.  Just
like Test::Simple's \f(CW\*(C`ok()\*(C'\fR.
.IP "\fBis_eq\fR" 4
.IX Item "is_eq"
.Vb 1
\&  $Test\->is_eq($got, $expected, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`is()\*(C'\fR.  Checks if \f(CW\*(C`$got eq $expected\*(C'\fR.  This is the
string version.
.Sp
\&\f(CW\*(C`undef\*(C'\fR only ever matches another \f(CW\*(C`undef\*(C'\fR.
.IP "\fBis_num\fR" 4
.IX Item "is_num"
.Vb 1
\&  $Test\->is_num($got, $expected, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`is()\*(C'\fR.  Checks if \f(CW\*(C`$got == $expected\*(C'\fR.  This is the
numeric version.
.Sp
\&\f(CW\*(C`undef\*(C'\fR only ever matches another \f(CW\*(C`undef\*(C'\fR.
.IP "\fBisnt_eq\fR" 4
.IX Item "isnt_eq"
.Vb 1
\&  $Test\->isnt_eq($got, $dont_expect, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`isnt()\*(C'\fR.  Checks if \f(CW\*(C`$got ne $dont_expect\*(C'\fR.  This is
the string version.
.IP "\fBisnt_num\fR" 4
.IX Item "isnt_num"
.Vb 1
\&  $Test\->isnt_num($got, $dont_expect, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`isnt()\*(C'\fR.  Checks if \f(CW\*(C`$got ne $dont_expect\*(C'\fR.  This is
the numeric version.
.IP "\fBlike\fR" 4
.IX Item "like"
.Vb 2
\&  $Test\->like($this, qr/$regex/, $name);
\&  $Test\->like($this, \*(Aq/$regex/\*(Aq, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`like()\*(C'\fR.  Checks if \f(CW$this\fR matches the given \f(CW$regex\fR.
.IP "\fBunlike\fR" 4
.IX Item "unlike"
.Vb 2
\&  $Test\->unlike($this, qr/$regex/, $name);
\&  $Test\->unlike($this, \*(Aq/$regex/\*(Aq, $name);
.Ve
.Sp
Like Test::More's \f(CW\*(C`unlike()\*(C'\fR.  Checks if \f(CW$this\fR \fBdoes not match\fR the
given \f(CW$regex\fR.
.IP "\fBcmp_ok\fR" 4
.IX Item "cmp_ok"
.Vb 1
\&  $Test\->cmp_ok($this, $type, $that, $name);
.Ve
.Sp
Works just like Test::More's \f(CW\*(C`cmp_ok()\*(C'\fR.
.Sp
.Vb 1
\&    $Test\->cmp_ok($big_num, \*(Aq!=\*(Aq, $other_big_num);
.Ve
.SS "Other Testing Methods"
.IX Subsection "Other Testing Methods"
These are methods which are used in the course of writing a test but are not themselves tests.
.IP "\fB\s-1BAIL_OUT\s0\fR" 4
.IX Item "BAIL_OUT"
.Vb 1
\&    $Test\->BAIL_OUT($reason);
.Ve
.Sp
Indicates to the Test::Harness that things are going so badly all
testing should terminate.  This includes running any additional test
scripts.
.Sp
It will exit with 255.
.IP "\fBskip\fR" 4
.IX Item "skip"
.Vb 2
\&    $Test\->skip;
\&    $Test\->skip($why);
.Ve
.Sp
Skips the current test, reporting \f(CW$why\fR.
.IP "\fBtodo_skip\fR" 4
.IX Item "todo_skip"
.Vb 2
\&  $Test\->todo_skip;
\&  $Test\->todo_skip($why);
.Ve
.Sp
Like \f(CW\*(C`skip()\*(C'\fR, only it will declare the test as failing and \s-1TODO. \s0 Similar
to
.Sp
.Vb 1
\&    print "not ok $tnum # TODO $why\en";
.Ve
.SS "Test building utility methods"
.IX Subsection "Test building utility methods"
These methods are useful when writing your own test methods.
.IP "\fBmaybe_regex\fR" 4
.IX Item "maybe_regex"
.Vb 2
\&  $Test\->maybe_regex(qr/$regex/);
\&  $Test\->maybe_regex(\*(Aq/$regex/\*(Aq);
.Ve
.Sp
This method used to be useful back when Test::Builder worked on Perls
before 5.6 which didn't have qr//.  Now its pretty useless.
.Sp
Convenience method for building testing functions that take regular
expressions as arguments.
.Sp
Takes a quoted regular expression produced by \f(CW\*(C`qr//\*(C'\fR, or a string
representing a regular expression.
.Sp
Returns a Perl value which may be used instead of the corresponding
regular expression, or \f(CW\*(C`undef\*(C'\fR if its argument is not recognised.
.Sp
For example, a version of \f(CW\*(C`like()\*(C'\fR, sans the useful diagnostic messages,
could be written as:
.Sp
.Vb 7
\&  sub laconic_like {
\&      my ($self, $this, $regex, $name) = @_;
\&      my $usable_regex = $self\->maybe_regex($regex);
\&      die "expecting regex, found \*(Aq$regex\*(Aq\en"
\&          unless $usable_regex;
\&      $self\->ok($this =~ m/$usable_regex/, $name);
\&  }
.Ve
.IP "\fBis_fh\fR" 4
.IX Item "is_fh"
.Vb 1
\&    my $is_fh = $Test\->is_fh($thing);
.Ve
.Sp
Determines if the given \f(CW$thing\fR can be used as a filehandle.
.SS "Test style"
.IX Subsection "Test style"
.IP "\fBlevel\fR" 4
.IX Item "level"
.Vb 1
\&    $Test\->level($how_high);
.Ve
.Sp
How far up the call stack should \f(CW$Test\fR look when reporting where the
test failed.
.Sp
Defaults to 1.
.Sp
Setting \f(CW$Test::Builder::Level\fR overrides.  This is typically useful
localized:
.Sp
.Vb 2
\&    sub my_ok {
\&        my $test = shift;
\&
\&        local $Test::Builder::Level = $Test::Builder::Level + 1;
\&        $TB\->ok($test);
\&    }
.Ve
.Sp
To be polite to other functions wrapping your own you usually want to increment \f(CW$Level\fR rather than set it to a constant.
.IP "\fBuse_numbers\fR" 4
.IX Item "use_numbers"
.Vb 1
\&    $Test\->use_numbers($on_or_off);
.Ve
.Sp
Whether or not the test should output numbers.  That is, this if true:
.Sp
.Vb 3
\&  ok 1
\&  ok 2
\&  ok 3
.Ve
.Sp
or this if false
.Sp
.Vb 3
\&  ok
\&  ok
\&  ok
.Ve
.Sp
Most useful when you can't depend on the test output order, such as
when threads or forking is involved.
.Sp
Defaults to on.
.IP "\fBno_diag\fR" 4
.IX Item "no_diag"
.Vb 1
\&    $Test\->no_diag($no_diag);
.Ve
.Sp
If set true no diagnostics will be printed.  This includes calls to
\&\f(CW\*(C`diag()\*(C'\fR.
.IP "\fBno_ending\fR" 4
.IX Item "no_ending"
.Vb 1
\&    $Test\->no_ending($no_ending);
.Ve
.Sp
Normally, Test::Builder does some extra diagnostics when the test
ends.  It also changes the exit code as described below.
.Sp
If this is true, none of that will be done.
.IP "\fBno_header\fR" 4
.IX Item "no_header"
.Vb 1
\&    $Test\->no_header($no_header);
.Ve
.Sp
If set to true, no \*(L"1..N\*(R" header will be printed.
.SS "Output"
.IX Subsection "Output"
Controlling where the test output goes.
.PP
It's ok for your test to change where \s-1STDOUT\s0 and \s-1STDERR\s0 point to,
Test::Builder's default output settings will not be affected.
.IP "\fBdiag\fR" 4
.IX Item "diag"
.Vb 1
\&    $Test\->diag(@msgs);
.Ve
.Sp
Prints out the given \f(CW@msgs\fR.  Like \f(CW\*(C`print\*(C'\fR, arguments are simply
appended together.
.Sp
Normally, it uses the \f(CW\*(C`failure_output()\*(C'\fR handle, but if this is for a
\&\s-1TODO\s0 test, the \f(CW\*(C`todo_output()\*(C'\fR handle is used.
.Sp
Output will be indented and marked with a # so as not to interfere
with test output.  A newline will be put on the end if there isn't one
already.
.Sp
We encourage using this rather than calling print directly.
.Sp
Returns false.  Why?  Because \f(CW\*(C`diag()\*(C'\fR is often used in conjunction with
a failing test (\f(CW\*(C`ok() || diag()\*(C'\fR) it \*(L"passes through\*(R" the failure.
.Sp
.Vb 1
\&    return ok(...) || diag(...);
.Ve
.IP "\fBnote\fR" 4
.IX Item "note"
.Vb 1
\&    $Test\->note(@msgs);
.Ve
.Sp
Like \f(CW\*(C`diag()\*(C'\fR, but it prints to the \f(CW\*(C`output()\*(C'\fR handle so it will not
normally be seen by the user except in verbose mode.
.IP "\fBexplain\fR" 4
.IX Item "explain"
.Vb 1
\&    my @dump = $Test\->explain(@msgs);
.Ve
.Sp
Will dump the contents of any references in a human readable format.
Handy for things like...
.Sp
.Vb 1
\&    is_deeply($have, $want) || diag explain $have;
.Ve
.Sp
or
.Sp
.Vb 1
\&    is_deeply($have, $want) || note explain $have;
.Ve
.IP "\fBoutput\fR" 4
.IX Item "output"
.PD 0
.IP "\fBfailure_output\fR" 4
.IX Item "failure_output"
.IP "\fBtodo_output\fR" 4
.IX Item "todo_output"
.PD
.Vb 4
\&    my $filehandle = $Test\->output;
\&    $Test\->output($filehandle);
\&    $Test\->output($filename);
\&    $Test\->output(\e$scalar);
.Ve
.Sp
These methods control where Test::Builder will print its output.
They take either an open \f(CW$filehandle\fR, a \f(CW$filename\fR to open and write to
or a \f(CW$scalar\fR reference to append to.  It will always return a \f(CW$filehandle\fR.
.Sp
\&\fBoutput\fR is where normal \*(L"ok/not ok\*(R" test output goes.
.Sp
Defaults to \s-1STDOUT.\s0
.Sp
\&\fBfailure_output\fR is where diagnostic output on test failures and
\&\f(CW\*(C`diag()\*(C'\fR goes.  It is normally not read by Test::Harness and instead is
displayed to the user.
.Sp
Defaults to \s-1STDERR.\s0
.Sp
\&\f(CW\*(C`todo_output\*(C'\fR is used instead of \f(CW\*(C`failure_output()\*(C'\fR for the
diagnostics of a failing \s-1TODO\s0 test.  These will not be seen by the
user.
.Sp
Defaults to \s-1STDOUT.\s0
.IP "reset_outputs" 4
.IX Item "reset_outputs"
.Vb 1
\&  $tb\->reset_outputs;
.Ve
.Sp
Resets all the output filehandles back to their defaults.
.IP "carp" 4
.IX Item "carp"
.Vb 1
\&  $tb\->carp(@message);
.Ve
.Sp
Warns with \f(CW@message\fR but the message will appear to come from the
point where the original test function was called (\f(CW\*(C`$tb\->caller\*(C'\fR).
.IP "croak" 4
.IX Item "croak"
.Vb 1
\&  $tb\->croak(@message);
.Ve
.Sp
Dies with \f(CW@message\fR but the message will appear to come from the
point where the original test function was called (\f(CW\*(C`$tb\->caller\*(C'\fR).
.SS "Test Status and Info"
.IX Subsection "Test Status and Info"
.IP "\fBcurrent_test\fR" 4
.IX Item "current_test"
.Vb 2
\&    my $curr_test = $Test\->current_test;
\&    $Test\->current_test($num);
.Ve
.Sp
Gets/sets the current test number we're on.  You usually shouldn't
have to set this.
.Sp
If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.
.IP "\fBis_passing\fR" 4
.IX Item "is_passing"
.Vb 1
\&   my $ok = $builder\->is_passing;
.Ve
.Sp
Indicates if the test suite is currently passing.
.Sp
More formally, it will be false if anything has happened which makes
it impossible for the test suite to pass.  True otherwise.
.Sp
For example, if no tests have run \f(CW\*(C`is_passing()\*(C'\fR will be true because
even though a suite with no tests is a failure you can add a passing
test to it and start passing.
.Sp
Don't think about it too much.
.IP "\fBsummary\fR" 4
.IX Item "summary"
.Vb 1
\&    my @tests = $Test\->summary;
.Ve
.Sp
A simple summary of the tests so far.  True for pass, false for fail.
This is a logical pass/fail, so todos are passes.
.Sp
Of course, test #1 is \f(CW$tests\fR[0], etc...
.IP "\fBdetails\fR" 4
.IX Item "details"
.Vb 1
\&    my @tests = $Test\->details;
.Ve
.Sp
Like \f(CW\*(C`summary()\*(C'\fR, but with a lot more detail.
.Sp
.Vb 7
\&    $tests[$test_num \- 1] = 
\&            { \*(Aqok\*(Aq       => is the test considered a pass?
\&              actual_ok  => did it literally say \*(Aqok\*(Aq?
\&              name       => name of the test (if any)
\&              type       => type of test (if any, see below).
\&              reason     => reason for the above (if any)
\&            };
.Ve
.Sp
\&'ok' is true if Test::Harness will consider the test to be a pass.
.Sp
\&'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.
.Sp
\&'name' is the name of the test.
.Sp
\&'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:
.Sp
.Vb 4
\&    skip        see skip()
\&    todo        see todo()
\&    todo_skip   see todo_skip()
\&    unknown     see below
.Ve
.Sp
Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when \f(CW\*(C`current_test()\*(C'\fR is changed.
In these cases, Test::Builder doesn't know the result of the test, so
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left \f(CW\*(C`undef\*(C'\fR.
.Sp
For example \*(L"not ok 23 \- hole count # \s-1TODO\s0 insufficient donuts\*(R" would
result in this structure:
.Sp
.Vb 7
\&    $tests[22] =    # 23 \- 1, since arrays start from 0.
\&      { ok        => 1,   # logically, the test passed since its todo
\&        actual_ok => 0,   # in absolute terms, it failed
\&        name      => \*(Aqhole count\*(Aq,
\&        type      => \*(Aqtodo\*(Aq,
\&        reason    => \*(Aqinsufficient donuts\*(Aq
\&      };
.Ve
.IP "\fBtodo\fR" 4
.IX Item "todo"
.Vb 2
\&    my $todo_reason = $Test\->todo;
\&    my $todo_reason = $Test\->todo($pack);
.Ve
.Sp
If the current tests are considered \*(L"\s-1TODO\*(R"\s0 it will return the reason,
if any.  This reason can come from a \f(CW$TODO\fR variable or the last call
to \f(CW\*(C`todo_start()\*(C'\fR.
.Sp
Since a \s-1TODO\s0 test does not need a reason, this function can return an
empty string even when inside a \s-1TODO\s0 block.  Use \f(CW\*(C`$Test\->in_todo\*(C'\fR
to determine if you are currently inside a \s-1TODO\s0 block.
.Sp
\&\f(CW\*(C`todo()\*(C'\fR is about finding the right package to look for \f(CW$TODO\fR in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on \f(CW\*(C`$Level + 1\*(C'\fR, since \f(CW\*(C`todo()\*(C'\fR is usually called inside
a test function.  As a last resort it will use \f(CW\*(C`exported_to()\*(C'\fR.
.Sp
Sometimes there is some confusion about where \fItodo()\fR should be looking
for the \f(CW$TODO\fR variable.  If you want to be sure, tell it explicitly
what \f(CW$pack\fR to use.
.IP "\fBfind_TODO\fR" 4
.IX Item "find_TODO"
.Vb 2
\&    my $todo_reason = $Test\->find_TODO();
\&    my $todo_reason = $Test\->find_TODO($pack);
.Ve
.Sp
Like \f(CW\*(C`todo()\*(C'\fR but only returns the value of \f(CW$TODO\fR ignoring
\&\f(CW\*(C`todo_start()\*(C'\fR.
.Sp
Can also be used to set \f(CW$TODO\fR to a new value while returning the
old value:
.Sp
.Vb 1
\&    my $old_reason = $Test\->find_TODO($pack, 1, $new_reason);
.Ve
.IP "\fBin_todo\fR" 4
.IX Item "in_todo"
.Vb 1
\&    my $in_todo = $Test\->in_todo;
.Ve
.Sp
Returns true if the test is currently inside a \s-1TODO\s0 block.
.IP "\fBtodo_start\fR" 4
.IX Item "todo_start"
.Vb 2
\&    $Test\->todo_start();
\&    $Test\->todo_start($message);
.Ve
.Sp
This method allows you declare all subsequent tests as \s-1TODO\s0 tests, up until
the \f(CW\*(C`todo_end\*(C'\fR method has been called.
.Sp
The \f(CW\*(C`TODO:\*(C'\fR and \f(CW$TODO\fR syntax is generally pretty good about figuring out
whether or not we're in a \s-1TODO\s0 test.  However, often we find that this is not
possible to determine (such as when we want to use \f(CW$TODO\fR but
the tests are being executed in other packages which can't be inferred
beforehand).
.Sp
Note that you can use this to nest \*(L"todo\*(R" tests
.Sp
.Vb 6
\& $Test\->todo_start(\*(Aqworking on this\*(Aq);
\& # lots of code
\& $Test\->todo_start(\*(Aqworking on that\*(Aq);
\& # more code
\& $Test\->todo_end;
\& $Test\->todo_end;
.Ve
.Sp
This is generally not recommended, but large testing systems often have weird
internal needs.
.Sp
We've tried to make this also work with the \s-1TODO:\s0 syntax, but it's not
guaranteed and its use is also discouraged:
.Sp
.Vb 9
\& TODO: {
\&     local $TODO = \*(AqWe have work to do!\*(Aq;
\&     $Test\->todo_start(\*(Aqworking on this\*(Aq);
\&     # lots of code
\&     $Test\->todo_start(\*(Aqworking on that\*(Aq);
\&     # more code
\&     $Test\->todo_end;
\&     $Test\->todo_end;
\& }
.Ve
.Sp
Pick one style or another of \*(L"\s-1TODO\*(R"\s0 to be on the safe side.
.ie n .IP """todo_end""" 4
.el .IP "\f(CWtodo_end\fR" 4
.IX Item "todo_end"
.Vb 1
\& $Test\->todo_end;
.Ve
.Sp
Stops running tests as \*(L"\s-1TODO\*(R"\s0 tests.  This method is fatal if called without a
preceding \f(CW\*(C`todo_start\*(C'\fR method call.
.IP "\fBcaller\fR" 4
.IX Item "caller"
.Vb 3
\&    my $package = $Test\->caller;
\&    my($pack, $file, $line) = $Test\->caller;
\&    my($pack, $file, $line) = $Test\->caller($height);
.Ve
.Sp
Like the normal \f(CW\*(C`caller()\*(C'\fR, except it reports according to your \f(CW\*(C`level()\*(C'\fR.
.Sp
\&\f(CW$height\fR will be added to the \f(CW\*(C`level()\*(C'\fR.
.Sp
If \f(CW\*(C`caller()\*(C'\fR winds up off the top of the stack it report the highest context.
.SH "EXIT CODES"
.IX Header "EXIT CODES"
If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.
.PP
So the exit codes are...
.PP
.Vb 3
\&    0                   all tests successful
\&    255                 test died or all passed but wrong # of tests run
\&    any other number    how many failed (including missing or extras)
.Ve
.PP
If you fail more than 254 tests, it will be reported as 254.
.SH "THREADS"
.IX Header "THREADS"
In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
number is shared amongst all threads.  This means if one thread sets
the test number using \f(CW\*(C`current_test()\*(C'\fR they will all be effected.
.PP
While versions earlier than 5.8.1 had threads they contain too many
bugs to support.
.PP
Test::Builder is only thread-aware if threads.pm is loaded \fIbefore\fR
Test::Builder.
.SH "MEMORY"
.IX Header "MEMORY"
An informative hash, accessible via \f(CW\*(C`<details()\*(C'\fR>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.
.PP
In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing \*(L"normal\*(R" (code) compares and
triggering \fIfail()\fR should anything go unexpected.
.PP
Future versions of Test::Builder will have a way to turn history off.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
\&\s-1CPAN\s0 can provide the best examples.  Test::Simple, Test::More,
Test::Exception and Test::Differences all use Test::Builder.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Simple, Test::More, Test::Harness
.SH "AUTHORS"
.IX Header "AUTHORS"
Original code by chromatic, maintained by Michael G Schwern
<schwern@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by chromatic <chromatic@wgz.org> and
                       Michael G Schwern <schwern@pobox.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder::Module.3pm                    0100644 0001750 0001750 00000016043 12566207463 025254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder::Module 3pm"
.TH Test::Builder::Module 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder::Module \- Base class for test modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Emulates Test::Simple
\&  package Your::Module;
\&
\&  my $CLASS = _\|_PACKAGE_\|_;
\&
\&  use base \*(AqTest::Builder::Module\*(Aq;
\&  @EXPORT = qw(ok);
\&
\&  sub ok ($;$) {
\&      my $tb = $CLASS\->builder;
\&      return $tb\->ok(@_);
\&  }
\&  
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a superclass for Test::Builder\-based modules.  It provides a
handful of common functionality and a method of getting at the underlying
Test::Builder object.
.SS "Importing"
.IX Subsection "Importing"
Test::Builder::Module is a subclass of Exporter which means your
module is also a subclass of Exporter.  \f(CW@EXPORT\fR, \f(CW@EXPORT_OK\fR, etc...
all act normally.
.PP
A few methods are provided to do the \f(CW\*(C`use Your::Module tests =\*(C'\fR 23> part
for you.
.PP
\fIimport\fR
.IX Subsection "import"
.PP
Test::Builder::Module provides an \fIimport()\fR method which acts in the
same basic way as Test::More's, setting the plan and controlling
exporting of functions and variables.  This allows your module to set
the plan independent of Test::More.
.PP
All arguments passed to \fIimport()\fR are passed onto 
\&\f(CW\*(C`Your::Module\->builder\->plan()\*(C'\fR with the exception of 
\&\f(CW\*(C`import =>[qw(things to import)]\*(C'\fR.
.PP
.Vb 1
\&    use Your::Module import => [qw(this that)], tests => 23;
.Ve
.PP
says to import the functions \fIthis()\fR and \fIthat()\fR as well as set the plan
to be 23 tests.
.PP
\&\fIimport()\fR also sets the \fIexported_to()\fR attribute of your builder to be
the caller of the \fIimport()\fR function.
.PP
Additional behaviors can be added to your \fIimport()\fR method by overriding
\&\fIimport_extra()\fR.
.PP
\fIimport_extra\fR
.IX Subsection "import_extra"
.PP
.Vb 1
\&    Your::Module\->import_extra(\e@import_args);
.Ve
.PP
\&\fIimport_extra()\fR is called by \fIimport()\fR.  It provides an opportunity for you
to add behaviors to your module based on its import list.
.PP
Any extra arguments which shouldn't be passed on to \fIplan()\fR should be 
stripped off by this method.
.PP
See Test::More for an example of its use.
.PP
\&\fB\s-1NOTE\s0\fR This mechanism is \fI\s-1VERY ALPHA AND LIKELY TO CHANGE\s0\fR as it
feels like a bit of an ugly hack in its current form.
.SS "Builder"
.IX Subsection "Builder"
Test::Builder::Module provides some methods of getting at the underlying
Test::Builder object.
.PP
\fIbuilder\fR
.IX Subsection "builder"
.PP
.Vb 1
\&  my $builder = Your::Class\->builder;
.Ve
.PP
This method returns the Test::Builder object associated with Your::Class.
It is not a constructor so you can call it as often as you like.
.PP
This is the preferred way to get the Test::Builder object.  You should
\&\fInot\fR get it via \f(CW\*(C`Test::Builder\->new\*(C'\fR as was previously
recommended.
.PP
The object returned by \fIbuilder()\fR may change at runtime so you should
call \fIbuilder()\fR inside each function rather than store it in a global.
.PP
.Vb 2
\&  sub ok {
\&      my $builder = Your::Class\->builder;
\&
\&      return $builder\->ok(@_);
\&  }
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder::Module5.16.3pm                0100644 0001750 0001750 00000015565 12566207441 025572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder::Module 3pm"
.TH Test::Builder::Module 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder::Module \- Base class for test modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Emulates Test::Simple
\&  package Your::Module;
\&
\&  my $CLASS = _\|_PACKAGE_\|_;
\&
\&  use base \*(AqTest::Builder::Module\*(Aq;
\&  @EXPORT = qw(ok);
\&
\&  sub ok ($;$) {
\&      my $tb = $CLASS\->builder;
\&      return $tb\->ok(@_);
\&  }
\&  
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a superclass for Test::Builder\-based modules.  It provides a
handful of common functionality and a method of getting at the underlying
Test::Builder object.
.SS "Importing"
.IX Subsection "Importing"
Test::Builder::Module is a subclass of Exporter which means your
module is also a subclass of Exporter.  \f(CW@EXPORT\fR, \f(CW@EXPORT_OK\fR, etc...
all act normally.
.PP
A few methods are provided to do the \f(CW\*(C`use Your::Module tests =\*(C'\fR 23> part
for you.
.PP
\fIimport\fR
.IX Subsection "import"
.PP
Test::Builder::Module provides an \fIimport()\fR method which acts in the
same basic way as Test::More's, setting the plan and controlling
exporting of functions and variables.  This allows your module to set
the plan independent of Test::More.
.PP
All arguments passed to \fIimport()\fR are passed onto 
\&\f(CW\*(C`Your::Module\->builder\->plan()\*(C'\fR with the exception of 
\&\f(CW\*(C`import =>[qw(things to import)]\*(C'\fR.
.PP
.Vb 1
\&    use Your::Module import => [qw(this that)], tests => 23;
.Ve
.PP
says to import the functions \fIthis()\fR and \fIthat()\fR as well as set the plan
to be 23 tests.
.PP
\&\fIimport()\fR also sets the \fIexported_to()\fR attribute of your builder to be
the caller of the \fIimport()\fR function.
.PP
Additional behaviors can be added to your \fIimport()\fR method by overriding
\&\fIimport_extra()\fR.
.PP
\fIimport_extra\fR
.IX Subsection "import_extra"
.PP
.Vb 1
\&    Your::Module\->import_extra(\e@import_args);
.Ve
.PP
\&\fIimport_extra()\fR is called by \fIimport()\fR.  It provides an opportunity for you
to add behaviors to your module based on its import list.
.PP
Any extra arguments which shouldn't be passed on to \fIplan()\fR should be 
stripped off by this method.
.PP
See Test::More for an example of its use.
.PP
\&\fB\s-1NOTE\s0\fR This mechanism is \fI\s-1VERY\s0 \s-1ALPHA\s0 \s-1AND\s0 \s-1LIKELY\s0 \s-1TO\s0 \s-1CHANGE\s0\fR as it
feels like a bit of an ugly hack in its current form.
.SS "Builder"
.IX Subsection "Builder"
Test::Builder::Module provides some methods of getting at the underlying
Test::Builder object.
.PP
\fIbuilder\fR
.IX Subsection "builder"
.PP
.Vb 1
\&  my $builder = Your::Class\->builder;
.Ve
.PP
This method returns the Test::Builder object associated with Your::Class.
It is not a constructor so you can call it as often as you like.
.PP
This is the preferred way to get the Test::Builder object.  You should
\&\fInot\fR get it via \f(CW\*(C`Test::Builder\->new\*(C'\fR as was previously
recommended.
.PP
The object returned by \fIbuilder()\fR may change at runtime so you should
call \fIbuilder()\fR inside each function rather than store it in a global.
.PP
.Vb 2
\&  sub ok {
\&      my $builder = Your::Class\->builder;
\&
\&      return $builder\->ok(@_);
\&  }
.Ve
                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder::Module5.18.3pm                0100644 0001750 0001750 00000016043 12566207463 025570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder::Module 3pm"
.TH Test::Builder::Module 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder::Module \- Base class for test modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Emulates Test::Simple
\&  package Your::Module;
\&
\&  my $CLASS = _\|_PACKAGE_\|_;
\&
\&  use base \*(AqTest::Builder::Module\*(Aq;
\&  @EXPORT = qw(ok);
\&
\&  sub ok ($;$) {
\&      my $tb = $CLASS\->builder;
\&      return $tb\->ok(@_);
\&  }
\&  
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a superclass for Test::Builder\-based modules.  It provides a
handful of common functionality and a method of getting at the underlying
Test::Builder object.
.SS "Importing"
.IX Subsection "Importing"
Test::Builder::Module is a subclass of Exporter which means your
module is also a subclass of Exporter.  \f(CW@EXPORT\fR, \f(CW@EXPORT_OK\fR, etc...
all act normally.
.PP
A few methods are provided to do the \f(CW\*(C`use Your::Module tests =\*(C'\fR 23> part
for you.
.PP
\fIimport\fR
.IX Subsection "import"
.PP
Test::Builder::Module provides an \fIimport()\fR method which acts in the
same basic way as Test::More's, setting the plan and controlling
exporting of functions and variables.  This allows your module to set
the plan independent of Test::More.
.PP
All arguments passed to \fIimport()\fR are passed onto 
\&\f(CW\*(C`Your::Module\->builder\->plan()\*(C'\fR with the exception of 
\&\f(CW\*(C`import =>[qw(things to import)]\*(C'\fR.
.PP
.Vb 1
\&    use Your::Module import => [qw(this that)], tests => 23;
.Ve
.PP
says to import the functions \fIthis()\fR and \fIthat()\fR as well as set the plan
to be 23 tests.
.PP
\&\fIimport()\fR also sets the \fIexported_to()\fR attribute of your builder to be
the caller of the \fIimport()\fR function.
.PP
Additional behaviors can be added to your \fIimport()\fR method by overriding
\&\fIimport_extra()\fR.
.PP
\fIimport_extra\fR
.IX Subsection "import_extra"
.PP
.Vb 1
\&    Your::Module\->import_extra(\e@import_args);
.Ve
.PP
\&\fIimport_extra()\fR is called by \fIimport()\fR.  It provides an opportunity for you
to add behaviors to your module based on its import list.
.PP
Any extra arguments which shouldn't be passed on to \fIplan()\fR should be 
stripped off by this method.
.PP
See Test::More for an example of its use.
.PP
\&\fB\s-1NOTE\s0\fR This mechanism is \fI\s-1VERY ALPHA AND LIKELY TO CHANGE\s0\fR as it
feels like a bit of an ugly hack in its current form.
.SS "Builder"
.IX Subsection "Builder"
Test::Builder::Module provides some methods of getting at the underlying
Test::Builder object.
.PP
\fIbuilder\fR
.IX Subsection "builder"
.PP
.Vb 1
\&  my $builder = Your::Class\->builder;
.Ve
.PP
This method returns the Test::Builder object associated with Your::Class.
It is not a constructor so you can call it as often as you like.
.PP
This is the preferred way to get the Test::Builder object.  You should
\&\fInot\fR get it via \f(CW\*(C`Test::Builder\->new\*(C'\fR as was previously
recommended.
.PP
The object returned by \fIbuilder()\fR may change at runtime so you should
call \fIbuilder()\fR inside each function rather than store it in a global.
.PP
.Vb 2
\&  sub ok {
\&      my $builder = Your::Class\->builder;
\&
\&      return $builder\->ok(@_);
\&  }
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder::Tester.3pm                    0100644 0001750 0001750 00000030776 12566207463 025306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder::Tester 3pm"
.TH Test::Builder::Tester 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder::Tester \- test testsuites that have been built with
Test::Builder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Test::Builder::Tester tests => 1;
\&    use Test::More;
\&
\&    test_out("not ok 1 \- foo");
\&    test_fail(+1);
\&    fail("foo");
\&    test_test("fail works");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A module that helps you test testing modules that are built with
\&\fBTest::Builder\fR.
.PP
The testing system is designed to be used by performing a three step
process for each test you wish to test.  This process starts with using
\&\f(CW\*(C`test_out\*(C'\fR and \f(CW\*(C`test_err\*(C'\fR in advance to declare what the testsuite you
are testing will output with \fBTest::Builder\fR to stdout and stderr.
.PP
You then can run the test(s) from your test suite that call
\&\fBTest::Builder\fR.  At this point the output of \fBTest::Builder\fR is
safely captured by \fBTest::Builder::Tester\fR rather than being
interpreted as real test output.
.PP
The final stage is to call \f(CW\*(C`test_test\*(C'\fR that will simply compare what you
predeclared to what \fBTest::Builder\fR actually outputted, and report the
results back with a \*(L"ok\*(R" or \*(L"not ok\*(R" (with debugging) to the normal
output.
.SS "Functions"
.IX Subsection "Functions"
These are the six methods that are exported as default.
.IP "test_out" 4
.IX Item "test_out"
.PD 0
.IP "test_err" 4
.IX Item "test_err"
.PD
Procedures for predeclaring the output that your test suite is
expected to produce until \f(CW\*(C`test_test\*(C'\fR is called.  These procedures
automatically assume that each line terminates with \*(L"\en\*(R".  So
.Sp
.Vb 1
\&   test_out("ok 1","ok 2");
.Ve
.Sp
is the same as
.Sp
.Vb 1
\&   test_out("ok 1\enok 2");
.Ve
.Sp
which is even the same as
.Sp
.Vb 2
\&   test_out("ok 1");
\&   test_out("ok 2");
.Ve
.Sp
Once \f(CW\*(C`test_out\*(C'\fR or \f(CW\*(C`test_err\*(C'\fR (or \f(CW\*(C`test_fail\*(C'\fR or \f(CW\*(C`test_diag\*(C'\fR) have
been called, all further output from \fBTest::Builder\fR will be
captured by \fBTest::Builder::Tester\fR.  This means that you will not
be able perform further tests to the normal output in the normal way
until you call \f(CW\*(C`test_test\*(C'\fR (well, unless you manually meddle with the
output filehandles)
.IP "test_fail" 4
.IX Item "test_fail"
Because the standard failure message that \fBTest::Builder\fR produces
whenever a test fails will be a common occurrence in your test error
output, and because it has changed between Test::Builder versions, rather
than forcing you to call \f(CW\*(C`test_err\*(C'\fR with the string all the time like
so
.Sp
.Vb 1
\&    test_err("# Failed test ($0 at line ".line_num(+1).")");
.Ve
.Sp
\&\f(CW\*(C`test_fail\*(C'\fR exists as a convenience function that can be called
instead.  It takes one argument, the offset from the current line that
the line that causes the fail is on.
.Sp
.Vb 1
\&    test_fail(+1);
.Ve
.Sp
This means that the example in the synopsis could be rewritten
more simply as:
.Sp
.Vb 4
\&   test_out("not ok 1 \- foo");
\&   test_fail(+1);
\&   fail("foo");
\&   test_test("fail works");
.Ve
.IP "test_diag" 4
.IX Item "test_diag"
As most of the remaining expected output to the error stream will be
created by Test::Builder's \f(CW\*(C`diag\*(C'\fR function, \fBTest::Builder::Tester\fR
provides a convenience function \f(CW\*(C`test_diag\*(C'\fR that you can use instead of
\&\f(CW\*(C`test_err\*(C'\fR.
.Sp
The \f(CW\*(C`test_diag\*(C'\fR function prepends comment hashes and spacing to the
start and newlines to the end of the expected output passed to it and
adds it to the list of expected error output.  So, instead of writing
.Sp
.Vb 1
\&   test_err("# Couldn\*(Aqt open file");
.Ve
.Sp
you can write
.Sp
.Vb 1
\&   test_diag("Couldn\*(Aqt open file");
.Ve
.Sp
Remember that \fBTest::Builder\fR's diag function will not add newlines to
the end of output and test_diag will. So to check
.Sp
.Vb 1
\&   Test::Builder\->new\->diag("foo\en","bar\en");
.Ve
.Sp
You would do
.Sp
.Vb 1
\&  test_diag("foo","bar")
.Ve
.Sp
without the newlines.
.IP "test_test" 4
.IX Item "test_test"
Actually performs the output check testing the tests, comparing the
data (with \f(CW\*(C`eq\*(C'\fR) that we have captured from \fBTest::Builder\fR against
that that was declared with \f(CW\*(C`test_out\*(C'\fR and \f(CW\*(C`test_err\*(C'\fR.
.Sp
This takes name/value pairs that effect how the test is run.
.RS 4
.IP "title (synonym 'name', 'label')" 4
.IX Item "title (synonym 'name', 'label')"
The name of the test that will be displayed after the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not
ok\*(C'\fR.
.IP "skip_out" 4
.IX Item "skip_out"
Setting this to a true value will cause the test to ignore if the
output sent by the test to the output stream does not match that
declared with \f(CW\*(C`test_out\*(C'\fR.
.IP "skip_err" 4
.IX Item "skip_err"
Setting this to a true value will cause the test to ignore if the
output sent by the test to the error stream does not match that
declared with \f(CW\*(C`test_err\*(C'\fR.
.RE
.RS 4
.Sp
As a convenience, if only one argument is passed then this argument
is assumed to be the name of the test (as in the above examples.)
.Sp
Once \f(CW\*(C`test_test\*(C'\fR has been run test output will be redirected back to
the original filehandles that \fBTest::Builder\fR was connected to
(probably \s-1STDOUT\s0 and \s-1STDERR,\s0) meaning any further tests you run
will function normally and cause success/errors for \fBTest::Harness\fR.
.RE
.IP "line_num" 4
.IX Item "line_num"
A utility function that returns the line number that the function was
called on.  You can pass it an offset which will be added to the
result.  This is very useful for working out the correct text of
diagnostic functions that contain line numbers.
.Sp
Essentially this is the same as the \f(CW\*(C`_\|_LINE_\|_\*(C'\fR macro, but the
\&\f(CW\*(C`line_num(+3)\*(C'\fR idiom is arguably nicer.
.PP
In addition to the six exported functions there exists one
function that can only be accessed with a fully qualified function
call.
.IP "color" 4
.IX Item "color"
When \f(CW\*(C`test_test\*(C'\fR is called and the output that your tests generate
does not match that which you declared, \f(CW\*(C`test_test\*(C'\fR will print out
debug information showing the two conflicting versions.  As this
output itself is debug information it can be confusing which part of
the output is from \f(CW\*(C`test_test\*(C'\fR and which was the original output from
your original tests.  Also, it may be hard to spot things like
extraneous whitespace at the end of lines that may cause your test to
fail even though the output looks similar.
.Sp
To assist you \f(CW\*(C`test_test\*(C'\fR can colour the background of the debug
information to disambiguate the different types of output. The debug
output will have its background coloured green and red.  The green
part represents the text which is the same between the executed and
actual output, the red shows which part differs.
.Sp
The \f(CW\*(C`color\*(C'\fR function determines if colouring should occur or not.
Passing it a true or false value will enable or disable colouring
respectively, and the function called with no argument will return the
current setting.
.Sp
To enable colouring from the command line, you can use the
\&\fBText::Builder::Tester::Color\fR module like so:
.Sp
.Vb 1
\&   perl \-Mlib=Text::Builder::Tester::Color test.t
.Ve
.Sp
Or by including the \fBTest::Builder::Tester::Color\fR module directly in
the \s-1PERL5LIB.\s0
.SH "BUGS"
.IX Header "BUGS"
Calls \f(CW\*(C`<Test::Builder\-\*(C'\fRno_ending>> turning off the ending tests.
This is needed as otherwise it will trip out because we've run more
tests than we strictly should have and it'll register any failures we
had that we were testing for as real failures.
.PP
The color function doesn't work unless \fBTerm::ANSIColor\fR is
compatible with your terminal.
.PP
Bugs (and requests for new features) can be reported to the author
though the \s-1CPAN RT\s0 system:
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Builder\-Tester>
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright Mark Fowler <mark@twoshortplanks.com> 2002, 2004.
.PP
Some code taken from \fBTest::More\fR and \fBTest::Catch\fR, written by by
Michael G Schwern <schwern@pobox.com>.  Hence, those parts
Copyright Micheal G Schwern 2001.  Used and distributed with
permission.
.PP
This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "NOTES"
.IX Header "NOTES"
Thanks to Richard Clamp <richardc@unixbeard.net> for letting
me use his testing system to try this module out on.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Builder, Test::Builder::Tester::Color, Test::More.
  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder::Tester5.16.3pm                0100644 0001750 0001750 00000030567 12566207441 025612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder::Tester 3pm"
.TH Test::Builder::Tester 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder::Tester \- test testsuites that have been built with
Test::Builder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Test::Builder::Tester tests => 1;
\&    use Test::More;
\&
\&    test_out("not ok 1 \- foo");
\&    test_fail(+1);
\&    fail("foo");
\&    test_test("fail works");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A module that helps you test testing modules that are built with
\&\fBTest::Builder\fR.
.PP
The testing system is designed to be used by performing a three step
process for each test you wish to test.  This process starts with using
\&\f(CW\*(C`test_out\*(C'\fR and \f(CW\*(C`test_err\*(C'\fR in advance to declare what the testsuite you
are testing will output with \fBTest::Builder\fR to stdout and stderr.
.PP
You then can run the test(s) from your test suite that call
\&\fBTest::Builder\fR.  At this point the output of \fBTest::Builder\fR is
safely captured by \fBTest::Builder::Tester\fR rather than being
interpreted as real test output.
.PP
The final stage is to call \f(CW\*(C`test_test\*(C'\fR that will simply compare what you
predeclared to what \fBTest::Builder\fR actually outputted, and report the
results back with a \*(L"ok\*(R" or \*(L"not ok\*(R" (with debugging) to the normal
output.
.SS "Functions"
.IX Subsection "Functions"
These are the six methods that are exported as default.
.IP "test_out" 4
.IX Item "test_out"
.PD 0
.IP "test_err" 4
.IX Item "test_err"
.PD
Procedures for predeclaring the output that your test suite is
expected to produce until \f(CW\*(C`test_test\*(C'\fR is called.  These procedures
automatically assume that each line terminates with \*(L"\en\*(R".  So
.Sp
.Vb 1
\&   test_out("ok 1","ok 2");
.Ve
.Sp
is the same as
.Sp
.Vb 1
\&   test_out("ok 1\enok 2");
.Ve
.Sp
which is even the same as
.Sp
.Vb 2
\&   test_out("ok 1");
\&   test_out("ok 2");
.Ve
.Sp
Once \f(CW\*(C`test_out\*(C'\fR or \f(CW\*(C`test_err\*(C'\fR (or \f(CW\*(C`test_fail\*(C'\fR or \f(CW\*(C`test_diag\*(C'\fR) have
been called, all further output from \fBTest::Builder\fR will be
captured by \fBTest::Builder::Tester\fR.  This means that you will not
be able perform further tests to the normal output in the normal way
until you call \f(CW\*(C`test_test\*(C'\fR (well, unless you manually meddle with the
output filehandles)
.IP "test_fail" 4
.IX Item "test_fail"
Because the standard failure message that \fBTest::Builder\fR produces
whenever a test fails will be a common occurrence in your test error
output, and because it has changed between Test::Builder versions, rather
than forcing you to call \f(CW\*(C`test_err\*(C'\fR with the string all the time like
so
.Sp
.Vb 1
\&    test_err("# Failed test ($0 at line ".line_num(+1).")");
.Ve
.Sp
\&\f(CW\*(C`test_fail\*(C'\fR exists as a convenience function that can be called
instead.  It takes one argument, the offset from the current line that
the line that causes the fail is on.
.Sp
.Vb 1
\&    test_fail(+1);
.Ve
.Sp
This means that the example in the synopsis could be rewritten
more simply as:
.Sp
.Vb 4
\&   test_out("not ok 1 \- foo");
\&   test_fail(+1);
\&   fail("foo");
\&   test_test("fail works");
.Ve
.IP "test_diag" 4
.IX Item "test_diag"
As most of the remaining expected output to the error stream will be
created by Test::Builder's \f(CW\*(C`diag\*(C'\fR function, \fBTest::Builder::Tester\fR
provides a convenience function \f(CW\*(C`test_diag\*(C'\fR that you can use instead of
\&\f(CW\*(C`test_err\*(C'\fR.
.Sp
The \f(CW\*(C`test_diag\*(C'\fR function prepends comment hashes and spacing to the
start and newlines to the end of the expected output passed to it and
adds it to the list of expected error output.  So, instead of writing
.Sp
.Vb 1
\&   test_err("# Couldn\*(Aqt open file");
.Ve
.Sp
you can write
.Sp
.Vb 1
\&   test_diag("Couldn\*(Aqt open file");
.Ve
.Sp
Remember that \fBTest::Builder\fR's diag function will not add newlines to
the end of output and test_diag will. So to check
.Sp
.Vb 1
\&   Test::Builder\->new\->diag("foo\en","bar\en");
.Ve
.Sp
You would do
.Sp
.Vb 1
\&  test_diag("foo","bar")
.Ve
.Sp
without the newlines.
.IP "test_test" 4
.IX Item "test_test"
Actually performs the output check testing the tests, comparing the
data (with \f(CW\*(C`eq\*(C'\fR) that we have captured from \fBTest::Builder\fR against
that that was declared with \f(CW\*(C`test_out\*(C'\fR and \f(CW\*(C`test_err\*(C'\fR.
.Sp
This takes name/value pairs that effect how the test is run.
.RS 4
.IP "title (synonym 'name', 'label')" 4
.IX Item "title (synonym 'name', 'label')"
The name of the test that will be displayed after the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not
ok\*(C'\fR.
.IP "skip_out" 4
.IX Item "skip_out"
Setting this to a true value will cause the test to ignore if the
output sent by the test to the output stream does not match that
declared with \f(CW\*(C`test_out\*(C'\fR.
.IP "skip_err" 4
.IX Item "skip_err"
Setting this to a true value will cause the test to ignore if the
output sent by the test to the error stream does not match that
declared with \f(CW\*(C`test_err\*(C'\fR.
.RE
.RS 4
.Sp
As a convenience, if only one argument is passed then this argument
is assumed to be the name of the test (as in the above examples.)
.Sp
Once \f(CW\*(C`test_test\*(C'\fR has been run test output will be redirected back to
the original filehandles that \fBTest::Builder\fR was connected to
(probably \s-1STDOUT\s0 and \s-1STDERR\s0,) meaning any further tests you run
will function normally and cause success/errors for \fBTest::Harness\fR.
.RE
.IP "line_num" 4
.IX Item "line_num"
A utility function that returns the line number that the function was
called on.  You can pass it an offset which will be added to the
result.  This is very useful for working out the correct text of
diagnostic functions that contain line numbers.
.Sp
Essentially this is the same as the \f(CW\*(C`_\|_LINE_\|_\*(C'\fR macro, but the
\&\f(CW\*(C`line_num(+3)\*(C'\fR idiom is arguably nicer.
.PP
In addition to the six exported functions there exists one
function that can only be accessed with a fully qualified function
call.
.IP "color" 4
.IX Item "color"
When \f(CW\*(C`test_test\*(C'\fR is called and the output that your tests generate
does not match that which you declared, \f(CW\*(C`test_test\*(C'\fR will print out
debug information showing the two conflicting versions.  As this
output itself is debug information it can be confusing which part of
the output is from \f(CW\*(C`test_test\*(C'\fR and which was the original output from
your original tests.  Also, it may be hard to spot things like
extraneous whitespace at the end of lines that may cause your test to
fail even though the output looks similar.
.Sp
To assist you \f(CW\*(C`test_test\*(C'\fR can colour the background of the debug
information to disambiguate the different types of output. The debug
output will have its background coloured green and red.  The green
part represents the text which is the same between the executed and
actual output, the red shows which part differs.
.Sp
The \f(CW\*(C`color\*(C'\fR function determines if colouring should occur or not.
Passing it a true or false value will enable or disable colouring
respectively, and the function called with no argument will return the
current setting.
.Sp
To enable colouring from the command line, you can use the
\&\fBText::Builder::Tester::Color\fR module like so:
.Sp
.Vb 1
\&   perl \-Mlib=Text::Builder::Tester::Color test.t
.Ve
.Sp
Or by including the \fBTest::Builder::Tester::Color\fR module directly in
the \s-1PERL5LIB\s0.
.SH "BUGS"
.IX Header "BUGS"
Calls \f(CW\*(C`<Test::Builder\-\*(C'\fRno_ending>> turning off the ending tests.
This is needed as otherwise it will trip out because we've run more
tests than we strictly should have and it'll register any failures we
had that we were testing for as real failures.
.PP
The color function doesn't work unless \fBTerm::ANSIColor\fR is
compatible with your terminal.
.PP
Bugs (and requests for new features) can be reported to the author
though the \s-1CPAN\s0 \s-1RT\s0 system:
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Builder\-Tester <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester>
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright Mark Fowler <mark@twoshortplanks.com> 2002, 2004.
.PP
Some code taken from \fBTest::More\fR and \fBTest::Catch\fR, written by by
Michael G Schwern <schwern@pobox.com>.  Hence, those parts
Copyright Micheal G Schwern 2001.  Used and distributed with
permission.
.PP
This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "NOTES"
.IX Header "NOTES"
Thanks to Richard Clamp <richardc@unixbeard.net> for letting
me use his testing system to try this module out on.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Builder, Test::Builder::Tester::Color, Test::More.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Test::Builder::Tester5.18.3pm                0100644 0001750 0001750 00000030776 12566207463 025622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Builder::Tester 3pm"
.TH Test::Builder::Tester 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Builder::Tester \- test testsuites that have been built with
Test::Builder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Test::Builder::Tester tests => 1;
\&    use Test::More;
\&
\&    test_out("not ok 1 \- foo");
\&    test_fail(+1);
\&    fail("foo");
\&    test_test("fail works");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A module that helps you test testing modules that are built with
\&\fBTest::Builder\fR.
.PP
The testing system is designed to be used by performing a three step
process for each test you wish to test.  This process starts with using
\&\f(CW\*(C`test_out\*(C'\fR and \f(CW\*(C`test_err\*(C'\fR in advance to declare what the testsuite you
are testing will output with \fBTest::Builder\fR to stdout and stderr.
.PP
You then can run the test(s) from your test suite that call
\&\fBTest::Builder\fR.  At this point the output of \fBTest::Builder\fR is
safely captured by \fBTest::Builder::Tester\fR rather than being
interpreted as real test output.
.PP
The final stage is to call \f(CW\*(C`test_test\*(C'\fR that will simply compare what you
predeclared to what \fBTest::Builder\fR actually outputted, and report the
results back with a \*(L"ok\*(R" or \*(L"not ok\*(R" (with debugging) to the normal
output.
.SS "Functions"
.IX Subsection "Functions"
These are the six methods that are exported as default.
.IP "test_out" 4
.IX Item "test_out"
.PD 0
.IP "test_err" 4
.IX Item "test_err"
.PD
Procedures for predeclaring the output that your test suite is
expected to produce until \f(CW\*(C`test_test\*(C'\fR is called.  These procedures
automatically assume that each line terminates with \*(L"\en\*(R".  So
.Sp
.Vb 1
\&   test_out("ok 1","ok 2");
.Ve
.Sp
is the same as
.Sp
.Vb 1
\&   test_out("ok 1\enok 2");
.Ve
.Sp
which is even the same as
.Sp
.Vb 2
\&   test_out("ok 1");
\&   test_out("ok 2");
.Ve
.Sp
Once \f(CW\*(C`test_out\*(C'\fR or \f(CW\*(C`test_err\*(C'\fR (or \f(CW\*(C`test_fail\*(C'\fR or \f(CW\*(C`test_diag\*(C'\fR) have
been called, all further output from \fBTest::Builder\fR will be
captured by \fBTest::Builder::Tester\fR.  This means that you will not
be able perform further tests to the normal output in the normal way
until you call \f(CW\*(C`test_test\*(C'\fR (well, unless you manually meddle with the
output filehandles)
.IP "test_fail" 4
.IX Item "test_fail"
Because the standard failure message that \fBTest::Builder\fR produces
whenever a test fails will be a common occurrence in your test error
output, and because it has changed between Test::Builder versions, rather
than forcing you to call \f(CW\*(C`test_err\*(C'\fR with the string all the time like
so
.Sp
.Vb 1
\&    test_err("# Failed test ($0 at line ".line_num(+1).")");
.Ve
.Sp
\&\f(CW\*(C`test_fail\*(C'\fR exists as a convenience function that can be called
instead.  It takes one argument, the offset from the current line that
the line that causes the fail is on.
.Sp
.Vb 1
\&    test_fail(+1);
.Ve
.Sp
This means that the example in the synopsis could be rewritten
more simply as:
.Sp
.Vb 4
\&   test_out("not ok 1 \- foo");
\&   test_fail(+1);
\&   fail("foo");
\&   test_test("fail works");
.Ve
.IP "test_diag" 4
.IX Item "test_diag"
As most of the remaining expected output to the error stream will be
created by Test::Builder's \f(CW\*(C`diag\*(C'\fR function, \fBTest::Builder::Tester\fR
provides a convenience function \f(CW\*(C`test_diag\*(C'\fR that you can use instead of
\&\f(CW\*(C`test_err\*(C'\fR.
.Sp
The \f(CW\*(C`test_diag\*(C'\fR function prepends comment hashes and spacing to the
start and newlines to the end of the expected output passed to it and
adds it to the list of expected error output.  So, instead of writing
.Sp
.Vb 1
\&   test_err("# Couldn\*(Aqt open file");
.Ve
.Sp
you can write
.Sp
.Vb 1
\&   test_diag("Couldn\*(Aqt open file");
.Ve
.Sp
Remember that \fBTest::Builder\fR's diag function will not add newlines to
the end of output and test_diag will. So to check
.Sp
.Vb 1
\&   Test::Builder\->new\->diag("foo\en","bar\en");
.Ve
.Sp
You would do
.Sp
.Vb 1
\&  test_diag("foo","bar")
.Ve
.Sp
without the newlines.
.IP "test_test" 4
.IX Item "test_test"
Actually performs the output check testing the tests, comparing the
data (with \f(CW\*(C`eq\*(C'\fR) that we have captured from \fBTest::Builder\fR against
that that was declared with \f(CW\*(C`test_out\*(C'\fR and \f(CW\*(C`test_err\*(C'\fR.
.Sp
This takes name/value pairs that effect how the test is run.
.RS 4
.IP "title (synonym 'name', 'label')" 4
.IX Item "title (synonym 'name', 'label')"
The name of the test that will be displayed after the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not
ok\*(C'\fR.
.IP "skip_out" 4
.IX Item "skip_out"
Setting this to a true value will cause the test to ignore if the
output sent by the test to the output stream does not match that
declared with \f(CW\*(C`test_out\*(C'\fR.
.IP "skip_err" 4
.IX Item "skip_err"
Setting this to a true value will cause the test to ignore if the
output sent by the test to the error stream does not match that
declared with \f(CW\*(C`test_err\*(C'\fR.
.RE
.RS 4
.Sp
As a convenience, if only one argument is passed then this argument
is assumed to be the name of the test (a