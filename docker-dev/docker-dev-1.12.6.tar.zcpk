9\-01; sbeck)"
.IX Header "VERSION 3.27 (planned 2013-09-01; sbeck)"
.SH "VERSION 3.26  (planned 2013\-06\-01; sbeck)"
.IX Header "VERSION 3.26 (planned 2013-06-01; sbeck)"
.SH "VERSION 3.25  (2013\-03\-01; sbeck)"
.IX Header "VERSION 3.25 (2013-03-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.SH "VERSION 3.24  (2012\-12\-03; sbeck)"
.IX Header "VERSION 3.24 (2012-12-03; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBSyria alias\fR" 4
.IX Item "Syria alias"
Syria added as an alias.  \s-1RT 82747\s0
.IP "\fB\s-1FIPS\-10\s0 country codes deprecated\fR" 4
.IX Item "FIPS-10 country codes deprecated"
The \s-1FIPS\-10\s0 document is being withdrawn.  It was deprecated in 2008,
and is being updated now only until all the agencies that use it have
switched to something else.  The current version no longer lists the
long names for countries.  These long names (such as 'Republic of
Albania' for Albania) only appeared in the old \s-1FIPS\-10\s0 document which
is no longer available, so they are no longer available in this module.
.Sp
I will continue to support the \s-1FIPS\-10\s0 codeset as long as it is available,
but at that point, it will be withdrawn immediately.  If an official
end-of-life date is announced, I will include a notice here.  Otherwise, support
for the codeset will be discontinued when the document is withdrawn.
.Sp
You are encouraged to no longer use the \s-1FIPS\-10\s0 codeset.
.IP "\fBDomain country codes now come from \s-1ISO 3166\s0\fR" 4
.IX Item "Domain country codes now come from ISO 3166"
The \s-1IANA\s0 domain codes have changed slightly.  The \s-1IANA\s0 no longer
publishes a list of countries associated with their codes.  Instead,
they use the \s-1ISO 3166\s0 codes and country names.  However, they support
a few non-standard codes, so I will continue to maintain this codeset.
The domain codes are now lowercase to correspond to the \s-1ISO 3166\s0 codes.
.SH "VERSION 3.23  (2012\-09\-01; sbeck)"
.IX Header "VERSION 3.23 (2012-09-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.SH "VERSION 3.22  (2012\-06\-01; sbeck)"
.IX Header "VERSION 3.22 (2012-06-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBUpdated perl version required\fR" 4
.IX Item "Updated perl version required"
Changed 'require 5.002' (which dated back to the version 2.xx Locale-Codes)
to 'require 5.006'.  Some features used in Locale-Codes are not supported that
far back.  Nicholas Clark
.IP "\fBSorted deprecated codes\fR" 4
.IX Item "Sorted deprecated codes"
The codes in the generated deprecated codes modules were not sorted making version
diffs bigger than they should be.  Nicholas Clark
.SH "VERSION 3.21  (2012\-03\-01; sbeck)"
.IX Header "VERSION 3.21 (2012-03-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.SH "VERSION 3.20  (2011\-12\-01; sbeck)"
.IX Header "VERSION 3.20 (2011-12-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBAdded limited support for deprecated codes\fR" 4
.IX Item "Added limited support for deprecated codes"
The code2XXX, XXX2code, all_XXX_codes, and all_XXX_names functions
now support retired codes.  \s-1RT 71124\s0
.IP "\fBFixed capitalization\fR" 4
.IX Item "Fixed capitalization"
The 'South Sudan' country was all caps.  \s-1RT 71024\s0
.IP "\fBPod tests off by default\fR" 4
.IX Item "Pod tests off by default"
The pod tests will not run at install time.  \s-1RT 71122\s0
.IP "\fBCodesets may be specified by name\fR" 4
.IX Item "Codesets may be specified by name"
All codesets may be specified by a constant or by their name now.  Previously,
they were specified only by a constant.
.IP "\fBalias_code deprecated\fR" 4
.IX Item "alias_code deprecated"
The alias_code function exists for backward compatibility.  It has been replaced
by rename_country_code .  The alias_code function will be removed sometime
after September, 2013 .
.IP "\fBCode cleanup\fR" 4
.IX Item "Code cleanup"
All work is now done in the central module (Locale::Codes).  Previously, some
was still done in the wrapper modules (Locale::Codes::*) but that is gone now.
.IP "\fBAdded LangFam module\fR" 4
.IX Item "Added LangFam module"
Added Language Family codes (langfam) as defined in \s-1ISO 639\-5.\s0
.SH "VERSION 3.18  (2011\-08\-31; sbeck)"
.IX Header "VERSION 3.18 (2011-08-31; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBNo longer use \s-1CIA\s0 data\fR" 4
.IX Item "No longer use CIA data"
The \s-1CIA\s0 world added non-standard values, so I no longer use it as
a source of data.  Based on a report by Michiel Beijen.
.SH "VERSION 3.17  (2011\-06\-28; sbeck)"
.IX Header "VERSION 3.17 (2011-06-28; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBAdded new types of codes\fR" 4
.IX Item "Added new types of codes"
Added Language Extension codes (langext) and Language Variation codes
(langvar) as defined in the \s-1IANA\s0 language registry.
.IP "\fBAdded new codeset(s)\fR" 4
.IX Item "Added new codeset(s)"
Added language codes from \s-1ISO 639\-5\s0
.Sp
Added language/script codes from the \s-1IANA\s0 language subtag
registry
.IP "\fBBug fixes\fR" 4
.IX Item "Bug fixes"
Fixed an uninitialized value warning.  \s-1RT 67438\s0
.Sp
Fixed the return value for the all_XXX_codes and all_XXX_names functions.  \s-1RT 69100\s0
.IP "\fBReorganized code\fR" 4
.IX Item "Reorganized code"
Reorganized modules to move Locale::MODULE to Locale::Codes::MODULE to
allow for cleaner future additions.  The original four modules (Locale::Language,
Locale::Currency, Locale::Country, Locale::Script) will continue to work, but
all new sets of codes will be added in the Locale::Codes namespace.
.SH "VERSION 3.16  (2011\-03\-01; sbeck)"
.IX Header "VERSION 3.16 (2011-03-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.SH "VERSION 3.15  (2010\-12\-02; sbeck)"
.IX Header "VERSION 3.15 (2010-12-02; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBMinor fixes\fR" 4
.IX Item "Minor fixes"
Added version number to Makefile.PL/Build.PL requirement
for \s-1POD\s0 testing modules.  \s-1RT 62247\s0
.Sp
Changed 'use vars' to 'our'
.SH "VERSION 3.14  (2010\-09\-28; sbeck)"
.IX Header "VERSION 3.14 (2010-09-28; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBBug fixes\fR" 4
.IX Item "Bug fixes"
Stripped out some \s-1HTML\s0 that got included with some codes.
.SH "VERSION 3.13  (2010\-06\-04; sbeck)"
.IX Header "VERSION 3.13 (2010-06-04; sbeck)"
\&\s-1NEW CODE\s0(s)
.SH "VERSION 3.12  (2010\-04\-06; sbeck)"
.IX Header "VERSION 3.12 (2010-04-06; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBReorganized code\fR" 4
.IX Item "Reorganized code"
Renamed test.pl to testfunc.pl to avoid causing an error
when built as part of perl.
.SH "VERSION 3.11  (2010\-03\-01; sbeck)"
.IX Header "VERSION 3.11 (2010-03-01; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBAdded new codeset(s)\fR" 4
.IX Item "Added new codeset(s)"
Added the \s-1IANA\s0 domain names to Country
.IP "\fBBug fixes\fR" 4
.IX Item "Bug fixes"
Fixed a problem that produced warnings with perl 5.11.5.
Jerry D. Hedden
.SH "VERSION 3.10  (2010\-02\-18; sbeck)"
.IX Header "VERSION 3.10 (2010-02-18; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBReorganized code\fR" 4
.IX Item "Reorganized code"
Moved support files into the Locale::Codes namespace.
.Sp
The work done in each of the Locale::XXX modules was virtually
identical to each other. It has all been moved to a central module and
the Locale::XXX modules are now just wrappers.
.IP "\fB(!) Changed XXX_code2code behavior slightly\fR" 4
.IX Item "(!) Changed XXX_code2code behavior slightly"
In previous versions, passing in the same code set for both code set
arguments would automatically return undef. For example:
.Sp
.Vb 2
\&   country_code2code(\*(Aqbo\*(Aq,LOCALE_CODE_ALPHA_2,LOCALE_CODE_ALPHA_2);
\&      => undef
.Ve
.Sp
This doesn't seem like reasonable behavior, so it has been changed
to allow the same code set:
.Sp
.Vb 2
\&   country_code2code(\*(Aqbo\*(Aq,LOCALE_CODE_ALPHA_2,LOCALE_CODE_ALPHA_2);
\&      => \*(Aqbo\*(Aq
.Ve
.Sp
Note that if an invalid code is passed in, undef will still be
returned:
.Sp
.Vb 2
\&   country_code2code(\*(Aqbol\*(Aq,LOCALE_CODE_ALPHA_2,LOCALE_CODE_ALPHA_2);
\&      => undef
.Ve
.IP "\fBAdded many semi-private routines\fR" 4
.IX Item "Added many semi-private routines"
Previous versions had only two semi-private routines: rename_country
and alias_code which had the ability to modify the internal data in
a couple very limited ways. It was requested (in an anonymous posting
by someone named Steve and also by Steve Hay) that better support
for modifying internal data, so a full set of routines were added.
.Sp
The full set of routines includes:
.Sp
.Vb 4
\&   rename_country
\&   rename_language
\&   rename_currency
\&   rename_script
\&
\&   add_country
\&   add_language
\&   add_currency
\&   add_script
\&
\&   delete_country
\&   delete_language
\&   delete_currency
\&   delete_script
\&
\&   add_country_alias
\&   add_language_alias
\&   add_currency_alias
\&   add_script_alias
\&
\&   delete_country_alias
\&   delete_language_alias
\&   delete_currency_alias
\&   delete_script_alias
\&
\&   rename_country_code
\&   rename_language_code
\&   rename_currency_code
\&   rename_script_code
\&
\&   add_country_code_alias
\&   add_language_code_alias
\&   add_currency_code_alias
\&   add_script_code_alias
\&
\&   delete_country_code_alias
\&   delete_language_code_alias
\&   delete_currency_code_alias
\&   delete_script_code_alias
.Ve
.IP "\fBNew aliases\fR" 4
.IX Item "New aliases"
Added \*(L"\s-1UK\*(R"\s0 alias. Steve Hay
.SH "VERSION 3.01  (2010\-02\-15; sbeck)"
.IX Header "VERSION 3.01 (2010-02-15; sbeck)"
.IP "\fBFixed Makefile.PL and Build.PL\fR" 4
.IX Item "Fixed Makefile.PL and Build.PL"
They now install as core modules as they are supposed to.  Reported in
\&\s-1RT 54526\s0
.SH "VERSION 3.00  (2010\-02\-10; sbeck)"
.IX Header "VERSION 3.00 (2010-02-10; sbeck)"
\&\s-1NEW CODE\s0(s)
.IP "\fBNew maintainer\fR" 4
.IX Item "New maintainer"
From 1997 to 2004, Locale::Codes was maintained by Neil
Bowers. Unfortunately, no updates were made from June 2004 to January
2010. During that time, a number of changes have been made to the
standards since then, so the data included was out-of-date.
.Sp
I contacted Neil to get his permission to assume maintenance of
the module, and he kindly agreed.
.IP "\fB(*) (!) All codes are generated from standards\fR" 4
.IX Item "(*) (!) All codes are generated from standards"
All of the values returned by the various functions are now values
directly from the standards. This means that the values returned in
the 2.xx series are not necessarily the same as the values returned
here.
.Sp
As an example, the \s-1ISO 3166\s0 standard which lists country codes refers
to the country associated with the code \*(L"bo\*(R" as \*(L"Bolivia,
Plurinational State of\*(R", so that is what is returned. In the 2.xx
series, \*(L"Bolivia\*(R" was returned.  Also, the country names vary from one
standard to another. So the code \*(L"bol\*(R" which is maintained by the
United Nations returns the name of the country as \*(L"Bolivia
(Plurinational State of)\*(R". Some common aliases have been added, so you
can still request a code associated with a county name \*(L"Bolivia\*(R".
.Sp
Since the data comes from the standards, some \*(L"incorrect\*(R" values are
no longer supported. For example, 2.07 treated \*(L"Zaire\*(R" as an alias for
\&\*(L"Congo\*(R", but the country changed it's name, and \*(L"Zaire\*(R" is not in the
standard, so it has been dropped in 3.00.
.IP "\fBAdded new codeset(s)\fR" 4
.IX Item "Added new codeset(s)"
\&\s-1FIPS 10\s0 country codes (requested in \s-1RT 1755\s0)
.Sp
Alpha\-3 and Term language codes (requested in \s-1RT 11730\s0)
.Sp
Numeric currency codes (requested in \s-1RT 18797\s0)
.IP "\fB(*) (!) Locale::Script changed\fR" 4
.IX Item "(*) (!) Locale::Script changed"
In 2.xx, Locale::Script assigned scripts to country codes, which is \s-1NOT\s0
how it is done currently in the standards. It appears that an older version
of \s-1ISO 15924\s0 did this, but I haven't found an old version to confirm
that, and in any case, that is not the case in the current standards.
.Sp
As a result, the Locale::Script module is completely incompatible with
the 2.xx version with respect to the types of codes it supports. None of
the old codes will work.
.IP "\fBAdded missing functions\fR" 4
.IX Item "Added missing functions"
I've added in some functions which were \*(L"missing\*(R" previously (since there was
only one set of codes supported, the code2code functions didn't apply):
.Sp
.Vb 2
\&   language_code2code
\&   currency_code2code
.Ve
.Sp
so the interfaces for each type of codes are consistent.
.IP "\fB(!) Dropped support for _alias_code\fR" 4
.IX Item "(!) Dropped support for _alias_code"
In Locale::Country, _alias_code was an allowed, but deprecated function
which was documented to be supported in the 2.xx series. I've removed it.
.IP "\fB(!) All functions return the standard value\fR" 4
.IX Item "(!) All functions return the standard value"
code2country (and other equivalent functions) now returns the name of
the country specified in the standard (if the different standards
refer to the country by different variations in the name, the results
will differ based on the \s-1CODESET\s0)
.IP "\fB(!) rename_country function altered\fR" 4
.IX Item "(!) rename_country function altered"
The rename_country function from 2.07 would guess the \s-1CODESET \s0(unlike
all other functions which used a default of \s-1LOCALE_CODE_ALPHA_2\s0). The
guess can cause problems since (with the addition of \s-1FIPS\s0) codes may
appear in different codesets for different countries. The behavior has
been changed to be the same as other functions (default to
\&\s-1LOCALE_CODE_ALPHA_2\s0).
.SH "VERSION 2.07  (2004\-06\-10; neilb)"
.IX Header "VERSION 2.07 (2004-06-10; neilb)"
Made \f(CW$_\fR local in the initialization code for each module
change back-propagated from Perl distribution
.PP
Removed two non \s-1ISO\-8859\-1\s0 characters from language names
change back-propagated from Perl distribution
.PP
Added the following aliases, with a test case for each
   \- Burma added to Myanmar
   \- French Southern and Antarctic Lands to
     French Southern Territories
patch from \s-1TJ\s0 Mather
.PP
\&\*(L"Canadian Dollar\*(R" was misspelled as \*(L"Candian Dollar\*(R"
   \- noted by Nick Cabatoff, patch from Michael Hennecke
.PP
Changes to Locale::Country reflecting changes in \s-1ISO 3166
   \-\s0 added Aland Islands (ax, ala, 248)
   \- \s-1YUGOSLAVIA\s0 is now \s-1SERBIA AND MONTENEGRO
      YU\s0 => \s-1CS
      YUG\s0 => \s-1SCG
      891\s0 => 891 (unchanged)
      (\s-1YUGOSLAVIA\s0 retained as an alias)
   \- \s-1EAST TIMOR\s0 changed to TIMOR-LESTE
      (old name retained as an alias)
   \- three letter code for Romania changed from \s-1ROM\s0 to \s-1ROU\s0
.PP
\&\s-1ZAIRE\s0 is now \s-1CONGO, THE DEMOCRATIC REPUBLIC OF THE
    ZR \s0 => \s-1CD
    ZAR\s0 => \s-1COD
    180\s0 => 180 (unchanged)
    (\s-1ZAIRE\s0 retained as alias)
.SH "VERSION 2.06  (2002\-07\-15; neilb)"
.IX Header "VERSION 2.06 (2002-07-15; neilb)"
The four modules which have data after _\|_DATA_\|_ weren't closing the
\&\s-1DATA\s0 filehandle after reading from it, which they should. Bug and
patch from Steve Hay.
.SH "VERSION 2.05  (2002\-07\-08; neilb)"
.IX Header "VERSION 2.05 (2002-07-08; neilb)"
Added three letter codes for the countries that were missing
them. Patch from \s-1TJ\s0 Mather.
.PP
Documentation bug: one of the examples used => where the
lvalue was a constant, which isn't allowed, unless you
put the () with the constant to force the right interpretation.
Pointed out by \s-1TJ\s0 Mather and \s-1MYT.\s0
.PP
Updated the \s-1URL\s0 for the appendix in the \s-1CIA\s0 world factbook.
Patch from \s-1TJ\s0 Mather.
.SH "VERSION 2.04  (2002\-05\-23; neilb)"
.IX Header "VERSION 2.04 (2002-05-23; neilb)"
Updated according to changes in \s-1ISO 3166\-1\s0 described
in \s-1ISO 3166\-1\s0 newsletters V\-4 and V\-5, dated 2002\-05\-20:
   \- Kazakstan is now \*(L"Kazakhstan\*(R"
   \- Macau is now \*(L"Macao\*(R"
The old names are retained as aliases.
.PP
The alpha\-2 and alpha\-3 codes for East Timor have changed:
   tp \-> tl
   tmp \-> tls
the numeric code stays 626. If you want to support the old
codes, you can use the semi-private function \fIalias_code()\fR.
.SH "VERSION 2.03  (2002\-03\-24; neilb)"
.IX Header "VERSION 2.03 (2002-03-24; neilb)"
Fixed a typo in the alias for the Vatican, reported (with patch)
by Philip Newton.
.PP
Added \*(L"Moldova\*(R" as an alias for \*(L"Moldova, Republic of\*(R"
.PP
Updated Makefile.PL to include \s-1AUTHOR\s0 and \s-1ABSTRACT\s0
.SH "VERSION 2.02  (2002\-03\-09; neilb)"
.IX Header "VERSION 2.02 (2002-03-09; neilb)"
Added semi-private routine \fIrename_country()\fR to Locale::Country,
based on a patch from Iain Chalmers.
.PP
Added test rename.t for the above function.
.PP
Renamed _alias_code to be alias_code. Have retained the old
name for backwards compatibility. Will remove it when the
major version number next changes.
.SH "VERSION 2.01  (2002\-02\-18; neilb)"
.IX Header "VERSION 2.01 (2002-02-18; neilb)"
Split the documentation for all modules into separate pod files.
.PP
Made sure all =over were =over 4; some were other values.
.PP
The \fIcode2code()\fR methods had one more shift than was needed.
.SH "VERSION 2.00  (2002\-02\-17; neilb)"
.IX Header "VERSION 2.00 (2002-02-17; neilb)"
Created Locale::Script which provides an interface to the \s-1ISO\s0 codes
for identification of scripts (writing scripts, rather than perl style
scripts). The codes are defined by \s-1ISO 15924,\s0 which is currently in
final draft.  Thanks to Jarkko for pointing out this new standard.
All three code sets are supported, and a test-suite added.
.PP
Added support for country name variants to Locale::Country,
so that
   country2code('\s-1USA\s0')
   country2code('United States')
   country2code('United States of America')
will all return 'us'.  This had been in the \s-1LIMITATIONS\s0 section since
the first version.  Patch from \s-1TJ\s0 Mather with additional variants from
me. Added test-cases for these.
.PP
Added \s-1VERSION\s0 to Locale::Constants. Thanks to Jarkko for
pointing that it was missing.
.PP
Should really have bumped major version with previous release,
since there was a change to the \s-1API.\s0
.SH "VERSION 1.06  (2001\-03\-04; neilb)"
.IX Header "VERSION 1.06 (2001-03-04; neilb)"
Added Locale::Constants, which defines three symbols for identifying
which codeset is being used:
.PP
.Vb 3
\&   LOCALE_CODE_ALPHA_2
\&   LOCALE_CODE_ALPHA_3
\&   LOCALE_CODE_NUMERIC
.Ve
.PP
Updated Locale::Country to support all three code sets defined by \s-1ISO
3166.\s0 This was requested by Keith Wall.  I haven't added multiple
codeset support to the other modules yet \- I'll wait until someone
asks for them.
.SH "VERSION 1.05  (2001\-02\-13; neilb)"
.IX Header "VERSION 1.05 (2001-02-13; neilb)"
Added Locale::Currency, contribution from Michael Hennecke.
.PP
Added test suite for it (t/currency.t) and added test cases
to t/all.t for the all_* functions.
.SH "VERSION 1.04  (2000\-12\-21; neilb)"
.IX Header "VERSION 1.04 (2000-12-21; neilb)"
Fixed very minor typos from 1.03!
.SH "VERSION 1.03  (2000\-12\-??; neilb)"
.IX Header "VERSION 1.03 (2000-12-??; neilb)"
Updated Locale::Country:
   \- fixed spelling of a few countries
   \- added link to a relevant page from \s-1CIA\s0 world factbook
.PP
Updated Locale::Language:
   \- fixed typo in the documentation (\s-1ISO 939\s0 should be 639)
.SH "VERSION 1.02  (2000\-05\-04; neilb)"
.IX Header "VERSION 1.02 (2000-05-04; neilb)"
Updated Locale::Country and Locale::Language to reflect changes in the
relevant \s-1ISO\s0 standards. These mainly reflect languages which are new
to the relevant standard, and changes in the spelling of some country
names.
.PP
Added official URLs for the standards to the \s-1SEE ALSO\s0 sections of the
doc for each module.
.PP
Thanks to Jarkko Hietaniemi for pointing me at the pages with latest
versions of \s-1ISO 3166\s0 and 639.
.SH "VERSION 1.00  (1998\-03\-09; neilb)"
.IX Header "VERSION 1.00 (1998-03-09; neilb)"
Added \fILocale::Country::_alias_code()\fR so that 'uk' can be added as the
code for \*(L"United Kingdom\*(R", if you want it.  This was prompted by Ed
Jordan.
.PP
Added a new test suite for handling this case, and extended the
existing test-suite to include testing of the case where 'uk' hasn't
been defined as a valid code.
.SH "VERSION 0.003  (1997\-05\-09; neilb)"
.IX Header "VERSION 0.003 (1997-05-09; neilb)"
First public release to \s-1CPAN\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Locale::Codes
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Constants.3pm                 0100644 0001750 0001750 00000011716 12566207457 025737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Constants 3pm"
.TH Locale::Codes::Constants 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Constants \- constants for Locale codes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBLocale::Codes::Constants\fR defines symbols which are used in the other
modules from the Locale-Codes distribution.
.PP
You shouldn't have to \f(CW\*(C`use\*(C'\fR this module directly yourself \- it is
used by the other Locale modules, which in turn export the symbols.
.PP
The constants are documented in each of the Locale modules.
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
None known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Locale::Codes
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Constants5.16.3pm             0100644 0001750 0001750 00000011375 12566207435 026246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Constants 3pm"
.TH Locale::Codes::Constants 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Constants \- constants for Locale codes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBLocale::Codes::Constants\fR defines symbols which are used in the other
modules from the Locale-Codes distribution.
.PP
You shouldn't have to \f(CW\*(C`use\*(C'\fR this module directly yourself \- it is
used by the other Locale modules, which in turn export the symbols.
.PP
The constants are documented in each of the Locale modules.
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
None known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Locale::Codes
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Constants5.18.3pm             0100644 0001750 0001750 00000011716 12566207457 026253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Constants 3pm"
.TH Locale::Codes::Constants 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Constants \- constants for Locale codes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBLocale::Codes::Constants\fR defines symbols which are used in the other
modules from the Locale-Codes distribution.
.PP
You shouldn't have to \f(CW\*(C`use\*(C'\fR this module directly yourself \- it is
used by the other Locale modules, which in turn export the symbols.
.PP
The constants are documented in each of the Locale modules.
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
None known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Locale::Codes
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country.3pm                   0100644 0001750 0001750 00000030676 12566207457 025434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country 3pm"
.TH Locale::Codes::Country 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country \- standard codes for country identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Country;
\&
\&   $country = code2country(\*(Aqjp\*(Aq [,CODESET]);        # $country gets \*(AqJapan\*(Aq
\&   $code    = country2code(\*(AqNorway\*(Aq [,CODESET]);    # $code gets \*(Aqno\*(Aq
\&
\&   @codes   = all_country_codes( [CODESET]);
\&   @names   = all_country_names();
\&
\&   # semi\-private routines
\&   Locale::Codes::Country::alias_code(\*(Aquk\*(Aq => \*(Aqgb\*(Aq);
\&   Locale::Codes::Country::rename_country(\*(Aqgb\*(Aq => \*(AqGreat Britain\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Country\*(C'\fR module provides access to several code sets
that can be used for identifying countries, such as those defined in
\&\s-1ISO 3166\-1.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
3166\-1\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $country = code2country(\*(Aqjp\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $country = code2country(\*(Aqjp\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_CODE_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_CODE_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 3166\-1,\s0 such
as 'tv' for Tuvalu.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_CODE_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_CODE_ALPHA_3"
This is the set of three-letter (lowercase) codes from \s-1ISO 3166\-1,\s0
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.
.IP "\fBnumeric, \s-1LOCALE_CODE_NUMERIC\s0\fR" 4
.IX Item "numeric, LOCALE_CODE_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 3166\-1,\s0 such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.
.Sp
If a 2\-digit code is entered, it is converted to 3 digits by prepending
a 0.
.IP "\fBfips\-10, \s-1LOCALE_CODE_FIPS\s0\fR" 4
.IX Item "fips-10, LOCALE_CODE_FIPS"
The \s-1FIPS 10\s0 data are two-letter (uppercase) codes assigned by the
National Geospatial-Intelligence Agency.
.IP "\fBdom, \s-1LOCALE_CODE_DOM\s0\fR" 4
.IX Item "dom, LOCALE_CODE_DOM"
The \s-1IANA\s0 is responsible for delegating management of the top level country
domains.  The country domains are the two-letter (lowercase) codes from \s-1ISO 3166\s0
with a few other additions.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2country ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2country ( CODE [,CODESET] )"
.PD 0
.IP "\fBcountry2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "country2code ( NAME [,CODESET] )"
.IP "\fBcountry_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "country_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_country_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_codes ( [CODESET] )"
.IP "\fBall_country_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_names ( [CODESET] )"
.IP "\fBLocale::Codes::Country::rename_country  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::rename_country ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::add_country ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Country::delete_country  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::delete_country ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Country::add_country_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Country::delete_country_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Country::delete_country_alias ( NAME )"
.IP "\fBLocale::Codes::Country::rename_country_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::rename_country_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::add_country_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::delete_country_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::delete_country_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.IP "\fBalias_code ( \s-1ALIAS, CODE\s0 [,CODESET] )\fR" 4
.IX Item "alias_code ( ALIAS, CODE [,CODESET] )"
Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.
.Sp
As of 3.10, the internal data for all types of codes can be modified.
.Sp
The alias_code function is preserved for backwards compatibility, but
the following two are identical:
.Sp
.Vb 2
\&   alias_code(ALIAS,CODE [,CODESET]);
\&   rename_country_code(CODE,ALIAS [,CODESET]);
.Ve
.Sp
and the latter should be used for consistency.
.Sp
The alias_code function is deprecated and will be removed at some point
in the future.
.Sp
\&\fBNote:\fR this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBLocale::SubCountry\fR" 4
.IX Item "Locale::SubCountry"
\&\s-1ISO\s0 codes for country sub-divisions (states, counties, provinces,
etc), as defined in \s-1ISO 3166\-2. \s0 This module is not part of the
Locale-Codes distribution, but is available from \s-1CPAN\s0 in
CPAN/modules/by\-module/Locale/
.IP "\fBhttp://www.iso.org/iso/country_codes\fR" 4
.IX Item "http://www.iso.org/iso/country_codes"
Official home page for the \s-1ISO 3166\s0 maintenance agency.
.Sp
Unfortunately, they do not make the actual \s-1ISO\s0 available for free,
so I cannot check the alpha\-3 and numerical codes here.
.IP "\fBhttp://www.iso.org/iso/list\-en1\-semic\-3.txt\fR" 4
.IX Item "http://www.iso.org/iso/list-en1-semic-3.txt"
.PD 0
.IP "\fBhttp://www.iso.org/iso/home/standards/country_codes/iso\-3166\-1_decoding_table.htm\fR" 4
.IX Item "http://www.iso.org/iso/home/standards/country_codes/iso-3166-1_decoding_table.htm"
.PD
The source of \s-1ISO 3166\-1\s0 two-letter codes used by this
module.
.IP "\fBhttp://unstats.un.org/unsd/methods/m49/m49alpha.htm\fR" 4
.IX Item "http://unstats.un.org/unsd/methods/m49/m49alpha.htm"
The source of the official \s-1ISO 3166\-1\s0 three-letter codes and
three-digit codes.
.Sp
For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the \s-1UN\s0 site.  I
get as much of the data from here as I can.
.IP "\fBhttp://earth\-info.nga.mil/gns/html/digraphs.htm\fR" 4
.IX Item "http://earth-info.nga.mil/gns/html/digraphs.htm"
The official list of the \s-1FIPS 10\s0 codes.
.IP "\fBhttp://www.iana.org/domains/\fR" 4
.IX Item "http://www.iana.org/domains/"
Official source of the top-level domain names.
.IP "\fBhttps://www.cia.gov/library/publications/the\-world\-factbook/appendix/print_appendix\-d.html\fR" 4
.IX Item "https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html"
The World Factbook maintained by the \s-1CIA\s0 is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.
.IP "\fBhttp://www.statoids.com/wab.html\fR" 4
.IX Item "http://www.statoids.com/wab.html"
Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country5.16.3pm               0100644 0001750 0001750 00000027731 12566207435 025740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country 3pm"
.TH Locale::Codes::Country 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country \- standard codes for country identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Country;
\&
\&   $country = code2country(\*(Aqjp\*(Aq [,CODESET]);        # $country gets \*(AqJapan\*(Aq
\&   $code    = country2code(\*(AqNorway\*(Aq [,CODESET]);    # $code gets \*(Aqno\*(Aq
\&
\&   @codes   = all_country_codes( [CODESET]);
\&   @names   = all_country_names();
\&
\&   # semi\-private routines
\&   Locale::Codes::Country::alias_code(\*(Aquk\*(Aq => \*(Aqgb\*(Aq);
\&   Locale::Codes::Country::rename_country(\*(Aqgb\*(Aq => \*(AqGreat Britain\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Country\*(C'\fR module provides access to several code sets
that can be used for identifying countries, such as those defined in
\&\s-1ISO\s0 3166\-1.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
3166\-1 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $country = code2country(\*(Aqjp\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $country = code2country(\*(Aqjp\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_CODE_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_CODE_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO\s0 3166\-1, such
as 'tv' for Tuvalu.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_CODE_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_CODE_ALPHA_3"
This is the set of three-letter (lowercase) codes from \s-1ISO\s0 3166\-1,
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.
.IP "\fBnumeric, \s-1LOCALE_CODE_NUMERIC\s0\fR" 4
.IX Item "numeric, LOCALE_CODE_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO\s0 3166\-1, such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.
.Sp
If a 2\-digit code is entered, it is converted to 3 digits by prepending
a 0.
.IP "\fBfips\-10, \s-1LOCALE_CODE_FIPS\s0\fR" 4
.IX Item "fips-10, LOCALE_CODE_FIPS"
The \s-1FIPS\s0 10 data are two-letter (uppercase) codes assigned by the
National Geospatial-Intelligence Agency.
.IP "\fBdom, \s-1LOCALE_CODE_DOM\s0\fR" 4
.IX Item "dom, LOCALE_CODE_DOM"
The \s-1IANA\s0 is responsible for assigning two-letter (uppercase) top-level
domain names to each country.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2country ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2country ( CODE [,CODESET] )"
.PD 0
.IP "\fBcountry2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "country2code ( NAME [,CODESET] )"
.IP "\fBcountry_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "country_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_country_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_codes ( [CODESET] )"
.IP "\fBall_country_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_names ( [CODESET] )"
.IP "\fBLocale::Codes::Country::rename_country  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::rename_country  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::add_country  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Country::delete_country  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::delete_country  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::Country::add_country_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Country::delete_country_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::Country::delete_country_alias  ( NAME )"
.IP "\fBLocale::Codes::Country::rename_country_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::rename_country_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::add_country_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::delete_country_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::delete_country_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.IP "\fBalias_code ( \s-1ALIAS\s0, \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "alias_code ( ALIAS, CODE [,CODESET] )"
Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.
.Sp
As of 3.10, the internal data for all types of codes can be modified.
.Sp
The alias_code function is preserved for backwards compatibility, but
the following two are identical:
.Sp
.Vb 2
\&   alias_code(ALIAS,CODE [,CODESET]);
\&   rename_country_code(CODE,ALIAS [,CODESET]);
.Ve
.Sp
and the latter should be used for consistency.
.Sp
The alias_code function is deprecated and will be removed at some point
in the future.
.Sp
\&\fBNote:\fR this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBLocale::SubCountry\fR" 4
.IX Item "Locale::SubCountry"
\&\s-1ISO\s0 codes for country sub-divisions (states, counties, provinces,
etc), as defined in \s-1ISO\s0 3166\-2.  This module is not part of the
Locale-Codes distribution, but is available from \s-1CPAN\s0 in
CPAN/modules/by\-module/Locale/
.IP "\fBhttp://www.iso.org/iso/country_codes\fR" 4
.IX Item "http://www.iso.org/iso/country_codes"
Official home page for the \s-1ISO\s0 3166 maintenance agency.
.Sp
Unfortunately, they do not make the actual \s-1ISO\s0 available for free,
so I cannot check the alpha\-3 and numerical codes here.
.IP "\fBhttp://www.iso.org/iso/list\-en1\-semic\-3.txt\fR" 4
.IX Item "http://www.iso.org/iso/list-en1-semic-3.txt"
The source of \s-1ISO\s0 3166\-1 two-letter codes used by this
module.
.IP "\fBhttp://unstats.un.org/unsd/methods/m49/m49alpha.htm\fR" 4
.IX Item "http://unstats.un.org/unsd/methods/m49/m49alpha.htm"
The source of the official \s-1ISO\s0 3166\-1 three-letter codes and
three-digit codes.
.Sp
For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the \s-1UN\s0 site.  I
get as much of the data from here as I can.
.IP "\fBhttp://earth\-info.nga.mil/gns/html/digraphs.htm\fR" 4
.IX Item "http://earth-info.nga.mil/gns/html/digraphs.htm"
The official list of the \s-1FIPS\s0 10 codes.
.IP "\fBhttp://www.iana.org/domains/\fR" 4
.IX Item "http://www.iana.org/domains/"
Official source of the top-level domain names.
.IP "\fBhttps://www.cia.gov/library/publications/the\-world\-factbook/appendix/print_appendix\-d.html\fR" 4
.IX Item "https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html"
The World Factbook maintained by the \s-1CIA\s0 is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.
.IP "\fBhttp://www.statoids.com/wab.html\fR" 4
.IX Item "http://www.statoids.com/wab.html"
Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country5.18.3pm               0100644 0001750 0001750 00000030676 12566207457 025750  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country 3pm"
.TH Locale::Codes::Country 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country \- standard codes for country identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Country;
\&
\&   $country = code2country(\*(Aqjp\*(Aq [,CODESET]);        # $country gets \*(AqJapan\*(Aq
\&   $code    = country2code(\*(AqNorway\*(Aq [,CODESET]);    # $code gets \*(Aqno\*(Aq
\&
\&   @codes   = all_country_codes( [CODESET]);
\&   @names   = all_country_names();
\&
\&   # semi\-private routines
\&   Locale::Codes::Country::alias_code(\*(Aquk\*(Aq => \*(Aqgb\*(Aq);
\&   Locale::Codes::Country::rename_country(\*(Aqgb\*(Aq => \*(AqGreat Britain\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Country\*(C'\fR module provides access to several code sets
that can be used for identifying countries, such as those defined in
\&\s-1ISO 3166\-1.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
3166\-1\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $country = code2country(\*(Aqjp\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $country = code2country(\*(Aqjp\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_CODE_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_CODE_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 3166\-1,\s0 such
as 'tv' for Tuvalu.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_CODE_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_CODE_ALPHA_3"
This is the set of three-letter (lowercase) codes from \s-1ISO 3166\-1,\s0
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.
.IP "\fBnumeric, \s-1LOCALE_CODE_NUMERIC\s0\fR" 4
.IX Item "numeric, LOCALE_CODE_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 3166\-1,\s0 such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.
.Sp
If a 2\-digit code is entered, it is converted to 3 digits by prepending
a 0.
.IP "\fBfips\-10, \s-1LOCALE_CODE_FIPS\s0\fR" 4
.IX Item "fips-10, LOCALE_CODE_FIPS"
The \s-1FIPS 10\s0 data are two-letter (uppercase) codes assigned by the
National Geospatial-Intelligence Agency.
.IP "\fBdom, \s-1LOCALE_CODE_DOM\s0\fR" 4
.IX Item "dom, LOCALE_CODE_DOM"
The \s-1IANA\s0 is responsible for delegating management of the top level country
domains.  The country domains are the two-letter (lowercase) codes from \s-1ISO 3166\s0
with a few other additions.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2country ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2country ( CODE [,CODESET] )"
.PD 0
.IP "\fBcountry2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "country2code ( NAME [,CODESET] )"
.IP "\fBcountry_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "country_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_country_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_codes ( [CODESET] )"
.IP "\fBall_country_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_names ( [CODESET] )"
.IP "\fBLocale::Codes::Country::rename_country  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::rename_country ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::add_country ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Country::delete_country  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::delete_country ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Country::add_country_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Country::delete_country_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Country::delete_country_alias ( NAME )"
.IP "\fBLocale::Codes::Country::rename_country_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::rename_country_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::add_country_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::add_country_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Country::delete_country_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Country::delete_country_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.IP "\fBalias_code ( \s-1ALIAS, CODE\s0 [,CODESET] )\fR" 4
.IX Item "alias_code ( ALIAS, CODE [,CODESET] )"
Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.
.Sp
As of 3.10, the internal data for all types of codes can be modified.
.Sp
The alias_code function is preserved for backwards compatibility, but
the following two are identical:
.Sp
.Vb 2
\&   alias_code(ALIAS,CODE [,CODESET]);
\&   rename_country_code(CODE,ALIAS [,CODESET]);
.Ve
.Sp
and the latter should be used for consistency.
.Sp
The alias_code function is deprecated and will be removed at some point
in the future.
.Sp
\&\fBNote:\fR this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBLocale::SubCountry\fR" 4
.IX Item "Locale::SubCountry"
\&\s-1ISO\s0 codes for country sub-divisions (states, counties, provinces,
etc), as defined in \s-1ISO 3166\-2. \s0 This module is not part of the
Locale-Codes distribution, but is available from \s-1CPAN\s0 in
CPAN/modules/by\-module/Locale/
.IP "\fBhttp://www.iso.org/iso/country_codes\fR" 4
.IX Item "http://www.iso.org/iso/country_codes"
Official home page for the \s-1ISO 3166\s0 maintenance agency.
.Sp
Unfortunately, they do not make the actual \s-1ISO\s0 available for free,
so I cannot check the alpha\-3 and numerical codes here.
.IP "\fBhttp://www.iso.org/iso/list\-en1\-semic\-3.txt\fR" 4
.IX Item "http://www.iso.org/iso/list-en1-semic-3.txt"
.PD 0
.IP "\fBhttp://www.iso.org/iso/home/standards/country_codes/iso\-3166\-1_decoding_table.htm\fR" 4
.IX Item "http://www.iso.org/iso/home/standards/country_codes/iso-3166-1_decoding_table.htm"
.PD
The source of \s-1ISO 3166\-1\s0 two-letter codes used by this
module.
.IP "\fBhttp://unstats.un.org/unsd/methods/m49/m49alpha.htm\fR" 4
.IX Item "http://unstats.un.org/unsd/methods/m49/m49alpha.htm"
The source of the official \s-1ISO 3166\-1\s0 three-letter codes and
three-digit codes.
.Sp
For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the \s-1UN\s0 site.  I
get as much of the data from here as I can.
.IP "\fBhttp://earth\-info.nga.mil/gns/html/digraphs.htm\fR" 4
.IX Item "http://earth-info.nga.mil/gns/html/digraphs.htm"
The official list of the \s-1FIPS 10\s0 codes.
.IP "\fBhttp://www.iana.org/domains/\fR" 4
.IX Item "http://www.iana.org/domains/"
Official source of the top-level domain names.
.IP "\fBhttps://www.cia.gov/library/publications/the\-world\-factbook/appendix/print_appendix\-d.html\fR" 4
.IX Item "https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html"
The World Factbook maintained by the \s-1CIA\s0 is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.
.IP "\fBhttp://www.statoids.com/wab.html\fR" 4
.IX Item "http://www.statoids.com/wab.html"
Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country_Codes.3pm             0100644 0001750 0001750 00000011242 12566207457 026535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country_Codes 3pm"
.TH Locale::Codes::Country_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country_Codes \- country codes for the Locale::Codes::Country module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Country module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country_Codes5.16.3pm         0100644 0001750 0001750 00000010721 12566207435 027044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country_Codes 3pm"
.TH Locale::Codes::Country_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country_Codes \- country codes for the Locale::Codes::Country module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Country module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country_Codes5.18.3pm         0100644 0001750 0001750 00000011242 12566207457 027051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country_Codes 3pm"
.TH Locale::Codes::Country_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country_Codes \- country codes for the Locale::Codes::Country module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Country module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country_Retired.3pm           0100644 0001750 0001750 00000011260 12566207457 027076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country_Retired 3pm"
.TH Locale::Codes::Country_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country_Retired \- retired country codes for the Locale::Codes::Country module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Country module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country_Retired5.16.3pm       0100644 0001750 0001750 00000010737 12566207435 027414  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country_Retired 3pm"
.TH Locale::Codes::Country_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country_Retired \- retired country codes for the Locale::Codes::Country module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Country module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Country_Retired5.18.3pm       0100644 0001750 0001750 00000011260 12566207457 027412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Country_Retired 3pm"
.TH Locale::Codes::Country_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Country_Retired \- retired country codes for the Locale::Codes::Country module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Country module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency.3pm                  0100644 0001750 0001750 00000021020 12566207457 025542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency 3pm"
.TH Locale::Codes::Currency 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency \- standard codes for currency identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Locale::Codes::Currency;
\&
\&    $curr = code2currency(\*(Aqusd\*(Aq);     # $curr gets \*(AqUS Dollar\*(Aq
\&    $code = currency2code(\*(AqEuro\*(Aq);    # $code gets \*(Aqeur\*(Aq
\&
\&    @codes   = all_currency_codes();
\&    @names   = all_currency_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Currency\*(C'\fR module provides access to standard codes used
for identifying currencies and funds, such as those defined in \s-1ISO 4217.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
4217\s0 three-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $curr = code2currency(\*(Aqusd\*(Aq,\*(Aqalpha\*(Aq);
\&   $curr = code2currency(\*(Aqusd\*(Aq,LOCALE_CURR_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_CURR_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_CURR_ALPHA"
This is a set of three-letter (uppercase) codes from \s-1ISO 4217\s0 such
as \s-1EUR\s0 for Euro.
.Sp
Two of the codes specified by the standard (\s-1XTS\s0 which is reserved
for testing purposes and \s-1XXX\s0 which is for transactions where no
currency is involved) are omitted.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_CURR_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_CURR_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 4217.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2currency ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2currency ( CODE [,CODESET] )"
.PD 0
.IP "\fBcurrency2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "currency2code ( NAME [,CODESET] )"
.IP "\fBcurrency_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "currency_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_currency_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_codes ( [CODESET] )"
.IP "\fBall_currency_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_names ( [CODESET] )"
.IP "\fBLocale::Codes::Currency::rename_currency  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::rename_currency ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Currency::delete_currency  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Currency::add_currency_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Currency::delete_currency_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency_alias ( NAME )"
.IP "\fBLocale::Codes::Currency::rename_currency_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::rename_currency_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::delete_currency_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iso.org/iso/support/currency_codes_list\-1.htm\fR" 4
.IX Item "http://www.iso.org/iso/support/currency_codes_list-1.htm"
The \s-1ISO 4217\s0 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001      Michael Hennecke
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency5.16.3pm              0100644 0001750 0001750 00000020507 12566207435 026061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency 3pm"
.TH Locale::Codes::Currency 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency \- standard codes for currency identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Locale::Codes::Currency;
\&
\&    $curr = code2currency(\*(Aqusd\*(Aq);     # $curr gets \*(AqUS Dollar\*(Aq
\&    $code = currency2code(\*(AqEuro\*(Aq);    # $code gets \*(Aqeur\*(Aq
\&
\&    @codes   = all_currency_codes();
\&    @names   = all_currency_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Currency\*(C'\fR module provides access to standard codes used
for identifying currencies and funds, such as those defined in \s-1ISO\s0 4217.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
4217 three-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $curr = code2currency(\*(Aqusd\*(Aq,\*(Aqalpha\*(Aq);
\&   $curr = code2currency(\*(Aqusd\*(Aq,LOCALE_CURR_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_CURR_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_CURR_ALPHA"
This is a set of three-letter (uppercase) codes from \s-1ISO\s0 4217 such
as \s-1EUR\s0 for Euro.
.Sp
Two of the codes specified by the standard (\s-1XTS\s0 which is reserved
for testing purposes and \s-1XXX\s0 which is for transactions where no
currency is involved) are omitted.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_CURR_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_CURR_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO\s0 4217.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2currency ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2currency ( CODE [,CODESET] )"
.PD 0
.IP "\fBcurrency2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "currency2code ( NAME [,CODESET] )"
.IP "\fBcurrency_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "currency_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_currency_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_codes ( [CODESET] )"
.IP "\fBall_currency_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_names ( [CODESET] )"
.IP "\fBLocale::Codes::Currency::rename_currency  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::rename_currency  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Currency::delete_currency  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Currency::delete_currency_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency_alias  ( NAME )"
.IP "\fBLocale::Codes::Currency::rename_currency_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::rename_currency_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::delete_currency_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iso.org/iso/support/currency_codes_list\-1.htm\fR" 4
.IX Item "http://www.iso.org/iso/support/currency_codes_list-1.htm"
The \s-1ISO\s0 4217 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001      Michael Hennecke
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency5.18.3pm              0100644 0001750 0001750 00000021020 12566207457 026056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency 3pm"
.TH Locale::Codes::Currency 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency \- standard codes for currency identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Locale::Codes::Currency;
\&
\&    $curr = code2currency(\*(Aqusd\*(Aq);     # $curr gets \*(AqUS Dollar\*(Aq
\&    $code = currency2code(\*(AqEuro\*(Aq);    # $code gets \*(Aqeur\*(Aq
\&
\&    @codes   = all_currency_codes();
\&    @names   = all_currency_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Currency\*(C'\fR module provides access to standard codes used
for identifying currencies and funds, such as those defined in \s-1ISO 4217.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
4217\s0 three-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $curr = code2currency(\*(Aqusd\*(Aq,\*(Aqalpha\*(Aq);
\&   $curr = code2currency(\*(Aqusd\*(Aq,LOCALE_CURR_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_CURR_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_CURR_ALPHA"
This is a set of three-letter (uppercase) codes from \s-1ISO 4217\s0 such
as \s-1EUR\s0 for Euro.
.Sp
Two of the codes specified by the standard (\s-1XTS\s0 which is reserved
for testing purposes and \s-1XXX\s0 which is for transactions where no
currency is involved) are omitted.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_CURR_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_CURR_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 4217.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2currency ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2currency ( CODE [,CODESET] )"
.PD 0
.IP "\fBcurrency2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "currency2code ( NAME [,CODESET] )"
.IP "\fBcurrency_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "currency_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_currency_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_codes ( [CODESET] )"
.IP "\fBall_currency_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_names ( [CODESET] )"
.IP "\fBLocale::Codes::Currency::rename_currency  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::rename_currency ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Currency::delete_currency  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Currency::add_currency_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Currency::delete_currency_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency_alias ( NAME )"
.IP "\fBLocale::Codes::Currency::rename_currency_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::rename_currency_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::add_currency_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::add_currency_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Currency::delete_currency_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Currency::delete_currency_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iso.org/iso/support/currency_codes_list\-1.htm\fR" 4
.IX Item "http://www.iso.org/iso/support/currency_codes_list-1.htm"
The \s-1ISO 4217\s0 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001      Michael Hennecke
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency_Codes.3pm            0100644 0001750 0001750 00000011250 12566207457 026663  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency_Codes 3pm"
.TH Locale::Codes::Currency_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency_Codes \- currency codes for the Locale::Codes::Currency module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Currency module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency_Codes5.16.3pm        0100644 0001750 0001750 00000010727 12566207435 027201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency_Codes 3pm"
.TH Locale::Codes::Currency_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency_Codes \- currency codes for the Locale::Codes::Currency module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Currency module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency_Codes5.18.3pm        0100644 0001750 0001750 00000011250 12566207457 027177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency_Codes 3pm"
.TH Locale::Codes::Currency_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency_Codes \- currency codes for the Locale::Codes::Currency module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Currency module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency_Retired.3pm          0100644 0001750 0001750 00000011266 12566207457 027233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency_Retired 3pm"
.TH Locale::Codes::Currency_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency_Retired \- retired currency codes for the Locale::Codes::Currency module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Currency module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency_Retired5.16.3pm      0100644 0001750 0001750 00000010745 12566207435 027542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency_Retired 3pm"
.TH Locale::Codes::Currency_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency_Retired \- retired currency codes for the Locale::Codes::Currency module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Currency module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Currency_Retired5.18.3pm      0100644 0001750 0001750 00000011266 12566207457 027547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Currency_Retired 3pm"
.TH Locale::Codes::Currency_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Currency_Retired \- retired currency codes for the Locale::Codes::Currency module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Currency module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt.3pm                   0100644 0001750 0001750 00000020100 12566207457 025310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt 3pm"
.TH Locale::Codes::LangExt 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt \- standard codes for language extension identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangExt;
\&
\&   $lext = code2langext(\*(Aqacm\*(Aq);                 # $lext gets \*(AqMesopotamian Arabic\*(Aq
\&   $code = langext2code(\*(AqMesopotamian Arabic\*(Aq); # $code gets \*(Aqacm\*(Aq
\&
\&   @codes   = all_langext_codes();
\&   @names   = all_langext_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangExt\*(C'\fR module provides access to standard codes
used for identifying language extensions, such as those as defined in
the \s-1IANA\s0 language registry.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1IANA\s0
language registry codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language extensions. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lext = code2langext(\*(Aqacm\*(Aq,\*(Aqalpha\*(Aq);
\&   $lext = code2langext(\*(Aqacm\*(Aq,LOCALE_LANGEXT_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of three-letter (lowercase) codes from the \s-1IANA\s0
language registry, such as 'acm' for Mesopotamian Arabic.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langext ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langext ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangext2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langext2code ( NAME [,CODESET] )"
.IP "\fBlangext_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "langext_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langext_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langext_codes ( [CODESET] )"
.IP "\fBall_langext_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langext_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangExt::rename_langext  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::rename_langext ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::delete_langext  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangExt::delete_langext_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext_alias ( NAME )"
.IP "\fBLocale::Codes::LangExt::rename_langext_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::rename_langext_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::delete_langext_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt5.16.3pm               0100644 0001750 0001750 00000017567 12566207435 025645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt 3pm"
.TH Locale::Codes::LangExt 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt \- standard codes for language extension identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangExt;
\&
\&   $lext = code2langext(\*(Aqacm\*(Aq);                 # $lext gets \*(AqMesopotamian Arabic\*(Aq
\&   $code = langext2code(\*(AqMesopotamian Arabic\*(Aq); # $code gets \*(Aqacm\*(Aq
\&
\&   @codes   = all_langext_codes();
\&   @names   = all_langext_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangExt\*(C'\fR module provides access to standard codes
used for identifying language extensions, such as those as defined in
the \s-1IANA\s0 language registry.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1IANA\s0
language registry codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language extensions. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lext = code2langext(\*(Aqacm\*(Aq,\*(Aqalpha\*(Aq);
\&   $lext = code2langext(\*(Aqacm\*(Aq,LOCALE_LANGEXT_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of three-letter (lowercase) codes from the \s-1IANA\s0
language registry, such as 'acm' for Mesopotamian Arabic.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langext ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langext ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangext2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langext2code ( NAME [,CODESET] )"
.IP "\fBlangext_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "langext_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langext_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langext_codes ( [CODESET] )"
.IP "\fBall_langext_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langext_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangExt::rename_langext  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::rename_langext  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::delete_langext  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangExt::delete_langext_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext_alias  ( NAME )"
.IP "\fBLocale::Codes::LangExt::rename_langext_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::rename_langext_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::delete_langext_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt5.18.3pm               0100644 0001750 0001750 00000020100 12566207457 025624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt 3pm"
.TH Locale::Codes::LangExt 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt \- standard codes for language extension identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangExt;
\&
\&   $lext = code2langext(\*(Aqacm\*(Aq);                 # $lext gets \*(AqMesopotamian Arabic\*(Aq
\&   $code = langext2code(\*(AqMesopotamian Arabic\*(Aq); # $code gets \*(Aqacm\*(Aq
\&
\&   @codes   = all_langext_codes();
\&   @names   = all_langext_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangExt\*(C'\fR module provides access to standard codes
used for identifying language extensions, such as those as defined in
the \s-1IANA\s0 language registry.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1IANA\s0
language registry codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language extensions. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lext = code2langext(\*(Aqacm\*(Aq,\*(Aqalpha\*(Aq);
\&   $lext = code2langext(\*(Aqacm\*(Aq,LOCALE_LANGEXT_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of three-letter (lowercase) codes from the \s-1IANA\s0
language registry, such as 'acm' for Mesopotamian Arabic.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langext ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langext ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangext2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langext2code ( NAME [,CODESET] )"
.IP "\fBlangext_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "langext_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langext_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langext_codes ( [CODESET] )"
.IP "\fBall_langext_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langext_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangExt::rename_langext  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::rename_langext ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::delete_langext  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangExt::delete_langext_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext_alias ( NAME )"
.IP "\fBLocale::Codes::LangExt::rename_langext_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::rename_langext_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::add_langext_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::add_langext_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangExt::delete_langext_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangExt::delete_langext_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt_Codes.3pm             0100644 0001750 0001750 00000011242 12566207457 026434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt_Codes 3pm"
.TH Locale::Codes::LangExt_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt_Codes \- langext codes for the Locale::Codes::LangExt module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangExt module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt_Codes5.16.3pm         0100644 0001750 0001750 00000010721 12566207435 026743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt_Codes 3pm"
.TH Locale::Codes::LangExt_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt_Codes \- langext codes for the Locale::Codes::LangExt module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangExt module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt_Codes5.18.3pm         0100644 0001750 0001750 00000011242 12566207457 026750  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt_Codes 3pm"
.TH Locale::Codes::LangExt_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt_Codes \- langext codes for the Locale::Codes::LangExt module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangExt module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt_Retired.3pm           0100644 0001750 0001750 00000011260 12566207457 026775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt_Retired 3pm"
.TH Locale::Codes::LangExt_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt_Retired \- retired langext codes for the Locale::Codes::LangExt module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangExt module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt_Retired5.16.3pm       0100644 0001750 0001750 00000010737 12566207435 027313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt_Retired 3pm"
.TH Locale::Codes::LangExt_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt_Retired \- retired langext codes for the Locale::Codes::LangExt module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangExt module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangExt_Retired5.18.3pm       0100644 0001750 0001750 00000011260 12566207457 027311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangExt_Retired 3pm"
.TH Locale::Codes::LangExt_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangExt_Retired \- retired langext codes for the Locale::Codes::LangExt module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangExt module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam.3pm                   0100644 0001750 0001750 00000017756 12566207457 025302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam 3pm"
.TH Locale::Codes::LangFam 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam \- standard codes for language extension identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangFam;
\&
\&   $lext = code2langfam(\*(Aqapa\*(Aq);                 # $lext gets \*(AqApache languages\*(Aq
\&   $code = langfam2code(\*(AqApache languages\*(Aq);    # $code gets \*(Aqapa\*(Aq
\&
\&   @codes   = all_langfam_codes();
\&   @names   = all_langfam_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangFam\*(C'\fR module provides access to standard codes
used for identifying language families, such as those as defined in
\&\s-1ISO 639\-5.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO 639\-5\s0
language family codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language families. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lext = code2langfam(\*(Aqapa\*(Aq,\*(Aqalpha\*(Aq);
\&   $lext = code2langfam(\*(Aqapa\*(Aq,LOCALE_LANGFAM_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of three-letter (lowercase) codes from \s-1ISO 639\-5\s0
such as 'apa' for Apache languages.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langfam ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langfam ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangfam2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langfam2code ( NAME [,CODESET] )"
.IP "\fBlangfam_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "langfam_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langfam_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langfam_codes ( [CODESET] )"
.IP "\fBall_langfam_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langfam_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangFam::rename_langfam  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::rename_langfam ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::delete_langfam  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangFam::delete_langfam_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam_alias ( NAME )"
.IP "\fBLocale::Codes::LangFam::rename_langfam_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::rename_langfam_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::delete_langfam_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/id.php\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/id.php"
\&\s-1ISO 639\-5 .\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam5.16.3pm               0100644 0001750 0001750 00000017445 12566207435 025603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam 3pm"
.TH Locale::Codes::LangFam 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam \- standard codes for language extension identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangFam;
\&
\&   $lext = code2langfam(\*(Aqapa\*(Aq);                 # $lext gets \*(AqApache languages\*(Aq
\&   $code = langfam2code(\*(AqApache languages\*(Aq);    # $code gets \*(Aqapa\*(Aq
\&
\&   @codes   = all_langfam_codes();
\&   @names   = all_langfam_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangFam\*(C'\fR module provides access to standard codes
used for identifying language families, such as those as defined in
\&\s-1ISO\s0 639\-5.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0 639\-5
language family codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language families. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lext = code2langfam(\*(Aqapa\*(Aq,\*(Aqalpha\*(Aq);
\&   $lext = code2langfam(\*(Aqapa\*(Aq,LOCALE_LANGFAM_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of three-letter (lowercase) codes from \s-1ISO\s0 639\-5
such as 'apa' for Apache languages.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langfam ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langfam ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangfam2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langfam2code ( NAME [,CODESET] )"
.IP "\fBlangfam_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "langfam_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langfam_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langfam_codes ( [CODESET] )"
.IP "\fBall_langfam_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langfam_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangFam::rename_langfam  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::rename_langfam  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::delete_langfam  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangFam::delete_langfam_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam_alias  ( NAME )"
.IP "\fBLocale::Codes::LangFam::rename_langfam_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::rename_langfam_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::delete_langfam_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/id.php\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/id.php"
\&\s-1ISO\s0 639\-5 .
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam5.18.3pm               0100644 0001750 0001750 00000017756 12566207457 025616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam 3pm"
.TH Locale::Codes::LangFam 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam \- standard codes for language extension identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangFam;
\&
\&   $lext = code2langfam(\*(Aqapa\*(Aq);                 # $lext gets \*(AqApache languages\*(Aq
\&   $code = langfam2code(\*(AqApache languages\*(Aq);    # $code gets \*(Aqapa\*(Aq
\&
\&   @codes   = all_langfam_codes();
\&   @names   = all_langfam_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangFam\*(C'\fR module provides access to standard codes
used for identifying language families, such as those as defined in
\&\s-1ISO 639\-5.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO 639\-5\s0
language family codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language families. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lext = code2langfam(\*(Aqapa\*(Aq,\*(Aqalpha\*(Aq);
\&   $lext = code2langfam(\*(Aqapa\*(Aq,LOCALE_LANGFAM_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of three-letter (lowercase) codes from \s-1ISO 639\-5\s0
such as 'apa' for Apache languages.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langfam ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langfam ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangfam2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langfam2code ( NAME [,CODESET] )"
.IP "\fBlangfam_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "langfam_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langfam_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langfam_codes ( [CODESET] )"
.IP "\fBall_langfam_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langfam_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangFam::rename_langfam  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::rename_langfam ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::delete_langfam  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangFam::delete_langfam_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam_alias ( NAME )"
.IP "\fBLocale::Codes::LangFam::rename_langfam_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::rename_langfam_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::add_langfam_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::add_langfam_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangFam::delete_langfam_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangFam::delete_langfam_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/id.php\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/id.php"
\&\s-1ISO 639\-5 .\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam_Codes.3pm             0100644 0001750 0001750 00000011242 12566207457 026377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam_Codes 3pm"
.TH Locale::Codes::LangFam_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam_Codes \- langfam codes for the Locale::Codes::LangFam module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam_Codes5.16.3pm         0100644 0001750 0001750 00000010721 12566207435 026706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam_Codes 3pm"
.TH Locale::Codes::LangFam_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam_Codes \- langfam codes for the Locale::Codes::LangFam module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam_Codes5.18.3pm         0100644 0001750 0001750 00000011242 12566207457 026713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam_Codes 3pm"
.TH Locale::Codes::LangFam_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam_Codes \- langfam codes for the Locale::Codes::LangFam module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam_Retired.3pm           0100644 0001750 0001750 00000011260 12566207457 026740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam_Retired 3pm"
.TH Locale::Codes::LangFam_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam_Retired \- retired langfam codes for the Locale::Codes::LangFam module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam_Retired5.16.3pm       0100644 0001750 0001750 00000010737 12566207435 027256  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam_Retired 3pm"
.TH Locale::Codes::LangFam_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam_Retired \- retired langfam codes for the Locale::Codes::LangFam module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangFam_Retired5.18.3pm       0100644 0001750 0001750 00000011260 12566207457 027254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangFam_Retired 3pm"
.TH Locale::Codes::LangFam_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangFam_Retired \- retired langfam codes for the Locale::Codes::LangFam module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar.3pm                   0100644 0001750 0001750 00000020215 12566207457 025307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar 3pm"
.TH Locale::Codes::LangVar 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar \- standard codes for language variation identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangVar;
\&
\&   $lvar = code2langvar(\*(Aqacm\*(Aq);                 # $lvar gets \*(AqMesopotamian Arabic\*(Aq
\&   $code = langvar2code(\*(AqMesopotamian Arabic\*(Aq); # $code gets \*(Aqacm\*(Aq
\&
\&   @codes   = all_langvar_codes();
\&   @names   = all_langvar_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangVar\*(C'\fR module provides access to standard codes
used for identifying language variations, such as those as defined in
the \s-1IANA\s0 language registry.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1IANA\s0
language registry codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language variations. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lvar = code2langvar(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lvar = code2langvar(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of alphanumeric codes from the \s-1IANA\s0
language registry, such as 'arevela' for Eastern Armenian.
.Sp
This code set is identified with the symbol \f(CW\*(C`LOCALE_LANGVAR_ALPHA\*(C'\fR.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langvar ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langvar ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangvar2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langvar2code ( NAME [,CODESET] )"
.IP "\fBlangvar_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "langvar_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langvar_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langvar_codes ( [CODESET] )"
.IP "\fBall_langvar_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langvar_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangVar::rename_langvar  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::rename_langvar ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::delete_langvar  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangVar::delete_langvar_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar_alias ( NAME )"
.IP "\fBLocale::Codes::LangVar::rename_langvar_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::rename_langvar_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::delete_langvar_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar5.16.3pm               0100644 0001750 0001750 00000017704 12566207435 025626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar 3pm"
.TH Locale::Codes::LangVar 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar \- standard codes for language variation identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangVar;
\&
\&   $lvar = code2langvar(\*(Aqacm\*(Aq);                 # $lvar gets \*(AqMesopotamian Arabic\*(Aq
\&   $code = langvar2code(\*(AqMesopotamian Arabic\*(Aq); # $code gets \*(Aqacm\*(Aq
\&
\&   @codes   = all_langvar_codes();
\&   @names   = all_langvar_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangVar\*(C'\fR module provides access to standard codes
used for identifying language variations, such as those as defined in
the \s-1IANA\s0 language registry.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1IANA\s0
language registry codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language variations. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lvar = code2langvar(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lvar = code2langvar(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of alphanumeric codes from the \s-1IANA\s0
language registry, such as 'arevela' for Eastern Armenian.
.Sp
This code set is identified with the symbol \f(CW\*(C`LOCALE_LANGVAR_ALPHA\*(C'\fR.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langvar ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langvar ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangvar2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langvar2code ( NAME [,CODESET] )"
.IP "\fBlangvar_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "langvar_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langvar_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langvar_codes ( [CODESET] )"
.IP "\fBall_langvar_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langvar_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangVar::rename_langvar  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::rename_langvar  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::delete_langvar  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangVar::delete_langvar_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar_alias  ( NAME )"
.IP "\fBLocale::Codes::LangVar::rename_langvar_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::rename_langvar_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::delete_langvar_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar5.18.3pm               0100644 0001750 0001750 00000020215 12566207457 025623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar 3pm"
.TH Locale::Codes::LangVar 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar \- standard codes for language variation identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::LangVar;
\&
\&   $lvar = code2langvar(\*(Aqacm\*(Aq);                 # $lvar gets \*(AqMesopotamian Arabic\*(Aq
\&   $code = langvar2code(\*(AqMesopotamian Arabic\*(Aq); # $code gets \*(Aqacm\*(Aq
\&
\&   @codes   = all_langvar_codes();
\&   @names   = all_langvar_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::LangVar\*(C'\fR module provides access to standard codes
used for identifying language variations, such as those as defined in
the \s-1IANA\s0 language registry.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1IANA\s0
language registry codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
language variations. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lvar = code2langvar(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lvar = code2langvar(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\fR" 4
.IX Item "alpha"
This is the set of alphanumeric codes from the \s-1IANA\s0
language registry, such as 'arevela' for Eastern Armenian.
.Sp
This code set is identified with the symbol \f(CW\*(C`LOCALE_LANGVAR_ALPHA\*(C'\fR.
.Sp
This is the default code set.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2langvar ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2langvar ( CODE [,CODESET] )"
.PD 0
.IP "\fBlangvar2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "langvar2code ( NAME [,CODESET] )"
.IP "\fBlangvar_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "langvar_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_langvar_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langvar_codes ( [CODESET] )"
.IP "\fBall_langvar_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_langvar_names ( [CODESET] )"
.IP "\fBLocale::Codes::LangVar::rename_langvar  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::rename_langvar ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::delete_langvar  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::LangVar::delete_langvar_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar_alias ( NAME )"
.IP "\fBLocale::Codes::LangVar::rename_langvar_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::rename_langvar_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::add_langvar_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::add_langvar_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::LangVar::delete_langvar_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::LangVar::delete_langvar_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&   Copyright (c) 2011\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar_Codes.3pm             0100644 0001750 0001750 00000011242 12566207457 026424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar_Codes 3pm"
.TH Locale::Codes::LangVar_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar_Codes \- langvar codes for the Locale::Codes::LangVar module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangVar module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar_Codes5.16.3pm         0100644 0001750 0001750 00000010721 12566207435 026733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar_Codes 3pm"
.TH Locale::Codes::LangVar_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar_Codes \- langvar codes for the Locale::Codes::LangVar module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangVar module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar_Codes5.18.3pm         0100644 0001750 0001750 00000011242 12566207457 026740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar_Codes 3pm"
.TH Locale::Codes::LangVar_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar_Codes \- langvar codes for the Locale::Codes::LangVar module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangVar module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar_Retired.3pm           0100644 0001750 0001750 00000011260 12566207457 026765  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar_Retired 3pm"
.TH Locale::Codes::LangVar_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar_Retired \- retired langvar codes for the Locale::Codes::LangVar module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangVar module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar_Retired5.16.3pm       0100644 0001750 0001750 00000010737 12566207435 027303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar_Retired 3pm"
.TH Locale::Codes::LangVar_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar_Retired \- retired langvar codes for the Locale::Codes::LangVar module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangVar module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::LangVar_Retired5.18.3pm       0100644 0001750 0001750 00000011260 12566207457 027301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::LangVar_Retired 3pm"
.TH Locale::Codes::LangVar_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::LangVar_Retired \- retired langvar codes for the Locale::Codes::LangVar module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::LangVar module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language.3pm                  0100644 0001750 0001750 00000021753 12566207457 025510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language 3pm"
.TH Locale::Codes::Language 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language \- standard codes for language identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Language;
\&
\&   $lang = code2language(\*(Aqen\*(Aq);        # $lang gets \*(AqEnglish\*(Aq
\&   $code = language2code(\*(AqFrench\*(Aq);    # $code gets \*(Aqfr\*(Aq
\&
\&   @codes   = all_language_codes();
\&   @names   = all_language_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Language\*(C'\fR module provides access to standard codes used
for identifying languages, such as those as defined in \s-1ISO 639.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
639\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lang = code2language(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lang = code2language(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_LANG_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_LANG_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 639\-1,\s0 such
as 'he' for Hebrew.  It also includes additions to this set included
in the \s-1IANA\s0 language registry.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_LANG_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_LANG_ALPHA_3"
This is the set of three-letter (lowercase) bibliographic codes from
\&\s-1ISO 639\-2\s0 and 639\-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the \s-1IANA\s0 language registry.
.IP "\fBterm, \s-1LOCALE_LANG_TERM\s0\fR" 4
.IX Item "term, LOCALE_LANG_TERM"
This is the set of three-letter (lowercase) terminologic codes from
\&\s-1ISO 639.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2language ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2language ( CODE [,CODESET] )"
.PD 0
.IP "\fBlanguage2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "language2code ( NAME [,CODESET] )"
.IP "\fBlanguage_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "language_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_language_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_codes ( [CODESET] )"
.IP "\fBall_language_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_names ( [CODESET] )"
.IP "\fBLocale::Codes::Language::rename_language  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::rename_language ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::add_language ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Language::delete_language  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::delete_language ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Language::add_language_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Language::delete_language_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Language::delete_language_alias ( NAME )"
.IP "\fBLocale::Codes::Language::rename_language_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::rename_language_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::add_language_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::delete_language_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::delete_language_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-2/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-2/"
Source of the \s-1ISO 639\-2\s0 codes.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/"
Source of the \s-1ISO 639\-5\s0 codes.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language5.16.3pm              0100644 0001750 0001750 00000021442 12566207435 026011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language 3pm"
.TH Locale::Codes::Language 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language \- standard codes for language identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Language;
\&
\&   $lang = code2language(\*(Aqen\*(Aq);        # $lang gets \*(AqEnglish\*(Aq
\&   $code = language2code(\*(AqFrench\*(Aq);    # $code gets \*(Aqfr\*(Aq
\&
\&   @codes   = all_language_codes();
\&   @names   = all_language_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Language\*(C'\fR module provides access to standard codes used
for identifying languages, such as those as defined in \s-1ISO\s0 639.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
639 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lang = code2language(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lang = code2language(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_LANG_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_LANG_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO\s0 639\-1, such
as 'he' for Hebrew.  It also includes additions to this set included
in the \s-1IANA\s0 language registry.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_LANG_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_LANG_ALPHA_3"
This is the set of three-letter (lowercase) bibliographic codes from
\&\s-1ISO\s0 639\-2 and 639\-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the \s-1IANA\s0 language registry.
.IP "\fBterm, \s-1LOCALE_LANG_TERM\s0\fR" 4
.IX Item "term, LOCALE_LANG_TERM"
This is the set of three-letter (lowercase) terminologic codes from
\&\s-1ISO\s0 639.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2language ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2language ( CODE [,CODESET] )"
.PD 0
.IP "\fBlanguage2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "language2code ( NAME [,CODESET] )"
.IP "\fBlanguage_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "language_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_language_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_codes ( [CODESET] )"
.IP "\fBall_language_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_names ( [CODESET] )"
.IP "\fBLocale::Codes::Language::rename_language  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::rename_language  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::add_language  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Language::delete_language  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::delete_language  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::Language::add_language_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Language::delete_language_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::Language::delete_language_alias  ( NAME )"
.IP "\fBLocale::Codes::Language::rename_language_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::rename_language_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::add_language_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::delete_language_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::delete_language_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-2/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-2/"
Source of the \s-1ISO\s0 639\-2 codes.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/"
Source of the \s-1ISO\s0 639\-5 codes.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language5.18.3pm              0100644 0001750 0001750 00000021753 12566207457 026024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language 3pm"
.TH Locale::Codes::Language 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language \- standard codes for language identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Language;
\&
\&   $lang = code2language(\*(Aqen\*(Aq);        # $lang gets \*(AqEnglish\*(Aq
\&   $code = language2code(\*(AqFrench\*(Aq);    # $code gets \*(Aqfr\*(Aq
\&
\&   @codes   = all_language_codes();
\&   @names   = all_language_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Language\*(C'\fR module provides access to standard codes used
for identifying languages, such as those as defined in \s-1ISO 639.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
639\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lang = code2language(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lang = code2language(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_LANG_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_LANG_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 639\-1,\s0 such
as 'he' for Hebrew.  It also includes additions to this set included
in the \s-1IANA\s0 language registry.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_LANG_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_LANG_ALPHA_3"
This is the set of three-letter (lowercase) bibliographic codes from
\&\s-1ISO 639\-2\s0 and 639\-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the \s-1IANA\s0 language registry.
.IP "\fBterm, \s-1LOCALE_LANG_TERM\s0\fR" 4
.IX Item "term, LOCALE_LANG_TERM"
This is the set of three-letter (lowercase) terminologic codes from
\&\s-1ISO 639.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2language ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2language ( CODE [,CODESET] )"
.PD 0
.IP "\fBlanguage2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "language2code ( NAME [,CODESET] )"
.IP "\fBlanguage_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "language_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_language_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_codes ( [CODESET] )"
.IP "\fBall_language_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_names ( [CODESET] )"
.IP "\fBLocale::Codes::Language::rename_language  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::rename_language ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::add_language ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Language::delete_language  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::delete_language ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Language::add_language_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Language::delete_language_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Language::delete_language_alias ( NAME )"
.IP "\fBLocale::Codes::Language::rename_language_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::rename_language_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::add_language_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::add_language_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Language::delete_language_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Language::delete_language_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-2/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-2/"
Source of the \s-1ISO 639\-2\s0 codes.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/"
Source of the \s-1ISO 639\-5\s0 codes.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language_Codes.3pm            0100644 0001750 0001750 00000011250 12566207460 026606  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language_Codes 3pm"
.TH Locale::Codes::Language_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language_Codes \- language codes for the Locale::Codes::Language module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Language module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language_Codes5.16.3pm        0100644 0001750 0001750 00000010727 12566207436 027133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language_Codes 3pm"
.TH Locale::Codes::Language_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language_Codes \- language codes for the Locale::Codes::Language module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Language module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language_Codes5.18.3pm        0100644 0001750 0001750 00000011250 12566207460 027122  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language_Codes 3pm"
.TH Locale::Codes::Language_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language_Codes \- language codes for the Locale::Codes::Language module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Language module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language_Retired.3pm          0100644 0001750 0001750 00000011266 12566207460 027156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language_Retired 3pm"
.TH Locale::Codes::Language_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language_Retired \- retired language codes for the Locale::Codes::Language module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Language module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language_Retired5.16.3pm      0100644 0001750 0001750 00000010745 12566207436 027474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language_Retired 3pm"
.TH Locale::Codes::Language_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language_Retired \- retired language codes for the Locale::Codes::Language module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Language module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Language_Retired5.18.3pm      0100644 0001750 0001750 00000011266 12566207460 027472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Language_Retired 3pm"
.TH Locale::Codes::Language_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Language_Retired \- retired language codes for the Locale::Codes::Language module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Language module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script.3pm                    0100644 0001750 0001750 00000021163 12566207460 025216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script 3pm"
.TH Locale::Codes::Script 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script \- standard codes for script identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Script;
\&
\&   $script  = code2script(\*(Aqphnx\*(Aq);                     # \*(AqPhoenician\*(Aq
\&   $code    = script2code(\*(AqPhoenician\*(Aq);               # \*(AqPhnx\*(Aq
\&   $code    = script2code(\*(AqPhoenician\*(Aq,
\&                          LOCALE_CODE_NUMERIC);        # 115
\&
\&   @codes   = all_script_codes();
\&   @scripts = all_script_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Script\*(C'\fR module provides access to standards codes used
for identifying scripts, such as those defined in \s-1ISO 15924.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
15924\s0 four-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
scripts. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $script = code2script(\*(Aqphnx\*(Aq,\*(Aqalpha\*(Aq);
\&   $script = code2script(\*(Aqphnx\*(Aq,LOCALE_SCRIPT_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_SCRIPT_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_SCRIPT_ALPHA"
This is a set of four-letter (capitalized) codes from \s-1ISO 15924\s0
such as 'Phnx' for Phoenician.  It also includes additions to this
set included in the \s-1IANA\s0 language registry.
.Sp
The Zxxx, Zyyy, and Zzzz codes are not used.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_SCRIPT_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_SCRIPT_NUMERIC"
This is a set of three-digit numeric codes from \s-1ISO 15924\s0 such as 115
for Phoenician.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2script ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2script ( CODE [,CODESET] )"
.PD 0
.IP "\fBscript2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "script2code ( NAME [,CODESET] )"
.IP "\fBscript_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "script_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_script_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_script_codes ( [CODESET] )"
.IP "\fBall_script_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_script_names ( [CODESET] )"
.IP "\fBLocale::Codes::Script::rename_script  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::rename_script ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::add_script ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Script::delete_script  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::delete_script ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Script::add_script_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Script::delete_script_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Script::delete_script_alias ( NAME )"
.IP "\fBLocale::Codes::Script::rename_script_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::rename_script_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::add_script_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::delete_script_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::delete_script_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.unicode.org/iso15924/\fR" 4
.IX Item "http://www.unicode.org/iso15924/"
Home page for \s-1ISO 15924.\s0
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script5.16.3pm                0100644 0001750 0001750 00000020652 12566207436 025535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script 3pm"
.TH Locale::Codes::Script 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script \- standard codes for script identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Script;
\&
\&   $script  = code2script(\*(Aqphnx\*(Aq);                     # \*(AqPhoenician\*(Aq
\&   $code    = script2code(\*(AqPhoenician\*(Aq);               # \*(AqPhnx\*(Aq
\&   $code    = script2code(\*(AqPhoenician\*(Aq,
\&                          LOCALE_CODE_NUMERIC);        # 115
\&
\&   @codes   = all_script_codes();
\&   @scripts = all_script_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Script\*(C'\fR module provides access to standards codes used
for identifying scripts, such as those defined in \s-1ISO\s0 15924.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
15924 four-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
scripts. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $script = code2script(\*(Aqphnx\*(Aq,\*(Aqalpha\*(Aq);
\&   $script = code2script(\*(Aqphnx\*(Aq,LOCALE_SCRIPT_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_SCRIPT_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_SCRIPT_ALPHA"
This is a set of four-letter (capitalized) codes from \s-1ISO\s0 15924
such as 'Phnx' for Phoenician.  It also includes additions to this
set included in the \s-1IANA\s0 language registry.
.Sp
The Zxxx, Zyyy, and Zzzz codes are not used.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_SCRIPT_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_SCRIPT_NUMERIC"
This is a set of three-digit numeric codes from \s-1ISO\s0 15924 such as 115
for Phoenician.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2script ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2script ( CODE [,CODESET] )"
.PD 0
.IP "\fBscript2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "script2code ( NAME [,CODESET] )"
.IP "\fBscript_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "script_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_script_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_script_codes ( [CODESET] )"
.IP "\fBall_script_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_script_names ( [CODESET] )"
.IP "\fBLocale::Codes::Script::rename_script  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::rename_script  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::add_script  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Script::delete_script  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::delete_script  ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Codes::Script::add_script_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Script::delete_script_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Codes::Script::delete_script_alias  ( NAME )"
.IP "\fBLocale::Codes::Script::rename_script_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::rename_script_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::add_script_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::delete_script_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::delete_script_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.unicode.org/iso15924/\fR" 4
.IX Item "http://www.unicode.org/iso15924/"
Home page for \s-1ISO\s0 15924.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script5.18.3pm                0100644 0001750 0001750 00000021163 12566207460 025532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script 3pm"
.TH Locale::Codes::Script 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script \- standard codes for script identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Codes::Script;
\&
\&   $script  = code2script(\*(Aqphnx\*(Aq);                     # \*(AqPhoenician\*(Aq
\&   $code    = script2code(\*(AqPhoenician\*(Aq);               # \*(AqPhnx\*(Aq
\&   $code    = script2code(\*(AqPhoenician\*(Aq,
\&                          LOCALE_CODE_NUMERIC);        # 115
\&
\&   @codes   = all_script_codes();
\&   @scripts = all_script_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Codes::Script\*(C'\fR module provides access to standards codes used
for identifying scripts, such as those defined in \s-1ISO 15924.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
15924\s0 four-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
scripts. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $script = code2script(\*(Aqphnx\*(Aq,\*(Aqalpha\*(Aq);
\&   $script = code2script(\*(Aqphnx\*(Aq,LOCALE_SCRIPT_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_SCRIPT_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_SCRIPT_ALPHA"
This is a set of four-letter (capitalized) codes from \s-1ISO 15924\s0
such as 'Phnx' for Phoenician.  It also includes additions to this
set included in the \s-1IANA\s0 language registry.
.Sp
The Zxxx, Zyyy, and Zzzz codes are not used.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_SCRIPT_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_SCRIPT_NUMERIC"
This is a set of three-digit numeric codes from \s-1ISO 15924\s0 such as 115
for Phoenician.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2script ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2script ( CODE [,CODESET] )"
.PD 0
.IP "\fBscript2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "script2code ( NAME [,CODESET] )"
.IP "\fBscript_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "script_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_script_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_script_codes ( [CODESET] )"
.IP "\fBall_script_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_script_names ( [CODESET] )"
.IP "\fBLocale::Codes::Script::rename_script  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::rename_script ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::add_script ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Codes::Script::delete_script  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::delete_script ( CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Codes::Script::add_script_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Codes::Script::delete_script_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Codes::Script::delete_script_alias ( NAME )"
.IP "\fBLocale::Codes::Script::rename_script_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::rename_script_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::add_script_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::add_script_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Codes::Script::delete_script_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Codes::Script::delete_script_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.unicode.org/iso15924/\fR" 4
.IX Item "http://www.unicode.org/iso15924/"
Home page for \s-1ISO 15924.\s0
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script_Codes.3pm              0100644 0001750 0001750 00000011234 12566207460 026331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script_Codes 3pm"
.TH Locale::Codes::Script_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script_Codes \- script codes for the Locale::Codes::Script module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Script module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script_Codes5.16.3pm          0100644 0001750 0001750 00000010713 12566207436 026647  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script_Codes 3pm"
.TH Locale::Codes::Script_Codes 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script_Codes \- script codes for the Locale::Codes::Script module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Script module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script_Codes5.18.3pm          0100644 0001750 0001750 00000011234 12566207460 026645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script_Codes 3pm"
.TH Locale::Codes::Script_Codes 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script_Codes \- script codes for the Locale::Codes::Script module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Script module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script_Retired.3pm            0100644 0001750 0001750 00000011252 12566207460 026672  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script_Retired 3pm"
.TH Locale::Codes::Script_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script_Retired \- retired script codes for the Locale::Codes::Script module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Script module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script_Retired5.16.3pm        0100644 0001750 0001750 00000010731 12566207436 027210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script_Retired 3pm"
.TH Locale::Codes::Script_Retired 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script_Retired \- retired script codes for the Locale::Codes::Script module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Script module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Codes::Script_Retired5.18.3pm        0100644 0001750 0001750 00000011252 12566207460 027206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Codes::Script_Retired 3pm"
.TH Locale::Codes::Script_Retired 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Codes::Script_Retired \- retired script codes for the Locale::Codes::Script module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains data used by the Locale::Codes::Script module. It is
not intended to be used directly, and contains no calleable routines.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Country.3pm                          0100644 0001750 0001750 00000030435 12566207460 024255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Country 3pm"
.TH Locale::Country 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Country \- standard codes for country identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Country;
\&
\&   $country = code2country(\*(Aqjp\*(Aq [,CODESET]);        # $country gets \*(AqJapan\*(Aq
\&   $code    = country2code(\*(AqNorway\*(Aq [,CODESET]);    # $code gets \*(Aqno\*(Aq
\&
\&   @codes   = all_country_codes( [CODESET]);
\&   @names   = all_country_names();
\&
\&   # semi\-private routines
\&   Locale::Country::alias_code(\*(Aquk\*(Aq => \*(Aqgb\*(Aq);
\&   Locale::Country::rename_country(\*(Aqgb\*(Aq => \*(AqGreat Britain\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Country\*(C'\fR module provides access to several code sets
that can be used for identifying countries, such as those defined in
\&\s-1ISO 3166\-1.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
3166\-1\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $country = code2country(\*(Aqjp\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $country = code2country(\*(Aqjp\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_CODE_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_CODE_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 3166\-1,\s0 such
as 'tv' for Tuvalu.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_CODE_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_CODE_ALPHA_3"
This is the set of three-letter (lowercase) codes from \s-1ISO 3166\-1,\s0
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.
.IP "\fBnumeric, \s-1LOCALE_CODE_NUMERIC\s0\fR" 4
.IX Item "numeric, LOCALE_CODE_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 3166\-1,\s0 such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.
.Sp
If a 2\-digit code is entered, it is converted to 3 digits by prepending
a 0.
.IP "\fBfips\-10, \s-1LOCALE_CODE_FIPS\s0\fR" 4
.IX Item "fips-10, LOCALE_CODE_FIPS"
The \s-1FIPS 10\s0 data are two-letter (uppercase) codes assigned by the
National Geospatial-Intelligence Agency.
.IP "\fBdom, \s-1LOCALE_CODE_DOM\s0\fR" 4
.IX Item "dom, LOCALE_CODE_DOM"
The \s-1IANA\s0 is responsible for delegating management of the top level country
domains.  The country domains are the two-letter (lowercase) codes from \s-1ISO 3166\s0
with a few other additions.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2country ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2country ( CODE [,CODESET] )"
.PD 0
.IP "\fBcountry2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "country2code ( NAME [,CODESET] )"
.IP "\fBcountry_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "country_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_country_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_codes ( [CODESET] )"
.IP "\fBall_country_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_names ( [CODESET] )"
.IP "\fBLocale::Country::rename_country  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::rename_country ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Country::add_country  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::add_country ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Country::delete_country  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::delete_country ( CODE [,CODESET] )"
.IP "\fBLocale::Country::add_country_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Country::add_country_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Country::delete_country_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Country::delete_country_alias ( NAME )"
.IP "\fBLocale::Country::rename_country_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::rename_country_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Country::add_country_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::add_country_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Country::delete_country_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::delete_country_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.IP "\fBalias_code ( \s-1ALIAS, CODE\s0 [,CODESET] )\fR" 4
.IX Item "alias_code ( ALIAS, CODE [,CODESET] )"
Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.
.Sp
As of 3.10, the internal data for all types of codes can be modified.
.Sp
The alias_code function is preserved for backwards compatibility, but
the following two are identical:
.Sp
.Vb 2
\&   alias_code(ALIAS,CODE [,CODESET]);
\&   rename_country_code(CODE,ALIAS [,CODESET]);
.Ve
.Sp
and the latter should be used for consistency.
.Sp
The alias_code function is deprecated and will be removed at some point
in the future.
.Sp
\&\fBNote:\fR this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBLocale::SubCountry\fR" 4
.IX Item "Locale::SubCountry"
\&\s-1ISO\s0 codes for country sub-divisions (states, counties, provinces,
etc), as defined in \s-1ISO 3166\-2. \s0 This module is not part of the
Locale-Codes distribution, but is available from \s-1CPAN\s0 in
CPAN/modules/by\-module/Locale/
.IP "\fBhttp://www.iso.org/iso/country_codes\fR" 4
.IX Item "http://www.iso.org/iso/country_codes"
Official home page for the \s-1ISO 3166\s0 maintenance agency.
.Sp
Unfortunately, they do not make the actual \s-1ISO\s0 available for free,
so I cannot check the alpha\-3 and numerical codes here.
.IP "\fBhttp://www.iso.org/iso/list\-en1\-semic\-3.txt\fR" 4
.IX Item "http://www.iso.org/iso/list-en1-semic-3.txt"
.PD 0
.IP "\fBhttp://www.iso.org/iso/home/standards/country_codes/iso\-3166\-1_decoding_table.htm\fR" 4
.IX Item "http://www.iso.org/iso/home/standards/country_codes/iso-3166-1_decoding_table.htm"
.PD
The source of \s-1ISO 3166\-1\s0 two-letter codes used by this
module.
.IP "\fBhttp://unstats.un.org/unsd/methods/m49/m49alpha.htm\fR" 4
.IX Item "http://unstats.un.org/unsd/methods/m49/m49alpha.htm"
The source of the official \s-1ISO 3166\-1\s0 three-letter codes and
three-digit codes.
.Sp
For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the \s-1UN\s0 site.  I
get as much of the data from here as I can.
.IP "\fBhttp://earth\-info.nga.mil/gns/html/digraphs.htm\fR" 4
.IX Item "http://earth-info.nga.mil/gns/html/digraphs.htm"
The official list of the \s-1FIPS 10\s0 codes.
.IP "\fBhttp://www.iana.org/domains/\fR" 4
.IX Item "http://www.iana.org/domains/"
Official source of the top-level domain names.
.IP "\fBhttps://www.cia.gov/library/publications/the\-world\-factbook/appendix/print_appendix\-d.html\fR" 4
.IX Item "https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html"
The World Factbook maintained by the \s-1CIA\s0 is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.
.IP "\fBhttp://www.statoids.com/wab.html\fR" 4
.IX Item "http://www.statoids.com/wab.html"
Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Country5.16.3pm                      0100644 0001750 0001750 00000027470 12566207436 024577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Country 3pm"
.TH Locale::Country 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Country \- standard codes for country identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Country;
\&
\&   $country = code2country(\*(Aqjp\*(Aq [,CODESET]);        # $country gets \*(AqJapan\*(Aq
\&   $code    = country2code(\*(AqNorway\*(Aq [,CODESET]);    # $code gets \*(Aqno\*(Aq
\&
\&   @codes   = all_country_codes( [CODESET]);
\&   @names   = all_country_names();
\&
\&   # semi\-private routines
\&   Locale::Country::alias_code(\*(Aquk\*(Aq => \*(Aqgb\*(Aq);
\&   Locale::Country::rename_country(\*(Aqgb\*(Aq => \*(AqGreat Britain\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Country\*(C'\fR module provides access to several code sets
that can be used for identifying countries, such as those defined in
\&\s-1ISO\s0 3166\-1.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
3166\-1 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $country = code2country(\*(Aqjp\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $country = code2country(\*(Aqjp\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_CODE_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_CODE_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO\s0 3166\-1, such
as 'tv' for Tuvalu.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_CODE_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_CODE_ALPHA_3"
This is the set of three-letter (lowercase) codes from \s-1ISO\s0 3166\-1,
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.
.IP "\fBnumeric, \s-1LOCALE_CODE_NUMERIC\s0\fR" 4
.IX Item "numeric, LOCALE_CODE_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO\s0 3166\-1, such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.
.Sp
If a 2\-digit code is entered, it is converted to 3 digits by prepending
a 0.
.IP "\fBfips\-10, \s-1LOCALE_CODE_FIPS\s0\fR" 4
.IX Item "fips-10, LOCALE_CODE_FIPS"
The \s-1FIPS\s0 10 data are two-letter (uppercase) codes assigned by the
National Geospatial-Intelligence Agency.
.IP "\fBdom, \s-1LOCALE_CODE_DOM\s0\fR" 4
.IX Item "dom, LOCALE_CODE_DOM"
The \s-1IANA\s0 is responsible for assigning two-letter (uppercase) top-level
domain names to each country.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2country ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2country ( CODE [,CODESET] )"
.PD 0
.IP "\fBcountry2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "country2code ( NAME [,CODESET] )"
.IP "\fBcountry_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "country_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_country_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_codes ( [CODESET] )"
.IP "\fBall_country_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_names ( [CODESET] )"
.IP "\fBLocale::Country::rename_country  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Country::rename_country  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Country::add_country  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Country::add_country  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Country::delete_country  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::delete_country  ( CODE [,CODESET] )"
.IP "\fBLocale::Country::add_country_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Country::add_country_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Country::delete_country_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Country::delete_country_alias  ( NAME )"
.IP "\fBLocale::Country::rename_country_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Country::rename_country_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Country::add_country_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Country::add_country_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Country::delete_country_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::delete_country_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.IP "\fBalias_code ( \s-1ALIAS\s0, \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "alias_code ( ALIAS, CODE [,CODESET] )"
Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.
.Sp
As of 3.10, the internal data for all types of codes can be modified.
.Sp
The alias_code function is preserved for backwards compatibility, but
the following two are identical:
.Sp
.Vb 2
\&   alias_code(ALIAS,CODE [,CODESET]);
\&   rename_country_code(CODE,ALIAS [,CODESET]);
.Ve
.Sp
and the latter should be used for consistency.
.Sp
The alias_code function is deprecated and will be removed at some point
in the future.
.Sp
\&\fBNote:\fR this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBLocale::SubCountry\fR" 4
.IX Item "Locale::SubCountry"
\&\s-1ISO\s0 codes for country sub-divisions (states, counties, provinces,
etc), as defined in \s-1ISO\s0 3166\-2.  This module is not part of the
Locale-Codes distribution, but is available from \s-1CPAN\s0 in
CPAN/modules/by\-module/Locale/
.IP "\fBhttp://www.iso.org/iso/country_codes\fR" 4
.IX Item "http://www.iso.org/iso/country_codes"
Official home page for the \s-1ISO\s0 3166 maintenance agency.
.Sp
Unfortunately, they do not make the actual \s-1ISO\s0 available for free,
so I cannot check the alpha\-3 and numerical codes here.
.IP "\fBhttp://www.iso.org/iso/list\-en1\-semic\-3.txt\fR" 4
.IX Item "http://www.iso.org/iso/list-en1-semic-3.txt"
The source of \s-1ISO\s0 3166\-1 two-letter codes used by this
module.
.IP "\fBhttp://unstats.un.org/unsd/methods/m49/m49alpha.htm\fR" 4
.IX Item "http://unstats.un.org/unsd/methods/m49/m49alpha.htm"
The source of the official \s-1ISO\s0 3166\-1 three-letter codes and
three-digit codes.
.Sp
For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the \s-1UN\s0 site.  I
get as much of the data from here as I can.
.IP "\fBhttp://earth\-info.nga.mil/gns/html/digraphs.htm\fR" 4
.IX Item "http://earth-info.nga.mil/gns/html/digraphs.htm"
The official list of the \s-1FIPS\s0 10 codes.
.IP "\fBhttp://www.iana.org/domains/\fR" 4
.IX Item "http://www.iana.org/domains/"
Official source of the top-level domain names.
.IP "\fBhttps://www.cia.gov/library/publications/the\-world\-factbook/appendix/print_appendix\-d.html\fR" 4
.IX Item "https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html"
The World Factbook maintained by the \s-1CIA\s0 is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.
.IP "\fBhttp://www.statoids.com/wab.html\fR" 4
.IX Item "http://www.statoids.com/wab.html"
Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Country5.18.3pm                      0100644 0001750 0001750 00000030435 12566207460 024571  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Country 3pm"
.TH Locale::Country 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Country \- standard codes for country identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Country;
\&
\&   $country = code2country(\*(Aqjp\*(Aq [,CODESET]);        # $country gets \*(AqJapan\*(Aq
\&   $code    = country2code(\*(AqNorway\*(Aq [,CODESET]);    # $code gets \*(Aqno\*(Aq
\&
\&   @codes   = all_country_codes( [CODESET]);
\&   @names   = all_country_names();
\&
\&   # semi\-private routines
\&   Locale::Country::alias_code(\*(Aquk\*(Aq => \*(Aqgb\*(Aq);
\&   Locale::Country::rename_country(\*(Aqgb\*(Aq => \*(AqGreat Britain\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Country\*(C'\fR module provides access to several code sets
that can be used for identifying countries, such as those defined in
\&\s-1ISO 3166\-1.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
3166\-1\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $country = code2country(\*(Aqjp\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $country = code2country(\*(Aqjp\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_CODE_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_CODE_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 3166\-1,\s0 such
as 'tv' for Tuvalu.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_CODE_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_CODE_ALPHA_3"
This is the set of three-letter (lowercase) codes from \s-1ISO 3166\-1,\s0
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.
.IP "\fBnumeric, \s-1LOCALE_CODE_NUMERIC\s0\fR" 4
.IX Item "numeric, LOCALE_CODE_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 3166\-1,\s0 such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.
.Sp
If a 2\-digit code is entered, it is converted to 3 digits by prepending
a 0.
.IP "\fBfips\-10, \s-1LOCALE_CODE_FIPS\s0\fR" 4
.IX Item "fips-10, LOCALE_CODE_FIPS"
The \s-1FIPS 10\s0 data are two-letter (uppercase) codes assigned by the
National Geospatial-Intelligence Agency.
.IP "\fBdom, \s-1LOCALE_CODE_DOM\s0\fR" 4
.IX Item "dom, LOCALE_CODE_DOM"
The \s-1IANA\s0 is responsible for delegating management of the top level country
domains.  The country domains are the two-letter (lowercase) codes from \s-1ISO 3166\s0
with a few other additions.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2country ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2country ( CODE [,CODESET] )"
.PD 0
.IP "\fBcountry2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "country2code ( NAME [,CODESET] )"
.IP "\fBcountry_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "country_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_country_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_codes ( [CODESET] )"
.IP "\fBall_country_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_country_names ( [CODESET] )"
.IP "\fBLocale::Country::rename_country  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::rename_country ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Country::add_country  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::add_country ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Country::delete_country  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::delete_country ( CODE [,CODESET] )"
.IP "\fBLocale::Country::add_country_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Country::add_country_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Country::delete_country_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Country::delete_country_alias ( NAME )"
.IP "\fBLocale::Country::rename_country_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::rename_country_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Country::add_country_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::add_country_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Country::delete_country_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Country::delete_country_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.IP "\fBalias_code ( \s-1ALIAS, CODE\s0 [,CODESET] )\fR" 4
.IX Item "alias_code ( ALIAS, CODE [,CODESET] )"
Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.
.Sp
As of 3.10, the internal data for all types of codes can be modified.
.Sp
The alias_code function is preserved for backwards compatibility, but
the following two are identical:
.Sp
.Vb 2
\&   alias_code(ALIAS,CODE [,CODESET]);
\&   rename_country_code(CODE,ALIAS [,CODESET]);
.Ve
.Sp
and the latter should be used for consistency.
.Sp
The alias_code function is deprecated and will be removed at some point
in the future.
.Sp
\&\fBNote:\fR this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBLocale::SubCountry\fR" 4
.IX Item "Locale::SubCountry"
\&\s-1ISO\s0 codes for country sub-divisions (states, counties, provinces,
etc), as defined in \s-1ISO 3166\-2. \s0 This module is not part of the
Locale-Codes distribution, but is available from \s-1CPAN\s0 in
CPAN/modules/by\-module/Locale/
.IP "\fBhttp://www.iso.org/iso/country_codes\fR" 4
.IX Item "http://www.iso.org/iso/country_codes"
Official home page for the \s-1ISO 3166\s0 maintenance agency.
.Sp
Unfortunately, they do not make the actual \s-1ISO\s0 available for free,
so I cannot check the alpha\-3 and numerical codes here.
.IP "\fBhttp://www.iso.org/iso/list\-en1\-semic\-3.txt\fR" 4
.IX Item "http://www.iso.org/iso/list-en1-semic-3.txt"
.PD 0
.IP "\fBhttp://www.iso.org/iso/home/standards/country_codes/iso\-3166\-1_decoding_table.htm\fR" 4
.IX Item "http://www.iso.org/iso/home/standards/country_codes/iso-3166-1_decoding_table.htm"
.PD
The source of \s-1ISO 3166\-1\s0 two-letter codes used by this
module.
.IP "\fBhttp://unstats.un.org/unsd/methods/m49/m49alpha.htm\fR" 4
.IX Item "http://unstats.un.org/unsd/methods/m49/m49alpha.htm"
The source of the official \s-1ISO 3166\-1\s0 three-letter codes and
three-digit codes.
.Sp
For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the \s-1UN\s0 site.  I
get as much of the data from here as I can.
.IP "\fBhttp://earth\-info.nga.mil/gns/html/digraphs.htm\fR" 4
.IX Item "http://earth-info.nga.mil/gns/html/digraphs.htm"
The official list of the \s-1FIPS 10\s0 codes.
.IP "\fBhttp://www.iana.org/domains/\fR" 4
.IX Item "http://www.iana.org/domains/"
Official source of the top-level domain names.
.IP "\fBhttps://www.cia.gov/library/publications/the\-world\-factbook/appendix/print_appendix\-d.html\fR" 4
.IX Item "https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html"
The World Factbook maintained by the \s-1CIA\s0 is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.
.IP "\fBhttp://www.statoids.com/wab.html\fR" 4
.IX Item "http://www.statoids.com/wab.html"
Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Currency.3pm                         0100644 0001750 0001750 00000020575 12566207460 024410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Currency 3pm"
.TH Locale::Currency 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Currency \- standard codes for currency identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Locale::Currency;
\&
\&    $curr = code2currency(\*(Aqusd\*(Aq);     # $curr gets \*(AqUS Dollar\*(Aq
\&    $code = currency2code(\*(AqEuro\*(Aq);    # $code gets \*(Aqeur\*(Aq
\&
\&    @codes   = all_currency_codes();
\&    @names   = all_currency_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Currency\*(C'\fR module provides access to standard codes used
for identifying currencies and funds, such as those defined in \s-1ISO 4217.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
4217\s0 three-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $curr = code2currency(\*(Aqusd\*(Aq,\*(Aqalpha\*(Aq);
\&   $curr = code2currency(\*(Aqusd\*(Aq,LOCALE_CURR_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_CURR_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_CURR_ALPHA"
This is a set of three-letter (uppercase) codes from \s-1ISO 4217\s0 such
as \s-1EUR\s0 for Euro.
.Sp
Two of the codes specified by the standard (\s-1XTS\s0 which is reserved
for testing purposes and \s-1XXX\s0 which is for transactions where no
currency is involved) are omitted.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_CURR_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_CURR_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 4217.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2currency ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2currency ( CODE [,CODESET] )"
.PD 0
.IP "\fBcurrency2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "currency2code ( NAME [,CODESET] )"
.IP "\fBcurrency_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "currency_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_currency_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_codes ( [CODESET] )"
.IP "\fBall_currency_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_names ( [CODESET] )"
.IP "\fBLocale::Currency::rename_currency  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::rename_currency ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Currency::add_currency  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::add_currency ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Currency::delete_currency  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::delete_currency ( CODE [,CODESET] )"
.IP "\fBLocale::Currency::add_currency_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Currency::add_currency_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Currency::delete_currency_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Currency::delete_currency_alias ( NAME )"
.IP "\fBLocale::Currency::rename_currency_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::rename_currency_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Currency::add_currency_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::add_currency_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Currency::delete_currency_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::delete_currency_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iso.org/iso/support/currency_codes_list\-1.htm\fR" 4
.IX Item "http://www.iso.org/iso/support/currency_codes_list-1.htm"
The \s-1ISO 4217\s0 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001      Michael Hennecke
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Currency5.16.3pm                     0100644 0001750 0001750 00000020264 12566207436 024720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Currency 3pm"
.TH Locale::Currency 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Currency \- standard codes for currency identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Locale::Currency;
\&
\&    $curr = code2currency(\*(Aqusd\*(Aq);     # $curr gets \*(AqUS Dollar\*(Aq
\&    $code = currency2code(\*(AqEuro\*(Aq);    # $code gets \*(Aqeur\*(Aq
\&
\&    @codes   = all_currency_codes();
\&    @names   = all_currency_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Currency\*(C'\fR module provides access to standard codes used
for identifying currencies and funds, such as those defined in \s-1ISO\s0 4217.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
4217 three-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $curr = code2currency(\*(Aqusd\*(Aq,\*(Aqalpha\*(Aq);
\&   $curr = code2currency(\*(Aqusd\*(Aq,LOCALE_CURR_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_CURR_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_CURR_ALPHA"
This is a set of three-letter (uppercase) codes from \s-1ISO\s0 4217 such
as \s-1EUR\s0 for Euro.
.Sp
Two of the codes specified by the standard (\s-1XTS\s0 which is reserved
for testing purposes and \s-1XXX\s0 which is for transactions where no
currency is involved) are omitted.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_CURR_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_CURR_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO\s0 4217.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2currency ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2currency ( CODE [,CODESET] )"
.PD 0
.IP "\fBcurrency2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "currency2code ( NAME [,CODESET] )"
.IP "\fBcurrency_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "currency_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_currency_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_codes ( [CODESET] )"
.IP "\fBall_currency_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_names ( [CODESET] )"
.IP "\fBLocale::Currency::rename_currency  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Currency::rename_currency  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Currency::add_currency  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Currency::add_currency  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Currency::delete_currency  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::delete_currency  ( CODE [,CODESET] )"
.IP "\fBLocale::Currency::add_currency_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Currency::add_currency_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Currency::delete_currency_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Currency::delete_currency_alias  ( NAME )"
.IP "\fBLocale::Currency::rename_currency_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Currency::rename_currency_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Currency::add_currency_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Currency::add_currency_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Currency::delete_currency_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::delete_currency_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iso.org/iso/support/currency_codes_list\-1.htm\fR" 4
.IX Item "http://www.iso.org/iso/support/currency_codes_list-1.htm"
The \s-1ISO\s0 4217 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001      Michael Hennecke
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Currency5.18.3pm                     0100644 0001750 0001750 00000020575 12566207460 024724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Currency 3pm"
.TH Locale::Currency 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Currency \- standard codes for currency identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Locale::Currency;
\&
\&    $curr = code2currency(\*(Aqusd\*(Aq);     # $curr gets \*(AqUS Dollar\*(Aq
\&    $code = currency2code(\*(AqEuro\*(Aq);    # $code gets \*(Aqeur\*(Aq
\&
\&    @codes   = all_currency_codes();
\&    @names   = all_currency_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Currency\*(C'\fR module provides access to standard codes used
for identifying currencies and funds, such as those defined in \s-1ISO 4217.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
4217\s0 three-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $curr = code2currency(\*(Aqusd\*(Aq,\*(Aqalpha\*(Aq);
\&   $curr = code2currency(\*(Aqusd\*(Aq,LOCALE_CURR_ALPHA);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha, \s-1LOCALE_CURR_ALPHA\s0\fR" 4
.IX Item "alpha, LOCALE_CURR_ALPHA"
This is a set of three-letter (uppercase) codes from \s-1ISO 4217\s0 such
as \s-1EUR\s0 for Euro.
.Sp
Two of the codes specified by the standard (\s-1XTS\s0 which is reserved
for testing purposes and \s-1XXX\s0 which is for transactions where no
currency is involved) are omitted.
.Sp
This is the default code set.
.IP "\fBnum, \s-1LOCALE_CURR_NUMERIC\s0\fR" 4
.IX Item "num, LOCALE_CURR_NUMERIC"
This is the set of three-digit numeric codes from \s-1ISO 4217.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2currency ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2currency ( CODE [,CODESET] )"
.PD 0
.IP "\fBcurrency2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "currency2code ( NAME [,CODESET] )"
.IP "\fBcurrency_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "currency_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_currency_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_codes ( [CODESET] )"
.IP "\fBall_currency_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_currency_names ( [CODESET] )"
.IP "\fBLocale::Currency::rename_currency  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::rename_currency ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Currency::add_currency  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::add_currency ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Currency::delete_currency  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::delete_currency ( CODE [,CODESET] )"
.IP "\fBLocale::Currency::add_currency_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Currency::add_currency_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Currency::delete_currency_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Currency::delete_currency_alias ( NAME )"
.IP "\fBLocale::Currency::rename_currency_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::rename_currency_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Currency::add_currency_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::add_currency_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Currency::delete_currency_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Currency::delete_currency_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.iso.org/iso/support/currency_codes_list\-1.htm\fR" 4
.IX Item "http://www.iso.org/iso/support/currency_codes_list-1.htm"
The \s-1ISO 4217\s0 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001      Michael Hennecke
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Language.3pm                         0100644 0001750 0001750 00000021530 12566207460 024331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Language 3pm"
.TH Locale::Language 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Language \- standard codes for language identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Language;
\&
\&   $lang = code2language(\*(Aqen\*(Aq);        # $lang gets \*(AqEnglish\*(Aq
\&   $code = language2code(\*(AqFrench\*(Aq);    # $code gets \*(Aqfr\*(Aq
\&
\&   @codes   = all_language_codes();
\&   @names   = all_language_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Language\*(C'\fR module provides access to standard codes used
for identifying languages, such as those as defined in \s-1ISO 639.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
639\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lang = code2language(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lang = code2language(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_LANG_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_LANG_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 639\-1,\s0 such
as 'he' for Hebrew.  It also includes additions to this set included
in the \s-1IANA\s0 language registry.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_LANG_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_LANG_ALPHA_3"
This is the set of three-letter (lowercase) bibliographic codes from
\&\s-1ISO 639\-2\s0 and 639\-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the \s-1IANA\s0 language registry.
.IP "\fBterm, \s-1LOCALE_LANG_TERM\s0\fR" 4
.IX Item "term, LOCALE_LANG_TERM"
This is the set of three-letter (lowercase) terminologic codes from
\&\s-1ISO 639.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2language ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2language ( CODE [,CODESET] )"
.PD 0
.IP "\fBlanguage2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "language2code ( NAME [,CODESET] )"
.IP "\fBlanguage_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "language_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_language_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_codes ( [CODESET] )"
.IP "\fBall_language_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_names ( [CODESET] )"
.IP "\fBLocale::Language::rename_language  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::rename_language ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Language::add_language  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::add_language ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Language::delete_language  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::delete_language ( CODE [,CODESET] )"
.IP "\fBLocale::Language::add_language_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Language::add_language_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Language::delete_language_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Language::delete_language_alias ( NAME )"
.IP "\fBLocale::Language::rename_language_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::rename_language_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Language::add_language_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::add_language_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Language::delete_language_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::delete_language_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-2/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-2/"
Source of the \s-1ISO 639\-2\s0 codes.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/"
Source of the \s-1ISO 639\-5\s0 codes.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Language5.16.3pm                     0100644 0001750 0001750 00000021217 12566207436 024650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Language 3pm"
.TH Locale::Language 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Language \- standard codes for language identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Language;
\&
\&   $lang = code2language(\*(Aqen\*(Aq);        # $lang gets \*(AqEnglish\*(Aq
\&   $code = language2code(\*(AqFrench\*(Aq);    # $code gets \*(Aqfr\*(Aq
\&
\&   @codes   = all_language_codes();
\&   @names   = all_language_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Language\*(C'\fR module provides access to standard codes used
for identifying languages, such as those as defined in \s-1ISO\s0 639.
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO\s0
639 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lang = code2language(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lang = code2language(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_LANG_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_LANG_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO\s0 639\-1, such
as 'he' for Hebrew.  It also includes additions to this set included
in the \s-1IANA\s0 language registry.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_LANG_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_LANG_ALPHA_3"
This is the set of three-letter (lowercase) bibliographic codes from
\&\s-1ISO\s0 639\-2 and 639\-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the \s-1IANA\s0 language registry.
.IP "\fBterm, \s-1LOCALE_LANG_TERM\s0\fR" 4
.IX Item "term, LOCALE_LANG_TERM"
This is the set of three-letter (lowercase) terminologic codes from
\&\s-1ISO\s0 639.
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2language ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2language ( CODE [,CODESET] )"
.PD 0
.IP "\fBlanguage2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "language2code ( NAME [,CODESET] )"
.IP "\fBlanguage_code2code ( \s-1CODE\s0 ,CODESET ,CODESET2 )\fR" 4
.IX Item "language_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_language_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_codes ( [CODESET] )"
.IP "\fBall_language_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_names ( [CODESET] )"
.IP "\fBLocale::Language::rename_language  ( \s-1CODE\s0 ,NEW_NAME [,CODESET] )\fR" 4
.IX Item "Locale::Language::rename_language  ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Language::add_language  ( \s-1CODE\s0 ,NAME [,CODESET] )\fR" 4
.IX Item "Locale::Language::add_language  ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Language::delete_language  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::delete_language  ( CODE [,CODESET] )"
.IP "\fBLocale::Language::add_language_alias  ( \s-1NAME\s0 ,NEW_NAME )\fR" 4
.IX Item "Locale::Language::add_language_alias  ( NAME ,NEW_NAME )"
.IP "\fBLocale::Language::delete_language_alias  ( \s-1NAME\s0 )\fR" 4
.IX Item "Locale::Language::delete_language_alias  ( NAME )"
.IP "\fBLocale::Language::rename_language_code  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Language::rename_language_code  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Language::add_language_code_alias  ( \s-1CODE\s0 ,NEW_CODE [,CODESET] )\fR" 4
.IX Item "Locale::Language::add_language_code_alias  ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Language::delete_language_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::delete_language_code_alias  ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-2/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-2/"
Source of the \s-1ISO\s0 639\-2 codes.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/"
Source of the \s-1ISO\s0 639\-5 codes.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2012 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Language5.18.3pm                     0100644 0001750 0001750 00000021530 12566207460 024645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Language 3pm"
.TH Locale::Language 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Language \- standard codes for language identification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Locale::Language;
\&
\&   $lang = code2language(\*(Aqen\*(Aq);        # $lang gets \*(AqEnglish\*(Aq
\&   $code = language2code(\*(AqFrench\*(Aq);    # $code gets \*(Aqfr\*(Aq
\&
\&   @codes   = all_language_codes();
\&   @names   = all_language_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Language\*(C'\fR module provides access to standard codes used
for identifying languages, such as those as defined in \s-1ISO 639.\s0
.PP
Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default \s-1ISO
639\s0 two-letter codes will be used.
.SH "SUPPORTED CODE SETS"
.IX Header "SUPPORTED CODE SETS"
There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.
.PP
For example, the two are equivalent:
.PP
.Vb 2
\&   $lang = code2language(\*(Aqen\*(Aq,\*(Aqalpha\-2\*(Aq);
\&   $lang = code2language(\*(Aqen\*(Aq,LOCALE_CODE_ALPHA_2);
.Ve
.PP
The codesets currently supported are:
.IP "\fBalpha\-2, \s-1LOCALE_LANG_ALPHA_2\s0\fR" 4
.IX Item "alpha-2, LOCALE_LANG_ALPHA_2"
This is the set of two-letter (lowercase) codes from \s-1ISO 639\-1,\s0 such
as 'he' for Hebrew.  It also includes additions to this set included
in the \s-1IANA\s0 language registry.
.Sp
This is the default code set.
.IP "\fBalpha\-3, \s-1LOCALE_LANG_ALPHA_3\s0\fR" 4
.IX Item "alpha-3, LOCALE_LANG_ALPHA_3"
This is the set of three-letter (lowercase) bibliographic codes from
\&\s-1ISO 639\-2\s0 and 639\-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the \s-1IANA\s0 language registry.
.IP "\fBterm, \s-1LOCALE_LANG_TERM\s0\fR" 4
.IX Item "term, LOCALE_LANG_TERM"
This is the set of three-letter (lowercase) terminologic codes from
\&\s-1ISO 639.\s0
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBcode2language ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "code2language ( CODE [,CODESET] )"
.PD 0
.IP "\fBlanguage2code ( \s-1NAME\s0 [,CODESET] )\fR" 4
.IX Item "language2code ( NAME [,CODESET] )"
.IP "\fBlanguage_code2code ( \s-1CODE ,CODESET ,CODESET2 \s0)\fR" 4
.IX Item "language_code2code ( CODE ,CODESET ,CODESET2 )"
.IP "\fBall_language_codes ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_codes ( [CODESET] )"
.IP "\fBall_language_names ( [\s-1CODESET\s0] )\fR" 4
.IX Item "all_language_names ( [CODESET] )"
.IP "\fBLocale::Language::rename_language  ( \s-1CODE ,NEW_NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::rename_language ( CODE ,NEW_NAME [,CODESET] )"
.IP "\fBLocale::Language::add_language  ( \s-1CODE ,NAME\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::add_language ( CODE ,NAME [,CODESET] )"
.IP "\fBLocale::Language::delete_language  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::delete_language ( CODE [,CODESET] )"
.IP "\fBLocale::Language::add_language_alias  ( \s-1NAME ,NEW_NAME \s0)\fR" 4
.IX Item "Locale::Language::add_language_alias ( NAME ,NEW_NAME )"
.IP "\fBLocale::Language::delete_language_alias  ( \s-1NAME \s0)\fR" 4
.IX Item "Locale::Language::delete_language_alias ( NAME )"
.IP "\fBLocale::Language::rename_language_code  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::rename_language_code ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Language::add_language_code_alias  ( \s-1CODE ,NEW_CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::add_language_code_alias ( CODE ,NEW_CODE [,CODESET] )"
.IP "\fBLocale::Language::delete_language_code_alias  ( \s-1CODE\s0 [,CODESET] )\fR" 4
.IX Item "Locale::Language::delete_language_code_alias ( CODE [,CODESET] )"
.PD
These routines are all documented in the Locale::Codes::API man page.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBLocale::Codes\fR" 4
.IX Item "Locale::Codes"
The Locale-Codes distribution.
.IP "\fBLocale::Codes::API\fR" 4
.IX Item "Locale::Codes::API"
The list of functions supported by this module.
.IP "\fBhttp://www.loc.gov/standards/iso639\-2/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-2/"
Source of the \s-1ISO 639\-2\s0 codes.
.IP "\fBhttp://www.loc.gov/standards/iso639\-5/\fR" 4
.IX Item "http://www.loc.gov/standards/iso639-5/"
Source of the \s-1ISO 639\-5\s0 codes.
.IP "\fBhttp://www.iana.org/assignments/language\-subtag\-registry\fR" 4
.IX Item "http://www.iana.org/assignments/language-subtag-registry"
The \s-1IANA\s0 language subtag registry.
.SH "AUTHOR"
.IX Header "AUTHOR"
See Locale::Codes for full author history.
.PP
Currently maintained by Sullivan Beck (sbeck@cpan.org).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&   Copyright (c) 1997\-2001 Canon Research Centre Europe (CRE).
\&   Copyright (c) 2001\-2010 Neil Bowers
\&   Copyright (c) 2010\-2013 Sullivan Beck
.Ve
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext.3pm                         0100644 0001750 0001750 00000165604 12566207460 024403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext 3pm"
.TH Locale::Maketext 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext \- framework for localization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  package MyProgram;
\&  use strict;
\&  use MyProgram::L10N;
\&   # ...which inherits from Locale::Maketext
\&  my $lh = MyProgram::L10N\->get_handle() || die "What language?";
\&  ...
\&  # And then any messages your program emits, like:
\&  warn $lh\->maketext( "Can\*(Aqt open file [_1]: [_2]\en", $f, $! );
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is a common feature of applications (whether run directly,
or via the Web) for them to be \*(L"localized\*(R" \*(-- i.e., for them
to a present an English interface to an English-speaker, a German
interface to a German-speaker, and so on for all languages it's
programmed with.  Locale::Maketext
is a framework for software localization; it provides you with the
tools for organizing and accessing the bits of text and text-processing
code that you need for producing localized applications.
.PP
In order to make sense of Maketext and how all its
components fit together, you should probably
go read Locale::Maketext::TPJ13, and
\&\fIthen\fR read the following documentation.
.PP
You may also want to read over the source for \f(CW\*(C`File::Findgrep\*(C'\fR
and its constituent modules \*(-- they are a complete (if small)
example application that uses Maketext.
.SH "QUICK OVERVIEW"
.IX Header "QUICK OVERVIEW"
The basic design of Locale::Maketext is object-oriented, and
Locale::Maketext is an abstract base class, from which you
derive a \*(L"project class\*(R".
The project class (with a name like \*(L"TkBocciBall::Localize\*(R",
which you then use in your module) is in turn the base class
for all the \*(L"language classes\*(R" for your project
(with names \*(L"TkBocciBall::Localize::it\*(R", 
\&\*(L"TkBocciBall::Localize::en\*(R",
\&\*(L"TkBocciBall::Localize::fr\*(R", etc.).
.PP
A language class is
a class containing a lexicon of phrases as class data,
and possibly also some methods that are of use in interpreting
phrases in the lexicon, or otherwise dealing with text in that
language.
.PP
An object belonging to a language class is called a \*(L"language
handle\*(R"; it's typically a flyweight object.
.PP
The normal course of action is to call:
.PP
.Vb 6
\&  use TkBocciBall::Localize;  # the localization project class
\&  $lh = TkBocciBall::Localize\->get_handle();
\&   # Depending on the user\*(Aqs locale, etc., this will
\&   # make a language handle from among the classes available,
\&   # and any defaults that you declare.
\&  die "Couldn\*(Aqt make a language handle??" unless $lh;
.Ve
.PP
From then on, you use the \f(CW\*(C`maketext\*(C'\fR function to access
entries in whatever lexicon(s) belong to the language handle
you got.  So, this:
.PP
.Vb 1
\&  print $lh\->maketext("You won!"), "\en";
.Ve
.PP
\&...emits the right text for this language.  If the object
in \f(CW$lh\fR belongs to class \*(L"TkBocciBall::Localize::fr\*(R" and
\&\f(CW%TkBocciBall::Localize::fr::Lexicon\fR contains \f(CW\*(C`("You won!"
=> "Tu as gagne\*'!")\*(C'\fR, then the above
code happily tells the user \*(L"Tu as gagne\*'!\*(R".
.SH "METHODS"
.IX Header "METHODS"
Locale::Maketext offers a variety of methods, which fall
into three categories:
.IP "\(bu" 4
Methods to do with constructing language handles.
.IP "\(bu" 4
\&\f(CW\*(C`maketext\*(C'\fR and other methods to do with accessing \f(CW%Lexicon\fR data
for a given language handle.
.IP "\(bu" 4
Methods that you may find it handy to use, from routines of
yours that you put in \f(CW%Lexicon\fR entries.
.PP
These are covered in the following section.
.SS "Construction Methods"
.IX Subsection "Construction Methods"
These are to do with constructing a language handle:
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass\->get_handle( ...langtags... ) || die \*(L"lg-handle?\*(R";
.Sp
This tries loading classes based on the language-tags you give (like
\&\f(CW\*(C`("en\-US", "sk", "kon", "es\-MX", "ja", "i\-klingon")\*(C'\fR, and for the first class
that succeeds, returns YourProjClass::\fIlanguage\fR\->\fInew()\fR.
.Sp
If it runs thru the entire given list of language-tags, and finds no classes
for those exact terms, it then tries \*(L"superordinate\*(R" language classes.
So if no \*(L"en-US\*(R" class (i.e., YourProjClass::en_us)
was found, nor classes for anything else in that list, we then try
its superordinate, \*(L"en\*(R" (i.e., YourProjClass::en), and so on thru 
the other language-tags in the given list: \*(L"es\*(R".
(The other language-tags in our example list: 
happen to have no superordinates.)
.Sp
If none of those language-tags leads to loadable classes, we then
try classes derived from YourProjClass\->\fIfallback_languages()\fR and
then if nothing comes of that, we use classes named by
YourProjClass\->\fIfallback_language_classes()\fR.  Then in the (probably
quite unlikely) event that that fails, we just return undef.
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass\->get_handle\fB()\fR || die \*(L"lg-handle?\*(R";
.Sp
When \f(CW\*(C`get_handle\*(C'\fR is called with an empty parameter list, magic happens:
.Sp
If \f(CW\*(C`get_handle\*(C'\fR senses that it's running in program that was
invoked as a \s-1CGI,\s0 then it tries to get language-tags out of the
environment variable \*(L"\s-1HTTP_ACCEPT_LANGUAGE\*(R",\s0 and it pretends that
those were the languages passed as parameters to \f(CW\*(C`get_handle\*(C'\fR.
.Sp
Otherwise (i.e., if not a \s-1CGI\s0), this tries various OS-specific ways
to get the language-tags for the current locale/language, and then
pretends that those were the value(s) passed to \f(CW\*(C`get_handle\*(C'\fR.
.Sp
Currently this OS-specific stuff consists of looking in the environment
variables \*(L"\s-1LANG\*(R"\s0 and \*(L"\s-1LANGUAGE\*(R"\s0; and on MSWin machines (where those
variables are typically unused), this also tries using
the module Win32::Locale to get a language-tag for whatever language/locale
is currently selected in the \*(L"Regional Settings\*(R" (or \*(L"International\*(R"?)
Control Panel.  I welcome further
suggestions for making this do the Right Thing under other operating
systems that support localization.
.Sp
If you're using localization in an application that keeps a configuration
file, you might consider something like this in your project class:
.Sp
.Vb 10
\&  sub get_handle_via_config {
\&    my $class = $_[0];
\&    my $chosen_language = $Config_settings{\*(Aqlanguage\*(Aq};
\&    my $lh;
\&    if($chosen_language) {
\&      $lh = $class\->get_handle($chosen_language)
\&       || die "No language handle for \e"$chosen_language\e""
\&            . " or the like";
\&    } else {
\&      # Config file missing, maybe?
\&      $lh = $class\->get_handle()
\&       || die "Can\*(Aqt get a language handle";
\&    }
\&    return $lh;
\&  }
.Ve
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass::langname\->\fInew()\fR;
.Sp
This constructs a language handle.  You usually \fBdon't\fR call this
directly, but instead let \f(CW\*(C`get_handle\*(C'\fR find a language class to \f(CW\*(C`use\*(C'\fR
and to then call \->new on.
.IP "\(bu" 4
\&\f(CW$lh\fR\->\fIinit()\fR;
.Sp
This is called by \->new to initialize newly-constructed language handles.
If you define an init method in your class, remember that it's usually
considered a good idea to call \f(CW$lh\fR\->SUPER::init in it (presumably at the
beginning), so that all classes get a chance to initialize a new object
however they see fit.
.IP "\(bu" 4
YourProjClass\->\fIfallback_languages()\fR
.Sp
\&\f(CW\*(C`get_handle\*(C'\fR appends the return value of this to the end of
whatever list of languages you pass \f(CW\*(C`get_handle\*(C'\fR.  Unless
you override this method, your project class
will inherit Locale::Maketext's \f(CW\*(C`fallback_languages\*(C'\fR, which
currently returns \f(CW\*(C`(\*(Aqi\-default\*(Aq, \*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)\*(C'\fR.
(\*(L"i\-default\*(R" is defined in \s-1RFC 2277\s0).
.Sp
This method (by having it return the name
of a language-tag that has an existing language class)
can be used for making sure that
\&\f(CW\*(C`get_handle\*(C'\fR will always manage to construct a language
handle (assuming your language classes are in an appropriate
\&\f(CW@INC\fR directory).  Or you can use the next method:
.IP "\(bu" 4
YourProjClass\->\fIfallback_language_classes()\fR
.Sp
\&\f(CW\*(C`get_handle\*(C'\fR appends the return value of this to the end
of the list of classes it will try using.  Unless
you override this method, your project class
will inherit Locale::Maketext's \f(CW\*(C`fallback_language_classes\*(C'\fR,
which currently returns an empty list, \f(CW\*(C`()\*(C'\fR.
By setting this to some value (namely, the name of a loadable
language class), you can be sure that
\&\f(CW\*(C`get_handle\*(C'\fR will always manage to construct a language
handle.
.ie n .SS "The ""maketext"" Method"
.el .SS "The ``maketext'' Method"
.IX Subsection "The maketext Method"
This is the most important method in Locale::Maketext:
.PP
.Vb 1
\&    $text = $lh\->maketext(I<key>, ...parameters for this phrase...);
.Ve
.PP
This looks in the \f(CW%Lexicon\fR of the language handle
\&\f(CW$lh\fR and all its superclasses, looking
for an entry whose key is the string \fIkey\fR.  Assuming such
an entry is found, various things then happen, depending on the
value found:
.PP
If the value is a scalarref, the scalar is dereferenced and returned
(and any parameters are ignored).
.PP
If the value is a coderef, we return &$value($lh, ...parameters...).
.PP
If the value is a string that \fIdoesn't\fR look like it's in Bracket Notation,
we return it (after replacing it with a scalarref, in its \f(CW%Lexicon\fR).
.PP
If the value \fIdoes\fR look like it's in Bracket Notation, then we compile
it into a sub, replace the string in the \f(CW%Lexicon\fR with the new coderef,
and then we return &$new_sub($lh, ...parameters...).
.PP
Bracket Notation is discussed in a later section.  Note
that trying to compile a string into Bracket Notation can throw
an exception if the string is not syntactically valid (say, by not
balancing brackets right.)
.PP
Also, calling &$coderef($lh, ...parameters...) can throw any sort of
exception (if, say, code in that sub tries to divide by zero).  But
a very common exception occurs when you have Bracket
Notation text that says to call a method \*(L"foo\*(R", but there is no such
method.  (E.g., "You have [qua\fBtn\fR,_1,ball]." will throw an exception
on trying to call \f(CW$lh\fR\->qua\fBtn\fR($_[1],'ball') \*(-- you presumably meant
\&\*(L"quant\*(R".)  \f(CW\*(C`maketext\*(C'\fR catches these exceptions, but only to make the
error message more readable, at which point it rethrows the exception.
.PP
An exception \fImay\fR be thrown if \fIkey\fR is not found in any
of \f(CW$lh\fR's \f(CW%Lexicon\fR hashes.  What happens if a key is not found,
is discussed in a later section, \*(L"Controlling Lookup Failure\*(R".
.PP
Note that you might find it useful in some cases to override
the \f(CW\*(C`maketext\*(C'\fR method with an \*(L"after method\*(R", if you want to
translate encodings, or even scripts:
.PP
.Vb 7
\&    package YrProj::zh_cn; # Chinese with PRC\-style glyphs
\&    use base (\*(AqYrProj::zh_tw\*(Aq);  # Taiwan\-style
\&    sub maketext {
\&      my $self = shift(@_);
\&      my $value = $self\->maketext(@_);
\&      return Chineeze::taiwan2mainland($value);
\&    }
.Ve
.PP
Or you may want to override it with something that traps
any exceptions, if that's critical to your program:
.PP
.Vb 7
\&  sub maketext {
\&    my($lh, @stuff) = @_;
\&    my $out;
\&    eval { $out = $lh\->SUPER::maketext(@stuff) };
\&    return $out unless $@;
\&    ...otherwise deal with the exception...
\&  }
.Ve
.PP
Other than those two situations, I don't imagine that
it's useful to override the \f(CW\*(C`maketext\*(C'\fR method.  (If
you run into a situation where it is useful, I'd be
interested in hearing about it.)
.ie n .IP "$lh\->fail_with \fIor\fR $lh\->fail_with(\fI\s-1PARAM\s0\fR)" 4
.el .IP "\f(CW$lh\fR\->fail_with \fIor\fR \f(CW$lh\fR\->fail_with(\fI\s-1PARAM\s0\fR)" 4
.IX Item "$lh->fail_with or $lh->fail_with(PARAM)"
.PD 0
.ie n .IP "$lh\->failure_handler_auto" 4
.el .IP "\f(CW$lh\fR\->failure_handler_auto" 4
.IX Item "$lh->failure_handler_auto"
.PD
These two methods are discussed in the section \*(L"Controlling
Lookup Failure\*(R".
.SS "Utility Methods"
.IX Subsection "Utility Methods"
These are methods that you may find it handy to use, generally
from \f(CW%Lexicon\fR routines of yours (whether expressed as
Bracket Notation or not).
.ie n .IP "$language\->quant($number, $singular)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR)" 4
.IX Item "$language->quant($number, $singular)"
.PD 0
.ie n .IP "$language\->quant($number, $singular, $plural)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR, \f(CW$plural\fR)" 4
.IX Item "$language->quant($number, $singular, $plural)"
.ie n .IP "$language\->quant($number, $singular, $plural, $negative)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR, \f(CW$plural\fR, \f(CW$negative\fR)" 4
.IX Item "$language->quant($number, $singular, $plural, $negative)"
.PD
This is generally meant to be called from inside Bracket Notation
(which is discussed later), as in
.Sp
.Vb 1
\&     "Your search matched [quant,_1,document]!"
.Ve
.Sp
It's for \fIquantifying\fR a noun (i.e., saying how much of it there is,
while giving the correct form of it).  The behavior of this method is
handy for English and a few other Western European languages, and you
should override it for languages where it's not suitable.  You can feel
free to read the source, but the current implementation is basically
as this pseudocode describes:
.Sp
.Vb 11
\&     if $number is 0 and there\*(Aqs a $negative,
\&        return $negative;
\&     elsif $number is 1,
\&        return "1 $singular";
\&     elsif there\*(Aqs a $plural,
\&        return "$number $plural";
\&     else
\&        return "$number " . $singular . "s";
\&     #
\&     # ...except that we actually call numf to
\&     #  stringify $number before returning it.
.Ve
.Sp
So for English (with Bracket Notation)
\&\f(CW"...[quant,_1,file]..."\fR is fine (for 0 it returns \*(L"0 files\*(R",
for 1 it returns \*(L"1 file\*(R", and for more it returns \*(L"2 files\*(R", etc.)
.Sp
But for \*(L"directory\*(R", you'd want \f(CW"[quant,_1,directory,directories]"\fR
so that our elementary \f(CW\*(C`quant\*(C'\fR method doesn't think that the
plural of \*(L"directory\*(R" is \*(L"directorys\*(R".  And you might find that the
output may sound better if you specify a negative form, as in:
.Sp
.Vb 1
\&     "[quant,_1,file,files,No files] matched your query.\en"
.Ve
.Sp
Remember to keep in mind verb agreement (or adjectives too, in
other languages), as in:
.Sp
.Vb 1
\&     "[quant,_1,document] were matched.\en"
.Ve
.Sp
Because if _1 is one, you get "1 document \fBwere\fR matched".
An acceptable hack here is to do something like this:
.Sp
.Vb 1
\&     "[quant,_1,document was, documents were] matched.\en"
.Ve
.ie n .IP "$language\->numf($number)" 4
.el .IP "\f(CW$language\fR\->numf($number)" 4
.IX Item "$language->numf($number)"
This returns the given number formatted nicely according to
this language's conventions.  Maketext's default method is
mostly to just take the normal string form of the number
(applying sprintf \*(L"%G\*(R" for only very large numbers), and then
to add commas as necessary.  (Except that
we apply \f(CW\*(C`tr/,./.,/\*(C'\fR if \f(CW$language\fR\->{'numf_comma'} is true;
that's a bit of a hack that's useful for languages that express
two million as \*(L"2.000.000\*(R" and not as \*(L"2,000,000\*(R").
.Sp
If you want anything fancier, consider overriding this with something
that uses Number::Format, or does something else
entirely.
.Sp
Note that numf is called by quant for stringifying all quantifying
numbers.
.ie n .IP "$language\->numerate($number, $singular, $plural, $negative)" 4
.el .IP "\f(CW$language\fR\->numerate($number, \f(CW$singular\fR, \f(CW$plural\fR, \f(CW$negative\fR)" 4
.IX Item "$language->numerate($number, $singular, $plural, $negative)"
This returns the given noun form which is appropriate for the quantity
\&\f(CW$number\fR according to this language's conventions.  \f(CW\*(C`numerate\*(C'\fR is
used internally by \f(CW\*(C`quant\*(C'\fR to quantify nouns.  Use it directly \*(--
usually from bracket notation \*(-- to avoid \f(CW\*(C`quant\*(C'\fR's implicit call to
\&\f(CW\*(C`numf\*(C'\fR and output of a numeric quantity.
.ie n .IP "$language\->sprintf($format, @items)" 4
.el .IP "\f(CW$language\fR\->sprintf($format, \f(CW@items\fR)" 4
.IX Item "$language->sprintf($format, @items)"
This is just a wrapper around Perl's normal \f(CW\*(C`sprintf\*(C'\fR function.
It's provided so that you can use \*(L"sprintf\*(R" in Bracket Notation:
.Sp
.Vb 1
\&     "Couldn\*(Aqt access datanode [sprintf,%10x=~[%s~],_1,_2]!\en"
.Ve
.Sp
returning...
.Sp
.Vb 1
\&     Couldn\*(Aqt access datanode      Stuff=[thangamabob]!
.Ve
.ie n .IP "$language\->\fIlanguage_tag()\fR" 4
.el .IP "\f(CW$language\fR\->\fIlanguage_tag()\fR" 4
.IX Item "$language->language_tag()"
Currently this just takes the last bit of \f(CW\*(C`ref($language)\*(C'\fR, turns
underscores to dashes, and returns it.  So if \f(CW$language\fR is
an object of class Hee::HOO::Haw::en_us, \f(CW$language\fR\->\fIlanguage_tag()\fR
returns \*(L"en-us\*(R".  (Yes, the usual representation for that language
tag is \*(L"en-US\*(R", but case is \fInever\fR considered meaningful in
language-tag comparison.)
.Sp
You may override this as you like; Maketext doesn't use it for
anything.
.ie n .IP "$language\->\fIencoding()\fR" 4
.el .IP "\f(CW$language\fR\->\fIencoding()\fR" 4
.IX Item "$language->encoding()"
Currently this isn't used for anything, but it's provided
(with default value of
\&\f(CW\*(C`(ref($language) && $language\->{\*(Aqencoding\*(Aq})) or "iso\-8859\-1"\*(C'\fR
) as a sort of suggestion that it may be useful/necessary to
associate encodings with your language handles (whether on a
per-class or even per-handle basis.)
.SS "Language Handle Attributes and Internals"
.IX Subsection "Language Handle Attributes and Internals"
A language handle is a flyweight object \*(-- i.e., it doesn't (necessarily)
carry any data of interest, other than just being a member of
whatever class it belongs to.
.PP
A language handle is implemented as a blessed hash.  Subclasses of yours
can store whatever data you want in the hash.  Currently the only hash
entry used by any crucial Maketext method is \*(L"fail\*(R", so feel free to
use anything else as you like.
.PP
\&\fBRemember: Don't be afraid to read the Maketext source if there's
any point on which this documentation is unclear.\fR  This documentation
is vastly longer than the module source itself.
.SH "LANGUAGE CLASS HIERARCHIES"
.IX Header "LANGUAGE CLASS HIERARCHIES"
These are Locale::Maketext's assumptions about the class
hierarchy formed by all your language classes:
.IP "\(bu" 4
You must have a project base class, which you load, and
which you then use as the first argument in
the call to YourProjClass\->get_handle(...).  It should derive
(whether directly or indirectly) from Locale::Maketext.
It \fBdoesn't matter\fR how you name this class, although assuming this
is the localization component of your Super Mega Program,
good names for your project class might be
SuperMegaProgram::Localization, SuperMegaProgram::L10N,
SuperMegaProgram::I18N, SuperMegaProgram::International,
or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.
.IP "\(bu" 4
Language classes are what YourProjClass\->get_handle will try to load.
It will look for them by taking each language-tag (\fBskipping\fR it
if it doesn't look like a language-tag or locale-tag!), turning it to
all lowercase, turning dashes to underscores, and appending it
to YourProjClass . \*(L"::\*(R".  So this:
.Sp
.Vb 3
\&  $lh = YourProjClass\->get_handle(
\&    \*(Aqen\-US\*(Aq, \*(Aqfr\*(Aq, \*(Aqkon\*(Aq, \*(Aqi\-klingon\*(Aq, \*(Aqi\-klingon\-romanized\*(Aq
\&  );
.Ve
.Sp
will try loading the classes 
YourProjClass::en_us (note lowercase!), YourProjClass::fr, 
YourProjClass::kon,
YourProjClass::i_klingon
and YourProjClass::i_klingon_romanized.  (And it'll stop at the
first one that actually loads.)
.IP "\(bu" 4
I assume that each language class derives (directly or indirectly)
from your project class, and also defines its \f(CW@ISA\fR, its \f(CW%Lexicon\fR,
or both.  But I anticipate no dire consequences if these assumptions
do not hold.
.IP "\(bu" 4
Language classes may derive from other language classes (although they
should have "use \fIThatclassname\fR\*(L" or \*(R"use base qw(\fI...classes...\fR)").
They may derive from the project
class.  They may derive from some other class altogether.  Or via
multiple inheritance, it may derive from any mixture of these.
.IP "\(bu" 4
I foresee no problems with having multiple inheritance in
your hierarchy of language classes.  (As usual, however, Perl will
complain bitterly if you have a cycle in the hierarchy: i.e., if
any class is its own ancestor.)
.SH "ENTRIES IN EACH LEXICON"
.IX Header "ENTRIES IN EACH LEXICON"
A typical \f(CW%Lexicon\fR entry is meant to signify a phrase,
taking some number (0 or more) of parameters.  An entry
is meant to be accessed by via
a string \fIkey\fR in \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...),
which should return a string that is generally meant for
be used for \*(L"output\*(R" to the user \*(-- regardless of whether
this actually means printing to \s-1STDOUT,\s0 writing to a file,
or putting into a \s-1GUI\s0 widget.
.PP
While the key must be a string value (since that's a basic
restriction that Perl places on hash keys), the value in
the lexicon can currently be of several types:
a defined scalar, scalarref, or coderef.  The use of these is
explained above, in the section 'The \*(L"maketext\*(R" Method', and
Bracket Notation for strings is discussed in the next section.
.PP
While you can use arbitrary unique IDs for lexicon keys
(like \*(L"_min_larger_max_error\*(R"), it is often
useful for if an entry's key is itself a valid value, like
this example error message:
.PP
.Vb 1
\&  "Minimum ([_1]) is larger than maximum ([_2])!\en",
.Ve
.PP
Compare this code that uses an arbitrary \s-1ID...\s0
.PP
.Vb 2
\&  die $lh\->maketext( "_min_larger_max_error", $min, $max )
\&   if $min > $max;
.Ve
.PP
\&...to this code that uses a key-as-value:
.PP
.Vb 4
\&  die $lh\->maketext(
\&   "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&   $min, $max
\&  ) if $min > $max;
.Ve
.PP
The second is, in short, more readable.  In particular, it's obvious
that the number of parameters you're feeding to that phrase (two) is
the number of parameters that it \fIwants\fR to be fed.  (Since you see
_1 and a _2 being used in the key there.)
.PP
Also, once a project is otherwise
complete and you start to localize it, you can scrape together
all the various keys you use, and pass it to a translator; and then
the translator's work will go faster if what he's presented is this:
.PP
.Vb 2
\& "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&  => "",   # fill in something here, Jacques!
.Ve
.PP
rather than this more cryptic mess:
.PP
.Vb 2
\& "_min_larger_max_error"
\&  => "",   # fill in something here, Jacques
.Ve
.PP
I think that keys as lexicon values makes the completed lexicon
entries more readable:
.PP
.Vb 2
\& "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&  => "Le minimum ([_1]) est plus grand que le maximum ([_2])!\en",
.Ve
.PP
Also, having valid values as keys becomes very useful if you set
up an _AUTO lexicon.  _AUTO lexicons are discussed in a later
section.
.PP
I almost always use keys that are themselves
valid lexicon values.  One notable exception is when the value is
quite long.  For example, to get the screenful of data that
a command-line program might return when given an unknown switch,
I often just use a brief, self-explanatory key such as \*(L"_USAGE_MESSAGE\*(R".  At that point I then go
and immediately to define that lexicon entry in the
ProjectClass::L10N::en lexicon (since English is always my \*(L"project
language\*(R"):
.PP
.Vb 3
\&  \*(Aq_USAGE_MESSAGE\*(Aq => <<\*(AqEOSTUFF\*(Aq,
\&  ...long long message...
\&  EOSTUFF
.Ve
.PP
and then I can use it as:
.PP
.Vb 1
\&  getopt(\*(AqoDI\*(Aq, \e%opts) or die $lh\->maketext(\*(Aq_USAGE_MESSAGE\*(Aq);
.Ve
.PP
Incidentally,
note that each class's \f(CW%Lexicon\fR inherits-and-extends
the lexicons in its superclasses.  This is not because these are
special hashes \fIper se\fR, but because you access them via the
\&\f(CW\*(C`maketext\*(C'\fR method, which looks for entries across all the
\&\f(CW%Lexicon\fR hashes in a language class \fIand\fR all its ancestor classes.
(This is because the idea of \*(L"class data\*(R" isn't directly implemented
in Perl, but is instead left to individual class-systems to implement
as they see fit..)
.PP
Note that you may have things stored in a lexicon
besides just phrases for output:  for example, if your program
takes input from the keyboard, asking a \*(L"(Y/N)\*(R" question,
you probably need to know what the equivalent of \*(L"Y[es]/N[o]\*(R" is
in whatever language.  You probably also need to know what
the equivalents of the answers \*(L"y\*(R" and \*(L"n\*(R" are.  You can
store that information in the lexicon (say, under the keys
\&\*(L"~answer_y\*(R" and \*(L"~answer_n\*(R", and the long forms as
\&\*(L"~answer_yes\*(R" and \*(L"~answer_no\*(R", where \*(L"~\*(R" is just an ad-hoc
character meant to indicate to programmers/translators that
these are not phrases for output).
.PP
Or instead of storing this in the language class's lexicon,
you can (and, in some cases, really should) represent the same bit
of knowledge as code in a method in the language class.  (That
leaves a tidy distinction between the lexicon as the things we
know how to \fIsay\fR, and the rest of the things in the lexicon class
as things that we know how to \fIdo\fR.)  Consider
this example of a processor for responses to French \*(L"oui/non\*(R"
questions:
.PP
.Vb 7
\&  sub y_or_n {
\&    return undef unless defined $_[1] and length $_[1];
\&    my $answer = lc $_[1];  # smash case
\&    return 1 if $answer eq \*(Aqo\*(Aq or $answer eq \*(Aqoui\*(Aq;
\&    return 0 if $answer eq \*(Aqn\*(Aq or $answer eq \*(Aqnon\*(Aq;
\&    return undef;
\&  }
.Ve
.PP
\&...which you'd then call in a construct like this:
.PP
.Vb 7
\&  my $response;
\&  until(defined $response) {
\&    print $lh\->maketext("Open the pod bay door (y/n)? ");
\&    $response = $lh\->y_or_n( get_input_from_keyboard_somehow() );
\&  }
\&  if($response) { $pod_bay_door\->open()         }
\&  else          { $pod_bay_door\->leave_closed() }
.Ve
.PP
Other data worth storing in a lexicon might be things like
filenames for language-targetted resources:
.PP
.Vb 10
\&  ...
\&  "_main_splash_png"
\&    => "/styles/en_us/main_splash.png",
\&  "_main_splash_imagemap"
\&    => "/styles/en_us/main_splash.incl",
\&  "_general_graphics_path"
\&    => "/styles/en_us/",
\&  "_alert_sound"
\&    => "/styles/en_us/hey_there.wav",
\&  "_forward_icon"
\&   => "left_arrow.png",
\&  "_backward_icon"
\&   => "right_arrow.png",
\&  # In some other languages, left equals
\&  #  BACKwards, and right is FOREwards.
\&  ...
.Ve
.PP
You might want to do the same thing for expressing key bindings
or the like (since hardwiring \*(L"q\*(R" as the binding for the function
that quits a screen/menu/program is useful only if your language
happens to associate \*(L"q\*(R" with \*(L"quit\*(R"!)
.SH "BRACKET NOTATION"
.IX Header "BRACKET NOTATION"
Bracket Notation is a crucial feature of Locale::Maketext.  I mean
Bracket Notation to provide a replacement for the use of sprintf formatting.
Everything you do with Bracket Notation could be done with a sub block,
but bracket notation is meant to be much more concise.
.PP
Bracket Notation is a like a miniature \*(L"template\*(R" system (in the sense
of Text::Template, not in the sense of \*(C+ templates),
where normal text is passed thru basically as is, but text in special
regions is specially interpreted.  In Bracket Notation, you use square brackets (\*(L"[...]\*(R"),
not curly braces (\*(L"{...}\*(R") to note sections that are specially interpreted.
.PP
For example, here all the areas that are taken literally are underlined with
a \*(L"^\*(R", and all the in-bracket special regions are underlined with an X:
.PP
.Vb 2
\&  "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&   ^^^^^^^^^ XX ^^^^^^^^^^^^^^^^^^^^^^^^^^ XX ^^^^
.Ve
.PP
When that string is compiled from bracket notation into a real Perl sub,
it's basically turned into:
.PP
.Vb 11
\&  sub {
\&    my $lh = $_[0];
\&    my @params = @_;
\&    return join \*(Aq\*(Aq,
\&      "Minimum (",
\&      ...some code here...
\&      ") is larger than maximum (",
\&      ...some code here...
\&      ")!\en",
\&  }
\&  # to be called by $lh\->maketext(KEY, params...)
.Ve
.PP
In other words, text outside bracket groups is turned into string
literals.  Text in brackets is rather more complex, and currently follows
these rules:
.IP "\(bu" 4
Bracket groups that are empty, or which consist only of whitespace,
are ignored.  (Examples: \*(L"[]\*(R", \*(L"[    ]\*(R", or a [ and a ] with returns
and/or tabs and/or spaces between them.
.Sp
Otherwise, each group is taken to be a comma-separated group of items,
and each item is interpreted as follows:
.IP "\(bu" 4
An item that is "_\fIdigits\fR\*(L" or \*(R"_\-\fIdigits\fR" is interpreted as
\&\f(CW$_\fR[\fIvalue\fR].  I.e., \*(L"_1\*(R" becomes with \f(CW$_\fR[1], and \*(L"_\-3\*(R" is interpreted
as \f(CW$_\fR[\-3] (in which case \f(CW@_\fR should have at least three elements in it).
Note that \f(CW$_\fR[0] is the language handle, and is typically not named
directly.
.IP "\(bu" 4
An item \*(L"_*\*(R" is interpreted to mean \*(L"all of \f(CW@_\fR except \f(CW$_\fR[0]\*(R".
I.e., \f(CW@_[1..$#_]\fR.  Note that this is an empty list in the case
of calls like \f(CW$lh\fR\->maketext(\fIkey\fR) where there are no
parameters (except \f(CW$_\fR[0], the language handle).
.IP "\(bu" 4
Otherwise, each item is interpreted as a string literal.
.PP
The group as a whole is interpreted as follows:
.IP "\(bu" 4
If the first item in a bracket group looks like a method name,
then that group is interpreted like this:
.Sp
.Vb 3
\&  $lh\->that_method_name(
\&    ...rest of items in this group...
\&  ),
.Ve
.IP "\(bu" 4
If the first item in a bracket group is \*(L"*\*(R", it's taken as shorthand
for the so commonly called \*(L"quant\*(R" method.  Similarly, if the first
item in a bracket group is \*(L"#\*(R", it's taken to be shorthand for
\&\*(L"numf\*(R".
.IP "\(bu" 4
If the first item in a bracket group is the empty-string, or \*(L"_*\*(R"
or "_\fIdigits\fR\*(L" or \*(R"_\-\fIdigits\fR", then that group is interpreted
as just the interpolation of all its items:
.Sp
.Vb 3
\&  join(\*(Aq\*(Aq,
\&    ...rest of items in this group...
\&  ),
.Ve
.Sp
Examples:  \*(L"[_1]\*(R" and \*(L"[,_1]\*(R", which are synonymous; and
"\f(CW\*(C`[,ID\-(,_4,\-,_2,)]\*(C'\fR", which compiles as
\&\f(CW\*(C`join "", "ID\-(", $_[4], "\-", $_[2], ")"\*(C'\fR.
.IP "\(bu" 4
Otherwise this bracket group is invalid.  For example, in the group
\&\*(L"[!@#,whatever]\*(R", the first item \f(CW"!@#"\fR is neither the empty-string,
"_\fInumber\fR\*(L", \*(R"_\-\fInumber\fR\*(L", \*(R"_*", nor a valid method name; and so
Locale::Maketext will throw an exception of you try compiling an
expression containing this bracket group.
.PP
Note, incidentally, that items in each group are comma-separated,
not \f(CW\*(C`/\es*,\es*/\*(C'\fR\-separated.  That is, you might expect that this
bracket group:
.PP
.Vb 1
\&  "Hoohah [foo, _1 , bar ,baz]!"
.Ve
.PP
would compile to this:
.PP
.Vb 7
\&  sub {
\&    my $lh = $_[0];
\&    return join \*(Aq\*(Aq,
\&      "Hoohah ",
\&      $lh\->foo( $_[1], "bar", "baz"),
\&      "!",
\&  }
.Ve
.PP
But it actually compiles as this:
.PP
.Vb 7
\&  sub {
\&    my $lh = $_[0];
\&    return join \*(Aq\*(Aq,
\&      "Hoohah ",
\&      $lh\->foo(" _1 ", " bar ", "baz"),  # note the <space> in " bar "
\&      "!",
\&  }
.Ve
.PP
In the notation discussed so far, the characters \*(L"[\*(R" and \*(L"]\*(R" are given
special meaning, for opening and closing bracket groups, and \*(L",\*(R" has
a special meaning inside bracket groups, where it separates items in the
group.  This begs the question of how you'd express a literal \*(L"[\*(R" or
\&\*(L"]\*(R" in a Bracket Notation string, and how you'd express a literal
comma inside a bracket group.  For this purpose I've adopted \*(L"~\*(R" (tilde)
as an escape character:  \*(L"~[\*(R" means a literal '[' character anywhere
in Bracket Notation (i.e., regardless of whether you're in a bracket
group or not), and ditto for \*(L"~]\*(R" meaning a literal ']', and \*(L"~,\*(R" meaning
a literal comma.  (Altho \*(L",\*(R" means a literal comma outside of
bracket groups \*(-- it's only inside bracket groups that commas are special.)
.PP
And on the off chance you need a literal tilde in a bracket expression,
you get it with \*(L"~~\*(R".
.PP
Currently, an unescaped \*(L"~\*(R" before a character
other than a bracket or a comma is taken to mean just a \*(L"~\*(R" and that
character.  I.e., \*(L"~X\*(R" means the same as \*(L"~~X\*(R" \*(-- i.e., one literal tilde,
and then one literal \*(L"X\*(R".  However, by using \*(L"~X\*(R", you are assuming that
no future version of Maketext will use \*(L"~X\*(R" as a magic escape sequence.
In practice this is not a great problem, since first off you can just
write \*(L"~~X\*(R" and not worry about it; second off, I doubt I'll add lots
of new magic characters to bracket notation; and third off, you
aren't likely to want literal \*(L"~\*(R" characters in your messages anyway,
since it's not a character with wide use in natural language text.
.PP
Brackets must be balanced \*(-- every openbracket must have
one matching closebracket, and vice versa.  So these are all \fBinvalid\fR:
.PP
.Vb 4
\&  "I ate [quant,_1,rhubarb pie."
\&  "I ate [quant,_1,rhubarb pie[."
\&  "I ate quant,_1,rhubarb pie]."
\&  "I ate quant,_1,rhubarb pie[."
.Ve
.PP
Currently, bracket groups do not nest.  That is, you \fBcannot\fR say:
.PP
.Vb 1
\&  "Foo [bar,baz,[quux,quuux]]\en";
.Ve
.PP
If you need a notation that's that powerful, use normal Perl:
.PP
.Vb 11
\&  %Lexicon = (
\&    ...
\&    "some_key" => sub {
\&      my $lh = $_[0];
\&      join \*(Aq\*(Aq,
\&        "Foo ",
\&        $lh\->bar(\*(Aqbaz\*(Aq, $lh\->quux(\*(Aqquuux\*(Aq)),
\&        "\en",
\&    },
\&    ...
\&  );
.Ve
.PP
Or write the \*(L"bar\*(R" method so you don't need to pass it the
output from calling quux.
.PP
I do not anticipate that you will need (or particularly want)
to nest bracket groups, but you are welcome to email me with
convincing (real-life) arguments to the contrary.
.SH "AUTO LEXICONS"
.IX Header "AUTO LEXICONS"
If maketext goes to look in an individual \f(CW%Lexicon\fR for an entry
for \fIkey\fR (where \fIkey\fR does not start with an underscore), and
sees none, \fBbut does see\fR an entry of \*(L"_AUTO\*(R" => \fIsome_true_value\fR,
then we actually define \f(CW$Lexicon\fR{\fIkey\fR} = \fIkey\fR right then and there,
and then use that value as if it had been there all
along.  This happens before we even look in any superclass \f(CW%Lexicons\fR!
.PP
(This is meant to be somewhat like the \s-1AUTOLOAD\s0 mechanism in
Perl's function call system \*(-- or, looked at another way,
like the AutoLoader module.)
.PP
I can picture all sorts of circumstances where you just
do not want lookup to be able to fail (since failing
normally means that maketext throws a \f(CW\*(C`die\*(C'\fR, although
see the next section for greater control over that).  But
here's one circumstance where _AUTO lexicons are meant to
be \fIespecially\fR useful:
.PP
As you're writing an application, you decide as you go what messages
you need to emit.  Normally you'd go to write this:
.PP
.Vb 5
\&  if(\-e $filename) {
\&    go_process_file($filename)
\&  } else {
\&    print qq{Couldn\*(Aqt find file "$filename"!\en};
\&  }
.Ve
.PP
but since you anticipate localizing this, you write:
.PP
.Vb 10
\&  use ThisProject::I18N;
\&  my $lh = ThisProject::I18N\->get_handle();
\&   # For the moment, assume that things are set up so
\&   # that we load class ThisProject::I18N::en
\&   # and that that\*(Aqs the class that $lh belongs to.
\&  ...
\&  if(\-e $filename) {
\&    go_process_file($filename)
\&  } else {
\&    print $lh\->maketext(
\&      qq{Couldn\*(Aqt find file "[_1]"!\en}, $filename
\&    );
\&  }
.Ve
.PP
Now, right after you've just written the above lines, you'd
normally have to go open the file 
ThisProject/I18N/en.pm, and immediately add an entry:
.PP
.Vb 2
\&  "Couldn\*(Aqt find file \e"[_1]\e"!\en"
\&  => "Couldn\*(Aqt find file \e"[_1]\e"!\en",
.Ve
.PP
But I consider that somewhat of a distraction from the work
of getting the main code working \*(-- to say nothing of the fact
that I often have to play with the program a few times before
I can decide exactly what wording I want in the messages (which
in this case would require me to go changing three lines of code:
the call to maketext with that key, and then the two lines in
ThisProject/I18N/en.pm).
.PP
However, if you set \*(L"_AUTO => 1\*(R" in the \f(CW%Lexicon\fR in,
ThisProject/I18N/en.pm (assuming that English (en) is
the language that all your programmers will be using for this
project's internal message keys), then you don't ever have to
go adding lines like this
.PP
.Vb 2
\&  "Couldn\*(Aqt find file \e"[_1]\e"!\en"
\&  => "Couldn\*(Aqt find file \e"[_1]\e"!\en",
.Ve
.PP
to ThisProject/I18N/en.pm, because if _AUTO is true there,
then just looking for an entry with the key \*(L"Couldn't find
file \e\*(R"[_1]\e\*(L"!\en\*(R" in that lexicon will cause it to be added,
with that value!
.PP
Note that the reason that keys that start with \*(L"_\*(R"
are immune to _AUTO isn't anything generally magical about
the underscore character \*(-- I just wanted a way to have most
lexicon keys be autoable, except for possibly a few, and I
arbitrarily decided to use a leading underscore as a signal
to distinguish those few.
.SH "READONLY LEXICONS"
.IX Header "READONLY LEXICONS"
If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.
.PP
For example a GDBM_File \s-1GDBM_READER\s0 tied hash will die with something like:
.PP
.Vb 1
\&   gdbm store returned \-1, errno 2, key "..." at ...
.Ve
.PP
All you need to do is turn on caching outside of the lexicon hash itself like so:
.PP
.Vb 6
\&   sub init {
\&       my ($lh) = @_;
\&       ...
\&       $lh\->{\*(Aquse_external_lex_cache\*(Aq} = 1;
\&       ...
\&   }
.Ve
.PP
And then instead of storing the compiled value in the lexicon hash it will store it in \f(CW$lh\fR\->{'_external_lex_cache'}
.SH "CONTROLLING LOOKUP FAILURE"
.IX Header "CONTROLLING LOOKUP FAILURE"
If you call \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...),
and there's no entry \fIkey\fR in \f(CW$lh\fR's class's \f(CW%Lexicon\fR, nor
in the superclass \f(CW%Lexicon\fR hash, \fIand\fR if we can't auto-make
\&\fIkey\fR (because either it starts with a \*(L"_\*(R", or because none
of its lexicons have \f(CW\*(C`_AUTO => 1,\*(C'\fR), then we have
failed to find a normal way to maketext \fIkey\fR.  What then
happens in these failure conditions, depends on the \f(CW$lh\fR object's
\&\*(L"fail\*(R" attribute.
.PP
If the language handle has no \*(L"fail\*(R" attribute, maketext
will simply throw an exception (i.e., it calls \f(CW\*(C`die\*(C'\fR, mentioning
the \fIkey\fR whose lookup failed, and naming the line number where
the calling \f(CW$lh\fR\->maketext(\fIkey\fR,...) was.
.PP
If the language handle has a \*(L"fail\*(R" attribute whose value is a
coderef, then \f(CW$lh\fR\->maketext(\fIkey\fR,...params...) gives up and calls:
.PP
.Vb 1
\&  return $that_subref\->($lh, $key, @params);
.Ve
.PP
Otherwise, the \*(L"fail\*(R" attribute's value should be a string denoting
a method name, so that \f(CW$lh\fR\->maketext(\fIkey\fR,...params...) can
give up with:
.PP
.Vb 1
\&  return $lh\->$that_method_name($phrase, @params);
.Ve
.PP
The \*(L"fail\*(R" attribute can be accessed with the \f(CW\*(C`fail_with\*(C'\fR method:
.PP
.Vb 2
\&  # Set to a coderef:
\&  $lh\->fail_with( \e&failure_handler );
\&
\&  # Set to a method name:
\&  $lh\->fail_with( \*(Aqfailure_method\*(Aq );
\&
\&  # Set to nothing (i.e., so failure throws a plain exception)
\&  $lh\->fail_with( undef );
\&
\&  # Get the current value
\&  $handler = $lh\->fail_with();
.Ve
.PP
Now, as to what you may want to do with these handlers:  Maybe you'd
want to log what key failed for what class, and then die.  Maybe
you don't like \f(CW\*(C`die\*(C'\fR and instead you want to send the error message
to \s-1STDOUT \s0(or wherever) and then merely \f(CW\*(C`exit()\*(C'\fR.
.PP
Or maybe you don't want to \f(CW\*(C`die\*(C'\fR at all!  Maybe you could use a
handler like this:
.PP
.Vb 10
\&  # Make all lookups fall back onto an English value,
\&  #  but only after we log it for later fingerpointing.
\&  my $lh_backup = ThisProject\->get_handle(\*(Aqen\*(Aq);
\&  open(LEX_FAIL_LOG, ">>wherever/lex.log") || die "GNAARGH $!";
\&  sub lex_fail {
\&    my($failing_lh, $key, $params) = @_;
\&    print LEX_FAIL_LOG scalar(localtime), "\et",
\&       ref($failing_lh), "\et", $key, "\en";
\&    return $lh_backup\->maketext($key,@params);
\&  }
.Ve
.PP
Some users have expressed that they think this whole mechanism of
having a \*(L"fail\*(R" attribute at all, seems a rather pointless complication.
But I want Locale::Maketext to be usable for software projects of \fIany\fR
scale and type; and different software projects have different ideas
of what the right thing is to do in failure conditions.  I could simply
say that failure always throws an exception, and that if you want to be
careful, you'll just have to wrap every call to \f(CW$lh\fR\->maketext in an
eval\ {\ }.  However, I want programmers to reserve the right (via
the \*(L"fail\*(R" attribute) to treat lookup failure as something other than
an exception of the same level of severity as a config file being
unreadable, or some essential resource being inaccessible.
.PP
One possibly useful value for the \*(L"fail\*(R" attribute is the method name
\&\*(L"failure_handler_auto\*(R".  This is a method defined in the class
Locale::Maketext itself.  You set it with:
.PP
.Vb 1
\&  $lh\->fail_with(\*(Aqfailure_handler_auto\*(Aq);
.Ve
.PP
Then when you call \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...) and
there's no \fIkey\fR in any of those lexicons, maketext gives up with
.PP
.Vb 1
\&  return $lh\->failure_handler_auto($key, @params);
.Ve
.PP
But failure_handler_auto, instead of dying or anything, compiles
\&\f(CW$key\fR, caching it in
.PP
.Vb 1
\&    $lh\->{\*(Aqfailure_lex\*(Aq}{$key} = $complied
.Ve
.PP
and then calls the compiled value, and returns that.  (I.e., if
\&\f(CW$key\fR looks like bracket notation, \f(CW$compiled\fR is a sub, and we return
&{$compiled}(@params); but if \f(CW$key\fR is just a plain string, we just
return that.)
.PP
The effect of using \*(L"failure_auto_handler\*(R"
is like an \s-1AUTO\s0 lexicon, except that it 1) compiles \f(CW$key\fR even if
it starts with \*(L"_\*(R", and 2) you have a record in the new hashref
\&\f(CW$lh\fR\->{'failure_lex'} of all the keys that have failed for
this object.  This should avoid your program dying \*(-- as long
as your keys aren't actually invalid as bracket code, and as
long as they don't try calling methods that don't exist.
.PP
\&\*(L"failure_auto_handler\*(R" may not be exactly what you want, but I
hope it at least shows you that maketext failure can be mitigated
in any number of very flexible ways.  If you can formalize exactly
what you want, you should be able to express that as a failure
handler.  You can even make it default for every object of a given
class, by setting it in that class's init:
.PP
.Vb 9
\&  sub init {
\&    my $lh = $_[0];  # a newborn handle
\&    $lh\->SUPER::init();
\&    $lh\->fail_with(\*(Aqmy_clever_failure_handler\*(Aq);
\&    return;
\&  }
\&  sub my_clever_failure_handler {
\&    ...you clever things here...
\&  }
.Ve
.SH "HOW TO USE MAKETEXT"
.IX Header "HOW TO USE MAKETEXT"
Here is a brief checklist on how to use Maketext to localize
applications:
.IP "\(bu" 4
Decide what system you'll use for lexicon keys.  If you insist,
you can use opaque IDs (if you're nostalgic for \f(CW\*(C`catgets\*(C'\fR),
but I have better suggestions in the
section \*(L"Entries in Each Lexicon\*(R", above.  Assuming you opt for
meaningful keys that double as values (like \*(L"Minimum ([_1]) is
larger than maximum ([_2])!\en\*(R"), you'll have to settle on what
language those should be in.  For the sake of argument, I'll
call this English, specifically American English, \*(L"en-US\*(R".
.IP "\(bu" 4
Create a class for your localization project.  This is
the name of the class that you'll use in the idiom:
.Sp
.Vb 2
\&  use Projname::L10N;
\&  my $lh = Projname::L10N\->get_handle(...) || die "Language?";
.Ve
.Sp
Assuming you call your class Projname::L10N, create a class
consisting minimally of:
.Sp
.Vb 3
\&  package Projname::L10N;
\&  use base qw(Locale::Maketext);
\&  ...any methods you might want all your languages to share...
\&
\&  # And, assuming you want the base class to be an _AUTO lexicon,
\&  # as is discussed a few sections up:
\&
\&  1;
.Ve
.IP "\(bu" 4
Create a class for the language your internal keys are in.  Name
the class after the language-tag for that language, in lowercase,
with dashes changed to underscores.  Assuming your project's first
language is \s-1US\s0 English, you should call this Projname::L10N::en_us.
It should consist minimally of:
.Sp
.Vb 6
\&  package Projname::L10N::en_us;
\&  use base qw(Projname::L10N);
\&  %Lexicon = (
\&    \*(Aq_AUTO\*(Aq => 1,
\&  );
\&  1;
.Ve
.Sp
(For the rest of this section, I'll assume that this \*(L"first
language class\*(R" of Projname::L10N::en_us has
_AUTO lexicon.)
.IP "\(bu" 4
Go and write your program.  Everywhere in your program where 
you would say:
.Sp
.Vb 1
\&  print "Foobar $thing stuff\en";
.Ve
.Sp
instead do it thru maketext, using no variable interpolation in
the key:
.Sp
.Vb 1
\&  print $lh\->maketext("Foobar [_1] stuff\en", $thing);
.Ve
.Sp
If you get tired of constantly saying \f(CW\*(C`print $lh\->maketext\*(C'\fR,
consider making a functional wrapper for it, like so:
.Sp
.Vb 7
\&  use Projname::L10N;
\&  use vars qw($lh);
\&  $lh = Projname::L10N\->get_handle(...) || die "Language?";
\&  sub pmt (@) { print( $lh\->maketext(@_)) }
\&   # "pmt" is short for "Print MakeText"
\&  $Carp::Verbose = 1;
\&   # so if maketext fails, we see made the call to pmt
.Ve
.Sp
Besides whole phrases meant for output, anything language-dependent
should be put into the class Projname::L10N::en_us,
whether as methods, or as lexicon entries \*(-- this is discussed
in the section \*(L"Entries in Each Lexicon\*(R", above.
.IP "\(bu" 4
Once the program is otherwise done, and once its localization for
the first language works right (via the data and methods in
Projname::L10N::en_us), you can get together the data for translation.
If your first language lexicon isn't an _AUTO lexicon, then you already
have all the messages explicitly in the lexicon (or else you'd be
getting exceptions thrown when you call \f(CW$lh\fR\->maketext to get
messages that aren't in there).  But if you were (advisedly) lazy and are
using an _AUTO lexicon, then you've got to make a list of all the phrases
that you've so far been letting _AUTO generate for you.  There are very
many ways to assemble such a list.  The most straightforward is to simply
grep the source for every occurrence of \*(L"maketext\*(R" (or calls
to wrappers around it, like the above \f(CW\*(C`pmt\*(C'\fR function), and to log the
following phrase.
.IP "\(bu" 4
You may at this point want to consider whether your base class 
(Projname::L10N), from which all lexicons inherit from (Projname::L10N::en,
Projname::L10N::es, etc.), should be an _AUTO lexicon.  It may be true
that in theory, all needed messages will be in each language class;
but in the presumably unlikely or \*(L"impossible\*(R" case of lookup failure,
you should consider whether your program should throw an exception,
emit text in English (or whatever your project's first language is),
or some more complex solution as described in the section
\&\*(L"Controlling Lookup Failure\*(R", above.
.IP "\(bu" 4
Submit all messages/phrases/etc. to translators.
.Sp
(You may, in fact, want to start with localizing to \fIone\fR other language
at first, if you're not sure that you've properly abstracted the
language-dependent parts of your code.)
.Sp
Translators may request clarification of the situation in which a
particular phrase is found.  For example, in English we are entirely happy
saying "\fIn\fR files found\*(L", regardless of whether we mean \*(R"I looked for files,
and found \fIn\fR of them\*(L" or the rather distinct situation of \*(R"I looked for
something else (like lines in files), and along the way I saw \fIn\fR
files.\*(L"  This may involve rethinking things that you thought quite clear:
should \*(R"Edit\*(L" on a toolbar be a noun (\*(R"editing\*(L") or a verb (\*(R"to edit\*(L")?  Is
there already a conventionalized way to express that menu option, separate
from the target language's normal word for \*(R"to edit"?
.Sp
In all cases where the very common phenomenon of quantification
(saying "\fIN\fR files", for \fBany\fR value of N)
is involved, each translator should make clear what dependencies the
number causes in the sentence.  In many cases, dependency is
limited to words adjacent to the number, in places where you might
expect them ("I found the\-?PLURAL \fIN\fR
empty\-?PLURAL directory\-?PLURAL\*(L"), but in some cases there are
unexpected dependencies (\*(R"I found\-?PLURAL ...\*(L"!) as well as long-distance
dependencies \*(R"The \fIN\fR directory\-?PLURAL could not be deleted\-?PLURAL"!).
.Sp
Remind the translators to consider the case where N is 0:
\&\*(L"0 files found\*(R" isn't exactly natural-sounding in any language, but it
may be unacceptable in many \*(-- or it may condition special
kinds of agreement (similar to English \*(L"I didN'T find \s-1ANY\s0 files\*(R").
.Sp
Remember to ask your translators about numeral formatting in their
language, so that you can override the \f(CW\*(C`numf\*(C'\fR method as
appropriate.  Typical variables in number formatting are:  what to
use as a decimal point (comma? period?); what to use as a thousands
separator (space? nonbreaking space? comma? period? small
middot? prime? apostrophe?); and even whether the so-called \*(L"thousands
separator\*(R" is actually for every third digit \*(-- I've heard reports of
two hundred thousand being expressible as \*(L"2,00,000\*(R" for some Indian
(Subcontinental) languages, besides the less surprising \*(L"200\ 000\*(R",
\&\*(L"200.000\*(R", \*(L"200,000\*(R", and \*(L"200'000\*(R".  Also, using a set of numeral
glyphs other than the usual \s-1ASCII \*(L"0\*(R"\-\*(L"9\*(R"\s0 might be appreciated, as via
\&\f(CW\*(C`tr/0\-9/\ex{0966}\-\ex{096F}/\*(C'\fR for getting digits in Devanagari script
(for Hindi, Konkani, others).
.Sp
The basic \f(CW\*(C`quant\*(C'\fR method that Locale::Maketext provides should be
good for many languages.  For some languages, it might be useful
to modify it (or its constituent \f(CW\*(C`numerate\*(C'\fR method)
to take a plural form in the two-argument call to \f(CW\*(C`quant\*(C'\fR
(as in \*(L"[quant,_1,files]\*(R") if
it's all-around easier to infer the singular form from the plural, than
to infer the plural form from the singular.
.Sp
But for other languages (as is discussed at length
in Locale::Maketext::TPJ13), simple
\&\f(CW\*(C`quant\*(C'\fR/\f(CW\*(C`numf\*(C'\fR is not enough.  For the particularly problematic
Slavic languages, what you may need is a method which you provide
with the number, the citation form of the noun to quantify, and
the case and gender that the sentence's syntax projects onto that
noun slot.  The method would then be responsible for determining
what grammatical number that numeral projects onto its noun phrase,
and what case and gender it may override the normal case and gender
with; and then it would look up the noun in a lexicon providing
all needed inflected forms.
.IP "\(bu" 4
You may also wish to discuss with the translators the question of
how to relate different subforms of the same language tag,
considering how this reacts with \f(CW\*(C`get_handle\*(C'\fR's treatment of
these.  For example, if a user accepts interfaces in \*(L"en, fr\*(R", and
you have interfaces available in \*(L"en-US\*(R" and \*(L"fr\*(R", what should
they get?  You may wish to resolve this by establishing that \*(L"en\*(R"
and \*(L"en-US\*(R" are effectively synonymous, by having one class
zero-derive from the other.
.Sp
For some languages this issue may never come up (Danish is rarely
expressed as \*(L"da-DK\*(R", but instead is just \*(L"da\*(R").  And for other
languages, the whole concept of a \*(L"generic\*(R" form may verge on
being uselessly vague, particularly for interfaces involving voice
media in forms of Arabic or Chinese.
.IP "\(bu" 4
Once you've localized your program/site/etc. for all desired
languages, be sure to show the result (whether live, or via
screenshots) to the translators.  Once they approve, make every
effort to have it then checked by at least one other speaker of
that language.  This holds true even when (or especially when) the
translation is done by one of your own programmers.  Some
kinds of systems may be harder to find testers for than others,
depending on the amount of domain-specific jargon and concepts
involved \*(-- it's easier to find people who can tell you whether
they approve of your translation for \*(L"delete this message\*(R" in an
email-via-Web interface, than to find people who can give you
an informed opinion on your translation for \*(L"attribute value\*(R"
in an \s-1XML\s0 query tool's interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I recommend reading all of these:
.PP
Locale::Maketext::TPJ13 \*(-- my \fIThe Perl
Journal\fR article about Maketext.  It explains many important concepts
underlying Locale::Maketext's design, and some insight into why
Maketext is better than the plain old approach of having 
message catalogs that are just databases of sprintf formats.
.PP
File::Findgrep is a sample application/module
that uses Locale::Maketext to localize its messages.  For a larger
internationalized system, see also Apache::MP3.
.PP
I18N::LangTags.
.PP
Win32::Locale.
.PP
\&\s-1RFC 3066, \s0\fITags for the Identification of Languages\fR,
as at http://sunsite.dk/RFC/rfc/rfc3066.html
.PP
\&\s-1RFC 2277, \s0\fI\s-1IETF\s0 Policy on Character Sets and Languages\fR
is at http://sunsite.dk/RFC/rfc/rfc2277.html \*(-- much of it is
just things of interest to protocol designers, but it explains
some basic concepts, like the distinction between locales and
language-tags.
.PP
The manual for \s-1GNU \s0\f(CW\*(C`gettext\*(C'\fR.  The gettext dist is available in
\&\f(CW\*(C`ftp://prep.ai.mit.edu/pub/gnu/\*(C'\fR \*(-- get
a recent gettext tarball and look in its \*(L"doc/\*(R" directory, there's
an easily browsable \s-1HTML\s0 version in there.  The
gettext documentation asks lots of questions worth thinking
about, even if some of their answers are sometimes wonky,
particularly where they start talking about pluralization.
.PP
The Locale/Maketext.pm source.  Obverse that the module is much
shorter than its documentation!
.SH "COPYRIGHT AND DISCLAIMER"
.IX Header "COPYRIGHT AND DISCLAIMER"
Copyright (c) 1999\-2004 Sean M. Burke.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext5.16.3pm                     0100644 0001750 0001750 00000165273 12566207436 024722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext 3pm"
.TH Locale::Maketext 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext \- framework for localization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  package MyProgram;
\&  use strict;
\&  use MyProgram::L10N;
\&   # ...which inherits from Locale::Maketext
\&  my $lh = MyProgram::L10N\->get_handle() || die "What language?";
\&  ...
\&  # And then any messages your program emits, like:
\&  warn $lh\->maketext( "Can\*(Aqt open file [_1]: [_2]\en", $f, $! );
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is a common feature of applications (whether run directly,
or via the Web) for them to be \*(L"localized\*(R" \*(-- i.e., for them
to a present an English interface to an English-speaker, a German
interface to a German-speaker, and so on for all languages it's
programmed with.  Locale::Maketext
is a framework for software localization; it provides you with the
tools for organizing and accessing the bits of text and text-processing
code that you need for producing localized applications.
.PP
In order to make sense of Maketext and how all its
components fit together, you should probably
go read Locale::Maketext::TPJ13, and
\&\fIthen\fR read the following documentation.
.PP
You may also want to read over the source for \f(CW\*(C`File::Findgrep\*(C'\fR
and its constituent modules \*(-- they are a complete (if small)
example application that uses Maketext.
.SH "QUICK OVERVIEW"
.IX Header "QUICK OVERVIEW"
The basic design of Locale::Maketext is object-oriented, and
Locale::Maketext is an abstract base class, from which you
derive a \*(L"project class\*(R".
The project class (with a name like \*(L"TkBocciBall::Localize\*(R",
which you then use in your module) is in turn the base class
for all the \*(L"language classes\*(R" for your project
(with names \*(L"TkBocciBall::Localize::it\*(R", 
\&\*(L"TkBocciBall::Localize::en\*(R",
\&\*(L"TkBocciBall::Localize::fr\*(R", etc.).
.PP
A language class is
a class containing a lexicon of phrases as class data,
and possibly also some methods that are of use in interpreting
phrases in the lexicon, or otherwise dealing with text in that
language.
.PP
An object belonging to a language class is called a \*(L"language
handle\*(R"; it's typically a flyweight object.
.PP
The normal course of action is to call:
.PP
.Vb 6
\&  use TkBocciBall::Localize;  # the localization project class
\&  $lh = TkBocciBall::Localize\->get_handle();
\&   # Depending on the user\*(Aqs locale, etc., this will
\&   # make a language handle from among the classes available,
\&   # and any defaults that you declare.
\&  die "Couldn\*(Aqt make a language handle??" unless $lh;
.Ve
.PP
From then on, you use the \f(CW\*(C`maketext\*(C'\fR function to access
entries in whatever lexicon(s) belong to the language handle
you got.  So, this:
.PP
.Vb 1
\&  print $lh\->maketext("You won!"), "\en";
.Ve
.PP
\&...emits the right text for this language.  If the object
in \f(CW$lh\fR belongs to class \*(L"TkBocciBall::Localize::fr\*(R" and
\&\f(CW%TkBocciBall::Localize::fr::Lexicon\fR contains \f(CW\*(C`("You won!"
=> "Tu as gagne\*'!")\*(C'\fR, then the above
code happily tells the user \*(L"Tu as gagne\*'!\*(R".
.SH "METHODS"
.IX Header "METHODS"
Locale::Maketext offers a variety of methods, which fall
into three categories:
.IP "\(bu" 4
Methods to do with constructing language handles.
.IP "\(bu" 4
\&\f(CW\*(C`maketext\*(C'\fR and other methods to do with accessing \f(CW%Lexicon\fR data
for a given language handle.
.IP "\(bu" 4
Methods that you may find it handy to use, from routines of
yours that you put in \f(CW%Lexicon\fR entries.
.PP
These are covered in the following section.
.SS "Construction Methods"
.IX Subsection "Construction Methods"
These are to do with constructing a language handle:
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass\->get_handle( ...langtags... ) || die \*(L"lg-handle?\*(R";
.Sp
This tries loading classes based on the language-tags you give (like
\&\f(CW\*(C`("en\-US", "sk", "kon", "es\-MX", "ja", "i\-klingon")\*(C'\fR, and for the first class
that succeeds, returns YourProjClass::\fIlanguage\fR\->\fInew()\fR.
.Sp
If it runs thru the entire given list of language-tags, and finds no classes
for those exact terms, it then tries \*(L"superordinate\*(R" language classes.
So if no \*(L"en-US\*(R" class (i.e., YourProjClass::en_us)
was found, nor classes for anything else in that list, we then try
its superordinate, \*(L"en\*(R" (i.e., YourProjClass::en), and so on thru 
the other language-tags in the given list: \*(L"es\*(R".
(The other language-tags in our example list: 
happen to have no superordinates.)
.Sp
If none of those language-tags leads to loadable classes, we then
try classes derived from YourProjClass\->\fIfallback_languages()\fR and
then if nothing comes of that, we use classes named by
YourProjClass\->\fIfallback_language_classes()\fR.  Then in the (probably
quite unlikely) event that that fails, we just return undef.
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass\->get_handle\fB()\fR || die \*(L"lg-handle?\*(R";
.Sp
When \f(CW\*(C`get_handle\*(C'\fR is called with an empty parameter list, magic happens:
.Sp
If \f(CW\*(C`get_handle\*(C'\fR senses that it's running in program that was
invoked as a \s-1CGI\s0, then it tries to get language-tags out of the
environment variable \*(L"\s-1HTTP_ACCEPT_LANGUAGE\s0\*(R", and it pretends that
those were the languages passed as parameters to \f(CW\*(C`get_handle\*(C'\fR.
.Sp
Otherwise (i.e., if not a \s-1CGI\s0), this tries various OS-specific ways
to get the language-tags for the current locale/language, and then
pretends that those were the value(s) passed to \f(CW\*(C`get_handle\*(C'\fR.
.Sp
Currently this OS-specific stuff consists of looking in the environment
variables \*(L"\s-1LANG\s0\*(R" and \*(L"\s-1LANGUAGE\s0\*(R"; and on MSWin machines (where those
variables are typically unused), this also tries using
the module Win32::Locale to get a language-tag for whatever language/locale
is currently selected in the \*(L"Regional Settings\*(R" (or \*(L"International\*(R"?)
Control Panel.  I welcome further
suggestions for making this do the Right Thing under other operating
systems that support localization.
.Sp
If you're using localization in an application that keeps a configuration
file, you might consider something like this in your project class:
.Sp
.Vb 10
\&  sub get_handle_via_config {
\&    my $class = $_[0];
\&    my $chosen_language = $Config_settings{\*(Aqlanguage\*(Aq};
\&    my $lh;
\&    if($chosen_language) {
\&      $lh = $class\->get_handle($chosen_language)
\&       || die "No language handle for \e"$chosen_language\e""
\&            . " or the like";
\&    } else {
\&      # Config file missing, maybe?
\&      $lh = $class\->get_handle()
\&       || die "Can\*(Aqt get a language handle";
\&    }
\&    return $lh;
\&  }
.Ve
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass::langname\->\fInew()\fR;
.Sp
This constructs a language handle.  You usually \fBdon't\fR call this
directly, but instead let \f(CW\*(C`get_handle\*(C'\fR find a language class to \f(CW\*(C`use\*(C'\fR
and to then call \->new on.
.IP "\(bu" 4
\&\f(CW$lh\fR\->\fIinit()\fR;
.Sp
This is called by \->new to initialize newly-constructed language handles.
If you define an init method in your class, remember that it's usually
considered a good idea to call \f(CW$lh\fR\->SUPER::init in it (presumably at the
beginning), so that all classes get a chance to initialize a new object
however they see fit.
.IP "\(bu" 4
YourProjClass\->\fIfallback_languages()\fR
.Sp
\&\f(CW\*(C`get_handle\*(C'\fR appends the return value of this to the end of
whatever list of languages you pass \f(CW\*(C`get_handle\*(C'\fR.  Unless
you override this method, your project class
will inherit Locale::Maketext's \f(CW\*(C`fallback_languages\*(C'\fR, which
currently returns \f(CW\*(C`(\*(Aqi\-default\*(Aq, \*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)\*(C'\fR.
(\*(L"i\-default\*(R" is defined in \s-1RFC\s0 2277).
.Sp
This method (by having it return the name
of a language-tag that has an existing language class)
can be used for making sure that
\&\f(CW\*(C`get_handle\*(C'\fR will always manage to construct a language
handle (assuming your language classes are in an appropriate
\&\f(CW@INC\fR directory).  Or you can use the next method:
.IP "\(bu" 4
YourProjClass\->\fIfallback_language_classes()\fR
.Sp
\&\f(CW\*(C`get_handle\*(C'\fR appends the return value of this to the end
of the list of classes it will try using.  Unless
you override this method, your project class
will inherit Locale::Maketext's \f(CW\*(C`fallback_language_classes\*(C'\fR,
which currently returns an empty list, \f(CW\*(C`()\*(C'\fR.
By setting this to some value (namely, the name of a loadable
language class), you can be sure that
\&\f(CW\*(C`get_handle\*(C'\fR will always manage to construct a language
handle.
.ie n .SS "The ""maketext"" Method"
.el .SS "The ``maketext'' Method"
.IX Subsection "The maketext Method"
This is the most important method in Locale::Maketext:
.PP
.Vb 1
\&    $text = $lh\->maketext(I<key>, ...parameters for this phrase...);
.Ve
.PP
This looks in the \f(CW%Lexicon\fR of the language handle
\&\f(CW$lh\fR and all its superclasses, looking
for an entry whose key is the string \fIkey\fR.  Assuming such
an entry is found, various things then happen, depending on the
value found:
.PP
If the value is a scalarref, the scalar is dereferenced and returned
(and any parameters are ignored).
.PP
If the value is a coderef, we return &$value($lh, ...parameters...).
.PP
If the value is a string that \fIdoesn't\fR look like it's in Bracket Notation,
we return it (after replacing it with a scalarref, in its \f(CW%Lexicon\fR).
.PP
If the value \fIdoes\fR look like it's in Bracket Notation, then we compile
it into a sub, replace the string in the \f(CW%Lexicon\fR with the new coderef,
and then we return &$new_sub($lh, ...parameters...).
.PP
Bracket Notation is discussed in a later section.  Note
that trying to compile a string into Bracket Notation can throw
an exception if the string is not syntactically valid (say, by not
balancing brackets right.)
.PP
Also, calling &$coderef($lh, ...parameters...) can throw any sort of
exception (if, say, code in that sub tries to divide by zero).  But
a very common exception occurs when you have Bracket
Notation text that says to call a method \*(L"foo\*(R", but there is no such
method.  (E.g., "You have [qua\fBtn\fR,_1,ball]." will throw an exception
on trying to call \f(CW$lh\fR\->qua\fBtn\fR($_[1],'ball') \*(-- you presumably meant
\&\*(L"quant\*(R".)  \f(CW\*(C`maketext\*(C'\fR catches these exceptions, but only to make the
error message more readable, at which point it rethrows the exception.
.PP
An exception \fImay\fR be thrown if \fIkey\fR is not found in any
of \f(CW$lh\fR's \f(CW%Lexicon\fR hashes.  What happens if a key is not found,
is discussed in a later section, \*(L"Controlling Lookup Failure\*(R".
.PP
Note that you might find it useful in some cases to override
the \f(CW\*(C`maketext\*(C'\fR method with an \*(L"after method\*(R", if you want to
translate encodings, or even scripts:
.PP
.Vb 7
\&    package YrProj::zh_cn; # Chinese with PRC\-style glyphs
\&    use base (\*(AqYrProj::zh_tw\*(Aq);  # Taiwan\-style
\&    sub maketext {
\&      my $self = shift(@_);
\&      my $value = $self\->maketext(@_);
\&      return Chineeze::taiwan2mainland($value);
\&    }
.Ve
.PP
Or you may want to override it with something that traps
any exceptions, if that's critical to your program:
.PP
.Vb 7
\&  sub maketext {
\&    my($lh, @stuff) = @_;
\&    my $out;
\&    eval { $out = $lh\->SUPER::maketext(@stuff) };
\&    return $out unless $@;
\&    ...otherwise deal with the exception...
\&  }
.Ve
.PP
Other than those two situations, I don't imagine that
it's useful to override the \f(CW\*(C`maketext\*(C'\fR method.  (If
you run into a situation where it is useful, I'd be
interested in hearing about it.)
.ie n .IP "$lh\->fail_with \fIor\fR $lh\->fail_with(\fI\s-1PARAM\s0\fR)" 4
.el .IP "\f(CW$lh\fR\->fail_with \fIor\fR \f(CW$lh\fR\->fail_with(\fI\s-1PARAM\s0\fR)" 4
.IX Item "$lh->fail_with or $lh->fail_with(PARAM)"
.PD 0
.ie n .IP "$lh\->failure_handler_auto" 4
.el .IP "\f(CW$lh\fR\->failure_handler_auto" 4
.IX Item "$lh->failure_handler_auto"
.PD
These two methods are discussed in the section \*(L"Controlling
Lookup Failure\*(R".
.SS "Utility Methods"
.IX Subsection "Utility Methods"
These are methods that you may find it handy to use, generally
from \f(CW%Lexicon\fR routines of yours (whether expressed as
Bracket Notation or not).
.ie n .IP "$language\->quant($number, $singular)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR)" 4
.IX Item "$language->quant($number, $singular)"
.PD 0
.ie n .IP "$language\->quant($number, $singular, $plural)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR, \f(CW$plural\fR)" 4
.IX Item "$language->quant($number, $singular, $plural)"
.ie n .IP "$language\->quant($number, $singular, $plural, $negative)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR, \f(CW$plural\fR, \f(CW$negative\fR)" 4
.IX Item "$language->quant($number, $singular, $plural, $negative)"
.PD
This is generally meant to be called from inside Bracket Notation
(which is discussed later), as in
.Sp
.Vb 1
\&     "Your search matched [quant,_1,document]!"
.Ve
.Sp
It's for \fIquantifying\fR a noun (i.e., saying how much of it there is,
while giving the correct form of it).  The behavior of this method is
handy for English and a few other Western European languages, and you
should override it for languages where it's not suitable.  You can feel
free to read the source, but the current implementation is basically
as this pseudocode describes:
.Sp
.Vb 11
\&     if $number is 0 and there\*(Aqs a $negative,
\&        return $negative;
\&     elsif $number is 1,
\&        return "1 $singular";
\&     elsif there\*(Aqs a $plural,
\&        return "$number $plural";
\&     else
\&        return "$number " . $singular . "s";
\&     #
\&     # ...except that we actually call numf to
\&     #  stringify $number before returning it.
.Ve
.Sp
So for English (with Bracket Notation)
\&\f(CW"...[quant,_1,file]..."\fR is fine (for 0 it returns \*(L"0 files\*(R",
for 1 it returns \*(L"1 file\*(R", and for more it returns \*(L"2 files\*(R", etc.)
.Sp
But for \*(L"directory\*(R", you'd want \f(CW"[quant,_1,directory,directories]"\fR
so that our elementary \f(CW\*(C`quant\*(C'\fR method doesn't think that the
plural of \*(L"directory\*(R" is \*(L"directorys\*(R".  And you might find that the
output may sound better if you specify a negative form, as in:
.Sp
.Vb 1
\&     "[quant,_1,file,files,No files] matched your query.\en"
.Ve
.Sp
Remember to keep in mind verb agreement (or adjectives too, in
other languages), as in:
.Sp
.Vb 1
\&     "[quant,_1,document] were matched.\en"
.Ve
.Sp
Because if _1 is one, you get "1 document \fBwere\fR matched".
An acceptable hack here is to do something like this:
.Sp
.Vb 1
\&     "[quant,_1,document was, documents were] matched.\en"
.Ve
.ie n .IP "$language\->numf($number)" 4
.el .IP "\f(CW$language\fR\->numf($number)" 4
.IX Item "$language->numf($number)"
This returns the given number formatted nicely according to
this language's conventions.  Maketext's default method is
mostly to just take the normal string form of the number
(applying sprintf \*(L"%G\*(R" for only very large numbers), and then
to add commas as necessary.  (Except that
we apply \f(CW\*(C`tr/,./.,/\*(C'\fR if \f(CW$language\fR\->{'numf_comma'} is true;
that's a bit of a hack that's useful for languages that express
two million as \*(L"2.000.000\*(R" and not as \*(L"2,000,000\*(R").
.Sp
If you want anything fancier, consider overriding this with something
that uses Number::Format, or does something else
entirely.
.Sp
Note that numf is called by quant for stringifying all quantifying
numbers.
.ie n .IP "$language\->numerate($number, $singular, $plural, $negative)" 4
.el .IP "\f(CW$language\fR\->numerate($number, \f(CW$singular\fR, \f(CW$plural\fR, \f(CW$negative\fR)" 4
.IX Item "$language->numerate($number, $singular, $plural, $negative)"
This returns the given noun form which is appropriate for the quantity
\&\f(CW$number\fR according to this language's conventions.  \f(CW\*(C`numerate\*(C'\fR is
used internally by \f(CW\*(C`quant\*(C'\fR to quantify nouns.  Use it directly \*(--
usually from bracket notation \*(-- to avoid \f(CW\*(C`quant\*(C'\fR's implicit call to
\&\f(CW\*(C`numf\*(C'\fR and output of a numeric quantity.
.ie n .IP "$language\->sprintf($format, @items)" 4
.el .IP "\f(CW$language\fR\->sprintf($format, \f(CW@items\fR)" 4
.IX Item "$language->sprintf($format, @items)"
This is just a wrapper around Perl's normal \f(CW\*(C`sprintf\*(C'\fR function.
It's provided so that you can use \*(L"sprintf\*(R" in Bracket Notation:
.Sp
.Vb 1
\&     "Couldn\*(Aqt access datanode [sprintf,%10x=~[%s~],_1,_2]!\en"
.Ve
.Sp
returning...
.Sp
.Vb 1
\&     Couldn\*(Aqt access datanode      Stuff=[thangamabob]!
.Ve
.ie n .IP "$language\->\fIlanguage_tag()\fR" 4
.el .IP "\f(CW$language\fR\->\fIlanguage_tag()\fR" 4
.IX Item "$language->language_tag()"
Currently this just takes the last bit of \f(CW\*(C`ref($language)\*(C'\fR, turns
underscores to dashes, and returns it.  So if \f(CW$language\fR is
an object of class Hee::HOO::Haw::en_us, \f(CW$language\fR\->\fIlanguage_tag()\fR
returns \*(L"en-us\*(R".  (Yes, the usual representation for that language
tag is \*(L"en-US\*(R", but case is \fInever\fR considered meaningful in
language-tag comparison.)
.Sp
You may override this as you like; Maketext doesn't use it for
anything.
.ie n .IP "$language\->\fIencoding()\fR" 4
.el .IP "\f(CW$language\fR\->\fIencoding()\fR" 4
.IX Item "$language->encoding()"
Currently this isn't used for anything, but it's provided
(with default value of
\&\f(CW\*(C`(ref($language) && $language\->{\*(Aqencoding\*(Aq})) or "iso\-8859\-1"\*(C'\fR
) as a sort of suggestion that it may be useful/necessary to
associate encodings with your language handles (whether on a
per-class or even per-handle basis.)
.SS "Language Handle Attributes and Internals"
.IX Subsection "Language Handle Attributes and Internals"
A language handle is a flyweight object \*(-- i.e., it doesn't (necessarily)
carry any data of interest, other than just being a member of
whatever class it belongs to.
.PP
A language handle is implemented as a blessed hash.  Subclasses of yours
can store whatever data you want in the hash.  Currently the only hash
entry used by any crucial Maketext method is \*(L"fail\*(R", so feel free to
use anything else as you like.
.PP
\&\fBRemember: Don't be afraid to read the Maketext source if there's
any point on which this documentation is unclear.\fR  This documentation
is vastly longer than the module source itself.
.SH "LANGUAGE CLASS HIERARCHIES"
.IX Header "LANGUAGE CLASS HIERARCHIES"
These are Locale::Maketext's assumptions about the class
hierarchy formed by all your language classes:
.IP "\(bu" 4
You must have a project base class, which you load, and
which you then use as the first argument in
the call to YourProjClass\->get_handle(...).  It should derive
(whether directly or indirectly) from Locale::Maketext.
It \fBdoesn't matter\fR how you name this class, although assuming this
is the localization component of your Super Mega Program,
good names for your project class might be
SuperMegaProgram::Localization, SuperMegaProgram::L10N,
SuperMegaProgram::I18N, SuperMegaProgram::International,
or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.
.IP "\(bu" 4
Language classes are what YourProjClass\->get_handle will try to load.
It will look for them by taking each language-tag (\fBskipping\fR it
if it doesn't look like a language-tag or locale-tag!), turning it to
all lowercase, turning dashes to underscores, and appending it
to YourProjClass . \*(L"::\*(R".  So this:
.Sp
.Vb 3
\&  $lh = YourProjClass\->get_handle(
\&    \*(Aqen\-US\*(Aq, \*(Aqfr\*(Aq, \*(Aqkon\*(Aq, \*(Aqi\-klingon\*(Aq, \*(Aqi\-klingon\-romanized\*(Aq
\&  );
.Ve
.Sp
will try loading the classes 
YourProjClass::en_us (note lowercase!), YourProjClass::fr, 
YourProjClass::kon,
YourProjClass::i_klingon
and YourProjClass::i_klingon_romanized.  (And it'll stop at the
first one that actually loads.)
.IP "\(bu" 4
I assume that each language class derives (directly or indirectly)
from your project class, and also defines its \f(CW@ISA\fR, its \f(CW%Lexicon\fR,
or both.  But I anticipate no dire consequences if these assumptions
do not hold.
.IP "\(bu" 4
Language classes may derive from other language classes (although they
should have "use \fIThatclassname\fR\*(L" or \*(R"use base qw(\fI...classes...\fR)").
They may derive from the project
class.  They may derive from some other class altogether.  Or via
multiple inheritance, it may derive from any mixture of these.
.IP "\(bu" 4
I foresee no problems with having multiple inheritance in
your hierarchy of language classes.  (As usual, however, Perl will
complain bitterly if you have a cycle in the hierarchy: i.e., if
any class is its own ancestor.)
.SH "ENTRIES IN EACH LEXICON"
.IX Header "ENTRIES IN EACH LEXICON"
A typical \f(CW%Lexicon\fR entry is meant to signify a phrase,
taking some number (0 or more) of parameters.  An entry
is meant to be accessed by via
a string \fIkey\fR in \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...),
which should return a string that is generally meant for
be used for \*(L"output\*(R" to the user \*(-- regardless of whether
this actually means printing to \s-1STDOUT\s0, writing to a file,
or putting into a \s-1GUI\s0 widget.
.PP
While the key must be a string value (since that's a basic
restriction that Perl places on hash keys), the value in
the lexicon can currently be of several types:
a defined scalar, scalarref, or coderef.  The use of these is
explained above, in the section 'The \*(L"maketext\*(R" Method', and
Bracket Notation for strings is discussed in the next section.
.PP
While you can use arbitrary unique IDs for lexicon keys
(like \*(L"_min_larger_max_error\*(R"), it is often
useful for if an entry's key is itself a valid value, like
this example error message:
.PP
.Vb 1
\&  "Minimum ([_1]) is larger than maximum ([_2])!\en",
.Ve
.PP
Compare this code that uses an arbitrary \s-1ID\s0...
.PP
.Vb 2
\&  die $lh\->maketext( "_min_larger_max_error", $min, $max )
\&   if $min > $max;
.Ve
.PP
\&...to this code that uses a key-as-value:
.PP
.Vb 4
\&  die $lh\->maketext(
\&   "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&   $min, $max
\&  ) if $min > $max;
.Ve
.PP
The second is, in short, more readable.  In particular, it's obvious
that the number of parameters you're feeding to that phrase (two) is
the number of parameters that it \fIwants\fR to be fed.  (Since you see
_1 and a _2 being used in the key there.)
.PP
Also, once a project is otherwise
complete and you start to localize it, you can scrape together
all the various keys you use, and pass it to a translator; and then
the translator's work will go faster if what he's presented is this:
.PP
.Vb 2
\& "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&  => "",   # fill in something here, Jacques!
.Ve
.PP
rather than this more cryptic mess:
.PP
.Vb 2
\& "_min_larger_max_error"
\&  => "",   # fill in something here, Jacques
.Ve
.PP
I think that keys as lexicon values makes the completed lexicon
entries more readable:
.PP
.Vb 2
\& "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&  => "Le minimum ([_1]) est plus grand que le maximum ([_2])!\en",
.Ve
.PP
Also, having valid values as keys becomes very useful if you set
up an _AUTO lexicon.  _AUTO lexicons are discussed in a later
section.
.PP
I almost always use keys that are themselves
valid lexicon values.  One notable exception is when the value is
quite long.  For example, to get the screenful of data that
a command-line program might return when given an unknown switch,
I often just use a brief, self-explanatory key such as \*(L"_USAGE_MESSAGE\*(R".  At that point I then go
and immediately to define that lexicon entry in the
ProjectClass::L10N::en lexicon (since English is always my \*(L"project
language\*(R"):
.PP
.Vb 3
\&  \*(Aq_USAGE_MESSAGE\*(Aq => <<\*(AqEOSTUFF\*(Aq,
\&  ...long long message...
\&  EOSTUFF
.Ve
.PP
and then I can use it as:
.PP
.Vb 1
\&  getopt(\*(AqoDI\*(Aq, \e%opts) or die $lh\->maketext(\*(Aq_USAGE_MESSAGE\*(Aq);
.Ve
.PP
Incidentally,
note that each class's \f(CW%Lexicon\fR inherits-and-extends
the lexicons in its superclasses.  This is not because these are
special hashes \fIper se\fR, but because you access them via the
\&\f(CW\*(C`maketext\*(C'\fR method, which looks for entries across all the
\&\f(CW%Lexicon\fR hashes in a language class \fIand\fR all its ancestor classes.
(This is because the idea of \*(L"class data\*(R" isn't directly implemented
in Perl, but is instead left to individual class-systems to implement
as they see fit..)
.PP
Note that you may have things stored in a lexicon
besides just phrases for output:  for example, if your program
takes input from the keyboard, asking a \*(L"(Y/N)\*(R" question,
you probably need to know what the equivalent of \*(L"Y[es]/N[o]\*(R" is
in whatever language.  You probably also need to know what
the equivalents of the answers \*(L"y\*(R" and \*(L"n\*(R" are.  You can
store that information in the lexicon (say, under the keys
\&\*(L"~answer_y\*(R" and \*(L"~answer_n\*(R", and the long forms as
\&\*(L"~answer_yes\*(R" and \*(L"~answer_no\*(R", where \*(L"~\*(R" is just an ad-hoc
character meant to indicate to programmers/translators that
these are not phrases for output).
.PP
Or instead of storing this in the language class's lexicon,
you can (and, in some cases, really should) represent the same bit
of knowledge as code in a method in the language class.  (That
leaves a tidy distinction between the lexicon as the things we
know how to \fIsay\fR, and the rest of the things in the lexicon class
as things that we know how to \fIdo\fR.)  Consider
this example of a processor for responses to French \*(L"oui/non\*(R"
questions:
.PP
.Vb 7
\&  sub y_or_n {
\&    return undef unless defined $_[1] and length $_[1];
\&    my $answer = lc $_[1];  # smash case
\&    return 1 if $answer eq \*(Aqo\*(Aq or $answer eq \*(Aqoui\*(Aq;
\&    return 0 if $answer eq \*(Aqn\*(Aq or $answer eq \*(Aqnon\*(Aq;
\&    return undef;
\&  }
.Ve
.PP
\&...which you'd then call in a construct like this:
.PP
.Vb 7
\&  my $response;
\&  until(defined $response) {
\&    print $lh\->maketext("Open the pod bay door (y/n)? ");
\&    $response = $lh\->y_or_n( get_input_from_keyboard_somehow() );
\&  }
\&  if($response) { $pod_bay_door\->open()         }
\&  else          { $pod_bay_door\->leave_closed() }
.Ve
.PP
Other data worth storing in a lexicon might be things like
filenames for language-targetted resources:
.PP
.Vb 10
\&  ...
\&  "_main_splash_png"
\&    => "/styles/en_us/main_splash.png",
\&  "_main_splash_imagemap"
\&    => "/styles/en_us/main_splash.incl",
\&  "_general_graphics_path"
\&    => "/styles/en_us/",
\&  "_alert_sound"
\&    => "/styles/en_us/hey_there.wav",
\&  "_forward_icon"
\&   => "left_arrow.png",
\&  "_backward_icon"
\&   => "right_arrow.png",
\&  # In some other languages, left equals
\&  #  BACKwards, and right is FOREwards.
\&  ...
.Ve
.PP
You might want to do the same thing for expressing key bindings
or the like (since hardwiring \*(L"q\*(R" as the binding for the function
that quits a screen/menu/program is useful only if your language
happens to associate \*(L"q\*(R" with \*(L"quit\*(R"!)
.SH "BRACKET NOTATION"
.IX Header "BRACKET NOTATION"
Bracket Notation is a crucial feature of Locale::Maketext.  I mean
Bracket Notation to provide a replacement for the use of sprintf formatting.
Everything you do with Bracket Notation could be done with a sub block,
but bracket notation is meant to be much more concise.
.PP
Bracket Notation is a like a miniature \*(L"template\*(R" system (in the sense
of Text::Template, not in the sense of \*(C+ templates),
where normal text is passed thru basically as is, but text in special
regions is specially interpreted.  In Bracket Notation, you use square brackets (\*(L"[...]\*(R"),
not curly braces (\*(L"{...}\*(R") to note sections that are specially interpreted.
.PP
For example, here all the areas that are taken literally are underlined with
a \*(L"^\*(R", and all the in-bracket special regions are underlined with an X:
.PP
.Vb 2
\&  "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&   ^^^^^^^^^ XX ^^^^^^^^^^^^^^^^^^^^^^^^^^ XX ^^^^
.Ve
.PP
When that string is compiled from bracket notation into a real Perl sub,
it's basically turned into:
.PP
.Vb 11
\&  sub {
\&    my $lh = $_[0];
\&    my @params = @_;
\&    return join \*(Aq\*(Aq,
\&      "Minimum (",
\&      ...some code here...
\&      ") is larger than maximum (",
\&      ...some code here...
\&      ")!\en",
\&  }
\&  # to be called by $lh\->maketext(KEY, params...)
.Ve
.PP
In other words, text outside bracket groups is turned into string
literals.  Text in brackets is rather more complex, and currently follows
these rules:
.IP "\(bu" 4
Bracket groups that are empty, or which consist only of whitespace,
are ignored.  (Examples: \*(L"[]\*(R", \*(L"[    ]\*(R", or a [ and a ] with returns
and/or tabs and/or spaces between them.
.Sp
Otherwise, each group is taken to be a comma-separated group of items,
and each item is interpreted as follows:
.IP "\(bu" 4
An item that is "_\fIdigits\fR\*(L" or \*(R"_\-\fIdigits\fR" is interpreted as
\&\f(CW$_\fR[\fIvalue\fR].  I.e., \*(L"_1\*(R" becomes with \f(CW$_\fR[1], and \*(L"_\-3\*(R" is interpreted
as \f(CW$_\fR[\-3] (in which case \f(CW@_\fR should have at least three elements in it).
Note that \f(CW$_\fR[0] is the language handle, and is typically not named
directly.
.IP "\(bu" 4
An item \*(L"_*\*(R" is interpreted to mean \*(L"all of \f(CW@_\fR except \f(CW$_\fR[0]\*(R".
I.e., \f(CW@_[1..$#_]\fR.  Note that this is an empty list in the case
of calls like \f(CW$lh\fR\->maketext(\fIkey\fR) where there are no
parameters (except \f(CW$_\fR[0], the language handle).
.IP "\(bu" 4
Otherwise, each item is interpreted as a string literal.
.PP
The group as a whole is interpreted as follows:
.IP "\(bu" 4
If the first item in a bracket group looks like a method name,
then that group is interpreted like this:
.Sp
.Vb 3
\&  $lh\->that_method_name(
\&    ...rest of items in this group...
\&  ),
.Ve
.IP "\(bu" 4
If the first item in a bracket group is \*(L"*\*(R", it's taken as shorthand
for the so commonly called \*(L"quant\*(R" method.  Similarly, if the first
item in a bracket group is \*(L"#\*(R", it's taken to be shorthand for
\&\*(L"numf\*(R".
.IP "\(bu" 4
If the first item in a bracket group is the empty-string, or \*(L"_*\*(R"
or "_\fIdigits\fR\*(L" or \*(R"_\-\fIdigits\fR", then that group is interpreted
as just the interpolation of all its items:
.Sp
.Vb 3
\&  join(\*(Aq\*(Aq,
\&    ...rest of items in this group...
\&  ),
.Ve
.Sp
Examples:  \*(L"[_1]\*(R" and \*(L"[,_1]\*(R", which are synonymous; and
"\f(CW\*(C`[,ID\-(,_4,\-,_2,)]\*(C'\fR", which compiles as
\&\f(CW\*(C`join "", "ID\-(", $_[4], "\-", $_[2], ")"\*(C'\fR.
.IP "\(bu" 4
Otherwise this bracket group is invalid.  For example, in the group
\&\*(L"[!@#,whatever]\*(R", the first item \f(CW"!@#"\fR is neither the empty-string,
"_\fInumber\fR\*(L", \*(R"_\-\fInumber\fR\*(L", \*(R"_*", nor a valid method name; and so
Locale::Maketext will throw an exception of you try compiling an
expression containing this bracket group.
.PP
Note, incidentally, that items in each group are comma-separated,
not \f(CW\*(C`/\es*,\es*/\*(C'\fR\-separated.  That is, you might expect that this
bracket group:
.PP
.Vb 1
\&  "Hoohah [foo, _1 , bar ,baz]!"
.Ve
.PP
would compile to this:
.PP
.Vb 7
\&  sub {
\&    my $lh = $_[0];
\&    return join \*(Aq\*(Aq,
\&      "Hoohah ",
\&      $lh\->foo( $_[1], "bar", "baz"),
\&      "!",
\&  }
.Ve
.PP
But it actually compiles as this:
.PP
.Vb 7
\&  sub {
\&    my $lh = $_[0];
\&    return join \*(Aq\*(Aq,
\&      "Hoohah ",
\&      $lh\->foo(" _1 ", " bar ", "baz"),  # note the <space> in " bar "
\&      "!",
\&  }
.Ve
.PP
In the notation discussed so far, the characters \*(L"[\*(R" and \*(L"]\*(R" are given
special meaning, for opening and closing bracket groups, and \*(L",\*(R" has
a special meaning inside bracket groups, where it separates items in the
group.  This begs the question of how you'd express a literal \*(L"[\*(R" or
\&\*(L"]\*(R" in a Bracket Notation string, and how you'd express a literal
comma inside a bracket group.  For this purpose I've adopted \*(L"~\*(R" (tilde)
as an escape character:  \*(L"~[\*(R" means a literal '[' character anywhere
in Bracket Notation (i.e., regardless of whether you're in a bracket
group or not), and ditto for \*(L"~]\*(R" meaning a literal ']', and \*(L"~,\*(R" meaning
a literal comma.  (Altho \*(L",\*(R" means a literal comma outside of
bracket groups \*(-- it's only inside bracket groups that commas are special.)
.PP
And on the off chance you need a literal tilde in a bracket expression,
you get it with \*(L"~~\*(R".
.PP
Currently, an unescaped \*(L"~\*(R" before a character
other than a bracket or a comma is taken to mean just a \*(L"~\*(R" and that
character.  I.e., \*(L"~X\*(R" means the same as \*(L"~~X\*(R" \*(-- i.e., one literal tilde,
and then one literal \*(L"X\*(R".  However, by using \*(L"~X\*(R", you are assuming that
no future version of Maketext will use \*(L"~X\*(R" as a magic escape sequence.
In practice this is not a great problem, since first off you can just
write \*(L"~~X\*(R" and not worry about it; second off, I doubt I'll add lots
of new magic characters to bracket notation; and third off, you
aren't likely to want literal \*(L"~\*(R" characters in your messages anyway,
since it's not a character with wide use in natural language text.
.PP
Brackets must be balanced \*(-- every openbracket must have
one matching closebracket, and vice versa.  So these are all \fBinvalid\fR:
.PP
.Vb 4
\&  "I ate [quant,_1,rhubarb pie."
\&  "I ate [quant,_1,rhubarb pie[."
\&  "I ate quant,_1,rhubarb pie]."
\&  "I ate quant,_1,rhubarb pie[."
.Ve
.PP
Currently, bracket groups do not nest.  That is, you \fBcannot\fR say:
.PP
.Vb 1
\&  "Foo [bar,baz,[quux,quuux]]\en";
.Ve
.PP
If you need a notation that's that powerful, use normal Perl:
.PP
.Vb 11
\&  %Lexicon = (
\&    ...
\&    "some_key" => sub {
\&      my $lh = $_[0];
\&      join \*(Aq\*(Aq,
\&        "Foo ",
\&        $lh\->bar(\*(Aqbaz\*(Aq, $lh\->quux(\*(Aqquuux\*(Aq)),
\&        "\en",
\&    },
\&    ...
\&  );
.Ve
.PP
Or write the \*(L"bar\*(R" method so you don't need to pass it the
output from calling quux.
.PP
I do not anticipate that you will need (or particularly want)
to nest bracket groups, but you are welcome to email me with
convincing (real-life) arguments to the contrary.
.SH "AUTO LEXICONS"
.IX Header "AUTO LEXICONS"
If maketext goes to look in an individual \f(CW%Lexicon\fR for an entry
for \fIkey\fR (where \fIkey\fR does not start with an underscore), and
sees none, \fBbut does see\fR an entry of \*(L"_AUTO\*(R" => \fIsome_true_value\fR,
then we actually define \f(CW$Lexicon\fR{\fIkey\fR} = \fIkey\fR right then and there,
and then use that value as if it had been there all
along.  This happens before we even look in any superclass \f(CW%Lexicons\fR!
.PP
(This is meant to be somewhat like the \s-1AUTOLOAD\s0 mechanism in
Perl's function call system \*(-- or, looked at another way,
like the AutoLoader module.)
.PP
I can picture all sorts of circumstances where you just
do not want lookup to be able to fail (since failing
normally means that maketext throws a \f(CW\*(C`die\*(C'\fR, although
see the next section for greater control over that).  But
here's one circumstance where _AUTO lexicons are meant to
be \fIespecially\fR useful:
.PP
As you're writing an application, you decide as you go what messages
you need to emit.  Normally you'd go to write this:
.PP
.Vb 5
\&  if(\-e $filename) {
\&    go_process_file($filename)
\&  } else {
\&    print qq{Couldn\*(Aqt find file "$filename"!\en};
\&  }
.Ve
.PP
but since you anticipate localizing this, you write:
.PP
.Vb 10
\&  use ThisProject::I18N;
\&  my $lh = ThisProject::I18N\->get_handle();
\&   # For the moment, assume that things are set up so
\&   # that we load class ThisProject::I18N::en
\&   # and that that\*(Aqs the class that $lh belongs to.
\&  ...
\&  if(\-e $filename) {
\&    go_process_file($filename)
\&  } else {
\&    print $lh\->maketext(
\&      qq{Couldn\*(Aqt find file "[_1]"!\en}, $filename
\&    );
\&  }
.Ve
.PP
Now, right after you've just written the above lines, you'd
normally have to go open the file 
ThisProject/I18N/en.pm, and immediately add an entry:
.PP
.Vb 2
\&  "Couldn\*(Aqt find file \e"[_1]\e"!\en"
\&  => "Couldn\*(Aqt find file \e"[_1]\e"!\en",
.Ve
.PP
But I consider that somewhat of a distraction from the work
of getting the main code working \*(-- to say nothing of the fact
that I often have to play with the program a few times before
I can decide exactly what wording I want in the messages (which
in this case would require me to go changing three lines of code:
the call to maketext with that key, and then the two lines in
ThisProject/I18N/en.pm).
.PP
However, if you set \*(L"_AUTO => 1\*(R" in the \f(CW%Lexicon\fR in,
ThisProject/I18N/en.pm (assuming that English (en) is
the language that all your programmers will be using for this
project's internal message keys), then you don't ever have to
go adding lines like this
.PP
.Vb 2
\&  "Couldn\*(Aqt find file \e"[_1]\e"!\en"
\&  => "Couldn\*(Aqt find file \e"[_1]\e"!\en",
.Ve
.PP
to ThisProject/I18N/en.pm, because if _AUTO is true there,
then just looking for an entry with the key \*(L"Couldn't find
file \e\*(R"[_1]\e\*(L"!\en\*(R" in that lexicon will cause it to be added,
with that value!
.PP
Note that the reason that keys that start with \*(L"_\*(R"
are immune to _AUTO isn't anything generally magical about
the underscore character \*(-- I just wanted a way to have most
lexicon keys be autoable, except for possibly a few, and I
arbitrarily decided to use a leading underscore as a signal
to distinguish those few.
.SH "READONLY LEXICONS"
.IX Header "READONLY LEXICONS"
If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.
.PP
For example a GDBM_File \s-1GDBM_READER\s0 tied hash will die with something like:
.PP
.Vb 1
\&   gdbm store returned \-1, errno 2, key "..." at ...
.Ve
.PP
All you need to do is turn on caching outside of the lexicon hash itself like so:
.PP
.Vb 6
\&   sub init {
\&       my ($lh) = @_;
\&       ...
\&       $lh\->{\*(Aquse_external_lex_cache\*(Aq} = 1;
\&       ...
\&   }
.Ve
.PP
And then instead of storing the compiled value in the lexicon hash it will store it in \f(CW$lh\fR\->{'_external_lex_cache'}
.SH "CONTROLLING LOOKUP FAILURE"
.IX Header "CONTROLLING LOOKUP FAILURE"
If you call \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...),
and there's no entry \fIkey\fR in \f(CW$lh\fR's class's \f(CW%Lexicon\fR, nor
in the superclass \f(CW%Lexicon\fR hash, \fIand\fR if we can't auto-make
\&\fIkey\fR (because either it starts with a \*(L"_\*(R", or because none
of its lexicons have \f(CW\*(C`_AUTO => 1,\*(C'\fR), then we have
failed to find a normal way to maketext \fIkey\fR.  What then
happens in these failure conditions, depends on the \f(CW$lh\fR object's
\&\*(L"fail\*(R" attribute.
.PP
If the language handle has no \*(L"fail\*(R" attribute, maketext
will simply throw an exception (i.e., it calls \f(CW\*(C`die\*(C'\fR, mentioning
the \fIkey\fR whose lookup failed, and naming the line number where
the calling \f(CW$lh\fR\->maketext(\fIkey\fR,...) was.
.PP
If the language handle has a \*(L"fail\*(R" attribute whose value is a
coderef, then \f(CW$lh\fR\->maketext(\fIkey\fR,...params...) gives up and calls:
.PP
.Vb 1
\&  return $that_subref\->($lh, $key, @params);
.Ve
.PP
Otherwise, the \*(L"fail\*(R" attribute's value should be a string denoting
a method name, so that \f(CW$lh\fR\->maketext(\fIkey\fR,...params...) can
give up with:
.PP
.Vb 1
\&  return $lh\->$that_method_name($phrase, @params);
.Ve
.PP
The \*(L"fail\*(R" attribute can be accessed with the \f(CW\*(C`fail_with\*(C'\fR method:
.PP
.Vb 2
\&  # Set to a coderef:
\&  $lh\->fail_with( \e&failure_handler );
\&
\&  # Set to a method name:
\&  $lh\->fail_with( \*(Aqfailure_method\*(Aq );
\&  
\&  # Set to nothing (i.e., so failure throws a plain exception)
\&  $lh\->fail_with( undef );
\&  
\&  # Get the current value
\&  $handler = $lh\->fail_with();
.Ve
.PP
Now, as to what you may want to do with these handlers:  Maybe you'd
want to log what key failed for what class, and then die.  Maybe
you don't like \f(CW\*(C`die\*(C'\fR and instead you want to send the error message
to \s-1STDOUT\s0 (or wherever) and then merely \f(CW\*(C`exit()\*(C'\fR.
.PP
Or maybe you don't want to \f(CW\*(C`die\*(C'\fR at all!  Maybe you could use a
handler like this:
.PP
.Vb 10
\&  # Make all lookups fall back onto an English value,
\&  #  but only after we log it for later fingerpointing.
\&  my $lh_backup = ThisProject\->get_handle(\*(Aqen\*(Aq);
\&  open(LEX_FAIL_LOG, ">>wherever/lex.log") || die "GNAARGH $!";
\&  sub lex_fail {
\&    my($failing_lh, $key, $params) = @_;
\&    print LEX_FAIL_LOG scalar(localtime), "\et",
\&       ref($failing_lh), "\et", $key, "\en";
\&    return $lh_backup\->maketext($key,@params);
\&  }
.Ve
.PP
Some users have expressed that they think this whole mechanism of
having a \*(L"fail\*(R" attribute at all, seems a rather pointless complication.
But I want Locale::Maketext to be usable for software projects of \fIany\fR
scale and type; and different software projects have different ideas
of what the right thing is to do in failure conditions.  I could simply
say that failure always throws an exception, and that if you want to be
careful, you'll just have to wrap every call to \f(CW$lh\fR\->maketext in an
eval\ {\ }.  However, I want programmers to reserve the right (via
the \*(L"fail\*(R" attribute) to treat lookup failure as something other than
an exception of the same level of severity as a config file being
unreadable, or some essential resource being inaccessible.
.PP
One possibly useful value for the \*(L"fail\*(R" attribute is the method name
\&\*(L"failure_handler_auto\*(R".  This is a method defined in the class
Locale::Maketext itself.  You set it with:
.PP
.Vb 1
\&  $lh\->fail_with(\*(Aqfailure_handler_auto\*(Aq);
.Ve
.PP
Then when you call \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...) and
there's no \fIkey\fR in any of those lexicons, maketext gives up with
.PP
.Vb 1
\&  return $lh\->failure_handler_auto($key, @params);
.Ve
.PP
But failure_handler_auto, instead of dying or anything, compiles
\&\f(CW$key\fR, caching it in
.PP
.Vb 1
\&    $lh\->{\*(Aqfailure_lex\*(Aq}{$key} = $complied
.Ve
.PP
and then calls the compiled value, and returns that.  (I.e., if
\&\f(CW$key\fR looks like bracket notation, \f(CW$compiled\fR is a sub, and we return
&{$compiled}(@params); but if \f(CW$key\fR is just a plain string, we just
return that.)
.PP
The effect of using \*(L"failure_auto_handler\*(R"
is like an \s-1AUTO\s0 lexicon, except that it 1) compiles \f(CW$key\fR even if
it starts with \*(L"_\*(R", and 2) you have a record in the new hashref
\&\f(CW$lh\fR\->{'failure_lex'} of all the keys that have failed for
this object.  This should avoid your program dying \*(-- as long
as your keys aren't actually invalid as bracket code, and as
long as they don't try calling methods that don't exist.
.PP
\&\*(L"failure_auto_handler\*(R" may not be exactly what you want, but I
hope it at least shows you that maketext failure can be mitigated
in any number of very flexible ways.  If you can formalize exactly
what you want, you should be able to express that as a failure
handler.  You can even make it default for every object of a given
class, by setting it in that class's init:
.PP
.Vb 9
\&  sub init {
\&    my $lh = $_[0];  # a newborn handle
\&    $lh\->SUPER::init();
\&    $lh\->fail_with(\*(Aqmy_clever_failure_handler\*(Aq);
\&    return;
\&  }
\&  sub my_clever_failure_handler {
\&    ...you clever things here...
\&  }
.Ve
.SH "HOW TO USE MAKETEXT"
.IX Header "HOW TO USE MAKETEXT"
Here is a brief checklist on how to use Maketext to localize
applications:
.IP "\(bu" 4
Decide what system you'll use for lexicon keys.  If you insist,
you can use opaque IDs (if you're nostalgic for \f(CW\*(C`catgets\*(C'\fR),
but I have better suggestions in the
section \*(L"Entries in Each Lexicon\*(R", above.  Assuming you opt for
meaningful keys that double as values (like \*(L"Minimum ([_1]) is
larger than maximum ([_2])!\en\*(R"), you'll have to settle on what
language those should be in.  For the sake of argument, I'll
call this English, specifically American English, \*(L"en-US\*(R".
.IP "\(bu" 4
Create a class for your localization project.  This is
the name of the class that you'll use in the idiom:
.Sp
.Vb 2
\&  use Projname::L10N;
\&  my $lh = Projname::L10N\->get_handle(...) || die "Language?";
.Ve
.Sp
Assuming you call your class Projname::L10N, create a class
consisting minimally of:
.Sp
.Vb 3
\&  package Projname::L10N;
\&  use base qw(Locale::Maketext);
\&  ...any methods you might want all your languages to share...
\&  
\&  # And, assuming you want the base class to be an _AUTO lexicon,
\&  # as is discussed a few sections up:
\&  
\&  1;
.Ve
.IP "\(bu" 4
Create a class for the language your internal keys are in.  Name
the class after the language-tag for that language, in lowercase,
with dashes changed to underscores.  Assuming your project's first
language is \s-1US\s0 English, you should call this Projname::L10N::en_us.
It should consist minimally of:
.Sp
.Vb 6
\&  package Projname::L10N::en_us;
\&  use base qw(Projname::L10N);
\&  %Lexicon = (
\&    \*(Aq_AUTO\*(Aq => 1,
\&  );
\&  1;
.Ve
.Sp
(For the rest of this section, I'll assume that this \*(L"first
language class\*(R" of Projname::L10N::en_us has
_AUTO lexicon.)
.IP "\(bu" 4
Go and write your program.  Everywhere in your program where 
you would say:
.Sp
.Vb 1
\&  print "Foobar $thing stuff\en";
.Ve
.Sp
instead do it thru maketext, using no variable interpolation in
the key:
.Sp
.Vb 1
\&  print $lh\->maketext("Foobar [_1] stuff\en", $thing);
.Ve
.Sp
If you get tired of constantly saying \f(CW\*(C`print $lh\->maketext\*(C'\fR,
consider making a functional wrapper for it, like so:
.Sp
.Vb 7
\&  use Projname::L10N;
\&  use vars qw($lh);
\&  $lh = Projname::L10N\->get_handle(...) || die "Language?";
\&  sub pmt (@) { print( $lh\->maketext(@_)) }
\&   # "pmt" is short for "Print MakeText"
\&  $Carp::Verbose = 1;
\&   # so if maketext fails, we see made the call to pmt
.Ve
.Sp
Besides whole phrases meant for output, anything language-dependent
should be put into the class Projname::L10N::en_us,
whether as methods, or as lexicon entries \*(-- this is discussed
in the section \*(L"Entries in Each Lexicon\*(R", above.
.IP "\(bu" 4
Once the program is otherwise done, and once its localization for
the first language works right (via the data and methods in
Projname::L10N::en_us), you can get together the data for translation.
If your first language lexicon isn't an _AUTO lexicon, then you already
have all the messages explicitly in the lexicon (or else you'd be
getting exceptions thrown when you call \f(CW$lh\fR\->maketext to get
messages that aren't in there).  But if you were (advisedly) lazy and are
using an _AUTO lexicon, then you've got to make a list of all the phrases
that you've so far been letting _AUTO generate for you.  There are very
many ways to assemble such a list.  The most straightforward is to simply
grep the source for every occurrence of \*(L"maketext\*(R" (or calls
to wrappers around it, like the above \f(CW\*(C`pmt\*(C'\fR function), and to log the
following phrase.
.IP "\(bu" 4
You may at this point want to consider whether your base class 
(Projname::L10N), from which all lexicons inherit from (Projname::L10N::en,
Projname::L10N::es, etc.), should be an _AUTO lexicon.  It may be true
that in theory, all needed messages will be in each language class;
but in the presumably unlikely or \*(L"impossible\*(R" case of lookup failure,
you should consider whether your program should throw an exception,
emit text in English (or whatever your project's first language is),
or some more complex solution as described in the section
\&\*(L"Controlling Lookup Failure\*(R", above.
.IP "\(bu" 4
Submit all messages/phrases/etc. to translators.
.Sp
(You may, in fact, want to start with localizing to \fIone\fR other language
at first, if you're not sure that you've properly abstracted the
language-dependent parts of your code.)
.Sp
Translators may request clarification of the situation in which a
particular phrase is found.  For example, in English we are entirely happy
saying "\fIn\fR files found\*(L", regardless of whether we mean \*(R"I looked for files,
and found \fIn\fR of them\*(L" or the rather distinct situation of \*(R"I looked for
something else (like lines in files), and along the way I saw \fIn\fR
files.\*(L"  This may involve rethinking things that you thought quite clear:
should \*(R"Edit\*(L" on a toolbar be a noun (\*(R"editing\*(L") or a verb (\*(R"to edit\*(L")?  Is
there already a conventionalized way to express that menu option, separate
from the target language's normal word for \*(R"to edit"?
.Sp
In all cases where the very common phenomenon of quantification
(saying "\fIN\fR files", for \fBany\fR value of N)
is involved, each translator should make clear what dependencies the
number causes in the sentence.  In many cases, dependency is
limited to words adjacent to the number, in places where you might
expect them ("I found the\-?PLURAL \fIN\fR
empty\-?PLURAL directory\-?PLURAL\*(L"), but in some cases there are
unexpected dependencies (\*(R"I found\-?PLURAL ...\*(L"!) as well as long-distance
dependencies \*(R"The \fIN\fR directory\-?PLURAL could not be deleted\-?PLURAL"!).
.Sp
Remind the translators to consider the case where N is 0:
\&\*(L"0 files found\*(R" isn't exactly natural-sounding in any language, but it
may be unacceptable in many \*(-- or it may condition special
kinds of agreement (similar to English \*(L"I didN'T find \s-1ANY\s0 files\*(R").
.Sp
Remember to ask your translators about numeral formatting in their
language, so that you can override the \f(CW\*(C`numf\*(C'\fR method as
appropriate.  Typical variables in number formatting are:  what to
use as a decimal point (comma? period?); what to use as a thousands
separator (space? nonbreaking space? comma? period? small
middot? prime? apostrophe?); and even whether the so-called \*(L"thousands
separator\*(R" is actually for every third digit \*(-- I've heard reports of
two hundred thousand being expressible as \*(L"2,00,000\*(R" for some Indian
(Subcontinental) languages, besides the less surprising \*(L"200\ 000\*(R",
\&\*(L"200.000\*(R", \*(L"200,000\*(R", and \*(L"200'000\*(R".  Also, using a set of numeral
glyphs other than the usual \s-1ASCII\s0 \*(L"0\*(R"\-\*(L"9\*(R" might be appreciated, as via
\&\f(CW\*(C`tr/0\-9/\ex{0966}\-\ex{096F}/\*(C'\fR for getting digits in Devanagari script
(for Hindi, Konkani, others).
.Sp
The basic \f(CW\*(C`quant\*(C'\fR method that Locale::Maketext provides should be
good for many languages.  For some languages, it might be useful
to modify it (or its constituent \f(CW\*(C`numerate\*(C'\fR method)
to take a plural form in the two-argument call to \f(CW\*(C`quant\*(C'\fR
(as in \*(L"[quant,_1,files]\*(R") if
it's all-around easier to infer the singular form from the plural, than
to infer the plural form from the singular.
.Sp
But for other languages (as is discussed at length
in Locale::Maketext::TPJ13), simple
\&\f(CW\*(C`quant\*(C'\fR/\f(CW\*(C`numf\*(C'\fR is not enough.  For the particularly problematic
Slavic languages, what you may need is a method which you provide
with the number, the citation form of the noun to quantify, and
the case and gender that the sentence's syntax projects onto that
noun slot.  The method would then be responsible for determining
what grammatical number that numeral projects onto its noun phrase,
and what case and gender it may override the normal case and gender
with; and then it would look up the noun in a lexicon providing
all needed inflected forms.
.IP "\(bu" 4
You may also wish to discuss with the translators the question of
how to relate different subforms of the same language tag,
considering how this reacts with \f(CW\*(C`get_handle\*(C'\fR's treatment of
these.  For example, if a user accepts interfaces in \*(L"en, fr\*(R", and
you have interfaces available in \*(L"en-US\*(R" and \*(L"fr\*(R", what should
they get?  You may wish to resolve this by establishing that \*(L"en\*(R"
and \*(L"en-US\*(R" are effectively synonymous, by having one class
zero-derive from the other.
.Sp
For some languages this issue may never come up (Danish is rarely
expressed as \*(L"da-DK\*(R", but instead is just \*(L"da\*(R").  And for other
languages, the whole concept of a \*(L"generic\*(R" form may verge on
being uselessly vague, particularly for interfaces involving voice
media in forms of Arabic or Chinese.
.IP "\(bu" 4
Once you've localized your program/site/etc. for all desired
languages, be sure to show the result (whether live, or via
screenshots) to the translators.  Once they approve, make every
effort to have it then checked by at least one other speaker of
that language.  This holds true even when (or especially when) the
translation is done by one of your own programmers.  Some
kinds of systems may be harder to find testers for than others,
depending on the amount of domain-specific jargon and concepts
involved \*(-- it's easier to find people who can tell you whether
they approve of your translation for \*(L"delete this message\*(R" in an
email-via-Web interface, than to find people who can give you
an informed opinion on your translation for \*(L"attribute value\*(R"
in an \s-1XML\s0 query tool's interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I recommend reading all of these:
.PP
Locale::Maketext::TPJ13 \*(-- my \fIThe Perl
Journal\fR article about Maketext.  It explains many important concepts
underlying Locale::Maketext's design, and some insight into why
Maketext is better than the plain old approach of having 
message catalogs that are just databases of sprintf formats.
.PP
File::Findgrep is a sample application/module
that uses Locale::Maketext to localize its messages.  For a larger
internationalized system, see also Apache::MP3.
.PP
I18N::LangTags.
.PP
Win32::Locale.
.PP
\&\s-1RFC\s0 3066, \fITags for the Identification of Languages\fR,
as at http://sunsite.dk/RFC/rfc/rfc3066.html
.PP
\&\s-1RFC\s0 2277, \fI\s-1IETF\s0 Policy on Character Sets and Languages\fR
is at http://sunsite.dk/RFC/rfc/rfc2277.html \*(-- much of it is
just things of interest to protocol designers, but it explains
some basic concepts, like the distinction between locales and
language-tags.
.PP
The manual for \s-1GNU\s0 \f(CW\*(C`gettext\*(C'\fR.  The gettext dist is available in
\&\f(CW\*(C`ftp://prep.ai.mit.edu/pub/gnu/\*(C'\fR \*(-- get
a recent gettext tarball and look in its \*(L"doc/\*(R" directory, there's
an easily browsable \s-1HTML\s0 version in there.  The
gettext documentation asks lots of questions worth thinking
about, even if some of their answers are sometimes wonky,
particularly where they start talking about pluralization.
.PP
The Locale/Maketext.pm source.  Obverse that the module is much
shorter than its documentation!
.SH "COPYRIGHT AND DISCLAIMER"
.IX Header "COPYRIGHT AND DISCLAIMER"
Copyright (c) 1999\-2004 Sean M. Burke.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext5.18.3pm                     0100644 0001750 0001750 00000165604 12566207460 024717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext 3pm"
.TH Locale::Maketext 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext \- framework for localization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  package MyProgram;
\&  use strict;
\&  use MyProgram::L10N;
\&   # ...which inherits from Locale::Maketext
\&  my $lh = MyProgram::L10N\->get_handle() || die "What language?";
\&  ...
\&  # And then any messages your program emits, like:
\&  warn $lh\->maketext( "Can\*(Aqt open file [_1]: [_2]\en", $f, $! );
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It is a common feature of applications (whether run directly,
or via the Web) for them to be \*(L"localized\*(R" \*(-- i.e., for them
to a present an English interface to an English-speaker, a German
interface to a German-speaker, and so on for all languages it's
programmed with.  Locale::Maketext
is a framework for software localization; it provides you with the
tools for organizing and accessing the bits of text and text-processing
code that you need for producing localized applications.
.PP
In order to make sense of Maketext and how all its
components fit together, you should probably
go read Locale::Maketext::TPJ13, and
\&\fIthen\fR read the following documentation.
.PP
You may also want to read over the source for \f(CW\*(C`File::Findgrep\*(C'\fR
and its constituent modules \*(-- they are a complete (if small)
example application that uses Maketext.
.SH "QUICK OVERVIEW"
.IX Header "QUICK OVERVIEW"
The basic design of Locale::Maketext is object-oriented, and
Locale::Maketext is an abstract base class, from which you
derive a \*(L"project class\*(R".
The project class (with a name like \*(L"TkBocciBall::Localize\*(R",
which you then use in your module) is in turn the base class
for all the \*(L"language classes\*(R" for your project
(with names \*(L"TkBocciBall::Localize::it\*(R", 
\&\*(L"TkBocciBall::Localize::en\*(R",
\&\*(L"TkBocciBall::Localize::fr\*(R", etc.).
.PP
A language class is
a class containing a lexicon of phrases as class data,
and possibly also some methods that are of use in interpreting
phrases in the lexicon, or otherwise dealing with text in that
language.
.PP
An object belonging to a language class is called a \*(L"language
handle\*(R"; it's typically a flyweight object.
.PP
The normal course of action is to call:
.PP
.Vb 6
\&  use TkBocciBall::Localize;  # the localization project class
\&  $lh = TkBocciBall::Localize\->get_handle();
\&   # Depending on the user\*(Aqs locale, etc., this will
\&   # make a language handle from among the classes available,
\&   # and any defaults that you declare.
\&  die "Couldn\*(Aqt make a language handle??" unless $lh;
.Ve
.PP
From then on, you use the \f(CW\*(C`maketext\*(C'\fR function to access
entries in whatever lexicon(s) belong to the language handle
you got.  So, this:
.PP
.Vb 1
\&  print $lh\->maketext("You won!"), "\en";
.Ve
.PP
\&...emits the right text for this language.  If the object
in \f(CW$lh\fR belongs to class \*(L"TkBocciBall::Localize::fr\*(R" and
\&\f(CW%TkBocciBall::Localize::fr::Lexicon\fR contains \f(CW\*(C`("You won!"
=> "Tu as gagne\*'!")\*(C'\fR, then the above
code happily tells the user \*(L"Tu as gagne\*'!\*(R".
.SH "METHODS"
.IX Header "METHODS"
Locale::Maketext offers a variety of methods, which fall
into three categories:
.IP "\(bu" 4
Methods to do with constructing language handles.
.IP "\(bu" 4
\&\f(CW\*(C`maketext\*(C'\fR and other methods to do with accessing \f(CW%Lexicon\fR data
for a given language handle.
.IP "\(bu" 4
Methods that you may find it handy to use, from routines of
yours that you put in \f(CW%Lexicon\fR entries.
.PP
These are covered in the following section.
.SS "Construction Methods"
.IX Subsection "Construction Methods"
These are to do with constructing a language handle:
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass\->get_handle( ...langtags... ) || die \*(L"lg-handle?\*(R";
.Sp
This tries loading classes based on the language-tags you give (like
\&\f(CW\*(C`("en\-US", "sk", "kon", "es\-MX", "ja", "i\-klingon")\*(C'\fR, and for the first class
that succeeds, returns YourProjClass::\fIlanguage\fR\->\fInew()\fR.
.Sp
If it runs thru the entire given list of language-tags, and finds no classes
for those exact terms, it then tries \*(L"superordinate\*(R" language classes.
So if no \*(L"en-US\*(R" class (i.e., YourProjClass::en_us)
was found, nor classes for anything else in that list, we then try
its superordinate, \*(L"en\*(R" (i.e., YourProjClass::en), and so on thru 
the other language-tags in the given list: \*(L"es\*(R".
(The other language-tags in our example list: 
happen to have no superordinates.)
.Sp
If none of those language-tags leads to loadable classes, we then
try classes derived from YourProjClass\->\fIfallback_languages()\fR and
then if nothing comes of that, we use classes named by
YourProjClass\->\fIfallback_language_classes()\fR.  Then in the (probably
quite unlikely) event that that fails, we just return undef.
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass\->get_handle\fB()\fR || die \*(L"lg-handle?\*(R";
.Sp
When \f(CW\*(C`get_handle\*(C'\fR is called with an empty parameter list, magic happens:
.Sp
If \f(CW\*(C`get_handle\*(C'\fR senses that it's running in program that was
invoked as a \s-1CGI,\s0 then it tries to get language-tags out of the
environment variable \*(L"\s-1HTTP_ACCEPT_LANGUAGE\*(R",\s0 and it pretends that
those were the languages passed as parameters to \f(CW\*(C`get_handle\*(C'\fR.
.Sp
Otherwise (i.e., if not a \s-1CGI\s0), this tries various OS-specific ways
to get the language-tags for the current locale/language, and then
pretends that those were the value(s) passed to \f(CW\*(C`get_handle\*(C'\fR.
.Sp
Currently this OS-specific stuff consists of looking in the environment
variables \*(L"\s-1LANG\*(R"\s0 and \*(L"\s-1LANGUAGE\*(R"\s0; and on MSWin machines (where those
variables are typically unused), this also tries using
the module Win32::Locale to get a language-tag for whatever language/locale
is currently selected in the \*(L"Regional Settings\*(R" (or \*(L"International\*(R"?)
Control Panel.  I welcome further
suggestions for making this do the Right Thing under other operating
systems that support localization.
.Sp
If you're using localization in an application that keeps a configuration
file, you might consider something like this in your project class:
.Sp
.Vb 10
\&  sub get_handle_via_config {
\&    my $class = $_[0];
\&    my $chosen_language = $Config_settings{\*(Aqlanguage\*(Aq};
\&    my $lh;
\&    if($chosen_language) {
\&      $lh = $class\->get_handle($chosen_language)
\&       || die "No language handle for \e"$chosen_language\e""
\&            . " or the like";
\&    } else {
\&      # Config file missing, maybe?
\&      $lh = $class\->get_handle()
\&       || die "Can\*(Aqt get a language handle";
\&    }
\&    return $lh;
\&  }
.Ve
.IP "\(bu" 4
\&\f(CW$lh\fR = YourProjClass::langname\->\fInew()\fR;
.Sp
This constructs a language handle.  You usually \fBdon't\fR call this
directly, but instead let \f(CW\*(C`get_handle\*(C'\fR find a language class to \f(CW\*(C`use\*(C'\fR
and to then call \->new on.
.IP "\(bu" 4
\&\f(CW$lh\fR\->\fIinit()\fR;
.Sp
This is called by \->new to initialize newly-constructed language handles.
If you define an init method in your class, remember that it's usually
considered a good idea to call \f(CW$lh\fR\->SUPER::init in it (presumably at the
beginning), so that all classes get a chance to initialize a new object
however they see fit.
.IP "\(bu" 4
YourProjClass\->\fIfallback_languages()\fR
.Sp
\&\f(CW\*(C`get_handle\*(C'\fR appends the return value of this to the end of
whatever list of languages you pass \f(CW\*(C`get_handle\*(C'\fR.  Unless
you override this method, your project class
will inherit Locale::Maketext's \f(CW\*(C`fallback_languages\*(C'\fR, which
currently returns \f(CW\*(C`(\*(Aqi\-default\*(Aq, \*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)\*(C'\fR.
(\*(L"i\-default\*(R" is defined in \s-1RFC 2277\s0).
.Sp
This method (by having it return the name
of a language-tag that has an existing language class)
can be used for making sure that
\&\f(CW\*(C`get_handle\*(C'\fR will always manage to construct a language
handle (assuming your language classes are in an appropriate
\&\f(CW@INC\fR directory).  Or you can use the next method:
.IP "\(bu" 4
YourProjClass\->\fIfallback_language_classes()\fR
.Sp
\&\f(CW\*(C`get_handle\*(C'\fR appends the return value of this to the end
of the list of classes it will try using.  Unless
you override this method, your project class
will inherit Locale::Maketext's \f(CW\*(C`fallback_language_classes\*(C'\fR,
which currently returns an empty list, \f(CW\*(C`()\*(C'\fR.
By setting this to some value (namely, the name of a loadable
language class), you can be sure that
\&\f(CW\*(C`get_handle\*(C'\fR will always manage to construct a language
handle.
.ie n .SS "The ""maketext"" Method"
.el .SS "The ``maketext'' Method"
.IX Subsection "The maketext Method"
This is the most important method in Locale::Maketext:
.PP
.Vb 1
\&    $text = $lh\->maketext(I<key>, ...parameters for this phrase...);
.Ve
.PP
This looks in the \f(CW%Lexicon\fR of the language handle
\&\f(CW$lh\fR and all its superclasses, looking
for an entry whose key is the string \fIkey\fR.  Assuming such
an entry is found, various things then happen, depending on the
value found:
.PP
If the value is a scalarref, the scalar is dereferenced and returned
(and any parameters are ignored).
.PP
If the value is a coderef, we return &$value($lh, ...parameters...).
.PP
If the value is a string that \fIdoesn't\fR look like it's in Bracket Notation,
we return it (after replacing it with a scalarref, in its \f(CW%Lexicon\fR).
.PP
If the value \fIdoes\fR look like it's in Bracket Notation, then we compile
it into a sub, replace the string in the \f(CW%Lexicon\fR with the new coderef,
and then we return &$new_sub($lh, ...parameters...).
.PP
Bracket Notation is discussed in a later section.  Note
that trying to compile a string into Bracket Notation can throw
an exception if the string is not syntactically valid (say, by not
balancing brackets right.)
.PP
Also, calling &$coderef($lh, ...parameters...) can throw any sort of
exception (if, say, code in that sub tries to divide by zero).  But
a very common exception occurs when you have Bracket
Notation text that says to call a method \*(L"foo\*(R", but there is no such
method.  (E.g., "You have [qua\fBtn\fR,_1,ball]." will throw an exception
on trying to call \f(CW$lh\fR\->qua\fBtn\fR($_[1],'ball') \*(-- you presumably meant
\&\*(L"quant\*(R".)  \f(CW\*(C`maketext\*(C'\fR catches these exceptions, but only to make the
error message more readable, at which point it rethrows the exception.
.PP
An exception \fImay\fR be thrown if \fIkey\fR is not found in any
of \f(CW$lh\fR's \f(CW%Lexicon\fR hashes.  What happens if a key is not found,
is discussed in a later section, \*(L"Controlling Lookup Failure\*(R".
.PP
Note that you might find it useful in some cases to override
the \f(CW\*(C`maketext\*(C'\fR method with an \*(L"after method\*(R", if you want to
translate encodings, or even scripts:
.PP
.Vb 7
\&    package YrProj::zh_cn; # Chinese with PRC\-style glyphs
\&    use base (\*(AqYrProj::zh_tw\*(Aq);  # Taiwan\-style
\&    sub maketext {
\&      my $self = shift(@_);
\&      my $value = $self\->maketext(@_);
\&      return Chineeze::taiwan2mainland($value);
\&    }
.Ve
.PP
Or you may want to override it with something that traps
any exceptions, if that's critical to your program:
.PP
.Vb 7
\&  sub maketext {
\&    my($lh, @stuff) = @_;
\&    my $out;
\&    eval { $out = $lh\->SUPER::maketext(@stuff) };
\&    return $out unless $@;
\&    ...otherwise deal with the exception...
\&  }
.Ve
.PP
Other than those two situations, I don't imagine that
it's useful to override the \f(CW\*(C`maketext\*(C'\fR method.  (If
you run into a situation where it is useful, I'd be
interested in hearing about it.)
.ie n .IP "$lh\->fail_with \fIor\fR $lh\->fail_with(\fI\s-1PARAM\s0\fR)" 4
.el .IP "\f(CW$lh\fR\->fail_with \fIor\fR \f(CW$lh\fR\->fail_with(\fI\s-1PARAM\s0\fR)" 4
.IX Item "$lh->fail_with or $lh->fail_with(PARAM)"
.PD 0
.ie n .IP "$lh\->failure_handler_auto" 4
.el .IP "\f(CW$lh\fR\->failure_handler_auto" 4
.IX Item "$lh->failure_handler_auto"
.PD
These two methods are discussed in the section \*(L"Controlling
Lookup Failure\*(R".
.SS "Utility Methods"
.IX Subsection "Utility Methods"
These are methods that you may find it handy to use, generally
from \f(CW%Lexicon\fR routines of yours (whether expressed as
Bracket Notation or not).
.ie n .IP "$language\->quant($number, $singular)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR)" 4
.IX Item "$language->quant($number, $singular)"
.PD 0
.ie n .IP "$language\->quant($number, $singular, $plural)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR, \f(CW$plural\fR)" 4
.IX Item "$language->quant($number, $singular, $plural)"
.ie n .IP "$language\->quant($number, $singular, $plural, $negative)" 4
.el .IP "\f(CW$language\fR\->quant($number, \f(CW$singular\fR, \f(CW$plural\fR, \f(CW$negative\fR)" 4
.IX Item "$language->quant($number, $singular, $plural, $negative)"
.PD
This is generally meant to be called from inside Bracket Notation
(which is discussed later), as in
.Sp
.Vb 1
\&     "Your search matched [quant,_1,document]!"
.Ve
.Sp
It's for \fIquantifying\fR a noun (i.e., saying how much of it there is,
while giving the correct form of it).  The behavior of this method is
handy for English and a few other Western European languages, and you
should override it for languages where it's not suitable.  You can feel
free to read the source, but the current implementation is basically
as this pseudocode describes:
.Sp
.Vb 11
\&     if $number is 0 and there\*(Aqs a $negative,
\&        return $negative;
\&     elsif $number is 1,
\&        return "1 $singular";
\&     elsif there\*(Aqs a $plural,
\&        return "$number $plural";
\&     else
\&        return "$number " . $singular . "s";
\&     #
\&     # ...except that we actually call numf to
\&     #  stringify $number before returning it.
.Ve
.Sp
So for English (with Bracket Notation)
\&\f(CW"...[quant,_1,file]..."\fR is fine (for 0 it returns \*(L"0 files\*(R",
for 1 it returns \*(L"1 file\*(R", and for more it returns \*(L"2 files\*(R", etc.)
.Sp
But for \*(L"directory\*(R", you'd want \f(CW"[quant,_1,directory,directories]"\fR
so that our elementary \f(CW\*(C`quant\*(C'\fR method doesn't think that the
plural of \*(L"directory\*(R" is \*(L"directorys\*(R".  And you might find that the
output may sound better if you specify a negative form, as in:
.Sp
.Vb 1
\&     "[quant,_1,file,files,No files] matched your query.\en"
.Ve
.Sp
Remember to keep in mind verb agreement (or adjectives too, in
other languages), as in:
.Sp
.Vb 1
\&     "[quant,_1,document] were matched.\en"
.Ve
.Sp
Because if _1 is one, you get "1 document \fBwere\fR matched".
An acceptable hack here is to do something like this:
.Sp
.Vb 1
\&     "[quant,_1,document was, documents were] matched.\en"
.Ve
.ie n .IP "$language\->numf($number)" 4
.el .IP "\f(CW$language\fR\->numf($number)" 4
.IX Item "$language->numf($number)"
This returns the given number formatted nicely according to
this language's conventions.  Maketext's default method is
mostly to just take the normal string form of the number
(applying sprintf \*(L"%G\*(R" for only very large numbers), and then
to add commas as necessary.  (Except that
we apply \f(CW\*(C`tr/,./.,/\*(C'\fR if \f(CW$language\fR\->{'numf_comma'} is true;
that's a bit of a hack that's useful for languages that express
two million as \*(L"2.000.000\*(R" and not as \*(L"2,000,000\*(R").
.Sp
If you want anything fancier, consider overriding this with something
that uses Number::Format, or does something else
entirely.
.Sp
Note that numf is called by quant for stringifying all quantifying
numbers.
.ie n .IP "$language\->numerate($number, $singular, $plural, $negative)" 4
.el .IP "\f(CW$language\fR\->numerate($number, \f(CW$singular\fR, \f(CW$plural\fR, \f(CW$negative\fR)" 4
.IX Item "$language->numerate($number, $singular, $plural, $negative)"
This returns the given noun form which is appropriate for the quantity
\&\f(CW$number\fR according to this language's conventions.  \f(CW\*(C`numerate\*(C'\fR is
used internally by \f(CW\*(C`quant\*(C'\fR to quantify nouns.  Use it directly \*(--
usually from bracket notation \*(-- to avoid \f(CW\*(C`quant\*(C'\fR's implicit call to
\&\f(CW\*(C`numf\*(C'\fR and output of a numeric quantity.
.ie n .IP "$language\->sprintf($format, @items)" 4
.el .IP "\f(CW$language\fR\->sprintf($format, \f(CW@items\fR)" 4
.IX Item "$language->sprintf($format, @items)"
This is just a wrapper around Perl's normal \f(CW\*(C`sprintf\*(C'\fR function.
It's provided so that you can use \*(L"sprintf\*(R" in Bracket Notation:
.Sp
.Vb 1
\&     "Couldn\*(Aqt access datanode [sprintf,%10x=~[%s~],_1,_2]!\en"
.Ve
.Sp
returning...
.Sp
.Vb 1
\&     Couldn\*(Aqt access datanode      Stuff=[thangamabob]!
.Ve
.ie n .IP "$language\->\fIlanguage_tag()\fR" 4
.el .IP "\f(CW$language\fR\->\fIlanguage_tag()\fR" 4
.IX Item "$language->language_tag()"
Currently this just takes the last bit of \f(CW\*(C`ref($language)\*(C'\fR, turns
underscores to dashes, and returns it.  So if \f(CW$language\fR is
an object of class Hee::HOO::Haw::en_us, \f(CW$language\fR\->\fIlanguage_tag()\fR
returns \*(L"en-us\*(R".  (Yes, the usual representation for that language
tag is \*(L"en-US\*(R", but case is \fInever\fR considered meaningful in
language-tag comparison.)
.Sp
You may override this as you like; Maketext doesn't use it for
anything.
.ie n .IP "$language\->\fIencoding()\fR" 4
.el .IP "\f(CW$language\fR\->\fIencoding()\fR" 4
.IX Item "$language->encoding()"
Currently this isn't used for anything, but it's provided
(with default value of
\&\f(CW\*(C`(ref($language) && $language\->{\*(Aqencoding\*(Aq})) or "iso\-8859\-1"\*(C'\fR
) as a sort of suggestion that it may be useful/necessary to
associate encodings with your language handles (whether on a
per-class or even per-handle basis.)
.SS "Language Handle Attributes and Internals"
.IX Subsection "Language Handle Attributes and Internals"
A language handle is a flyweight object \*(-- i.e., it doesn't (necessarily)
carry any data of interest, other than just being a member of
whatever class it belongs to.
.PP
A language handle is implemented as a blessed hash.  Subclasses of yours
can store whatever data you want in the hash.  Currently the only hash
entry used by any crucial Maketext method is \*(L"fail\*(R", so feel free to
use anything else as you like.
.PP
\&\fBRemember: Don't be afraid to read the Maketext source if there's
any point on which this documentation is unclear.\fR  This documentation
is vastly longer than the module source itself.
.SH "LANGUAGE CLASS HIERARCHIES"
.IX Header "LANGUAGE CLASS HIERARCHIES"
These are Locale::Maketext's assumptions about the class
hierarchy formed by all your language classes:
.IP "\(bu" 4
You must have a project base class, which you load, and
which you then use as the first argument in
the call to YourProjClass\->get_handle(...).  It should derive
(whether directly or indirectly) from Locale::Maketext.
It \fBdoesn't matter\fR how you name this class, although assuming this
is the localization component of your Super Mega Program,
good names for your project class might be
SuperMegaProgram::Localization, SuperMegaProgram::L10N,
SuperMegaProgram::I18N, SuperMegaProgram::International,
or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.
.IP "\(bu" 4
Language classes are what YourProjClass\->get_handle will try to load.
It will look for them by taking each language-tag (\fBskipping\fR it
if it doesn't look like a language-tag or locale-tag!), turning it to
all lowercase, turning dashes to underscores, and appending it
to YourProjClass . \*(L"::\*(R".  So this:
.Sp
.Vb 3
\&  $lh = YourProjClass\->get_handle(
\&    \*(Aqen\-US\*(Aq, \*(Aqfr\*(Aq, \*(Aqkon\*(Aq, \*(Aqi\-klingon\*(Aq, \*(Aqi\-klingon\-romanized\*(Aq
\&  );
.Ve
.Sp
will try loading the classes 
YourProjClass::en_us (note lowercase!), YourProjClass::fr, 
YourProjClass::kon,
YourProjClass::i_klingon
and YourProjClass::i_klingon_romanized.  (And it'll stop at the
first one that actually loads.)
.IP "\(bu" 4
I assume that each language class derives (directly or indirectly)
from your project class, and also defines its \f(CW@ISA\fR, its \f(CW%Lexicon\fR,
or both.  But I anticipate no dire consequences if these assumptions
do not hold.
.IP "\(bu" 4
Language classes may derive from other language classes (although they
should have "use \fIThatclassname\fR\*(L" or \*(R"use base qw(\fI...classes...\fR)").
They may derive from the project
class.  They may derive from some other class altogether.  Or via
multiple inheritance, it may derive from any mixture of these.
.IP "\(bu" 4
I foresee no problems with having multiple inheritance in
your hierarchy of language classes.  (As usual, however, Perl will
complain bitterly if you have a cycle in the hierarchy: i.e., if
any class is its own ancestor.)
.SH "ENTRIES IN EACH LEXICON"
.IX Header "ENTRIES IN EACH LEXICON"
A typical \f(CW%Lexicon\fR entry is meant to signify a phrase,
taking some number (0 or more) of parameters.  An entry
is meant to be accessed by via
a string \fIkey\fR in \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...),
which should return a string that is generally meant for
be used for \*(L"output\*(R" to the user \*(-- regardless of whether
this actually means printing to \s-1STDOUT,\s0 writing to a file,
or putting into a \s-1GUI\s0 widget.
.PP
While the key must be a string value (since that's a basic
restriction that Perl places on hash keys), the value in
the lexicon can currently be of several types:
a defined scalar, scalarref, or coderef.  The use of these is
explained above, in the section 'The \*(L"maketext\*(R" Method', and
Bracket Notation for strings is discussed in the next section.
.PP
While you can use arbitrary unique IDs for lexicon keys
(like \*(L"_min_larger_max_error\*(R"), it is often
useful for if an entry's key is itself a valid value, like
this example error message:
.PP
.Vb 1
\&  "Minimum ([_1]) is larger than maximum ([_2])!\en",
.Ve
.PP
Compare this code that uses an arbitrary \s-1ID...\s0
.PP
.Vb 2
\&  die $lh\->maketext( "_min_larger_max_error", $min, $max )
\&   if $min > $max;
.Ve
.PP
\&...to this code that uses a key-as-value:
.PP
.Vb 4
\&  die $lh\->maketext(
\&   "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&   $min, $max
\&  ) if $min > $max;
.Ve
.PP
The second is, in short, more readable.  In particular, it's obvious
that the number of parameters you're feeding to that phrase (two) is
the number of parameters that it \fIwants\fR to be fed.  (Since you see
_1 and a _2 being used in the key there.)
.PP
Also, once a project is otherwise
complete and you start to localize it, you can scrape together
all the various keys you use, and pass it to a translator; and then
the translator's work will go faster if what he's presented is this:
.PP
.Vb 2
\& "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&  => "",   # fill in something here, Jacques!
.Ve
.PP
rather than this more cryptic mess:
.PP
.Vb 2
\& "_min_larger_max_error"
\&  => "",   # fill in something here, Jacques
.Ve
.PP
I think that keys as lexicon values makes the completed lexicon
entries more readable:
.PP
.Vb 2
\& "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&  => "Le minimum ([_1]) est plus grand que le maximum ([_2])!\en",
.Ve
.PP
Also, having valid values as keys becomes very useful if you set
up an _AUTO lexicon.  _AUTO lexicons are discussed in a later
section.
.PP
I almost always use keys that are themselves
valid lexicon values.  One notable exception is when the value is
quite long.  For example, to get the screenful of data that
a command-line program might return when given an unknown switch,
I often just use a brief, self-explanatory key such as \*(L"_USAGE_MESSAGE\*(R".  At that point I then go
and immediately to define that lexicon entry in the
ProjectClass::L10N::en lexicon (since English is always my \*(L"project
language\*(R"):
.PP
.Vb 3
\&  \*(Aq_USAGE_MESSAGE\*(Aq => <<\*(AqEOSTUFF\*(Aq,
\&  ...long long message...
\&  EOSTUFF
.Ve
.PP
and then I can use it as:
.PP
.Vb 1
\&  getopt(\*(AqoDI\*(Aq, \e%opts) or die $lh\->maketext(\*(Aq_USAGE_MESSAGE\*(Aq);
.Ve
.PP
Incidentally,
note that each class's \f(CW%Lexicon\fR inherits-and-extends
the lexicons in its superclasses.  This is not because these are
special hashes \fIper se\fR, but because you access them via the
\&\f(CW\*(C`maketext\*(C'\fR method, which looks for entries across all the
\&\f(CW%Lexicon\fR hashes in a language class \fIand\fR all its ancestor classes.
(This is because the idea of \*(L"class data\*(R" isn't directly implemented
in Perl, but is instead left to individual class-systems to implement
as they see fit..)
.PP
Note that you may have things stored in a lexicon
besides just phrases for output:  for example, if your program
takes input from the keyboard, asking a \*(L"(Y/N)\*(R" question,
you probably need to know what the equivalent of \*(L"Y[es]/N[o]\*(R" is
in whatever language.  You probably also need to know what
the equivalents of the answers \*(L"y\*(R" and \*(L"n\*(R" are.  You can
store that information in the lexicon (say, under the keys
\&\*(L"~answer_y\*(R" and \*(L"~answer_n\*(R", and the long forms as
\&\*(L"~answer_yes\*(R" and \*(L"~answer_no\*(R", where \*(L"~\*(R" is just an ad-hoc
character meant to indicate to programmers/translators that
these are not phrases for output).
.PP
Or instead of storing this in the language class's lexicon,
you can (and, in some cases, really should) represent the same bit
of knowledge as code in a method in the language class.  (That
leaves a tidy distinction between the lexicon as the things we
know how to \fIsay\fR, and the rest of the things in the lexicon class
as things that we know how to \fIdo\fR.)  Consider
this example of a processor for responses to French \*(L"oui/non\*(R"
questions:
.PP
.Vb 7
\&  sub y_or_n {
\&    return undef unless defined $_[1] and length $_[1];
\&    my $answer = lc $_[1];  # smash case
\&    return 1 if $answer eq \*(Aqo\*(Aq or $answer eq \*(Aqoui\*(Aq;
\&    return 0 if $answer eq \*(Aqn\*(Aq or $answer eq \*(Aqnon\*(Aq;
\&    return undef;
\&  }
.Ve
.PP
\&...which you'd then call in a construct like this:
.PP
.Vb 7
\&  my $response;
\&  until(defined $response) {
\&    print $lh\->maketext("Open the pod bay door (y/n)? ");
\&    $response = $lh\->y_or_n( get_input_from_keyboard_somehow() );
\&  }
\&  if($response) { $pod_bay_door\->open()         }
\&  else          { $pod_bay_door\->leave_closed() }
.Ve
.PP
Other data worth storing in a lexicon might be things like
filenames for language-targetted resources:
.PP
.Vb 10
\&  ...
\&  "_main_splash_png"
\&    => "/styles/en_us/main_splash.png",
\&  "_main_splash_imagemap"
\&    => "/styles/en_us/main_splash.incl",
\&  "_general_graphics_path"
\&    => "/styles/en_us/",
\&  "_alert_sound"
\&    => "/styles/en_us/hey_there.wav",
\&  "_forward_icon"
\&   => "left_arrow.png",
\&  "_backward_icon"
\&   => "right_arrow.png",
\&  # In some other languages, left equals
\&  #  BACKwards, and right is FOREwards.
\&  ...
.Ve
.PP
You might want to do the same thing for expressing key bindings
or the like (since hardwiring \*(L"q\*(R" as the binding for the function
that quits a screen/menu/program is useful only if your language
happens to associate \*(L"q\*(R" with \*(L"quit\*(R"!)
.SH "BRACKET NOTATION"
.IX Header "BRACKET NOTATION"
Bracket Notation is a crucial feature of Locale::Maketext.  I mean
Bracket Notation to provide a replacement for the use of sprintf formatting.
Everything you do with Bracket Notation could be done with a sub block,
but bracket notation is meant to be much more concise.
.PP
Bracket Notation is a like a miniature \*(L"template\*(R" system (in the sense
of Text::Template, not in the sense of \*(C+ templates),
where normal text is passed thru basically as is, but text in special
regions is specially interpreted.  In Bracket Notation, you use square brackets (\*(L"[...]\*(R"),
not curly braces (\*(L"{...}\*(R") to note sections that are specially interpreted.
.PP
For example, here all the areas that are taken literally are underlined with
a \*(L"^\*(R", and all the in-bracket special regions are underlined with an X:
.PP
.Vb 2
\&  "Minimum ([_1]) is larger than maximum ([_2])!\en",
\&   ^^^^^^^^^ XX ^^^^^^^^^^^^^^^^^^^^^^^^^^ XX ^^^^
.Ve
.PP
When that string is compiled from bracket notation into a real Perl sub,
it's basically turned into:
.PP
.Vb 11
\&  sub {
\&    my $lh = $_[0];
\&    my @params = @_;
\&    return join \*(Aq\*(Aq,
\&      "Minimum (",
\&      ...some code here...
\&      ") is larger than maximum (",
\&      ...some code here...
\&      ")!\en",
\&  }
\&  # to be called by $lh\->maketext(KEY, params...)
.Ve
.PP
In other words, text outside bracket groups is turned into string
literals.  Text in brackets is rather more complex, and currently follows
these rules:
.IP "\(bu" 4
Bracket groups that are empty, or which consist only of whitespace,
are ignored.  (Examples: \*(L"[]\*(R", \*(L"[    ]\*(R", or a [ and a ] with returns
and/or tabs and/or spaces between them.
.Sp
Otherwise, each group is taken to be a comma-separated group of items,
and each item is interpreted as follows:
.IP "\(bu" 4
An item that is "_\fIdigits\fR\*(L" or \*(R"_\-\fIdigits\fR" is interpreted as
\&\f(CW$_\fR[\fIvalue\fR].  I.e., \*(L"_1\*(R" becomes with \f(CW$_\fR[1], and \*(L"_\-3\*(R" is interpreted
as \f(CW$_\fR[\-3] (in which case \f(CW@_\fR should have at least three elements in it).
Note that \f(CW$_\fR[0] is the language handle, and is typically not named
directly.
.IP "\(bu" 4
An item \*(L"_*\*(R" is interpreted to mean \*(L"all of \f(CW@_\fR except \f(CW$_\fR[0]\*(R".
I.e., \f(CW@_[1..$#_]\fR.  Note that this is an empty list in the case
of calls like \f(CW$lh\fR\->maketext(\fIkey\fR) where there are no
parameters (except \f(CW$_\fR[0], the language handle).
.IP "\(bu" 4
Otherwise, each item is interpreted as a string literal.
.PP
The group as a whole is interpreted as follows:
.IP "\(bu" 4
If the first item in a bracket group looks like a method name,
then that group is interpreted like this:
.Sp
.Vb 3
\&  $lh\->that_method_name(
\&    ...rest of items in this group...
\&  ),
.Ve
.IP "\(bu" 4
If the first item in a bracket group is \*(L"*\*(R", it's taken as shorthand
for the so commonly called \*(L"quant\*(R" method.  Similarly, if the first
item in a bracket group is \*(L"#\*(R", it's taken to be shorthand for
\&\*(L"numf\*(R".
.IP "\(bu" 4
If the first item in a bracket group is the empty-string, or \*(L"_*\*(R"
or "_\fIdigits\fR\*(L" or \*(R"_\-\fIdigits\fR", then that group is interpreted
as just the interpolation of all its items:
.Sp
.Vb 3
\&  join(\*(Aq\*(Aq,
\&    ...rest of items in this group...
\&  ),
.Ve
.Sp
Examples:  \*(L"[_1]\*(R" and \*(L"[,_1]\*(R", which are synonymous; and
"\f(CW\*(C`[,ID\-(,_4,\-,_2,)]\*(C'\fR", which compiles as
\&\f(CW\*(C`join "", "ID\-(", $_[4], "\-", $_[2], ")"\*(C'\fR.
.IP "\(bu" 4
Otherwise this bracket group is invalid.  For example, in the group
\&\*(L"[!@#,whatever]\*(R", the first item \f(CW"!@#"\fR is neither the empty-string,
"_\fInumber\fR\*(L", \*(R"_\-\fInumber\fR\*(L", \*(R"_*", nor a valid method name; and so
Locale::Maketext will throw an exception of you try compiling an
expression containing this bracket group.
.PP
Note, incidentally, that items in each group are comma-separated,
not \f(CW\*(C`/\es*,\es*/\*(C'\fR\-separated.  That is, you might expect that this
bracket group:
.PP
.Vb 1
\&  "Hoohah [foo, _1 , bar ,baz]!"
.Ve
.PP
would compile to this:
.PP
.Vb 7
\&  sub {
\&    my $lh = $_[0];
\&    return join \*(Aq\*(Aq,
\&      "Hoohah ",
\&      $lh\->foo( $_[1], "bar", "baz"),
\&      "!",
\&  }
.Ve
.PP
But it actually compiles as this:
.PP
.Vb 7
\&  sub {
\&    my $lh = $_[0];
\&    return join \*(Aq\*(Aq,
\&      "Hoohah ",
\&      $lh\->foo(" _1 ", " bar ", "baz"),  # note the <space> in " bar "
\&      "!",
\&  }
.Ve
.PP
In the notation discussed so far, the characters \*(L"[\*(R" and \*(L"]\*(R" are given
special meaning, for opening and closing bracket groups, and \*(L",\*(R" has
a special meaning inside bracket groups, where it separates items in the
group.  This begs the question of how you'd express a literal \*(L"[\*(R" or
\&\*(L"]\*(R" in a Bracket Notation string, and how you'd express a literal
comma inside a bracket group.  For this purpose I've adopted \*(L"~\*(R" (tilde)
as an escape character:  \*(L"~[\*(R" means a literal '[' character anywhere
in Bracket Notation (i.e., regardless of whether you're in a bracket
group or not), and ditto for \*(L"~]\*(R" meaning a literal ']', and \*(L"~,\*(R" meaning
a literal comma.  (Altho \*(L",\*(R" means a literal comma outside of
bracket groups \*(-- it's only inside bracket groups that commas are special.)
.PP
And on the off chance you need a literal tilde in a bracket expression,
you get it with \*(L"~~\*(R".
.PP
Currently, an unescaped \*(L"~\*(R" before a character
other than a bracket or a comma is taken to mean just a \*(L"~\*(R" and that
character.  I.e., \*(L"~X\*(R" means the same as \*(L"~~X\*(R" \*(-- i.e., one literal tilde,
and then one literal \*(L"X\*(R".  However, by using \*(L"~X\*(R", you are assuming that
no future version of Maketext will use \*(L"~X\*(R" as a magic escape sequence.
In practice this is not a great problem, since first off you can just
write \*(L"~~X\*(R" and not worry about it; second off, I doubt I'll add lots
of new magic characters to bracket notation; and third off, you
aren't likely to want literal \*(L"~\*(R" characters in your messages anyway,
since it's not a character with wide use in natural language text.
.PP
Brackets must be balanced \*(-- every openbracket must have
one matching closebracket, and vice versa.  So these are all \fBinvalid\fR:
.PP
.Vb 4
\&  "I ate [quant,_1,rhubarb pie."
\&  "I ate [quant,_1,rhubarb pie[."
\&  "I ate quant,_1,rhubarb pie]."
\&  "I ate quant,_1,rhubarb pie[."
.Ve
.PP
Currently, bracket groups do not nest.  That is, you \fBcannot\fR say:
.PP
.Vb 1
\&  "Foo [bar,baz,[quux,quuux]]\en";
.Ve
.PP
If you need a notation that's that powerful, use normal Perl:
.PP
.Vb 11
\&  %Lexicon = (
\&    ...
\&    "some_key" => sub {
\&      my $lh = $_[0];
\&      join \*(Aq\*(Aq,
\&        "Foo ",
\&        $lh\->bar(\*(Aqbaz\*(Aq, $lh\->quux(\*(Aqquuux\*(Aq)),
\&        "\en",
\&    },
\&    ...
\&  );
.Ve
.PP
Or write the \*(L"bar\*(R" method so you don't need to pass it the
output from calling quux.
.PP
I do not anticipate that you will need (or particularly want)
to nest bracket groups, but you are welcome to email me with
convincing (real-life) arguments to the contrary.
.SH "AUTO LEXICONS"
.IX Header "AUTO LEXICONS"
If maketext goes to look in an individual \f(CW%Lexicon\fR for an entry
for \fIkey\fR (where \fIkey\fR does not start with an underscore), and
sees none, \fBbut does see\fR an entry of \*(L"_AUTO\*(R" => \fIsome_true_value\fR,
then we actually define \f(CW$Lexicon\fR{\fIkey\fR} = \fIkey\fR right then and there,
and then use that value as if it had been there all
along.  This happens before we even look in any superclass \f(CW%Lexicons\fR!
.PP
(This is meant to be somewhat like the \s-1AUTOLOAD\s0 mechanism in
Perl's function call system \*(-- or, looked at another way,
like the AutoLoader module.)
.PP
I can picture all sorts of circumstances where you just
do not want lookup to be able to fail (since failing
normally means that maketext throws a \f(CW\*(C`die\*(C'\fR, although
see the next section for greater control over that).  But
here's one circumstance where _AUTO lexicons are meant to
be \fIespecially\fR useful:
.PP
As you're writing an application, you decide as you go what messages
you need to emit.  Normally you'd go to write this:
.PP
.Vb 5
\&  if(\-e $filename) {
\&    go_process_file($filename)
\&  } else {
\&    print qq{Couldn\*(Aqt find file "$filename"!\en};
\&  }
.Ve
.PP
but since you anticipate localizing this, you write:
.PP
.Vb 10
\&  use ThisProject::I18N;
\&  my $lh = ThisProject::I18N\->get_handle();
\&   # For the moment, assume that things are set up so
\&   # that we load class ThisProject::I18N::en
\&   # and that that\*(Aqs the class that $lh belongs to.
\&  ...
\&  if(\-e $filename) {
\&    go_process_file($filename)
\&  } else {
\&    print $lh\->maketext(
\&      qq{Couldn\*(Aqt find file "[_1]"!\en}, $filename
\&    );
\&  }
.Ve
.PP
Now, right after you've just written the above lines, you'd
normally have to go open the file 
ThisProject/I18N/en.pm, and immediately add an entry:
.PP
.Vb 2
\&  "Couldn\*(Aqt find file \e"[_1]\e"!\en"
\&  => "Couldn\*(Aqt find file \e"[_1]\e"!\en",
.Ve
.PP
But I consider that somewhat of a distraction from the work
of getting the main code working \*(-- to say nothing of the fact
that I often have to play with the program a few times before
I can decide exactly what wording I want in the messages (which
in this case would require me to go changing three lines of code:
the call to maketext with that key, and then the two lines in
ThisProject/I18N/en.pm).
.PP
However, if you set \*(L"_AUTO => 1\*(R" in the \f(CW%Lexicon\fR in,
ThisProject/I18N/en.pm (assuming that English (en) is
the language that all your programmers will be using for this
project's internal message keys), then you don't ever have to
go adding lines like this
.PP
.Vb 2
\&  "Couldn\*(Aqt find file \e"[_1]\e"!\en"
\&  => "Couldn\*(Aqt find file \e"[_1]\e"!\en",
.Ve
.PP
to ThisProject/I18N/en.pm, because if _AUTO is true there,
then just looking for an entry with the key \*(L"Couldn't find
file \e\*(R"[_1]\e\*(L"!\en\*(R" in that lexicon will cause it to be added,
with that value!
.PP
Note that the reason that keys that start with \*(L"_\*(R"
are immune to _AUTO isn't anything generally magical about
the underscore character \*(-- I just wanted a way to have most
lexicon keys be autoable, except for possibly a few, and I
arbitrarily decided to use a leading underscore as a signal
to distinguish those few.
.SH "READONLY LEXICONS"
.IX Header "READONLY LEXICONS"
If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.
.PP
For example a GDBM_File \s-1GDBM_READER\s0 tied hash will die with something like:
.PP
.Vb 1
\&   gdbm store returned \-1, errno 2, key "..." at ...
.Ve
.PP
All you need to do is turn on caching outside of the lexicon hash itself like so:
.PP
.Vb 6
\&   sub init {
\&       my ($lh) = @_;
\&       ...
\&       $lh\->{\*(Aquse_external_lex_cache\*(Aq} = 1;
\&       ...
\&   }
.Ve
.PP
And then instead of storing the compiled value in the lexicon hash it will store it in \f(CW$lh\fR\->{'_external_lex_cache'}
.SH "CONTROLLING LOOKUP FAILURE"
.IX Header "CONTROLLING LOOKUP FAILURE"
If you call \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...),
and there's no entry \fIkey\fR in \f(CW$lh\fR's class's \f(CW%Lexicon\fR, nor
in the superclass \f(CW%Lexicon\fR hash, \fIand\fR if we can't auto-make
\&\fIkey\fR (because either it starts with a \*(L"_\*(R", or because none
of its lexicons have \f(CW\*(C`_AUTO => 1,\*(C'\fR), then we have
failed to find a normal way to maketext \fIkey\fR.  What then
happens in these failure conditions, depends on the \f(CW$lh\fR object's
\&\*(L"fail\*(R" attribute.
.PP
If the language handle has no \*(L"fail\*(R" attribute, maketext
will simply throw an exception (i.e., it calls \f(CW\*(C`die\*(C'\fR, mentioning
the \fIkey\fR whose lookup failed, and naming the line number where
the calling \f(CW$lh\fR\->maketext(\fIkey\fR,...) was.
.PP
If the language handle has a \*(L"fail\*(R" attribute whose value is a
coderef, then \f(CW$lh\fR\->maketext(\fIkey\fR,...params...) gives up and calls:
.PP
.Vb 1
\&  return $that_subref\->($lh, $key, @params);
.Ve
.PP
Otherwise, the \*(L"fail\*(R" attribute's value should be a string denoting
a method name, so that \f(CW$lh\fR\->maketext(\fIkey\fR,...params...) can
give up with:
.PP
.Vb 1
\&  return $lh\->$that_method_name($phrase, @params);
.Ve
.PP
The \*(L"fail\*(R" attribute can be accessed with the \f(CW\*(C`fail_with\*(C'\fR method:
.PP
.Vb 2
\&  # Set to a coderef:
\&  $lh\->fail_with( \e&failure_handler );
\&
\&  # Set to a method name:
\&  $lh\->fail_with( \*(Aqfailure_method\*(Aq );
\&
\&  # Set to nothing (i.e., so failure throws a plain exception)
\&  $lh\->fail_with( undef );
\&
\&  # Get the current value
\&  $handler = $lh\->fail_with();
.Ve
.PP
Now, as to what you may want to do with these handlers:  Maybe you'd
want to log what key failed for what class, and then die.  Maybe
you don't like \f(CW\*(C`die\*(C'\fR and instead you want to send the error message
to \s-1STDOUT \s0(or wherever) and then merely \f(CW\*(C`exit()\*(C'\fR.
.PP
Or maybe you don't want to \f(CW\*(C`die\*(C'\fR at all!  Maybe you could use a
handler like this:
.PP
.Vb 10
\&  # Make all lookups fall back onto an English value,
\&  #  but only after we log it for later fingerpointing.
\&  my $lh_backup = ThisProject\->get_handle(\*(Aqen\*(Aq);
\&  open(LEX_FAIL_LOG, ">>wherever/lex.log") || die "GNAARGH $!";
\&  sub lex_fail {
\&    my($failing_lh, $key, $params) = @_;
\&    print LEX_FAIL_LOG scalar(localtime), "\et",
\&       ref($failing_lh), "\et", $key, "\en";
\&    return $lh_backup\->maketext($key,@params);
\&  }
.Ve
.PP
Some users have expressed that they think this whole mechanism of
having a \*(L"fail\*(R" attribute at all, seems a rather pointless complication.
But I want Locale::Maketext to be usable for software projects of \fIany\fR
scale and type; and different software projects have different ideas
of what the right thing is to do in failure conditions.  I could simply
say that failure always throws an exception, and that if you want to be
careful, you'll just have to wrap every call to \f(CW$lh\fR\->maketext in an
eval\ {\ }.  However, I want programmers to reserve the right (via
the \*(L"fail\*(R" attribute) to treat lookup failure as something other than
an exception of the same level of severity as a config file being
unreadable, or some essential resource being inaccessible.
.PP
One possibly useful value for the \*(L"fail\*(R" attribute is the method name
\&\*(L"failure_handler_auto\*(R".  This is a method defined in the class
Locale::Maketext itself.  You set it with:
.PP
.Vb 1
\&  $lh\->fail_with(\*(Aqfailure_handler_auto\*(Aq);
.Ve
.PP
Then when you call \f(CW$lh\fR\->maketext(\fIkey\fR, ...parameters...) and
there's no \fIkey\fR in any of those lexicons, maketext gives up with
.PP
.Vb 1
\&  return $lh\->failure_handler_auto($key, @params);
.Ve
.PP
But failure_handler_auto, instead of dying or anything, compiles
\&\f(CW$key\fR, caching it in
.PP
.Vb 1
\&    $lh\->{\*(Aqfailure_lex\*(Aq}{$key} = $complied
.Ve
.PP
and then calls the compiled value, and returns that.  (I.e., if
\&\f(CW$key\fR looks like bracket notation, \f(CW$compiled\fR is a sub, and we return
&{$compiled}(@params); but if \f(CW$key\fR is just a plain string, we just
return that.)
.PP
The effect of using \*(L"failure_auto_handler\*(R"
is like an \s-1AUTO\s0 lexicon, except that it 1) compiles \f(CW$key\fR even if
it starts with \*(L"_\*(R", and 2) you have a record in the new hashref
\&\f(CW$lh\fR\->{'failure_lex'} of all the keys that have failed for
this object.  This should avoid your program dying \*(-- as long
as your keys aren't actually invalid as bracket code, and as
long as they don't try calling methods that don't exist.
.PP
\&\*(L"failure_auto_handler\*(R" may not be exactly what you want, but I
hope it at least shows you that maketext failure can be mitigated
in any number of very flexible ways.  If you can formalize exactly
what you want, you should be able to express that as a failure
handler.  You can even make it default for every object of a given
class, by setting it in that class's init:
.PP
.Vb 9
\&  sub init {
\&    my $lh = $_[0];  # a newborn handle
\&    $lh\->SUPER::init();
\&    $lh\->fail_with(\*(Aqmy_clever_failure_handler\*(Aq);
\&    return;
\&  }
\&  sub my_clever_failure_handler {
\&    ...you clever things here...
\&  }
.Ve
.SH "HOW TO USE MAKETEXT"
.IX Header "HOW TO USE MAKETEXT"
Here is a brief checklist on how to use Maketext to localize
applications:
.IP "\(bu" 4
Decide what system you'll use for lexicon keys.  If you insist,
you can use opaque IDs (if you're nostalgic for \f(CW\*(C`catgets\*(C'\fR),
but I have better suggestions in the
section \*(L"Entries in Each Lexicon\*(R", above.  Assuming you opt for
meaningful keys that double as values (like \*(L"Minimum ([_1]) is
larger than maximum ([_2])!\en\*(R"), you'll have to settle on what
language those should be in.  For the sake of argument, I'll
call this English, specifically American English, \*(L"en-US\*(R".
.IP "\(bu" 4
Create a class for your localization project.  This is
the name of the class that you'll use in the idiom:
.Sp
.Vb 2
\&  use Projname::L10N;
\&  my $lh = Projname::L10N\->get_handle(...) || die "Language?";
.Ve
.Sp
Assuming you call your class Projname::L10N, create a class
consisting minimally of:
.Sp
.Vb 3
\&  package Projname::L10N;
\&  use base qw(Locale::Maketext);
\&  ...any methods you might want all your languages to share...
\&
\&  # And, assuming you want the base class to be an _AUTO lexicon,
\&  # as is discussed a few sections up:
\&
\&  1;
.Ve
.IP "\(bu" 4
Create a class for the language your internal keys are in.  Name
the class after the language-tag for that language, in lowercase,
with dashes changed to underscores.  Assuming your project's first
language is \s-1US\s0 English, you should call this Projname::L10N::en_us.
It should consist minimally of:
.Sp
.Vb 6
\&  package Projname::L10N::en_us;
\&  use base qw(Projname::L10N);
\&  %Lexicon = (
\&    \*(Aq_AUTO\*(Aq => 1,
\&  );
\&  1;
.Ve
.Sp
(For the rest of this section, I'll assume that this \*(L"first
language class\*(R" of Projname::L10N::en_us has
_AUTO lexicon.)
.IP "\(bu" 4
Go and write your program.  Everywhere in your program where 
you would say:
.Sp
.Vb 1
\&  print "Foobar $thing stuff\en";
.Ve
.Sp
instead do it thru maketext, using no variable interpolation in
the key:
.Sp
.Vb 1
\&  print $lh\->maketext("Foobar [_1] stuff\en", $thing);
.Ve
.Sp
If you get tired of constantly saying \f(CW\*(C`print $lh\->maketext\*(C'\fR,
consider making a functional wrapper for it, like so:
.Sp
.Vb 7
\&  use Projname::L10N;
\&  use vars qw($lh);
\&  $lh = Projname::L10N\->get_handle(...) || die "Language?";
\&  sub pmt (@) { print( $lh\->maketext(@_)) }
\&   # "pmt" is short for "Print MakeText"
\&  $Carp::Verbose = 1;
\&   # so if maketext fails, we see made the call to pmt
.Ve
.Sp
Besides whole phrases meant for output, anything language-dependent
should be put into the class Projname::L10N::en_us,
whether as methods, or as lexicon entries \*(-- this is discussed
in the section \*(L"Entries in Each Lexicon\*(R", above.
.IP "\(bu" 4
Once the program is otherwise done, and once its localization for
the first language works right (via the data and methods in
Projname::L10N::en_us), you can get together the data for translation.
If your first language lexicon isn't an _AUTO lexicon, then you already
have all the messages explicitly in the lexicon (or else you'd be
getting exceptions thrown when you call \f(CW$lh\fR\->maketext to get
messages that aren't in there).  But if you were (advisedly) lazy and are
using an _AUTO lexicon, then you've got to make a list of all the phrases
that you've so far been letting _AUTO generate for you.  There are very
many ways to assemble such a list.  The most straightforward is to simply
grep the source for every occurrence of \*(L"maketext\*(R" (or calls
to wrappers around it, like the above \f(CW\*(C`pmt\*(C'\fR function), and to log the
following phrase.
.IP "\(bu" 4
You may at this point want to consider whether your base class 
(Projname::L10N), from which all lexicons inherit from (Projname::L10N::en,
Projname::L10N::es, etc.), should be an _AUTO lexicon.  It may be true
that in theory, all needed messages will be in each language class;
but in the presumably unlikely or \*(L"impossible\*(R" case of lookup failure,
you should consider whether your program should throw an exception,
emit text in English (or whatever your project's first language is),
or some more complex solution as described in the section
\&\*(L"Controlling Lookup Failure\*(R", above.
.IP "\(bu" 4
Submit all messages/phrases/etc. to translators.
.Sp
(You may, in fact, want to start with localizing to \fIone\fR other language
at first, if you're not sure that you've properly abstracted the
language-dependent parts of your code.)
.Sp
Translators may request clarification of the situation in which a
particular phrase is found.  For example, in English we are entirely happy
saying "\fIn\fR files found\*(L", regardless of whether we mean \*(R"I looked for files,
and found \fIn\fR of them\*(L" or the rather distinct situation of \*(R"I looked for
something else (like lines in files), and along the way I saw \fIn\fR
files.\*(L"  This may involve rethinking things that you thought quite clear:
should \*(R"Edit\*(L" on a toolbar be a noun (\*(R"editing\*(L") or a verb (\*(R"to edit\*(L")?  Is
there already a conventionalized way to express that menu option, separate
from the target language's normal word for \*(R"to edit"?
.Sp
In all cases where the very common phenomenon of quantification
(saying "\fIN\fR files", for \fBany\fR value of N)
is involved, each translator should make clear what dependencies the
number causes in the sentence.  In many cases, dependency is
limited to words adjacent to the number, in places where you might
expect them ("I found the\-?PLURAL \fIN\fR
empty\-?PLURAL directory\-?PLURAL\*(L"), but in some cases there are
unexpected dependencies (\*(R"I found\-?PLURAL ...\*(L"!) as well as long-distance
dependencies \*(R"The \fIN\fR directory\-?PLURAL could not be deleted\-?PLURAL"!).
.Sp
Remind the translators to consider the case where N is 0:
\&\*(L"0 files found\*(R" isn't exactly natural-sounding in any language, but it
may be unacceptable in many \*(-- or it may condition special
kinds of agreement (similar to English \*(L"I didN'T find \s-1ANY\s0 files\*(R").
.Sp
Remember to ask your translators about numeral formatting in their
language, so that you can override the \f(CW\*(C`numf\*(C'\fR method as
appropriate.  Typical variables in number formatting are:  what to
use as a decimal point (comma? period?); what to use as a thousands
separator (space? nonbreaking space? comma? period? small
middot? prime? apostrophe?); and even whether the so-called \*(L"thousands
separator\*(R" is actually for every third digit \*(-- I've heard reports of
two hundred thousand being expressible as \*(L"2,00,000\*(R" for some Indian
(Subcontinental) languages, besides the less surprising \*(L"200\ 000\*(R",
\&\*(L"200.000\*(R", \*(L"200,000\*(R", and \*(L"200'000\*(R".  Also, using a set of numeral
glyphs other than the usual \s-1ASCII \*(L"0\*(R"\-\*(L"9\*(R"\s0 might be appreciated, as via
\&\f(CW\*(C`tr/0\-9/\ex{0966}\-\ex{096F}/\*(C'\fR for getting digits in Devanagari script
(for Hindi, Konkani, others).
.Sp
The basic \f(CW\*(C`quant\*(C'\fR method that Locale::Maketext provides should be
good for many languages.  For some languages, it might be useful
to modify it (or its constituent \f(CW\*(C`numerate\*(C'\fR method)
to take a plural form in the two-argument call to \f(CW\*(C`quant\*(C'\fR
(as in \*(L"[quant,_1,files]\*(R") if
it's all-around easier to infer the singular form from the plural, than
to infer the plural form from the singular.
.Sp
But for other languages (as is discussed at length
in Locale::Maketext::TPJ13), simple
\&\f(CW\*(C`quant\*(C'\fR/\f(CW\*(C`numf\*(C'\fR is not enough.  For the particularly problematic
Slavic languages, what you may need is a method which you provide
with the number, the citation form of the noun to quantify, and
the case and gender that the sentence's syntax projects onto that
noun slot.  The method would then be responsible for determining
what grammatical number that numeral projects onto its noun phrase,
and what case and gender it may override the normal case and gender
with; and then it would look up the noun in a lexicon providing
all needed inflected forms.
.IP "\(bu" 4
You may also wish to discuss with the translators the question of
how to relate different subforms of the same language tag,
considering how this reacts with \f(CW\*(C`get_handle\*(C'\fR's treatment of
these.  For example, if a user accepts interfaces in \*(L"en, fr\*(R", and
you have interfaces available in \*(L"en-US\*(R" and \*(L"fr\*(R", what should
they get?  You may wish to resolve this by establishing that \*(L"en\*(R"
and \*(L"en-US\*(R" are effectively synonymous, by having one class
zero-derive from the other.
.Sp
For some languages this issue may never come up (Danish is rarely
expressed as \*(L"da-DK\*(R", but instead is just \*(L"da\*(R").  And for other
languages, the whole concept of a \*(L"generic\*(R" form may verge on
being uselessly vague, particularly for interfaces involving voice
media in forms of Arabic or Chinese.
.IP "\(bu" 4
Once you've localized your program/site/etc. for all desired
languages, be sure to show the result (whether live, or via
screenshots) to the translators.  Once they approve, make every
effort to have it then checked by at least one other speaker of
that language.  This holds true even when (or especially when) the
translation is done by one of your own programmers.  Some
kinds of systems may be harder to find testers for than others,
depending on the amount of domain-specific jargon and concepts
involved \*(-- it's easier to find people who can tell you whether
they approve of your translation for \*(L"delete this message\*(R" in an
email-via-Web interface, than to find people who can give you
an informed opinion on your translation for \*(L"attribute value\*(R"
in an \s-1XML\s0 query tool's interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I recommend reading all of these:
.PP
Locale::Maketext::TPJ13 \*(-- my \fIThe Perl
Journal\fR article about Maketext.  It explains many important concepts
underlying Locale::Maketext's design, and some insight into why
Maketext is better than the plain old approach of having 
message catalogs that are just databases of sprintf formats.
.PP
File::Findgrep is a sample application/module
that uses Locale::Maketext to localize its messages.  For a larger
internationalized system, see also Apache::MP3.
.PP
I18N::LangTags.
.PP
Win32::Locale.
.PP
\&\s-1RFC 3066, \s0\fITags for the Identification of Languages\fR,
as at http://sunsite.dk/RFC/rfc/rfc3066.html
.PP
\&\s-1RFC 2277, \s0\fI\s-1IETF\s0 Policy on Character Sets and Languages\fR
is at http://sunsite.dk/RFC/rfc/rfc2277.html \*(-- much of it is
just things of interest to protocol designers, but it explains
some basic concepts, like the distinction between locales and
language-tags.
.PP
The manual for \s-1GNU \s0\f(CW\*(C`gettext\*(C'\fR.  The gettext dist is available in
\&\f(CW\*(C`ftp://prep.ai.mit.edu/pub/gnu/\*(C'\fR \*(-- get
a recent gettext tarball and look in its \*(L"doc/\*(R" directory, there's
an easily browsable \s-1HTML\s0 version in there.  The
gettext documentation asks lots of questions worth thinking
about, even if some of their answers are sometimes wonky,
particularly where they start talking about pluralization.
.PP
The Locale/Maketext.pm source.  Obverse that the module is much
shorter than its documentation!
.SH "COPYRIGHT AND DISCLAIMER"
.IX Header "COPYRIGHT AND DISCLAIMER"
Copyright (c) 1999\-2004 Sean M. Burke.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Cookbook.3pm               0100644 0001750 0001750 00000020427 12566207460 026247  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Cookbook 3pm"
.TH Locale::Maketext::Cookbook 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Cookbook \- recipes for using Locale::Maketext
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This is a work in progress. Not much progress by now :\-)
.SH "ONESIDED LEXICONS"
.IX Header "ONESIDED LEXICONS"
\&\fIAdapted from a suggestion by Dan Muey\fR
.PP
It may be common (for example at your main lexicon) that
the hash keys and values coincide. Like that
.PP
.Vb 2
\&    q{Hello, tell me your name} 
\&      => q{Hello, tell me your name}
.Ve
.PP
It would be nice to just write:
.PP
.Vb 1
\&    q{Hello, tell me your name} => \*(Aq\*(Aq
.Ve
.PP
and have this magically inflated to the first form.
Among the advantages of such representation, that would
lead to  
smaller files, less prone to mistyping or mispasting, 
and handy to someone translating it which can simply 
copy the main lexicon and enter the translation 
instead of having to remove the value first.
.PP
That can be achieved by overriding \f(CW\*(C`init\*(C'\fR
in your class and working on the main lexicon
with code like that:
.PP
.Vb 2
\&    package My::I18N;
\&    ...
\&
\&    sub init {
\&        my $lh = shift; # a newborn handle
\&        $lh\->SUPER::init();
\&        inflate_lexicon(\e%My::I18N::en::Lexicon);
\&        return;
\&    }
\&
\&    sub inflate_lexicon {
\&        my $lex = shift;
\&        while (my ($k, $v) = each %$lex) {
\&            $v = $k if !defined $v || $v eq \*(Aq\*(Aq;
\&        }
\&    }
.Ve
.PP
Here we are assuming \f(CW\*(C`My::I18N::en\*(C'\fR to own the
main lexicon.
.PP
There are some downsides here: the size economy
will not stand at runtime after this \f(CW\*(C`init()\*(C'\fR
runs. But it should not be that critical, since
if you don't have space for that, you won't have
space for any other language besides the main one
as well. You could do that too with ties,
expanding the value at lookup time which
should be more time expensive as an option.
.SH "DECIMAL PLACES IN NUMBER FORMATTING"
.IX Header "DECIMAL PLACES IN NUMBER FORMATTING"
\&\fIAfter \s-1CPAN RT\s0 #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)\fR
.PP
The documentation of Locale::Maketext advises that 
the standard bracket method \f(CW\*(C`numf\*(C'\fR is limited and that
you must override that for better results. It even
suggests the use of Number::Format.
.PP
One such defect of standard \f(CW\*(C`numf\*(C'\fR is to not be
able to use a certain decimal precision.
For example,
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1]\*(Aq, 355/113);
.Ve
.PP
outputs
.PP
.Vb 1
\&    pi is 3.14159292035398
.Ve
.PP
Since pi X 355/116 is only accurate 
to 6 decimal places, you would want to say:
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1,6]\*(Aq, 355/113);
.Ve
.PP
and get \*(L"pi is 3.141592\*(R".
.PP
One solution for that could use \f(CW\*(C`Number::Format\*(C'\fR
like that:
.PP
.Vb 1
\&    package Wuu;
\&
\&    use base qw(Locale::Maketext);
\&
\&    use Number::Format;
\&
\&    # can be overridden according to language conventions
\&    sub _numf_params {
\&        return (
\&            \-thousands_sep  => \*(Aq.\*(Aq,
\&            \-decimal_point  => \*(Aq,\*(Aq,
\&            \-decimal_digits => 2,
\&        );
\&    }
\&
\&    # builds a Number::Format
\&    sub _numf_formatter {
\&        my ($lh, $scale) = @_;
\&        my @params = $lh\->_numf_params;
\&        if ($scale) { # use explicit scale rather than default
\&            push @params, (\-decimal_digits => $scale);
\&        }
\&        return Number::Format\->new(@params);
\&    }
\&
\&    sub numf {
\&        my ($lh, $n, $scale) = @_;
\&        # get the (cached) formatter
\&        my $nf = $lh\->{_\|_nf}{$scale} ||= $lh\->_numf_formatter($scale);
\&        # format the number itself
\&        return $nf\->format_number($n);
\&    }
\&
\&    package Wuu::pt;
\&
\&    use base qw(Wuu);
.Ve
.PP
and then
.PP
.Vb 2
\&    my $lh = Wuu\->get_handle(\*(Aqpt\*(Aq);
\&    $lh\->maketext(\*(AqA [numf,_1,3] km de dista\*^ncia\*(Aq, 1550.2222);
.Ve
.PP
would return \*(L"A 1.550,222 km de dista\*^ncia\*(R".
.PP
Notice that the standard utility methods of 
\&\f(CW\*(C`Locale::Maketext\*(C'\fR are irremediably limited
because they could not aim to do everything
that could be expected from them in different languages,
cultures and applications. So extending \f(CW\*(C`numf\*(C'\fR,
\&\f(CW\*(C`quant\*(C'\fR, and \f(CW\*(C`sprintf\*(C'\fR is natural as soon
as your needs exceed what the standard ones do.
                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Cookbook5.16.3pm           0100644 0001750 0001750 00000020115 12566207436 026556  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Cookbook 3pm"
.TH Locale::Maketext::Cookbook 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Cookbook \- recipes for using Locale::Maketext
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This is a work in progress. Not much progress by now :\-)
.SH "ONESIDED LEXICONS"
.IX Header "ONESIDED LEXICONS"
\&\fIAdapted from a suggestion by Dan Muey\fR
.PP
It may be common (for example at your main lexicon) that
the hash keys and values coincide. Like that
.PP
.Vb 2
\&    q{Hello, tell me your name} 
\&      => q{Hello, tell me your name}
.Ve
.PP
It would be nice to just write:
.PP
.Vb 1
\&    q{Hello, tell me your name} => \*(Aq\*(Aq
.Ve
.PP
and have this magically inflated to the first form.
Among the advantages of such representation, that would
lead to  
smaller files, less prone to mistyping or mispasting, 
and handy to someone translating it which can simply 
copy the main lexicon and enter the translation 
instead of having to remove the value first.
.PP
That can be achieved by overriding \f(CW\*(C`init\*(C'\fR
in your class and working on the main lexicon
with code like that:
.PP
.Vb 2
\&    package My::I18N;
\&    ...
\&
\&    sub init {
\&        my $lh = shift; # a newborn handle
\&        $lh\->SUPER::init();
\&        inflate_lexicon(\e%My::I18N::en::Lexicon);
\&        return;
\&    }
\&
\&    sub inflate_lexicon {
\&        my $lex = shift;
\&        while (my ($k, $v) = each %$lex) {
\&            $v = $k if !defined $v || $v eq \*(Aq\*(Aq;
\&        }
\&    }
.Ve
.PP
Here we are assuming \f(CW\*(C`My::I18N::en\*(C'\fR to own the
main lexicon.
.PP
There are some downsides here: the size economy
will not stand at runtime after this \f(CW\*(C`init()\*(C'\fR
runs. But it should not be that critical, since
if you don't have space for that, you won't have
space for any other language besides the main one
as well. You could do that too with ties,
expanding the value at lookup time which
should be more time expensive as an option.
.SH "DECIMAL PLACES IN NUMBER FORMATTING"
.IX Header "DECIMAL PLACES IN NUMBER FORMATTING"
\&\fIAfter \s-1CPAN\s0 \s-1RT\s0 #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)\fR
.PP
The documentation of Locale::Maketext advises that 
the standard bracket method \f(CW\*(C`numf\*(C'\fR is limited and that
you must override that for better results. It even
suggests the use of Number::Format.
.PP
One such defect of standard \f(CW\*(C`numf\*(C'\fR is to not be
able to use a certain decimal precision.
For example,
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1]\*(Aq, 355/113);
.Ve
.PP
outputs
.PP
.Vb 1
\&    pi is 3.14159292035398
.Ve
.PP
Since pi X 355/116 is only accurate 
to 6 decimal places, you would want to say:
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1,6]\*(Aq, 355/113);
.Ve
.PP
and get \*(L"pi is 3.141592\*(R".
.PP
One solution for that could use \f(CW\*(C`Number::Format\*(C'\fR
like that:
.PP
.Vb 1
\&    package Wuu;
\&
\&    use base qw(Locale::Maketext);
\&
\&    use Number::Format;
\&
\&    # can be overridden according to language conventions
\&    sub _numf_params {
\&        return (
\&            \-thousands_sep  => \*(Aq.\*(Aq,
\&            \-decimal_point  => \*(Aq,\*(Aq,
\&            \-decimal_digits => 2,
\&        );
\&    }
\&
\&    # builds a Number::Format
\&    sub _numf_formatter {
\&        my ($lh, $scale) = @_;
\&        my @params = $lh\->_numf_params;
\&        if ($scale) { # use explicit scale rather than default
\&            push @params, (\-decimal_digits => $scale);
\&        }
\&        return Number::Format\->new(@params);
\&    }
\&
\&    sub numf {
\&        my ($lh, $n, $scale) = @_;
\&        # get the (cached) formatter
\&        my $nf = $lh\->{_\|_nf}{$scale} ||= $lh\->_numf_formatter($scale);
\&        # format the number itself
\&        return $nf\->format_number($n);
\&    }
\&
\&    package Wuu::pt;
\&
\&    use base qw(Wuu);
.Ve
.PP
and then
.PP
.Vb 2
\&    my $lh = Wuu\->get_handle(\*(Aqpt\*(Aq);
\&    $lh\->maketext(\*(AqA [numf,_1,3] km de dista\*^ncia\*(Aq, 1550.2222);
.Ve
.PP
would return \*(L"A 1.550,222 km de dista\*^ncia\*(R".
.PP
Notice that the standard utility methods of 
\&\f(CW\*(C`Locale::Maketext\*(C'\fR are irremediably limited
because they could not aim to do everything
that could be expected from them in different languages,
cultures and applications. So extending \f(CW\*(C`numf\*(C'\fR,
\&\f(CW\*(C`quant\*(C'\fR, and \f(CW\*(C`sprintf\*(C'\fR is natural as soon
as your needs exceed what the standard ones do.
                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Cookbook5.18.3pm           0100644 0001750 0001750 00000020427 12566207460 026563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Cookbook 3pm"
.TH Locale::Maketext::Cookbook 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Cookbook \- recipes for using Locale::Maketext
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This is a work in progress. Not much progress by now :\-)
.SH "ONESIDED LEXICONS"
.IX Header "ONESIDED LEXICONS"
\&\fIAdapted from a suggestion by Dan Muey\fR
.PP
It may be common (for example at your main lexicon) that
the hash keys and values coincide. Like that
.PP
.Vb 2
\&    q{Hello, tell me your name} 
\&      => q{Hello, tell me your name}
.Ve
.PP
It would be nice to just write:
.PP
.Vb 1
\&    q{Hello, tell me your name} => \*(Aq\*(Aq
.Ve
.PP
and have this magically inflated to the first form.
Among the advantages of such representation, that would
lead to  
smaller files, less prone to mistyping or mispasting, 
and handy to someone translating it which can simply 
copy the main lexicon and enter the translation 
instead of having to remove the value first.
.PP
That can be achieved by overriding \f(CW\*(C`init\*(C'\fR
in your class and working on the main lexicon
with code like that:
.PP
.Vb 2
\&    package My::I18N;
\&    ...
\&
\&    sub init {
\&        my $lh = shift; # a newborn handle
\&        $lh\->SUPER::init();
\&        inflate_lexicon(\e%My::I18N::en::Lexicon);
\&        return;
\&    }
\&
\&    sub inflate_lexicon {
\&        my $lex = shift;
\&        while (my ($k, $v) = each %$lex) {
\&            $v = $k if !defined $v || $v eq \*(Aq\*(Aq;
\&        }
\&    }
.Ve
.PP
Here we are assuming \f(CW\*(C`My::I18N::en\*(C'\fR to own the
main lexicon.
.PP
There are some downsides here: the size economy
will not stand at runtime after this \f(CW\*(C`init()\*(C'\fR
runs. But it should not be that critical, since
if you don't have space for that, you won't have
space for any other language besides the main one
as well. You could do that too with ties,
expanding the value at lookup time which
should be more time expensive as an option.
.SH "DECIMAL PLACES IN NUMBER FORMATTING"
.IX Header "DECIMAL PLACES IN NUMBER FORMATTING"
\&\fIAfter \s-1CPAN RT\s0 #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)\fR
.PP
The documentation of Locale::Maketext advises that 
the standard bracket method \f(CW\*(C`numf\*(C'\fR is limited and that
you must override that for better results. It even
suggests the use of Number::Format.
.PP
One such defect of standard \f(CW\*(C`numf\*(C'\fR is to not be
able to use a certain decimal precision.
For example,
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1]\*(Aq, 355/113);
.Ve
.PP
outputs
.PP
.Vb 1
\&    pi is 3.14159292035398
.Ve
.PP
Since pi X 355/116 is only accurate 
to 6 decimal places, you would want to say:
.PP
.Vb 1
\&    $lh\->maketext(\*(Aqpi is [numf,_1,6]\*(Aq, 355/113);
.Ve
.PP
and get \*(L"pi is 3.141592\*(R".
.PP
One solution for that could use \f(CW\*(C`Number::Format\*(C'\fR
like that:
.PP
.Vb 1
\&    package Wuu;
\&
\&    use base qw(Locale::Maketext);
\&
\&    use Number::Format;
\&
\&    # can be overridden according to language conventions
\&    sub _numf_params {
\&        return (
\&            \-thousands_sep  => \*(Aq.\*(Aq,
\&            \-decimal_point  => \*(Aq,\*(Aq,
\&            \-decimal_digits => 2,
\&        );
\&    }
\&
\&    # builds a Number::Format
\&    sub _numf_formatter {
\&        my ($lh, $scale) = @_;
\&        my @params = $lh\->_numf_params;
\&        if ($scale) { # use explicit scale rather than default
\&            push @params, (\-decimal_digits => $scale);
\&        }
\&        return Number::Format\->new(@params);
\&    }
\&
\&    sub numf {
\&        my ($lh, $n, $scale) = @_;
\&        # get the (cached) formatter
\&        my $nf = $lh\->{_\|_nf}{$scale} ||= $lh\->_numf_formatter($scale);
\&        # format the number itself
\&        return $nf\->format_number($n);
\&    }
\&
\&    package Wuu::pt;
\&
\&    use base qw(Wuu);
.Ve
.PP
and then
.PP
.Vb 2
\&    my $lh = Wuu\->get_handle(\*(Aqpt\*(Aq);
\&    $lh\->maketext(\*(AqA [numf,_1,3] km de dista\*^ncia\*(Aq, 1550.2222);
.Ve
.PP
would return \*(L"A 1.550,222 km de dista\*^ncia\*(R".
.PP
Notice that the standard utility methods of 
\&\f(CW\*(C`Locale::Maketext\*(C'\fR are irremediably limited
because they could not aim to do everything
that could be expected from them in different languages,
cultures and applications. So extending \f(CW\*(C`numf\*(C'\fR,
\&\f(CW\*(C`quant\*(C'\fR, and \f(CW\*(C`sprintf\*(C'\fR is natural as soon
as your needs exceed what the standard ones do.
                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract.3pm                0100644 0001750 0001750 00000040710 12566242634 026112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract 3"
.TH Locale::Maketext::Extract 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract \- Extract translatable strings from source
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    my $Ext = Locale::Maketext::Extract\->new;
\&    $Ext\->read_po(\*(Aqmessages.po\*(Aq);
\&    $Ext\->extract_file($_) for <*.pl>;
\&
\&    # Set $entries_are_in_gettext_format if the .pl files above use
\&    # loc(\*(Aq%1\*(Aq) instead of loc(\*(Aq[_1]\*(Aq)
\&    $Ext\->compile($entries_are_in_gettext_format);
\&
\&    $Ext\->write_po(\*(Aqmessages.po\*(Aq);
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    ### Specifying parser plugins ###
\&
\&    my $Ext = Locale::Maketext::Extract\->new(
\&
\&        # Specify which parser plugins to use
\&        plugins => {
\&
\&            # Use Perl parser, process files with extension .pl .pm .cgi
\&            perl => [],
\&
\&            # Use YAML parser, process all files
\&            yaml => [\*(Aq*\*(Aq],
\&
\&            # Use TT2 parser, process files with extension .tt2 .tt .html
\&            # or which match the regex
\&            tt2  => [
\&                \*(Aqtt2\*(Aq,
\&                \*(Aqtt\*(Aq,
\&                \*(Aqhtml\*(Aq,
\&                qr/\e.tt2?\e./
\&            ],
\&
\&            # Use My::Module as a parser for all files
\&            \*(AqMy::Module\*(Aq => [\*(Aq*\*(Aq],
\&
\&        },
\&
\&        # Warn if a parser can\*(Aqt process a file or problems loading a plugin
\&        warnings => 1,
\&
\&        # List processed files
\&        verbose => 1,
\&
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can extract translatable strings from files, and write
them back to \s-1PO\s0 files.  It can also parse existing \s-1PO\s0 files and merge
their contents with newly extracted strings.
.PP
A command-line utility, xgettext.pl, is installed with this module
as well.
.PP
The format parsers are loaded as plugins, so it is possible to define
your own parsers.
.PP
Following formats of input files are supported:
.IP "Perl source files  (plugin: perl)" 4
.IX Item "Perl source files (plugin: perl)"
Valid localization function names are: \f(CW\*(C`translate\*(C'\fR, \f(CW\*(C`maketext\*(C'\fR,
\&\f(CW\*(C`gettext\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`loc\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`_\*(C'\fR and \f(CW\*(C`_\|_\*(C'\fR.
.Sp
For a slightly more accurate, but much slower Perl parser, you can  use the \s-1PPI\s0
plugin. This does not have a short name (like \f(CW\*(C`perl\*(C'\fR), but must be specified
in full.
.IP "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)" 4
.IX Item "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.Sp
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.IP "Template Toolkit (plugin: tt2)" 4
.IX Item "Template Toolkit (plugin: tt2)"
Valid forms are:
.Sp
.Vb 3
\&  [% | l(arg1,argn) %]string[% END %]
\&  [% \*(Aqstring\*(Aq | l(arg1,argn) %]
\&  [% l(\*(Aqstring\*(Aq,arg1,argn) %]
\&
\&  FILTER and | are interchangeable
\&  l and loc are interchangeable
\&  args are optional
.Ve
.IP "Text::Template (plugin: text)" 4
.IX Item "Text::Template (plugin: text)"
Sentences between \f(CW\*(C`STARTxxx\*(C'\fR and \f(CW\*(C`ENDxxx\*(C'\fR are extracted individually.
.IP "\s-1YAML \s0(plugin: yaml)" 4
.IX Item "YAML (plugin: yaml)"
Valid forms are _\*(L"string\*(R" or _'string', eg:
.Sp
.Vb 2
\&    title: _"My title"
\&    desc:  _\*(AqMy "quoted" string\*(Aq
.Ve
.Sp
Quotes do not have to be escaped, so you could also do:
.Sp
.Vb 1
\&    desc:  _"My "quoted" string"
.Ve
.IP "HTML::FormFu (plugin: formfu)" 4
.IX Item "HTML::FormFu (plugin: formfu)"
HTML::FormFu uses a config-file to generate forms, with built in
support for localizing errors, labels etc.
.Sp
We extract the text after \f(CW\*(C`_loc: \*(C'\fR:
    content_loc: this is the string
    message_loc: ['Max string length: [_1]', 10]
.IP "Generic Template (plugin: generic)" 4
.IX Item "Generic Template (plugin: generic)"
Strings inside {{...}} are extracted.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructor"
.IX Subsection "Constructor"
.Vb 1
\&    new()
\&
\&    new(
\&        plugins   => {...},
\&        warnings  => 1 | 0,
\&        verbose   => 0 | 1 | 2 | 3,
\&    )
.Ve
.PP
See \*(L"Plugins\*(R", \*(L"Warnings\*(R" and \*(L"Verbose\*(R" for details
.SS "Plugins"
.IX Subsection "Plugins"
.Vb 1
\&    $ext\->plugins({...});
.Ve
.PP
Locale::Maketext::Extract uses plugins (see below for the list)
to parse different formats.
.PP
Each plugin can also specify which file types it can parse.
.PP
.Vb 3
\&    # use only the YAML plugin
\&    # only parse files with the default extension list defined in the plugin
\&    # ie .yaml .yml .conf
\&
\&    $ext\->plugins({
\&        yaml => [],
\&    })
\&
\&
\&    # use only the Perl plugin
\&    # parse all file types
\&
\&    $ext\->plugins({
\&        perl => \*(Aq*\*(Aq
\&    })
\&
\&    $ext\->plugins({
\&        tt2  => [
\&            \*(Aqtt\*(Aq,              # matches base filename against /\e.tt$/
\&            qr/\e.tt2?\e./,      # matches base filename against regex
\&            \e&my_filter,       # codref called
\&        ]
\&    })
\&
\&    sub my_filter {
\&        my ($base_filename,$path_to_file) = @_;
\&
\&        return 1 | 0;
\&    }
\&
\&    # Specify your own parser
\&    # only parse files with the default extension list defined in the plugin
\&
\&    $ext\->plugins({
\&        \*(AqMy::Extract::Parser\*(Aq  => []
\&    })
.Ve
.PP
By default, if no plugins are specified, it first tries to determine which
plugins are intended specifically for the file type and uses them. If no
such plugins are found, it then uses all of the builtin plugins, overriding
the file types specified in each.
.PP
\fIAvailable plugins\fR
.IX Subsection "Available plugins"
.ie n .IP """perl""    : Locale::Maketext::Extract::Plugin::Perl" 4
.el .IP "\f(CWperl\fR    : Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "perl : Locale::Maketext::Extract::Plugin::Perl"
For a slightly more accurate but much slower Perl parser, you can use
the \s-1PPI\s0 plugin. This does not have a short name, but must be specified in
full, ie: Locale::Maketext::Extract::Plugin::PPI
.ie n .IP """tt2""     : Locale::Maketext::Extract::Plugin::TT2" 4
.el .IP "\f(CWtt2\fR     : Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "tt2 : Locale::Maketext::Extract::Plugin::TT2"
.PD 0
.ie n .IP """yaml""    : Locale::Maketext::Extract::Plugin::YAML" 4
.el .IP "\f(CWyaml\fR    : Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "yaml : Locale::Maketext::Extract::Plugin::YAML"
.ie n .IP """formfu""  : Locale::Maketext::Extract::Plugin::FormFu" 4
.el .IP "\f(CWformfu\fR  : Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "formfu : Locale::Maketext::Extract::Plugin::FormFu"
.ie n .IP """mason""   : Locale::Maketext::Extract::Plugin::Mason" 4
.el .IP "\f(CWmason\fR   : Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "mason : Locale::Maketext::Extract::Plugin::Mason"
.ie n .IP """text""    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.el .IP "\f(CWtext\fR    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "text : Locale::Maketext::Extract::Plugin::TextTemplate"
.ie n .IP """generic"" : Locale::Maketext::Extract::Plugin::Generic" 4
.el .IP "\f(CWgeneric\fR : Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "generic : Locale::Maketext::Extract::Plugin::Generic"
.PD
.PP
Also, see Locale::Maketext::Extract::Plugin::Base for details of how to
write your own plugin.
.SS "Warnings"
.IX Subsection "Warnings"
Because the \s-1YAML\s0 and \s-1TT2\s0 plugins use proper parsers, rather than just regexes,
if a source file is not valid and it is unable to parse the file, then the
parser will throw an error and abort parsing.
.PP
The next enabled plugin will be tried.
.PP
By default, you will not see these errors.  If you would like to see them,
then enable warnings via \fInew()\fR. All parse errors will be printed to \s-1STDERR.\s0
.PP
Also, if developing your own plugin, turn on warnings to see any errors that
result from loading your plugin.
.SS "Verbose"
.IX Subsection "Verbose"
If you would like to see which files have been processed, which plugins were
used, and which strings were extracted, then enable \f(CW\*(C`verbose\*(C'\fR. If no
acceptable plugin was found, or no strings were extracted, then the file
is not listed:
.PP
.Vb 1
\&      $ext = Locale::Extract\->new( verbose => 1 | 2 | 3);
\&
\&   OR
\&      xgettext.pl ... \-v           # files reported
\&      xgettext.pl ... \-v \-v        # files and plugins reported
\&      xgettext.pl ... \-v \-v \-v     # files, plugins and strings reported
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.Vb 6
\&    header, set_header
\&    lexicon, set_lexicon, msgstr, set_msgstr
\&    entries, set_entries, entry, add_entry, del_entry
\&    compiled_entries, set_compiled_entries, compiled_entry,
\&    add_compiled_entry, del_compiled_entry
\&    clear
.Ve
.SS "\s-1PO\s0 File manipulation"
.IX Subsection "PO File manipulation"
\fImethod read_po ($file)\fR
.IX Subsection "method read_po ($file)"
.PP
\fImethod write_po ($file, \f(CI$add_format_marker\fI?)\fR
.IX Subsection "method write_po ($file, $add_format_marker?)"
.SS "Extraction"
.IX Subsection "Extraction"
.Vb 2
\&    extract
\&    extract_file
.Ve
.SS "Compilation"
.IX Subsection "Compilation"
\fIcompile($entries_are_in_gettext_style?)\fR
.IX Subsection "compile($entries_are_in_gettext_style?)"
.PP
Merges the \f(CW\*(C`entries\*(C'\fR into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
If \f(CW$entries_are_in_gettext_style\fR is true, the previously extracted entries
are assumed to be in the \fBGettext\fR style (e.g. \f(CW%1\fR).
.PP
Otherwise they are assumed to be in \fBMaketext\fR style (e.g. \f(CW\*(C`[_1]\*(C'\fR) and are
converted into \fBGettext\fR style before merging into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
The \f(CW\*(C`entries\*(C'\fR are \fInot\fR cleared after each compilation; use
\&\f(CW\*(C`\-\*(C'\fR\fIset_entries()\fR> to clear them if you need to extract from sources with
varying styles.
.PP
\fInormalize_space\fR
.IX Subsection "normalize_space"
.SS "Lexicon accessors"
.IX Subsection "Lexicon accessors"
.Vb 3
\&    msgids, has_msgid,
\&    msgstr, set_msgstr
\&    msg_positions, msg_variables, msg_format, msg_out
.Ve
.SS "Internal utilities"
.IX Subsection "Internal utilities"
.Vb 5
\&    _default_header
\&    _maketext_to_gettext
\&    _escape
\&    _format
\&    _plugins_specifically_for_file
.Ve
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Thanks to Jesse Vincent for contributing to an early version of this
module.
.PP
Also to Alain Barbet, who effectively re-wrote the source parser with a
flex-like algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
xgettext.pl, Locale::Maketext, Locale::Maketext::Lexicon
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract5.16.3pm            0100644 0001750 0001750 00000040444 12566242631 026425  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract 3"
.TH Locale::Maketext::Extract 3 "2011-07-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract \- Extract translatable strings from source
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    my $Ext = Locale::Maketext::Extract\->new;
\&    $Ext\->read_po(\*(Aqmessages.po\*(Aq);
\&    $Ext\->extract_file($_) for <*.pl>;
\&
\&    # Set $entries_are_in_gettext_format if the .pl files above use
\&    # loc(\*(Aq%1\*(Aq) instead of loc(\*(Aq[_1]\*(Aq)
\&    $Ext\->compile($entries_are_in_gettext_format);
\&
\&    $Ext\->write_po(\*(Aqmessages.po\*(Aq);
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    ### Specifying parser plugins ###
\&
\&    my $Ext = Locale::Maketext::Extract\->new(
\&
\&        # Specify which parser plugins to use
\&        plugins => {
\&
\&            # Use Perl parser, process files with extension .pl .pm .cgi
\&            perl => [],
\&
\&            # Use YAML parser, process all files
\&            yaml => [\*(Aq*\*(Aq],
\&
\&            # Use TT2 parser, process files with extension .tt2 .tt .html
\&            # or which match the regex
\&            tt2  => [
\&                \*(Aqtt2\*(Aq,
\&                \*(Aqtt\*(Aq,
\&                \*(Aqhtml\*(Aq,
\&                qr/\e.tt2?\e./
\&            ],
\&
\&            # Use My::Module as a parser for all files
\&            \*(AqMy::Module\*(Aq => [\*(Aq*\*(Aq],
\&
\&        },
\&
\&        # Warn if a parser can\*(Aqt process a file or problems loading a plugin
\&        warnings => 1,
\&
\&        # List processed files
\&        verbose => 1,
\&
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can extract translatable strings from files, and write
them back to \s-1PO\s0 files.  It can also parse existing \s-1PO\s0 files and merge
their contents with newly extracted strings.
.PP
A command-line utility, xgettext.pl, is installed with this module
as well.
.PP
The format parsers are loaded as plugins, so it is possible to define
your own parsers.
.PP
Following formats of input files are supported:
.IP "Perl source files  (plugin: perl)" 4
.IX Item "Perl source files  (plugin: perl)"
Valid localization function names are: \f(CW\*(C`translate\*(C'\fR, \f(CW\*(C`maketext\*(C'\fR,
\&\f(CW\*(C`gettext\*(C'\fR, \f(CW\*(C`loc\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`_\*(C'\fR and \f(CW\*(C`_\|_\*(C'\fR.
.Sp
For a slightly more accurate, but much slower Perl parser, you can  use the \s-1PPI\s0
plugin. This does not have a short name (like \f(CW\*(C`perl\*(C'\fR), but must be specified
in full.
.IP "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)" 4
.IX Item "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.Sp
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.IP "Template Toolkit (plugin: tt2)" 4
.IX Item "Template Toolkit (plugin: tt2)"
Valid forms are:
.Sp
.Vb 3
\&  [% | l(arg1,argn) %]string[% END %]
\&  [% \*(Aqstring\*(Aq | l(arg1,argn) %]
\&  [% l(\*(Aqstring\*(Aq,arg1,argn) %]
\&
\&  FILTER and | are interchangeable
\&  l and loc are interchangeable
\&  args are optional
.Ve
.IP "Text::Template (plugin: text)" 4
.IX Item "Text::Template (plugin: text)"
Sentences between \f(CW\*(C`STARTxxx\*(C'\fR and \f(CW\*(C`ENDxxx\*(C'\fR are extracted individually.
.IP "\s-1YAML\s0 (plugin: yaml)" 4
.IX Item "YAML (plugin: yaml)"
Valid forms are _\*(L"string\*(R" or _'string', eg:
.Sp
.Vb 2
\&    title: _"My title"
\&    desc:  _\*(AqMy "quoted" string\*(Aq
.Ve
.Sp
Quotes do not have to be escaped, so you could also do:
.Sp
.Vb 1
\&    desc:  _"My "quoted" string"
.Ve
.IP "HTML::FormFu (plugin: formfu)" 4
.IX Item "HTML::FormFu (plugin: formfu)"
HTML::FormFu uses a config-file to generate forms, with built in
support for localizing errors, labels etc.
.Sp
We extract the text after \f(CW\*(C`_loc: \*(C'\fR:
    content_loc: this is the string
    message_loc: ['Max string length: [_1]', 10]
.IP "Generic Template (plugin: generic)" 4
.IX Item "Generic Template (plugin: generic)"
Strings inside {{...}} are extracted.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructor"
.IX Subsection "Constructor"
.Vb 1
\&    new()
\&
\&    new(
\&        plugins   => {...},
\&        warnings  => 1 | 0,
\&        verbose   => 0 | 1 | 2 | 3,
\&    )
.Ve
.PP
See \*(L"Plugins\*(R", \*(L"Warnings\*(R" and \*(L"Verbose\*(R" for details
.SS "Plugins"
.IX Subsection "Plugins"
.Vb 1
\&    $ext\->plugins({...});
.Ve
.PP
Locale::Maketext::Extract uses plugins (see below for the list)
to parse different formats.
.PP
Each plugin can also specify which file types it can parse.
.PP
.Vb 3
\&    # use only the YAML plugin
\&    # only parse files with the default extension list defined in the plugin
\&    # ie .yaml .yml .conf
\&
\&    $ext\->plugins({
\&        yaml => [],
\&    })
\&
\&
\&    # use only the Perl plugin
\&    # parse all file types
\&
\&    $ext\->plugins({
\&        perl => \*(Aq*\*(Aq
\&    })
\&
\&    $ext\->plugins({
\&        tt2  => [
\&            \*(Aqtt\*(Aq,              # matches base filename against /\e.tt$/
\&            qr/\e.tt2?\e./,      # matches base filename against regex
\&            \e&my_filter,       # codref called
\&        ]
\&    })
\&
\&    sub my_filter {
\&        my ($base_filename,$path_to_file) = @_;
\&
\&        return 1 | 0;
\&    }
\&
\&    # Specify your own parser
\&    # only parse files with the default extension list defined in the plugin
\&
\&    $ext\->plugins({
\&        \*(AqMy::Extract::Parser\*(Aq  => []
\&    })
.Ve
.PP
By default, if no plugins are specified, then it uses all of the builtin
plugins, and overrides the file types specified in each plugin
 \- instead, each plugin is tried for every file.
.PP
\fIAvailable plugins\fR
.IX Subsection "Available plugins"
.ie n .IP """perl""    : Locale::Maketext::Extract::Plugin::Perl" 4
.el .IP "\f(CWperl\fR    : Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "perl    : Locale::Maketext::Extract::Plugin::Perl"
For a slightly more accurate but much slower Perl parser, you can use
the \s-1PPI\s0 plugin. This does not have a short name, but must be specified in
full, ie: Locale::Maketext::Extract::Plugin::PPI
.ie n .IP """tt2""     : Locale::Maketext::Extract::Plugin::TT2" 4
.el .IP "\f(CWtt2\fR     : Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "tt2     : Locale::Maketext::Extract::Plugin::TT2"
.PD 0
.ie n .IP """yaml""    : Locale::Maketext::Extract::Plugin::YAML" 4
.el .IP "\f(CWyaml\fR    : Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "yaml    : Locale::Maketext::Extract::Plugin::YAML"
.ie n .IP """formfu""  : Locale::Maketext::Extract::Plugin::FormFu" 4
.el .IP "\f(CWformfu\fR  : Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "formfu  : Locale::Maketext::Extract::Plugin::FormFu"
.ie n .IP """mason""   : Locale::Maketext::Extract::Plugin::Mason" 4
.el .IP "\f(CWmason\fR   : Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "mason   : Locale::Maketext::Extract::Plugin::Mason"
.ie n .IP """text""    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.el .IP "\f(CWtext\fR    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "text    : Locale::Maketext::Extract::Plugin::TextTemplate"
.ie n .IP """generic"" : Locale::Maketext::Extract::Plugin::Generic" 4
.el .IP "\f(CWgeneric\fR : Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "generic : Locale::Maketext::Extract::Plugin::Generic"
.PD
.PP
Also, see Locale::Maketext::Extract::Plugin::Base for details of how to
write your own plugin.
.SS "Warnings"
.IX Subsection "Warnings"
Because the \s-1YAML\s0 and \s-1TT2\s0 plugins use proper parsers, rather than just regexes,
if a source file is not valid and it is unable to parse the file, then the
parser will throw an error and abort parsing.
.PP
The next enabled plugin will be tried.
.PP
By default, you will not see these errors.  If you would like to see them,
then enable warnings via \fInew()\fR. All parse errors will be printed to \s-1STDERR\s0.
.PP
Also, if developing your own plugin, turn on warnings to see any errors that
result from loading your plugin.
.SS "Verbose"
.IX Subsection "Verbose"
If you would like to see which files have been processed, which plugins were
used, and which strings were extracted, then enable \f(CW\*(C`verbose\*(C'\fR. If no
acceptable plugin was found, or no strings were extracted, then the file
is not listed:
.PP
.Vb 1
\&      $ext = Locale::Extract\->new( verbose => 1 | 2 | 3);
\&
\&   OR
\&      xgettext.pl ... \-v           # files reported
\&      xgettext.pl ... \-v \-v        # files and plugins reported
\&      xgettext.pl ... \-v \-v \-v     # files, plugins and strings reported
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.Vb 6
\&    header, set_header
\&    lexicon, set_lexicon, msgstr, set_msgstr
\&    entries, set_entries, entry, add_entry, del_entry
\&    compiled_entries, set_compiled_entries, compiled_entry,
\&    add_compiled_entry, del_compiled_entry
\&    clear
.Ve
.SS "\s-1PO\s0 File manipulation"
.IX Subsection "PO File manipulation"
\fImethod read_po ($file)\fR
.IX Subsection "method read_po ($file)"
.PP
\fImethod write_po ($file, \f(CI$add_format_marker\fI?)\fR
.IX Subsection "method write_po ($file, $add_format_marker?)"
.SS "Extraction"
.IX Subsection "Extraction"
.Vb 2
\&    extract
\&    extract_file
.Ve
.SS "Compilation"
.IX Subsection "Compilation"
\fIcompile($entries_are_in_gettext_style?)\fR
.IX Subsection "compile($entries_are_in_gettext_style?)"
.PP
Merges the \f(CW\*(C`entries\*(C'\fR into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
If \f(CW$entries_are_in_gettext_style\fR is true, the previously extracted entries
are assumed to be in the \fBGettext\fR style (e.g. \f(CW%1\fR).
.PP
Otherwise they are assumed to be in \fBMaketext\fR style (e.g. \f(CW\*(C`[_1]\*(C'\fR) and are
converted into \fBGettext\fR style before merging into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
The \f(CW\*(C`entries\*(C'\fR are \fInot\fR cleared after each compilation; use
\&\f(CW\*(C`\-\*(C'\fR\fIset_entries()\fR> to clear them if you need to extract from sources with
varying styles.
.PP
\fInormalize_space\fR
.IX Subsection "normalize_space"
.SS "Lexicon accessors"
.IX Subsection "Lexicon accessors"
.Vb 3
\&    msgids, has_msgid,
\&    msgstr, set_msgstr
\&    msg_positions, msg_variables, msg_format, msg_out
.Ve
.SS "Internal utilities"
.IX Subsection "Internal utilities"
.Vb 4
\&    _default_header
\&    _maketext_to_gettext
\&    _escape
\&    _format
.Ve
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Thanks to Jesse Vincent for contributing to an early version of this
module.
.PP
Also to Alain Barbet, who effectively re-wrote the source parser with a
flex-like algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
xgettext.pl, Locale::Maketext, Locale::Maketext::Lexicon
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract5.18.3pm            0100644 0001750 0001750 00000040710 12566242634 026426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract 3"
.TH Locale::Maketext::Extract 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract \- Extract translatable strings from source
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    my $Ext = Locale::Maketext::Extract\->new;
\&    $Ext\->read_po(\*(Aqmessages.po\*(Aq);
\&    $Ext\->extract_file($_) for <*.pl>;
\&
\&    # Set $entries_are_in_gettext_format if the .pl files above use
\&    # loc(\*(Aq%1\*(Aq) instead of loc(\*(Aq[_1]\*(Aq)
\&    $Ext\->compile($entries_are_in_gettext_format);
\&
\&    $Ext\->write_po(\*(Aqmessages.po\*(Aq);
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    ### Specifying parser plugins ###
\&
\&    my $Ext = Locale::Maketext::Extract\->new(
\&
\&        # Specify which parser plugins to use
\&        plugins => {
\&
\&            # Use Perl parser, process files with extension .pl .pm .cgi
\&            perl => [],
\&
\&            # Use YAML parser, process all files
\&            yaml => [\*(Aq*\*(Aq],
\&
\&            # Use TT2 parser, process files with extension .tt2 .tt .html
\&            # or which match the regex
\&            tt2  => [
\&                \*(Aqtt2\*(Aq,
\&                \*(Aqtt\*(Aq,
\&                \*(Aqhtml\*(Aq,
\&                qr/\e.tt2?\e./
\&            ],
\&
\&            # Use My::Module as a parser for all files
\&            \*(AqMy::Module\*(Aq => [\*(Aq*\*(Aq],
\&
\&        },
\&
\&        # Warn if a parser can\*(Aqt process a file or problems loading a plugin
\&        warnings => 1,
\&
\&        # List processed files
\&        verbose => 1,
\&
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can extract translatable strings from files, and write
them back to \s-1PO\s0 files.  It can also parse existing \s-1PO\s0 files and merge
their contents with newly extracted strings.
.PP
A command-line utility, xgettext.pl, is installed with this module
as well.
.PP
The format parsers are loaded as plugins, so it is possible to define
your own parsers.
.PP
Following formats of input files are supported:
.IP "Perl source files  (plugin: perl)" 4
.IX Item "Perl source files (plugin: perl)"
Valid localization function names are: \f(CW\*(C`translate\*(C'\fR, \f(CW\*(C`maketext\*(C'\fR,
\&\f(CW\*(C`gettext\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`loc\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`_\*(C'\fR and \f(CW\*(C`_\|_\*(C'\fR.
.Sp
For a slightly more accurate, but much slower Perl parser, you can  use the \s-1PPI\s0
plugin. This does not have a short name (like \f(CW\*(C`perl\*(C'\fR), but must be specified
in full.
.IP "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)" 4
.IX Item "HTML::Mason (Mason 1) and Mason (Mason 2) (plugin: mason)"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.Sp
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.IP "Template Toolkit (plugin: tt2)" 4
.IX Item "Template Toolkit (plugin: tt2)"
Valid forms are:
.Sp
.Vb 3
\&  [% | l(arg1,argn) %]string[% END %]
\&  [% \*(Aqstring\*(Aq | l(arg1,argn) %]
\&  [% l(\*(Aqstring\*(Aq,arg1,argn) %]
\&
\&  FILTER and | are interchangeable
\&  l and loc are interchangeable
\&  args are optional
.Ve
.IP "Text::Template (plugin: text)" 4
.IX Item "Text::Template (plugin: text)"
Sentences between \f(CW\*(C`STARTxxx\*(C'\fR and \f(CW\*(C`ENDxxx\*(C'\fR are extracted individually.
.IP "\s-1YAML \s0(plugin: yaml)" 4
.IX Item "YAML (plugin: yaml)"
Valid forms are _\*(L"string\*(R" or _'string', eg:
.Sp
.Vb 2
\&    title: _"My title"
\&    desc:  _\*(AqMy "quoted" string\*(Aq
.Ve
.Sp
Quotes do not have to be escaped, so you could also do:
.Sp
.Vb 1
\&    desc:  _"My "quoted" string"
.Ve
.IP "HTML::FormFu (plugin: formfu)" 4
.IX Item "HTML::FormFu (plugin: formfu)"
HTML::FormFu uses a config-file to generate forms, with built in
support for localizing errors, labels etc.
.Sp
We extract the text after \f(CW\*(C`_loc: \*(C'\fR:
    content_loc: this is the string
    message_loc: ['Max string length: [_1]', 10]
.IP "Generic Template (plugin: generic)" 4
.IX Item "Generic Template (plugin: generic)"
Strings inside {{...}} are extracted.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructor"
.IX Subsection "Constructor"
.Vb 1
\&    new()
\&
\&    new(
\&        plugins   => {...},
\&        warnings  => 1 | 0,
\&        verbose   => 0 | 1 | 2 | 3,
\&    )
.Ve
.PP
See \*(L"Plugins\*(R", \*(L"Warnings\*(R" and \*(L"Verbose\*(R" for details
.SS "Plugins"
.IX Subsection "Plugins"
.Vb 1
\&    $ext\->plugins({...});
.Ve
.PP
Locale::Maketext::Extract uses plugins (see below for the list)
to parse different formats.
.PP
Each plugin can also specify which file types it can parse.
.PP
.Vb 3
\&    # use only the YAML plugin
\&    # only parse files with the default extension list defined in the plugin
\&    # ie .yaml .yml .conf
\&
\&    $ext\->plugins({
\&        yaml => [],
\&    })
\&
\&
\&    # use only the Perl plugin
\&    # parse all file types
\&
\&    $ext\->plugins({
\&        perl => \*(Aq*\*(Aq
\&    })
\&
\&    $ext\->plugins({
\&        tt2  => [
\&            \*(Aqtt\*(Aq,              # matches base filename against /\e.tt$/
\&            qr/\e.tt2?\e./,      # matches base filename against regex
\&            \e&my_filter,       # codref called
\&        ]
\&    })
\&
\&    sub my_filter {
\&        my ($base_filename,$path_to_file) = @_;
\&
\&        return 1 | 0;
\&    }
\&
\&    # Specify your own parser
\&    # only parse files with the default extension list defined in the plugin
\&
\&    $ext\->plugins({
\&        \*(AqMy::Extract::Parser\*(Aq  => []
\&    })
.Ve
.PP
By default, if no plugins are specified, it first tries to determine which
plugins are intended specifically for the file type and uses them. If no
such plugins are found, it then uses all of the builtin plugins, overriding
the file types specified in each.
.PP
\fIAvailable plugins\fR
.IX Subsection "Available plugins"
.ie n .IP """perl""    : Locale::Maketext::Extract::Plugin::Perl" 4
.el .IP "\f(CWperl\fR    : Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "perl : Locale::Maketext::Extract::Plugin::Perl"
For a slightly more accurate but much slower Perl parser, you can use
the \s-1PPI\s0 plugin. This does not have a short name, but must be specified in
full, ie: Locale::Maketext::Extract::Plugin::PPI
.ie n .IP """tt2""     : Locale::Maketext::Extract::Plugin::TT2" 4
.el .IP "\f(CWtt2\fR     : Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "tt2 : Locale::Maketext::Extract::Plugin::TT2"
.PD 0
.ie n .IP """yaml""    : Locale::Maketext::Extract::Plugin::YAML" 4
.el .IP "\f(CWyaml\fR    : Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "yaml : Locale::Maketext::Extract::Plugin::YAML"
.ie n .IP """formfu""  : Locale::Maketext::Extract::Plugin::FormFu" 4
.el .IP "\f(CWformfu\fR  : Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "formfu : Locale::Maketext::Extract::Plugin::FormFu"
.ie n .IP """mason""   : Locale::Maketext::Extract::Plugin::Mason" 4
.el .IP "\f(CWmason\fR   : Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "mason : Locale::Maketext::Extract::Plugin::Mason"
.ie n .IP """text""    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.el .IP "\f(CWtext\fR    : Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "text : Locale::Maketext::Extract::Plugin::TextTemplate"
.ie n .IP """generic"" : Locale::Maketext::Extract::Plugin::Generic" 4
.el .IP "\f(CWgeneric\fR : Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "generic : Locale::Maketext::Extract::Plugin::Generic"
.PD
.PP
Also, see Locale::Maketext::Extract::Plugin::Base for details of how to
write your own plugin.
.SS "Warnings"
.IX Subsection "Warnings"
Because the \s-1YAML\s0 and \s-1TT2\s0 plugins use proper parsers, rather than just regexes,
if a source file is not valid and it is unable to parse the file, then the
parser will throw an error and abort parsing.
.PP
The next enabled plugin will be tried.
.PP
By default, you will not see these errors.  If you would like to see them,
then enable warnings via \fInew()\fR. All parse errors will be printed to \s-1STDERR.\s0
.PP
Also, if developing your own plugin, turn on warnings to see any errors that
result from loading your plugin.
.SS "Verbose"
.IX Subsection "Verbose"
If you would like to see which files have been processed, which plugins were
used, and which strings were extracted, then enable \f(CW\*(C`verbose\*(C'\fR. If no
acceptable plugin was found, or no strings were extracted, then the file
is not listed:
.PP
.Vb 1
\&      $ext = Locale::Extract\->new( verbose => 1 | 2 | 3);
\&
\&   OR
\&      xgettext.pl ... \-v           # files reported
\&      xgettext.pl ... \-v \-v        # files and plugins reported
\&      xgettext.pl ... \-v \-v \-v     # files, plugins and strings reported
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.Vb 6
\&    header, set_header
\&    lexicon, set_lexicon, msgstr, set_msgstr
\&    entries, set_entries, entry, add_entry, del_entry
\&    compiled_entries, set_compiled_entries, compiled_entry,
\&    add_compiled_entry, del_compiled_entry
\&    clear
.Ve
.SS "\s-1PO\s0 File manipulation"
.IX Subsection "PO File manipulation"
\fImethod read_po ($file)\fR
.IX Subsection "method read_po ($file)"
.PP
\fImethod write_po ($file, \f(CI$add_format_marker\fI?)\fR
.IX Subsection "method write_po ($file, $add_format_marker?)"
.SS "Extraction"
.IX Subsection "Extraction"
.Vb 2
\&    extract
\&    extract_file
.Ve
.SS "Compilation"
.IX Subsection "Compilation"
\fIcompile($entries_are_in_gettext_style?)\fR
.IX Subsection "compile($entries_are_in_gettext_style?)"
.PP
Merges the \f(CW\*(C`entries\*(C'\fR into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
If \f(CW$entries_are_in_gettext_style\fR is true, the previously extracted entries
are assumed to be in the \fBGettext\fR style (e.g. \f(CW%1\fR).
.PP
Otherwise they are assumed to be in \fBMaketext\fR style (e.g. \f(CW\*(C`[_1]\*(C'\fR) and are
converted into \fBGettext\fR style before merging into \f(CW\*(C`compiled_entries\*(C'\fR.
.PP
The \f(CW\*(C`entries\*(C'\fR are \fInot\fR cleared after each compilation; use
\&\f(CW\*(C`\-\*(C'\fR\fIset_entries()\fR> to clear them if you need to extract from sources with
varying styles.
.PP
\fInormalize_space\fR
.IX Subsection "normalize_space"
.SS "Lexicon accessors"
.IX Subsection "Lexicon accessors"
.Vb 3
\&    msgids, has_msgid,
\&    msgstr, set_msgstr
\&    msg_positions, msg_variables, msg_format, msg_out
.Ve
.SS "Internal utilities"
.IX Subsection "Internal utilities"
.Vb 5
\&    _default_header
\&    _maketext_to_gettext
\&    _escape
\&    _format
\&    _plugins_specifically_for_file
.Ve
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Thanks to Jesse Vincent for contributing to an early version of this
module.
.PP
Also to Alain Barbet, who effectively re-wrote the source parser with a
flex-like algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
xgettext.pl, Locale::Maketext, Locale::Maketext::Lexicon
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::Base.3pm  0100644 0001750 0001750 00000024020 12566242634 030430  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Base 3"
.TH Locale::Maketext::Extract::Plugin::Base 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Base \- Base module for format parser plugins
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package My::Parser::Plugin;
\&    use base qw(Locale::Maketext::Extract::Plugin::Base);
\&
\&    sub file_types {
\&        return [qw( ext ext2 )]
\&    }
\&
\&    sub extract {
\&        my $self = shift;
\&        local $_ = shift;
\&
\&        my $line = 1;
\&
\&        while (my $found = $self\->routine_to_extract_strings) {
\&            $self\->add_entry($str,[$filename,$line,$vars])
\&        }
\&
\&        return;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All format parser plugins in Locale::Maketext::Extract inherit from
Locale::Maketext::Extract::Plugin::Base.
.PP
If you want to write your own custom parser plugin, you will need to inherit
from this module, and provide \f(CW\*(C`file_types()\*(C'\fR and \f(CW\*(C`extract()\*(C'\fR methods,
as shown above.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 3
\&    $plugin = My::Parser\->new(
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
.Ve
.IP "\fIadd_entry()\fR" 4
.IX Item "add_entry()"
.Vb 1
\&    $plugin\->add_entry($str,$line,$vars)
.Ve
.ie n .IP """entries()""" 4
.el .IP "\f(CWentries()\fR" 4
.IX Item "entries()"
.Vb 1
\&    $entries = $plugin\->entries;
.Ve
.ie n .IP """clear()""" 4
.el .IP "\f(CWclear()\fR" 4
.IX Item "clear()"
.Vb 1
\&    $plugin\->clear
.Ve
.Sp
Clears all stored entries.
.IP "\fIfile_types()\fR" 4
.IX Item "file_types()"
.Vb 1
\&    @default_file_types = $plugin\->file_types
.Ve
.Sp
Returns a list of recognised file types that your module knows how to parse.
.Sp
Each file type can be one of:
.RS 4
.IP "\(bu" 4
A plain string
.Sp
.Vb 2
\&   \*(Aqpl\*(Aq  => base filename is matched against qr/\e.pl$/
\&   \*(Aq*\*(Aq   => all files are accepted
.Ve
.IP "\(bu" 4
A regex
.Sp
.Vb 1
\&   qr/\e.tt2?\e./ => base filename is matched against this regex
.Ve
.IP "\(bu" 4
A codref
.Sp
.Vb 2
\&    sub {}  => this codref is called as $coderef\->($base_filename,$path_to_file)
\&               It should return true or false
.Ve
.RE
.RS 4
.RE
.IP "\fIextract()\fR" 4
.IX Item "extract()"
.Vb 1
\&    $plugin\->extract($filecontents);
.Ve
.Sp
\&\fIextract()\fR is the method that will be called to process the contents of the
current file.
.Sp
When it finds a string that should be extracted, it should call
.Sp
.Vb 1
\&   $self\->add_entry($string,$line,$vars])
.Ve
.Sp
where \f(CW$vars\fR refers to any arguments that are being passed to the localise
function. For instance:
.Sp
.Vb 1
\&   l("You found [quant,_1,file,files]",files_found)
\&
\&     string: "You found [quant,_1,file,files]"
\&     vars  : (files_found)
.Ve
.Sp
\&\s-1IMPORTANT:\s0 a single plugin instance is used for all files, so if you plan
on storing state information in the \f(CW$plugin\fR object, this should be cleared
out at the beginning of \f(CW\*(C`extract()\*(C'\fR
.IP "\fIknown_file_type()\fR" 4
.IX Item "known_file_type()"
.Vb 3
\&    if ($plugin\->known_file_type($filename_with_path)) {
\&        ....
\&    }
.Ve
.Sp
Determines whether the current file should be handled by this parser, based
either on the list of file_types specified when this object was created,
or the default file_types specified in the module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::PPI" 4
.IX Item "Locale::Maketext::Extract::Plugin::PPI"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley [\s-1DRTECH\s0] <clinton@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Locale::Maketext::Extract::Plugin::Base5.16.3pm                                                     0100644 0001750 0001750 00000023735 12566242631 030674  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Base 3"
.TH Locale::Maketext::Extract::Plugin::Base 3 "2011-03-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Base \- Base module for format parser plugins
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package My::Parser::Plugin;
\&    use base qw(Locale::Maketext::Extract::Plugin::Base);
\&
\&    sub file_types {
\&        return [qw( ext ext2 )]
\&    }
\&
\&    sub extract {
\&        my $self = shift;
\&        local $_ = shift;
\&
\&        my $line = 1;
\&
\&        while (my $found = $self\->routine_to_extract_strings) {
\&            $self\->add_entry($str,[$filename,$line,$vars])
\&        }
\&
\&        return;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All format parser plugins in Locale::Maketext::Extract inherit from
Locale::Maketext::Extract::Plugin::Base.
.PP
If you want to write your own custom parser plugin, you will need to inherit
from this module, and provide \f(CW\*(C`file_types()\*(C'\fR and \f(CW\*(C`extract()\*(C'\fR methods,
as shown above.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 3
\&    $plugin = My::Parser\->new(
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
.Ve
.IP "\fIadd_entry()\fR" 4
.IX Item "add_entry()"
.Vb 1
\&    $plugin\->add_entry($str,$line,$vars)
.Ve
.ie n .IP """entries()""" 4
.el .IP "\f(CWentries()\fR" 4
.IX Item "entries()"
.Vb 1
\&    $entries = $plugin\->entries;
.Ve
.ie n .IP """clear()""" 4
.el .IP "\f(CWclear()\fR" 4
.IX Item "clear()"
.Vb 1
\&    $plugin\->clear
.Ve
.Sp
Clears all stored entries.
.IP "\fIfile_types()\fR" 4
.IX Item "file_types()"
.Vb 1
\&    @default_file_types = $plugin\->file_types
.Ve
.Sp
Returns a list of recognised file types that your module knows how to parse.
.Sp
Each file type can be one of:
.RS 4
.IP "\(bu" 4
A plain string
.Sp
.Vb 2
\&   \*(Aqpl\*(Aq  => base filename is matched against qr/\e.pl$/
\&   \*(Aq*\*(Aq   => all files are accepted
.Ve
.IP "\(bu" 4
A regex
.Sp
.Vb 1
\&   qr/\e.tt2?\e./ => base filename is matched against this regex
.Ve
.IP "\(bu" 4
A codref
.Sp
.Vb 2
\&    sub {}  => this codref is called as $coderef\->($base_filename,$path_to_file)
\&               It should return true or false
.Ve
.RE
.RS 4
.RE
.IP "\fIextract()\fR" 4
.IX Item "extract()"
.Vb 1
\&    $plugin\->extract($filecontents);
.Ve
.Sp
\&\fIextract()\fR is the method that will be called to process the contents of the
current file.
.Sp
When it finds a string that should be extracted, it should call
.Sp
.Vb 1
\&   $self\->add_entry($string,$line,$vars])
.Ve
.Sp
where \f(CW$vars\fR refers to any arguments that are being passed to the localise
function. For instance:
.Sp
.Vb 1
\&   l("You found [quant,_1,file,files]",files_found)
\&
\&     string: "You found [quant,_1,file,files]"
\&     vars  : (files_found)
.Ve
.Sp
\&\s-1IMPORTANT:\s0 a single plugin instance is used for all files, so if you plan
on storing state information in the \f(CW$plugin\fR object, this should be cleared
out at the beginning of \f(CW\*(C`extract()\*(C'\fR
.IP "\fIknown_file_type()\fR" 4
.IX Item "known_file_type()"
.Vb 3
\&    if ($plugin\->known_file_type($filename_with_path)) {
\&        ....
\&    }
.Ve
.Sp
Determines whether the current file should be handled by this parser, based
either on the list of file_types specified when this object was created,
or the default file_types specified in the module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::PPI" 4
.IX Item "Locale::Maketext::Extract::Plugin::PPI"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley [\s-1DRTECH\s0] <clinton@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                   Locale::Maketext::Extract::Plugin::Base5.18.3pm                                                     0100644 0001750 0001750 00000024020 12566242634 030665  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Base 3"
.TH Locale::Maketext::Extract::Plugin::Base 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Base \- Base module for format parser plugins
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package My::Parser::Plugin;
\&    use base qw(Locale::Maketext::Extract::Plugin::Base);
\&
\&    sub file_types {
\&        return [qw( ext ext2 )]
\&    }
\&
\&    sub extract {
\&        my $self = shift;
\&        local $_ = shift;
\&
\&        my $line = 1;
\&
\&        while (my $found = $self\->routine_to_extract_strings) {
\&            $self\->add_entry($str,[$filename,$line,$vars])
\&        }
\&
\&        return;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All format parser plugins in Locale::Maketext::Extract inherit from
Locale::Maketext::Extract::Plugin::Base.
.PP
If you want to write your own custom parser plugin, you will need to inherit
from this module, and provide \f(CW\*(C`file_types()\*(C'\fR and \f(CW\*(C`extract()\*(C'\fR methods,
as shown above.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 3
\&    $plugin = My::Parser\->new(
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
.Ve
.IP "\fIadd_entry()\fR" 4
.IX Item "add_entry()"
.Vb 1
\&    $plugin\->add_entry($str,$line,$vars)
.Ve
.ie n .IP """entries()""" 4
.el .IP "\f(CWentries()\fR" 4
.IX Item "entries()"
.Vb 1
\&    $entries = $plugin\->entries;
.Ve
.ie n .IP """clear()""" 4
.el .IP "\f(CWclear()\fR" 4
.IX Item "clear()"
.Vb 1
\&    $plugin\->clear
.Ve
.Sp
Clears all stored entries.
.IP "\fIfile_types()\fR" 4
.IX Item "file_types()"
.Vb 1
\&    @default_file_types = $plugin\->file_types
.Ve
.Sp
Returns a list of recognised file types that your module knows how to parse.
.Sp
Each file type can be one of:
.RS 4
.IP "\(bu" 4
A plain string
.Sp
.Vb 2
\&   \*(Aqpl\*(Aq  => base filename is matched against qr/\e.pl$/
\&   \*(Aq*\*(Aq   => all files are accepted
.Ve
.IP "\(bu" 4
A regex
.Sp
.Vb 1
\&   qr/\e.tt2?\e./ => base filename is matched against this regex
.Ve
.IP "\(bu" 4
A codref
.Sp
.Vb 2
\&    sub {}  => this codref is called as $coderef\->($base_filename,$path_to_file)
\&               It should return true or false
.Ve
.RE
.RS 4
.RE
.IP "\fIextract()\fR" 4
.IX Item "extract()"
.Vb 1
\&    $plugin\->extract($filecontents);
.Ve
.Sp
\&\fIextract()\fR is the method that will be called to process the contents of the
current file.
.Sp
When it finds a string that should be extracted, it should call
.Sp
.Vb 1
\&   $self\->add_entry($string,$line,$vars])
.Ve
.Sp
where \f(CW$vars\fR refers to any arguments that are being passed to the localise
function. For instance:
.Sp
.Vb 1
\&   l("You found [quant,_1,file,files]",files_found)
\&
\&     string: "You found [quant,_1,file,files]"
\&     vars  : (files_found)
.Ve
.Sp
\&\s-1IMPORTANT:\s0 a single plugin instance is used for all files, so if you plan
on storing state information in the \f(CW$plugin\fR object, this should be cleared
out at the beginning of \f(CW\*(C`extract()\*(C'\fR
.IP "\fIknown_file_type()\fR" 4
.IX Item "known_file_type()"
.Vb 3
\&    if ($plugin\->known_file_type($filename_with_path)) {
\&        ....
\&    }
.Ve
.Sp
Determines whether the current file should be handled by this parser, based
either on the list of file_types specified when this object was created,
or the default file_types specified in the module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::PPI" 4
.IX Item "Locale::Maketext::Extract::Plugin::PPI"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley [\s-1DRTECH\s0] <clinton@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::FormFu.3pm0100644 0001750 0001750 00000020406 12566242634 030760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::FormFu 3"
.TH Locale::Maketext::Extract::Plugin::FormFu 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::FormFu \- FormFu format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::FormFu\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTML::FormFu uses a config-file to generate forms, with built in support
for localizing errors, labels etc.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    formfu
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
We extract the text after any key which ends in \f(CW\*(C`_loc\*(C'\fR:
.PP
.Vb 2
\&    content_loc: this is the string
\&    message_loc: [\*(AqMax length [_1]\*(Aq, 10]
.Ve
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".yaml" 4
.IX Item ".yaml"
.PD 0
.IP ".yml" 4
.IX Item ".yml"
.IP ".conf" 4
.IX Item ".conf"
.PD
.SH "REQUIRES"
.IX Header "REQUIRES"
\&\s-1YAML\s0
.SH "NOTES"
.IX Header "NOTES"
The docs for the \s-1YAML\s0 module describes it as alpha code. It is not as tolerant
of errors as YAML::Syck. However, because it is pure Perl, it is easy
to hook into.
.PP
I have seen it enter endless loops, so if xgettext.pl hangs, try running it
again with \f(CW\*(C`\-\-verbose \-\-verbose\*(C'\fR (twice) enabled, so that you can see if
the fault lies with \s-1YAML. \s0 If it does, either correct the \s-1YAML\s0 source file,
or use the file_types to exclude that file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "\s-1YAML\s0" 4
.IX Item "YAML"
.PD 0
.IP "HTML::FormFu" 4
.IX Item "HTML::FormFu"
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley <clint@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                          Locale::Maketext::Extract::Plugin::FormFu5.16.3pm                                                   0100644 0001750 0001750 00000020323 12566242631 031206  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::FormFu 3"
.TH Locale::Maketext::Extract::Plugin::FormFu 3 "2010-08-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::FormFu \- FormFu format parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::FormFu\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTML::FormFu uses a config-file to generate forms, with built in support
for localizing errors, labels etc.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    formfu
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
We extract the text after any key which ends in \f(CW\*(C`_loc\*(C'\fR:
.PP
.Vb 2
\&    content_loc: this is the string
\&    message_loc: [\*(AqMax length [_1]\*(Aq, 10]
.Ve
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".yaml" 4
.IX Item ".yaml"
.PD 0
.IP ".yml" 4
.IX Item ".yml"
.IP ".conf" 4
.IX Item ".conf"
.PD
.SH "REQUIRES"
.IX Header "REQUIRES"
\&\s-1YAML\s0
.SH "NOTES"
.IX Header "NOTES"
The docs for the \s-1YAML\s0 module describes it as alpha code. It is not as tolerant
of errors as YAML::Syck. However, because it is pure Perl, it is easy
to hook into.
.PP
I have seen it enter endless loops, so if xgettext.pl hangs, try running it
again with \f(CW\*(C`\-\-verbose \-\-verbose\*(C'\fR (twice) enabled, so that you can see if
the fault lies with \s-1YAML\s0.  If it does, either correct the \s-1YAML\s0 source file,
or use the file_types to exclude that file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "\s-1YAML\s0" 4
.IX Item "YAML"
.PD 0
.IP "HTML::FormFu" 4
.IX Item "HTML::FormFu"
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley <clint@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                                                                                                                                                                                                                                                                             Locale::Maketext::Extract::Plugin::FormFu5.18.3pm                                                   0100644 0001750 0001750 00000020406 12566242634 031215  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::FormFu 3"
.TH Locale::Maketext::Extract::Plugin::FormFu 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::FormFu \- FormFu format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::FormFu\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTML::FormFu uses a config-file to generate forms, with built in support
for localizing errors, labels etc.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    formfu
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
We extract the text after any key which ends in \f(CW\*(C`_loc\*(C'\fR:
.PP
.Vb 2
\&    content_loc: this is the string
\&    message_loc: [\*(AqMax length [_1]\*(Aq, 10]
.Ve
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".yaml" 4
.IX Item ".yaml"
.PD 0
.IP ".yml" 4
.IX Item ".yml"
.IP ".conf" 4
.IX Item ".conf"
.PD
.SH "REQUIRES"
.IX Header "REQUIRES"
\&\s-1YAML\s0
.SH "NOTES"
.IX Header "NOTES"
The docs for the \s-1YAML\s0 module describes it as alpha code. It is not as tolerant
of errors as YAML::Syck. However, because it is pure Perl, it is easy
to hook into.
.PP
I have seen it enter endless loops, so if xgettext.pl hangs, try running it
again with \f(CW\*(C`\-\-verbose \-\-verbose\*(C'\fR (twice) enabled, so that you can see if
the fault lies with \s-1YAML. \s0 If it does, either correct the \s-1YAML\s0 source file,
or use the file_types to exclude that file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "\s-1YAML\s0" 4
.IX Item "YAML"
.PD 0
.IP "HTML::FormFu" 4
.IX Item "HTML::FormFu"
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley <clint@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                          Locale::Maketext::Extract::Plugin::Generic.3pm                                                      0100644 0001750 0001750 00000016632 12566242634 031065  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Generic 3"
.TH Locale::Maketext::Extract::Plugin::Generic 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Generic \- Generic template parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Generic\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from generic templates.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    generic
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Strings inside {{...}} are extracted.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP "All file types" 4
.IX Item "All file types"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                      Locale::Maketext::Extract::Plugin::Generic5.16.3pm                                                  0100644 0001750 0001750 00000016547 12566242631 031401  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Generic 3"
.TH Locale::Maketext::Extract::Plugin::Generic 3 "2010-08-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Generic \- Generic template parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Generic\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from generic templates.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    generic
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Strings inside {{...}} are extracted.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP "All file types" 4
.IX Item "All file types"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                                                                                                                         Locale::Maketext::Extract::Plugin::Generic5.18.3pm                                                  0100644 0001750 0001750 00000016632 12566242634 031401  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Generic 3"
.TH Locale::Maketext::Extract::Plugin::Generic 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Generic \- Generic template parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Generic\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from generic templates.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    generic
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Strings inside {{...}} are extracted.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP "All file types" 4
.IX Item "All file types"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::Haml.3pm  0100644 0001750 0001750 00000017163 12566242634 030451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Haml 3"
.TH Locale::Maketext::Extract::Plugin::Haml 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Haml \- HAML format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Haml\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from \s-1HAML\s0 files.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    haml
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Extracts strings in the same way as Locale::Maketext::Extract::Plugin::Perl,
but only ones within \*(L"text\*(R" components of \s-1HAML\s0 files.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".haml" 4
.IX Item ".haml"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.PP
Calum Halcrow <cpan@calumhalcrow.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                             Locale::Maketext::Extract::Plugin::Haml5.18.3pm                                                     0100644 0001750 0001750 00000017163 12566242634 030706  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Haml 3"
.TH Locale::Maketext::Extract::Plugin::Haml 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Haml \- HAML format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Haml\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from \s-1HAML\s0 files.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    haml
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Extracts strings in the same way as Locale::Maketext::Extract::Plugin::Perl,
but only ones within \*(L"text\*(R" components of \s-1HAML\s0 files.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".haml" 4
.IX Item ".haml"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.PP
Calum Halcrow <cpan@calumhalcrow.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::Mason.3pm 0100644 0001750 0001750 00000017232 12566242634 030642  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Mason 3"
.TH Locale::Maketext::Extract::Plugin::Mason 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Mason \- HTML::Mason (aka Mason 1) and Mason (aka Mason 2) format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Mason\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from Mason files.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    mason
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.PP
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP "All file types" 4
.IX Item "All file types"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                      Locale::Maketext::Extract::Plugin::Mason5.16.3pm                                                    0100644 0001750 0001750 00000017147 12566242631 031077  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Mason 3"
.TH Locale::Maketext::Extract::Plugin::Mason 3 "2011-07-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Mason \- HTML::Mason (aka Mason 1) and Mason
(aka Mason 2) format parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Mason\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from Mason files.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    mason
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.PP
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP "All file types" 4
.IX Item "All file types"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                                                                                                                                                                                                                                                                                                                                                                                         Locale::Maketext::Extract::Plugin::Mason5.18.3pm                                                    0100644 0001750 0001750 00000017232 12566242634 031077  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Mason 3"
.TH Locale::Maketext::Extract::Plugin::Mason 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Mason \- HTML::Mason (aka Mason 1) and Mason (aka Mason 2) format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Mason\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from Mason files.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    mason
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
HTML::Mason (aka Mason 1)
 Strings inside <&|/l>...</&> and <&|/loc>...</&> are extracted.
.PP
Mason (aka Mason 2)
Strings inside <% $.floc { %>...</%> or <% $.fl { %>...</%> or
<% \f(CW$self\fR\->floc { %>...</%> or <% \f(CW$self\fR\->fl { %>...</%> are extracted.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP "All file types" 4
.IX Item "All file types"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
.PD
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::PPI.3pm   0100644 0001750 0001750 00000017662 12566242634 030224  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::PPI 3"
.TH Locale::Maketext::Extract::Plugin::PPI 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::PPI \- Perl format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::PPI\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Does exactly the same thing as the Locale::Maketext::Extract::Plugin::Perl
parser, but more accurately, and more slowly. Considerably more slowly! For this
reason it isn't a built-in plugin.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    none \- the module must be specified in full
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid localization function names are:
.IP "translate" 4
.IX Item "translate"
.PD 0
.IP "maketext" 4
.IX Item "maketext"
.IP "gettext" 4
.IX Item "gettext"
.IP "l" 4
.IX Item "l"
.IP "loc" 4
.IX Item "loc"
.IP "x" 4
.IX Item "x"
.IP "_" 4
.IX Item "_"
.IP "_\|_" 4
.IX Item "__"
.PD
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".pm" 4
.IX Item ".pm"
.PD 0
.IP ".pl" 4
.IX Item ".pl"
.IP ".cgi" 4
.IX Item ".cgi"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                              Locale::Maketext::Extract::Plugin::PPI5.16.3pm                                                      0100644 0001750 0001750 00000017550 12566242631 030450  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::PPI 3"
.TH Locale::Maketext::Extract::Plugin::PPI 3 "2010-08-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::PPI \- Perl format parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::PPI\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Does exactly the same thing as the Locale::Maketext::Extract::Plugin::Perl
parser, but more accurately, and more slowly. Considerably more slowly! For this
reason it isn't a built-in plugin.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    none \- the module must be specified in full
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid localization function names are:
.IP "translate" 4
.IX Item "translate"
.PD 0
.IP "maketext" 4
.IX Item "maketext"
.IP "gettext" 4
.IX Item "gettext"
.IP "loc" 4
.IX Item "loc"
.IP "x" 4
.IX Item "x"
.IP "_" 4
.IX Item "_"
.IP "_\|_" 4
.IX Item "__"
.PD
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".pm" 4
.IX Item ".pm"
.PD 0
.IP ".pl" 4
.IX Item ".pl"
.IP ".cgi" 4
.IX Item ".cgi"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                                                                                                                        Locale::Maketext::Extract::Plugin::PPI5.18.3pm                                                      0100644 0001750 0001750 00000017662 12566242634 030461  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::PPI 3"
.TH Locale::Maketext::Extract::Plugin::PPI 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::PPI \- Perl format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::PPI\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Does exactly the same thing as the Locale::Maketext::Extract::Plugin::Perl
parser, but more accurately, and more slowly. Considerably more slowly! For this
reason it isn't a built-in plugin.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    none \- the module must be specified in full
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid localization function names are:
.IP "translate" 4
.IX Item "translate"
.PD 0
.IP "maketext" 4
.IX Item "maketext"
.IP "gettext" 4
.IX Item "gettext"
.IP "l" 4
.IX Item "l"
.IP "loc" 4
.IX Item "loc"
.IP "x" 4
.IX Item "x"
.IP "_" 4
.IX Item "_"
.IP "_\|_" 4
.IX Item "__"
.PD
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".pm" 4
.IX Item ".pm"
.PD 0
.IP ".pl" 4
.IX Item ".pl"
.IP ".cgi" 4
.IX Item ".cgi"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::Perl.3pm  0100644 0001750 0001750 00000020021 12566242634 030455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Perl 3"
.TH Locale::Maketext::Extract::Plugin::Perl 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Perl \- Perl format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Perl\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise (including \s-1HEREDOCS\s0 and
concatenated strings) from Perl code.
.PP
This Perl parser is very fast and very good, but not perfect \- it does make
mistakes. The \s-1PPI\s0 parser (Locale::Maketext::Extract::Plugin::PPI) is more
accurate, but a lot slower, and so is not enabled by default.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    perl
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid localization function names are:
.IP "translate" 4
.IX Item "translate"
.PD 0
.IP "maketext" 4
.IX Item "maketext"
.IP "gettext" 4
.IX Item "gettext"
.IP "l" 4
.IX Item "l"
.IP "loc" 4
.IX Item "loc"
.IP "x" 4
.IX Item "x"
.IP "_" 4
.IX Item "_"
.IP "_\|_" 4
.IX Item "__"
.PD
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".pm" 4
.IX Item ".pm"
.PD 0
.IP ".pl" 4
.IX Item ".pl"
.IP ".cgi" 4
.IX Item ".cgi"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::PPI" 4
.IX Item "Locale::Maketext::Extract::Plugin::PPI"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Locale::Maketext::Extract::Plugin::Perl5.16.3pm                                                     0100644 0001750 0001750 00000017707 12566242631 030726  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Perl 3"
.TH Locale::Maketext::Extract::Plugin::Perl 3 "2010-08-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Perl \- Perl format parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Perl\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise (including \s-1HEREDOCS\s0 and
concatenated strings) from Perl code.
.PP
This Perl parser is very fast and very good, but not perfect \- it does make
mistakes. The \s-1PPI\s0 parser (Locale::Maketext::Extract::Plugin::PPI) is more
accurate, but a lot slower, and so is not enabled by default.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    perl
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid localization function names are:
.IP "translate" 4
.IX Item "translate"
.PD 0
.IP "maketext" 4
.IX Item "maketext"
.IP "gettext" 4
.IX Item "gettext"
.IP "loc" 4
.IX Item "loc"
.IP "x" 4
.IX Item "x"
.IP "_" 4
.IX Item "_"
.IP "_\|_" 4
.IX Item "__"
.PD
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".pm" 4
.IX Item ".pm"
.PD 0
.IP ".pl" 4
.IX Item ".pl"
.IP ".cgi" 4
.IX Item ".cgi"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::PPI" 4
.IX Item "Locale::Maketext::Extract::Plugin::PPI"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                         Locale::Maketext::Extract::Plugin::Perl5.18.3pm                                                     0100644 0001750 0001750 00000020021 12566242634 030712  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::Perl 3"
.TH Locale::Maketext::Extract::Plugin::Perl 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::Perl \- Perl format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::Perl\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise (including \s-1HEREDOCS\s0 and
concatenated strings) from Perl code.
.PP
This Perl parser is very fast and very good, but not perfect \- it does make
mistakes. The \s-1PPI\s0 parser (Locale::Maketext::Extract::Plugin::PPI) is more
accurate, but a lot slower, and so is not enabled by default.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    perl
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid localization function names are:
.IP "translate" 4
.IX Item "translate"
.PD 0
.IP "maketext" 4
.IX Item "maketext"
.IP "gettext" 4
.IX Item "gettext"
.IP "l" 4
.IX Item "l"
.IP "loc" 4
.IX Item "loc"
.IP "x" 4
.IX Item "x"
.IP "_" 4
.IX Item "_"
.IP "_\|_" 4
.IX Item "__"
.PD
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".pm" 4
.IX Item ".pm"
.PD 0
.IP ".pl" 4
.IX Item ".pl"
.IP ".cgi" 4
.IX Item ".cgi"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::PPI" 4
.IX Item "Locale::Maketext::Extract::Plugin::PPI"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::TT2" 4
.IX Item "Locale::Maketext::Extract::Plugin::TT2"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Locale::Maketext::Extract::Plugin::TT2.3pm   0100644 0001750 0001750 00000023761 12566242634 030202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::TT2 3"
.TH Locale::Maketext::Extract::Plugin::TT2 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::TT2 \- Template Toolkit format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::TT2\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from Template Toolkit templates.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    tt2
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid formats are:
.IP "[% |l(args) %]string[% \s-1END\s0 %]" 4
.IX Item "[% |l(args) %]string[% END %]"
.PD 0
.IP "[% 'string' | l(args) %]" 4
.IX Item "[% 'string' | l(args) %]"
.IP "[% l('string',args) %]" 4
.IX Item "[% l('string',args) %]"
.IP "[% c.l('string') %]" 4
.IX Item "[% c.l('string') %]"
.PD
Also all the above combinations with \f(CW\*(C`c.\*(C'\fR prepended should work
correctly. This is the default syntax when using \s-1TT\s0 templates
with Mojolicious.
.PP
l and loc are interchangeable.
.PP
| and \s-1FILTER\s0 are interchangeable.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".tt" 4
.IX Item ".tt"
.PD 0
.IP ".tt2" 4
.IX Item ".tt2"
.IP ".html" 4
.IX Item ".html"
.IP ".tt.*" 4
.IX Item ".tt.*"
.IP ".tt2.*" 4
.IX Item ".tt2.*"
.PD
.SH "REQUIRES"
.IX Header "REQUIRES"
Template
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
\&\fB\s-1BEWARE\s0\fR Using the \f(CW\*(C`loc\*(C'\fR form can give false positives if you use the Perl parser
plugin on \s-1TT\s0 files.  If you want to use the \f(CW\*(C`loc\*(C'\fR form, then you should
specify the file types that you want to the Perl plugin to parse, or enable
the default file types, eg:
.Sp
.Vb 2
\&   xgetext.pl \-P perl ....        # default file types
\&   xgettext.pl \-P perl=pl,pm  ... # specified file types
.Ve
.IP "\(bu" 4
The string-to-be-localised must be a string, not a variable. We try not
to extract calls to your localise function which contain variables eg:
.Sp
.Vb 2
\&    l(\*(Aqstring\*(Aq,arg)  # extracted
\&    l(var,arg)       # not extracted
.Ve
.Sp
This doesn't work for block filters, so don't do that. Eg:
.Sp
.Vb 3
\&    [%  FILTER l %]
\&       string [% var %]      # BAD!
\&    [% END %]
.Ve
.IP "\(bu" 4
Getting the right line number is difficult in \s-1TT.\s0 Often it'll be a range
of lines, or it may be thrown out by the use of \s-1PRE_CHOMP\s0 or \s-1POST_CHOMP. \s0 It will
always be within a few lines of the correct location.
.IP "\(bu" 4
If you have \s-1PRE/POST_CHOMP\s0 enabled by default in your templates, then you should
extract the strings using the same values.  In order to set them, you can
use the following wrapper script:
.Sp
.Vb 1
\&   #!/usr/bin/perl
\&
\&   use Locale::Maketext::Extract::Run qw(xgettext);
\&   use Locale::Maketext::Extract::Plugin::TT2();
\&
\&   %Locale::Maketext::Extract::Plugin::TT2::PARSER_OPTIONS = (
\&        PRE_CHOMP  => 1, # or 2
\&        POST_CHOMP => 1, # or 2
\&
\&        # Also START/END_TAG, ANYCASE, INTERPOLATE, V1DOLLAR, EVAL_PERL
\&   );
\&
\&   xgettext(@ARGV);
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Andy Wardley for writing the Template::Directive subclass which
made this possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.IP "Template::Toolkit" 4
.IX Item "Template::Toolkit"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley <clint@traveljury.com>
.PP
Andy Wardley http://wardley.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
               Locale::Maketext::Extract::Plugin::TT25.16.3pm                                                      0100644 0001750 0001750 00000023676 12566242631 030437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::TT2 3"
.TH Locale::Maketext::Extract::Plugin::TT2 3 "2011-08-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::TT2 \- Template Toolkit format parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::TT2\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from Template Toolkit templates.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    tt2
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid formats are:
.IP "[% |l(args) %]string[% \s-1END\s0 %]" 4
.IX Item "[% |l(args) %]string[% END %]"
.PD 0
.IP "[% 'string' | l(args) %]" 4
.IX Item "[% 'string' | l(args) %]"
.IP "[% l('string',args) %]" 4
.IX Item "[% l('string',args) %]"
.IP "[% c.l('string') %]" 4
.IX Item "[% c.l('string') %]"
.PD
Also all the above combinations with \f(CW\*(C`c.\*(C'\fR prepended should work
correctly. This is the default syntax when using \s-1TT\s0 templates
with Mojolicious.
.PP
l and loc are interchangeable.
.PP
| and \s-1FILTER\s0 are interchangeable.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".tt" 4
.IX Item ".tt"
.PD 0
.IP ".tt2" 4
.IX Item ".tt2"
.IP ".html" 4
.IX Item ".html"
.IP ".tt.*" 4
.IX Item ".tt.*"
.IP ".tt2.*" 4
.IX Item ".tt2.*"
.PD
.SH "REQUIRES"
.IX Header "REQUIRES"
Template
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
\&\fB\s-1BEWARE\s0\fR Using the \f(CW\*(C`loc\*(C'\fR form can give false positives if you use the Perl parser
plugin on \s-1TT\s0 files.  If you want to use the \f(CW\*(C`loc\*(C'\fR form, then you should
specify the file types that you want to the Perl plugin to parse, or enable
the default file types, eg:
.Sp
.Vb 2
\&   xgetext.pl \-P perl ....        # default file types
\&   xgettext.pl \-P perl=pl,pm  ... # specified file types
.Ve
.IP "\(bu" 4
The string-to-be-localised must be a string, not a variable. We try not
to extract calls to your localise function which contain variables eg:
.Sp
.Vb 2
\&    l(\*(Aqstring\*(Aq,arg)  # extracted
\&    l(var,arg)       # not extracted
.Ve
.Sp
This doesn't work for block filters, so don't do that. Eg:
.Sp
.Vb 3
\&    [%  FILTER l %]
\&       string [% var %]      # BAD!
\&    [% END %]
.Ve
.IP "\(bu" 4
Getting the right line number is difficult in \s-1TT\s0. Often it'll be a range
of lines, or it may be thrown out by the use of \s-1PRE_CHOMP\s0 or \s-1POST_CHOMP\s0.  It will
always be within a few lines of the correct location.
.IP "\(bu" 4
If you have \s-1PRE/POST_CHOMP\s0 enabled by default in your templates, then you should
extract the strings using the same values.  In order to set them, you can
use the following wrapper script:
.Sp
.Vb 1
\&   #!/usr/bin/perl
\&
\&   use Locale::Maketext::Extract::Run qw(xgettext);
\&   use Locale::Maketext::Extract::Plugin::TT2();
\&
\&   %Locale::Maketext::Extract::Plugin::TT2::PARSER_OPTIONS = (
\&        PRE_CHOMP  => 1, # or 2
\&        POST_CHOMP => 1, # or 2
\&
\&        # Also START/END_TAG, ANYCASE, INTERPOLATE, V1DOLLAR, EVAL_PERL
\&   );
\&
\&   xgettext(@ARGV);
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Andy Wardley for writing the Template::Directive subclass which
made this possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.IP "Template::Toolkit" 4
.IX Item "Template::Toolkit"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley <clint@traveljury.com>
.PP
Andy Wardley http://wardley.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2008 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT\s0"" License"
.el .SS "The ``\s-1MIT\s0'' License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R", \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EXPRESS\s0
\&\s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1THE\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0,
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1AND\s0 \s-1NONINFRINGEMENT\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0
\&\s-1THE\s0 \s-1AUTHORS\s0 \s-1OR\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1CLAIM\s0, \s-1DAMAGES\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1AN\s0 \s-1ACTION\s0 \s-1OF\s0 \s-1CONTRACT\s0, \s-1TORT\s0 \s-1OR\s0 \s-1OTHERWISE\s0, \s-1ARISING\s0
\&\s-1FROM\s0, \s-1OUT\s0 \s-1OF\s0 \s-1OR\s0 \s-1IN\s0 \s-1CONNECTION\s0 \s-1WITH\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1OR\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1OTHER\s0
\&\s-1DEALINGS\s0 \s-1IN\s0 \s-1THE\s0 \s-1SOFTWARE\s0.
                                                                  Locale::Maketext::Extract::Plugin::TT25.18.3pm                                                      0100644 0001750 0001750 00000023761 12566242634 030437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Maketext::Extract::Plugin::TT2 3"
.TH Locale::Maketext::Extract::Plugin::TT2 3 "2014-02-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Maketext::Extract::Plugin::TT2 \- Template Toolkit format parser
.SH "VERSION"
.IX Header "VERSION"
version 0.99
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    $plugin = Locale::Maketext::Extract::Plugin::TT2\->new(
\&        $lexicon            # A Locale::Maketext::Extract object
\&        @file_types         # Optionally specify a list of recognised file types
\&    )
\&
\&    $plugin\->extract($filename,$filecontents);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extracts strings to localise from Template Toolkit templates.
.SH "SHORT PLUGIN NAME"
.IX Header "SHORT PLUGIN NAME"
.Vb 1
\&    tt2
.Ve
.SH "VALID FORMATS"
.IX Header "VALID FORMATS"
Valid formats are:
.IP "[% |l(args) %]string[% \s-1END\s0 %]" 4
.IX Item "[% |l(args) %]string[% END %]"
.PD 0
.IP "[% 'string' | l(args) %]" 4
.IX Item "[% 'string' | l(args) %]"
.IP "[% l('string',args) %]" 4
.IX Item "[% l('string',args) %]"
.IP "[% c.l('string') %]" 4
.IX Item "[% c.l('string') %]"
.PD
Also all the above combinations with \f(CW\*(C`c.\*(C'\fR prepended should work
correctly. This is the default syntax when using \s-1TT\s0 templates
with Mojolicious.
.PP
l and loc are interchangeable.
.PP
| and \s-1FILTER\s0 are interchangeable.
.SH "KNOWN FILE TYPES"
.IX Header "KNOWN FILE TYPES"
.IP ".tt" 4
.IX Item ".tt"
.PD 0
.IP ".tt2" 4
.IX Item ".tt2"
.IP ".html" 4
.IX Item ".html"
.IP ".tt.*" 4
.IX Item ".tt.*"
.IP ".tt2.*" 4
.IX Item ".tt2.*"
.PD
.SH "REQUIRES"
.IX Header "REQUIRES"
Template
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
\&\fB\s-1BEWARE\s0\fR Using the \f(CW\*(C`loc\*(C'\fR form can give false positives if you use the Perl parser
plugin on \s-1TT\s0 files.  If you want to use the \f(CW\*(C`loc\*(C'\fR form, then you should
specify the file types that you want to the Perl plugin to parse, or enable
the default file types, eg:
.Sp
.Vb 2
\&   xgetext.pl \-P perl ....        # default file types
\&   xgettext.pl \-P perl=pl,pm  ... # specified file types
.Ve
.IP "\(bu" 4
The string-to-be-localised must be a string, not a variable. We try not
to extract calls to your localise function which contain variables eg:
.Sp
.Vb 2
\&    l(\*(Aqstring\*(Aq,arg)  # extracted
\&    l(var,arg)       # not extracted
.Ve
.Sp
This doesn't work for block filters, so don't do that. Eg:
.Sp
.Vb 3
\&    [%  FILTER l %]
\&       string [% var %]      # BAD!
\&    [% END %]
.Ve
.IP "\(bu" 4
Getting the right line number is difficult in \s-1TT.\s0 Often it'll be a range
of lines, or it may be thrown out by the use of \s-1PRE_CHOMP\s0 or \s-1POST_CHOMP. \s0 It will
always be within a few lines of the correct location.
.IP "\(bu" 4
If you have \s-1PRE/POST_CHOMP\s0 enabled by default in your templates, then you should
extract the strings using the same values.  In order to set them, you can
use the following wrapper script:
.Sp
.Vb 1
\&   #!/usr/bin/perl
\&
\&   use Locale::Maketext::Extract::Run qw(xgettext);
\&   use Locale::Maketext::Extract::Plugin::TT2();
\&
\&   %Locale::Maketext::Extract::Plugin::TT2::PARSER_OPTIONS = (
\&        PRE_CHOMP  => 1, # or 2
\&        POST_CHOMP => 1, # or 2
\&
\&        # Also START/END_TAG, ANYCASE, INTERPOLATE, V1DOLLAR, EVAL_PERL
\&   );
\&
\&   xgettext(@ARGV);
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Andy Wardley for writing the Template::Directive subclass which
made this possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "xgettext.pl" 4
.IX Item "xgettext.pl"
for extracting translatable strings from common template
systems and perl source files.
.IP "Locale::Maketext::Lexicon" 4
.IX Item "Locale::Maketext::Lexicon"
.PD 0
.IP "Locale::Maketext::Extract::Plugin::Base" 4
.IX Item "Locale::Maketext::Extract::Plugin::Base"
.IP "Locale::Maketext::Extract::Plugin::FormFu" 4
.IX Item "Locale::Maketext::Extract::Plugin::FormFu"
.IP "Locale::Maketext::Extract::Plugin::Perl" 4
.IX Item "Locale::Maketext::Extract::Plugin::Perl"
.IP "Locale::Maketext::Extract::Plugin::YAML" 4
.IX Item "Locale::Maketext::Extract::Plugin::YAML"
.IP "Locale::Maketext::Extract::Plugin::Mason" 4
.IX Item "Locale::Maketext::Extract::Plugin::Mason"
.IP "Locale::Maketext::Extract::Plugin::TextTemplate" 4
.IX Item "Locale::Maketext::Extract::Plugin::TextTemplate"
.IP "Locale::Maketext::Extract::Plugin::Generic" 4
.IX Item "Locale::Maketext::Extract::Plugin::Generic"
.IP "Template::Toolkit" 4
.IX Item "Template::Toolkit"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Clinton Gormley <clint@traveljury.com>
.PP
Andy Wardley http://wardley.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 by Audrey Tang <cpan@audreyt.org>.
.PP
This software is released under the \s-1MIT\s0 license cited below.
.ie n .SS "The ""\s-1MIT""\s0 License"
.el .SS "The ``\s-1MIT''\s0 License"
.IX Subsection "The MIT License"
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Clinton Gormley <drtech@cpan.org>
.IP "\(bu" 4
Audrey Tang <cpan@audreyt.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by Audrey Tang.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
               Locale::Maketext::Extract::Plugin::TextTemplate.3pm                                                 0100644 0001750 0001750 00000016704 12566242634 032131  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.