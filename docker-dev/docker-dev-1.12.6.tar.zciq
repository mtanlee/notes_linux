 and keys used by both in-kernel and user space power management.
    @discussion IOPM.h defines a range of power management constants used in several in-kernel and user space APIs. Most significantly, the IOPMPowerFlags used to specify the fields of an IOPMPowerState struct are defined here.

    Most of the constants defined in IOPM.h are deprecated or for Apple internal use only, and are not elaborated on in headerdoc.
*/

enum {
    kIOPMMaxPowerStates = 10,
    IOPMMaxPowerStates = kIOPMMaxPowerStates
};

/*! @enum IOPMPowerFlags
    @abstract Bits are used in defining capabilityFlags, inputPowerRequirements, and outputPowerCharacter in the IOPMPowerState structure.
    @discussion These bits may be bitwise-OR'd together in the IOPMPowerState capabilityFlags field, the outputPowerCharacter field, and/or the inputPowerRequirement field. 
    
    The comments clearly mark whether each flag should be used in the capabilityFlags field, outputPowerCharacter field, and inputPowerRequirement field, or all three.
    
    The value of capabilityFlags, inputPowerRequirement or outputPowerCharacter may be 0. Most drivers implement their 'OFF' state, used when asleep, by defininf each of the 3 fields as 0.
    
    The bits listed below are only the most common bits used to define a device's power states. Your device's IO family may require that your device specify other input or output power flags to interact properly. Consult family-specific documentation to determine if your IOPower plane parents or children require other power flags; they probably don't.

    @constant kIOPMPowerOn Indicates the device is on, requires power, and provides power. Useful as a: Capability, InputPowerRequirement, OutputPowerCharacter

    @constant kIOPMDeviceUsable Indicates the device is usable in this state. Useful only as a Capability

    @constant kIOPMLowPower 
    Indicates device is in a low power state. May be bitwis-OR'd together
    with kIOPMDeviceUsable flag, to indicate the device is still usable.
    
    A device with a capability of kIOPMLowPower may:
       Require either 0 or kIOPMPowerOn from its power parent
       Offer either kIOPMLowPower, kIOPMPowerOn, or 0 (no power at all)
         to its power plane children.

    Useful only as a Capability, although USB drivers should consult USB family documentation for other valid circumstances to use the kIOPMLowPower bit.

    @constant kIOPMPreventIdleSleep
    In the capability field of a power state, disallows idle system sleep while the device is in that state.
    
    For example, displays and disks set this capability for their ON power state; since the system may not idle sleep while the display (and thus keyboard or mouse) or the disk is active.

    Useful only as a Capability.
    
    @constant kIOPMSleepCapability
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
    
    @constant kIOPMRestartCapability
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
    
    @constant kIOPMSleep
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.

    @constant kIOPMRestart
    Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.

    @constant kIOPMInitialDeviceState
    Indicates the initial power state for the device. If <code>initialPowerStateForDomainState()</code> returns a power state with this flag set in the capability field, then the initial power change is performed without calling the driver's <code>setPowerState()</code>.

    @constant kIOPMRootDomainState
    An indication that the power flags represent the state of the root power
    domain. This bit must not be set in the IOPMPowerState structure.
    Power Management may pass this bit to initialPowerStateForDomainState()
    to map from a global system state to the desired device state.
*/
typedef unsigned long IOPMPowerFlags;
enum {
    kIOPMPowerOn                    = 0x00000002,
    kIOPMDeviceUsable               = 0x00008000,
    kIOPMLowPower                   = 0x00010000,
    kIOPMPreventIdleSleep           = 0x00000040,
    kIOPMSleepCapability            = 0x00000004,
    kIOPMRestartCapability          = 0x00000080,
    kIOPMSleep                      = 0x00000001,
    kIOPMRestart                    = 0x00000080,
    kIOPMInitialDeviceState         = 0x00000100,
    kIOPMRootDomainState            = 0x00000200
};

/*
 * Private IOPMPowerFlags
 *
 * For Apple use only
 * Not for use with non-Apple drivers
 * Their behavior is undefined
 */
enum {
    kIOPMClockNormal                = 0x0004,
    kIOPMClockRunning               = 0x0008,
    kIOPMPreventSystemSleep         = 0x0010,
    kIOPMDoze                       = 0x0400,
    kIOPMChildClamp                 = 0x0080,
    kIOPMChildClamp2                = 0x0200,
    kIOPMNotPowerManaged            = 0x0800
};

/*
 * Deprecated IOPMPowerFlags
 * Their behavior is undefined when used in IOPMPowerState
 * Capability, InputPowerRequirement, or OutputPowerCharacter fields.
 */
enum {
    kIOPMMaxPerformance             = 0x4000,
    kIOPMPassThrough                = 0x0100,
    kIOPMAuxPowerOn                 = 0x0020,
    kIOPMNotAttainable              = 0x0001,
    kIOPMContextRetained            = 0x2000,
    kIOPMConfigRetained             = 0x1000,
    kIOPMStaticPowerValid           = 0x0800,
    kIOPMSoftSleep                  = 0x0400,
    kIOPMCapabilitiesMask =     kIOPMPowerOn | kIOPMDeviceUsable | 
                                kIOPMMaxPerformance | kIOPMContextRetained | 
                                kIOPMConfigRetained | kIOPMSleepCapability |
                                kIOPMRestartCapability
};

/*
 * Support for old names of IOPMPowerFlag constants
 */
enum {
    IOPMNotAttainable           = kIOPMNotAttainable,
    IOPMPowerOn                 = kIOPMPowerOn,
    IOPMClockNormal             = kIOPMClockNormal,
    IOPMClockRunning            = kIOPMClockRunning,
    IOPMAuxPowerOn              = kIOPMAuxPowerOn,
    IOPMDeviceUsable            = kIOPMDeviceUsable,
    IOPMMaxPerformance          = kIOPMMaxPerformance,
    IOPMContextRetained         = kIOPMContextRetained,
    IOPMConfigRetained          = kIOPMConfigRetained,
    IOPMNotPowerManaged         = kIOPMNotPowerManaged,
    IOPMSoftSleep               = kIOPMSoftSleep
};


enum {
    kIOPMNextHigherState        = 1,
    kIOPMHighestState           = 2,
    kIOPMNextLowerState         = 3,
    kIOPMLowestState            = 4
};

enum {
    IOPMNextHigherState         = kIOPMNextHigherState,
    IOPMHighestState            = kIOPMHighestState,
    IOPMNextLowerState          = kIOPMNextLowerState,
    IOPMLowestState             = kIOPMLowestState
};

// Internal commands used by power managment command queue
enum {
    kIOPMBroadcastAggressiveness = 1,
    kIOPMUnidleDevice
};

// Power consumption unknown value
enum {
    kIOPMUnknown = 0xFFFF
};

/*******************************************************************************
 *
 * Root Domain property keys of interest
 *
 ******************************************************************************/

/* AppleClamshellState 
 * reflects the state of the clamshell (lid) on a portable.
 * It has a boolean value.
 *  true        == clamshell is closed
 *  false       == clamshell is open
 *  not present == no clamshell on this hardware
 */
#define kAppleClamshellStateKey             "AppleClamshellState"

/* AppleClamshellCausesSleep 
 * reflects the clamshell close behavior on a portable. 
 * It has a boolean value.
 *  true        == system will sleep when clamshell is closed
 *  false       == system will not sleep on clamshell close 
 *                  (typically external display mode)
 *  not present == no clamshell on this hardware
 */
#define kAppleClamshellCausesSleepKey       "AppleClamshellCausesSleep"

/* kIOPMSleepWakeUUIDKey
 * Key refers to a CFStringRef that will uniquely identify
 * a sleep/wake cycle for logging & tracking.
 * The key becomes valid at the beginning of a sleep cycle - before we
 * initiate any sleep/wake notifications.
 * The key becomes invalid at the completion of a system wakeup. The
 * property will not be present in the IOPMrootDomain's registry entry
 * when it is invalid.
 * 
 * See IOPMrootDomain notification kIOPMMessageSleepWakeUUIDChange
 */
 #define kIOPMSleepWakeUUIDKey              "SleepWakeUUID"

/* kIOPMBootSessionUUIDKey
 * Key refers to a CFStringRef that will uniquely identify
 * a boot cycle.
 * The key becomes valid at boot time and remains valid 
 * till shutdown. The property value will remain same across 
 * sleep/wake/hibernate cycle.
 */
#define kIOPMBootSessionUUIDKey             "BootSessionUUID"

/* kIOPMDeepSleepEnabledKey
 * Indicates the Deep Sleep enable state.
 * It has a boolean value.
 *  true        == Deep Sleep is enabled
 *  false       == Deep Sleep is disabled
 *  not present == Deep Sleep is not supported on this hardware
 */
#define kIOPMDeepSleepEnabledKey            "Standby Enabled"

/* kIOPMDeepSleepDelayKey
 * Key refers to a CFNumberRef that represents the delay in seconds before
 * entering Deep Sleep state. The property is not present if Deep Sleep is
 * unsupported.
 */
#define kIOPMDeepSleepDelayKey              "Standby Delay"

/* kIOPMDestroyFVKeyOnStandbyKey
 * Specifies if FileVault key can be stored when going to standby mode
 * It has a boolean value,
 *  true        == Destroy FV key when going to standby mode
 *  false       == Retain FV key when going to standby mode
 *  not present == Retain FV key when going to standby mode
 */
#define kIOPMDestroyFVKeyOnStandbyKey       "DestroyFVKeyOnStandby"

/*******************************************************************************
 *
 * Properties that can control power management behavior
 *
 ******************************************************************************/

/* kIOPMResetPowerStateOnWakeKey
 * If an IOService publishes this key with the value of kOSBooleanTrue,
 * then PM will disregard the influence from changePowerStateToPriv() or
 * any activity tickles that occurred before system sleep when resolving
 * the initial device power state on wake. Influences from power children
 * and changePowerStateTo() are not eliminated. At the earliest opportunity
 * upon system wake, PM will query the driver for a new power state to be
 * installed as the initial changePowerStateToPriv() influence, by calling
 * initialPowerStateForDomainState() with both kIOPMRootDomainState and
 * kIOPMPowerOn flags set. The default implementation will always return
 * the lowest power state. Drivers can override this default behavior to
 * immediately raise the power state when there are work blocked on the
 * power change, and cannot afford to wait until the next activity tickle.
 * This property should be statically added to a driver's plist or set at
 * runtime before calling PMinit().
 */
#define kIOPMResetPowerStateOnWakeKey       "IOPMResetPowerStateOnWake"

/*******************************************************************************
 *
 * Driver PM Assertions
 *
 ******************************************************************************/

/* Driver Assertion bitfield description
 * Driver PM assertions are defined by these bits.
 */
enum {
    /*! kIOPMDriverAssertionCPUBit
     * When set, PM kernel will prefer to leave the CPU and core hardware
     * running in "Dark Wake" state, instead of sleeping.
     */
    kIOPMDriverAssertionCPUBit                      = 0x01,

    /*! kIOPMDriverAssertionUSBExternalDeviceBit
     * When set, driver is informing PM that an external USB device is attached.
     */
    kIOPMDriverAssertionUSBExternalDeviceBit        = 0x04,

    /*! kIOPMDriverAssertionBluetoothHIDDevicePairedBit
     * When set, driver is informing PM that a Bluetooth HID device is paired.
     */
    kIOPMDriverAssertionBluetoothHIDDevicePairedBit = 0x08,

    /*! kIOPMDriverAssertionExternalMediaMountedBit
     * When set, driver is informing PM that an external media is mounted.
     */
    kIOPMDriverAssertionExternalMediaMountedBit     = 0x10,

    /*! kIOPMDriverAssertionReservedBit5
     * Reserved for Thunderbolt.
     */
    kIOPMDriverAssertionReservedBit5                = 0x20,

    /*! kIOPMDriverAssertionPreventDisplaySleepBit
     * When set, the display should remain powered on while the system's awake.
     */
    kIOPMDriverAssertionPreventDisplaySleepBit      = 0x40,

    /*! kIOPMDriverAssertionReservedBit7
     * Reserved for storage family.
     */
    kIOPMDriverAssertionReservedBit7                = 0x80,

    /*! kIOPMDriverAssertionMagicPacketWakeEnabledBit
     * When set, driver is informing PM that magic packet wake is enabled.
     */
    kIOPMDriverAssertionMagicPacketWakeEnabledBit   = 0x100,

    /*! kIOPMDriverAssertionNetworkKeepAliveActiveBit
     * When set, driver is informing PM that it is holding the network
     * interface up to do TCPKeepAlive
     */
    kIOPMDriverAssertionNetworkKeepAliveActiveBit   = 0x200
};

 /* kIOPMAssertionsDriverKey
  * This kIOPMrootDomain key refers to a CFNumberRef property, containing
  * a bitfield describing the aggregate PM assertion levels.
  * Example: A value of 0 indicates that no driver has asserted anything.
  * Or, a value of <link>kIOPMDriverAssertionCPUBit</link>
  *   indicates that a driver (or drivers) have asserted a need for CPU and video.
  */
#define kIOPMAssertionsDriverKey            "DriverPMAssertions"

 /* kIOPMAssertionsDriverKey
  * This kIOPMrootDomain key refers to a CFNumberRef property, containing
  * a bitfield describing the aggregate PM assertion levels.
  * Example: A value of 0 indicates that no driver has asserted anything.
  * Or, a value of <link>kIOPMDriverAssertionCPUBit</link>
  *   indicates that a driver (or drivers) have asserted a need for CPU and video.
  */
#define kIOPMAssertionsDriverDetailedKey    "DriverPMAssertionsDetailed"

/*******************************************************************************
 *
 * Kernel Driver assertion detailed dictionary keys
 *
 * Keys decode the Array & dictionary data structure under IOPMrootDomain property 
 *  kIOPMAssertionsDriverKey.
 *
 */
#define kIOPMDriverAssertionIDKey               "ID"
#define kIOPMDriverAssertionCreatedTimeKey      "CreatedTime"
#define kIOPMDriverAssertionModifiedTimeKey     "ModifiedTime"
#define kIOPMDriverAssertionOwnerStringKey      "Owner"
#define kIOPMDriverAssertionOwnerServiceKey     "ServicePtr"
#define kIOPMDriverAssertionRegistryEntryIDKey  "RegistryEntryID"
#define kIOPMDriverAssertionLevelKey            "Level"
#define kIOPMDriverAssertionAssertedKey         "Assertions"

/*******************************************************************************
 *
 * Root Domain general interest messages
 *
 * Available by registering for interest type 'gIOGeneralInterest' 
 * on IOPMrootDomain. 
 *
 ******************************************************************************/

/* kIOPMMessageClamshellStateChange
 * Delivered as a general interest notification on the IOPMrootDomain
 * IOPMrootDomain sends this message when state of either AppleClamshellState
 * or AppleClamshellCausesSleep changes. If this clamshell change results in
 * a sleep, the sleep will initiate soon AFTER delivery of this message.
 * The state of both variables is encoded in a bitfield argument sent with
 * the message. Check bits 0 and 1 using kClamshellStateBit & kClamshellSleepBit
 */
enum {
    kClamshellStateBit = (1 << 0),
    kClamshellSleepBit = (1 << 1)
};

#define kIOPMMessageClamshellStateChange   \
                iokit_family_msg(sub_iokit_powermanagement, 0x100)

/* kIOPMMessageFeatureChange
 * Delivered when the set of supported features ("Supported Features" dictionary
 * under IOPMrootDomain registry) changes in some way. Typically addition or
 * removal of a supported feature.
 * RootDomain passes no argument with this message.
 */
#define kIOPMMessageFeatureChange           \
                iokit_family_msg(sub_iokit_powermanagement, 0x110)

/* kIOPMMessageInflowDisableCancelled
 * The battery has drained completely to its "Fully Discharged" state. 
 * If a user process has disabled battery inflow for battery 
 * calibration, we forcibly re-enable Inflow at this point.
 * If inflow HAS been forcibly re-enabled, bit 0
 * (kInflowForciblyEnabledBit) will be set.
 */
enum {
    kInflowForciblyEnabledBit = (1 << 0)
};

/* kIOPMMessageInternalBatteryFullyDischarged
 * The battery has drained completely to its "Fully Discharged" state. 
 */
#define kIOPMMessageInternalBatteryFullyDischarged  \
                iokit_family_msg(sub_iokit_powermanagement, 0x120)

/* kIOPMMessageSystemPowerEventOccurred
 * Some major system thermal property has changed, and interested clients may
 * modify their behavior.
 */
#define kIOPMMessageSystemPowerEventOccurred  \
                iokit_family_msg(sub_iokit_powermanagement, 0x130)

/* kIOPMMessageSleepWakeUUIDChange
 * Either a new SleepWakeUUID has been specified at the beginning of a sleep,
 * or we're removing the existing property upon completion of a wakeup.
 */
#define kIOPMMessageSleepWakeUUIDChange  \
                iokit_family_msg(sub_iokit_powermanagement, 0x140)
                
/* kIOPMMessageSleepWakeUUIDSet
 * Argument accompanying the kIOPMMessageSleepWakeUUIDChange notification when 
 * a new UUID has been specified.
 */
#define kIOPMMessageSleepWakeUUIDSet                    ((void *)1)

/* kIOPMMessageSleepWakeUUIDCleared
 * Argument accompanying the kIOPMMessageSleepWakeUUIDChange notification when 
 * the current UUID has been removed.
 */
#define kIOPMMessageSleepWakeUUIDCleared                ((void *)0)

/*! kIOPMMessageDriverAssertionsChanged
 *  Sent when kernel PM driver assertions have changed.
 */
#define kIOPMMessageDriverAssertionsChanged  \
                iokit_family_msg(sub_iokit_powermanagement, 0x150)

/*! kIOPMMessageDarkWakeThermalEmergency
 * Sent when machine becomes unsustainably warm in DarkWake.
 * Kernel PM might choose to put the machine back to sleep right after.
 */
#define kIOPMMessageDarkWakeThermalEmergency \
                iokit_family_msg(sub_iokit_powermanagement, 0x160)

/*******************************************************************************
 *
 * Power commands issued to root domain
 * Use with IOPMrootDomain::receivePowerNotification()
 *
 * These commands are issued from system drivers only:
 *      ApplePMU, AppleSMU, IOGraphics, AppleACPIFamily
 *
 * TODO: deprecate kIOPMAllowSleep and kIOPMPreventSleep
 ******************************************************************************/
enum {
  kIOPMSleepNow                 = (1<<0),  // put machine to sleep now
  kIOPMAllowSleep               = (1<<1),  // allow idle sleep
  kIOPMPreventSleep             = (1<<2),  // do not allow idle sleep
  kIOPMPowerButton              = (1<<3),  // power button was pressed
  kIOPMClamshellClosed          = (1<<4),  // clamshell was closed
  kIOPMPowerEmergency           = (1<<5),  // battery dangerously low
  kIOPMDisableClamshell         = (1<<6),  // do not sleep on clamshell closure
  kIOPMEnableClamshell          = (1<<7),  // sleep on clamshell closure
  kIOPMProcessorSpeedChange     = (1<<8),  // change the processor speed
  kIOPMOverTemp                 = (1<<9),  // system dangerously hot
  kIOPMClamshellOpened          = (1<<10), // clamshell was opened
  kIOPMDWOverTemp               = (1<<11)  // DarkWake thermal limits exceeded.
};


/*******************************************************************************
 *
 * Power Management Return Codes
 *
 ******************************************************************************/
enum {
    kIOPMNoErr                  = 0,

    // Returned by driver's setPowerState(), powerStateWillChangeTo(),
    // powerStateDidChangeTo(), or acknowledgeSetPowerState() to
    // implicitly acknowledge power change upon function return.
    kIOPMAckImplied             = 0,

    // Deprecated
    kIOPMWillAckLater           = 1,

    // Returned by requestPowerDomainState() to indicate
    // unrecognized specification parameter.
    kIOPMBadSpecification       = 4,

    // Returned by requestPowerDomainState() to indicate
    // no power state matches search specification.
    kIOPMNoSuchState            = 5,

    // Deprecated
    kIOPMCannotRaisePower       = 6,

    // Deprecated
    kIOPMParameterError         = 7,

    // Returned when power management state is accessed
    // before driver has called PMinit().
    kIOPMNotYetInitialized      = 8,

    // And the old constants; deprecated
    IOPMNoErr = kIOPMNoErr,
    IOPMAckImplied = kIOPMAckImplied, 
    IOPMWillAckLater = kIOPMWillAckLater,
    IOPMBadSpecification = kIOPMBadSpecification,
    IOPMNoSuchState = kIOPMNoSuchState,
    IOPMCannotRaisePower = kIOPMCannotRaisePower,
    IOPMParameterError = kIOPMParameterError,
    IOPMNotYetInitialized = kIOPMNotYetInitialized
};


// IOPMPowerSource class descriptive strings
// Power Source state is published as properties to the IORegistry under these 
// keys.
#define kIOPMPSExternalConnectedKey                 "ExternalConnected"
#define kIOPMPSExternalChargeCapableKey             "ExternalChargeCapable"
#define kIOPMPSBatteryInstalledKey                  "BatteryInstalled"
#define kIOPMPSIsChargingKey                        "IsCharging"
#define kIOPMFullyChargedKey                        "FullyCharged"
#define kIOPMPSAtWarnLevelKey                       "AtWarnLevel"
#define kIOPMPSAtCriticalLevelKey                   "AtCriticalLevel"
#define kIOPMPSCurrentCapacityKey                   "CurrentCapacity"
#define kIOPMPSMaxCapacityKey                       "MaxCapacity"
#define kIOPMPSDesignCapacityKey                    "DesignCapacity"
#define kIOPMPSTimeRemainingKey                     "TimeRemaining"
#define kIOPMPSAmperageKey                          "Amperage"
#define kIOPMPSVoltageKey                           "Voltage"
#define kIOPMPSCycleCountKey                        "CycleCount"
#define kIOPMPSMaxErrKey                            "MaxErr"
#define kIOPMPSAdapterInfoKey                       "AdapterInfo"
#define kIOPMPSLocationKey                          "Location"
#define kIOPMPSErrorConditionKey                    "ErrorCondition"
#define kIOPMPSManufacturerKey                      "Manufacturer"
#define kIOPMPSManufactureDateKey                   "ManufactureDate"
#define kIOPMPSModelKey                             "Model"
#define kIOPMPSSerialKey                            "Serial"
#define kIOPMDeviceNameKey                          "DeviceName"
#define kIOPMPSLegacyBatteryInfoKey                 "LegacyBatteryInfo"
#define kIOPMPSBatteryHealthKey                     "BatteryHealth"
#define kIOPMPSHealthConfidenceKey                  "HealthConfidence"
#define kIOPMPSCapacityEstimatedKey	                "CapacityEstimated"
#define kIOPMPSBatteryChargeStatusKey               "ChargeStatus"
#define kIOPMPSBatteryTemperatureKey                "Temperature"
#define kIOPMPSAdapterDetailsKey		    "AdapterDetails"
#define kIOPMPSChargerConfigurationKey		    "ChargerConfiguration"

// kIOPMPSBatteryChargeStatusKey may have one of the following values, or may have
// no value. If kIOPMBatteryChargeStatusKey has a NULL value (or no value) associated with it
// then charge is proceeding normally. If one of these battery charge status reasons is listed,
// then the charge may have been interrupted.
#define kIOPMBatteryChargeStatusTooHot              "HighTemperature"
#define kIOPMBatteryChargeStatusTooCold             "LowTemperature"
#define kIOPMBatteryChargeStatusTooHotOrCold	    "HighOrLowTemperature"
#define kIOPMBatteryChargeStatusGradient            "BatteryTemperatureGradient"

// Definitions for battery location, in case of multiple batteries.
// A location of 0 is unspecified
// Location is undefined for single battery systems
enum {
    kIOPMPSLocationLeft = 1001,
    kIOPMPSLocationRight = 1002
};

// Battery quality health types, specified by BatteryHealth and HealthConfidence
// properties in an IOPMPowerSource battery kext.
enum {
    kIOPMUndefinedValue = 0,
    kIOPMPoorValue      = 1,
    kIOPMFairValue      = 2,
    kIOPMGoodValue      = 3
};

// Keys for kIOPMPSAdapterDetailsKey dictionary
#define kIOPMPSAdapterDetailsIDKey		    "AdapterID"
#define kIOPMPSAdapterDetailsWattsKey		    "Watts"
#define kIOPMPSAdapterDetailsRevisionKey	    "AdapterRevision"
#define kIOPMPSAdapterDetailsSerialNumberKey	    "SerialNumber"
#define kIOPMPSAdapterDetailsFamilyKey		    "FamilyCode"
#define kIOPMPSAdapterDetailsAmperageKey	    "Amperage"
#define kIOPMPSAdapterDetailsDescriptionKey	    "Description"
#define kIOPMPSAdapterDetailsPMUConfigurationKey    "PMUConfiguration"

// Battery's time remaining estimate is invalid this long (seconds) after a wake
#define kIOPMPSInvalidWakeSecondsKey           "BatteryInvalidWakeSeconds"

// Battery must wait this long (seconds) after being completely charged before
// the battery is settled.
#define kIOPMPSPostChargeWaitSecondsKey        "PostChargeWaitSeconds"

// Battery must wait this long (seconds) after being completely discharged 
// before the battery is settled.
#define kIOPMPSPostDishargeWaitSecondsKey      "PostDischargeWaitSeconds"


/* CPU Power Management status keys
 * Pass as arguments to IOPMrootDomain::systemPowerEventOccurred
 * Or as arguments to IOPMSystemPowerEventOccurred()
 * Or to decode the dictionary obtained from IOPMCopyCPUPowerStatus()
 * These keys reflect restrictions placed on the CPU by the system
 * to bring the CPU's power consumption within allowable thermal and 
 * power constraints.
 */


/* kIOPMGraphicsPowerLimitsKey
 *   The key representing the dictionary of graphics power limits.
 *   The dictionary contains the other kIOPMCPUPower keys & their associated
 *   values (e.g. Speed limit, Processor Count, and Schedule limits).
 */
#define kIOPMGraphicsPowerLimitsKey                     "Graphics_Power_Limits"

/* kIOPMGraphicsPowerLimitPerformanceKey
 *   The key representing the percent of overall performance made available
 *   by the graphics chip as a percentage (integer 0 - 100).
 */
#define kIOPMGraphicsPowerLimitPerformanceKey           "Graphics_Power_Performance"



/* kIOPMCPUPowerLimitsKey
 *   The key representing the dictionary of CPU Power Limits.
 *   The dictionary contains the other kIOPMCPUPower keys & their associated
 *   values (e.g. Speed limit, Processor Count, and Schedule limits).
 */
#define kIOPMCPUPowerLimitsKey                          "CPU_Power_Limits"

/* kIOPMCPUPowerLimitProcessorSpeedKey defines the speed & voltage limits placed 
 *   on the CPU.
 *   Represented as a percentage (0-100) of maximum CPU speed.
 */
#define kIOPMCPUPowerLimitProcessorSpeedKey             "CPU_Speed_Limit"

/* kIOPMCPUPowerLimitProcessorCountKey reflects how many, if any, CPUs have been
 *   taken offline. Represented as an integer number of CPUs (0 - Max CPUs).
 */
#define kIOPMCPUPowerLimitProcessorCountKey             "CPU_Available_CPUs"

/* kIOPMCPUPowerLimitSchedulerTimeKey represents the percentage (0-100) of CPU time 
 *   available. 100% at normal operation. The OS may limit this time for a percentage
 *   less than 100%.
 */
#define kIOPMCPUPowerLimitSchedulerTimeKey              "CPU_Scheduler_Limit"


/* Thermal Level Warning Key
 * Indicates the thermal constraints placed on the system. This value may 
 * cause clients to action to consume fewer system resources.
 * The value associated with this warning is defined by the platform.
 */
#define kIOPMThermalLevelWarningKey                     "Thermal_Level_Warning"

/* Thermal Warning Level values
 *      kIOPMThermalLevelNormal   - under normal operating conditions
 *      kIOPMThermalLevelDanger   - thermal pressure may cause system slowdown
 *      kIOPMThermalLevelCritical - thermal conditions may cause imminent shutdown
 *
 * The platform may define additional thermal levels if necessary.
 * Platform specific values are defined from 100 and above
 */
enum {
  kIOPMThermalLevelNormal    = 0,
  kIOPMThermalLevelDanger    = 5,
  kIOPMThermalLevelCritical  = 10,

  kIOPMThermalLevelWarning = 100,
  kIOPMThermalLevelTrap    = 110,

  kIOPMThermalLevelUnknown = 255,
};

#define kIOPMThermalWarningLevelNormal kIOPMThermalLevelNormal
#define kIOPMThermalWarningLevelDanger kIOPMThermalLevelWarning
#define kIOPMThermalWarningLevelCrisis kIOPMThermalLevelCritical

// PM Settings Controller setting types
// Settings types used primarily with:
//      IOPMrootDomain::registerPMSettingController
// The values are identical to the similarly named keys for use in user space
// PM settings work. Those keys are defined in IOPMLibPrivate.h.
#define kIOPMSettingWakeOnRingKey                   "Wake On Modem Ring"
#define kIOPMSettingRestartOnPowerLossKey           "Automatic Restart On Power Loss"
#define kIOPMSettingWakeOnACChangeKey               "Wake On AC Change"
#define kIOPMSettingSleepOnPowerButtonKey           "Sleep On Power Button"
#define kIOPMSettingWakeOnClamshellKey              "Wake On Clamshell Open"
#define kIOPMSettingReduceBrightnessKey             "ReduceBrightness"
#define kIOPMSettingDisplaySleepUsesDimKey          "Display Sleep Uses Dim"
#define kIOPMSettingTimeZoneOffsetKey               "TimeZoneOffsetSeconds"
#define kIOPMSettingMobileMotionModuleKey           "MobileMotionModule"
#define kIOPMSettingGraphicsSwitchKey               "GPUSwitch"

// Setting controlling drivers can register to receive scheduled wake data
// Either in "CF seconds" type, or structured calendar data in a formatted
// IOPMCalendarStruct defined below.
#define kIOPMSettingAutoWakeSecondsKey              "wake"
#define kIOPMSettingAutoWakeCalendarKey             "WakeByCalendarDate"
#define kIOPMSettingAutoPowerSecondsKey             "poweron"
#define kIOPMSettingAutoPowerCalendarKey            "PowerByCalendarDate"

// Debug seconds auto wake
// Used by sleep cycling debug tools
#define kIOPMSettingDebugWakeRelativeKey            "WakeRelativeToSleep"
#define kIOPMSettingDebugPowerRelativeKey           "PowerRelativeToShutdown"

// Maintenance wake calendar.
#define kIOPMSettingMaintenanceWakeCalendarKey      "MaintenanceWakeCalendarDate"


struct IOPMCalendarStruct {
    UInt32      year;
    UInt8       month;
    UInt8       day;
    UInt8       hour;
    UInt8       minute;
    UInt8       second;
    UInt8       selector;
};
typedef struct IOPMCalendarStruct IOPMCalendarStruct;

// SetAggressiveness types
enum {
    kPMGeneralAggressiveness = 0,
    kPMMinutesToDim,
    kPMMinutesToSpinDown,
    kPMMinutesToSleep,
    kPMEthernetWakeOnLANSettings,
    kPMSetProcessorSpeed,
    kPMPowerSource,
    kPMMotionSensor,
    kPMLastAggressivenessType
};
#define kMaxType (kPMLastAggressivenessType-1)

// SetAggressiveness values for the kPMPowerSource aggressiveness type
enum {
    kIOPMInternalPower = 1,
    kIOPMExternalPower
};

#define kIOREMSleepEnabledKey               "REMSleepEnabled"

// Strings for deciphering the dictionary returned from IOPMCopyBatteryInfo
#define kIOBatteryInfoKey                   "IOBatteryInfo"
#define kIOBatteryCurrentChargeKey          "Current"
#define kIOBatteryCapacityKey               "Capacity"
#define kIOBatteryFlagsKey                  "Flags"
#define kIOBatteryVoltageKey                "Voltage"
#define kIOBatteryAmperageKey               "Amperage"
#define kIOBatteryCycleCountKey             "Cycle Count"

enum {
    kIOBatteryInstalled         = (1 << 2),
    kIOBatteryCharge            = (1 << 1),
    kIOBatteryChargerConnect    = (1 << 0)
};

// Private power management message indicating battery data has changed
// Indicates new data resides in the IORegistry
#define kIOPMMessageBatteryStatusHasChanged         iokit_family_msg(sub_iokit_pmu, 0x100)

// Apple private Legacy messages for re-routing AutoWake and AutoPower messages to the PMU
// through newer user space IOPMSchedulePowerEvent API
#define kIOPMUMessageLegacyAutoWake                 iokit_family_msg(sub_iokit_pmu, 0x200)
#define kIOPMUMessageLegacyAutoPower                iokit_family_msg(sub_iokit_pmu, 0x210)

// For use with IOPMPowerSource bFlags
#define IOPM_POWER_SOURCE_REV   2
enum {
  kIOPMACInstalled      = kIOBatteryChargerConnect,
  kIOPMBatteryCharging  = kIOBatteryCharge,
  kIOPMBatteryInstalled = kIOBatteryInstalled,
  kIOPMUPSInstalled     = (1<<3),
  kIOPMBatteryAtWarn    = (1<<4),
  kIOPMBatteryDepleted  = (1<<5),
  kIOPMACnoChargeCapability = (1<<6),     // AC adapter cannot charge battery
  kIOPMRawLowBattery    = (1<<7),         // used only by  Platform Expert
  kIOPMForceLowSpeed    = (1<<8),         // set by Platfm Expert, chk'd by Pwr Plugin
  kIOPMClosedClamshell  = (1<<9),         // set by PMU - reflects state of the clamshell
  kIOPMClamshellStateOnWake = (1<<10)     // used only by Platform Expert
};

// **********************************************
// Internal power management data structures
// **********************************************

#if KERNEL && __cplusplus
class IOService;

enum {
    kIOPowerEmergencyLevel = 1000
};

enum {
    kIOPMSubclassPolicy,
    kIOPMSuperclassPolicy1
};

struct stateChangeNote {
    IOPMPowerFlags    stateFlags;
    unsigned long    stateNum;
    void *         powerRef;
};
typedef struct stateChangeNote stateChangeNote;

#endif /* KERNEL && __cplusplus */
struct IOPowerStateChangeNotification {
    void *        powerRef;
    unsigned long    returnValue;
    unsigned long    stateNumber;
    IOPMPowerFlags    stateFlags;
};
typedef struct IOPowerStateChangeNotification IOPowerStateChangeNotification;
typedef IOPowerStateChangeNotification sleepWakeNote;

/*! @struct IOPMSystemCapabilityChangeParameters
    @abstract A structure describing a system capability change.
    @discussion A system capability change is a system level transition from a set
        of system capabilities to a new set of system capabilities. Power management
        sends a <code>kIOMessageSystemCapabilityChange</code> message and provides
        this structure as the message data (by reference) to
        <code>gIOPriorityPowerStateInterest</code> clients when system capability
        changes.
    @field notifyRef An identifier for this message notification. Clients with pending
        I/O can signal completion by calling <code>allowPowerChange()</code> with this
        value as the argument. Clients that are able to process the notification
        synchronously should ignore this field.
    @field maxWaitForReply A return value to the caller indicating the maximum time in
        microseconds to wait for the <code>allowPowerChange()</code> call. The default
        value is zero, which indicates the client processing has finished, and power
        management should not wait for an <code>allowPowerChange()</code> call.
    @field changeFlags Flags will be set to indicate whether the notification precedes
        the capability change (<code>kIOPMSystemCapabilityWillChange</code>), or after
        the capability change has occurred (<code>kIOPMSystemCapabilityDidChange</code>).
    @field __reserved1 Set to zero.
    @field fromCapabilities The system capabilities at the start of the transition.
    @field toCapabilities The system capabilities at the end of the transition.
    @field __reserved2 Set to zero.
 */
struct IOPMSystemCapabilityChangeParameters {
    uint32_t    notifyRef;
    uint32_t    maxWaitForReply;
    uint32_t    changeFlags;
    uint32_t    __reserved1;
    uint32_t    fromCapabilities;
    uint32_t    toCapabilities;
    uint32_t    __reserved2[4];
};

/*! @enum IOPMSystemCapabilityChangeFlags
    @constant kIOPMSystemCapabilityWillChange Indicates the system capability will change.
    @constant kIOPMSystemCapabilityDidChange Indicates the system capability has changed.
*/
enum {
    kIOPMSystemCapabilityWillChange = 0x01,
    kIOPMSystemCapabilityDidChange  = 0x02
};

enum {
    kIOPMSystemCapabilityCPU        = 0x01,
    kIOPMSystemCapabilityGraphics   = 0x02,
    kIOPMSystemCapabilityAudio      = 0x04,
    kIOPMSystemCapabilityNetwork    = 0x08
};

#endif /* ! _IOKIT_IOPM_H */
                                                                                         IOPMLibDefs.h                                                                                       0100644 0001750 0001750 00000004017 12567450740 035654  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


#define	kPMSetAggressiveness            0
#define	kPMGetAggressiveness            1
#define	kPMSleepSystem                  2
#define	kPMAllowPowerChange             3
#define	kPMCancelPowerChange            4
#define	kPMShutdownSystem               5
#define	kPMRestartSystem                6
#define kPMSleepSystemOptions           7
#define kPMSetMaintenanceWakeCalendar   8
#define kPMSetUserAssertionLevels       9
#define kPMActivityTickle               10
#define kPMGetSystemSleepType           11
#define kPMSetClamshellSleepState       12
#define kPMSleepWakeWatchdogEnable      13
#define kPMSleepWakeDebugTrig           14
#define kPMSetDisplayPowerOn            15

#define kNumPMMethods                   16
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IOPMPowerSource.h                                                                                   0100644 0001750 0001750 00000022430 12567450740 036620  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
 
#ifndef _IOPMPowerSource_h_
#define _IOPMPowerSource_h_

#include <libkern/c++/OSObject.h>
#include <IOKit/pwr_mgt/IOPM.h>
#include <IOKit/IOTypes.h>
#include <IOKit/IOReturn.h>
#include <IOKit/IOService.h>

enum {
    kSecondsPerHour = 3600,
    kTenMinutesInSeconds = 600
};

/*! @class IOPMPowerSource
 *
 * See IOKit/pwr_mgt/IOPM.h for power source keys relevant to this class. These
 * report-type keys are required for calls to IOPMPowerSource::setReportables(),
 * and they define the IORegistry interface through which data is passed back
 * up to the rest of the system.
 *
 * A subclassing driver that doesn't want to do anything fancy should:
 *   1. Subclass IOPMPowerSource
 *   2. Install its own battery change notifications or polling routine that can
 *          converse with actual battery hardware.
 *   3. When battery state changes, change the relevant member variables
 *          through setCurrentCapacity() style accessors.
 *   4. Call updateStatus() on itself when all such settings have been updated.
 *   
 * The subclass driver should also initially populate its settings and call
 * updateStatus() on launch.
 *
 *
 * Settings:
 *
 * <pre>
 * ExternalConnected
 * Type: bool
 * IORegistry Key: kIOPMPSExternalConnectedKey
 * True if computer is drawing external power 
 *
 * ExternalChargeCapable
 * Type: bool
 * IORegistry Key: kIOPMPSExternalChargeCapableKey
 * True if external power is capable of charging internal battery
 *
 * BatteryInstalled
 * Type: bool
 * IORegistry Key: kIOPMPSBatteryInstalledKey
 * True if a battery is present; false if removed
 *
 * IsCharging
 * Type: bool
 * IORegistry Key: kIOPMPSIsChargingKey
 * True if battery is charging itself from external power
 *
 * AtWarnLevel
 * Type: bool
 * IORegistry Key: kIOPMPSAtWarnLevelKey
 * True if draining battery capacity and past warn level
 *
 * AtCriticalLevel
 * Type: bool
 * IORegistry Key: kIOPMPSAtCriticalLevelKey
 * True if draining battery capacity and past critical level
 *
 * CurrentCapacity
 * MaxCapacity
 * Type: unsigned int
 * IORegistry Key: kIOPMPSCurrentCapacityKey, kIOPMPSMaxCapacityKey
 * Capacity measured in mAh
 *
 * TimeRemaining
 * Type: int
 * IORegistry Key: kIOPMPSTimeRemainingKey
 * Time remaining measured in minutes
 *
 * Amperage
 * Type: int
 * IORegistry Key: kIOPMPSAmperageKey
 * Current is measured in mA
 *
 * Voltage
 * Type: unsigned int
 * IORegistry Key: kIOPMPSVoltageKey
 * Voltage measured in mV
 *
 * CycleCount
 * Type: unsigned int
 * IORegistry Key: kIOPMPSCycleCountKey
 * Number of charge/discharge cycles
 *
 * AdapterInfo
 * Type: int
 * IORegistry Key: kIOPMPSAdapterInfoKey
 * Power adapter information
 *
 * Location
 * Type: int
 * IORegistry Key: kIOPMPSLocationKey
 * Clue about battery's location in machine - Left vs. Right
 *
 * ErrorCondition
 * Type: OSSymbol
 * IORegistry Key: kIOPMPSErrorConditionKey
 * String describing error state of battery
 *
 * Manufacturer
 * Type: OSSymbol
 * IORegistry Key: kIOPMPSManufacturerKey
 * String describing battery manufacturer
 *
 * Manufactured Date
 * Type: unsigned 16-bit bitfield
 * IORegistry Key: kIOPMPSManufactureDateKey
 * Date is published in a bitfield per the Smart Battery Data spec rev 1.1 
 * in section 5.1.26
 *   Bits 0...4 => day (value 1-31; 5 bits)
 *   Bits 5...8 => month (value 1-12; 4 bits)
 *   Bits 9...15 => years since 1980 (value 0-127; 7 bits)
 *
 * Model
 * Type: OSSymbol
 * IORegistry Key: kIOPMPSModelKey
 * String describing model number
 *
 * Serial
 * Type: OSSymbol
 * IORegistry Key: kIOPMPSSerialKey
 * String describing serial number or unique info
 * The serial number published hear bears no correspondence to the Apple serial
 * number printed on each battery. This is a manufacturer serial number with 
 * no correlation to the printed serial number.
 *
 * LegacyIOBatteryInfo
 * Type: OSDictionary
 * IORegistry Key: kIOPMPSLegacyBatteryInfoKey
 * Dictionary conforming to the OS X 10.0-10.4 
 * </pre>
 */

class IOPMPowerSource : public IOService
{
    OSDeclareDefaultStructors(IOPMPowerSource)

    friend class IOPMPowerSourceList;

 protected:

/*! @var settingsChangedSinceLastUpdate
 * Used by subclasses to determine if any settings have been modified via the
 * accessors below since last call to update(). true is settings have changed;
 * false otherwise.
 */
    bool settingsChangedSinceUpdate;
    
/*! @var properties
 * Stores power source state
 */
    OSDictionary            *properties;

    const OSSymbol *externalConnectedKey;
    const OSSymbol *externalChargeCapableKey;
    const OSSymbol *batteryInstalledKey;
    const OSSymbol *chargingKey;
    const OSSymbol *warnLevelKey;
    const OSSymbol *criticalLevelKey;
    const OSSymbol *currentCapacityKey;
    const OSSymbol *maxCapacityKey;
    const OSSymbol *timeRemainingKey;
    const OSSymbol *amperageKey;
    const OSSymbol *voltageKey;
    const OSSymbol *cycleCountKey;
    const OSSymbol *adapterInfoKey;
    const OSSymbol *locationKey;
    const OSSymbol *errorConditionKey;
    const OSSymbol *manufacturerKey;
    const OSSymbol *modelKey;
    const OSSymbol *serialKey;
    const OSSymbol *batteryInfoKey;

    // Tracking for IOPMPowerSourceList
    IOPMPowerSource         *nextInList;

 public:

/*! @function powerSource
    @abstract Creates a new IOPMPowerSource nub. Must be attached to IORegistry,
        and registered by provider.
*/
    static IOPMPowerSource *powerSource(void);

    virtual bool init(void) APPLE_KEXT_OVERRIDE;
    
    virtual void free(void) APPLE_KEXT_OVERRIDE;

/*! @function updateStatus
    @abstract Must be called by physical battery controller when battery state
                has changed significantly.
    @discussion The system will not poll this object for battery updates. Rather \
    the battery's controller must call updateStatus() every time state changes \
    and the settings will be relayed to higher levels of power management. \
    The subclassing driver should override this only if the driver needs to add \
    new settings to the base class.
*/
    virtual void updateStatus(void);

/* Public accessors for battery state
 */
    bool externalConnected(void);
    bool externalChargeCapable(void);
    bool batteryInstalled(void);
    bool isCharging(void);
    bool atWarnLevel(void);
    bool atCriticalLevel(void);

    unsigned int currentCapacity(void);
    unsigned int maxCapacity(void);
    unsigned int capacityPercentRemaining(void);
    int timeRemaining(void);
    int amperage(void);
    unsigned int voltage(void);
    unsigned int cycleCount(void);
    int adapterInfo(void);
    int location(void);
    
    OSSymbol *errorCondition(void);
    OSSymbol *manufacturer(void);
    OSSymbol *model(void);
    OSSymbol *serial(void);
    OSDictionary *legacyIOBatteryInfo(void);
    
    OSObject *getPSProperty(const OSSymbol *);
    
protected:

/* Protected "setter" methods for subclasses
 * Subclasses should use these setters to modify all battery properties.
 * 
 * Subclasses must follow all property changes with a call to updateStatus() 
 * to flush settings changes to upper level battery API clients.
 *
 */
    void setExternalConnected(bool);
    void setExternalChargeCapable(bool);
    void setBatteryInstalled(bool);
    void setIsCharging(bool);
    void setAtWarnLevel(bool);
    void setAtCriticalLevel(bool);

    void setCurrentCapacity(unsigned int);
    void setMaxCapacity(unsigned int);    
    void setTimeRemaining(int);
    void setAmperage(int);    
    void setVoltage(unsigned int);
    void setCycleCount(unsigned int);
    void setAdapterInfo(int);
    void setLocation(int);

    void setErrorCondition(OSSymbol *);
    void setManufacturer(OSSymbol *);
    void setModel(OSSymbol *);
    void setSerial(OSSymbol *);
    void setLegacyIOBatteryInfo(OSDictionary *);

/*! All of these methods funnel through the generic accessor method
   setPSProperty. Caller can pass in any arbitrary OSSymbol key, and
   that value will be stored in the PM settings dictionary, and relayed
   onto the IORegistry at update time.
 */
    void setPSProperty(const OSSymbol *, OSObject *);
};

#endif
                                                                                                                                                                                                                                        IOPMPowerSourceList.h                                                                               0100644 0001750 0001750 00000003774 12567450740 037466  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#include <libkern/c++/OSObject.h>
#include <IOKit/IOReturn.h>

class IOPMPowerSource;

class IOPMPowerSourceList : public OSObject
{
    OSDeclareDefaultStructors(IOPMPowerSourceList)
 private:
    // pointer to first power source in list
    IOPMPowerSource         *firstItem;

    // how many power sources are in the list
    unsigned long           length;

  public:
    void initialize(void);
    void free(void) APPLE_KEXT_OVERRIDE;

    unsigned long numberOfItems(void);
    IOReturn addToList(IOPMPowerSource *newPowerSource);
    IOReturn removeFromList(IOPMPowerSource *theItem);
    
    IOPMPowerSource *firstInList(void);
    IOPMPowerSource *nextInList(IOPMPowerSource *currentItem);
};

    IOPMpowerState.h                                                                                    0100644 0001750 0001750 00000007530 12567450740 036504  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOPMPOWERSTATE_H
#define _IOKIT_IOPMPOWERSTATE_H

#include <IOKit/pwr_mgt/IOPM.h>

/*! @header IOPMpowerState.h
    @abstract Defines the struct IOPMPowerState that power managed drivers should use to describe their power states.
*/

/*! @struct IOPMPowerState
    @abstract Describes a device's power state.
    @discussion To take part in system power management, drivers should define an array of 2 or more power states and pass it to kernel power management through IOService::registerPowerDriver.
    @field version Defines version number of this struct. Just use the value "1" when defining an IOPMPowerState.
    @field	capabilityFlags Describes the capability of the device in this state.
    @field	outputPowerCharacter Describes the power provided in this state.
    @field	inputPowerRequirement Describes the input power required in this state.
    @field	staticPower Describes average consumption in milliwatts. Unused; drivers may specify 0.
    @field	stateOrder Valid in version kIOPMPowerStateVersion2 or greater of this structure. Defines ordering of power states independently of the power state ordinal.
    @field	powerToAttain Describes dditional power to attain this state from next lower state (in milliWatts). Unused; drivers may specify 0.
    @field	timeToAttain Describes time required to enter this state from next lower state (in microseconds). Unused; drivers may specify 0.
    @field	settleUpTime Describes settle time required after entering this state from next lower state (microseconds). Unused; drivers may specify 0.
    @field timeToLower Describes time required to enter next lower state from this one (microseconds). Unused; drivers may specify 0.
    @field	settleDownTime Settle time required after entering next lower state from this state (microseconds). Unused; drivers may specify 0.
    @field	powerDomainBudget Describes power in milliWatts a domain in this state can deliver to its children. Unused; drivers may specify 0.
}
*/

struct IOPMPowerState
{
    unsigned long	version;
    IOPMPowerFlags	capabilityFlags;
    IOPMPowerFlags	outputPowerCharacter;
    IOPMPowerFlags	inputPowerRequirement;
    unsigned long	staticPower;
    unsigned long	stateOrder;
    unsigned long	powerToAttain;
    unsigned long	timeToAttain;
    unsigned long	settleUpTime;
    unsigned long	timeToLower;
    unsigned long	settleDownTime;
    unsigned long	powerDomainBudget;
};

typedef struct IOPMPowerState IOPMPowerState;

enum {
    kIOPMPowerStateVersion1 = 1,
    kIOPMPowerStateVersion2 = 2
};

#endif /* _IOKIT_IOPMPOWERSTATE_H */
                                                                                                                                                                        IOPowerConnection.h                                                                                 0100644 0001750 0001750 00000014237 12567450740 037230  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */


#ifndef _IOKIT_IOPOWERCONNECTION_H
#define _IOKIT_IOPOWERCONNECTION_H

#include <IOKit/IOService.h>
#include <IOKit/pwr_mgt/IOPM.h>

/*! @class IOPowerConnection
 *  Do not use IOPowerConnection. This class is an implementation detail defined
 *  for IOPM's management of the IORegistry IOPower plane.
 *
 *  Only Kernel IOKit power management should reference the IOPowerConnection class.
 */

class IOPowerConnection : public IOService
{
    OSDeclareDefaultStructors(IOPowerConnection)

protected:
    /*! @field parentKnowsState	true: parent knows state of its domain
					used by child */
    bool            stateKnown;

    /*! @field currentPowerFlags	power flags which describe  the current state of the power domain
					used by child */
    IOPMPowerFlags 	currentPowerFlags;

    /*! @field desiredDomainState	state number which corresponds to the child's desire
					used by parent */
    unsigned long	desiredDomainState;

    /*! @field requestFlag		set to true when desiredDomainState is set */
    bool            requestFlag;

    /*! @field preventIdleSleepFlag	true if child has this bit set in its desired state
					used by parent */
    unsigned long	preventIdleSleepFlag;

    /*! @field preventSystemSleepFlag	true if child has this bit set in its desired state
					used by parent */
    unsigned long	preventSystemSleepFlag;

    /*! @field awaitingAck		true if child has not yet acked our notification
					used by parent */
    bool            awaitingAck;

    /*! @field readyFlag		true if the child has been added as a power child
					used by parent */
	bool            readyFlag;


public:
    /*! @function setParentKnowsState
        @abstract Sets the stateKnown variable.
        @discussion Called by the parent when the object is created and called by the child when it discovers that the parent now knows its state. */
    void setParentKnowsState (bool );

    /*! @function setParentCurrentPowerFlags
        @abstract Sets the currentPowerFlags variable.
        @discussion Called by the parent when the object is created and called by the child when it discovers that the parent state is changing. */
    void setParentCurrentPowerFlags (IOPMPowerFlags );

    /*! @function parentKnowsState
        @abstract Returns the stateKnown variable. */
    bool parentKnowsState (void );

    /*! @function parentCurrentPowerFlags
        @abstract Returns the currentPowerFlags variable. */
    IOPMPowerFlags parentCurrentPowerFlags (void );

    /*! @function setDesiredDomainState
        @abstract Sets the desiredDomainState variable.
        @discussion Called by the parent. */
    void setDesiredDomainState (unsigned long );

    /*! @function getDesiredDomainState
        @abstract Returns the desiredDomainState variable.
    @discussion Called by the parent. */
    unsigned long getDesiredDomainState ( void );

    /*! @function setChildHasRequestedPower
        @abstract Set the flag that says that the child has called requestPowerDomainState.
    @discussion Called by the parent. */
    void setChildHasRequestedPower ( void );

    /*! @function childHasRequestedPower
        @abstract Return the flag that says whether the child has called requestPowerDomainState.
    @discussion Called by the PCI Aux Power Supply Driver to see if a device driver
        is power managed. */
    bool childHasRequestedPower ( void );
    
    /*! @function setPreventIdleSleepFlag
        @abstract Sets the preventIdleSleepFlag variable.
        @discussion Called by the parent. */
    void setPreventIdleSleepFlag (unsigned long );

    /*! @function getPreventIdleSleepFlag
        @abstract Returns the preventIdleSleepFlag variable.
    @discussion Called by the parent. */
    bool getPreventIdleSleepFlag ( void );
    
    /*! @function setPreventSystemSleepFlag
        @abstract Sets the preventSystemSleepFlag variable.
        @discussion Called by the parent. */
    void setPreventSystemSleepFlag (unsigned long );

    /*! @function getPreventSystemSleepFlag
        @abstract Returns the preventSystemSleepFlag variable.
        @discussion Called by the parent. */
    bool getPreventSystemSleepFlag ( void );
    
    /*! @function setAwaitingAck
        @abstract Sets the awaitingAck variable.
        @discussion Called by the parent. */
    void setAwaitingAck ( bool );

    /*! @function getAwaitingAck
        @abstract Returns the awaitingAck variable.
        @discussion Called by the parent. */
    bool getAwaitingAck ( void );

    /*! @function setReadyFlag
        @abstract Sets the readyFlag variable.
        @discussion Called by the parent. */
	void setReadyFlag( bool flag );

    /*! @function getReadyFlag
        @abstract Returns the readyFlag variable.
        @discussion Called by the parent. */
	bool getReadyFlag( void ) const;
};

#endif /* ! _IOKIT_IOPOWERCONNECTION_H */

                                                                                                                                                                                                                                                                                                                                                                 RootDomain.h                                                                                        0100644 0001750 0001750 00000037424 12567450740 035742  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/pwr_mgt                                                        /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_ROOTDOMAIN_H
#define _IOKIT_ROOTDOMAIN_H

#include <IOKit/IOService.h>
#include <IOKit/pwr_mgt/IOPM.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <sys/vnode.h>


/*!
 * Types for PM Assertions
 * For creating, releasing, and getting PM assertion levels.
 */

/*! IOPMDriverAssertionType
 * A bitfield describing a set of assertions. May be used to specify which assertions
 * to set with <link>IOPMrootDomain::createPMAssertion</link>; or to query which
 * assertions are set with <link>IOPMrootDomain::releasePMAssertion</link>.
 */
typedef uint64_t IOPMDriverAssertionType;

/* IOPMDriverAssertionID
 * Drivers may create PM assertions to request system behavior (keep the system awake,
 *  or keep the display awake). When a driver creates an assertion via
 *  <link>IOPMrootDomain::createPMAssertion</link>, PM returns a handle to
 *  the assertion of type IOPMDriverAssertionID.
 */
typedef uint64_t IOPMDriverAssertionID;
#define kIOPMUndefinedDriverAssertionID       0

/* IOPMDriverAssertionLevel
 * Possible values for IOPMDriverAssertionLevel are <link>kIOPMDriverAssertionLevelOff</link>
 * and <link>kIOPMDriverAssertionLevelOn</link>
 */
typedef uint32_t IOPMDriverAssertionLevel;
#define kIOPMDriverAssertionLevelOff          0
#define kIOPMDriverAssertionLevelOn           255

/*
 * Flags for get/setSleepSupported()
 */
enum {
    kRootDomainSleepNotSupported    = 0x00000000,
    kRootDomainSleepSupported         = 0x00000001,
    kFrameBufferDeepSleepSupported    = 0x00000002,
    kPCICantSleep                   = 0x00000004
};

/*
 *IOPMrootDomain registry property keys
 */
#define kRootDomainSupportedFeatures        "Supported Features"
#define kRootDomainSleepReasonKey           "Last Sleep Reason"
#define kRootDomainSleepOptionsKey          "Last Sleep Options"
#define kIOPMRootDomainWakeReasonKey        "Wake Reason"
#define kIOPMRootDomainWakeTypeKey          "Wake Type"
#define kIOPMRootDomainPowerStatusKey       "Power Status"

/*
 * Possible sleep reasons found under kRootDomainSleepReasonsKey
 */
#define kIOPMClamshellSleepKey              "Clamshell Sleep"
#define kIOPMPowerButtonSleepKey            "Power Button Sleep"
#define kIOPMSoftwareSleepKey               "Software Sleep"
#define kIOPMOSSwitchHibernationKey         "OS Switch Sleep"
#define kIOPMIdleSleepKey                   "Idle Sleep"
#define kIOPMLowPowerSleepKey               "Low Power Sleep"
#define kIOPMThermalEmergencySleepKey       "Thermal Emergency Sleep"
#define kIOPMMaintenanceSleepKey            "Maintenance Sleep"

/*
 * String constants for communication with PM CPU
 */
#define kIOPMRootDomainLidCloseCString      "LidClose"
#define kIOPMRootDomainBatPowerCString      "BatPower"

/*
 * Supported Feature bitfields for IOPMrootDomain::publishFeature()
 */
enum {
    kIOPMSupportedOnAC      = (1<<0),
    kIOPMSupportedOnBatt    = (1<<1),
    kIOPMSupportedOnUPS     = (1<<2)
};

typedef IOReturn (*IOPMSettingControllerCallback)
                    (OSObject *target, const OSSymbol *type,
                     OSObject *val, uintptr_t refcon);

__BEGIN_DECLS
IONotifier *    registerSleepWakeInterest(
                    IOServiceInterestHandler, void *, void * = 0);

IONotifier *    registerPrioritySleepWakeInterest(
                    IOServiceInterestHandler handler,
                    void * self, void * ref = 0);

IOReturn        acknowledgeSleepWakeNotification(void * );

IOReturn        vetoSleepWakeNotification(void * PMrefcon);
__END_DECLS

#define IOPM_ROOTDOMAIN_REV        2

class IOPMrootDomain: public IOService
{
    OSDeclareFinalStructors(IOPMrootDomain)

public:
    static IOPMrootDomain * construct( void );

    virtual bool        start( IOService * provider ) APPLE_KEXT_OVERRIDE;
    virtual IOReturn    setAggressiveness( unsigned long, unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual IOReturn    getAggressiveness( unsigned long, unsigned long * ) APPLE_KEXT_OVERRIDE;

    virtual IOReturn    sleepSystem( void );
    IOReturn            sleepSystemOptions( OSDictionary *options );

    virtual IOReturn    setProperties( OSObject * ) APPLE_KEXT_OVERRIDE;
    virtual bool        serializeProperties( OSSerialize * s ) const APPLE_KEXT_OVERRIDE;
    virtual OSObject *  copyProperty( const char * aKey ) const APPLE_KEXT_OVERRIDE;

/*! @function systemPowerEventOccurred
    @abstract Other drivers may inform IOPMrootDomain of system PM events
    @discussion systemPowerEventOccurred is a richer alternative to receivePowerNotification()
        Only Apple-owned kexts should have reason to call systemPowerEventOccurred.
    @param event An OSSymbol describing the type of power event.
    @param value A 32-bit integer value associated with the event.
    @param shouldUpdate indicates whether the root domain should send a notification
        to interested parties. Pass false if you're calling systemPowerEventOccurred
        several times in succession; and pass true only on the last invocatino.
    @result kIOReturnSuccess on success */

    IOReturn            systemPowerEventOccurred(
                                    const OSSymbol *event,
                                    uint32_t intValue );

    IOReturn            systemPowerEventOccurred(
                                    const OSSymbol *event,
                                    OSObject *value );

    void 				claimSystemWakeEvent( IOService     *device,
                                              IOOptionBits  flags,
                                              const char    *reason,
                                              OSObject      *details = 0 );

    virtual IOReturn    receivePowerNotification( UInt32 msg );

    virtual void        setSleepSupported( IOOptionBits flags );

    virtual IOOptionBits getSleepSupported( void );

    void                wakeFromDoze( void );

    // KEXT driver announces support of power management feature

    void                publishFeature( const char *feature );

    // KEXT driver announces support of power management feature
    // And specifies power sources with kIOPMSupportedOn{AC/Batt/UPS} bitfield.
    // Returns a unique uint32_t identifier for later removing support for this
    // feature.
    // NULL is acceptable for uniqueFeatureID for kexts without plans to unload.

    void                publishFeature( const char *feature,
                                        uint32_t supportedWhere,
                                        uint32_t *uniqueFeatureID);

    // KEXT driver announces removal of a previously published power management
    // feature. Pass 'uniqueFeatureID' returned from publishFeature()

    IOReturn            removePublishedFeature( uint32_t removeFeatureID );

/*! @function copyPMSetting
    @abstract Copy the current value for a PM setting. Returns an OSNumber or
        OSData depending on the setting.
    @param whichSetting Name of the desired setting.
    @result OSObject value if valid, NULL otherwise. */

    OSObject *          copyPMSetting( OSSymbol *whichSetting );

/*! @function registerPMSettingController
    @abstract Register for callbacks on changes to certain PM settings.
    @param settings NULL terminated array of C strings, each string for a PM
        setting that the caller is interested in and wants to get callbacks for.
    @param callout C function ptr or member function cast as such.
    @param target The target of the callback, usually 'this'
    @param refcon Will be passed to caller in callback; for caller's use.
    @param handle Caller should keep the OSObject * returned here. If non-NULL,
        handle will have a retain count of 1 on return. To deregister, pass to
        unregisterPMSettingController()
    @result kIOReturnSuccess on success. */

    IOReturn            registerPMSettingController(
                                 const OSSymbol *settings[],
                                 IOPMSettingControllerCallback callout,
                                 OSObject   *target,
                                 uintptr_t  refcon,
                                 OSObject   **handle);    // out param

/*! @function registerPMSettingController
    @abstract Register for callbacks on changes to certain PM settings.
    @param settings NULL terminated array of C strings, each string for a PM
        setting that the caller is interested in and wants to get callbacks for.
    @param supportedPowerSources bitfield indicating which power sources these
        settings are supported for (kIOPMSupportedOnAC, etc.)
    @param callout C function ptr or member function cast as such.
    @param target The target of the callback, usually 'this'
    @param refcon Will be passed to caller in callback; for caller's use.
    @param handle Caller should keep the OSObject * returned here. If non-NULL,
        handle will have a retain count of 1 on return. To deregister, pass to
        unregisterPMSettingController()
    @result kIOReturnSuccess on success. */

    IOReturn            registerPMSettingController(
                                 const OSSymbol *settings[],
                                 uint32_t   supportedPowerSources,
                                 IOPMSettingControllerCallback callout,
                                 OSObject   *target,
                                 uintptr_t  refcon,
                                 OSObject   **handle);    // out param

    virtual IONotifier * registerInterest(
                                const OSSymbol * typeOfInterest,
                                IOServiceInterestHandler handler,
                                void * target, void * ref = 0 ) APPLE_KEXT_OVERRIDE;

    virtual IOReturn    callPlatformFunction(
                                const OSSymbol *functionName,
                                bool waitForFunction,
                                void *param1, void *param2,
                                void *param3, void *param4 ) APPLE_KEXT_OVERRIDE;

/*! @function createPMAssertion
    @abstract Creates an assertion to influence system power behavior.
    @param whichAssertionBits A bitfield specify the assertion that the caller requests.
    @param assertionLevel An integer detailing the initial assertion level, kIOPMDriverAssertionLevelOn
        or kIOPMDriverAssertionLevelOff.
    @param ownerService A pointer to the caller's IOService class, for tracking.
    @param ownerDescription A reverse-DNS string describing the caller's identity and reason.
    @result On success, returns a new assertion of type IOPMDriverAssertionID
*/
    IOPMDriverAssertionID createPMAssertion(
                                IOPMDriverAssertionType whichAssertionsBits,
                                IOPMDriverAssertionLevel assertionLevel,
                                IOService *ownerService,
                                const char *ownerDescription);

/* @function setPMAssertionLevel
   @abstract Modify the level of a pre-existing assertion.
   @discussion Change the value of a PM assertion to influence system behavior,
    without undergoing the work required to create or destroy an assertion. Suggested
    for clients who will assert and de-assert needs for PM behavior several times over
    their lifespan.
   @param assertionID An assertion ID previously returned by <link>createPMAssertion</link>
   @param assertionLevel The new assertion level.
   @result kIOReturnSuccess if it worked; kIOReturnNotFound or other IOReturn error on failure.
*/
    IOReturn setPMAssertionLevel(IOPMDriverAssertionID assertionID, IOPMDriverAssertionLevel assertionLevel);

/*! @function getPMAssertionLevel
    @absract Returns the active level of the specified assertion(s).
    @discussion Returns <link>kIOPMDriverAssertionLevelOff</link> or
        <link>kIOPMDriverAssertionLevelOn</link>. If multiple assertions are specified
        in the bitfield, only returns <link>kIOPMDriverAssertionLevelOn</link>
        if all assertions are active.
    @param whichAssertionBits Bits defining the assertion or assertions the caller is interested in
        the level of. If in doubt, pass <link>kIOPMDriverAssertionCPUBit</link> as the argument.
    @result Returns <link>kIOPMDriverAssertionLevelOff</link> or
        <link>kIOPMDriverAssertionLevelOn</link> indicating the specified assertion's levels, if available.
        If the assertions aren't supported on this machine, or aren't recognized by the OS, the
        result is undefined.
*/
    IOPMDriverAssertionLevel getPMAssertionLevel(IOPMDriverAssertionType whichAssertionBits);

/*! @function releasePMAssertion
    @abstract Removes an assertion to influence system power behavior.
    @result On success, returns a new assertion of type IOPMDriverAssertionID *
*/
    IOReturn releasePMAssertion(IOPMDriverAssertionID releaseAssertion);

/*! @function restartWithStackshot
    @abstract Take a stackshot of the system and restart the system.
    @result Return kIOReturnSuccess if it work, kIOReturnError if the service is not available.
*/
    IOReturn restartWithStackshot();

private:
    virtual IOReturn    changePowerStateTo( unsigned long ordinal ) APPLE_KEXT_COMPATIBILITY_OVERRIDE;
    virtual IOReturn    changePowerStateToPriv( unsigned long ordinal );
    virtual IOReturn    requestPowerDomainState( IOPMPowerFlags, IOPowerConnection *, unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual void        powerChangeDone( unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual bool        tellChangeDown( unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual bool        askChangeDown( unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual void        tellChangeUp( unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual void        tellNoChangeDown( unsigned long ) APPLE_KEXT_OVERRIDE;
    virtual IOReturn configureReport(IOReportChannelList   *channels,
                                    IOReportConfigureAction action,
                                    void                    *result,
                                    void                    *destination) APPLE_KEXT_OVERRIDE;
    virtual IOReturn updateReport(IOReportChannelList      *channels,
                                  IOReportUpdateAction     action,
                                  void                     *result,
                                  void                     *destination) APPLE_KEXT_OVERRIDE;

    void             configureReportGated(uint64_t channel_id,
                                          uint64_t action,
                                          void     *result);
    IOReturn         updateReportGated(uint64_t ch_id, 
                                       void *result, 
                                       IOBufferMemoryDescriptor *dest);

};


#endif /* _IOKIT_ROOTDOMAIN_H */
                                                                                                                                                                                                                                            rtc/                                                                                                0040755 0001750 0001750 00000000000 12612224742 032610  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IORTCController.h                                                                                   0100644 0001750 0001750 00000003254 12567450737 035724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/rtc                                                            /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * 24 Nov  1998 suurballe  Created.
 */

#include <IOKit/IOService.h>

typedef void (*RTC_tick_handler)( IOService * );


class IORTCController: public IOService
{
OSDeclareAbstractStructors(IORTCController)

public:

virtual IOReturn getRealTimeClock ( UInt8 * currentTime, IOByteCount * length ) = 0;
virtual IOReturn setRealTimeClock ( UInt8 * newTime ) = 0;
};

                                                                                                                                                                                                                                                                                                                                                    sbp2/                                                                                               0040755 0001750 0001750 00000000000 12612224742 032666  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOFireWireSBP2LSIWorkaroundDescriptor.h                                                             0100644 0001750 0001750 00000027671 12567452043 042135  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#if __ppc__

/*!
  @header IOFireWireSBP2LSIWorkaroundDescriptor
  Contains the class definition for IOFireWireSBP2LSIWorkaroundDescriptor.
*/

#ifndef _IOKIT_IOFIREWIRESBP2LSIWORKAROUNDDESCRIPTOR_H
#define _IOKIT_IOFIREWIRESBP2LSIWORKAROUNDDESCRIPTOR_H

#include <IOKit/IOMemoryDescriptor.h>

class IOFireWireSBP2LSIRange;

/*!
    @class IOFireWireSBP2LSIWorkaroundDescriptor
    @abstract This is a subclass of IOGeneralMemoryDescriptor. It is designed to work around
    a hardware problem in a common SBP2 target.  It takes a memory descriptor as
	an argument.  It retains this descriptor and returns a new one with resegmented
	physical segments and potentially some "unfixable" segments double buffered.

    If the transfer will cause data to be sent from the Mac, syncBuffersForOutput
    must be called before the transfer.
    
    If the transfer will cause data to be recieve by the Mac, syncBuffersForInput
    must be called after the transfer.

    This class calculates the new segmentation only once when it is created.
    Any changes to the structure of the original memory descriptor will render
    this one useless.  It must be released and a new IOFireWireSBP2LSIWorkaroundDescriptor
    can be created.
    
    LSI Bridge Workaround Algorithm Details
    
    Goals:
    1. Avoid LSI Logic "< 16 byte" bug - prevent any data packet smaller than 16 bytes
    2. Minimize double-buffering
    3. Support non-multiple-of-512-byte devices, e.g. CD Audio
    
    Solution:
    Write a page table such that the bridge will nor use packets smaller than 16 bytes.
    In other words, rearrange the memory descriptor to avoid the bug, and do it such
    that the SBP-2 layer will not break up a segment (du ro the 64k-1 limit) and
    re-introduces the problem

    SBP-2 defines the kFWSBP2MaxPageClusterSize constant.   We simply make sure
    none of our segments are larger than this size and SBP-2 will not break them
    up when it writes the SBP-2 page table.
    
    Notes:
    - Some double buffering is unavoidable.  Discontiguous pages may yield page
    fragments at the start or end of the buffer (or both, with non-512x buffers).
    solution uses less than 33 bytes of double-buffer per segment in original
    memory descriptor.
    - If driver must break up IO to meet ATA limit of 255 (250?) blocks, assume
    the driver does this at a higher level (before applying workaround).
    - It is expected that the original memory descriptor has been prepared (wired)
*/

class IOFireWireSBP2LSIWorkaroundDescriptor : public IOGeneralMemoryDescriptor
{
	OSDeclareDefaultStructors(IOFireWireSBP2LSIWorkaroundDescriptor)

	friend class IOFireWireSBP2LSIRange;

protected:

    // reserved for future use
    struct ExpansionData { };
    ExpansionData *reserved; 
    
	bool	fFixedCapacity; 	// for both allocators
	
	//////////////////////////////////////
	// for range allocator

	OSArray *				fPermanentRanges;
	UInt32					fAllocatedRangesCount;

	virtual IOReturn rangeAllocatorInitialize( UInt32 rangeCount );
	virtual void rangeAllocatorDeallocateAllRanges( void );
	virtual IOFireWireSBP2LSIRange * rangeAllocatorNewRange( void );
	virtual void rangeAllocatorFree( void );

	//////////////////////////////////////
	// for buffer allocator
	
	OSArray *				fBufferDescriptors;
	UInt32					fPermanentPages;
	IOByteCount				fAllocatedBytesCount;

	virtual IOReturn bufferAllocatorInitialize( IOByteCount requestedBufferSize );
	virtual void bufferAllocatorDeallocateAllBuffers( void );
	virtual void * bufferAllocatorNewBuffer( IOPhysicalAddress * address );
	virtual void bufferAllocatorFree( void );

	//////////////////////////////////////
	// for range table allocator
	
	IOPhysicalRange * 		fRangeTable;
	IOByteCount				fRangeTableSize;

	virtual IOReturn rangeTableAllocatorInitialize( UInt32 requestedBufferSize );
	virtual IOPhysicalRange * rangeTableAllocatorNewTable( UInt32 entries );
	virtual void rangeTableAllocatorFree( void );

	//////////////////////////////////////
	// for workaround

	IOMemoryDescriptor * 	fOriginalDesc;	
	OSArray *				fRanges;	
	IOByteCount 			fOffset;
	IOByteCount				fLength;
	IODirection				fDirection;
	
						  
	virtual bool initWithCapacity
					( UInt32 permanentRanges, IOByteCount permanentBufferSpace, bool fixedCapacity );

	virtual void free();
	
	virtual IOReturn resetToInitialCapacity( void );
	virtual IOReturn initializeRangesArray( void );
	virtual IOReturn recalculateSmallSegments( void );
	virtual IOReturn splitLargeSegments( void );
	virtual IOReturn resegmentOddLengthSegments( void );
	virtual IOReturn initializeBuffers( void );

	virtual bool initWithAddress( void *      address,       /* not supported */
                                  IOByteCount withLength,
                                  IODirection withDirection );

    virtual bool initWithAddress( vm_address_t address,      /* not supported */
                                  IOByteCount  withLength,
                                  IODirection  withDirection,
                                  task_t       withTask );

    virtual bool initWithPhysicalAddress( 
                                  IOPhysicalAddress address, /* not supported */
                                  IOByteCount       withLength,
                                  IODirection       withDirection );

    virtual bool initWithPhysicalRanges( 
                                  IOPhysicalRange * ranges,  /* not supported */
                                  UInt32            withCount,
                                  IODirection       withDirection,
                                  bool              asReference = false );

    virtual bool initWithRanges(  IOVirtualRange * ranges,   /* not supported */
                                  UInt32           withCount,
                                  IODirection      withDirection,
                                  task_t           withTask,
                                  bool             asReference = false );

public:
	
	// static factory methods and intializers 
	
	//
	// create a new instance
	//
	
	
    /*!
		@function withDescriptor
		@abstract Creates a new IOFireWireSBP2LSIWorkaroundDescriptor.
		@discussion	Create a IOFireWireSBP2LSIWorkaroundDescriptor with no permanent capacity then 
        inits it the given descriptor. This is basicly a short cut for calling 
        withCapacity( 0, 0, false) and the initWithDescriptor()
        @param desc Original memory descriptor.
        @param offset Offset of data to "fix" in bytes from beginning of descriptor.
        @param len Length of data in bytes to "fix"
        @param direction IODirection of data transfer.
        @result Returns a new IOFireWireSBP2LSIWorkaroundDescriptor if successful.
	*/
    
	static IOFireWireSBP2LSIWorkaroundDescriptor * withDescriptor
					( IOMemoryDescriptor * desc, IOByteCount offset = 0,  
					  IOByteCount len = 0, IODirection direction = kIODirectionOutIn );
	
	// initialize with descriptor				  
	
    /*!
		@function initWithDescriptor
		@abstract Initialize an IOFireWireSBP2LSIWorkaroundDescriptor with the given descriptor.
		@discussion	Initialize the workaround descriptor with the given descriptor. 
        @param desc Original memory descriptor.
        @param offset Offset of data to "fix" in bytes from beginning of descriptor.
        @param len Length of data in bytes to "fix"
        @param direction IODirection of data transfer.
        @result Returns true if the initialization was successful.
	*/
    
    virtual bool initWithDescriptor( IOMemoryDescriptor * desc, IOByteCount offset = 0,  
								     IOByteCount len = 0, IODirection direction = kIODirectionOutIn );
	
	
	///////////////////////////////////
	
    
    /*!
		@function withCapacity
		@abstract Create a new descriptor with possibly a permanent capacity.
		@discussion	Create and IOFireWireSBP2LSIWorkaroundDescriptor with a permanent fixed capacity. 
        You should call initWithDescriptor afterward. permanentRanges is number of ranges to keep 
        permanently allocated for use by the algorithm.  If fixedCapacity is false additional ranges 
        may be allocated and deallocated dyanmicly if needed. The algorithm may require more or less 
        ranges than either the original descriptor or the final fixed may decriptor contain.
        permanentBufferSpace is the number of bytes of permanent buffer to keep arround. If fixedCapacity 
        is false additional buffer space may be allocated and deallocated dynamically. permanentBufferSpace 
        should generally be set to 32 * maximum number of ranges. fixedCapacity is a flag indicating 
        whether dynamic allocations are allowed. When making decisions about the maximum amount of 
        buffer space to keep around, it should be noted tha the maximum number of ranges maybe different 
        from permanentRanges if fixedCapcity is false.
        @param permanentRanges Count of permanent ranges.
        @param permanentBufferSpace Byte count of permanent buffers.
        @param fixedCapacity bool indicating if dynamic allocations can be made.
        @result Returns true if the initialization was successful.
	*/
    
	static IOFireWireSBP2LSIWorkaroundDescriptor * withCapacity
						( UInt32 permanentRanges, IOByteCount permanentBufferSpace, bool fixedCapacity );


	///////////////////////////////////

	//
	// manipulate buffers for IO
	//

    /*!
		@function syncBuffersForOutput
		@abstract Synchronize the buffers for output.
		@discussion	Since double buffering may be invovled in the workaround.  The driver needs to 
        indicate when these buffers should be syncronized with the original descriptor.  For data 
        that will be output syncBuffersForOutput should be called before submiting the ORB.
        @result Returns kIOReturnSuccess if sync was successful.
	*/
    	
	virtual IOReturn syncBuffersForOutput( void );  // call before output

    /*!
		@function syncBuffersForInput
		@abstract Synchronize the buffers for input.
		@discussion	Since double buffering may be invovled in the workaround.  The driver needs to 
        indicate when these buffers should be syncronized with the original descriptor.  For data 
        that will be input syncBuffersForOutput should be called after receiving completion status 
        for the ORB.
        @result Returns kIOReturnSuccess if sync was successful.
	*/
    
    virtual IOReturn syncBuffersForInput( void );	// call after input
    
private:

    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LSIWorkaroundDescriptor, 8);
    
};

#endif

#endif
                                                                       IOFireWireSBP2LUN.h                                                                                 0100644 0001750 0001750 00000024244 12567452043 036022  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
  @header IOFireWireSBP2LUN
  Contains the class definition for IOFireWireSBP2LUN.
*/

#ifndef _IOKIT_IOFIREWIRESBP2LUN_H
#define _IOKIT_IOFIREWIRESBP2LUN_H

#include <IOKit/IOService.h>
#include <IOKit/IOCommandGate.h>

#include <IOKit/firewire/IOFireWireUnit.h>

#include <IOKit/sbp2/IOFireWireSBP2Login.h>
#include <IOKit/sbp2/IOFireWireSBP2ManagementORB.h>

class IOFireWireSBP2Target;

/*!
    @class IOFireWireSBP2LUN
    @abstract Provider for most drivers. 
    @discussion IOFireWireSBP2LUN objects are created by IOFireWireSBP2Target objects.  Each target may have zero or more IOFireWireSBP2LUN children. The LUN object serves as the matching nub for most drivers and therefore will be the provider for most drivers.  It supplies the methods that control the operation of the LUN as a whole.  Methods that control the behavior and execution of an SBP2 login session are supplied in a separate IOFireWireSBP2Login object. The LUN can be used to create one of these login objects.
    The LUN can also create IOFireWireSBP2ManagementORBs for configuring and appending non-login related management functions.  Login related management functions (ie. Login, Logout, Reconnect) are supplied by the IOFireWireSBP2Login.
    Finally the LUN can supply a reference to the IOFireWireUnit.  This can be useful if a driver wishes to access the standard FireWire APIs.  
*/

class IOFireWireSBP2LUN : public IOService
{
    OSDeclareDefaultStructors( IOFireWireSBP2LUN );

	friend class IOFireWireSBP2ManagementORB;
	friend class IOFireWireSBP2Login;
	friend class IOFireWireSBP2UserClient;
	
protected: 

    // reserved for future use
    struct ExpansionData { };
    ExpansionData *reserved;

	////////////////////////////////////////////
	// methods called by friend classes

	// IOFireWireSBP2Login methods
    virtual void removeLogin( IOFireWireSBP2Login * login );
	virtual IOFireWireSBP2Target * getTarget( void );
	
	// IOFireWireSBP2ManagementORB methods
	virtual void clearAllTasksInSet( void );  // assumes caller is on workloop
	virtual void removeManagementORB( IOFireWireSBP2ManagementORB * orb ); 
	
	// IOFireWireSBP2UserClient methods
	virtual void flushAllManagementORBs( void );

public:

	////////////////////////////////////////////
	// IOService overrides

    /*! @function attach
        @abstract Attaches an IOService client to a provider in the registry.
        @discussion See IOService for discussion.
        @param provider The IOService object which will serve as this objects provider.
        @result false if the provider is inactive or on a resource failure, otherwise true. 
    */
    
    virtual bool attach( IOService *provider );

	/*! @function handleOpen
		@abstract Overrideable method to control the open / close behaviour of an IOService.
		@discussion See IOService for discussion.		
		@param forClient Designates the client of the provider requesting the open.
		@param options Options for the open, may be interpreted by the implementor of handleOpen.
		@result Return true if the open was successful, false otherwise. */

    virtual bool handleOpen(  IOService *	  forClient,
                              IOOptionBits	  options,
                              void *		  arg );
	/*! 
		@function handleClose
		@abstract Overrideable method to control the open / close behaviour of an IOService.
		@discussion See IOService for discussion.
		@param forClient Designates the client of the provider requesting the close.
		@param options Options for the close, may be interpreted by the implementor of handleOpen. 
	*/

    virtual void handleClose(   IOService *		forClient,
                                IOOptionBits	options );
    
 	/*! 
		@function matchPropertyTable
		@abstract Implements SBP2 specific matching.
		@discussion See IOService for discussion.
	    @param table The dictionary of properties to be matched against.
		@result Returns false if the family considers the matching dictionary does not match in properties it 			understands, true otherwise.
	*/
    	
	virtual bool matchPropertyTable(OSDictionary * table);
																	
protected:

	////////////////////////////////////////////
	// private fields
	
    IOFireWireSBP2Target * 	fProviderTarget;
    UInt32					fLUNumber;
    OSSet *					fLoginSet;
    OSIterator *			fLoginSetIterator;
	IOCommandGate * 		fGate;
	OSSet *					fORBSet;
    OSIterator *			fORBSetIterator;
	OSObject * 				fDiagnostics;
	
	////////////////////////////////////////////
	// private methods
	
	// IOService methods
    virtual void free( void );
    virtual IOReturn message( UInt32 type, IOService * provider, void * argument = 0 );
    
	// create management orb internals
	static IOReturn staticCreateManagementORBAction( OSObject *self,
													 void * refCon,
													 void * completion, 
													 void * orb, 
													 void * );
	virtual IOReturn createManagementORBAction( void * refCon,
												FWSBP2ManagementCallback completion, 
												IOFireWireSBP2ManagementORB ** orb );

	// remove management orb internals
	static IOReturn staticRemoveManagementORBAction( OSObject * self, void * orb, 
													void *, void *, void * );
	virtual IOReturn removeManagementORBAction( IOFireWireSBP2ManagementORB * orb );

	// flush all management orb internals
	static IOReturn staticExecuteFlushAllMgmtORBs( OSObject * self, void *, 
													void *, void *, void * );
	virtual IOReturn executeFlushAllMgmtORBs( void );

	// IOFireWireSBP2ManagementORB friend class wrappers
    virtual bool initMgmtORBWithLUN( IOFireWireSBP2ManagementORB * orb, IOFireWireSBP2LUN * lun, 
									 void * refCon, 
									 FWSBP2ManagementCallback completion );
									 		
	// IOFireWireSBP2Login friend class wrappers
    virtual bool initLoginWithLUN( IOFireWireSBP2Login * login, IOFireWireSBP2LUN * lun );
	virtual void suspendedNotify( void );
	virtual void resumeNotify( void );
		
private:

    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 0);

public:

	////////////////////////////////////////////
    // client methods

	// getters
	
    /*!
		@function getFireWireUnit
		@abstract Returns an IOFireWireUnit object.
		@discussion An IOFireWireUnit is the provider of an IOFireWireSBP2Target.  In order to 
        use the base FireWire services you will need a reference to the unit.  This method 
        returns that reference.
		@result Returns a pointer to an IOFireWireUnit.
	*/
    
    virtual IOFireWireUnit * getFireWireUnit( void );
    
    /*!
		@function getLUNumber
		@abstract Returns the LUNs number.
		@discussion Each LUN has a number to uniquely identify it on a device.  This method returns 
        this value in a UInt32.		
        @result Returns a UInt32 containing the Logical Unit Number.
	*/
    
	virtual UInt32 getLUNumber( void );
    
	// factory methods
    
    /*!
		@function createLogin
		@abstract Creates a new IOFireWireSBP2Login object.
		@discussion	Creates a new IOFireWireSBP2Login object for the LUN.  Login objects supply most 
        of the SBP2 APIs related to login maintenance and Normal Command ORB execution.
        @result Returns a pointer to a new IOFireWireSBP2Login.
	*/

    virtual IOFireWireSBP2Login *createLogin( void );	

    /*!
		@function createManagementORB
		@abstract Creates a new IOFireWireSBP2ManagementORB object.
		@discussion	Creates a new IOFireWireSBP2ManagementORB object.  Management objects let you 
        execute commands like QueryLogins, LogicalUnitReset, and AbortTask.  These commands are 
        configured after they are created here.  When they are done executing (after a call to submit) 
        the supplied completion routine will be called with the supplied refcon.  Usually this refCon
        is the "this" pointer of completion method's object.
        @param refCon The refcon passed to the completion routine.
        @param completion The completion routine.  Called when the ORB finishes execution.	
        @result Returns a pointer to a new IOFireWireSBP2Login.
	*/
        
    virtual IOFireWireSBP2ManagementORB * createManagementORB( void * refCon, FWSBP2ManagementCallback completion );

protected:

    static IOReturn staticCreateLogin( OSObject *self, void * login, void *, void *, void * );
    virtual IOReturn createLoginAction( IOFireWireSBP2Login ** login );

    static IOReturn staticRemoveLoginAction( OSObject *self, void * login, void *, void *, void * );
    virtual IOReturn removeLoginAction( IOFireWireSBP2Login * login );

public:

    /*!
		@function getDiagnostics
		@abstract Debug-only method.
		@discussion	Returns a reference to the internal diagnostics object when the services are built 
        in debug mode. Should be a no-op in release builds.
        @result Returns a pointer to the diagnostics object (if any).
	*/
    	
	virtual OSObject * getDiagnostics( void );

    virtual bool finalize( IOOptionBits options );

protected:

	void terminateNotify( void );
	
private:
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2LUN, 8);

};

#endif                                                                                                                                                                                                                                                                                                                                                             IOFireWireSBP2Login.h                                                                               0100644 0001750 0001750 00000121033 12567452043 036426  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
  @header IOFireWireSBP2Login
  Contains the class definition for IOFireWireSBP2Login.
*/

#ifndef _IOKIT_IOFIREWIRESBP2LOGIN_H
#define _IOKIT_IOFIREWIRESBP2LOGIN_H

#include <IOKit/IOCommandGate.h>

#include <IOKit/firewire/IOFireWireUnit.h>

#include <IOKit/sbp2/IOFireWireSBP2ORB.h>
#include <IOKit/sbp2/IOFireWireSBP2Target.h>

// login option flags
enum
{
	kFWSBP2DontSynchronizeMgmtAgent = (1 << 0),
    kFWSBP2ExclusiveLogin 			= (1 << 5)
};

// notification events
enum
{
    kFWSBP2NormalCommandStatus	= 6,
    kFWSBP2NormalCommandTimeout	= 7,
    kFWSBP2UnsolicitedStatus	= 8,
    kFWSBP2NormalCommandReset	= 9
};

#define kIOMessageFWSBP2ReconnectComplete	iokit_fw_err(0x3E8)
#define kIOMessageFWSBP2ReconnectFailed		iokit_fw_err(0x3E9)

/*! 
    @typedef FWSBP2LoginResponse
    @param length Length of login response.
    @param loginID Unique id representing this login. 
    @param commandBlockAgentAddressHi High 32 bits of command block agent address.
    @param commandBlockAgentAddressLo Low 32 bits of command block agent address.
    @param reserved Reserved.
    @param reconnectHold Reconnect timeout encoded as 2^reconnectHold seconds.
*/

typedef struct
{
    UInt16		length;
    UInt16		loginID;
    UInt32		commandBlockAgentAddressHi;
    UInt32		commandBlockAgentAddressLo;
    UInt16		reserved;
    UInt16		reconnectHold;
} FWSBP2LoginResponse, *FWSBP2LoginResponsePtr;

/*! 
    @typedef FWSBP2StatusBlock
    @param details Src, Resp, D, Len fields of status block format
    @param sbpStatus SBP2 specific status
    @param orbOffsetHi High 32 bits of address of orb status is for.
    @param orbOffsetLo Low 32 bits of address of orb status is for.
    @param status[6] Up to 48 bytes of additional data. Length is determined by len field.
*/

typedef struct
{
    UInt8		details;
    UInt8		sbpStatus;
    UInt16		orbOffsetHi;
    UInt32		orbOffsetLo;
    UInt32		status[6];	
} FWSBP2StatusBlock;

class IOFireWireSBP2LUN;
class IOFireWireSBP2Login;

// struct sent to login complete handler

/*! 
    @typedef FWSBP2LoginCompleteParams
    @param login Pointer to IOFireWireSBP2Login object.
    @param generation FireWire generation value.
    @param status Status of login attempt.
    @param loginResponse Pointer to login response struct.
    @param statusBlock Pointer to status block buffer.
    @param statusBlockLength Length of entire status block.
*/

typedef struct
{
    IOFireWireSBP2Login * 	login;			// login object this param is sent from
    UInt32					generation;		// generation this login was attempted in 
  
    IOReturn				status;			// status of login attempt
	
    FWSBP2LoginResponsePtr	loginResponse;		// pointer to loginResponse buffer
    FWSBP2StatusBlock *		statusBlock;		// pointer to statusBlock buffer
    UInt32					statusBlockLength;	// size of statusBlock buffer
	
} FWSBP2LoginCompleteParams, *FWSBP2LoginCompleteParamsPtr;

// struct sent to logout complete handler

/*! 
    @typedef FWSBP2LogoutCompleteParams
    @param login Pointer to IOFireWireSBP2Login object.
    @param generation FireWire generation value.
    @param status Status of login attempt.
    @param statusBlock Pointer to status block buffer.
    @param statusBlockLength Length of entire status block.
*/

typedef struct
{
    IOFireWireSBP2Login * 	login;			// login object this param is sent from
    UInt32					generation;		// generation this login was attempted in

    IOReturn				status;			// status of login attempt
	
    FWSBP2StatusBlock *		statusBlock;		// pointer to statusBlock buffer
    UInt32					statusBlockLength;	// size of statusBlock buffer
	
} FWSBP2LogoutCompleteParams, *FWSBP2LogoutCompleteParamsPtr;

// struct sent with reconnect notification

/*! 
    @typedef FWSBP2LogoutCompleteParams
    @param login Pointer to IOFireWireSBP2Login object.
    @param generation FireWire generation value.
    @param status Status of login attempt.
    @param reconnectStatusBlock Pointer to status block buffer.
    @param reconnectStatusBlockLength Length of entire status block.
*/

typedef struct
{
    IOFireWireSBP2Login * 	login;			// login object this param is sent from
    UInt32					generation;		// generation this login was attempted in

    IOReturn			status;			// status of reconnect attempt

    void *			reconnectStatusBlock;		// pointer to statusBlock buffer
    UInt32			reconnectStatusBlockLength;	// size of statusBlock buffer
} FWSBP2ReconnectParams, *FWSBP2ReconnectParamsPtr;

// Callback when login and logout commands complete asynchronously

/*! 
    @typedef FWSBP2LoginCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param params Structure containing additional information about the status of the login. 
*/
    
typedef void (*FWSBP2LoginCallback)(void * refCon, FWSBP2LoginCompleteParamsPtr params);

/*! 
    @typedef FWSBP2LogoutCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param params Structure containing additional information about the status of the logout. 
*/

typedef void (*FWSBP2LogoutCallback)(void * refCon, FWSBP2LogoutCompleteParamsPtr params);

/*! 
    @typedef FWSBP2StatusCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
*/

typedef void (*FWSBP2StatusCallback)(void * refCon, IOReturn status);

/*! 
    @typedef FWSBP2FetchAgentWriteCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
    @param orb Indicates current last orb in chain.
*/

typedef void (*FWSBP2FetchAgentWriteCallback)(void * refCon, IOReturn status, IOFireWireSBP2ORB * orb);

/*! 
    @typedef FWSBP2NotifyParams
    @param notificationEvent Type of event we are being notified of.
    @param message buffer containing message.
    @param length length of message field.
    @param generation FireWire generation value.
*/

typedef struct
{
    void *				commandObject;
    UInt32 				notificationEvent;
    const void * 		message;
    UInt32				length;
    UInt32				generation;
} FWSBP2NotifyParams, *FWSBP2NotifyParamsPtr;


/*! 
    @typedef FWSBP2NotifyCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param params FWSBP2NotifyParams containing notification information.
*/

typedef void (*FWSBP2NotifyCallback)(void * refCon, FWSBP2NotifyParamsPtr params);

/*!
    @class IOFireWireSBP2Login
    @abstract Supplies the login maintenance and Normal Command ORB execution portions of the API.
    @discussion Supplies APIs for login maintenance and command execution.  Drivers can use this 
    object to create IOFireWireSBP2ORB objects and execute them.  Solicited and unsolicited status 
    callback routines can be registered and the SBP2 services will notify the driver when the 
    appropriate status arrives.
    This class also handles login maintenance.  Supplies APIs for logging in and logging out and 
    attempts to reconnect to the LUN after bus resets.  The base FireWire services deliver bus 
    reset notification via the IOKit message routine.  The SBP2 services build on this behavior 
    and deliver reconnectFailed and reconnectComplete through the message routine as well.
*/

class IOFireWireSBP2Login : public OSObject
{
    OSDeclareDefaultStructors( IOFireWireSBP2Login )

	friend class IOFireWireSBP2ORB;
	friend class IOFireWireSBP2LUN;
	friend class IOFireWireSBP2UserClient;
	
protected:

    // command selectors
    enum
    {
        kLoginCommandIdle		= 0,
        kLoginCommandDoLogin 	= 1,
        kLoginCommandDoLogout	= 2,
        kLoginAddORB			= 3,
        kLoginRemoveORB			= 4,
		kLoginFetchAgentReset	= 5
     };

    // internal login states
    enum
    {
        kLoginStateIdle			= 0,
        kLoginStateLoggingIn	= 1,
        kLoginStateConnected	= 2,
        kLoginStateReconnect	= 3,
        kLoginStateLoggingOut	= 4,
		kLoginStateTerminated	= 5
    };

    // rom keys
    enum
    {
        kUnitCharacteristicsKey 	= 0x3A,
        kManagementAgentOffsetKey	= 0x54
    };

    // sbp2 defs
    enum
    {
        kFWSBP2RequestComplete 	= 0,
        kFWSBP2TransportFailure	= 1,
        kFWSBP2IllegalRequest	= 2,
        kFWSBP2VendorDependent	= 3
    };

    enum
    {
        kFWSBP2NoSense					= 0,
        kFWSBP2RequestTypeNotSupported	= 1,
        kFWSBP2SpeedNotSupported		= 2,
        kFWSBP2PageSizeNotSupported		= 3,
        kFWSBP2AccessDenied				= 4,
        kFWSBP2LogicalUnitNotSupported	= 5,
        kFWSBP2MaxPayloadTooSmall		= 6,
        kFWSBP2FunctionRejected			= 9,
        kFWSBP2LoginIDNotRecognized		= 10,
        kFWSBP2DummyORBCompleted		= 11,
        kFWSBP2RequestAborted			= 12,
        kFWSBP2UnspecifiedError			= 0xFF
    };

    typedef struct
    {
        UInt32		password[2];
        UInt32		loginResponseAddressHi;
        UInt32		loginResponseAddressLo;
        UInt16		options;
        UInt16		lun;
        UInt16		passwordLength;
        UInt16		loginResponseLength;
        UInt32		statusFIFOAddressHi;
        UInt32		statusFIFOAddressLo;
    } FWSBP2LoginORB;

    typedef struct
    {
        UInt32		reserved1[4];
        UInt16		options;
        UInt16		loginID;
        UInt32		reserved2;
        UInt32		statusFIFOAddressHi;
        UInt32		statusFIFOAddressLo;
    } FWSBP2ReconnectORB;
    
    typedef struct
    {
        UInt32		reserved1[4];
        UInt16		options;
        UInt16		loginID;
        UInt32		reserved2;
        UInt32		statusFIFOAddressHi;
        UInt32		statusFIFOAddressLo;
    } FWSBP2LogoutORB;

protected:

    ///////////////////////////////////////////////////////////////////
    // private interface methods

	// IOFireWireSBP2LUN methods
	virtual void clearAllTasksInSet( void );
    virtual bool initWithLUN( IOFireWireSBP2LUN * lun );
    virtual void suspendedNotify( void );
    virtual void resumeNotify( void );
	
	// IOFireWireSBP2ORB methods
	virtual IOFireWireUnit * getFireWireUnit( void );
    virtual IOFireWireSBP2LUN * getFireWireLUN( void );
    virtual bool isFetchAgentWriteInProgress( void );
    virtual bool isConnected( void );
    virtual IOReturn removeORB( IOFireWireSBP2ORB * orb );
    virtual IOReturn appendORBImmediate( IOFireWireSBP2ORB * orb );
    virtual IOReturn appendORB( IOFireWireSBP2ORB * orb );
    virtual void sendTimeoutNotification( IOFireWireSBP2ORB * orb );
     
protected:
  
    // reserved for future use
    struct ExpansionData { };
    ExpansionData *reserved; 
          
    IOFireWireSBP2LUN * 	fLUN;
    IOFireWireUnit *		fUnit;
	IOFireWireController *	fControl;
	IOCommandGate * 		fGate;

    FWSBP2LoginCallback		fLoginCompletionCallback;
    void *	  				fLoginCompletionRefCon;

    FWSBP2LogoutCallback	fLogoutCompletionCallback;
    void *					fLogoutCompletionRefCon;
    
    FWSBP2NotifyCallback	fStatusNotifyCallback;
    void *					fStatusNotifyRefCon;

    FWSBP2NotifyCallback	fUnsolicitedStatusNotifyCallback;
    void *					fUnsolicitedStatusNotifyRefCon;
    
    UInt32					fLoginFlags;
    UInt32					fReconnectTime;
    
    UInt32					fLoginState;
    UInt32					fManagementOffset;
    UInt32					fManagementTimeout;
    UInt32					fMaxORBSize;
    UInt32					fMaxCommandBlockSize;
    UInt16					fLoginNodeID;
    UInt32					fLoginGeneration;
    UInt32					fLoginID;
    UInt32					fReconnectHold;
    UInt32					fMaxPayloadSize;
    void *					fRefCon;
    
    // resources
    
    FWSBP2LoginORB			fLoginORB;
    IOFWAddressSpace *		fLoginORBAddressSpace;
    FWAddress				fLoginORBAddress;

    FWSBP2LoginResponse		fLoginResponse;
    IOFWAddressSpace *		fLoginResponseAddressSpace;
    FWAddress				fLoginResponseAddress;

    FWSBP2ReconnectORB		fReconnectORB;
    IOFWAddressSpace *		fReconnectORBAddressSpace;
    FWAddress				fReconnectORBAddress;
    
    FWSBP2StatusBlock		fStatusBlock;
    IOFWAddressSpace *		fStatusBlockAddressSpace;
    FWAddress				fStatusBlockAddress;

    FWSBP2StatusBlock		fReconnectStatusBlock;
    IOFWAddressSpace *		fReconnectStatusBlockAddressSpace;
    FWAddress				fReconnectStatusBlockAddress;

    FWSBP2LogoutORB			fLogoutORB;
    IOFWAddressSpace *		fLogoutORBAddressSpace;
    FWAddress				fLogoutORBAddress;
    bool					fLogoutPending;
	
    IOFWWriteCommand *		fLoginWriteCommand;
    IOMemoryDescriptor *	fLoginWriteCommandMemory;
    bool					fLoginWriteInProgress;
     
    IOFWWriteCommand *		fReconnectWriteCommand;
    IOMemoryDescriptor *	fReconnectWriteCommandMemory;
    bool					fReconnectWriteInProgress;
    bool					fReconnectWriteInterrupted;
    
    IOFWWriteCommand *		fLogoutWriteCommand;
    IOMemoryDescriptor *	fLogoutWriteCommandMemory;
    bool					fLogoutWriteInProgress;
    
    IOFWCommand *			fLoginTimeoutCommand;
    bool					fLoginTimeoutTimerSet;

    IOFWDelayCommand *		fReconnectTimeoutCommand;
    bool					fReconnectTimeoutTimerSet;

    IOFWCommand *			fLogoutTimeoutCommand;
    bool					fLogoutTimeoutTimerSet;

    FWAddress 				fFetchAgentAddress;
    IOMemoryDescriptor *	fFetchAgentWriteCommandMemory;
    FWAddress 				fLastORBAddress;
    IOFireWireSBP2ORB *		fLastORB;
    IOFWWriteCommand *		fFetchAgentWriteCommand;
    bool					fFetchAgentWriteCommandInUse;
	FWSBP2FetchAgentWriteCallback 	fFetchAgentWriteCompletion;
	void * 							fFetchAgentWriteRefCon;
	IOFireWireSBP2ORB *		fORBToWrite;
	
    OSSet *					fORBSet;
    OSIterator *			fORBSetIterator;
 
    void *					fPasswordBuf;
    UInt32					fPasswordLen;
    IOFWAddressSpace *		fPasswordAddressSpace;
    FWAddress				fPasswordAddress;
	IOMemoryDescriptor *	fPasswordDescriptor;

	bool fSuspended;
	
	UInt32					fLoginRetryDelay;
	UInt32					fLoginRetryCount;
	UInt32					fLoginRetryMax;
	IOFWDelayCommand *		fLoginRetryTimeoutCommand;
    bool					fLoginRetryTimeoutTimerSet;
	IOFireWireSBP2Target * 	fTarget;
	
	bool					fUnsolicitedStatusEnableRequested;
	
	IOFWDelayCommand *		fReconnectRetryTimeoutCommand;
    bool					fReconnectRetryTimeoutTimerSet;	

	int						fCriticalSectionCount;
	
	// init / destroy
    virtual IOReturn getUnitInformation( void );
    virtual IOReturn allocateResources( void );
    virtual void free( void );
        	
	// orb add / remove
	virtual IOReturn addORB( IOFireWireSBP2ORB * orb );
	static IOReturn staticExecuteAddORB( OSObject *self, void * orb, void *, void *, void * );
	virtual IOReturn executeAddORB( IOFireWireSBP2ORB * orb );

	static IOReturn staticExecuteRemoveORB( OSObject *self, void * orb, void *, void *, void * );
	virtual IOReturn executeRemoveORB( IOFireWireSBP2ORB * orb );

    //
    // login
    //

    static IOReturn staticExecuteLogin( OSObject *self, void *, void *, void *, void * );
    virtual IOReturn executeLogin( void );
    virtual void abortLogin( void );
    
    // login write complete handler
    static void loginWriteCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
    virtual void loginWriteComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

    // login timeout handler
    static void loginTimeoutStatic( void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
    virtual void loginTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );

    // status block write handler
    static UInt32 statusBlockWriteStatic(void *refcon, UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                                         const void *buf, IOFWRequestRefCon lockRead);
   	virtual UInt32 statusBlockWrite( UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len, const void *buf, IOFWRequestRefCon lockRead);
	virtual void completeLogin( IOReturn state, const void *buf = NULL, UInt32 len = 0, void * buf2 = NULL );

    //
    // reconnect
    //
    
    virtual void doReconnect( void );
    virtual void restartReconnect( void );
    virtual void startReconnectTimer( void );

    // reconnect write complete handler
    static void reconnectWriteCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
    virtual void reconnectWriteComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

    // reconnect timeout handler
    static void reconnectTimeoutStatic( void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
    virtual void reconnectTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );

    // reconnect status block
    static UInt32 reconnectStatusBlockWriteStatic(void *refcon, UInt16 nodeID, IOFWSpeed &speed, FWAddress addr,
                                                  UInt32 len, const void *buf, IOFWRequestRefCon lockRead);
   	virtual UInt32 reconnectStatusBlockWrite( UInt16 nodeID, IOFWSpeed &speed, FWAddress addr, UInt32 len,
                                              const void *buf, IOFWRequestRefCon lockRead);

    virtual void sendReconnectNotification( UInt32 event );
    virtual void sendReconnectNotificationWithStatusBlock( UInt32 event );

    //
    // logout
    //
    
	static IOReturn staticExecuteLogout( OSObject *self, void *, void *, void *, void * );
    virtual IOReturn executeLogout( void );
    
    // logout write complete handler
    static void logoutWriteCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
    virtual void logoutWriteComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

    // logout timeout handler
    static void logoutTimeoutStatic( void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
    virtual void logoutTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
	
	virtual void completeLogout( IOReturn state, const void *buf = NULL, UInt32 len = 0);

	// fetch agent write complete handler
    static void fetchAgentWriteCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
    virtual void fetchAgentWriteComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

    //
    // fetch agent
    //

	bool 							fFetchAgentResetInProgress;
	UInt32 							fFetchAgentResetBuffer;
	FWAddress 						fFetchAgentResetAddress;
	IOFWWriteQuadCommand *			fFetchAgentResetCommand;
	void * 							fFetchAgentResetRefCon;
	FWSBP2StatusCallback 			fFetchAgentResetCompletion;

	static IOReturn staticExecuteFetchAgentReset( OSObject *self, void *, void *, void *, void * );
	virtual IOReturn executeFetchAgentReset( void );
	static void fetchAgentResetCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
	virtual void fetchAgentResetComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

	//
	// doorbell
	//
	
	bool 							fDoorbellInProgress;
	bool							fDoorbellRingAgain;
	UInt32 							fDoorbellBuffer;
	FWAddress 						fDoorbellAddress;
	IOFWWriteQuadCommand *			fDoorbellCommand;
	
	static IOReturn staticExecuteDoorbell( OSObject *self, void *, void *, void *, void * );
	virtual IOReturn executeDoorbell( void );
	static void doorbellCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
	virtual void doorbellComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

	//
	// enable unsolicited satus
	//

	bool 							fUnsolicitedStatusEnableInProgress;
	UInt32 							fUnsolicitedStatusEnableBuffer;
	FWAddress 						fUnsolicitedStatusEnableAddress;
	IOFWWriteQuadCommand *			fUnsolicitedStatusEnableCommand;

	static IOReturn staticExecuteUnsolicitedStatusEnable( OSObject *self, void *, void *, void *, void * );
	virtual IOReturn executeUnsolicitedStatusEnable( void );
	static void unsolicitedStatusEnableCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
	virtual void unsolicitedStatusEnableComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

	//
	// busy timeout stuff
	//
	
	bool 							fSetBusyTimeoutInProgress;
	UInt32 							fSetBusyTimeoutBuffer;
	FWAddress 						fSetBusyTimeoutAddress;
	IOFWWriteQuadCommand *			fSetBusyTimeoutCommand;
	
	bool							fInCriticalSection;

	UInt16					fLocalNodeID;
	bool					fFastStartSupported;
	UInt32					fFastStartOffset;
	UInt32					fFastStartMaxPayload;
	
	UInt32					fUserLoginGeneration;
	bool					fUserLoginGenerationSet;
	
	IOFWDelayCommand *		fFetchAgentRetryTimerCommand;
    bool					fFetchAgentRetryTimerSet;	
	
	virtual IOReturn executeSetBusyTimeout( void );
	static void setBusyTimeoutCompleteStatic( void *refcon, IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );
	virtual void setBusyTimeoutComplete( IOReturn status, IOFireWireNub *device, IOFWCommand *fwCmd );

private:
	// IOFireWireSBP2ORB friend class wrappers
	OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 0);

protected: 									
	virtual bool initORBWithLogin( IOFireWireSBP2ORB * orb, IOFireWireSBP2Login * login );
	virtual void setNextORBAddress( IOFireWireSBP2ORB * orb, FWAddress address );
    virtual void fetchAgentWriteComplete( IOFireWireSBP2ORB * orb, IOReturn status );
    virtual bool isORBTimerSet( IOFireWireSBP2ORB * orb );
    virtual void cancelORBTimer( IOFireWireSBP2ORB * orb );
	
	// IOFireWireSBP2LUN friend class wrappers
	virtual void removeLogin( void );
	virtual IOFireWireSBP2Target * getTarget( void );
	
	UInt32		fARDMAMax;
	bool		fPhysicalAccessEnabled;

	bool					fLoginStatusReceived;
	FWSBP2StatusBlock		fLoginStatusBlock;
	UInt32					fLoginStatusBlockLen;
		
private:

    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 4);
	OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 5);

public:

	//////////////////////////////

    /*!
		@function createORB
		@abstract Creates a new IOFireWireSBP2ORB for this login.
		@discussion	Create a new IOFireWireSBP2ORB for this login.  It can be configured 
        with it's accessors and executed with submitORB below.
        @result Returns a pointer to the new ORB object.
	*/
    	
	virtual IOFireWireSBP2ORB * createORB( void );
	
    /*!
		@function submitORB
		@abstract Submits the given orb
		@discussion	Starts execution of the given ORB.  If the ORB is an immediate ORB it's 
        addresss is written to the fetch agent.  If it is a non immediate orb its address 
        is appended to the last orb of the currently processing chain.  The doorbell is not 
        rung automatically it must be run manually with the ringDoorbell command described below.
        @param orb The orb to be executed.	
        @result Returns kIOReturnSuccess if the ORB has been started successfully.
	*/
    
    virtual IOReturn submitORB( IOFireWireSBP2ORB * orb );

    // set callbacks
    
    /*!
		@function setStatusNotifyProc
		@abstract Sets the callback to be called on normal command status.
		@discussion The supplied callback is called when normal command status is recieved, when 
        a normal command times out, or when a normal command is aborted. 
        "notificationEvent" in the callback's params will indicate what happened.
        It will be set to one of the following values: kFWSBP2NormalCommandReset, kFWSBP2NormalCommandStatus, 
        or kFWSBP2NormalCommandTimeout.  If the event type is kFWSBP2NormalCommandTimeout and "len" is 
        non-zero then "message" contains the data written to the status block.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2NotifyCallback.
	*/
    
    virtual void setStatusNotifyProc( void * refCon, FWSBP2NotifyCallback callback );

    /*!
		@function getStatusNotifyProc
		@abstract Returns the callback to be called on normal command status.
		@discussion Returns the refCon and callback address of the status notify callback.
        @param refCon output parameter returning the refCon to be passed to the callback.	
        @param callback output parameter returning the address of the callback.
	*/
    
    virtual void getStatusNotifyProc( void ** refCon, FWSBP2NotifyCallback * callback );

    /*!
		@function setUnsolicitedStatusNotifyProc
		@abstract Sets the callback to be called on normal command status.
		@discussion The supplied callback is called when unsolicited status is recieved.
        "notificationEvent" in the callback's params will indicate what happened.  In this 
        case it will be set to kFWSBP2UnsolicitedStatus. If "len" is 
        non-zero then "message" contains the data written to the status block. Note: any buffers 
        returned by callbacks are only valid for the duration of the login and should not have 
        their contents modified.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2NotifyCallback.
	*/
    
    virtual void setUnsolicitedStatusNotifyProc( void * refCon, FWSBP2NotifyCallback callback );
    
    /*!
		@function getUnsolicitedStatusNotifyProc
		@abstract Returns the callback to be called on unsolicited status.
		@discussion Returns the refCon and callback address of the unsolicited status notify callback.
        @param refCon output parameter returning the refCon to be passed to the callback.	
        @param callback output parameter returning the address of the callback.
	*/
    
    virtual void getUnsolicitedStatusNotifyProc( void ** refCon, FWSBP2NotifyCallback * callback );

    // command handling
    
    /*!
		@function setLoginCompletion
		@abstract Sets the callback to be called when a login attempt is complete.
		@discussion The supplied callback is called when a login attempt has completed. "status" in the
        callback's params should be checked to determine the success or failure of the login attempt.  
        If "statusBlock" is non-null then login status was written and it has been supplied here.  If 
        the login attempt was successful then the login response will be supplied in the "loginResponse" 
        buffer.  Note: all buffers supplied to callbacks are only valid for the duration of the callback.  
        Also, you are not to modify the contents of any supplied buffer.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2LoginCallback.
	*/
    
	virtual void setLoginCompletion( void * refCon, FWSBP2LoginCallback completion );
    
    /*!
		@function submitLogin
		@abstract Attempts to login to the LUN.		
        @discussion This call begins the login process.  The login object should be configured prior 
        to this call. If kIOReturnSuccess is returned from this call then the loginCompletion routine 
        will be called when the login completes (successfully or unsuccesfully). 
        @result Returns kIOReturnSuccess login has successlly begun.
	*/
    
    virtual IOReturn submitLogin( void );
	
    /*!
		@function submitLogout
		@abstract Attempts to logout of the LUN.		
        @discussion This call begins the logout process.  If kIOReturnSuccess is returned from this call then
        the logoutCompletion routine will be called when the logout completes (successfully or unsuccesfully). 
        @result Returns kIOReturnSuccess if logout has successfully begun.
	*/
    
    virtual IOReturn submitLogout( void );
 
    /*!
		@function setLogoutCompletion
		@abstract Sets the callback to be called when a logout attempt is complete.
		@discussion The supplied callback is called when a logout attempt has completed. "status" in the
        callback's params should be checked to determine the success or failure of the logout attempt.  
        If "statusBlock" is non-null then logout status was written and it has been supplied here. 
        Note: all buffers supplied to callbacks are only valid for the duration of the callback.  
        Also, you are not to modify the contents of any supplied buffer.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2LogoutCallback.
	*/
   
    virtual void setLogoutCompletion( void * refCon, FWSBP2LogoutCallback completion );
 
    /*!
		@function setFetchAgentWriteCompletion
		@abstract Sets the callback to be called when the fetch agent write completes.
		@discussion When an immediate orb is executed with submitORB, it's address is written to a 
        specific address on the device.  This address is called the fetch agent.  The device the 
        reads that orb from the Mac's memory and executes it.  With this call you can register to 
        be called back when this write to the fetch agent completes.  The SBP2 services guarantee 
        that the fetch agent write will be complete before status is reported for an ORB, so for 
        most drivers this notification is not required.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2FetchAgentWriteCallback.
	*/
       
	virtual void setFetchAgentWriteCompletion( void * refCon, FWSBP2FetchAgentWriteCallback completion );

    /*!
		@function setFetchAgentResetCompletion
		@abstract Sets the callback to be called when a fetch agent reset completes.
		@discussion The fetch agent state machine on the device can be reset by a write to a specific 
        register.  The SBP2 services offer a utility method to reset the fetch agent.  You can register 
        a callback routine here to be notified when this rest write completes.
        @param refCon refCon passed to callback.	
        @param callback address of callback method of type FWSBP2FetchAgentWriteCallback.
	*/
    
    virtual void setFetchAgentResetCompletion( void * refCon, FWSBP2StatusCallback completion );

    /*!
		@function submitFetchAgentReset
		@abstract Resets the LUN's fetch agent.
		@discussion The fetch agent state machine on the device can be reset by a write to a specific 
        register.  This reset can be intiated by a call to this method.  Notification of the completion 
        of this write can be had by registering a callback with the setFetchAgentResetCompletion method.
        @result Returns kIOReturnSuccess if the reset started successfully.
	*/
    
	virtual IOReturn submitFetchAgentReset( void );

    /*!
		@function ringDoorbell
		@abstract Rings the doorbell on the LUN.
		@discussion Non-immediate appends to the ORB chain may require the fetch agent state machine 
        to be notified of the new ORB's presence.  This is accomplished by writing to the so called 
        doorbell register.  This method begins one of those writes.
        @result Returns kIOReturnSuccess if the ring started successfully.
	*/
    
 	virtual IOReturn ringDoorbell( void );
    
    /*!
		@function enableUnsolicitedStatus
		@abstract Enables unsolicited status.
		@discussion After unsolicited is sent the device will not send any additional unsolicited status 
        until a specific register is written.  This serves as a sort of flow-control for unsolicited status.  
        After unsolicited status is recieved and processed drivers will want to reenable the delivery 
        of unsolicted status by a call to this method.
        @result Returns kIOReturnSuccess if the status enable write started successfully.
	*/
        
	virtual IOReturn enableUnsolicitedStatus( void );
	
    // accessors
    
    /*!
		@function getMaxCommandBlockSize
		@abstract Returns the maximum command block size.
		@discussion The device publishes an upper limit on the size of command block that it can 
        accept.  That value can be accessed via this method.
        @result Returns a UInt32 containing the maximum command block size.
	*/
    
    virtual UInt32 getMaxCommandBlockSize( void );
    
    /*!
		@function getLoginID
		@abstract Returns the current login ID.
		@discussion When we successfully login to a device.  The device gives us a unique login id.  
        This is used internally for reconnecting to the device after bus resets and for certain other 
        management ORBs.  Most drivers are probably not interested in this value.
        @result Returns a UInt32 containing the current login ID.
	*/
    
    virtual UInt32 getLoginID( void );

    /*!
		@function setLoginFlags
		@abstract Sets login configuration flags.
		@discussion Configures the login behavior according to the provided flags.  Currently two 
        flags are defined for this API.  kFWSBP2ExclusiveLogin sets the exclusive login bit in the 
        login ORB. kFWSBP2DontSynchronizeMgmtAgent allows simultaneous logins or reconnects to LUNs
        with a common management agent (ie LUNs in the same unit directory).
        @param loginFlags the login configuration flags.
	*/
    
    virtual void setLoginFlags( UInt32 loginFlags );
    
    /*!
		@function getLoginFlags
		@abstract Returns the currently set login flags.
		@discussion Returns the current state of the login flags.  Currently there is only one
        flag defined for this API.  kFWSBP2ExclusiveLogin indicates that the exclusive login bit
        should be set in the login ORB.
        @result Returns a UInt32 containing the currently set login flags.
	*/
    
    virtual UInt32 getLoginFlags( void );

    /*!
		@function setReconnectTime
		@abstract Sets the desired reconnect duration.
		@discussion The target and initiator arbitrate the duration of the reconnect timeout.  Here 
        the initiator specifies its desired timeout time in 2^reconnectTime seconds.  After a 
        successful login the device returns the actual timeout value it wishes to use.  This value 
        may be less than the reconnect timeout that the intiator specified if this is all that the 
        device can support.
        @param reconnectTime The desired reconnect timeout encoded as 2^reconnectTime seconds.
	*/
    
    virtual void setReconnectTime( UInt32 reconnectTime );
    
    /*!
		@function getReconnectTime
		@abstract Returns the currently set reconnect time.
		@discussion Returns the currently desired initiator reconnect time encoded as 2^time seconds.
        @result Returns a UInt32 containing the currently set reconnect time.
	*/
    
    virtual UInt32 getReconnectTime( void );

    /*!
		@function setMaxPayloadSize
		@abstract Sets the maximum data transfer length for a normal command ORB.
		@discussion Sets the maximum data transfer length for a normal command ORB.  This value is 
        the maximum for all ORBs sent to this LUN.  This can be trimmed further on an ORB by ORB basis, 
        by a similar call in the IOFireWireSBP2ORB itself.
        @param reconnectTime The desired maximum payload size in bytes.
	*/
    
    virtual void setMaxPayloadSize( UInt32 maxPayloadSize );
    
    /*!
		@function getMaxPayloadSize
		@abstract Returns the currently set maximum payload size.
		@discussion Returns the currently global maximum payload size in bytes.
        @result Returns a UInt32 containing the currently set maximum payload size.
	*/

    virtual UInt32 getMaxPayloadSize( void );

    /*!
		@function setPassword
		@abstract Sets the login password.
		@discussion Sets the login password using a buffer and a length.  An alternate version exists 
        that accepts an IOMemoryDescriptor.  If the password length is 8 or less the password is copied 
        directly into the login orb.  If the length is greater than 8 the buffer is referenced by address 
        in the login ORB.  In this case the buffer is not copied and should remain allocated for the 
        duration of the login attempt.
        @param buf a pointer to the password buffer.
        @param len the length in bytes of the password buffer.
        @result Returns kIOReturnSuccess on success.
	*/

    virtual IOReturn setPassword( void * buf, UInt32 len );

    /*!
		@function setPassword
		@abstract Sets the login password.
		@discussion Sets the login password using an IOMemoryDescriptor.  An alternate version exists 
        that accepts a buffer and a length.  If the password length is 8 or less the password is copied 
        directly into the login orb.  If the length is greater than 8 the buffer is referenced by address 
        in the login ORB.
        @param memory an IOMemoryDescriptor referencing the password.
        @result Returns kIOReturnSuccess on success.
	*/
    
    virtual IOReturn setPassword( IOMemoryDescriptor * memory );


    /*!
		@function setRefCon
		@abstract Sets the login refCon.
		@discussion Sets a user defined value on the login that can be retrieved later with the 
        method getRefCon.
        @param refCon a user defined value.
    */
    
    virtual void setRefCon( void * refCon );
    
    /*!
		@function getRefCon
		@abstract Returns the refCon set with setRefCon.
		@discussion Returns the user defined value previously stored in the login with setRefCon.
        @result Returns the previously stored user defined value.
	*/
    
    virtual void * getRefCon( void );
	
    /*!
		@function setBusyTimeoutRegisterValue
		@abstract Sets the value to be written to the BUSY_TIMEOUT register.
		@discussion 1394-1995 defines a register known as the BUSY_TIMEOUT register. This register 
        controls the busy retry behavior of your device.  The initial value for this register is 
        0x00000000.  Which means busied transactions will not be retried.  Since most devices want 
        their transactions retired on busy acks, the SBP2 service automatically updates the 
        BUSY_TIMEOUT register with the value specified here whenever necessary.  Most drivers should 
        set this value to 0x0000000f.
        @param timeout desired value of the BUSY_TIMEOUT register.
    */
    
	virtual void setBusyTimeoutRegisterValue( UInt32 timeout );
    
protected:

    virtual void startORBTimer( IOFireWireSBP2ORB * orb );
    virtual void prepareORBForExecution( IOFireWireSBP2ORB * orb );

    static IOReturn staticExecuteORB( OSObject *self, void * orb, void *, void *, void * );
    virtual IOReturn executeORB( IOFireWireSBP2ORB * orb );

public:

    /*! 
        @function release
        @abstract Primary implementation of the release mechanism.
        @discussion See OSObject.h for more information.  When retainCount == when then call free(). 
    */
    
    virtual void release() const;
	
	/*! 
        @function setLoginRetryCountAndDelayTime
        @abstract Sets login retry behavior.
        @discussion Sets login retry behavior.
        @param retryCount number of times to retry logins
		@param uSecs delay time in microseconds between login retries
    */
	
	virtual void setLoginRetryCountAndDelayTime( UInt32 retryCount, UInt32 uSecs );
	
protected:
	virtual IOReturn initialExecuteLogin( void );
	virtual void startLoginRetryTimer( void );
	virtual void stopLoginRetryTimer( void );
	static void loginRetryTimeoutStatic( void *refcon, IOReturn status,
										 IOFireWireBus *bus, IOFWBusCommand *fwCmd );
	virtual void loginRetryTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd);

	virtual void startReconnectRetryTimer( void );
	virtual void stopReconnectRetryTimer( void );
	static void reconnectRetryTimeoutStatic( void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
	virtual void reconnectRetryTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );

	virtual bool isORBAppended( IOFireWireSBP2ORB * orb );
	virtual void setORBIsAppended( IOFireWireSBP2ORB * orb, bool state );

public:    
	virtual void setAddressLoForLoginORBAndResponse( UInt32 addressLoORB, UInt32 addresLoResponse );
	
	virtual void setLoginGeneration( UInt32 generation );
	virtual void clearLoginGeneration( void );

protected:
	void startFetchAgentRetryTimer( UInt32 duration );
	void stopFetchAgentRetryTimer( void );
	static void fetchAgentRetryTimerStatic( void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
	void fetchAgentRetryTimer( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
	
	void terminateNotify( void );
	void processLoginWrite( void );

public:
	
	bool	isPhysicalAccessEnabled( void );
	UInt32	getARDMMax( void );
	
private:
    
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Login, 8);

 };

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     IOFireWireSBP2ManagementORB.h                                                                       0100644 0001750 0001750 00000025503 12567452043 040002  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
  @header IOFireWireSBP2ManagementORB
  Contains the class definition for IOFireWireSBP2ManagementORB.
*/

#ifndef _IOKIT_IOFIREWIRESBP2MANAGEMENTORB_H
#define _IOKIT_IOFIREWIRESBP2MANAGEMENTORB_H

#include <IOKit/firewire/IOFWCommand.h>
#include <IOKit/firewire/IOFireWireUnit.h>

#include <IOKit/IOUserClient.h>

class IOFireWireSBP2LUN;
class IOFireWireSBP2ManagementORB;
class IOFireWireSBP2ORB;

enum
{
    kFWSBP2QueryLogins			= 1,
    kFWSBP2AbortTask			= 0xb,
    kFWSBP2AbortTaskSet			= 0xc,
    kFWSBP2LogicalUnitReset		= 0xe,
    kFWSBP2TargetReset			= 0xf
};

// Callback when management command completes asynchronously

/*! 
    @typedef FWSBP2ManagementCallback
    @param refCon Reference constant supplied when the notification was registered.
    @param status Indicates success or failure of operation. 
    @param orb Indicates current orb status is for.
*/

typedef void (*FWSBP2ManagementCallback)(void * refCon, IOReturn status, IOFireWireSBP2ManagementORB * orb);

/*!
    @class IOFireWireSBP2ManagementORB
    @abstract Supplies non login related management ORBs.  Management ORBs can be executed independent 
    of a login, if necessary.  Management ORBs are created using the IOFireWireSBP2LUN interface.
*/

class IOFireWireSBP2ManagementORB : public IOFWCommand
{
    OSDeclareDefaultStructors( IOFireWireSBP2ManagementORB )

	friend class IOFireWireSBP2LUN;
	friend class IOFireWireSBP2UserClient;
	
protected:

	////////////////////////////////////////            
    // rom keys
	
    enum
    {
        kUnitCharacteristicsKey 	= 0x3A,
        kManagementAgentOffsetKey	= 0x54
    };

	////////////////////////////////////////        
	// structs
	
    typedef struct
    {
        UInt32		orbOffsetHi;
        UInt32		orbOffsetLo;
        UInt32		reserved1[2];
        UInt16		options;
        UInt16		loginID;
        UInt32		reserved2;
        UInt32		statusFIFOAddressHi;
        UInt32		statusFIFOAddressLo;
    } FWSBP2TaskManagementORB;

    typedef struct
    {
        UInt32		reserved1[2];
        UInt32		queryResponseAddressHi;
        UInt32		queryResponseAddressLo;
        UInt16		options;
        UInt16		lun;
        UInt16		reserved2;
        UInt16		queryResponseLength;
        UInt32		statusFIFOAddressHi;
        UInt32		statusFIFOAddressLo;
    } FWSBP2QueryLoginsORB;
    
    typedef struct
    {
        UInt8		details;
        UInt8		sbpStatus;
        UInt16		orbOffsetHi;
        UInt32		orbOffsetLo;
        UInt32		status[6];
    } FWSBP2StatusBlock;

protected:

	////////////////////////////////////////        
	// friend methods
	
    // IOFireWireSBP2LUN methods
    virtual bool initWithLUN( 	IOFireWireSBP2LUN * lun, 
								void * refCon,
								FWSBP2ManagementCallback completion  );
	
	// IOFireWireSBP2UserClient methods
    virtual void setAsyncCallbackReference( void * asyncRef );
    virtual void getAsyncCallbackReference( void * asyncRef );

protected:
   
    // reserved for future use
    struct ExpansionData 
	{
		bool fInCriticalSection; 
	};
    ExpansionData * fExpansionData; 
         
    IOFireWireSBP2LUN * 		fLUN;
    IOFireWireUnit *			fUnit;
    
    UInt32						fManagementOffset;
    UInt32						fManagementTimeout;
    UInt32						fFunction;
    OSObject * 					fManageeCommand;
    
	// our orb
    FWSBP2TaskManagementORB		fManagementORB;
    IOFWAddressSpace *			fManagementORBAddressSpace;
    FWAddress					fManagementORBAddress;

	// command to write management agent
    IOFWWriteCommand *			fWriteCommand;
    IOMemoryDescriptor *		fWriteCommandMemory;

	// timeout
    IOFWCommand *				fTimeoutCommand;
    bool						fTimeoutTimerSet;

	// status block
    FWSBP2StatusBlock			fStatusBlock;
    IOFWAddressSpace *			fStatusBlockAddressSpace;
    FWAddress					fStatusBlockAddress;

	// response buffer
    void *						fResponseBuf;
    UInt32						fResponseLen;
    IOFWAddressSpace *			fResponseAddressSpace;
    FWAddress					fResponseAddress;

	// competion routine
	FWSBP2ManagementCallback	fCompletionCallback;
    void * 						fCompletionRefCon;

    // for user client
    OSAsyncReference64			fCallbackAsyncRef;
	
	IOMemoryMap *				fResponseMap;
	
	bool						fCompleting;
	
	////////////////////////////////////////        

    // init / destroy
    virtual IOReturn getUnitInformation( void );
    virtual IOReturn allocateResources( void );
    virtual void free( void );
        
    // command execution
    virtual IOReturn execute( void );
    virtual IOReturn complete( IOReturn state );

    // write complete handler
    static void writeCompleteStatic( 	void *refcon, 
										IOReturn status, 
										IOFireWireNub *device, 
										IOFWCommand *fwCmd );
    virtual void writeComplete( IOReturn status, 
								IOFireWireNub *device, 
								IOFWCommand *fwCmd );

    // timeout handler
    static void handleTimeoutStatic( 	void *refcon, 
										IOReturn status, 
										IOFireWireBus *bus, 
										IOFWBusCommand *fwCmd );
    virtual void handleTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );

    // status block write handler
    static UInt32 statusBlockWriteStatic( 	void *refcon, 
											UInt16 nodeID, 
											IOFWSpeed &speed, 
											FWAddress addr, 
											UInt32 len,
											const void *buf, 
											IOFWRequestRefCon lockRead );
    virtual UInt32 statusBlockWrite( 	UInt16 nodeID, 
										FWAddress addr, 
										UInt32 len, 
										const void *buf, 
										IOFWRequestRefCon lockRead );

	// IOFireWireSBP2LUN friend class wrappers
	virtual void clearAllTasksInSet( void );
	virtual void removeManagementORB( IOFireWireSBP2ManagementORB * orb );
	
public:
    
	////////////////////////////////////////        
    // client methods

    /*!
		@function setCommandFunction
		@abstract Sets the function of the management ORB.
		@discussion Sets the the function of the management ORB.  Legal values are kFWSBP2QueryLogins,
        kFWSBP2AbortTask, kFWSBP2AbortTaskSet,  kFWSBP2LogicalUnitReset, and kFWSBP2TargetReset.
        @param function a value indicating the desired management function.
        @result Returns kIOReturnSuccess if function was a legal function.
	*/
    	
    virtual IOReturn setCommandFunction( UInt32 function );
    
    /*!
		@function getCommandFunction
		@abstract Returns the current function of the management ORB.
		@discussion Returns the function of the management ORB.  This is the same value that was 
        set with setCommandFunction.
        @result Returns the function of the management ORB.
	*/
    
    virtual UInt32 getCommandFunction( void );

    /*!
		@function setManageeCommand
		@abstract Sets the command to be managed by the management ORB.
		@discussion All management functions except kFWSBP2QueryLogins require a reference to an ORB of 
        some sort.  kFWSBP2AbortTaskSet,  kFWSBP2LogicalUnitReset, and kFWSBP2TargetReset require a 
        reference to the login ORB.  kFWSBP2AbortTask requires a reference to the ORB to be aborted.  
        This method allows you to set the ORB to be managed.
        @param command a reference to an IOFireWireSBP2Login or an IOFireWireSBP2ORB.
 	*/
    
    virtual void setManageeCommand( OSObject * command );
    
    /*!
		@function getCommandFunction
		@abstract Returns the current managee command of the management ORB.
		@discussion Returns the current managee command of the management ORB.  This is the same value that was 
        set with setManageeCommand.
        @result  Returns the current managee command of the management ORB.
	*/
    
    virtual OSObject* getManageeCommand( void );

    /*!
		@function setResponseBuffer
		@abstract Sets the response buffer for the management ORB.
		@discussion Sets the response buffer for the management ORB.  kFWSBP2QueryLogins returns 
        a response to its query and needs to write it somewhere.  This routine allows you to 
        specify the location.
        @param desc memory descriptor for buffer.
        @result Returns kIOReturnSuccess on a success.
	*/
    
	virtual IOReturn setResponseBuffer( IOMemoryDescriptor * desc );
    
    /*!
		@function setResponseBuffer
		@abstract Sets the response buffer for the management ORB.
		@discussion Sets the response buffer for the management ORB.  kFWSBP2QueryLogins returns 
        a response to its query and needs to write it somewhere.  This routine allows you to 
        specify the location.        
        @param buf backing store for buffer
        @param len length of buffer.
        @result Returns kIOReturnSuccess on a success.
	*/
    
    virtual IOReturn setResponseBuffer( void * buf, UInt32 len );
    
    /*!
		@function getResponseBuffer
		@abstract Returns the response buffer for the management ORB.
		@discussion Returns the response buffer set in setResponseBuffer above        
        @param desc memory descriptor for buffer.
        @param buf output parameter for backing store for buffer
        @param len output parameter for length of buffer.
	*/
    
    virtual void getResponseBuffer( void ** buf, UInt32 * len );

    /*! 
        @function release
        @abstract Primary implementation of the release mechanism.
        @discussion See OSObject.h for more information. 
        @param when When retainCount == when then call free(). 
    */
    
	virtual void release() const;

protected:

	virtual void setORBToDummy( IOFireWireSBP2ORB * orb );

	virtual void suspendedNotify();

private:

    OSMetaClassDeclareReservedUsed(IOFireWireSBP2ManagementORB, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ManagementORB, 8);
    
};

#endif                                                                                                                                                                                             IOFireWireSBP2ORB.h                                                                                 0100644 0001750 0001750 00000051341 12567452043 036004  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
  @header IOFireWireSBP2ORB
  Contains the class definition for IOFireWireSBP2ORB.
*/

#ifndef _IOKIT_IOFIREWIRESBP2ORB_H
#define _IOKIT_IOFIREWIRESBP2ORB_H

#include <IOKit/firewire/IOFireWireUnit.h>

#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/IOUserClient.h>
#include <IOKit/IODMACommand.h>

enum
{
    kFWSBP2ConstraintForceDoubleBuffer		= (1 << 0)
};

// login option flags
enum
{
    kFWSBP2CommandCompleteNotify			= (1 << 0),
    kFWSBP2CommandTransferDataFromTarget	= (1 << 1),
    kFWSBP2CommandImmediate					= (1 << 2),
    
    kFWSBP2CommandNormalORB					= (1 << 5),
    kFWSBP2CommandReservedORB				= (1 << 6),
    kFWSBP2CommandVendorORB					= (1 << 7),
    kFWSBP2CommandDummyORB					= (1 << 8),
    kFWSBP2CommandCheckGeneration			= (1 << 9),
	
	kFWSBP2CommandFixedSize					= (1 << 10),
	kFWSBP2CommandVirtualORBs				= (1 << 11)     // handy for debugging
};

enum
{
    kFWSBP2MaxPageClusterSize = 0xf000
};

class IOFireWireSBP2ORB;
class IOFireWireSBP2LUN;
class IOFireWireSBP2Login;

/*!
    @class IOFireWireSBP2ORB
    @abstract Represents an SBP2 normal command ORB.  Supplies the APIs for configuring normal
    command ORBs.  This includes setting the command block and writing the page tables for I/O.
    The ORBs are executed using the submitORB method in IOFireWireSBP2Login.
*/

class IOFireWireSBP2ORB : public IOCommand
{
    OSDeclareDefaultStructors( IOFireWireSBP2ORB )

	friend class IOFireWireSBP2Login;
	friend class IOFireWireSBP2ManagementORB;
	
protected:
    
    typedef struct
    {
        UInt32		nextORBAddressHi;
        UInt32		nextORBAddressLo;
        UInt32		dataDescriptorHi;
        UInt32		dataDescriptorLo;
        UInt16		options;
        UInt16		dataSize;
        UInt32		commandBlock[1];  // will be variable sized
     } FWSBP2ORB;

    typedef struct
    {
        UInt16		segmentLength;
        UInt16		segmentBaseAddressHi;
        UInt32		segmentBaseAddressLo;
    } FWSBP2PTE;

private:

    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2ORB, 8);

protected:    

    virtual void deallocateBufferAddressSpace( void );
    virtual IOReturn allocateTimer( void );
    virtual void deallocateTimer( void );
    
    /*!
		@function deallocatePageTable
		@abstract Frees up memory allocated for the page table.
		@discussion	Frees all memory associated with the page table.  Undoes what allocatePageTable does. 
        Calling allocatePageTable again will automatically deallocate the existing page table before 
        allocating a new one, so this method is not used in most cases.
	*/
    
    virtual void deallocatePageTable( void );

protected:
	
    // IOFireWireSBP2Login methods
	virtual bool initWithLogin( IOFireWireSBP2Login * login );
    virtual void setNextORBAddress( FWAddress address );

public:

    /*!
		@function allocatePageTable
		@abstract Allocates memory for the page table.
		@discussion	Page table allocation is handle automatically by the ORB, except if the 
        kFWSBP2CommandFixedSize flags is set.  In this case we will fail to write a page table if we 
        need more page table space than we have already.  This method is exposed so these drivers 
        can preallocate as much page table as they need.  This is useful if your driver is part of 
        the paging path and cannot allow allocations to occur.
        @param entryCount number of entries of page table to be allocated.
	*/

    virtual IOReturn allocatePageTable( UInt32 entryCount );

protected:

    virtual bool isTimerSet( void );
    virtual void cancelTimer( void );
    
protected:
  
    // reserved for future use
    struct ExpansionData { };
    ExpansionData *reserved; 
       
    IOFireWireSBP2Login *	fLogin;
    IOFireWireSBP2LUN * 	fLUN;
    IOFireWireUnit *		fUnit;
    IOFireWireController *	fControl;
    IODMACommand *			fDMACommand;
	void *					fUnused2;
	
    UInt32			fCommandFlags;
    UInt32			fMaxPayloadSize;
    UInt32			fTimeoutDuration;
    UInt32			fGeneration;
    UInt64			fRefCon;

	//
    // orb
    //
	
	IOMemoryDescriptor *		fORBDescriptor;
    FWSBP2ORB *					fORBBuffer;
	
    FWAddress 					fORBPseudoAddress;
    IOFWAddressSpace *			fORBPseudoAddressSpace;

    IOFWAddressSpace *			fORBPhysicalAddressSpace;
	FWAddress					fORBPhysicalAddress;

	//
    // page table
    //
	
	UInt32						fPageTableSize;
    IOBufferMemoryDescriptor *	fPageTableDescriptor;

    IOFWAddressSpace *			fPageTablePhysicalAddressSpace;
	FWAddress					fPageTablePhysicalAddress;
	UInt32						fPageTablePhysicalLength;
	
	IOFWAddressSpace *			fPageTablePseudoAddressSpace;   
	FWAddress					fPageTablePseudoAddress;

	//
    // buffers
    //
	
	IOFWAddressSpace *		fBufferAddressSpace;
    bool					fBufferAddressSpaceAllocated;
    IOMemoryDescriptor *	fBufferDescriptor;
    
	//
    // timer
    //
	
	IOFWDelayCommand *		fTimeoutCommand;
    bool					fTimeoutTimerSet;

	bool					fInProgress;
	bool					fIsAppended;
	
    UInt32					fFetchAgentWriteRetries;
    UInt32					fPTECount;
    UInt32					fFetchAgentWriteRetryInterval;

	UInt32					fConstraintOptions;

    virtual IOReturn allocateResources( void );
    virtual void free( void );

    // orb timeout handler
    static void orbTimeoutStatic( void *refcon, IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );
    virtual void orbTimeout( IOReturn status, IOFireWireBus *bus, IOFWBusCommand *fwCmd );

	// login friend class wrappers
	virtual IOFireWireUnit * getFireWireUnit( void );
	virtual IOFireWireSBP2LUN * getFireWireLUN( void );
  	virtual void deallocateORB( void );
	virtual IOReturn allocateORB( UInt32 orbSize );
    virtual IOReturn removeORB( IOFireWireSBP2ORB * orb );
    virtual void prepareORBForExecution( void );
    virtual void startTimer( void );
    virtual void sendTimeoutNotification( IOFireWireSBP2ORB * orb );

public:
 
    /*! 
        @function release
        @abstract Primary implementation of the release mechanism.
        @discussion See OSObject.h for more information. 
        @param when When retainCount == when then call free(). 
    */
       
	virtual void release() const;

    /*! 
        @function getLogin
        @abstract Gets the login associated with this ORB.
        @discussion Returns the IOFireWireSBP2Login object associated with this ORB.
        @result Returns a pointer to an IOFireWireSBP2Login. 
    */
    
    virtual IOFireWireSBP2Login * getLogin( void );

    /*! 
        @function setCommandBuffersAsRanges
        @abstract Creates a page table from a list of ranges.
        @discussion Creates a page table with the given parameters. Any addresses mapped by this method 
        must remain valid until setCommandBuffers is called again or releaseCommandBuffers is called.  
        The SBP2 services do not release references to the command buffers just because the command 
        has completed.
        @param ranges An array of ranges representing the data to be transfered.
        @param withCount The number of ranges in the ranges array.
        @param withDirection An IODirection indicating the direction of data transfer.
        @param withTask The task that these adressses reside in.
        @param offset Offset in bytes into data to begin writing table at.
        @param length Number of bytes of data to map from offset.
        @result Returns KIOReturnSuccess if the page table was written successfully. 
    */
    
    virtual IOReturn setCommandBuffersAsRanges(  IOVirtualRange * ranges,
                                                 UInt32           withCount,
                                                 IODirection      withDirection,
                                                 task_t           withTask,
                                                 UInt32		offset = 0,
                                                 UInt32		length = 0 );
    /*! 
        @function setCommandBuffersAsRanges
        @abstract Creates a page table from a list of ranges.
        @discussion Creates a page table with the given parameters. Any addresses mapped by this method 
        must remain valid until setCommandBuffers is called again or releaseCommandBuffers is called.  
        The SBP2 services do not release references to the command buffers just because the command 
        has completed.
        @param memoryDescriptor IOMemoryDescriptor describe ranges to be written to a page table.
        @param offset Offset in bytes into data to begin writing table at.
        @param length Number of bytes of data to map from offset.
        @result Returns KIOReturnSuccess if the page table was written successfully. 
    */
    
    virtual IOReturn setCommandBuffers( IOMemoryDescriptor * memoryDescriptor, UInt32 offset = 0, 
																				UInt32 length = 0 );


    /*! 
        @function releaseCommandBuffers
        @abstract Releases SBP2's reference to the command buffers.
        @discussion When you create a page table with one of the variants of setCommandBuffers.  
        SBP2 holds on to a reference to the buffers until this method is called.  This means that 
        if a command completed and you manipulated the memory descriptor or released the buffers 
        without calling this method you could leave FW in an inconsistent state.  
        @result Returns KIOReturnSuccess if the page table was cleared successfully. 
    */

    virtual IOReturn releaseCommandBuffers( void );
    
    /*! 
        @function setCommandBlock
        @abstract Sets the command block portion of the ORB.
        @discussion Copys the data provided in the buffer to the command block portion of the ORB.
        @param buffer Pointer to buffer to copy command block from.
        @param length Number of bytes of data to copy.
        @result Returns KIOReturnSuccess if the command block was updated successfully. 
    */
    
    virtual IOReturn setCommandBlock( void * buffer, UInt32 length );
    
    /*! 
        @function setCommandBlock
        @abstract Sets the command block portion of the ORB.
        @discussion Copys the data provided in the buffer to the command block portion of the ORB.
        @param memory IOMemoryDescriptor representing the command block buffer.
        @result Returns KIOReturnSuccess if the command block was updated successfully. 
    */
    
    virtual IOReturn setCommandBlock( IOMemoryDescriptor * memory );
    
    /*! 
        @function getCommandBufferDescriptor
        @abstract Returns the memory descriptor representing the command buffer.
        @discussion Returns the IOMemoryDescriptor for the data mapped by setCommandBuffer variants.  
        Works for setCommandBuffersAsRanges too.
        @result Returns memory descriptor representing mapped data buffers. 
    */
    
	virtual IOMemoryDescriptor * getCommandBufferDescriptor( void );
	
    // accessors
    
    /*! 
        @function setCommandFlags
        @abstract Sets configuration flags for the ORB.
        @discussion Sets the configuration flags for the ORB.  These can be any of the following:
		<p>kFWSBP2CommandCompleteNotify - Set the notify bit as specified in SBP2 standard. Set to receive completion/timeout notification on this ORB.  You almost always want to set this.</p>
		<p>kFWSBP2CommandTransferDataFromTarget - Transfer direction as specified in SBP2 standard.  Set if data is to be written by the device into the host's memory.</p>
		<p>kFWSBP2CommandImmediate - Immediate Append.  ORB address will be written to fetch agent and not chained.  It is only legal to have one immediate ORB in progress at a time.</p>
		<p>kFWSBP2CommandNormalORB - ORB format 0 - Format specified by SBP2 standard.  Set this for most ORBs.</p>
		<p>kFWSBP2CommandReservedORB - ORB format 1 - Format reserved by SBP2 standard for future standardization.</p>
		<p>kFWSBP2CommandVendorORB - ORB format 2 - Format specified by SBP2 standard for vendor dependent ORBs.</p>
		<p>kFWSBP2CommandDummyORB - ORB format 3 - Format specified by SBP2 standard for dummy ORBs.</p>
		<p>kFWSBP2CommandCheckGeneration - If set upon submitORB, the ORB will only be appended if generation set with setCommandGeneration() matches the current generation.  Pretty much all SBP2 drivers need sophisticated logic to track login state, so this is generally not used. </p>
		<p>kFWSBP2CommandFixedSize - Do not allocate more memory for page table if needed.  If there is not enough space in the currently allocated page table, the setCommandBuffers call will fail.  This is important to set if your device is the backing store, as we don't want to cause memory allocations on the paging path. </p>
		<p>kFWSBP2CommandVirtualORBs - Normally ORBs are backed by physical address spaces.  Setting this flag makes this ORB backed by a pseudo address space.  This can make ORBs easier to see in a bus trace.  Virtual ORBs will have an address in the form of ffcX.XXXX.0000.0000.  Pseudo address space backed ORBs are slower, so you won't want to set for deployment builds.</p>
        @param flags The flags to be set.
    */
    
    virtual void setCommandFlags( UInt32 flags );

    /*! 
        @function getCommandFlags
        @abstract Sets configuration flags for the ORB.
        @discussion Returns the current configuration flags set on this ORB.
        @result Return The current ORB flags.
    */
    
    virtual UInt32 getCommandFlags( void );

    /*! 
        @function setMaxPayloadSize
        @abstract Sets max payload size for the ORB.
        @discussion This sets the maximum payload size for this ORB only.  This size is clipped by 
        the global max payload size set in the login object.
        @param maxPayloadSize The maximum payload size in bytes.
    */
    
    virtual void setMaxPayloadSize( UInt32 maxPayloadSize );

    /*! 
        @function getMaxPayloadSize
        @abstract Gets max payload size for the ORB.
        @discussion This gets the maximum payload size for this ORB only.
        @result Returns the maximum payload size in bytes.
    */
    
    virtual UInt32 getMaxPayloadSize( void );

    /*! 
        @function setCommandTimeout
        @abstract Sets the timeout of the ORB.
        @discussion This sets the timeout for the ORB in milliseconds. Note that ORBs without timeouts 
        can be "lost."  You will obviously not recieve timeout notification for timeouts of zero.  But 
        perhaps less obviously you will not recieve orb reset notification, which is really a sort of
        accelerated timeout notification for bus reset situations.  
        @param timeout The timeout duration in milliseconds.
    */
    
    virtual void setCommandTimeout( UInt32 timeout );
    
    /*! 
        @function getCommandTimeout
        @abstract Gets the timeout of the ORB.
        @discussion This method gets the timeout for this ORB in milliseconds.
        @result Returns the timeout for the orb in milliseconds.
    */
    
    virtual UInt32 getCommandTimeout( void );


    /*! 
        @function setCommandGeneration
        @abstract Sets the command generation.
        @discussion This sets the bus generation this ORB should be appended in.  It is only meaningful 
        when combined with the kFWSBP2CommandCheckGeneration flags above.
        @param gen The bus generation for command execution.
    */
    
    virtual void setCommandGeneration( UInt32 gen );
    
    /*! 
        @function getCommandGeneration
        @abstract Gets the command generation.
        @discussion This gets the bus generation this ORB should be appended in.
        @result Returns the bus generation for command execution.
    */
    
    virtual UInt32 getCommandGeneration( void );

    /*!
		@function setRefCon
		@abstract Sets the ORB refCon.
		@discussion Sets a user defined value on the ORB that can be retrieved later with the 
        method getRefCon.
        @param refCon a user defined value.
    */
    
    virtual void setRefCon( void * refCon );

    /*!
		@function getRefCon
		@abstract Returns the refCon set with setRefCon.
		@discussion Returns the user defined value previously stored in the ORB with setRefCon.
        @result Returns the previously stored user defined value.
	*/
    
    virtual void * getRefCon( void );

protected:    

    virtual void setToDummy( void );

public:	
    /*!
		@function getORBAddress
		@abstract Returns the FireWire address of this ORB.
		@discussion Returns the FireWire bus address of this ORB.  This is not the same as the Macintosh 
        address for the IOFireWireSBP2ORB.
        @result Returns the FireWire address of this ORB.
	*/
    
    virtual void getORBAddress( FWAddress * address );

protected:
	
	virtual bool isAppended( void );
	virtual void setIsAppended( bool state );
	virtual UInt32 getFetchAgentWriteRetries( void );
    virtual void setFetchAgentWriteRetries( UInt32 retries );

    virtual void prepareFastStartPacket( IOBufferMemoryDescriptor * descriptor );

	UInt32 getFetchAgentWriteRetryInterval( void );
    void setFetchAgentWriteRetryInterval( UInt32 interval );

	IOReturn completeBufferAddressSpace( void );
	IOReturn prepareBufferAddressSpace( IOMemoryDescriptor * memoryDescriptor );

public:

    /*!
		@function setBufferConstraints
		@abstract Configures page table generation parameters
		@discussion Sets the maximums size of any page table segment and the required alignemnt.  Double buffering
		may be used to satisfy these constraints. The only supported option is kFWSBP2ConstraintForceDoubleBuffer which
		forces a page aligned double buffering of the entire descriptor.
        @result May return an error if there is a problem allocating the underlying resources or if buffers are currently attached.
	*/

	IOReturn setBufferConstraints( UInt64 maxSegmentSize, UInt32 alignment, UInt32 options = 0);


    /*! 
        @function setCommandBuffersAsRanges64
        @abstract Creates a page table from a list of 64 bit ranges.
        @discussion Creates a page table with the given parameters. Any addresses mapped by this method 
        must remain valid until setCommandBuffers is called again or releaseCommandBuffers is called.  
        The SBP2 services do not release references to the command buffers just because the command 
        has completed. This is a 64 bit compatible version of setCommandBuffersAsRanges.
        @param ranges An array of ranges representing the data to be transfered.
        @param withCount The number of ranges in the ranges array.
        @param withDirection An IODirection indicating the direction of data transfer.
        @param withTask The task that these adressses reside in.
        @param offset Offset in bytes into data to begin writing table at.
        @param length Number of bytes of data to map from offset.
        @result Returns KIOReturnSuccess if the page table was written successfully. 
    */
	   
    IOReturn setCommandBuffersAsRanges64(	IOAddressRange *	ranges,
											uint64_t			withCount,
											IODirection			withDirection,
											task_t				withTask,
											uint64_t			offset = 0,
											uint64_t			length = 0);

    /*!
		@function setRefCon64
		@abstract Sets the ORB refCon as a 64 bit value.
		@discussion Sets a user defined value on the ORB that can be retrieved later with the 
        method getRefCon.
        @param refCon a user defined value.
    */
    
    virtual void setRefCon64( UInt64 refCon );

    /*!
		@function getRefCon64
		@abstract Returns the 64 bit refCon set with setRefCon64.
		@discussion Returns the user defined value previously stored in the ORB with setRefCon.
        @result Returns the previously stored user defined value.
	*/
    
    virtual UInt64 getRefCon64( void );

protected:
	
	UInt32	calculateTransferSizeLog( bool * clipping );


};
    
#endif
                                                                                                                                                                                                                                                                                               IOFireWireSBP2Target.h                                                                              0100644 0001750 0001750 00000016576 12567452043 036623  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
  @header IOFireWireSBP2Target
  Contains the class definition for IOFireWireSBP2Target.
*/

#ifndef _IOKIT_IOFIREWIRESBP2TARGET_H
#define _IOKIT_IOFIREWIRESBP2TARGET_H

#include <IOKit/firewire/IOFireWireUnit.h>
#include <IOKit/IOService.h>

enum
{
    kIOFWSBP2FailsOnAckBusy = (1 << 0),
	kIOFWSBP2FailsOnBusResetsDuringIO = (1 << 1),
	kIOFWSBP2DontUsePTPacketLimit = (1 << 2)
};

/*!
    @class IOFireWireSBP2Target
    @abstract Serves as bridge between IOFireWireUnit and IOFireWireLUN.
    @discussion Matches against IOFireWireUnits supporting the SBP2 protocol.  Creates IOFireWireSBP2LUN nubs 	for matching. Most drivers will match against an IOFireWireSBP2LUN, but matching against an 	IOFireWireSBP2Target is also supported. This can be useful in cases where a single driver wishes to 
    control all LUNs on a device. Support for this technique is minimal, however, and the driver will be
    required to discover it's LUNs through the registry.
*/

class IOFireWireSBP2Target : public IOService
{
    OSDeclareDefaultStructors(IOFireWireSBP2Target);

protected:
	
	/////////////////////////////////////////
    // rom keys
	
    enum
    {
        kCmdSpecIDKey 				= 0x38,
        kCmdSetKey					= 0x39,
        kSoftwareRevKey				= 0x3b,
        kFirmwareRevKey	 			= 0x3c,
        kLUNKey						= 0x14,
        kLUNDirectoryKey			= 0xd4,
        kManagementAgentOffsetKey	= 0x54,
		kUnitCharacteristicsKey 	= 0x3A,
		kRevisionKey				= 0x21,
		kFastStartKey				= 0x3E
    };

    typedef struct
    {
		UInt32 cmdSpecID; 
		UInt32 cmdSet;
		UInt32 vendorID;
		UInt32 softwareRev;
		UInt32 firmwareRev; 
		UInt32 lun;
		UInt32 devType;
		UInt32 unitCharacteristics;
		UInt32 managementOffset;
		UInt32 revision;
		bool fastStartSupported;
		UInt32 fastStart;
    } LUNInfo;
	
    // reserved for future use
    struct ExpansionData 
	{
		bool				fStarted;
		OSArray *			fPendingMgtAgentCommands ;
		UInt32				fNumberPendingMgtAgentOrbs;
		UInt32				fNumLUNs;
	};
    ExpansionData * fExpansionData; 
    
	/////////////////////////////////////////
	// private fields
	
    bool 				fOpenFromTarget;
    UInt32				fOpenFromLUNCount;    
    IOFireWireUnit * 	fProviderUnit;
    UInt32				fFlags;
    
	IOFireWireController * fControl;
	
	UInt32 				fIOCriticalSectionCount;
	
	/////////////////////////////////////////
	// private internals

    virtual void free( void );	
    virtual IOReturn message( 	UInt32 type, 
								IOService * provider,
								void * argument = 0);
    
    virtual void scanForLUNs( void );
    IOReturn createLUN( LUNInfo * info );

public:

	/////////////////////////////////////////
	// public methods
	
	/*! @function handleOpen
		@abstract Overrideable method to control the open / close behaviour of an IOService.
		@discussion See IOService for discussion.		
		@param forClient Designates the client of the provider requesting the open.
		@param options Options for the open, may be interpreted by the implementor of handleOpen.
		@result Return true if the open was successful, false otherwise. */

    virtual bool handleOpen( IOService * forClient, IOOptionBits options, void * arg );
	
	/*! 
		@function handleClose
		@abstract Overrideable method to control the open / close behaviour of an IOService.
		@discussion See IOService for discussion.
		@param forClient Designates the client of the provider requesting the close.
		@param options Options for the close, may be interpreted by the implementor of handleOpen. 
	*/

	virtual void handleClose( IOService * forClient, IOOptionBits options );

	/*! 
		@function handleIsOpen
		@abstract Overrideable method to control the open / close behaviour of an IOService.
		@discussion See IOService for discussion.		
		@param forClient If non-zero, isOpen returns the open state for that client. If zero is passed, isOpen returns the open state for all clients.
		@result Returns true if the specific, or any, client has the IOService open. 
	*/
	
    virtual bool handleIsOpen(  const IOService * forClient ) const;
    
	/*! 
		@function start
		@abstract During an IOService instantiation, the start method is called when the IOService has been selected to run on the provider.
		@discussion See IOService for discussion.
		@result Return true if the start was successful, false otherwise (which will cause the instance to be detached and usually freed).
	*/
	
    virtual bool start( IOService *provider );
 
	/*! 
		@function stop
		@abstract During an IOService termination, the stop method is called in its clients before they are detached & it is destroyed.
		@discussion See IOService for discussion.
	*/
   
	virtual void stop( IOService *provider );

	/*!
		@function getFireWireUnit
		@abstract Returns an IOFireWireUnit object.
		@discussion An IOFireWireUnit is the provider of an IOFireWireSBP2Target.  In order to use the base FireWire services
		you will need a reference to the unit.  This method returns that reference.
		@result Returns a pointer to an IOFireWireUnit.
	*/
	
    virtual IOFireWireUnit * getFireWireUnit( void );
	
	/*! 
		@function matchPropertyTable
		@abstract Implements SBP2 specific matching.
		@discussion See IOService for discussion.
	    @param table The dictionary of properties to be matched against.
		@result Returns false if the family considers the matching dictionary does not match in properties it understands, true otherwise.
	*/
	
	virtual bool matchPropertyTable( OSDictionary * table );

    virtual void setTargetFlags( UInt32 flags );
    virtual UInt32 getTargetFlags( void );

protected:
    virtual void configurePhysicalFilter( void );

public:
    virtual void clearTargetFlags( UInt32 flags );
	virtual IOReturn beginIOCriticalSection( void );
	virtual void endIOCriticalSection( void );

    virtual bool finalize( IOOptionBits options );
    
    IOReturn 	synchMgmtAgentAccess( IOFWCommand * mgmtOrbCommand );
	void		completeMgmtAgentAccess( );
	void 		clearMgmtAgentAccess( );
	void		cancelMgmtAgentAccess( IOFWCommand * mgmtOrbCommand );

protected:

    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 0);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 1);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 2);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 3);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 4);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 5);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 6);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 7);
    OSMetaClassDeclareReservedUnused(IOFireWireSBP2Target, 8);	
    
};

#endif
                                                                                                                                  IOFireWireSBP2UserClient.h                                                                          0100644 0001750 0001750 00000020113 12567452043 037430  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIRESBP2USERCLIENT_H
#define _IOKIT_IOFIREWIRESBP2USERCLIENT_H

#include <IOKit/IOUserClient.h>

#define FIREWIREPRIVATE
#include <IOKit/firewire/IOFireWireController.h>
#undef FIREWIREPRIVATE

#include <IOKit/firewire/IOFWUserObjectExporter.h>

#include <IOKit/sbp2/IOFireWireSBP2UserClientCommon.h>
#include <IOKit/sbp2/IOFireWireSBP2LUN.h>

class IOFireWireSBP2UserClient : public IOUserClient
{
    OSDeclareDefaultStructors(IOFireWireSBP2UserClient)

protected:

    bool					fOpened;
	bool					fStarted;
    IOFireWireSBP2Login * 	fLogin;
    task_t					fTask;
	
    IOFireWireSBP2LUN *		fProviderLUN;
    OSAsyncReference64		fMessageCallbackAsyncRef;
    OSAsyncReference64		fLoginCallbackAsyncRef;
    OSAsyncReference64		fLogoutCallbackAsyncRef;
    OSAsyncReference64		fUnsolicitedStatusNotifyAsyncRef;
    OSAsyncReference64		fStatusNotifyAsyncRef;
    OSAsyncReference64		fFetchAgentResetAsyncRef;
	OSAsyncReference64		fFetchAgentWriteAsyncRef;
	
	IOFWUserObjectExporter	*	fExporter;
	
	IOFireWireLib::UserObjectHandle		fSessionRef;
	
 	virtual IOReturn externalMethod(	uint32_t selector, 
										IOExternalMethodArguments * args,
										IOExternalMethodDispatch * dispatch, 
										OSObject * target, 
										void * reference );
public:

	virtual bool initWithTask( task_t owningTask, void * securityToken, UInt32 type, OSDictionary * properties );
	virtual void free ();
				
    virtual bool start( IOService * provider );

    virtual IOReturn clientClose( void );
    virtual IOReturn clientDied( void );

	// IOFireWireSBP2ManagementORB friend class wrappers
	virtual void flushAllManagementORBs( void );

    /////////////////////////////////////////////////
    // IOFireWireSBP2LUN

    IOReturn open( IOExternalMethodArguments * arguments );
	IOReturn openWithSessionRef( IOExternalMethodArguments * arguments );
	IOReturn getSessionRef( IOExternalMethodArguments * arguments );
    IOReturn close( IOExternalMethodArguments * arguments );

    // callbacks
	IOReturn setMessageCallback( IOExternalMethodArguments * arguments );
    virtual IOReturn message( UInt32 type, IOService * provider, void * arg );

    /////////////////////////////////////////////////
    // IOFireWireSBP2Login
    
    IOReturn setLoginCallback( IOExternalMethodArguments * arguments );
	IOReturn setLogoutCallback( IOExternalMethodArguments * arguments );
    IOReturn setUnsolicitedStatusNotify( IOExternalMethodArguments * arguments );
    IOReturn setStatusNotify( IOExternalMethodArguments * arguments );
	IOReturn createLogin( IOExternalMethodArguments * arguments );
    IOReturn releaseLogin( IOExternalMethodArguments * arguments );
    IOReturn submitLogin( IOExternalMethodArguments * arguments );
    IOReturn submitLogout( IOExternalMethodArguments * arguments );
	IOReturn setLoginFlags( IOExternalMethodArguments * arguments );
    IOReturn getMaxCommandBlockSize( IOExternalMethodArguments * arguments );
    IOReturn getLoginID( IOExternalMethodArguments * arguments );
    IOReturn setReconnectTime( IOExternalMethodArguments * arguments );
	IOReturn setMaxPayloadSize( IOExternalMethodArguments * arguments );
    
	IOReturn submitFetchAgentReset( IOExternalMethodArguments * arguments );
	IOReturn setFetchAgentWriteCompletion( IOExternalMethodArguments * arguments );
	IOReturn ringDoorbell( IOExternalMethodArguments * arguments );
	IOReturn enableUnsolicitedStatus( IOExternalMethodArguments * arguments );
	IOReturn setBusyTimeoutRegisterValue( IOExternalMethodArguments * arguments );
    IOReturn setPassword( IOExternalMethodArguments * arguments );

	// callbacks
	
	static void staticLoginCallback( void * refCon, FWSBP2LoginCompleteParamsPtr params );
    virtual void loginCallback( FWSBP2LoginCompleteParamsPtr params );

	static void staticLogoutCallback( void * refCon, FWSBP2LogoutCompleteParamsPtr params );
    virtual void logoutCallback( FWSBP2LogoutCompleteParamsPtr params );

	static void staticStatusNotify( void * refCon, FWSBP2NotifyParams * params );
    virtual void statusNotify( FWSBP2NotifyParams * params );

	static void staticUnsolicitedNotify( void * refCon, FWSBP2NotifyParams * params );
    virtual void unsolicitedNotify( FWSBP2NotifyParams * params );

	static void staticFetchAgentWriteComplete( void * refCon, IOReturn status, IOFireWireSBP2ORB * orb );
	virtual void fetchAgentWriteComplete( IOReturn status, IOFireWireSBP2ORB * orb );

    static void staticFetchAgentResetComplete( void * refCon, IOReturn status );
    virtual void fetchAgentResetComplete( IOReturn status );
	
    /////////////////////////////////////////////////
    // IOFireWireSBP2ORB

    IOReturn createORB(  IOExternalMethodArguments * arguments );
    IOReturn releaseORB(  IOExternalMethodArguments * arguments );
	IOReturn submitORB(  IOExternalMethodArguments * arguments );
    IOReturn setCommandFlags(  IOExternalMethodArguments * arguments );
    IOReturn setORBRefCon(  IOExternalMethodArguments * arguments );
	IOReturn setMaxORBPayloadSize(  IOExternalMethodArguments * arguments );
    IOReturn setCommandTimeout(  IOExternalMethodArguments * arguments );
	IOReturn setCommandGeneration(  IOExternalMethodArguments * arguments );
    IOReturn setToDummy(  IOExternalMethodArguments * arguments );
    IOReturn setCommandBuffersAsRanges(  IOExternalMethodArguments * arguments );
    IOReturn releaseCommandBuffers(  IOExternalMethodArguments * arguments );
    IOReturn setCommandBlock(  IOExternalMethodArguments * arguments );
	
	// LSI workaround
    IOReturn LSIWorkaroundSetCommandBuffersAsRanges(  IOExternalMethodArguments * arguments );
	IOReturn LSIWorkaroundSyncBuffersForOutput(  IOExternalMethodArguments * arguments );
	IOReturn LSIWorkaroundSyncBuffersForInput(  IOExternalMethodArguments * arguments );
															
    /////////////////////////////////////////////////
    // IOFireWireSBP2MgmtORB

	IOReturn createMgmtORB(  IOExternalMethodArguments * arguments );
    IOReturn releaseMgmtORB(  IOExternalMethodArguments * arguments );
    IOReturn setMgmtORBCallback(  IOExternalMethodArguments * arguments );
    IOReturn submitMgmtORB(  IOExternalMethodArguments * arguments );	
	IOReturn setMgmtORBCommandFunction(  IOExternalMethodArguments * arguments );
	IOReturn setMgmtORBManageeORB(  IOExternalMethodArguments * arguments );
	IOReturn setMgmtORBManageeLogin(  IOExternalMethodArguments * arguments );
	IOReturn setMgmtORBResponseBuffer(  IOExternalMethodArguments * arguments );

	// callbacks
    static void staticMgmtORBCallback( void * refCon, IOReturn status, IOFireWireSBP2ManagementORB * orb );
    virtual void mgmtORBCallback( IOReturn status, IOFireWireSBP2ManagementORB * orb );
	
	// IOFireWireSBP2MgmtORB friend class wrappers
	virtual void setMgmtORBAsyncCallbackReference( IOFireWireSBP2ManagementORB * orb, void * asyncRef );    
	virtual void getMgmtORBAsyncCallbackReference( IOFireWireSBP2ManagementORB * orb, void * asyncRef );

	    uint32_t		   checkScalarInputCount;
    uint32_t		   checkStructureInputSize;
    uint32_t		   checkScalarOutputCount;
    uint32_t		   checkStructureOutputSize;
    
    IOReturn checkArguments( IOExternalMethodArguments * args, uint32_t scalarInCount, uint32_t structInCount, 
    													uint32_t scalarOutCount, uint32_t structOutCount );

};

#endif                                                                                                                                                                                                                                                                                                                                                                                                                                                     IOFireWireSBP2UserClientCommon.h                                                                    0100644 0001750 0001750 00000010654 12567452043 040612  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIRESBP2USERCLIENTCOMMON_H_
#define _IOKIT_IOFIREWIRESBP2USERCLIENTCOMMON_H_

#define kIOFireWireSBP2LibConnection 12

enum IOFWSBP2UserClientCommandCodes {
    kIOFWSBP2UserClientOpen,						// kIOUCScalarIScalarO 0,0
    kIOFWSBP2UserClientClose,						// kIOUCScalarIScalarO 0,0
    kIOFWSBP2UserClientCreateLogin,					// kIOUCScalarIScalarO 0,1
    kIOFWSBP2UserClientReleaseLogin,				// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSubmitLogin,					// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSubmitLogout,				// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSetLoginFlags,				// kIOUCScalarIScalarO 2,0
    kIOFWSBP2UserClientGetMaxCommandBlockSize,		// kIOUCScalarIScalarO 1,1
    kIOFWSBP2UserClientGetLoginID,					// kIOUCScalarIScalarO 1,1
    kIOFWSBP2UserClientSetReconnectTime,			// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSetMaxPayloadSize,			// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientCreateORB,					// kIOUCScalarIScalarO 0,1
    kIOFWSBP2UserClientReleaseORB,					// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSubmitORB,					// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSetCommandFlags,  			// kIOUCScalarIScalarO 2,0
    kIOFWSBP2UserClientSetMaxORBPayloadSize, 		// kIOUCScalarIScalarO 2,0
    kIOFWSBP2UserClientSetCommandTimeout, 			// kIOUCScalarIScalarO 2,0
    kIOFWSBP2UserClientSetCommandGeneration, 		// kIOUCScalarIScalarO 2,0
    kIOFWSBP2UserClientSetToDummy,	  				// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSetCommandBuffersAsRanges,	// kIOUCScalarIScalarO 6,0
    kIOFWSBP2UserClientReleaseCommandBuffers, 		// kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientSetCommandBlock,	  			// kIOUCScalarIScalarO 3,0
	kIOFWSBP2UserClientCreateMgmtORB,     			// kIOUCScalarIScalarO 0,1
	kIOFWSBP2UserClientReleaseMgmtORB,   			// kIOUCScalarIScalarO 1,0
	kIOFWSBP2UserClientSubmitMgmtORB,    			// kIOUCScalarIScalarO 1,0
	kIOFWSBP2UserClientMgmtORBSetCommandFunction,   // kIOUCScalarIScalarO 2,0
	kIOFWSBP2UserClientMgmtORBSetManageeORB,  		// kIOUCScalarIScalarO 2,0
	kIOFWSBP2UserClientMgmtORBSetManageeLogin,    	// kIOUCScalarIScalarO 2,0
	kIOFWSBP2UserClientMgmtORBSetResponseBuffer,    // kIOUCScalarIScalarO 3,0
	kIOFWSBP2UserClientLSIWorkaroundSetCommandBuffersAsRanges, // kIOUCScalarIScalarO 6,0
	kIOFWSBP2UserClientMgmtORBLSIWorkaroundSyncBuffersForOutput, // kIOUCScalarIScalarO 1,0
	kIOFWSBP2UserClientMgmtORBLSIWorkaroundSyncBuffersForInput, // kIOUCScalarIScalarO 1,0
    kIOFWSBP2UserClientOpenWithSessionRef,			// kIOUCScalarIScalarO 1,0
	kIOFWSBP2UserClientGetSessionRef,				// kIOUCScalarIScalarO 0,1
	kIOFWSBP2UserClientRingDoorbell,				// kIOUCScalarIScalarO 1, 0
	kIOFWSBP2UserClientEnableUnsolicitedStatus, // kIOUCScalarIScalarO 1, 0
	kIOFWSBP2UserClientSetBusyTimeoutRegisterValue,   // kIOUCScalarIScalarO 2, 0
	kIOFWSBP2UserClientSetORBRefCon, 				// kIOUCScalarIScalarO 2, 0
	kIOFWSBP2UserClientSetPassword,					// kIOUCScalarIScalarO 3, 0
    kIOFWSBP2UserClientSetMessageCallback,   		// kIOUCScalarIScalarO 2, 0
    kIOFWSBP2UserClientSetLoginCallback,			// kIOUCScalarIScalarO 2, 0
    kIOFWSBP2UserClientSetLogoutCallback,			// kIOUCScalarIScalarO 2, 0
    kIOFWSBP2UserClientSetUnsolicitedStatusNotify, 	// kIOUCScalarIScalarO 2, 0
    kIOFWSBP2UserClientSetStatusNotify, 			// kIOUCScalarIScalarO 2, 0
	kIOFWSBP2UserClientSetMgmtORBCallback,  		// kIOUCScalarIScalarO 3, 0
	kIOFWSBP2UserClientSubmitFetchAgentReset,  		// kIOUCScalarIScalarO 3, 0
	kIOFWSBP2UserClientSetFetchAgentWriteCompletion, // kIOUCScalarIScalaO 2, 0
    kIOFWSBP2UserClientNumCommands
};

#endif                                                                                    IOFireWireSerialBusProtocolTransport.h                                                              0100644 0001750 0001750 00000033437 12567471025 042272  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/sbp2                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


/*!
  @header IOFireWireSerialBusProtocolTransport
  Contains the class definition for IOFireWireSerialBusProtocolTransport.
*/


#ifndef _IOKIT_IO_FIREWIRE_SERIAL_BUS_PROTOCOL_TRANSPORT_H_
#define _IOKIT_IO_FIREWIRE_SERIAL_BUS_PROTOCOL_TRANSPORT_H_


#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/IOLib.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOService.h>
#include <IOKit/IOCommandPool.h>
#include <IOKit/firewire/IOFireWireUnit.h>
#include <IOKit/sbp2/IOFireWireSBP2LUN.h>

#include <IOKit/scsi/IOSCSIProtocolServices.h>

/*!
	@class IOFireWireSerialBusProtocolTransport
	@abstract SCSI Protocol Driver Family for FireWire SBP2 Devices. 
	@discussion IOFireWireSerialBusProtocolTransport contains all the bus specific support for FireWire
	SBP2 compliant devices. To add vendor specific features or workarounds you will sub-class the appropriate
	methods of this family. 
*/

class IOFireWireSerialBusProtocolTransport : public IOSCSIProtocolServices
{
	
	OSDeclareDefaultStructors ( IOFireWireSerialBusProtocolTransport )
	
private:
	
	IOFireWireUnit *				fUnit;
	IOFireWireSBP2LUN *				fSBPTarget;
	IOFireWireSBP2Login *			fLogin;
	IOFireWireSBP2ORB *				fORB;
	IOFireWireSBP2ManagementORB * 	fLUNResetORB;
	
	// /!\ WARNING! NOT USED left behind for legacy binary reasons
	IOSimpleLock *					fQueueLock;
	
	UInt32							fLoginRetryCount;
	bool							fDeferRegisterService;
	bool							fNeedLogin;
    
    // /!\ WARNING! NOT USED left behind for legacy binary reasons
	bool							fPhysicallyConnected;
	
	static void
	StatusNotifyStatic ( void * refCon, FWSBP2NotifyParamsPtr params );
	
	static void
	UnsolicitedStatusNotifyStatic (	void * 					refCon,
									FWSBP2NotifyParamsPtr 	params );
	
	static void
	LunResetCompleteStatic (	void * 							refCon,
								IOReturn						status,
								IOFireWireSBP2ManagementORB * 	orb );
	
	static void
	FetchAgentResetCompleteStatic (	void * refcon,
									IOReturn status );
	
	static IOReturn
	ConnectToDeviceStatic (	OSObject * refCon, void *, void *, void *, void * );
	
	virtual void
	FetchAgentResetComplete ( IOReturn status );
	
	static void LoginCompletionStatic ( void * refCon, FWSBP2LoginCompleteParams * params );
	
	static void
	LogoutCompletionStatic ( void * refCon, FWSBP2LogoutCompleteParams * params );
	
	/*!
		@function CoalesceSenseData
		@abstract CoalesceSenseData convert a SBP-2 status block into a SPC-2 sense block.
		@discussion	CoalesceSenseData pulls the appropriate bits out of the SBP2 sense block
		as defined in SBP-2 Annex B section B.2 and dynamically builds a sense data block as
		defined in SPC-2 section 7.23.2.
	*/
	
	SCSITaskStatus
	CoalesceSenseData (	FWSBP2StatusBlock *	sourceData,
						UInt8				quadletCount,
						SCSI_Sense_Data *	targetData );
	
	virtual void ConnectToDevice ( void );
	
	virtual void DisconnectFromDevice ( void );
	
	virtual bool IsDeviceCPUInDiskMode ( void );

protected:
    
	/*!
		@function AllocateResources
		@abstract Allocate Resources.
		@discussion	Called from start method to allocate needed resources.
	*/
    
	virtual IOReturn AllocateResources ( void );
    
	/*!
		@function DeallocateResources
		@abstract Deallocate Resources.
		@discussion	Called from cleanUp method to deallocate resources.
	*/
    
	virtual void DeallocateResources ( void );
	
	enum SBP2LoginState
	{
		kFirstTimeLoggingInState,
		kLogginSucceededState,
		kLogginFailedState
	};
	
	/*! 
		@typedef SBP2ClientOrbData
		@param orb IOFireWireSBP2ORB for request.
		@param scsiTask SCSITaskIdentifier of request. 
		@param serviceResponse SCSIServiceResponse of request.
		@param taskStatus SCSITaskStatus of request.
		@discussion This structure is stuffed into the refcon so we can associate which
		IOFireWireSBP2ORB and SCSITaskIdentifier is completing.
	*/
	
	typedef struct {
		IOFireWireSBP2ORB *				orb;
		SCSITaskIdentifier 				scsiTask;
		SCSIServiceResponse 			serviceResponse;
		SCSITaskStatus					taskStatus;
		IOBufferMemoryDescriptor *		quadletAlignedBuffer;
	} SBP2ClientOrbData;
	
	static const UInt32 kDefaultBusyTimeoutValue	= 0x0000000F;
	static const UInt64 kMaxFireWireLUN				= 0xFFFF;
	static const UInt32 kMaxFireWirePayload			= 4096;
	static const UInt32 kMaxLoginRetryCount			= 8;
	static const UInt32 kMaxReconnectCount			= 128;
	static const UInt32 kCSRModelInfoKey			= 0x17;

	UInt32	fReconnectCount;
	bool 	fLoggedIn;
	
	// binary compatibility instance variable expansion
	struct ExpansionData
	{ 
		IOCommandPool *		fCommandPool;
		IOCommandPool *		fSubmitQueue;
		SBP2LoginState		fLoginState;
		bool				fLUNResetPathFlag;
		int					fLUNResetCount;
		bool				fAlwaysSetSenseData;
		bool				fAutonomousSpinDownWorkAround;
	};
	
	ExpansionData * reserved;
	
	bool fObjectIsOpen;

	/*!
		@function CommandORBAccessor
		@abstract accessor function for fORB.
		@discussion	xxx.
	*/

	IOFireWireSBP2ORB * CommandORBAccessor ( void );
   
	/*!
		@function SBP2LoginAccessor
		@abstract accessor function for fLogin.
		@discussion	xxx.
	*/

	IOFireWireSBP2Login * SBP2LoginAccessor ( void );

	virtual IOReturn
	message ( UInt32 type, IOService * provider, void * argument = 0 );

	/*!
		@function SendSCSICommand
		@abstract Prepare and send a SCSI command to the device.
		@discussion	The incoming SCSITaskIdentifier gets turned into a IOFireWireSBP2ORB
		and is submitted to the SBP2 layer. See IOSCSIProtocolServices.h for more details
		regarding SendSCSICommand. Also see IOFireWireSBP2Lib.h for details regarding the
		IOFireWireSBP2ORB structure and the submitORB method.
		@result If the command was sent to the device and is pending completion, the
		subclass should return true and return back the kSCSIServiceResponse_Request_In_Process response.
		If the command completes immediately with an error, the subclass will return true
		and return back the appropriate status. If the subclass is currently processing all the
		commands it can, the subclass will return false and the command will be resent next time
		CommandCompleted is called.
	*/

	virtual bool 
	SendSCSICommand (	SCSITaskIdentifier 		request,
						SCSIServiceResponse *	serviceResponse,
						SCSITaskStatus *		taskStatus );

	/*!
		@function SetCommandBuffers
		@abstract Method to set orb's buffers.
		@discussion	This method was added so that subclasses can override and massage buffers as
		needed. The default simply calls setCommandBuffers. See IOFireWireSBP2Lib.h for details
		regarding the setCommandBuffers method.
		@result xxx.
	*/
	
	virtual IOReturn
	SetCommandBuffers (	IOFireWireSBP2ORB * orb, SCSITaskIdentifier request );

	/*!
		@function CompleteSCSITask
		@abstract This qualifies and sets appropriate data then calls CommandCompleted.
		@discussion	See IOSCSIProtocolServices.h for more details
		regarding CommandCompleted.
	*/
	
	virtual void 
	CompleteSCSITask ( IOFireWireSBP2ORB * orb );

	/*!
		@function AbortSCSICommand
		@abstract This method is intended to abort an in progress SCSI Task.
		@discussion	Currently not implemented in super class. This is a stub method for adding
		the abort command in the near future.
		@result See SCSITask.h for SCSIServiceResponse codes.
	*/
	
	virtual SCSIServiceResponse 
	AbortSCSICommand ( SCSITaskIdentifier request );

	/*!
		@function StatusNotify
		@abstract This is our handler for status.
		@discussion See IOFireWireSBP2Lib.h for details regarding the FWSBP2NotifyParams
		structure that is passed in to the completion..
	*/
	
	virtual void
	StatusNotify ( FWSBP2NotifyParams * params );

	/*!
		@function SetValidAutoSenseData
		@abstract Set the auto sense data that was returned for a given SCSI Task.
		@discussion	SetValidAutoSenseData is called to qualify sense data that is copied to the
		client via the SetAutoSenseData method. See IOSCSIProtocolServices.h for more details
		regarding SetAutoSenseData.
	*/
	
	void
	SetValidAutoSenseData (	SBP2ClientOrbData *	clientData,
							FWSBP2StatusBlock *	statusBlock,
							SCSI_Sense_Data *	targetData );
	
	/*!
		@function UnsolicitedStatusNotify
		@abstract This is our handler for unsolicited status.
		@discussion	After we have parsed and handled the unsolicited status we call 
		enableUnsolicitedStatus. See IOFireWireSBP2Lib.h for details regarding the
		enableUnsolicitedStatus method.
	*/
	
	virtual void
	UnsolicitedStatusNotify ( FWSBP2NotifyParamsPtr params );

	/*!
		@function LoginCompletion
		@abstract Completion routine for login complete.
		@discussion	See IOFireWireSBP2Lib.h for details regarding the FWSBP2LogoutCompleteParams
		structure that is passed in to the completion.
	*/
	
	virtual void 
	LoginCompletion ( FWSBP2LoginCompleteParams * params );

	/*!
		@function LogoutCompletion
		@abstract Completion routine for logout complete.
		@discussion	See IOFireWireSBP2Lib.h for details regarding the FWSBP2LogoutCompleteParams
		structure that is passed in to the completion.
	*/
	
	virtual void 
	LogoutCompletion ( FWSBP2LogoutCompleteParams * params );

	/*!
		@function IsProtocolServiceSupported
		@abstract Determine is specified feature is supported by the protocol layer.
		@discussion	If the service has a value that must be returned, it will be returned in the
		serviceValue output parameter. See IOSCSIProtocolServices.h for more details regarding
		IsProtocolServiceSupported.
		@result Will return true if the specified feature is supported by the protocol layer.
	*/

	virtual bool
	IsProtocolServiceSupported ( SCSIProtocolFeature feature, void * serviceValue );

	/*!
		@function HandleProtocolServiceFeature
		@abstract Handle specified feature supported by the protocol layer.
		@discussion	See IOSCSIProtocolServices.h for more details regarding HandleProtocolServiceFeature.
		@result Will return true if the specified feature is supported by the protocol layer.
	*/

	virtual bool
	HandleProtocolServiceFeature ( SCSIProtocolFeature feature, void * serviceValue );
   
	/*!
		@function LunResetComplete
		@abstract Callback to submit Fetch Agent Reset.
		@discussion	See IOFireWireSBP2Lib.h for details regarding the submitFetchAgentReset
		method.
	*/
	
	virtual void
	LunResetComplete ( IOReturn status, IOFireWireSBP2ManagementORB * orb );

public:

	/*!
		@function init
		@abstract See IOService for discussion.
		@discussion	Setup and prime class into known state.
	*/
	
	bool init ( OSDictionary * propTable );

	/*! 
		@function start
		@discussion See IOService for discussion.
		@result Return true if the start was successful, false otherwise ( which will
		cause the instance to be detached and usually freed ).
	*/

	virtual bool start ( IOService * provider );
	
	/*!
	 	@function cleanUp
		@abstract cleanUp is called to tear down IOFireWireSerialBusProtocolTransport.
		@discussion	cleanUp is called when we receive a kIOFWMessageServiceIsRequestingClose
		message or if we fail our initialization.
	*/
	
	virtual void cleanUp ( void );
	
	/*!
		@function finalize
		@abstract See IOService for discussion.
		@result Returns true.
	*/
	
	virtual bool finalize ( IOOptionBits options );

	/*! 
		@function free
		@discussion See IOService for discussion.
		@result none.
	*/
	
	virtual void free ( void );
		
protected:
	
	virtual IOReturn login ( void );
    OSMetaClassDeclareReservedUsed ( IOFireWireSerialBusProtocolTransport, 1 );
    
	virtual IOReturn submitLogin ( void );
    OSMetaClassDeclareReservedUsed ( IOFireWireSerialBusProtocolTransport, 2 );
    
	virtual void loginLost ( void );
    OSMetaClassDeclareReservedUsed ( IOFireWireSerialBusProtocolTransport, 3 );
    
    void loginSuspended ( void );
	OSMetaClassDeclareReservedUsed ( IOFireWireSerialBusProtocolTransport, 4 );
   
	virtual void loginResumed ( void );
	OSMetaClassDeclareReservedUsed ( IOFireWireSerialBusProtocolTransport, 5 );

	static IOReturn CriticalOrbSubmissionStatic ( 
			OSObject * refCon, 
			void * val1,
			void * val2,
			void * val3,
			void * val4 );

	/*!
		@function CriticalOrbSubmission
		@abstract xxx.
		@discussion	xxx.
		@result none.
	*/
	
	void
		CriticalOrbSubmission (
			IOFireWireSBP2ORB * orb,
			SCSITaskIdentifier request );
	
	virtual void submitOrbFromQueue ( void );
	OSMetaClassDeclareReservedUsed ( IOFireWireSerialBusProtocolTransport, 6 );
	
private:
	
	// binary compatibility reserved method space
    
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 7 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 8 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 9 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 10 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 11 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 12 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 13 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 14 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 15 );
	OSMetaClassDeclareReservedUnused ( IOFireWireSerialBusProtocolTransport, 16 );
	
};

#endif	/* _IOKIT_IO_FIREWIRE_SERIAL_BUS_PROTOCOL_TRANSPORT_H_ */                                                                                                                                                                                                                                 scsi/                                                                                               0040755 0001750 0001750 00000000000 12612224742 032761  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOBDServices.h                                                                                      0100644 0001750 0001750 00000017173 12567470660 035374  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 2006-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_BD_SERVICES_H_
#define _IOKIT_IO_BD_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// IOKit includes
#include <IOKit/IOTypes.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOBDTypes.h>
#include <IOKit/storage/IOBDBlockStorageDevice.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPeripheralDeviceType05.h>

class IOMemoryDescriptor;

//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOBDServices : public IOBDBlockStorageDevice
{
	
	OSDeclareDefaultStructors ( IOBDServices )
		
protected:
	
	OSSet *								fClients;
	IOSCSIPeripheralDeviceType05 *		fProvider;
	
	virtual void	free ( void );			
	
    // Reserve space for future expansion.
    struct IOBDServicesExpansionData { };
    IOBDServicesExpansionData *		fIOBDServicesReserved;
	
public:
	
	static void			AsyncReadWriteComplete ( void * 		clientData,
		                          				 IOReturn		status,
		                      					 UInt64 		actualByteCount );
	
	// Deprecated
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks,
											IOStorageCompletion		completion );

	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageCompletion		completion );
											
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageAttributes *   attributes,
											IOStorageCompletion *	completion );

    virtual IOReturn	doEjectMedia ( void );

    virtual IOReturn	doFormatMedia ( UInt64 byteCapacity );

    virtual UInt32		doGetFormatCapacities ( UInt64 *	capacities,
    											UInt32		capacitiesMaxCount ) const;
    virtual IOReturn	doSynchronizeCache ( void );
	
	virtual IOReturn	getWriteCacheState ( bool * enabled );
	
	virtual IOReturn	setWriteCacheState ( bool enabled );
        
    virtual char *		getVendorString ( void );
    
    virtual char *		getProductString ( void );
    
    virtual char *		getRevisionString ( void );
    
    virtual char *		getAdditionalDeviceInfoString ( void );
    
    virtual IOReturn	reportBlockSize ( UInt64 * blockSize );
    
    virtual IOReturn	reportEjectability ( bool * isEjectable );
    
    virtual IOReturn	reportMediaState ( bool * mediaPresent, bool * changed );
    
    virtual IOReturn	reportMaxValidBlock ( UInt64 * maxBlock );
        
    virtual IOReturn	reportRemovability ( bool * isRemovable );
    
    virtual IOReturn	reportWriteProtection ( bool * isWriteProtected );

	/* CD Specific */
	virtual IOReturn	doAsyncReadCD ( IOMemoryDescriptor * buffer,
										UInt32 block,
										UInt32 nblks,
										CDSectorArea sectorArea,
										CDSectorType sectorType,
										IOStorageCompletion completion );
	
	virtual IOReturn	readISRC ( UInt8 track, CDISRC isrc );
	
	virtual IOReturn	readMCN ( CDMCN mcn);
	
	virtual IOReturn	readTOC ( IOMemoryDescriptor * buffer );
	
	virtual IOReturn	audioPause ( bool pause );
	
	virtual IOReturn	audioPlay ( CDMSF timeStart, CDMSF timeStop );
	
	virtual IOReturn	audioScan ( CDMSF timeStart, bool reverse );
	
	virtual IOReturn	audioStop ( void );
	
	virtual IOReturn	getAudioStatus ( CDAudioStatus * status );
	
	virtual IOReturn	getAudioVolume ( UInt8 * leftVolume, UInt8 * rightVolume );
	
	virtual IOReturn	setAudioVolume ( UInt8 leftVolume, UInt8 rightVolume );

	virtual IOReturn	getSpeed ( UInt16 * kilobytesPerSecond );
	
	virtual IOReturn	setSpeed ( UInt16 kilobytesPerSecond );
	
	/* DVD Specific */
	virtual UInt32			getMediaType		( void );
    
	virtual IOReturn		reportKey			( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt32 lba,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );
												  
	virtual IOReturn		sendKey				( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );

	virtual IOReturn		readDVDStructure 	( 	IOMemoryDescriptor * 		buffer,
													const UInt8					structureFormat,
													const UInt32				logicalBlockAddress,
													const UInt8					layer,
													const UInt8 				agid );

	/* BD Specific */
    virtual IOReturn		readDiscStructure	(	IOMemoryDescriptor * buffer,
													UInt8                structureFormat,
													UInt32               logicalBlockAddress,
													UInt8                layer,
													UInt8                agid,
													UInt8                mediaType );

	/* 10.6.0 */
    virtual IOReturn		requestIdle ( void );
	
	/* System Specific */
	virtual IOReturn 	message ( UInt32 type, IOService * provider, void * argument );
    virtual IOReturn	setProperties ( OSObject * properties );

	/* User Client Specific */
	virtual bool start ( IOService * provider );
	virtual bool open ( IOService * client, IOOptionBits options, IOStorageAccess access );
	
	virtual bool handleOpen	( IOService * client, IOOptionBits options, void * access );
	virtual void handleClose ( IOService * client, IOOptionBits options );
	virtual bool handleIsOpen ( const IOService * client ) const;

	/* Added with 10.1.3 */
	virtual IOReturn	readTOC (	IOMemoryDescriptor *	buffer,
									CDTOCFormat				format,
									UInt8					msf,
									UInt8					trackSessionNumber,
									UInt16 *				actualByteCount ); 
	
	/* Added with 10.1.3 */
	virtual IOReturn	readDiscInfo (	IOMemoryDescriptor *	buffer,
										UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	virtual IOReturn	readTrackInfo (	IOMemoryDescriptor *	buffer,
										UInt32					address,
										CDTrackInfoAddressType	addressType,
										UInt16 *				actualByteCount );
	
	/* Added with 10.5 */
	virtual IOReturn	splitTrack ( UInt32 address );
	
private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOBDServices, 1 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 2 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 3 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 4 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 5 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 6 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 7 );
    OSMetaClassDeclareReservedUnused ( IOBDServices, 8 );
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_BD_SERVICES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                     IOBlockStorageServices.h                                                                            0100644 0001750 0001750 00000012147 12567470660 037462  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_BLOCK_STORAGE_SERVICES_H_
#define _IOKIT_IO_BLOCK_STORAGE_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// IOKit includes
#include <IOKit/IOTypes.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOBlockStorageDevice.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIBlockCommandsDevice.h>


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOBlockStorageServices : public IOBlockStorageDevice
{
	
	OSDeclareDefaultStructors ( IOBlockStorageServices )
	
private:
	
	bool							fMediaChanged;  /* DEPRECATED */
	bool							fMediaPresent;
	
protected:
	
    IOSCSIBlockCommandsDevice *     fProvider;
	
	UInt64							fMaxReadBlocks;
	UInt64							fMaxWriteBlocks;
	
	virtual bool		attach ( IOService * provider );
	virtual void		detach ( IOService * provider );
	virtual void		free ( void );
    virtual IOReturn	newUserClient (
    						   task_t			owningTask,
    						   void *			securityID,
    						   UInt32			type,
    						   OSDictionary * 	properties,
    						   IOUserClient **	handler );
	
    // Reserve space for future expansion.
    struct IOBlockStorageServicesExpansionData { };
    IOBlockStorageServicesExpansionData * fIOBlockStorageServicesReserved;
	
public:
	
	virtual IOReturn 	message ( UInt32 type, IOService * provider, void * argument );
	
	static void 		AsyncReadWriteComplete ( void * 			clientData,
                                				 IOReturn			status,
                                				 UInt64 			actualByteCount );
	
	// Deprecated
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks,
											IOStorageCompletion		completion );
											
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageCompletion 	completion );

	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageAttributes *   attributes,
											IOStorageCompletion *	completion );
													
    virtual IOReturn	doEjectMedia ( void );
	
    virtual IOReturn	doFormatMedia ( UInt64 byteCapacity );
	
    virtual UInt32		doGetFormatCapacities ( UInt64 *	capacities,
    											UInt32		capacitiesMaxCount ) const;
    virtual IOReturn	doSynchronizeCache ( void );
	
    virtual char *		getVendorString ( void );
    
    virtual char *		getProductString ( void );
    
    virtual char *		getRevisionString ( void );
    
    virtual char *		getAdditionalDeviceInfoString ( void );
    
    virtual IOReturn	reportBlockSize ( UInt64 * blockSize );
    
    virtual IOReturn	reportEjectability ( bool * isEjectable );
    
    virtual IOReturn	reportMediaState ( bool * mediaPresent, bool * changed );
    
    virtual IOReturn	reportMaxValidBlock ( UInt64 * maxBlock );
        
    virtual IOReturn	reportRemovability ( bool * isRemovable );
    
    virtual IOReturn	reportWriteProtection ( bool * isWriteProtected );
	
	virtual IOReturn	getWriteCacheState ( bool * enabled );
	
	virtual IOReturn	setWriteCacheState ( bool enabled );
	
#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 1 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 2 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 3 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 4 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 5 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 6 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 7 );
    OSMetaClassDeclareReservedUnused ( IOBlockStorageServices, 8 );
#endif /* !TARGET_OS_EMBEDDED */
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_BLOCK_STORAGE_SERVICES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                         IOCompactDiscServices.h                                                                             0100644 0001750 0001750 00000017025 12567470660 037274  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_COMPACT_DISC_SERVICES_H_
#define _IOKIT_IO_COMPACT_DISC_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// IOKit includes
#include <IOKit/IOTypes.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOCDTypes.h>
#include <IOKit/storage/IOCDBlockStorageDevice.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPeripheralDeviceType05.h>

class IOMemoryDescriptor;

// Use this switch to turn off the data cache.
#define _USE_DATA_CACHING_		1


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOCompactDiscServices : public IOCDBlockStorageDevice
{
	
	OSDeclareDefaultStructors ( IOCompactDiscServices )
	
#if (_USE_DATA_CACHING_)
	// Data Cache members
	bool				fUseDataCache;			// Indicates if cache should be used.  This
												// will be set to false if all the necessary support
												// for the data cache could not be allocated or
												// initialized.
	UInt8 *				fDataCacheStorage;		// Storage space for the cache
	UInt32				fDataCacheStartBlock;	// Starting block of the data in the cache.
	UInt32				fDataCacheBlockCount;	// Number of contiguous blocks in the cache  
												// starting with fDataCacheStartBlock. A value of
												// zero in this member indicates that all data
												// in the cache is invalid.
	
	IOSimpleLock *		fDataCacheLock; 		// This is the lock for preventing multiple access 
												// while manipulating the data cache.
#endif

protected:
	
	OSSet *								fClients;
	IOSCSIPeripheralDeviceType05 *		fProvider;
	
	virtual void	free ( void );			

    // Reserve space for future expansion.
    struct IOCompactDiscServicesExpansionData { };
    IOCompactDiscServicesExpansionData * fIOCompactDiscServicesReserved;

public:

	static 	void 		AsyncReadWriteComplete ( 	void * 			clientData,
                                					IOReturn		status,
                                					UInt64 			actualByteCount );

	// Deprecated
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks,
											IOStorageCompletion		completion );

	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageCompletion		completion );
											
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageAttributes *   attributes,
											IOStorageCompletion *	completion );

    virtual IOReturn	doEjectMedia ( void );

    virtual IOReturn	doFormatMedia ( UInt64 byteCapacity );

    virtual UInt32		doGetFormatCapacities ( UInt64 *	capacities,
    											UInt32		capacitiesMaxCount ) const;
    virtual IOReturn	doSynchronizeCache ( void );

	virtual IOReturn	getWriteCacheState ( bool * enabled );
	
	virtual IOReturn	setWriteCacheState ( bool enabled );
        
    virtual char *		getVendorString ( void );
    
    virtual char *		getProductString ( void );
    
    virtual char *		getRevisionString ( void );
    
    virtual char *		getAdditionalDeviceInfoString ( void );
    
    virtual IOReturn	reportBlockSize ( UInt64 * blockSize );
    
    virtual IOReturn	reportEjectability ( bool * isEjectable );
    
    virtual IOReturn	reportMediaState ( bool * mediaPresent, bool * changed );
    
    virtual IOReturn	reportMaxValidBlock ( UInt64 * maxBlock );
        
    virtual IOReturn	reportRemovability ( bool * isRemovable );
    
    virtual IOReturn	reportWriteProtection ( bool * isWriteProtected );

	/* CD Specific */
	virtual IOReturn	doAsyncReadCD ( IOMemoryDescriptor * buffer,
										UInt32 block,
										UInt32 nblks,
										CDSectorArea sectorArea,
										CDSectorType sectorType,
										IOStorageCompletion completion );
	
	virtual IOReturn	readISRC ( UInt8 track, CDISRC isrc );
	
	virtual IOReturn	readMCN ( CDMCN mcn);
	
	virtual IOReturn	readTOC ( IOMemoryDescriptor * buffer );
	
	virtual IOReturn	audioPause ( bool pause );
	
	virtual IOReturn	audioPlay ( CDMSF timeStart, CDMSF timeStop );
	
	virtual IOReturn	audioScan ( CDMSF timeStart, bool reverse );
	
	virtual IOReturn	audioStop ( void );
	
	virtual IOReturn	getAudioStatus ( CDAudioStatus * status );
	
	virtual IOReturn	getAudioVolume ( UInt8 * leftVolume, UInt8 * rightVolume );
	
	virtual IOReturn	setAudioVolume ( UInt8 leftVolume, UInt8 rightVolume );

	virtual UInt32		getMediaType ( void );
	
	virtual IOReturn	getSpeed ( UInt16 * kilobytesPerSecond );
	
	virtual IOReturn	setSpeed ( UInt16 kilobytesPerSecond );
			
	/* System Specific */
	virtual IOReturn message ( UInt32 type, IOService * provider, void * argument );
    virtual IOReturn setProperties ( OSObject * properties );
	
	/* User Client Specific */
	virtual bool start ( IOService * provider );
	virtual bool open ( IOService * client, IOOptionBits options, IOStorageAccess access );
	
	virtual bool handleOpen	( IOService * client, IOOptionBits options, void * access );
	virtual void handleClose ( IOService * client, IOOptionBits options );
	virtual bool handleIsOpen ( const IOService * client ) const;
	
	/* Added with 10.1.3 */
	virtual IOReturn	readTOC (	IOMemoryDescriptor *	buffer,
									CDTOCFormat				format,
									UInt8					msf,
									UInt8					trackSessionNumber,
									UInt16 *				actualByteCount ); 
	
	/* Added with 10.1.3 */
	virtual IOReturn	readDiscInfo (	IOMemoryDescriptor *	buffer,
										UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	virtual IOReturn	readTrackInfo (	IOMemoryDescriptor *	buffer,
										UInt32					address,
										CDTrackInfoAddressType	addressType,
										UInt16 *				actualByteCount );

private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 1 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 2 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 3 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 4 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 5 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 6 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 7 );
    OSMetaClassDeclareReservedUnused ( IOCompactDiscServices, 8 );
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_COMPACT_DISC_SERVICES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           IODVDServices.h                                                                                     0100644 0001750 0001750 00000020163 12567470660 035515  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_DVD_SERVICES_H_
#define _IOKIT_IO_DVD_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// IOKit includes
#include <IOKit/IOTypes.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IODVDTypes.h>
#include <IOKit/storage/IODVDBlockStorageDevice.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPeripheralDeviceType05.h>

class IOMemoryDescriptor;

// Use this switch to turn off the data cache.
#define _DVD_USE_DATA_CACHING_		1


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IODVDServices : public IODVDBlockStorageDevice
{
	
	OSDeclareDefaultStructors ( IODVDServices )
	
#if (_DVD_USE_DATA_CACHING_)
	// Data Cache members
	bool				fUseDataCache;			// Indicates if cache should be used.  This
												// will be set to false if all the necessary support
												// for the data cache could not be allocated or
												// initialized.
	UInt8 *				fDataCacheStorage;		// Storage space for the cache
	UInt32				fDataCacheStartBlock;	// Starting block of the data in the cache.
	UInt32				fDataCacheBlockCount;	// Number of contiguous blocks in the cache  
												// starting with fDataCacheStartBlock. A value of
												// zero in this member indicates that all data
												// in the cache is invalid.
	
	IOSimpleLock *		fDataCacheLock; 		// This is the lock for preventing multiple access 
												// while manipulating the data cache.
#endif
	
protected:
	
	OSSet *								fClients;
	IOSCSIPeripheralDeviceType05 *		fProvider;
	
	virtual void	free ( void );			
	
    // Reserve space for future expansion.
    struct IODVDServicesExpansionData { };
    IODVDServicesExpansionData * fIODVDServicesReserved;
	
public:
	
	static void			AsyncReadWriteComplete ( void * 		clientData,
		                          				 IOReturn		status,
		                      					 UInt64 		actualByteCount );
	
	// Deprecated
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks,
											IOStorageCompletion		completion );

	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageCompletion		completion );
											
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageAttributes *   attributes,
											IOStorageCompletion *	completion );

    virtual IOReturn	doEjectMedia ( void );

    virtual IOReturn	doFormatMedia ( UInt64 byteCapacity );

    virtual UInt32		doGetFormatCapacities ( UInt64 *	capacities,
    											UInt32		capacitiesMaxCount ) const;
    virtual IOReturn	doSynchronizeCache ( void );
	
	virtual IOReturn	getWriteCacheState ( bool * enabled );
	
	virtual IOReturn	setWriteCacheState ( bool enabled );
        
    virtual char *		getVendorString ( void );
    
    virtual char *		getProductString ( void );
    
    virtual char *		getRevisionString ( void );
    
    virtual char *		getAdditionalDeviceInfoString ( void );
    
    virtual IOReturn	reportBlockSize ( UInt64 * blockSize );
    
    virtual IOReturn	reportEjectability ( bool * isEjectable );
    
    virtual IOReturn	reportMediaState ( bool * mediaPresent, bool * changed );
    
    virtual IOReturn	reportMaxValidBlock ( UInt64 * maxBlock );
        
    virtual IOReturn	reportRemovability ( bool * isRemovable );
    
    virtual IOReturn	reportWriteProtection ( bool * isWriteProtected );

	/* CD Specific */
	virtual IOReturn	doAsyncReadCD ( IOMemoryDescriptor * buffer,
										UInt32 block,
										UInt32 nblks,
										CDSectorArea sectorArea,
										CDSectorType sectorType,
										IOStorageCompletion completion );
	
	virtual IOReturn	readISRC ( UInt8 track, CDISRC isrc );
	
	virtual IOReturn	readMCN ( CDMCN mcn);
	
	virtual IOReturn	readTOC ( IOMemoryDescriptor * buffer );
	
	virtual IOReturn	audioPause ( bool pause );
	
	virtual IOReturn	audioPlay ( CDMSF timeStart, CDMSF timeStop );
	
	virtual IOReturn	audioScan ( CDMSF timeStart, bool reverse );
	
	virtual IOReturn	audioStop ( void );
	
	virtual IOReturn	getAudioStatus ( CDAudioStatus * status );
	
	virtual IOReturn	getAudioVolume ( UInt8 * leftVolume, UInt8 * rightVolume );
	
	virtual IOReturn	setAudioVolume ( UInt8 leftVolume, UInt8 rightVolume );

	virtual IOReturn	getSpeed ( UInt16 * kilobytesPerSecond );
	
	virtual IOReturn	setSpeed ( UInt16 kilobytesPerSecond );
	
	/* DVD Specific */
	virtual UInt32			getMediaType		( void );
    
	virtual IOReturn		reportKey			( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt32 lba,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );
												  
	virtual IOReturn		sendKey				( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );

	virtual IOReturn		readDVDStructure 	( 	IOMemoryDescriptor * 		buffer,
													const UInt8					structureFormat,
													const UInt32				logicalBlockAddress,
													const UInt8					layer,
													const UInt8 				agid );

	/* 10.6.0 */
    virtual IOReturn		requestIdle ( void );
	
	/* System Specific */
	virtual IOReturn 	message ( UInt32 type, IOService * provider, void * argument );
    virtual IOReturn	setProperties ( OSObject * properties );

	/* User Client Specific */
	virtual bool start ( IOService * provider );
	virtual bool open ( IOService * client, IOOptionBits options, IOStorageAccess access );
	
	virtual bool handleOpen	( IOService * client, IOOptionBits options, void * access );
	virtual void handleClose ( IOService * client, IOOptionBits options );
	virtual bool handleIsOpen ( const IOService * client ) const;

	/* Added with 10.1.3 */
	virtual IOReturn	readTOC (	IOMemoryDescriptor *	buffer,
									CDTOCFormat				format,
									UInt8					msf,
									UInt8					trackSessionNumber,
									UInt16 *				actualByteCount ); 
	
	/* Added with 10.1.3 */
	virtual IOReturn	readDiscInfo (	IOMemoryDescriptor *	buffer,
										UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	virtual IOReturn	readTrackInfo (	IOMemoryDescriptor *	buffer,
										UInt32					address,
										CDTrackInfoAddressType	addressType,
										UInt16 *				actualByteCount );
	
private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IODVDServices, 1 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 2 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 3 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 4 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 5 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 6 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 7 );
    OSMetaClassDeclareReservedUnused ( IODVDServices, 8 );
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_DVD_SERVICES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                             IOReducedBlockServices.h                                                                            0100644 0001750 0001750 00000011375 12567470660 037433  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_REDUCED_BLOCK_SERVICES_H_
#define _IOKIT_IO_REDUCED_BLOCK_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// Generic IOKit related headers
#include <IOKit/IOTypes.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOBlockStorageDevice.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPeripheralDeviceType0E.h>


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOReducedBlockServices : public IOBlockStorageDevice
{
	
	OSDeclareDefaultStructors ( IOReducedBlockServices )
	
	
protected:
    // Reserve space for future expansion.
    struct IOReducedBlockServicesExpansionData { };
    IOReducedBlockServicesExpansionData * fIOReducedBlockServicesReserved;
	
	IOSCSIPeripheralDeviceType0E *     fProvider;
	
	virtual bool	attach ( IOService * provider );
	virtual void	detach ( IOService * provider );
	virtual void	free ( void );
	
	
public:

	virtual IOReturn 	message ( UInt32 type, IOService * provider, void * argument );
	
	static void			AsyncReadWriteComplete ( void * 			clientData,
                                				 IOReturn			status,
                                				 UInt64 			actualByteCount );
                                				
	// Deprecated
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks,
											IOStorageCompletion		completion );

	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageCompletion		completion );
											
	virtual IOReturn	doAsyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											IOStorageAttributes *   attributes,
											IOStorageCompletion *	completion );

    virtual IOReturn	doEjectMedia ( void );

    virtual IOReturn	doFormatMedia ( UInt64 byteCapacity );

    virtual UInt32		doGetFormatCapacities ( UInt64 *	capacities,
    											UInt32		capacitiesMaxCount ) const;

    virtual IOReturn	doSynchronizeCache ( void );
	
	virtual IOReturn	getWriteCacheState ( bool * enabled );
	
	virtual IOReturn	setWriteCacheState ( bool enabled );
        
    virtual char *		getVendorString ( void );
    
    virtual char *		getProductString ( void );
    
    virtual char *		getRevisionString ( void );
    
    virtual char *		getAdditionalDeviceInfoString ( void );
    
    virtual IOReturn	reportBlockSize ( UInt64 * blockSize );
    
    virtual IOReturn	reportEjectability ( bool * isEjectable );
    
    virtual IOReturn	reportMediaState ( bool * mediaPresent, bool * changed );
    
    virtual IOReturn	reportMaxValidBlock ( UInt64 * maxBlock );
        
    virtual IOReturn	reportRemovability ( bool * isRemovable );
    
    virtual IOReturn	reportWriteProtection ( bool * isWriteProtected );

private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 1 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 2 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 3 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 4 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 5 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 6 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 7 );
    OSMetaClassDeclareReservedUnused ( IOReducedBlockServices, 8 );
    
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_REDUCED_BLOCK_SERVICES_H_ */
                                                                                                                                                                                                                                                                   IOSCSIBlockCommandsDevice.h                                                                         0100644 0001750 0001750 00000050273 12567470660 037717  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_BLOCK_COMMANDS_DEVICE_H_
#define _IOKIT_IO_SCSI_BLOCK_COMMANDS_DEVICE_H_

#if defined(KERNEL) && defined(__cplusplus)

//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

// SBC power states as defined in T10:996D SCSI Block Commands - 3 (SBC-3)
// Revision 8c, November 13, 1997, pages 10-11.
enum
{
	kSBCPowerStateSystemSleep 	= 0,
	kSBCPowerStateSleep 		= 1,
	kSBCPowerStateStandby 		= 2,
	kSBCPowerStateIdle			= 3,
	kSBCPowerStateActive		= 4,
	kSBCNumPowerStates			= 5
};

enum
{
	kMediaStateUnlocked	= 0,
	kMediaStateLocked 	= 1
};


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/IOService.h>
#include <IOKit/IOUserClient.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOStorage.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPrimaryCommandsDevice.h>

// Build includes
#include <TargetConditionals.h>


// Forward declaration for the SCSIBlockCommands that is used internally by the
// IOSCSIBlockCommandsDevice class.
class SCSIBlockCommands;

//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIBlockCommandsDevice : public IOSCSIPrimaryCommandsDevice
{
	
	OSDeclareAbstractStructors ( IOSCSIBlockCommandsDevice )
	
private:

	IOReturn				GetWriteCacheState ( IOMemoryDescriptor * 	buffer,
												 UInt8					modePageControlValue );
	
	static void				AsyncReadWriteComplete ( SCSITaskIdentifier	completedTask );
	
protected:
	
	// Reserve space for future expansion.
    struct IOSCSIBlockCommandsDeviceExpansionData
	{
		IONotifier *		fPowerDownNotifier;
		bool				fWriteCacheEnabled;
		bool				fDeviceIsShared;
		UInt64				fMediumBlockCount64;
#if !TARGET_OS_EMBEDDED
		bool				fDeviceHasSATTranslation;
        bool                fDeviceHasNVMETranslation;
#endif /* !TARGET_OS_EMBEDDED */
		bool				fProtocolSpecificPowerControl;
		bool				fRequiresEjectWithStartStopUnit;
	};
    IOSCSIBlockCommandsDeviceExpansionData * fIOSCSIBlockCommandsDeviceReserved;
	
	#define fPowerDownNotifier	fIOSCSIBlockCommandsDeviceReserved->fPowerDownNotifier
	#define fWriteCacheEnabled	fIOSCSIBlockCommandsDeviceReserved->fWriteCacheEnabled
	
	// The fDeviceIsShared is used to indicate whether this device exists on a Physical
	// Interconnect that allows multiple initiators to access it.  This is used mainly
	// by the power management code to not send power state related START_STOP_UNIT
	// commands to the device.
	// The fDeviceIsShared value is also used to prevent power state commands from being
	// sent to manual eject device since these devices behave better when allowed to
	// manage their own power.
	#define fDeviceIsShared	fIOSCSIBlockCommandsDeviceReserved->fDeviceIsShared
	
	// The fMediumBlockCount64 provides support for 64 bit LBAs and
	// replaces fMediumBlockCount which only supports 32 bits.
	// This value should not be directly accessed and instead the member routine 
	// ReportMediumTotalBlockCount() should be used to retrieve it and the member routine
	// SetMediumCharacteristics() should be used to set it.
	#define fMediumBlockCount64	fIOSCSIBlockCommandsDeviceReserved->fMediumBlockCount64
	
#if !TARGET_OS_EMBEDDED
	#define fDeviceHasSATTranslation fIOSCSIBlockCommandsDeviceReserved->fDeviceHasSATTranslation
#endif /* !TARGET_OS_EMBEDDED */

#if !TARGET_OS_EMBEDDED
    #define fDeviceHasNVMETranslation fIOSCSIBlockCommandsDeviceReserved->fDeviceHasNVMETranslation
#endif /* !TARGET_OS_EMBEDDED */

	// Device support protocol specific power off
	#define fProtocolSpecificPowerControl fIOSCSIBlockCommandsDeviceReserved->fProtocolSpecificPowerControl
	
	// Device requires START_STOP_UNIT for ejects, regardless if PREVENT_ALLOW_MEIDUMREMOVAL
	// failed. 
	#define fRequiresEjectWithStartStopUnit fIOSCSIBlockCommandsDeviceReserved->fRequiresEjectWithStartStopUnit
	
private:
	/* OBSOLETE. Use IOSCSIPrimaryCommandsDevice::Get/SetANSIVersion */
	UInt8				fANSIVersion;

protected:
	// ---- Device Characteristics ----
	bool				fMediaIsRemovable;
	
	// ---- Medium Characteristics ----
	bool				fMediumPresent;
	
private:
	// The byte count of each physical block on the medium.
	// This value should not be directly accessed and instead the member routine 
	// ReportMediumBlockSize() should be used to retrieve it and the member routine
	// SetMediumCharacteristics() should be used to set it.
	UInt32				fMediumBlockSize;
	
	// The total number of blocks of fMediumBlockSize on the medium.
	// OBSOLETE.  Use fMediumBlockCount64 instead which allows for support of
	// devices that have 33 through 64 bit LBA values.
	UInt32				fMediumBlockCount;
	
protected:
	// Whether the installed medium is protected from writes
	bool				fMediumIsWriteProtected;
	
	// Whether user removal of medium has been prevented	
	bool				fMediumRemovalPrevented;
	
	// Indicates whether this is a known manual eject device
	bool				fKnownManualEject;
	
	// Polling thread variables
	thread_call_t		fPollingThread;
	UInt32				fPollingMode;
	enum
	{
		kPollingMode_Suspended		= 0,
		kPollingMode_NewMedia 		= 1,
		kPollingMode_MediaRemoval	= 2
	};
	
	// ---- Methods for controlling the current state of device support ----
	virtual bool		InitializeDeviceSupport ( void );
	virtual void		StartDeviceSupport ( void );
	virtual void		SuspendDeviceSupport ( void );
	virtual void		ResumeDeviceSupport ( void );
	virtual void		StopDeviceSupport ( void );
	virtual void		TerminateDeviceSupport ( void );
	virtual void 		free ( void );
	virtual bool		ClearNotReadyStatus ( void );
	virtual void 		CreateStorageServiceNub ( void );
	virtual bool		DetermineDeviceCharacteristics ( void );
	void				GetMediumRotationRate ( void );
	
	// ---- Methods used for controlling the polling thread ----
	virtual void		ProcessPoll ( void );
	virtual void		EnablePolling ( void );
	virtual void		DisablePolling ( void );
	
	// Main and support methods for polling for new Media
	virtual void		PollForNewMedia ( void );
	virtual bool		DetermineMediaPresence ( void );
	virtual bool		PreventMediumRemoval ( void );
	virtual bool		DetermineMediumCapacity (
							UInt64 * 				blockSize,
							UInt64 * 				blockCount );
	virtual bool		DetermineMediumWriteProtectState ( void );
    
    // Main and support methods for polling for Media removal
	virtual void		PollForMediaRemoval ( void );
	
	// ---- Methods used for handling medium characteristics ----
	
	// OBSOLETE - Use the version compatible with 64 bit LBAs instead.
	virtual void		SetMediumCharacteristics (
							UInt32 					blockSize,
							UInt32 					blockCount );

	void				SetMediumCharacteristics (
							UInt64 					blockSize,
							UInt64 					blockCount );
	
	virtual void		ResetMediumCharacteristics ( void );

	virtual IOReturn	IssueRead (
							IOMemoryDescriptor *	buffer,
						 	UInt64					startBlock,
					 		UInt64					blockCount );
	
	virtual IOReturn	IssueRead (
							IOMemoryDescriptor *	buffer,
					  		UInt64					startBlock,
					 		UInt64					blockCount,
					   		void * 					clientData );
	
	virtual IOReturn	IssueWrite (
							IOMemoryDescriptor *	buffer,
							UInt64					startBlock,
					   		UInt64					blockCount );
	
	virtual IOReturn	IssueWrite (
							IOMemoryDescriptor *	buffer,
						 	UInt64					startBlock,
					  		UInt64					blockCount,
							void * 					clientData );
	
	// ----- Power Management Support ------
	
	// We override this method to set our power states and register ourselves
	// as a power policy maker.
	virtual void 		InitializePowerManagement ( IOService * provider );
	
	// We override this method so that when we register for power management,
	// we go to our active power state (which the drive is definitely in
	// at startup time).
	virtual UInt32		GetInitialPowerState ( void );
	
	// We override this method in order to provide the number of transitions
	// from Fully active to Sleep state so that the idle timer can be adjusted
	// to the appropriate time period based on the disk spindown time set in
	// the Energy Saver prefs panel.
	virtual UInt32		GetNumberOfPowerStateTransitions ( void );
	
	// The TicklePowerManager method is called to tell the power manager that
	// the device needs to be in a certain power state to handle requests.
	virtual void		TicklePowerManager ( void );
	
	// The HandlePowerChange method is the state machine for power management.
	// It is guaranteed to be on its own thread of execution (different from
	// the power manager thread AND the workloop thread. This routine can
	// send sync or async calls to the drive without worrying about threading
	// issues.
	virtual void		HandlePowerChange ( void );
	
	// The HandleCheckPowerState (void) method is on the serialized side of the
	// command gate and can change member variables safely without
	// multi-threading issues. It's main purpose is to call the superclass'
	// HandleCheckPowerState ( UInt32 maxPowerState ) with the max power state
	// the class registered with.
	virtual void		HandleCheckPowerState ( void );
	
	// The VerifyMediumPresence method is called to see if the medium which we
	// anticipated being there is still there.
	virtual bool		VerifyMediumPresence ( void );
	
	// The CheckMediumCapacity is called to see if the medium has indeed changed
	// capacity data. If it has, it messages the upper layers.
	void 				CheckMediumCapacityData ( void );
	
public:
	
	static 	void		sProcessPoll ( void * pdtDriver, void * refCon );
	
	// ---- Methods for controlling the device ----
	virtual IOReturn	SyncReadWrite (
							IOMemoryDescriptor *	buffer,
							UInt64					startBlock,
							UInt64					blockCount,
							UInt64					blockSize );
	
	virtual IOReturn	AsyncReadWrite (
							IOMemoryDescriptor *	buffer,
							UInt64					startBlock,
							UInt64					blockCount,
							UInt64					blockSize,
							void * 					clientData );
	
	IOReturn	GetWriteCacheState ( bool * enabled );	
	IOReturn	SetWriteCacheState ( bool enabled );
	void		DetermineMediumGeometry ( void );
	
	// ---- Methods for controlling medium state ----
	virtual IOReturn	EjectTheMedium ( void );
	virtual IOReturn	LockUnlockMedium ( bool doLock );
	virtual IOReturn	SynchronizeCache ( void );
	
	// ---- Methods for controlling media format ----
	virtual IOReturn	FormatMedium (
							UInt64 					blockCount,
							UInt64 					blockSize );
	virtual UInt32		GetFormatCapacities (
							UInt64 * 				capacities,
			 				UInt32   				capacitiesMaxCount ) const;
	
	// ---- Query methods to report device characteristics ----
	
	// Report the maximum number of blocks that the device can handle per
	// read or write.  A value of 0 (zero) indicates there is no limit aside
	// from the size of the method's return parameter.
	virtual UInt64		ReportDeviceMaxBlocksReadTransfer ( void );
	virtual UInt64		ReportDeviceMaxBlocksWriteTransfer ( void );
	
	// Report whether the device supports removal of the media.
	virtual bool		ReportDeviceMediaRemovability ( void );
	
	// ---- Query methods to report installed medium characteristics ----
	virtual UInt64		ReportMediumBlockSize ( void );
	virtual UInt64		ReportMediumTotalBlockCount ( void );
	virtual bool		ReportMediumWriteProtection ( void );
	
	virtual IOReturn	message ( UInt32 type, IOService * nub, void * arg );
	
	// ---- Called prior to restarting or shutting down ----
	virtual void systemWillShutdown ( IOOptionBits specifier );
	
protected:
	
	virtual bool READ_10 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField2Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	// Defined in SBC-2 section 5.10
	bool READ_10 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField3Bit 			RDPROTECT,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			FUA_NV,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField2Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	virtual bool READ_12 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	// Defined in SBC-2 section 5.11
	bool READ_12 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField3Bit			RDPROTECT,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			FUA_NV,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte 			TRANSFER_LENGTH,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField1Byte 			CONTROL );

	bool READ_16 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField3Bit			RDPROTECT,
						SCSICmdField1Bit			DPO,
						SCSICmdField1Bit			FUA,
						SCSICmdField1Bit			FUA_NV,
						SCSICmdField8Byte			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte			TRANSFER_LENGTH,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField1Byte			CONTROL );
	
	virtual bool READ_CAPACITY (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField1Bit 			PMI,
						SCSICmdField1Byte 			CONTROL );
	
	bool READ_CAPACITY_16 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField8Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte			ALLOCATION_LENGTH,
						SCSICmdField1Bit 			PMI,
						SCSICmdField1Byte 			CONTROL );
	
	virtual bool START_STOP_UNIT (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED,
						SCSICmdField4Bit 			POWER_CONDITIONS,
						SCSICmdField1Bit 			LOEJ,
						SCSICmdField1Bit 			START,
						SCSICmdField1Byte 			CONTROL );

	virtual bool SYNCHRONIZE_CACHE (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField2Byte 			NUMBER_OF_BLOCKS,
						SCSICmdField1Byte 			CONTROL );

	// Defined in SBC-2 section 5.22
	bool SYNCHRONIZE_CACHE (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED,
						SCSICmdField1Bit 			SYNC_NV,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField2Byte 			NUMBER_OF_BLOCKS,
						SCSICmdField1Byte 			CONTROL );

	bool SYNCRONIZE_CACHE_16 (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit			SYNC_NV,
						SCSICmdField1Bit			IMMED,
						SCSICmdField8Byte			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte			NUMBER_OF_BLOCKS,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField1Byte			CONTROL );

	virtual bool WRITE_10 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			EBP,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField2Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	//  Defined in SBC-2 section 5.29
	bool WRITE_10 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField3Bit			WRPROTECT,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			FUA_NV,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField2Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	virtual bool WRITE_12 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			EBP,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	//  Defined in SBC-2 section 5.30
	bool WRITE_12 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField3Bit			WRPROTECT,
						SCSICmdField1Bit 			DPO,
						SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			FUA_NV,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField4Byte 			TRANSFER_LENGTH,
						SCSICmdField1Byte 			CONTROL );

	bool WRITE_16 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						UInt32						blockSize,
						SCSICmdField3Bit			WRPROTECT,
						SCSICmdField1Bit			DPO,
						SCSICmdField1Bit			FUA,
						SCSICmdField1Bit			FUA_NV,
						SCSICmdField8Byte			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField4Byte			TRANSFER_LENGTH,
						SCSICmdField5Bit			GROUP_NUMBER,
						SCSICmdField1Byte			CONTROL );	
	
	/* Added with 10.2 */	
	OSMetaClassDeclareReservedUsed ( IOSCSIBlockCommandsDevice, 1 );
	
public:
	
	virtual IOReturn	PowerDownHandler (	void * 			refCon,
											UInt32 			messageType,
											IOService * 	provider,
											void * 			messageArgument,
											vm_size_t 		argSize );
	

	/* Added with 10.2 */	
	OSMetaClassDeclareReservedUsed ( IOSCSIBlockCommandsDevice, 2 );
	
protected:
	
	virtual	void		SetMediumIcon ( void );
	
	
	/* Added with 10.3.3 */		
	OSMetaClassDeclareReservedUsed ( IOSCSIBlockCommandsDevice, 3 );
	
protected:

	virtual	void AsyncReadWriteCompletion ( SCSITaskIdentifier completedTask );
	
	
	/* Added with 10.6.0 */
	OSMetaClassDeclareReservedUsed ( IOSCSIBlockCommandsDevice, 4 );
	
public:
	
	virtual	IOReturn AsyncReadWrite (
							IOMemoryDescriptor *	buffer,
							UInt64					startBlock,
							UInt64					blockCount,
							UInt64					blockSize,
							IOStorageAttributes *	attributes,
							void * 					clientData );
	
	
private:
	
#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 8 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 9 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 10 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 11 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 12 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSIBlockCommandsDevice, 16 );
#endif /* !TARGET_OS_EMBEDDED */
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_SCSI_BLOCK_COMMANDS_DEVICE_H_ */
                                                                                                                                                                                                                                                                                                                                     IOSCSIMultimediaCommandsDevice.h                                                                    0100644 0001750 0001750 00000070705 12567470660 040761  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_MULTIMEDIA_COMMANDS_DEVICE_H_
#define _IOKIT_IO_SCSI_MULTIMEDIA_COMMANDS_DEVICE_H_

#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif

#include <IOKit/storage/IOStorageDeviceCharacteristics.h>

// Build includes
#include <TargetConditionals.h>


//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------


// Message constants
#define kIOMessageTrayStateChange			0x69000035
#define kIOMessageTrayStateHasChanged		kIOMessageTrayStateChange // DEPRECATED, use kIOMessageTrayStateChange instead

// Message values for kIOMessageTrayStateChange
enum
{
	kMessageTrayStateChangeRequestAccepted	= 0,
	kMessageTrayStateChangeRequestRejected	= 1
};

#define kIOMessageMediaAccessChange			0x69000036

// Message values for kIOMessageMediaAccessChange
enum
{
	kMessageDeterminingMediaPresence	= 0,
	kMessageFoundMedia					= 1,
	kMessageMediaTypeDetermined			= 2
};

// IOKit property keys and constants
#define	kIOPropertySupportedCDFeatures		kIOPropertySupportedCDFeaturesKey
#define	kIOPropertySupportedDVDFeatures		kIOPropertySupportedDVDFeaturesKey
#define	kIOPropertySupportedBDFeatures		kIOPropertySupportedBDFeaturesKey
#define kIOPropertyLowPowerPolling			"Low Power Polling"

typedef UInt32 CDFeatures;
enum
{
	kCDFeaturesAnalogAudioBit			= 0,	// Analog Audio playback
	kCDFeaturesReadStructuresBit		= 1,	// CD-ROM
	kCDFeaturesWriteOnceBit				= 2,	// CD-R
	kCDFeaturesReWriteableBit			= 3,	// CD-R/W
	kCDFeaturesCDDAStreamAccurateBit	= 4,	// CD-DA stream accurate
	kCDFeaturesPacketWriteBit			= 5,	// Packet Writing
	kCDFeaturesTAOWriteBit				= 6,	// CD Track At Once
	kCDFeaturesSAOWriteBit				= 7,	// CD Mastering - Session At Once
	kCDFeaturesRawWriteBit				= 8,	// CD Mastering - Raw
	kCDFeaturesTestWriteBit				= 9,	// CD Mastering/TAO - Test Write
	kCDFeaturesBUFWriteBit				= 10	// CD Mastering/TAO - Buffer Underrun Free
};

enum
{
	kCDFeaturesAnalogAudioMask 			= (1 << kCDFeaturesAnalogAudioBit),
	kCDFeaturesReadStructuresMask		= (1 << kCDFeaturesReadStructuresBit),
	kCDFeaturesWriteOnceMask			= (1 << kCDFeaturesWriteOnceBit),
	kCDFeaturesReWriteableMask			= (1 << kCDFeaturesReWriteableBit),
	kCDFeaturesCDDAStreamAccurateMask	= (1 << kCDFeaturesCDDAStreamAccurateBit),
	kCDFeaturesPacketWriteMask			= (1 << kCDFeaturesPacketWriteBit),
	kCDFeaturesTAOWriteMask				= (1 << kCDFeaturesTAOWriteBit),
	kCDFeaturesSAOWriteMask				= (1 << kCDFeaturesSAOWriteBit),
	kCDFeaturesRawWriteMask				= (1 << kCDFeaturesRawWriteBit),
	kCDFeaturesTestWriteMask			= (1 << kCDFeaturesTestWriteBit),
	kCDFeaturesBUFWriteMask				= (1 << kCDFeaturesBUFWriteBit)
};

typedef	UInt32 DVDFeatures;
enum
{
	kDVDFeaturesCSSBit 					= 0,	// DVD-CSS
	kDVDFeaturesReadStructuresBit 		= 1,	// DVD-ROM
	kDVDFeaturesWriteOnceBit			= 2,	// DVD-R
	kDVDFeaturesRandomWriteableBit		= 3,	// DVD-RAM
	kDVDFeaturesReWriteableBit			= 4,	// DVD-RW
	kDVDFeaturesTestWriteBit			= 5,	// DVD-R Write - Test Write
	kDVDFeaturesBUFWriteBit				= 6,	// DVD-R Write - Buffer Underrun Free
	kDVDFeaturesPlusRBit				= 7,	// DVD+R
	kDVDFeaturesPlusRWBit				= 8,	// DVD+RW (implies backgound format support)
	kDVDFeaturesHDReadBit				= 9,	// HD DVD-ROM
	kDVDFeaturesHDRBit					= 10,	// HD DVD-R
	kDVDFeaturesHDRAMBit				= 11,	// HD DVD-RAM
	kDVDFeaturesHDRWBit					= 12	// HD DVD-RW
};

enum
{
	kDVDFeaturesCSSMask 				= (1 << kDVDFeaturesCSSBit),
	kDVDFeaturesReadStructuresMask 		= (1 << kDVDFeaturesReadStructuresBit),
	kDVDFeaturesWriteOnceMask			= (1 << kDVDFeaturesWriteOnceBit),
	kDVDFeaturesRandomWriteableMask		= (1 << kDVDFeaturesRandomWriteableBit),
	kDVDFeaturesReWriteableMask			= (1 << kDVDFeaturesReWriteableBit),
	kDVDFeaturesTestWriteMask			= (1 << kDVDFeaturesTestWriteBit),
	kDVDFeaturesBUFWriteMask			= (1 << kDVDFeaturesBUFWriteBit),
	kDVDFeaturesPlusRMask				= (1 << kDVDFeaturesPlusRBit),
	kDVDFeaturesPlusRWMask				= (1 << kDVDFeaturesPlusRWBit),
	kDVDFeaturesHDReadMask				= (1 << kDVDFeaturesHDReadBit),
	kDVDFeaturesHDRMask					= (1 << kDVDFeaturesHDRBit),
	kDVDFeaturesHDRAMMask				= (1 << kDVDFeaturesHDRAMBit),
	kDVDFeaturesHDRWMask				= (1 << kDVDFeaturesHDRWBit)
};

typedef	UInt32 BDFeatures;
enum
{
	kBDFeaturesReadBit					= 0,	// BD-ROM
	kBDFeaturesWriteBit					= 1		// BD-R / BD-RE
};

enum
{
	kBDFeaturesReadMask					= (1 << kBDFeaturesReadBit),
	kBDFeaturesWriteMask				= (1 << kBDFeaturesWriteBit)
};

enum
{
	kDiscStatusEmpty 					= 0,
	kDiscStatusIncomplete				= 1,
	kDiscStatusComplete					= 2,
	kDiscStatusOther					= 3,
	kDiscStatusMask						= 0x03,
	kDiscStatusErasableMask				= 0x10
};


#if defined(KERNEL) && defined(__cplusplus)

// MMC power states as defined in T10:1228D SCSI Multimedia Commands - 2 (MMC-2)
// Revision 11a, August 30, 1999, page 312 (Annex F).
enum
{
	kMMCPowerStateSystemSleep	= 0,
	kMMCPowerStateSleep 		= 1,
	kMMCPowerStateStandby 		= 2,
	kMMCPowerStateIdle			= 3,
	kMMCPowerStateActive		= 4,
	kMMCNumPowerStates			= 5
};

enum
{
	kMediaStateUnlocked	= 0,
	kMediaStateLocked 	= 1
};


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOMemoryDescriptor.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOStorage.h>
#include <IOKit/storage/IOCDTypes.h>
#include <IOKit/storage/IODVDTypes.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPrimaryCommandsDevice.h>

// Forward definitions for internal use only classes
class SCSIMultimediaCommands;
class SCSIBlockCommands;


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIMultimediaCommandsDevice : public IOSCSIPrimaryCommandsDevice
{
	
	OSDeclareAbstractStructors ( IOSCSIMultimediaCommandsDevice )
	
private:
	
	static void		AsyncReadWriteComplete ( SCSITaskIdentifier completedTask );
	
protected:
	
    // Reserve space for future expansion.
    struct IOSCSIMultimediaCommandsDeviceExpansionData
	{
		IONotifier *		fPowerDownNotifier;
		bool				fDeviceSupportsPowerOff;
		BDFeatures			fSupportedBDFeatures;
		bool				fDeviceSupportsAsyncNotification;
		bool				fDeviceSupportsFastSpindown;
		UInt8				fCDLoadingMechanism;
        bool                fDoNotLockMedia;
	};
    IOSCSIMultimediaCommandsDeviceExpansionData * fIOSCSIMultimediaCommandsDeviceReserved;
	
	#define fPowerDownNotifier 					fIOSCSIMultimediaCommandsDeviceReserved->fPowerDownNotifier
	#define fDeviceSupportsPowerOff 			fIOSCSIMultimediaCommandsDeviceReserved->fDeviceSupportsPowerOff
	#define fSupportedBDFeatures				fIOSCSIMultimediaCommandsDeviceReserved->fSupportedBDFeatures
	#define fDeviceSupportsAsyncNotification	fIOSCSIMultimediaCommandsDeviceReserved->fDeviceSupportsAsyncNotification
	#define fDeviceSupportsFastSpindown			fIOSCSIMultimediaCommandsDeviceReserved->fDeviceSupportsFastSpindown
	#define fCDLoadingMechanism					fIOSCSIMultimediaCommandsDeviceReserved->fCDLoadingMechanism
    #define fDoNotLockMedia                     fIOSCSIMultimediaCommandsDeviceReserved->fDoNotLockMedia
	
	CDFeatures						fSupportedCDFeatures;
	DVDFeatures						fSupportedDVDFeatures;

	UInt16							fCurrentDiscSpeed;	
	bool							fMediaChanged; 
	bool							fMediaPresent;
	
	// The byte count of each physical block on the media.
	UInt32							fMediaBlockSize;
	
	// The total number of blocks of fMediaBlockSize on the media.
	UInt32							fMediaBlockCount;
	
	// Flags used to indicate device feature
	bool							fMediaIsRemovable;
	bool							fMediaIsWriteProtected;
	UInt32							fMediaType;
	
	thread_call_t					fPollingThread;
	bool							fDeviceSupportsLowPowerPolling;
	bool							fLowPowerPollingEnabled;
	UInt32							fPollingMode;
	
	enum
	{
		kPollingMode_Suspended		= 0,
		kPollingMode_NewMedia 		= 1,
		kPollingMode_MediaRemoval	= 2
	};
	
	virtual IOReturn	setProperties ( OSObject * properties );
	
	virtual void 		CreateStorageServiceNub ( void );
	virtual bool		DetermineDeviceCharacteristics ( void );
	virtual IOReturn	DetermineIfMediaIsRemovable ( void );
	virtual IOReturn	DetermineDeviceFeatures ( void );
	virtual void		DetermineMediaType ( void );
	virtual bool		CheckForDVDMediaType ( void );
	virtual bool		CheckForCDMediaType ( void );
	virtual void		PollForMedia ( void );
	virtual void		EnablePolling ( void );
	virtual void		DisablePolling ( void );
	virtual void		CheckWriteProtection ( void );
	virtual bool		ClearNotReadyStatus ( void );
		
	virtual IOReturn	GetDeviceConfiguration ( void );
	virtual IOReturn	GetDeviceConfigurationSize ( UInt32 * size );
	virtual IOReturn	ParseFeatureList ( UInt32 numProfiles, UInt8 * firstFeaturePtr );
	
	virtual IOReturn	GetMechanicalCapabilities ( void );
	virtual IOReturn	GetMechanicalCapabilitiesSize ( UInt32 * size );
	virtual IOReturn	ParseMechanicalCapabilities ( UInt8 * mechanicalCapabilitiesPtr );

	virtual IOReturn	CheckForLowPowerPollingSupport ( void );
	virtual IOReturn	GetCurrentPowerStateOfDrive ( UInt32 * powerState );

	virtual IOReturn	IssueRead ( IOMemoryDescriptor *	buffer,
									UInt64					startBlock,
									UInt64					blockCount );

	virtual IOReturn	IssueRead ( IOMemoryDescriptor *	buffer,
									void *					clientData,
									UInt64					startBlock,
									UInt64					blockCount );
	
	virtual IOReturn	IssueWrite ( IOMemoryDescriptor *	buffer,
									UInt64					startBlock,
									UInt64					blockCount );
	
	virtual IOReturn	IssueWrite ( IOMemoryDescriptor *	buffer,
									void *					clientData,
									UInt64					startBlock,
									UInt64					blockCount );

    virtual void		SetMediaCharacteristics ( UInt32 blockSize, UInt32 blockCount );
 	virtual void		ResetMediaCharacteristics ( void );

	UInt8				ConvertBCDToHex ( UInt8 binaryCodedDigit );

	// ------ User Client Support ------
	
	virtual IOReturn 	HandleSetUserClientExclusivityState ( IOService * userClient, bool state );

	// ----- Power Management Support ------
	
	// We override this method to set our power states and register ourselves
	// as a power policy maker.
	virtual void 		InitializePowerManagement ( IOService * provider );
	
	// We override this method so that when we register for power management,
	// we go to our active power state (which the drive is definitely in
	// at startup time).
	virtual UInt32		GetInitialPowerState ( void );

	// We override this method in order to provide the number of transitions
	// from Fully active to Sleep state so that the idle timer can be adjusted
	// to the appropriate time period based on the disk spindown time set in
	// the Energy Saver prefs panel.
	virtual UInt32		GetNumberOfPowerStateTransitions ( void );
	
	// The TicklePowerManager method is called to tell the power manager that the
	// device needs to be in a certain power state to handle requests.
	virtual void		TicklePowerManager ( void );

	// The HandlePowerChange method is the state machine for power management.
	// It is guaranteed to be on its own thread of execution (different from
	// the power manager thread AND the workloop thread. This routine can
	// send sync or async calls to the drive without worrying about threading
	// issues.
	virtual void		HandlePowerChange ( void );

	// The HandleCheckPowerState (void) method is on the serialized side of the command
	// gate and can change member variables safely without multi-threading issues.
	// It's main purpose is to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState )
	// with the max power state the class registered with.
	virtual void		HandleCheckPowerState ( void );

	// The CheckMediaPresence method is called to see if the media which we
	// anticipated being there is still there.
	virtual bool		CheckMediaPresence ( void );
	
	virtual bool		InitializeDeviceSupport ( void );
	virtual void		StartDeviceSupport ( void );
	virtual void		SuspendDeviceSupport ( void );
	virtual void		ResumeDeviceSupport ( void );
	virtual void		StopDeviceSupport ( void );
	virtual void		TerminateDeviceSupport ( void );
	
	virtual void		free ( void );

	virtual IOReturn	VerifyDeviceState ( void );


public:
	
	virtual IOReturn 	setAggressiveness ( unsigned long type, unsigned long minutes );
	
	virtual IOReturn	SyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					startBlock,
											UInt64					blockCount );
	
	virtual IOReturn	AsyncReadWrite (	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											void *					clientData );

	virtual IOReturn	EjectTheMedia ( void );
	virtual IOReturn	GetTrayState ( UInt8 * trayState );
	virtual IOReturn	SetTrayState ( UInt8 trayState );
	virtual IOReturn	FormatMedia ( UInt64 byteCapacity );
	virtual UInt32		GetFormatCapacities ( 	UInt64 * capacities,
												UInt32   capacitiesMaxCount ) const;
	virtual IOReturn	LockUnlockMedia ( bool doLock );
	virtual IOReturn	SynchronizeCache ( void );
	virtual IOReturn	ReportBlockSize ( UInt64 * blockSize );
	virtual IOReturn	ReportEjectability ( bool * isEjectable );
	virtual IOReturn	ReportLockability ( bool * isLockable );
	virtual IOReturn	ReportPollRequirements ( bool * pollIsRequired,
												 bool * pollIsExpensive );
	virtual IOReturn	ReportMaxReadTransfer (  UInt64 	blockSize,
												 UInt64 * 	max );
	virtual IOReturn	ReportMaxValidBlock ( UInt64 * maxBlock );
	virtual IOReturn	ReportMaxWriteTransfer ( UInt64	blockSize,
												UInt64 * max );
	virtual IOReturn	ReportMediaState ( 	bool * mediaPresent,
											bool * changed );
	virtual IOReturn	ReportRemovability ( bool * isRemovable );
	virtual IOReturn	ReportWriteProtection ( bool * isWriteProtected );
	
	static 	void		sPollForMedia ( void * pdtDriver, void * refCon );

	/* CD Specific */
	virtual IOReturn	SetMediaAccessSpeed ( UInt16 kilobytesPerSecond );
	
	virtual IOReturn	GetMediaAccessSpeed ( UInt16 * kilobytesPerSecond );

	virtual IOReturn	AsyncReadCD ( 	IOMemoryDescriptor * buffer,
										UInt32 block,
										UInt32 nblks,
										CDSectorArea sectorArea,
										CDSectorType sectorType,
										void *	clientData );
	
	virtual IOReturn	ReadISRC ( UInt8 track, CDISRC isrc );
	
	virtual IOReturn	ReadMCN ( CDMCN mcn);
	
	virtual IOReturn	ReadTOC ( IOMemoryDescriptor * buffer );
	
	/* DVD Specific */
	virtual UInt32			GetMediaType		( void );
    
	virtual IOReturn		ReportKey			( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt32 lba,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );
												  
	virtual IOReturn		SendKey				( IOMemoryDescriptor * buffer,
												  const DVDKeyClass keyClass,
												  const UInt8 agid,
												  const DVDKeyFormat keyFormat );
												  
	virtual IOReturn		ReadDVDStructure 	( 	IOMemoryDescriptor * 		buffer,
													const UInt32 				length,
													const UInt8					structureFormat,
													const UInt32				logicalBlockAddress,
													const UInt8					layer,
													const UInt8 				agid );

	// The block size decoding for Read CD and Read CD MSF  as defined in table 255
    bool	GetBlockSize (
						UInt32 *					requestedByteCount,
						SCSICmdField3Bit 			EXPECTED_SECTOR_TYPE,
						SCSICmdField1Bit 			SYNC,
						SCSICmdField2Bit 			HEADER_CODES,
						SCSICmdField1Bit 			USER_DATA,
						SCSICmdField1Bit 			EDC_ECC,
						SCSICmdField2Bit 			ERROR_FIELD,
						SCSICmdField3Bit 			SUBCHANNEL_SELECTION_BITS );
	
	SCSICmdField4Byte ConvertMSFToLBA ( SCSICmdField3Byte MSF );
	
	// The GET CONFIGURATION command as defined in section 6.1.4
    virtual bool GET_CONFIGURATION (
						SCSITaskIdentifier			request,
   						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField2Bit 			RT, 
						SCSICmdField2Byte 			STARTING_FEATURE_NUMBER, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The GET EVENT/STATUS NOTIFICATION command as defined in section 6.1.5
    virtual bool GET_EVENT_STATUS_NOTIFICATION (
						SCSITaskIdentifier			request,
	    				IOMemoryDescriptor *		dataBuffer,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField1Byte 			NOTIFICATION_CLASS_REQUEST, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The GET PERFORMANCE command as defined in section 6.1.6
    virtual bool GET_PERFORMANCE (
						SCSITaskIdentifier			request,
	   					IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Bit 			TOLERANCE, 
						SCSICmdField1Bit 			WRITE, 
						SCSICmdField2Bit 			EXCEPT, 
						SCSICmdField4Byte 			STARTING_LBA, 
						SCSICmdField2Byte 			MAXIMUM_NUMBER_OF_DESCRIPTORS, 
						SCSICmdField1Byte 			CONTROL );

	// The LOAD/UNLOAD MEDIUM command as defined in section 6.1.7
    virtual bool LOAD_UNLOAD_MEDIUM (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField1Bit 			LO_UNLO, 
						SCSICmdField1Bit 			START, 
						SCSICmdField1Byte 			SLOT, 
						SCSICmdField1Byte 			CONTROL );

	// The MECHANISM STATUS command as defined in section 6.1.8
    virtual bool MECHANISM_STATUS (
						SCSITaskIdentifier			request,
	   					IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	virtual bool READ_10 (
						SCSITaskIdentifier			request,
		    			IOMemoryDescriptor 			*dataBuffer, 
		    			UInt32						blockSize,
		    			SCSICmdField1Bit 			DPO, 
		    			SCSICmdField1Bit 			FUA,
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField2Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	// The READ CD command as defined in section 6.1.15
    virtual bool READ_CD (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField3Bit 			EXPECTED_SECTOR_TYPE,
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			STARTING_LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField3Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Bit 			SYNC,
						SCSICmdField2Bit 			HEADER_CODES,
						SCSICmdField1Bit 			USER_DATA,
						SCSICmdField1Bit 			EDC_ECC,
						SCSICmdField2Bit 			ERROR_FIELD,
						SCSICmdField3Bit 			SUBCHANNEL_SELECTION_BITS,
						SCSICmdField1Byte 			CONTROL );

	// The READ CD MSF command as defined in section 6.1.16
    virtual bool READ_CD_MSF (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField3Bit 			EXPECTED_SECTOR_TYPE,
						SCSICmdField3Byte 			STARTING_MSF, 
						SCSICmdField3Byte 			ENDING_MSF, 
						SCSICmdField1Bit 			SYNC,
						SCSICmdField2Bit 			HEADER_CODES,
						SCSICmdField1Bit 			USER_DATA,
						SCSICmdField1Bit 			EDC_ECC,
						SCSICmdField2Bit 			ERROR_FIELD,
						SCSICmdField3Bit 			SUBCHANNEL_SELECTION_BITS,
						SCSICmdField1Byte 			CONTROL );

	// The READ CAPACITY command as defined in section 6.1.17
    virtual bool READ_CAPACITY (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField1Bit 			RELADR,
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
						SCSICmdField1Bit 			PMI,
						SCSICmdField1Byte 			CONTROL );

	// The READ DISC INFORMATION command as defined in section 6.1.18
    virtual bool READ_DISC_INFORMATION (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The READ DVD STRUCTURE command as defined in section 6.1.19
    virtual bool READ_DVD_STRUCTURE (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField4Byte 			ADDRESS,
						SCSICmdField1Byte 			LAYER_NUMBER, 
						SCSICmdField1Byte 			FORMAT, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField2Bit 			AGID,
						SCSICmdField1Byte 			CONTROL );

	// The READ FORMAT CAPACITIES command as defined in section 6.1.20
    virtual bool READ_FORMAT_CAPACITIES (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	// The READ SUB-CHANNEL command as defined in section 6.1.23
    virtual bool READ_SUB_CHANNEL (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField1Bit 			MSF,
						SCSICmdField1Bit 			SUBQ,
						SCSICmdField1Byte 			SUB_CHANNEL_PARAMETER_LIST, 
						SCSICmdField1Byte 			TRACK_NUMBER, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The READ TOC/PMA/ATIP command as defined in section 6.1.24/25
    virtual bool READ_TOC_PMA_ATIP (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer, 
						SCSICmdField1Bit 			MSF,
						SCSICmdField4Bit 			FORMAT,
						SCSICmdField1Byte			TRACK_SESSION_NUMBER,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The READ TRACK INFORMATION command as defined in section 6.1.26
    virtual bool READ_TRACK_INFORMATION (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Bit 			ADDRESS_NUMBER_TYPE,
						SCSICmdField4Byte			LOGICAL_BLOCK_ADDRESS_TRACK_SESSION_NUMBER,
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	/*********************** LEGACY COMMAND SUPPORT ***********************/
	// The SET CD SPEED command as defined in section 6.1.36
    virtual bool SET_CD_SPEED (
						SCSITaskIdentifier			request,
						SCSICmdField2Byte 			LOGICAL_UNIT_READ_SPEED, 
						SCSICmdField2Byte 			LOGICAL_UNIT_WRITE_SPEED, 
						SCSICmdField1Byte 			CONTROL );
	/*********************** END LEGACY COMMAND SUPPORT ***********************/

	// The SET READ AHEAD command as defined in section 6.1.37
    virtual bool SET_READ_AHEAD (
						SCSITaskIdentifier			request,
						SCSICmdField4Byte 			TRIGGER_LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField4Byte 			READ_AHEAD_LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField1Byte 			CONTROL );

	// The SET STREAMING command as defined in section 6.1.38
    virtual bool SET_STREAMING (
						SCSITaskIdentifier			request,
	 		   			IOMemoryDescriptor *		dataBuffer,
						SCSICmdField2Byte 			PARAMETER_LIST_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	virtual bool START_STOP_UNIT ( 
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField4Bit 			POWER_CONDITIONS, 
						SCSICmdField1Bit 			LOEJ, 
						SCSICmdField1Bit 			START, 
						SCSICmdField1Byte 			CONTROL );

	// The SYNCHRONIZE CACHE command as defined in section 6.1.40
    virtual bool SYNCHRONIZE_CACHE (
						SCSITaskIdentifier			request,
						SCSICmdField1Bit 			IMMED, 
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField2Byte 			NUMBER_OF_BLOCKS, 
						SCSICmdField1Byte 			CONTROL );

	// The WRITE (10) command as defined in section 6.1.41
    virtual bool WRITE_10 (
						SCSITaskIdentifier			request,
		    			IOMemoryDescriptor *		dataBuffer, 
		    			UInt32						blockSize,
						SCSICmdField1Bit 			DPO, 
						SCSICmdField1Bit 			FUA, 
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField2Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Byte 			CONTROL );

	// The WRITE AND VERIFY (10) command as defined in section 6.1.42
    virtual bool WRITE_AND_VERIFY_10 (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
		    			UInt32						blockSize,
						SCSICmdField1Bit 			DPO, 
						SCSICmdField1Bit 			BYT_CHK, 
						SCSICmdField1Bit 			RELADR, 
						SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
						SCSICmdField4Byte 			TRANSFER_LENGTH, 
						SCSICmdField1Byte 			CONTROL );
	
	/* Added with 10.1.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 1 );
	
	virtual IOReturn	ReadTOC (	IOMemoryDescriptor *	buffer,
									CDTOCFormat				format,
									UInt8					msf,
									UInt32					trackSessionNumber,
									UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 2 );
    
	virtual IOReturn	ReadDiscInfo (	IOMemoryDescriptor *	buffer,
										UInt16 *				actualByteCount );
	
	/* Added with 10.1.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 3 );
	
	virtual IOReturn	ReadTrackInfo (	IOMemoryDescriptor *	buffer,
										UInt32					address,
										CDTrackInfoAddressType	addressType,
										UInt16 *				actualByteCount );
	
	/* Added with 10.2 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 4 );
	
	virtual IOReturn	PowerDownHandler ( void * 		refCon,
										   UInt32 		messageType,
										   IOService * 	provider,
										   void * 		messageArgument,
										   vm_size_t 	argSize );
	
	/* Added with 10.3.3 */
	OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 5 );
	
	
protected:
	
	
	virtual void AsyncReadWriteCompletion ( SCSITaskIdentifier completedTask );
	
	
public:
	
	
	/* Added with 10.5 */
    OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 6 );
	
	virtual	IOReturn	ReadDiscStructure (	IOMemoryDescriptor * 		buffer,
											const UInt32 				length,
											const UInt8					structureFormat,
											const UInt32				logicalBlockAddress,
											const UInt8					layer,
											const UInt8 				agid,
											const UInt8					mediaType );
	
	
	bool		CheckForBDMediaType ( void );
	
	
    bool		READ_DISC_STRUCTURE (
						SCSITaskIdentifier			request,
						IOMemoryDescriptor *		dataBuffer,
						SCSICmdField4Bit 			MEDIA_TYPE,
						SCSICmdField4Byte 			ADDRESS,
						SCSICmdField1Byte 			LAYER_NUMBER, 
						SCSICmdField1Byte 			FORMAT, 
						SCSICmdField2Byte 			ALLOCATION_LENGTH, 
						SCSICmdField2Bit 			AGID,
						SCSICmdField1Byte 			CONTROL );
	
	
    OSMetaClassDeclareReservedUsed ( IOSCSIMultimediaCommandsDevice, 7 );
	
	virtual	IOReturn	ReserveTrack (	UInt8		reservationType,
										UInt8		reservationFormat,
										UInt64		ReservationParameter );
	
	
	bool		RESERVE_TRACK_V2 (	SCSITaskIdentifier		request,
									SCSICmdField1Bit		RMZ,
									SCSICmdField1Bit		ARSV,
									SCSICmdField7Byte		RESERVATION_PARAMETER,
									SCSICmdField1Byte 		CONTROL					);
	
	
	bool		REPORT_KEY_V2 (	SCSITaskIdentifier			request,
								IOMemoryDescriptor *		dataBuffer,
								SCSICmdField4Byte			LOGICAL_BLOCK_ADDRESS,
								SCSICmdField1Byte			KEY_CLASS,
								SCSICmdField2Byte 			ALLOCATION_LENGTH,
								SCSICmdField2Bit 			AGID,
								SCSICmdField6Bit 			KEY_FORMAT,
								SCSICmdField1Byte 			CONTROL					);
	
	
	bool		SEND_KEY_V2 (	SCSITaskIdentifier			request,
								IOMemoryDescriptor *		dataBuffer,
								SCSICmdField1Byte			KEY_CLASS,
								SCSICmdField2Byte 			PARAMETER_LIST_LENGTH,
								SCSICmdField2Bit 			AGID,
								SCSICmdField6Bit 			KEY_FORMAT,
								SCSICmdField1Byte 			CONTROL					);
	
	
protected:
	
	
	void		SetPollingMode ( UInt32 newPollingMode );
	
	
public:
	
	
	/* 10.6.0 */
	
	IOReturn	RequestIdle ( void );
	
private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 	8 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 	9 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 10 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 11 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 12 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 13 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 14 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 15 );
    OSMetaClassDeclareReservedUnused ( IOSCSIMultimediaCommandsDevice, 16 );
    
};

#endif /* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_SCSI_MULTIMEDIA_COMMANDS_DEVICE_H_ */
                                                           IOSCSIPeripheralDeviceNub.h                                                                         0100644 0001750 0001750 00000020144 12567470660 037735  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_NUB_H_
#define _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_NUB_H_


//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

// Probe score values
enum
{
	kPeripheralDeviceTypeNoMatch 	= 0,
	kDefaultProbeRanking 			= 5000,
	kFirstOrderRanking 				= 10000,
	kSecondOrderRanking 			= 15000,
	kThirdOrderRanking 				= 20000
};


#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOService.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIProtocolServices.h>

// Build includes
#include <TargetConditionals.h>


// Forward definitions for internal use only classes.
class SCSIPrimaryCommands;

//-----------------------------------------------------------------------------
//	Class Declarations
//-----------------------------------------------------------------------------

class IOSCSIPeripheralDeviceNub : public IOSCSIProtocolServices
{
	
	OSDeclareDefaultStructors ( IOSCSIPeripheralDeviceNub )
	
private:
	
	static bool		sCompareIOProperty (
										IOService *		object,
										OSDictionary *	table,
										char *			propertyKeyName,
										bool *			matches );
	
	static void		TaskCallback ( SCSITaskIdentifier completedTask );
	void			TaskCompletion ( SCSITaskIdentifier completedTask );
	
	static IOReturn	sWaitForTask ( void * object, SCSITask * request );
	IOReturn		GatedWaitForTask ( SCSITask * request );
	
protected:

	SCSIServiceResponse SendTask ( SCSITask * request );
	
	bool			InterrogateDevice ( void );										
	
	// Reserve space for future expansion.
	struct IOSCSIPeripheralDeviceNubExpansionData { };
	IOSCSIPeripheralDeviceNubExpansionData * fIOSCSIPeripheralDeviceNubReserved;
	
	IOSCSIProtocolInterface *		fProvider;

	UInt8							fDefaultInquiryCount;
	
	virtual bool		SendSCSICommand ( 	SCSITaskIdentifier 		request, 
											SCSIServiceResponse * 	serviceResponse,
											SCSITaskStatus * 		taskStatus );
	
	virtual SCSIServiceResponse	AbortSCSICommand ( SCSITaskIdentifier request );
	
	// The IsProtocolServiceSupported will return true if the specified
	// feature is supported by the protocol layer.  If the service has a value that must be
	// returned, it will be returned in the serviceValue output parameter.
	virtual bool	IsProtocolServiceSupported ( SCSIProtocolFeature feature, void * serviceValue );
	
	virtual bool	HandleProtocolServiceFeature ( SCSIProtocolFeature feature, void * serviceValue );
	
public:
	
	bool				init	( OSDictionary * propTable );
	virtual bool		start	( IOService * provider );
	virtual void		free	( void );
	
	virtual IOReturn	message ( UInt32 type, IOService * nub, void * arg );
										
	virtual bool		matchPropertyTable ( OSDictionary * table,
											 SInt32 * score );
	
	// The ExecuteCommand method will take a SCSITask object and transport
	// it across the physical wires to the device
	virtual	void		ExecuteCommand ( SCSITaskIdentifier	request );
	
	// The Task Management function to allow the SCSI Application Layer client to request
	// that a specific task be aborted.
	virtual SCSIServiceResponse		AbortTask ( UInt8 theLogicalUnit, SCSITaggedTaskIdentifier theTag );

	// The Task Management function to allow the SCSI Application Layer client to request
	// that a all tasks curerntly in the task set be aborted.
	virtual SCSIServiceResponse		AbortTaskSet ( UInt8 theLogicalUnit );

	virtual SCSIServiceResponse		ClearACA ( UInt8 theLogicalUnit );

	virtual SCSIServiceResponse		ClearTaskSet ( UInt8 theLogicalUnit );
    
	virtual SCSIServiceResponse		LogicalUnitReset ( UInt8 theLogicalUnit );

	virtual SCSIServiceResponse		TargetReset ( void );

    // ************* Obsoleted Member Routine ****************
    // The AbortCommand method is replaced by the AbortTask Management function and
    // should no longer be called.
	virtual SCSIServiceResponse		AbortCommand ( SCSITaskIdentifier abortTask );
	
private:
	

#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  1 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  2 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  3 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  4 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  8 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub,  9 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 10 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 11 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 12 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceNub, 16 );
#endif /* !TARGET_OS_EMBEDDED */
	
};


class IOSCSILogicalUnitNub : public IOSCSIPeripheralDeviceNub
{
	
	OSDeclareDefaultStructors ( IOSCSILogicalUnitNub )
	
private:
	
	UInt8				fLogicalUnitNumber;
	
protected:
	
	// Reserve space for future expansion.
	struct IOSCSILogicalUnitNubExpansionData { };
	IOSCSILogicalUnitNubExpansionData * fIOSCSILogicalUnitNubReserved;
	
public:
	
	virtual void		SetLogicalUnitNumber ( UInt8 newLUN );
	UInt8				GetLogicalUnitNumber ( void );
	
	// The ExecuteCommand method will take a SCSITask object and transport
	// it across the physical wires to the device
	virtual	void		ExecuteCommand ( SCSITaskIdentifier	request );
	
private:
	
#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  1 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  2 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  3 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  4 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  5 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  6 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  7 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  8 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub,  9 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 10 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 11 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 12 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSILogicalUnitNub, 16 );
#endif /* !TARGET_OS_EMBEDDED */
	
};


#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_NUB_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                            IOSCSIPeripheralDeviceType00.h                                                                      0100644 0001750 0001750 00000006714 12567470660 040301  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_OO_H_
#define _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_OO_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIBlockCommandsDevice.h>


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIPeripheralDeviceType00 : public IOSCSIBlockCommandsDevice
{
	
	OSDeclareDefaultStructors ( IOSCSIPeripheralDeviceType00 )
	
protected:
	
	// Reserve space for future expansion.
	struct IOSCSIPeripheralDeviceType00ExpansionData
	{
		OSSet *	fClients;
	};
	IOSCSIPeripheralDeviceType00ExpansionData * fIOSCSIPeripheralDeviceType00Reserved;
	
public:
	
	bool				init ( OSDictionary * propTable );
	virtual bool		start ( IOService * provider );
	virtual void		free ( void );

	virtual bool		handleOpen (
							  IOService * 	client,
							  IOOptionBits 	options,
							  void * 		access );
	
	virtual void		handleClose (
							IOService * 	client,
							IOOptionBits 	options );
	
	virtual bool		handleIsOpen ( const IOService * client ) const;
	
    virtual IOReturn	newUserClient (
    						   task_t			owningTask,
    						   void *			securityID,
    						   UInt32			type,
    						   OSDictionary * 	properties,
    						   IOUserClient **	handler );
	virtual void 		CreateStorageServiceNub ( void );

	virtual char *		GetVendorString ( void );
	virtual char *		GetProductString ( void );
	virtual char *		GetRevisionString ( void );
	
	
private:
	
#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 1 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 2 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 3 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 4 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType00, 8 );
#endif /* !TARGET_OS_EMBEDDED */
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_OO_H_ */
                                                    IOSCSIPeripheralDeviceType05.h                                                                      0100644 0001750 0001750 00000005444 12567470660 040305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_05_H_
#define _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_05_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIMultimediaCommandsDevice.h>


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIPeripheralDeviceType05 : public IOSCSIMultimediaCommandsDevice
{
	
	OSDeclareDefaultStructors ( IOSCSIPeripheralDeviceType05 )
	
protected:
    
    // Reserve space for future expansion.
    struct IOSCSIPeripheralDeviceType05ExpansionData { };
    IOSCSIPeripheralDeviceType05ExpansionData * fIOSCSIPeripheralDeviceType05Reserved;
	
public:
    
    bool			init	( OSDictionary * propTable );
    virtual bool	start	( IOService * provider );
    virtual void 	stop	( IOService *  provider );
	
private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 1 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 2 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 3 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 4 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 5 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 6 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 7 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType05, 8 );
    
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_05_H_ */
                                                                                                                                                                                                                            IOSCSIPeripheralDeviceType07.h                                                                      0100644 0001750 0001750 00000005350 12567470660 040303  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_07_H_
#define _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_07_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIBlockCommandsDevice.h>


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIPeripheralDeviceType07 : public IOSCSIBlockCommandsDevice
{
	
	OSDeclareDefaultStructors ( IOSCSIPeripheralDeviceType07 )
	
protected:
	
	// Reserve space for future expansion.
	struct IOSCSIPeripheralDeviceType07ExpansionData { };
	IOSCSIPeripheralDeviceType07ExpansionData * fIOSCSIPeripheralDeviceType07Reserved;
	
public:
	
	bool			init ( OSDictionary * propTable );
	virtual bool	start ( IOService * provider );
	virtual void 	stop ( IOService *  provider );
		
private:
	
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 1 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 2 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 3 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 4 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType07, 8 );
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_07_H_ */
                                                                                                                                                                                                                                                                                        IOSCSIPeripheralDeviceType0E.h                                                                      0100644 0001750 0001750 00000005535 12567470660 040326  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_0E_H_
#define _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_0E_H_

#if defined(KERNEL) && defined(__cplusplus)

//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIReducedBlockCommandsDevice.h>


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIPeripheralDeviceType0E : public IOSCSIReducedBlockCommandsDevice
{
	
	OSDeclareDefaultStructors ( IOSCSIPeripheralDeviceType0E )
	
protected:
    
    // Reserve space for future expansion.
    struct IOSCSIPeripheralDeviceType0EExpansionData { };
    IOSCSIPeripheralDeviceType0EExpansionData * fIOSCSIPeripheralDeviceType0EReserved;
	
public:
    
    bool			init 	( OSDictionary * propTable );
    virtual bool	start 	( IOService * provider );
    virtual void 	stop 	( IOService *  provider );
	
private:
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 1 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 2 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 3 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 4 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 5 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 6 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 7 );
    OSMetaClassDeclareReservedUnused ( IOSCSIPeripheralDeviceType0E, 8 );
    
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_SCSI_PERIPHERAL_DEVICE_TYPE_0E_H_ */
                                                                                                                                                                   IOSCSIPrimaryCommandsDevice.h                                                                       0100644 0001750 0001750 00000062533 12567470660 040312  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_PRIMARY_COMMANDS_DEVICE_H_
#define _IOKIT_IO_SCSI_PRIMARY_COMMANDS_DEVICE_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOService.h>
#include <IOKit/IOReturn.h>
#include <IOKit/IOMemoryDescriptor.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/SCSICommandDefinitions.h>
#include <IOKit/scsi/SCSICmds_INQUIRY_Definitions.h>
#include <IOKit/scsi/SCSICmds_REQUEST_SENSE_Defs.h>
#include <IOKit/scsi/IOSCSIProtocolInterface.h>

// Build includes
#include <TargetConditionals.h>


//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

// Notification messages
enum
{
	kSCSIServicesNotification_Suspend	= 0x69000080,
	kSCSIServicesNotification_Resume	= 0x69000090
};


// Timeout values
enum
{
	kOneSecondTimeoutInMS 		= 1000,
	kTenSecondTimeoutInMS 		= 10 * kOneSecondTimeoutInMS,
	kThirtySecondTimeoutInMS	= 30 * kOneSecondTimeoutInMS,
    kFortyFiveSecondTimeoutInMS	= 45 * kOneSecondTimeoutInMS
};

// Mode page values for page control field
enum
{
	kModePageControlCurrentValues		= 0x00,
	kModePageControlChangeableValues	= 0x01,
	kModePageControlDefaultValues		= 0x02,
	kModePageControlSavedValues			= 0x03
};

// The command should be tried 5 times.  The original attempt 
// plus 4 retries.
#define kDefaultRetryCount		4

// Forward declarations for internal use only classes
class SCSIPrimaryCommands;


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

class IOSCSIPrimaryCommandsDevice : public IOSCSIProtocolInterface
{
	
	OSDeclareAbstractStructors ( IOSCSIPrimaryCommandsDevice )
	
	friend class SCSITaskUserClient;
	
private:

	IOSCSIProtocolInterface *		fProtocolDriver;
	
	// The fProtocolAccessEnabled member variable indicates whether
	// requests coming from the client can be sent to the device.
	// This will be set to true after the Protocol Service driver is successfully 
	// opened and before the call to InitializeDeviceSupport and set to false before 
	// TerminateDeviceSupport is called.
	bool							fProtocolAccessEnabled;
	
	// The fDeviceAccessEnabled member variable indicates whether
	// requests coming from the client can be sent to the device.
	// This will be set to true after InitializeDeviceSupport is called and
	// set to false before StopDeviceSupport is called.
	bool							fDeviceAccessEnabled;
	bool							fDeviceAccessSuspended;
	
	static bool		ServerKeyswitchCallback ( void *		target,
											  void *		refCon,
											  IOService *	newService );
	
	static void		TaskCallback ( SCSITaskIdentifier completedTask );
	void			TaskCompletion ( SCSITaskIdentifier completedTask );
	
	static IOReturn	sWaitForTask ( void * object, SCSITaskIdentifier request );
	IOReturn		GatedWaitForTask ( SCSITaskIdentifier request );
	
protected:
	
	// Reserve space for future expansion.
	struct IOSCSIPrimaryCommandsDeviceExpansionData
	{
		IONotifier *				fKeySwitchNotifier;
		UInt8						fANSIVersion;
		UInt32						fReadTimeoutDuration;
		UInt32						fWriteTimeoutDuration;
		bool						fCMDQUE;
		SCSITaggedTaskIdentifier	fTaskID;
		IOSimpleLock *				fTaskIDLock;
		UInt32						fRetryCount;
        UInt32                      fNumCommandsExecuting;
	};
	IOSCSIPrimaryCommandsDeviceExpansionData * fIOSCSIPrimaryCommandsDeviceReserved;
	
	#define	fReadTimeoutDuration		fIOSCSIPrimaryCommandsDeviceReserved->fReadTimeoutDuration
	#define	fWriteTimeoutDuration		fIOSCSIPrimaryCommandsDeviceReserved->fWriteTimeoutDuration
	#define	fRetryCount					fIOSCSIPrimaryCommandsDeviceReserved->fRetryCount
    #define	fNumCommandsExecuting       fIOSCSIPrimaryCommandsDeviceReserved->fNumCommandsExecuting
    
	UInt8							fDefaultInquiryCount;
	OSDictionary *					fDeviceCharacteristicsDictionary;
	UInt32							fNumCommandsOutstanding;
	
	virtual void 					free ( void );
	void							SetANSIVersion ( UInt8 );
	void							SetCMDQUE ( bool value );
	IOReturn						GetModeSense ( 
										IOMemoryDescriptor *		dataBuffer,
										SCSICmdField6Bit 			PAGE_CODE,
										SCSICmdField2Byte 			ALLOCATION_LENGTH,
										bool *						use10ByteModeSense );
	bool							RetrieveINQUIRYData (
										UInt8						EVPD,
										UInt8						inquiryPage,
										UInt8 *						inquiryBuffer,
										UInt16 *					dataSize );
	
	// This flag is set if the device responds to a MODE_SENSE_10 command
	// with the page code set to 0x1A (Power Conditions Mode Page)
	bool							fDeviceSupportsPowerConditions;
	
	// This method is called by the start method to obtain information from
	// the device with regards to whether it supports the power conditions mode page.
	virtual void					CheckPowerConditionsModePage ( void );
	
	// This will return back the Protocol driver that is used to
	// send service requests to the device.
	virtual IOSCSIProtocolInterface * GetProtocolDriver ( void );
	
	// This will get a new SCSITask for the caller
	virtual SCSITaskIdentifier		GetSCSITask ( void );
	
	// This will release a SCSITask (eventually return it to a pool)
	virtual void					ReleaseSCSITask ( SCSITaskIdentifier request );
	
	// This will return a unique value for the tagged task identifier
	SCSITaggedTaskIdentifier		GetUniqueTagID ( void );
	
	// Call for executing the command synchronously	
	SCSIServiceResponse 			SendCommand ( 	
										SCSITaskIdentifier 	request,
										UInt32 				timeoutDuration );
														
	// Call for executing the command asycnchronously	
	void 							SendCommand ( 
										SCSITaskIdentifier 	request,
										UInt32 				timeoutDuration,
										SCSITaskCompletion 	taskCompletion );
	
	
	virtual bool 					InitializeDeviceSupport ( void ) = 0;
	virtual void 					StartDeviceSupport ( void ) = 0;
	virtual void 					SuspendDeviceSupport ( void ) = 0;
	virtual void 					ResumeDeviceSupport ( void ) = 0;
	virtual void 					StopDeviceSupport ( void ) = 0;
	virtual void 					TerminateDeviceSupport ( void ) = 0;
	virtual UInt32					GetNumberOfPowerStateTransitions ( void ) = 0;
	
	virtual IOReturn				VerifyDeviceState ( void );
	// Called to clear any power-on/reset status in the drive
	virtual bool					ClearPowerOnReset ( void );
	virtual bool					ClearNotReadyStatus ( void ) = 0;
	
	bool							IsProtocolAccessEnabled ( void );
	bool							IsDeviceAccessEnabled ( void );
	bool							IsDeviceAccessSuspended ( void );

	// Accessors for saving and retrieving data from an SCSITask object.
	bool 							ResetForNewTask(	
										SCSITaskIdentifier 		request );
	bool							SetTaskAttribute ( 
										SCSITaskIdentifier 		request, 
										SCSITaskAttribute 		newAttribute );
	SCSITaskAttribute				GetTaskAttribute ( 
										SCSITaskIdentifier 		request );
	bool							SetTaggedTaskIdentifier ( 
										SCSITaskIdentifier 			request, 
										SCSITaggedTaskIdentifier	taggedTaskIdentifier );
	SCSITaggedTaskIdentifier		GetTaggedTaskIdentifier ( 
										SCSITaskIdentifier 		request );
	bool							SetTaskState ( 	
										SCSITaskIdentifier 		request,
										SCSITaskState 			newTaskState );
	SCSITaskState					GetTaskState ( 
										SCSITaskIdentifier 		request );
	bool							SetTaskStatus ( 
										SCSITaskIdentifier 		request, 
										SCSITaskStatus 			newStatus );
	SCSITaskStatus					GetTaskStatus ( 
										SCSITaskIdentifier 		request );
	bool 							SetCommandDescriptorBlock ( 
										SCSITaskIdentifier 		request,
										UInt8					cdbByte0,
										UInt8					cdbByte1,
										UInt8					cdbByte2,
										UInt8					cdbByte3,
										UInt8					cdbByte4,
										UInt8					cdbByte5 );
	
	// Populate the 10 Byte Command Descriptor Block
	bool 							SetCommandDescriptorBlock ( 
										SCSITaskIdentifier 		request,
										UInt8					cdbByte0,
										UInt8					cdbByte1,
										UInt8					cdbByte2,
										UInt8					cdbByte3,
										UInt8					cdbByte4,
										UInt8					cdbByte5,
										UInt8					cdbByte6,
										UInt8					cdbByte7,
										UInt8					cdbByte8,
										UInt8					cdbByte9 );
	
	// Populate the 12 Byte Command Descriptor Block
	bool 							SetCommandDescriptorBlock ( 
										SCSITaskIdentifier 		request,
										UInt8					cdbByte0,
										UInt8					cdbByte1,
										UInt8					cdbByte2,
										UInt8					cdbByte3,
										UInt8					cdbByte4,
										UInt8					cdbByte5,
										UInt8					cdbByte6,
										UInt8					cdbByte7,
										UInt8					cdbByte8,
										UInt8					cdbByte9,
										UInt8					cdbByte10,
										UInt8					cdbByte11 );
	
	// Populate the 16 Byte Command Descriptor Block
	bool 							SetCommandDescriptorBlock ( 
										SCSITaskIdentifier 		request,
										UInt8					cdbByte0,
										UInt8					cdbByte1,
										UInt8					cdbByte2,
										UInt8					cdbByte3,
										UInt8					cdbByte4,
										UInt8					cdbByte5,
										UInt8					cdbByte6,
										UInt8					cdbByte7,
										UInt8					cdbByte8,
										UInt8					cdbByte9,
										UInt8					cdbByte10,
										UInt8					cdbByte11,
										UInt8					cdbByte12,
										UInt8					cdbByte13,
										UInt8					cdbByte14,
										UInt8					cdbByte15 );
										
	bool							SetDataTransferDirection ( 
										SCSITaskIdentifier 		request, 
										UInt8 					newDirection );
	UInt8							GetDataTransferDirection ( 
										SCSITaskIdentifier 		request );
	bool							SetRequestedDataTransferCount (
										SCSITaskIdentifier 		request, 
										UInt64 					newRequestedCount );
	UInt64							GetRequestedDataTransferCount (
										SCSITaskIdentifier 		request );
	bool							SetRealizedDataTransferCount (
										SCSITaskIdentifier 		request,
										UInt64 					newRealizedDataCount );
	UInt64							GetRealizedDataTransferCount ( 
										SCSITaskIdentifier 		request );
	bool							SetDataBuffer ( 
										SCSITaskIdentifier 		request, 
										IOMemoryDescriptor * 	newBuffer );
	IOMemoryDescriptor *			GetDataBuffer ( 
										SCSITaskIdentifier 		request );
	bool							SetTimeoutDuration ( 
										SCSITaskIdentifier 		request, 
										UInt32 					newTimeout );
	UInt32							GetTimeoutDuration ( 
										SCSITaskIdentifier 		request );
	bool							SetTaskCompletionCallback ( 
										SCSITaskIdentifier 		request,
										SCSITaskCompletion 		newCallback );
	void							TaskCompletedNotification ( 
										SCSITaskIdentifier 		request );
	
	bool							SetServiceResponse (
										SCSITaskIdentifier 		request,
										SCSIServiceResponse 	serviceResponse );
	SCSIServiceResponse 			GetServiceResponse (
										SCSITaskIdentifier 		request );
	bool							SetAutosenseCommand (
										SCSITaskIdentifier 		request,
										UInt8					cdbByte0,
										UInt8					cdbByte1,
										UInt8					cdbByte2,
										UInt8					cdbByte3,
										UInt8					cdbByte4,
										UInt8					cdbByte5 );
	bool							GetAutoSenseData (
										SCSITaskIdentifier 		request,
										SCSI_Sense_Data * 		senseData ); // DEPRECATED, use below function instead
	bool							GetAutoSenseData (
										SCSITaskIdentifier 		request,
										SCSI_Sense_Data * 		senseData,
										UInt8					senseDataSize );
	UInt8							GetAutoSenseDataSize (
										SCSITaskIdentifier 		request );
	
	bool							SetApplicationLayerReference (
										SCSITaskIdentifier 		request,
										void * 					newReferenceValue );
	void *							GetApplicationLayerReference (
										SCSITaskIdentifier 		request );
	
	void 							IncrementOutstandingCommandsCount ( void );
	static void						sIncrementOutstandingCommandsCount ( 
										IOSCSIPrimaryCommandsDevice * self );
	virtual void					HandleIncrementOutstandingCommandsCount ( void );	
	

	// This static member routine provides a mechanism for retrieving a pointer to
	// the object that is claimed as the owner of the specified SCSITask.
	static OSObject *				sGetOwnerForTask ( SCSITaskIdentifier request );
	
public:
	
	bool				init ( OSDictionary * propTable );
	virtual bool		start ( IOService * provider );
	virtual void		stop ( IOService *  provider );
	virtual IOReturn 	message ( UInt32 type, IOService * nub, void * arg );
	
	// The setAgressiveness method is called by the power manager
	// to notify us of certain power management settings. We override
	// this method in order to catch the kPMMinutesToSpinDown message
	// in order to set our idle timer.
	virtual IOReturn 	setAggressiveness ( unsigned long type, unsigned long minutes );
	
	// Methods for getting device information strings
	virtual char *		GetVendorString ( void );
	virtual char *		GetProductString ( void );
	virtual char *		GetRevisionString ( void );
	OSDictionary *		GetProtocolCharacteristicsDictionary ( void );
	OSDictionary *		GetDeviceCharacteristicsDictionary ( void );	
	UInt8				GetANSIVersion ( void );
	bool				GetCMDQUE ( void );
#if !TARGET_OS_EMBEDDED
    OSString *          MapINQUIRYDataToIconFile ( void );
#endif /* !TARGET_OS_EMBEDDED */
	UInt32				GetRetryCount ( void );
	
	// -- SCSI Protocol Interface Methods	--
	// The ExecuteCommand method will take a SCSI Task and transport
	// it across the physical wire(s) to the device
	virtual void		ExecuteCommand ( SCSITaskIdentifier request );
	
	// The Task Management function to allow the SCSI Application Layer client to request
	// that a specific task be aborted.
	SCSIServiceResponse		AbortTask ( UInt8 theLogicalUnit, SCSITaggedTaskIdentifier theTag );

	// The Task Management function to allow the SCSI Application Layer client to request
	// that a all tasks curerntly in the task set be aborted.
	SCSIServiceResponse		AbortTaskSet ( UInt8 theLogicalUnit );

	SCSIServiceResponse		ClearACA ( UInt8 theLogicalUnit );

	SCSIServiceResponse		ClearTaskSet ( UInt8 theLogicalUnit );
    
	SCSIServiceResponse		LogicalUnitReset ( UInt8 theLogicalUnit );

	SCSIServiceResponse		TargetReset ( void );

	// The AbortCommand method will abort the indicated SCSI Task,
	// if it is possible and the task has not already completed.
	virtual SCSIServiceResponse	AbortCommand ( SCSITaskIdentifier request );
	
	// The IsProtocolServiceSupported will return true if the specified
	// feature is supported by the protocol layer.  If the service has a value that must be
	// returned, it will be returned in the serviceValue output parameter.
	virtual bool		IsProtocolServiceSupported (
											SCSIProtocolFeature feature,
											void *				serviceValue );
	
	// The HandleProtocolServiceFeature will return true if the specified feature could
	// be handled properly by the protocol layer.
	virtual bool		HandleProtocolServiceFeature (
											SCSIProtocolFeature	feature,
											void *				serviceValue );
	
	// Utility methods for use by all peripheral device objects.

	// isParameterValid are used to validate that the parameter passed into
	// the command methods are of the correct value.
	
	// Validate Parameter used for 1 bit to 1 byte paramaters
    bool 				IsParameterValid ( 
							SCSICmdField1Byte 			param,
							SCSICmdField1Byte 			mask );
	
	// Validate Parameter used for 9 bit to 2 byte paramaters
	bool 				IsParameterValid ( 
							SCSICmdField2Byte 			param,
							SCSICmdField2Byte 			mask );
	
	// Validate Parameter used for 17 bit to 4 byte paramaters
	bool 				IsParameterValid ( 
							SCSICmdField4Byte 			param,
							SCSICmdField4Byte 			mask );
	
	// Validate Parameter used for 33 bit to 8 byte paramaters
	bool 				IsParameterValid ( 
							SCSICmdField8Byte 			param,
							SCSICmdField8Byte 			mask );
	

	bool 				IsMemoryDescriptorValid (
							IOMemoryDescriptor * 		dataBuffer );
	
	bool 				IsMemoryDescriptorValid (
							IOMemoryDescriptor * 		dataBuffer,
							UInt64						requiredSize );
	
	virtual bool		INQUIRY (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			CMDDT,
							SCSICmdField1Bit 			EVPD,
							SCSICmdField1Byte 			PAGE_OR_OPERATION_CODE,
							SCSICmdField1Byte 			ALLOCATION_LENGTH, 
							SCSICmdField1Byte 			CONTROL );

#if !TARGET_OS_EMBEDDED
	
	virtual bool		LOG_SELECT (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			PCR,
							SCSICmdField1Bit 			SP,
							SCSICmdField2Bit 			PC,
							SCSICmdField2Byte 			PARAMETER_LIST_LENGTH,
							SCSICmdField1Byte 			CONTROL );  

	virtual bool		LOG_SENSE (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			PPC,
							SCSICmdField1Bit 			SP,
							SCSICmdField2Bit 			PC,
							SCSICmdField6Bit 			PAGE_CODE,
							SCSICmdField2Byte 			PARAMETER_POINTER,
							SCSICmdField2Byte 			ALLOCATION_LENGTH, 
							SCSICmdField1Byte 			CONTROL );  
	
#endif /* !TARGET_OS_EMBEDDED */
	
	virtual bool		MODE_SELECT_6 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			PF,
							SCSICmdField1Bit 			SP,
							SCSICmdField1Byte 			PARAMETER_LIST_LENGTH, 
							SCSICmdField1Byte 			CONTROL );  

   	virtual bool		MODE_SELECT_10 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			PF,
							SCSICmdField1Bit 			SP,
							SCSICmdField2Byte 			PARAMETER_LIST_LENGTH, 
							SCSICmdField1Byte 			CONTROL );  

   	virtual bool		MODE_SENSE_6 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			DBD,
	   						SCSICmdField2Bit 			PC,
	   						SCSICmdField6Bit 			PAGE_CODE,
	   						SCSICmdField1Byte 			ALLOCATION_LENGTH,
							SCSICmdField1Byte 			CONTROL );

   	virtual bool		MODE_SENSE_10 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			LLBAA,
							SCSICmdField1Bit 			DBD,
	   						SCSICmdField2Bit 			PC,
	   						SCSICmdField6Bit 			PAGE_CODE,
	   						SCSICmdField2Byte 			ALLOCATION_LENGTH,
							SCSICmdField1Byte 			CONTROL );

#if !TARGET_OS_EMBEDDED
	
  	virtual bool		PERSISTENT_RESERVE_IN (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
	   						SCSICmdField5Bit 			SERVICE_ACTION,
	   						SCSICmdField2Byte 			ALLOCATION_LENGTH,
							SCSICmdField1Byte 			CONTROL );

   	virtual bool		PERSISTENT_RESERVE_OUT (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
	   						SCSICmdField5Bit 			SERVICE_ACTION,
	   						SCSICmdField4Bit 			SCOPE,
	   						SCSICmdField4Bit 			TYPE,
							SCSICmdField1Byte 			CONTROL );
	
#endif /* !TARGET_OS_EMBEDDED */

	virtual bool		PREVENT_ALLOW_MEDIUM_REMOVAL (
							SCSITaskIdentifier			request,
		 					SCSICmdField2Bit 			PREVENT, 
							SCSICmdField1Byte 			CONTROL );
	
#if !TARGET_OS_EMBEDDED
	
	virtual bool		READ_BUFFER (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField4Bit 			MODE,
							SCSICmdField1Byte 			BUFFER_ID,
							SCSICmdField3Byte 			BUFFER_OFFSET,
							SCSICmdField3Byte 			ALLOCATION_LENGTH, 
							SCSICmdField1Byte 			CONTROL );

	virtual bool		RECEIVE (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
		 					SCSICmdField3Byte 			TRANSFER_LENGTH,
							SCSICmdField1Byte 			CONTROL );

	virtual bool		RECEIVE_DIAGNOSTICS_RESULTS (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
		 					SCSICmdField1Bit 			PCV,
		 					SCSICmdField1Byte			PAGE_CODE,
		 					SCSICmdField2Byte 			ALLOCATION_LENGTH,
							SCSICmdField1Byte 			CONTROL );

	virtual bool		RELEASE_6 (
							SCSITaskIdentifier			request,
							SCSICmdField1Byte 			CONTROL );
	
	virtual bool		RELEASE_10 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			THRDPTY,
							SCSICmdField1Bit 			LONGID,
							SCSICmdField1Byte 			THIRD_PARTY_DEVICE_ID,
							SCSICmdField2Byte 			PARAMETER_LIST_LENGTH,
							SCSICmdField1Byte 			CONTROL );
	
	virtual bool		REPORT_DEVICE_IDENTIFIER ( 
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField4Byte 			ALLOCATION_LENGTH,
							SCSICmdField1Byte 			CONTROL );
	
#endif /* !TARGET_OS_EMBEDDED */

   	virtual bool		REPORT_LUNS ( 
							SCSITaskIdentifier			request,
   							IOMemoryDescriptor *		dataBuffer,
				   			SCSICmdField4Byte 			ALLOCATION_LENGTH,
				   			SCSICmdField1Byte 			CONTROL );
	
	virtual bool		REQUEST_SENSE (
							SCSITaskIdentifier			request,
   							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Byte 			ALLOCATION_LENGTH, 
							SCSICmdField1Byte 			CONTROL );
 	
#if !TARGET_OS_EMBEDDED
	
 	virtual bool		RESERVE_6 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Byte 			CONTROL );
	
	virtual bool		RESERVE_10 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			THRDPTY,
							SCSICmdField1Bit 			LONGID,
							SCSICmdField1Byte 			THIRD_PARTY_DEVICE_ID,
							SCSICmdField2Byte 			PARAMETER_LIST_LENGTH,
							SCSICmdField1Byte 			CONTROL );
	
	virtual bool		SEND (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit			AER,
		 					SCSICmdField3Byte 			TRANSFER_LENGTH,
							SCSICmdField1Byte 			CONTROL );

  	virtual bool		SEND_DIAGNOSTICS (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
				  		 	SCSICmdField3Bit 			SELF_TEST_CODE,
				  		 	SCSICmdField1Bit 			PF,
				  		 	SCSICmdField1Bit 			SELF_TEST,
				  		 	SCSICmdField1Bit 			DEVOFFL,
				  		 	SCSICmdField1Bit 			UNITOFFL,
				  	 		SCSICmdField2Byte 			PARAMETER_LIST_LENGTH,
				  	 		SCSICmdField1Byte 			CONTROL );
	
	virtual bool		SET_DEVICE_IDENTIFIER (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField5Bit 			SERVICE_ACTION,
							SCSICmdField4Byte 			PARAMETER_LIST_LENGTH,
							SCSICmdField1Byte 			CONTROL );
	
#endif /* !TARGET_OS_EMBEDDED */
	
	virtual bool		TEST_UNIT_READY (
							SCSITaskIdentifier			request,
							SCSICmdField1Byte 			CONTROL );
	
#if !TARGET_OS_EMBEDDED
 	
	virtual bool		WRITE_BUFFER (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField4Bit 			MODE,
							SCSICmdField1Byte 			BUFFER_ID,
							SCSICmdField3Byte 			BUFFER_OFFSET,
							SCSICmdField3Byte 			PARAMETER_LIST_LENGTH,
							SCSICmdField1Byte 			CONTROL );
	
#endif /* !TARGET_OS_EMBEDDED */
	
	// The SPC-3 INQUIRY command as defined in section 6.4.1 of SPC-3.
	bool				INQUIRY (
							SCSITaskIdentifier			request,
  							IOMemoryDescriptor *		dataBuffer,
    						SCSICmdField1Bit 			EVPD,
    						SCSICmdField1Byte 			PAGE_CODE,
    						SCSICmdField2Byte 			ALLOCATION_LENGTH,
    						SCSICmdField1Byte 			CONTROL );
	
    OSMetaClassDeclareReservedUsed ( IOSCSIPrimaryCommandsDevice,  1 );
    
    // ClampPowerState() will check if it is currently running behind the
    // workloop lock, if not, it will call itself again to run behind the
    // workloop gate.  When subclassing ClampPowerState() make sure to take
    // workloop synchronization in consideration.
    
    virtual void        ClampPowerState ( void );
    
    OSMetaClassDeclareReservedUsed ( IOSCSIPrimaryCommandsDevice,  2 );
    
    virtual void        ReleasePowerStateClamp ( void );
    
    
private:
	
	
#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  3 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  4 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  8 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice,  9 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 10 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 11 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 12 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSIPrimaryCommandsDevice, 16 );
#endif /* !TARGET_OS_EMBEDDED */
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_SCSI_PRIMARY_COMMANDS_DEVICE_H_ */
                                                                                                                                                                     IOSCSIProtocolInterface.h                                                                           0100644 0001750 0001750 00000111144 12567470660 037500  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_SCSI_PROTOCOL_INTERFACE_H_
#define _IOKIT_IO_SCSI_PROTOCOL_INTERFACE_H_


/*! @header SCSI Protocol Interface
	@discussion
	This file contains definitions for the IOSCSIProtocolInterface class,
	SCSI Protocol Features used by this interface, and additional constants
	used by this interface.
*/


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

#include <IOKit/storage/IOStorageDeviceCharacteristics.h>
#include <TargetConditionals.h>

//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

/*
SCSI Device Characteristics - Defined between SCSI Application Layer and
							  SCSI Protocol Layer only.
*/

/*!
@constant kIOPropertySCSIDeviceCharacteristicsKey
@discussion
This key is used to define SCSI Device Characteristics for a particular device.
It is the key for the dictionary containing the keys of characteristics. These keys
are only defined between the SCSI Protocol Layer and the SCSI Applicaiton Layer. Some
properties may be copied from this dictionary to the more generic Device Characteristics
or Protocol Characteristics dictionaries.
*/
#define kIOPropertySCSIDeviceCharacteristicsKey		"SCSI Device Characteristics"

/*!
@constant kIOPropertySCSIInquiryLengthKey
@discussion
This key is used to define a default INQUIRY length to issue to the device. The
value is a UInt32 corresponding to the number of bytes to request in the INQUIRY
command.
*/
#define kIOPropertySCSIInquiryLengthKey				"Inquiry Length"

/*!
@constant kIOPropertySCSIManualEjectKey
@discussion
This key is used to indicate that the device is known to be a manual ejectable media
device.  This property overrides all of the driver checks for determining this capability.
This property is a string, although if it exists it should always be true.
*/
#define kIOPropertySCSIManualEjectKey				"Manual Eject"

/*!
@constant kIOPropertyReadTimeOutDurationKey
@discussion
This key is used to define the Read Time Out for a particular device.
This property overrides all of the protocol defaults.
This property is a value, in milliseconds.
*/
#define kIOPropertyReadTimeOutDurationKey			"Read Time Out Duration"

/*!
@constant kIOPropertyWriteTimeOutDurationKey
@discussion
This key is used to define the Write Time Out for a particular device.
This property overrides all of the protocol defaults.
This property is a value, in milliseconds.
*/
#define kIOPropertyWriteTimeOutDurationKey			"Write Time Out Duration"

/*!
@constant kIOPropertyRetryCountKey
@discussion
This key is used to define the number of Read/Write retries for a particular device.
This property overrides all of the protocol defaults.
The value is a UInt32 corresponding to the number of retries.
*/
#define kIOPropertyRetryCountKey					"Retry Count"

/*!
 @constant kIOPropertyAutonomousSpinDownKey
 @discussion
 This key is used to indicate that the device is known to have its own internal logic
 for idle disk spin down. This key is used to mark device which respond poorly to our
 efforts to manually spin down or spin up the device when it is already in the desired 
 state. 
 */
#define kIOPropertyAutonomousSpinDownKey			"Autonomous Spin Down"

/*!
 @constant kIOPropertyDoNotPreventMediumRemovalKey
 @discussion
 This key is used to indicate that the device either does not require or respond
 well to PREVENT_ALLOW_MEDIUM_REMOVAL. This property indicates that the 
 PREVENT_ALLOW_MEDIUM_REMOVAL should not be used with the specified device.
 */
#define kIOPropertyDoNotPreventMediumRemovalKey     "Do Not Prevent Medium Removal"

/*!
 @constant kIOPropertyEjectRequireStartStopUnitKey
 @discussion
 This key is used to indicate that while the device may have failed PREVENT_ALLOW_MEDIUM
 REMOVAL it still requires a START_STOP_UNIT to eject/unload media. 
 */
#define kIOPropertyEjectRequireStartStopUnitKey		"Eject Requires START_STOP_UNIT"

/*!
 @constant kIOPropertyRequiresRestartEjectKey
 @discussion
 This key is used to indicate that the device requires a START_STOP_UNIT to eject
 the device's media prior to restarting to ensuring proper function at next boot cycle.
 */
#define kIOPropertyRequiresRestartEjectKey          "Require Restart Eject"

#if defined(KERNEL) && defined(__cplusplus)


/*!
@constant kCFBundleIdentifierKey
@discussion
Property key for CFBundleIdentifier.
*/
#define kCFBundleIdentifierKey					"CFBundleIdentifier"

/*!
@constant kIOSCSIArchitectureBundleIdentifierKey
@discussion
IOSCSIArchitectureModelFamily's CFBundle identifier.
*/
#define kIOSCSIArchitectureBundleIdentifierKey	"com.apple.iokit.IOSCSIArchitectureModelFamily"


// General kernel headers
#include <kern/thread.h>

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOService.h>
#include <IOKit/IOCommandGate.h>
#include <IOKit/IOWorkLoop.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/SCSITask.h>


/*!
@enum SCSI Protocol Interface Device Notification values
@discussion
Message values for SCSI Protocol Interface Device Notifications.
@constant kSCSIProtocolNotification_DeviceRemoved
Private message sent between a SCSI protocol service provider and
SCSI application layer driver to indicate device removal.
@constant kSCSIProtocolNotification_VerifyDeviceState
Private message sent between a SCSI protocol service provider and
SCSI application layer driver to indicate device state may have
changed and the device state should be re-verified by the SCSI
Application Layer driver. An example would be a bus reset which clears
the tray locking state of an ATAPI device.
@constant kSCSIServicesNotification_ExclusivityChanged
Message sent when a change in exclusivity state occurs. Usually in
response to acquiring/releasing exclusive access to a device via a user client.
*/
enum
{
	kSCSIProtocolNotification_DeviceRemoved			= 0x69000010,
	kSCSIProtocolNotification_VerifyDeviceState		= 0x69000020,
	kSCSIServicesNotification_ExclusivityChanged	= 0x69000030
};


/*!
@typedef SCSIProtocolFeature
@discussion
Typedef for SCSIProtocolFeature, a 32-bit quantity.
*/
typedef UInt32 SCSIProtocolFeature;

/*!
@enum SCSI Protocol Features
@discussion
The list of SCSI Protocol Features currently supported.
*/
enum
{
	
	/*!
	@constant kSCSIProtocolFeature_ACA Not yet used.
	*/
	kSCSIProtocolFeature_ACA								= 1,
	
	/*!
	@constant kSCSIProtocolFeature_CPUInDiskMode Used to determine
	if the SCSI Protocol Services Driver supports a CPU which is in
	target disk mode.
	*/
	kSCSIProtocolFeature_CPUInDiskMode						= 2,
	
	/*!
	@constant kSCSIProtocolFeature_ProtocolSpecificPolling Used
	to determine if the SCSI Protocol Services Driver supports
	protocol specific polling for media. This is used for low-power
	polling specifically for ATAPI devices on ATA buses
	*/
	kSCSIProtocolFeature_ProtocolSpecificPolling			= 3,
	
	/*!
	@constant kSCSIProtocolFeature_ProtocolSpecificSleepCommand Used
	to determine if the SCSI Protocol Services Driver supports
	protocol specific sleep commands to a drive. This is used for
	sleeping drives specifically ATAPI devices on ATA buses.
	*/
	kSCSIProtocolFeature_ProtocolSpecificSleepCommand		= 4,
	
	/*!
	@constant kSCSIProtocolFeature_GetMaximumLogicalUnitNumber If
	the SCSI Protocol Services Driver supports logical units, it will
	report the maximum addressable ID that it supports in the UInt32 pointer
	that is passed in as the serviceValue. If only one unit is supported,
	the driver should return false for this query.
	*/
	kSCSIProtocolFeature_GetMaximumLogicalUnitNumber		= 5,
	
	/*!
	@constant kSCSIProtocolFeature_MaximumReadBlockTransferCount If
	the SCSI Protocol Services Driver has a maximum number of
	blocks that can be transfered in a read request, it will return
	true to this query and return the block count in the UInt32 pointer
	that is passed in as the serviceValue.
	*/
	kSCSIProtocolFeature_MaximumReadBlockTransferCount		= 6,

	/*!
	@constant kSCSIProtocolFeature_MaximumWriteBlockTransferCount If
	the SCSI Protocol Services Driver has a maximum number of
	blocks that can be transferred in a write request, it will return
	true to this query and return the block count in the UInt32 pointer
	that is passed in as the serviceValue.
	*/
	kSCSIProtocolFeature_MaximumWriteBlockTransferCount		= 7,

	/*!
	@constant kSCSIProtocolFeature_MaximumReadTransferByteCount If
	the SCSI Protocol Services Driver has a maximum byte count
	that can be transferred in a read request, it will return
	true to this query and return the byte count in the UInt64 pointer
	that is passed in as the serviceValue.
	*/
	kSCSIProtocolFeature_MaximumReadTransferByteCount		= 8,

	/*!
	@constant kSCSIProtocolFeature_MaximumWriteTransferByteCount If
	the SCSI Protocol Services Driver has a maximum byte count
	that can be transferred in a write request, it will return
	true to this query and return the byte count in the UInt64 pointer
	that is passed in as the serviceValue.
	*/
	kSCSIProtocolFeature_MaximumWriteTransferByteCount		= 9,
	
	/*!
	@constant kSCSIProtocolFeature_SubmitDefaultInquiryData If
	the SCSI Protocol Services Driver needs any extra information to
	make any negotiation settings from the standard INQUIRY data, this 
	will be called to set that appropriately. The serviceValue will
	point to a SCSICmd_INQUIRY_StandardData buffer. The size
	of the buffer depends on the SCSI Device Characteristics
	dictionary for the device or bus. If there is no
	kIOPropertySCSIInquiryLengthKey value set in the dictionary
	or if it doesn't exist, then the size of the data will be
	the size of the full amount of Inquiry retrieved from the device.
	*/
	kSCSIProtocolFeature_SubmitDefaultInquiryData			= 10,
	
	/*!
	@constant kSCSIProtocolFeature_ProtocolAlwaysReportsAutosenseData If
	the SCSI Protocol Services Driver always reports available
	autosense data when a kSCSITaskStatus_CHECK_CONDITION is set,
	then the protocol layer should return true. E.g. FireWire
	transport drivers should respond true to this.
	*/
	kSCSIProtocolFeature_ProtocolAlwaysReportsAutosenseData	= 11,
	
	/*!
	@constant kSCSIProtocolFeature_ProtocolSpecificPowerOff If
	the SCSI Protocol Services Driver supports removing the power
	to the drive, then the protocol layer should return true. This is
	used for aggressive power management, specifically for ATAPI
	devices on ATA buses.
	*/
	kSCSIProtocolFeature_ProtocolSpecificPowerOff			= 12,
	
	/*!
	@constant kSCSIProtocolFeature_ProtocolSpecificPowerControl
	Used to determine if the SCSI Protocol Services Driver supports
	switching the power to the drive on and off. This is used for aggressive
	power management, specifically for SATAPI devices on AHCI buses.
	*/
	kSCSIProtocolFeature_ProtocolSpecificPowerControl		= 13,
	
	/*!
	@constant kSCSIProtocolFeature_ProtocolSpecificAsyncNotification
	Used to determine if the SCSI Protocol Services Driver supports
	asynchronous notifications from the drive. This is used to prevent
	polling for media, specifically for SATAPI devices on AHCI buses.
	*/
	kSCSIProtocolFeature_ProtocolSpecificAsyncNotification	= 14,
	
	/*!
	kSCSIProtocolFeature_HierarchicalLogicalUnits:
	If the SCSI Protocol Services layer supports hierarchical
	logical units, then the protocol services layer should report true
	and use IOSCSIProtocolServices::GetLogicalUnitBytes() to retrieve
	the full 8 bytes of LUN information.
	*/
	kSCSIProtocolFeature_HierarchicalLogicalUnits			= 15,
	
	/*!
	kSCSIProtocolFeature_MultiPathing:
	If the SCSI Protocol Services layer supports multi-pathing,
	then the protocol services layer should report true. 
	This is used to support multiple paths to a logical unit
	by creating a IOSCSIMultipathedLogicalUnit object.
	*/
	kSCSIProtocolFeature_MultiPathing						= 16
	
};


/*!
@typedef SCSIProtocolPowerState
@discussion
Typedef for SCSIProtocolPowerState, a 32-bit quantity.
*/
typedef UInt32 SCSIProtocolPowerState;

/*!
@enum SCSI Protocol Power States
@discussion
The list of SCSI Protocol Power States.
*/
enum
{
	/*!
	@constant kSCSIProtocolPowerStateOff
	Off power state.
	*/
	kSCSIProtocolPowerStateOff			= 0,

	/*!
	@constant kSCSIProtocolPowerStateOn
	On power state.
	*/
	kSCSIProtocolPowerStateOn			= 1
};


//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

/*!
@class IOSCSIProtocolInterface
@superclass IOService
@discussion
This class defines the public SCSI Protocol Layer API for any class that
provides Protocol services or needs to provide the Protocol Service API
for passing service requests to a Protocol Service driver.
*/
class IOSCSIProtocolInterface : public IOService
{
	
	OSDeclareAbstractStructors ( IOSCSIProtocolInterface )
	
public:
	
	/*!
	@function start
	@abstract During an IOService object's instantiation, starts the IOService object that has been selected to run on the provider.
	@discussion See IOService.h for details.
	@result <code>true</code> if the start was successful; <code>false</code> otherwise (which will cause the instance to be detached and usually freed).
	*/
	virtual bool	start ( IOService * provider );
	
	/*!
	@function free
	@abstract Called to release all resources held by the object.
	@discussion Release all resources held by the object, then call super::free().  
	*/	
	virtual void	free ( void );

	/*!
	@function willTerminate
	@abstract Passes a termination up the stack.
	@discussion Notification that a provider has been terminated, sent before recursing up the stack, in root-to-leaf order.
	@param provider The terminated provider of this object.
	@param options Options originally passed to terminate().
	@result <code>true</code>.
	*/
	virtual bool	willTerminate ( IOService * provider, IOOptionBits options );

	/*!
	@function GetUserClientExclusivityState
	@abstract Gets the current exclusivity state of the user client.
	@discussion The GetUserClientExclusivityState() method is called by the SCSITaskUserClient
	to determine if any user client is holding exclusive access at the current time. This is simply
	a preflight check and a return value of <code>false</code> does not guarantee that a subsequent
	call to SetUserClientExclusivityState() will return successfully.
	@result <code>true</code> if a user client is in exclusive control of the device, <code>false</code> otherwise.
	*/
	virtual bool 		GetUserClientExclusivityState ( void );
	
	/*!
	@function SetUserClientExclusivityState
	@abstract Sets the current exclusivity state of the user client.
	@discussion The SetUserClientExclusivityState() method is called by the SCSITaskUserClient
	to set the exclusive access mode.
	@param userClient The instance of SCSITaskUserClient for which to change exclusivity state.
	@param state Exclusivity state. <code>true</code> means exclusive access is desired, <code>false</code>
	means exclusive access is being released.
	@result A valid IOReturn code indicating success or the type of failure.
	*/
	virtual IOReturn	SetUserClientExclusivityState ( IOService * userClient, bool state );
	
	
	/*!
	@function initialPowerStateForDomainState
	@abstract Determines which power state a device is in, given the current power domain state.
	@discussion Power management calls this method once, when the driver is initializing power management.
	Subclasses should not need to override this method.
	@param flags Flags that describe the character of "domain power"; they represent the <code>outputPowerCharacter</code> field of a state in the power domain's power state array. 
	@result A state number. 
	*/
	virtual unsigned long	initialPowerStateForDomainState ( IOPMPowerFlags flags );
	
	/*!
	@function setPowerState
	@abstract Requests a power managed driver to change the power state of its device.
	@discussion Requests a power managed driver to change the power state of its device. Most subclasses
	of IOSCSIProtocolInterface have class-specific mechanisms and should not override this routine.
	See IOSCSIProtocolServices.h, IOSCSIBlockCommandsDevice.h, IOSCSIReducedBlockCommandsDevice.h, and
	IOSCSIMultimediaCommandsDevice.h for more information about power management changes.
	Subclasses should not need to override this method.
	@param powerStateOrdinal The number in the power state array to which the drive is being instructed to change.
	@param whichDevice A pointer to the power management object which registered to manage power for this device.
	The whichDevice field is not pertinent to us since the driver is both the "policy maker" for the device,
	and the "policy implementor" for the device.
	@result See IOService.h for details.
	*/
	virtual IOReturn 	setPowerState ( unsigned long powerStateOrdinal, IOService * whichDevice );
	
	/*!
	@function IsPowerManagementIntialized
	@abstract Called to determine if power management is initialized.
	@discussion Called to determine if power management is initialized.
	Subclasses should not need to override this method.
	@result <code>true</code> if power management has been initialized, <code>false</code> otherwise.
	*/
	virtual bool		IsPowerManagementIntialized ( void );
	
	/*!
	@function CheckPowerState
	@abstract Called by clients to ensure device is in correct power state before issuing I/O.
	@discussion Called by clients to ensure device is in correct power state before issuing I/O.
	If the device is not ready to handle such requests, it gives the driver a chance to block the
	thread until the device is ready. Subclasses should not need to override this method.
	*/
	virtual void 		CheckPowerState ( void );
	
	/*!
	@function ExecuteCommand
	@abstract Called to send a SCSITask and transport it across the physical wire(s) to the device.
	@discussion Called to send a SCSITask and transport it across the physical wire(s) to the device.
	Subclasses internal to IOSCSIArchitectureModelFamily will need to override this method. Third
	party subclasses should not need to override this method.
	@param request A valid SCSITaskIdentifier representing the task to transport across the wire(s).
	*/
	virtual void		ExecuteCommand ( SCSITaskIdentifier request ) = 0;
	
	/*!
	@function AbortCommand
	@abstract Obsolete. Do not use this method.
	@discussion Obsolete. Do not use this method.
	*/
	virtual SCSIServiceResponse		AbortCommand ( SCSITaskIdentifier request ) = 0;
	
	/*!
	@function IsProtocolServiceSupported
	@abstract This method is called to query for support of a protocol specific service feature.
	@discussion This method is called to query for support of a protocol specific service feature.
	Subclasses of IOSCSIProtocolServices should override this method.
	@param feature A valid SCSIProtocolFeature. See enums for SCSIProtocolFeature.
	@param serviceValue A pointer to a structure/value that is used in conjunction with the feature
	requested. See enums for SCSIProtocolFeature. NB: This parameter may be NULL for certain
	feature requests.
	@result <code>true</code> if the feature is supported, <code>false</code> otherwise.
	*/
	virtual bool		IsProtocolServiceSupported ( 
								SCSIProtocolFeature 	feature, 
								void * 					serviceValue ) = 0;
	
	/*!
	@function HandleProtocolServiceFeature
	@abstract This method is called to enact support of a protocol specific service feature.
	@discussion This method is called to enact support of a protocol specific service feature.
	Subclasses of IOSCSIProtocolServices should override this method.
	@param feature A valid SCSIProtocolFeature. See enums for SCSIProtocolFeature.
	@param serviceValue A pointer to a structure/value that is used in conjunction with the feature
	requested. See enums for SCSIProtocolFeature. NB: This parameter may be NULL for certain
	feature requests.
	@result <code>true</code> if the service feature request succeeded, <code>false</code> otherwise.
	*/
	virtual bool		HandleProtocolServiceFeature ( 
								SCSIProtocolFeature 	feature, 
								void * 					serviceValue ) = 0;
	
protected:
	
	// Reserve space for future expansion.
	struct IOSCSIProtocolInterfaceExpansionData
	{
		IOWorkLoop *	fWorkLoop;
	};
	IOSCSIProtocolInterfaceExpansionData * fIOSCSIProtocolInterfaceReserved;
	
	// ------ Power Management Support ------
	
	thread_call_t		fPowerManagementThread;
	IOCommandGate *		fCommandGate;
	UInt32				fCurrentPowerState;
	UInt32				fProposedPowerState;
	bool				fPowerTransitionInProgress;
	bool				fPowerAckInProgress;
	bool				fPowerManagementInitialized;
	
	/*!
	@function GetCommandGate
	@abstract Accessor method to obtain the IOCommandGate.
	@discussion Accessor method to obtain the IOCommandGate.
	@result The IOCommandGate for this instance. May return NULL.
	*/
	IOCommandGate *		GetCommandGate ( void );
	
	/*!
	@function InitializePowerManagement
	@abstract This method is called to initialize power management.
	@discussion This method is called to initialize power management. It will call PMinit(), joinPMTree(),
	and makeUsable(). This method does not call registerPowerDriver().
	Subclasses may override this method to change the behavior (such as the number of power states).
	@param provider The power management provider (i.e. the provider to attach to in the PowerManagement
	tree). This may be a device that is not in the PM Tree itself, in which case, the IOService plane
	is traversed towards the root node in an effort to find a node in the PM Tree.
	*/
	virtual void		InitializePowerManagement ( IOService * provider );
	
	/*!
	@function GetInitialPowerState
	@abstract This method is called to obtain the initial power state of the device (usually the highest).
	@discussion This method is called to obtain the initial power state of the device (usually the highest).
	Subclasses must override this method.
	@result A power state ordinal.
	*/
	virtual UInt32		GetInitialPowerState ( void ) = 0;
	
	/*!
	@function finalize
	@abstract Finalizes the destruction of an IOService object.
	@discussion See IOService.h
	Subclasses may override this method, but should call super::finalize().
    @result <code>true</code>.
	*/
	virtual bool		finalize ( IOOptionBits options );
	
	/*!
	@function sHandleSetPowerState
	@abstract The sHandleSetPowerState method is a static function used as C->C++ glue
	for going behind the command gate.
	@discussion The sHandleSetPowerState method is a static function used as C->C++ glue
	for going behind the command gate.
	@param self The 'this' pointer for the class.
	@param powerStateOrdinal The power state to which device shall be changed.
    @result A valid IOReturn code indicating success or failure.
	*/
	static IOReturn 	sHandleSetPowerState ( IOSCSIProtocolInterface * self, UInt32 powerStateOrdinal );
	
	/*!
	@function sGetPowerTransistionInProgress
	@abstract The sGetPowerTransistionInProgress method is a static function used as C->C++ glue
	for going behind the command gate.
	@discussion The sGetPowerTransistionInProgress method is a static function used as C->C++ glue
	for going behind the command gate.
	@param self The 'this' pointer for the class.
    @result <code>true</code> if a power state is in progress, otherwise <code>false</code>.
	*/
	static bool sGetPowerTransistionInProgress ( IOSCSIProtocolInterface * 	self );
	
	/*!
	@function HandleSetPowerState
	@abstract The HandleSetPowerState method is called by the glue code and is on the
	serialized side of the command gate.
	@discussion The HandleSetPowerState method is called by the glue code and is on the
	serialized side of the command gate. This allows us to touch any member
	variables as necessary without any multi-threading issues.
	Subclasses may override this method to change behavior. Third party subclasses
	should not need to override this method, but may.
	@param powerStateOrdinal The power state to which device shall be changed.
	*/
	virtual void		HandleSetPowerState ( UInt32 powerStateOrdinal );
	
	/*!
	@function sPowerManagement
	@abstract The sPowerManagement method is a static C-function which is called using
	mach's thread_call API. It guarantees us a thread of execution which is
	different than the power management thread and the workloop thread on which
	we can issue commands to the device synchronously or asynchronously without
	worrying about deadlocks. It calls through to HandlePowerChange, which is
	a state machine used to direct power management.
	@discussion The sPowerManagement method is a static C-function which is called using
	mach's thread_call API. It guarantees us a thread of execution which is
	different than the power management thread and the workloop thread on which
	we can issue commands to the device synchronously or asynchronously without
	worrying about deadlocks. It calls through to HandlePowerChange, which is
	a state machine used to direct power management.
	@param whichDevice The 'this' pointer.
	*/
	static void			sPowerManagement ( thread_call_param_t whichDevice );
	
	/*!
	@function HandlePowerChange
	@abstract The HandlePowerChange method is pure virtual and is left to each protocol or
	application layer driver to implement. It is guaranteed to be called on its
	own thread of execution and can make synchronous or asynchronous calls.
	@discussion The HandlePowerChange method is pure virtual and is left to each protocol or
	application layer driver to implement. It is guaranteed to be called on its
	own thread of execution and can make synchronous or asynchronous calls.
	Subclasses must override this method. Third party subclasses shouldn't need to override
	this method but can to alter the default behavior.
	*/
	virtual void		HandlePowerChange ( void ) = 0;
		
	/*!
	@function sHandleCheckPowerState
	@abstract The sHandleCheckPowerState method is a static function used as C->C++ glue
	for going behind the command gate.
	@discussion The sHandleCheckPowerState method is a static function used as C->C++ glue
	for going behind the command gate.
	@param self The 'this' pointer for the class.
	*/
	static void			sHandleCheckPowerState ( IOSCSIProtocolInterface * self );
	
	/*!
	@function HandleCheckPowerState(void)
	@abstract The HandleCheckPowerState (void) method is on the serialized side of the command
	gate and can change member variables safely without multi-threading issues.
	It's main purpose is to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState )
	with the max power state the class registered with.
	@discussion The HandleCheckPowerState (void) method is on the serialized side of the command
	gate and can change member variables safely without multi-threading issues.
	It's main purpose is to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState )
	with the max power state the class registered with.
	Subclasses must override this method. Third party subclasses shouldn't need to override
	this method but can to alter the default behavior.
	*/
	virtual void		HandleCheckPowerState ( void ) = 0;
	
	/*!
	@function HandleCheckPowerState(UInt32 maxPowerState)
	@abstract The HandleCheckPowerState(UInt32 maxPowerState) method is called by
	the subclasses and is passed the maxPowerState number given to the power
	manager at initialization time. This guarantees the threads block until that
	power state has been achieved.
	@discussion The HandleCheckPowerState(UInt32 maxPowerState) method is called by
	the subclasses and is passed the maxPowerState number given to the power
	manager at initialization time. This guarantees the threads block until that
	power state has been achieved.
	@param maxPowerState The maximum power state in the power state array.
	*/
	void 				HandleCheckPowerState ( UInt32 maxPowerState );
	
	/*!
	@function TicklePowerManager(void)
	@abstract The TicklePowerManager(void) method is called by CheckPowerState and
	sends an activity tickle to the power manager so that the idle timer is
	reset.
	@discussion The TicklePowerManager(void) method is called by CheckPowerState and
	sends an activity tickle to the power manager so that the idle timer is
	reset.
	Subclasses must override this method. Third party subclasses shouldn't need to override
	this method but can to alter the default behavior.
	*/
	virtual void		TicklePowerManager ( void ) = 0;
	
	/*!
	@function TicklePowerManager(UInt32 maxPowerState)
	@abstract The TicklePowerManager(UInt32 maxPowerState) method is a convenience
	function which can be called by subclasses in TicklePowerManager (void)
	in order to tell the power manager to reset idle timer or bring the device
	into the requested state. It returns whatever is returned by activityTickle
	(true if device is in the requested state, false if it is not).
	@discussion The TicklePowerManager(UInt32 maxPowerState) method is a convenience
	function which can be called by subclasses in TicklePowerManager(void)
	in order to tell the power manager to reset idle timer or bring the device
	into the requested state. It returns whatever is returned by activityTickle
	(true if device is in the requested state, false if it is not).
	@param maxPowerState The maximum power state in the power state array.
	@result The result of the call to activityTickle(). See IOService.h for details.
	*/
	bool				TicklePowerManager ( UInt32 maxPowerState );
	
	// ------ User Client Support ------
	
	bool				fUserClientExclusiveControlled;
	IOService *			fUserClient;
	
	/*!
	@function sGetUserClientExclusivityState
	@abstract The sGetUserClientExclusivityState method is a static function used as C->C++ glue
	for going behind the command gate.
	@discussion The sGetUserClientExclusivityState method is a static function used as C->C++ glue
	for going behind the command gate.
	@param self The 'this' pointer for the class.
	@param state A pointer to a bool in which the state should be set.
	*/
	static void 	sGetUserClientExclusivityState ( IOSCSIProtocolInterface * self, bool * state );
	
	/*!
	@function sSetUserClientExclusivityState
	@abstract The sSetUserClientExclusivityState method is a static function used as C->C++ glue
	for going behind the command gate.
	@discussion The sSetUserClientExclusivityState method is a static function used as C->C++ glue
	for going behind the command gate.
	@param self The 'this' pointer for the class.
	@param result A pointer to an IOReturn for the resulting status.
	@param userClient The instance of SCSITaskUserClient for which to change exclusivity state.
	@param state A bool indicating the desired state to set.
	*/
	static void		sSetUserClientExclusivityState ( IOSCSIProtocolInterface * self, IOReturn * result, IOService * userClient, bool state );

	/*!
	@function HandleGetUserClientExclusivityState
	@abstract Gets the current exclusivity state of the user client.
	@discussion The HandleGetUserClientExclusivityState() method is called on the serialized side
	of the command gate to determine if any user client is holding exclusive access at the current
	time. See discussion for GetUserClientExclusivityState().
	Subclasses may override this method to alter default behavior. Third party subclasses should
	not need to override this method.
	@result <code>true</code> if a user client is in exclusive control of the device, <code>false</code> otherwise.
	*/
	virtual bool	HandleGetUserClientExclusivityState ( void );

	/*!
	@function HandleSetUserClientExclusivityState
	@abstract Sets the current exclusivity state of the user client.
	@discussion The HandleSetUserClientExclusivityState() method is called on the serialized side
	of the command gate to set the exclusive access mode.
	@param userClient The instance of SCSITaskUserClient for which to change exclusivity state.
	@param state Exclusivity state. <code>true</code> means exclusive access is desired, <code>false</code>
	means exclusive access is being released.
	@result A valid IOReturn code indicating success or the type of failure.
	*/
	virtual IOReturn	HandleSetUserClientExclusivityState ( IOService * userClient, bool state );
	
public:
	
	// ------- SCSI Architecture Model Task Management Functions ------

	OSMetaClassDeclareReservedUsed ( IOSCSIProtocolInterface, 1 );
	/*!
	@function AbortTask
	@abstract Aborts a task based on the Logical Unit and tagged task identifier.
	@discussion Aborts a task based on the Logical Unit and tagged task identifier.
	Subclasses must override this method. Third party subclasses should not need to override
	this method.
	@param theLogicalUnit This value should be zero unless the device driver is
	more complex and managing multiple Logical Units.
	@param theTag A valid SCSITaggedTaskIdentifier representing an outstanding SCSITask.
	@result A valid SCSIServiceResponse code.
	*/
	virtual SCSIServiceResponse		AbortTask ( UInt8 theLogicalUnit, SCSITaggedTaskIdentifier theTag ) = 0;
	
	OSMetaClassDeclareReservedUsed ( IOSCSIProtocolInterface, 2 );
	/*!
	@function AbortTaskSet
	@abstract Aborts a task set based on the Logical Unit.
	@discussion Aborts a task set based on the Logical Unit.
	Subclasses must override this method. Third party subclasses should not need to override
	this method.
	@param theLogicalUnit This value should be zero unless the device driver is
	more complex and managing multiple Logical Units.
	@result A valid SCSIServiceResponse code.
	*/
	virtual SCSIServiceResponse		AbortTaskSet ( UInt8 theLogicalUnit ) = 0;
	
	OSMetaClassDeclareReservedUsed ( IOSCSIProtocolInterface, 3 );
	/*!
	@function ClearACA
	@abstract Clears an Auto-Contingent Allegiance (ACA) for the specified Logical Unit.
	@discussion Clears an Auto-Contingent Allegiance (ACA) for the specified Logical Unit.
	Subclasses must override this method. Third party subclasses should not need to override
	this method.
	@param theLogicalUnit This value should be zero unless the device driver is
	more complex and managing multiple Logical Units.
	@result A valid SCSIServiceResponse code.
	*/
	virtual SCSIServiceResponse		ClearACA ( UInt8 theLogicalUnit ) = 0;
	
	OSMetaClassDeclareReservedUsed ( IOSCSIProtocolInterface, 4 );
	/*!
	@function ClearTaskSet
	@abstract Clears a task set for the specified Logical Unit.
	@discussion Clears a task set for the specified Logical Unit.
	Subclasses must override this method. Third party subclasses should not need to override
	this method.
	@param theLogicalUnit This value should be zero unless the device driver is
	more complex and managing multiple Logical Units.
	@result A valid SCSIServiceResponse code.
	*/
	virtual SCSIServiceResponse		ClearTaskSet ( UInt8 theLogicalUnit ) = 0;
	
	OSMetaClassDeclareReservedUsed ( IOSCSIProtocolInterface, 5 );
	/*!
	@function LogicalUnitReset
	@abstract Resets the specified Logical Unit.
	@discussion Resets the specified Logical Unit.
	Subclasses must override this method. Third party subclasses should not need to override
	this method.
	@param theLogicalUnit This value should be zero unless the device driver is
	more complex and managing multiple Logical Units.
	@result A valid SCSIServiceResponse code.
	*/
	virtual SCSIServiceResponse		LogicalUnitReset ( UInt8 theLogicalUnit ) = 0;
	
	OSMetaClassDeclareReservedUsed ( IOSCSIProtocolInterface, 6 );
	
	/*!
	@function TargetReset
	@abstract Resets the target device.
	@discussion Resets the target device.
	Subclasses must override this method. Third party subclasses should not need to override
	this method.
	@result A valid SCSIServiceResponse code.
	*/
	virtual SCSIServiceResponse		TargetReset ( void ) = 0;
	
private:
	
	// Method to show that the disk spinning up in spindump stacks
	void							__DISK_IS_ASLEEP__ ( void ) __attribute__((noinline));

#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface,  7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface,  8 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface,  9 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 10 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 11 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 12 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSIProtocolInterface, 16 );
#endif /* !TARGET_OS_EMBEDDED */
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_SCSI_PROTOCOL_INTERFACE_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                            IOSCSIProtocolServices.h                                                                            0100644 0001750 0001750 00000101067 12567470660 037366  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_PROTOCOL_SERVICES_H_
#define _IOKIT_IO_SCSI_PROTOCOL_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// Mach includes
#include <kern/queue.h>

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOCommandGate.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/SCSITask.h>
#include <IOKit/scsi/IOSCSIProtocolInterface.h>
#include <IOKit/scsi/SCSICmds_REQUEST_SENSE_Defs.h>

// Build includes
#include <TargetConditionals.h>


//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

// Power Management values
enum
{
	kSCSIProtocolLayerPowerStateOff				= 0,
	kSCSIProtocolLayerPowerStateOn				= 1,
	kSCSIProtocolLayerNumDefaultStates			= 2
};

// Forward definitions of internal use only classes
class SCSITask;

//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

/*!
 @class IOSCSIProtocolServices
 @superclass IOSCSIProtocolInterface
 @discussion
 This class defines the public SCSI Protocol Services Layer API for any class
 that implements SCSI protocol services. A protocol services layer driver is
 responsible for taking incoming SCSITaskIdentifier objects and translating
 them to the native command type for the native protocol interface
 (e.g. SBP-2 ORB on FireWire).
 */
class IOSCSIProtocolServices : public IOSCSIProtocolInterface
{
	
	OSDeclareAbstractStructors ( IOSCSIProtocolServices )
	
private:
	
	// The head pointer for the queue of waiting SCSI Tasks.
	SCSITask *		fSCSITaskQueueHead;		/* OBSOLETE */
	
	// This is the lock for preventing multiple access while
	// manipulating the SCSI Task queue.
	IOSimpleLock *	fQueueLock;
	
	// The internal flag to indicate whether service requests should be
	// executed or immediately errored, such as when a device is removed.
	bool			fAllowServiceRequests;
	
protected:
	
	// Reserve space for future expansion.
	struct IOSCSIProtocolServicesExpansionData
	{
		// For internal use only. Do not use.
		UInt32				fSemaphore;
		bool				fRequiresAutosenseDescriptor;
		SCSITaskCompletion	fCompletionRoutine;
		queue_head_t		fTaskQueueHead;
		queue_head_t		fAutoSenseQueueHead;
	};
	IOSCSIProtocolServicesExpansionData * fIOSCSIProtocolServicesReserved;
			
	/*!
	@function SendSCSICommand
	@abstract Pure virtual method subclasses must implement in order to send SCSITasks on the wire.
	@discussion Send a SCSI Command to the device.  If the command was sent to the
	device and is pending completion, the subclass should return true and
	return back the kSCSIServiceResponse_Request_In_Process response. 
	If the command completes immediately with an error, the subclass will
	return true and return back the appropriate status.
	If the subclass is currently processing all the commands it can, the
	subclass will return false and the command will be resent next time
	CommandCompleted is called.
	@param request A valid SCSITaskIdentifier representing the command to send on the wire.
	@param serviceResponse Pointer to a SCSIServiceResponse value returned to the caller.
	@param taskStatus Pointer to a SCSITaskStatus value returned to the caller.
	@result False if no more commands can be processed at this time, otherwise true.
	*/
	virtual bool	SendSCSICommand ( 	SCSITaskIdentifier 		request, 
										SCSIServiceResponse *	serviceResponse,
										SCSITaskStatus *		taskStatus ) = 0;
	
	/*!
	@function AbortSCSICommand
	@abstract Pure virtual method subclasses must implement so that SCSITasks may be aborted.
	@discussion Provides the capability for a caller to request that a particular SCSITask
	be aborted.
	@param request A valid SCSITaskIdentifier representing the command to be aborted.
	@result A valid SCSIServiceResponse.
	*/
	virtual SCSIServiceResponse	AbortSCSICommand ( SCSITaskIdentifier request ) = 0;
	
	/*!
	@function CommandCompleted
	@abstract Method subclass calls to complete a SCSITask.
	@discussion Subclasses will call this inherited method when the command
	executed by SendSCSICommand has completed.
	@param request A valid SCSITaskIdentifier indicating the request to complete.
	@param serviceResponse A valid SCSIServiceResponse value.
	@param taskStatus A valid SCSITaskStatus value.
	*/
	void	CommandCompleted ( 	SCSITaskIdentifier 	request, 
								SCSIServiceResponse serviceResponse,
								SCSITaskStatus		taskStatus );
	
	/*!
	@function GetTaskAttribute
	@abstract Accessor method to retrieve the SCSITaskAttribute associated with the specified request.
	@discussion Accessor method to retrieve the SCSITaskAttribute associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result A valid SCSITaskAttribute value.
	*/
	SCSITaskAttribute	GetTaskAttribute ( SCSITaskIdentifier request );
	
	/*!
	@function SetTaskState
	@abstract Accessor method to set the SCSITaskState associated with the specified request.
	@discussion Accessor method to set the SCSITaskState associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@param newTaskState A valid SCSITaskState value.
	@result True on success, otherwise false.
	*/
	bool			SetTaskState ( 	SCSITaskIdentifier request, 
									SCSITaskState newTaskState );
	/*!
	@function GetTaskState
	@abstract Accessor method to retrieve the SCSITaskState associated with the specified request.
	@discussion Accessor method to retrieve the SCSITaskState associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result A valid SCSITaskState value.
	*/
	SCSITaskState	GetTaskState ( 	SCSITaskIdentifier request );
	
	/*!
	@function GetLogicalUnitNumber
	@abstract Accessor method to retrieve the logical unit number associated with the specified request.
	@discussion Accessor method to retrieve the logical unit number associated with the specified request.
	NOTE: This method is deprecated in favor of GetLogicalUnitBytes().
	@param request A valid SCSITaskIdentifier.
	@result A valid single-byte LUN value.
	*/
	UInt8	GetLogicalUnitNumber ( SCSITaskIdentifier request );

	/*!
	@function GetLogicalUnitBytes
	@abstract Accessor method to retrieve the logical unit bytes associated with the specified request.
	@discussion Accessor method to retrieve the logical unit bytes associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@param lunBytes A pointer to SCSILogicalUnitBytes to be filled in by this method.
	*/
	void	GetLogicalUnitBytes ( SCSITaskIdentifier request, SCSILogicalUnitBytes * lunBytes );
	
	/*!
	@function GetCommandDescriptorBlockSize
	@abstract Accessor method to retrieve the Command Descriptor Block size associated with the specified request.
	@discussion Accessor method to retrieve the Command Descriptor Block size associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result A valid CDB size (e.g. 6, 10, 12, or 16 bytes).
	*/
	UInt8	GetCommandDescriptorBlockSize ( SCSITaskIdentifier request );
	
	/*!
	@function GetCommandDescriptorBlock
	@abstract Accessor method to retrieve the Command Descriptor Block associated with the specified request.
	@discussion Accessor method to retrieve the Command Descriptor Block associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@param cdbData A pointer to SCSICommandDescriptorBlock to be filled in by this method.
	NOTE: This routine will always fill in 16 bytes, so if the protocol layer driver supports less than this amount
	it will have to create a local SCSICommandDescriptorBlock variable to get the CDB data.
	@result True on success, otherwise false.
	*/
	bool	GetCommandDescriptorBlock ( SCSITaskIdentifier 				request, 
										SCSICommandDescriptorBlock * 	cdbData );
	
	/*!
	@function GetDataTransferDirection
	@abstract Accessor method to retrieve the data transfer direction associated with the specified request.
	@discussion Accessor method to retrieve the data transfer direction associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result The data transfer direction (e.g. kSCSIDataTransfer_NoDataTransfer).
	*/
	UInt8	GetDataTransferDirection ( SCSITaskIdentifier request );
	
	/*!
	@function GetRequestedDataTransferCount
	@abstract Accessor method to retrieve the requested data transfer count associated with the specified request.
	@discussion Accessor method to retrieve the requested data transfer count associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result The requested data transfer count.
	*/
	UInt64	GetRequestedDataTransferCount ( SCSITaskIdentifier request );
	
	/*!
	@function SetRealizedDataTransferCount
	@abstract Accessor method to set the realized (actual) data transfer count associated with the specified request.
	@discussion Accessor method to set the realized (actual) data transfer count associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@param newRealizedDataCount The realized (actual) data count transferred.
	@result True on success, otherwise false.   
	*/
	bool	SetRealizedDataTransferCount ( SCSITaskIdentifier request,
										   UInt64 newRealizedDataCount );
	
	/*!
	@function GetRealizedDataTransferCount
	@abstract Accessor method to retrieve the realized data transfer count associated with the specified request.
	@discussion Accessor method to retrieve the realized data transfer count associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result The realized data transfer count.
	*/
	UInt64	GetRealizedDataTransferCount ( SCSITaskIdentifier request );
	
	/*!
	@function GetDataBuffer
	@abstract Accessor method to retrieve the data buffer associated with the specified request.
	@discussion Accessor method to retrieve the data buffer associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result An IOMemoryDescriptor associated with the request. May be NULL if data transfer
	direction is kSCSIDataTransfer_NoDataTransfer.
	*/
	IOMemoryDescriptor *	GetDataBuffer ( SCSITaskIdentifier request );
	
	/*!
	@function GetDataBufferOffset
	@abstract Accessor method to retrieve the data buffer offset associated with the specified request.
	@discussion Accessor method to retrieve the data buffer offset associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result Offset into the data buffer at which to start the transfer of data.
	*/
	UInt64	GetDataBufferOffset ( SCSITaskIdentifier request );
	
	/*!
	@function GetTimeoutDuration
	@abstract Accessor method to retrieve the timeout duration in milliseconds associated with the specified request.
	@discussion Accessor method to retrieve the timeout duration in milliseconds associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result Timeout duration in milliseconds.
	*/
	UInt32	GetTimeoutDuration ( SCSITaskIdentifier request );
	
	/*!
	@function GetAutosenseRequestedDataTransferCount
	@abstract Accessor method to retrieve the requested data transfer count for autosense data
	associated with the specified request.
	@discussion Accessor method to retrieve the requested data transfer count for autosense data
	associated with the specified request.
	@param request A valid SCSITaskIdentifier.
	@result The requested autosense data transfer count.
	*/
	UInt64	GetAutosenseRequestedDataTransferCount ( SCSITaskIdentifier	request );
	
	/*!
	@function SetAutoSenseData
	@abstract Accessor method to set the autosense data. NOTE: This method is deprecated.
	@discussion Accessor method to set the autosense data. NOTE: This method is deprecated.
	@param request A valid SCSITaskIdentifier.
	@param senseData A pointer to a SCSI_Sense_Data structure to be copied. Only
	sizeof(struct SCSI_Sense_Data) bytes will be copied.
	@result True if sense data was successfully copied, otherwise false.
	*/
	bool	SetAutoSenseData ( SCSITaskIdentifier	request,
							   SCSI_Sense_Data *	senseData ) __attribute__ ((deprecated));
	
	/*!
	@function SetAutoSenseData
	@abstract Accessor method to set the autosense data.
	@discussion Accessor method to set the autosense data.
	@param request A valid SCSITaskIdentifier.
	@param senseData A pointer to sense data to be copied.
	@param senseDataSize Number of bytes to copy.
	@result True if sense data was successfully copied, otherwise false.
	*/
	bool	SetAutoSenseData ( SCSITaskIdentifier	request,
							   SCSI_Sense_Data *	senseData,
							   UInt8				senseDataSize );
	
	/*!
	@function EnsureAutosenseDescriptorExists
	@abstract Internal method, not to be called by subclasses.
	@discussion Internal method, not to be called by subclasses.
	@param request A valid SCSITaskIdentifier.
	*/
	void	EnsureAutosenseDescriptorExists ( SCSITaskIdentifier request );
	
	/*!
	@function SetProtocolLayerReference
	@abstract Accessor method to set the protocol layer reference.
	@discussion Accessor method to set the protocol layer reference.
	@param request A valid SCSITaskIdentifier.
	@param newReferenceValue Pointer to reference data.
	@result True on success, otherwise false.
	*/
	bool	SetProtocolLayerReference ( 
				SCSITaskIdentifier 		request, 
				void *					newReferenceValue );

	/*!
	@function GetProtocolLayerReference
	@abstract Accessor method to retrieve the protocol layer reference.
	@discussion Accessor method to retrieve the protocol layer reference.
	@param request A valid SCSITaskIdentifier.
	@result The protocol layer reference value. May be NULL.
	*/
	void *	GetProtocolLayerReference ( SCSITaskIdentifier request );
	
	/*!
	@function SetTaskExecutionMode
	@abstract Internal method used to set the task execution mode.
	@discussion Internal method used to set the task execution mode.
	@param request A valid SCSITaskIdentifier.
	@param newTaskMode A valid SCSITaskMode value.
	@result True on success, otherwise false.
	*/
	bool	SetTaskExecutionMode (
				SCSITaskIdentifier 		request, 
				SCSITaskMode 			newTaskMode );

	/*!
	@function GetTaskExecutionMode
	@abstract Internal method used to retrieve the task execution mode.
	@discussion Internal method used to retrieve the task execution mode.
	@param request A valid SCSITaskIdentifier.
	@result A valid SCSITaskMode value.
	*/
	SCSITaskMode	GetTaskExecutionMode ( SCSITaskIdentifier request );
	
	/*!
	@function SendNotification_DeviceRemoved
	@abstract Method called by subclasses when a device is physically removed from the bus.
	@discussion Method called by subclasses when a device is physically removed from the bus.
	*/
	void 	SendNotification_DeviceRemoved ( void );
	
	/*!
	@function SendNotification_VerifyDeviceState
	@abstract Method called by subclasses when a device state needs to be re-verified due to some
	bus condition which may have changed the device state.
	@discussion Method called by subclasses when a device state needs to be re-verified due to some
	bus condition which may have changed the device state.
	*/
	void 	SendNotification_VerifyDeviceState ( void );   
	
	// -- SCSI Task Queue Management Methods --
	// Following are the commands used to manipulate the queue of pending SCSI Tasks.
	
	/*!
	@function AddSCSITaskToQueue
	@abstract Internal method called to add a SCSITask to the processing queue.
	@discussion Internal method called to add a SCSITask to the processing queue.
	@param request A valid SCSITaskIdentifier.
	*/
	void 	AddSCSITaskToQueue ( SCSITaskIdentifier request );
	
	/*!
	@function AddSCSITaskToHeadOfQueue
	@abstract Internal method called to add a SCSITask to the head of the processing queue.
	@discussion Internal method called to add a SCSITask to the head of the processing queue.
	@param request A valid SCSITask pointer.
	*/
	void 	AddSCSITaskToHeadOfQueue ( SCSITask * request );
	
	/*!
	@function RetrieveNextSCSITaskFromQueue
	@abstract Internal method called to retrieve the next SCSITask to process.
	@discussion Internal method called to retrieve the next SCSITask to process.
	@result A valid SCSITask pointer or NULL if there are no tasks to process.
	*/
	SCSITask * RetrieveNextSCSITaskFromQueue ( void );
	
	/*!
	@function AbortSCSITaskFromQueue
	@abstract Deprecated internal method.
	@discussion Deprecated internal method.
	*/
	bool 	AbortSCSITaskFromQueue ( SCSITask * request );
	
	/*!
	@function SendSCSITasksFromQueue
	@abstract Internal method called to start processing SCSITasks.
	@discussion Internal method called to start processing SCSITasks. Only one client or workloop
	thread may process SCSITasks at any point in time. This method coordinates to ensure only one
	thread does so.
	*/
	void	SendSCSITasksFromQueue ( void );
	
	/*!
	@function RejectSCSITasksCurrentlyQueued
	@abstract Internal method called to reject currently enqueued SCSITasks.
	@discussion Internal method called to reject currently enqueued SCSITasks. This method is
	typically called in response to device termination.
	*/
	void	RejectSCSITasksCurrentlyQueued ( void );
	
	/*!
	@function ProcessCompletedTask
	@abstract Internal method called to process completed SCSITasks.
	@discussion Internal method called to process completed SCSITasks. This method determines if
	a CHECK_CONDITION has occurred and if sense data was requested and autosense data is not present.
	If so, it will change the execution mode of the SCSITask and request sense data on behalf of
	the caller.
	@param request A valid SCSITaskIdentifier.
	@param serviceResponse A valid SCSIServiceResponse value.
	@param taskStatus A valid SCSITaskStatus value.
	*/
	void	ProcessCompletedTask ( 	SCSITaskIdentifier 	request, 
									SCSIServiceResponse serviceResponse,
									SCSITaskStatus		taskStatus );
	
	/*!
	@function RejectTask
	@abstract Internal method called to reject a particular SCSITask.
	@discussion Internal method called to reject a particular SCSITask.
	@param request A valid SCSITaskIdentifier.
	*/
	void	RejectTask ( SCSITaskIdentifier	request );
	
	// ------ Power Management Support ------
	
	/*!
	@function InitializePowerManagement
	@abstract Subclasses call this method to initialize power management.
	@discussion Subclasses call this method to initialize power management.
	In the protocol services layer, this method calls the protocol interface layer
	to initialize power management state variables and then registers the protocol
	layer driver with the power manager with two(2) states, ON and OFF. Subclasses may
	override this behavior.
	@param provider The provider to be joined to in the power management tree.
	*/
	virtual void		InitializePowerManagement ( IOService * provider );
	
	/*!
	@function GetInitialPowerState
	@abstract This method is called once, right after InitializePowerManagement()
	in order to determine what state the device is initially in at startup time (usually
	the highest power mode).
	@discussion This method is called once, right after InitializePowerManagement()
	in order to determine what state the device is initially in at startup time (usually
	the highest power mode).
	@result The power state the device is currently in.
	*/
	virtual UInt32		GetInitialPowerState ( void );
	
	/*!
	@function HandlePowerChange
	@abstract This method is called to handle a power change.
	@discussion This method is called to handle a power change. It is called from a clean thread
	context (i.e. new thread, no locks held) and can make synchronous or asynchronous calls.
	*/
	virtual void		HandlePowerChange ( void );
	
	/*!
	@function HandleCheckPowerState
	@abstract Method called to check if the device is in the correct power state for an I/O.
	@discussion The HandleCheckPowerState (void) method is on the serialized side of the command
	gate and can change member variables safely without multi-threading issues. Its main purpose is
	to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState ) with the max power state
	with which the class registered.
	*/
	virtual void		HandleCheckPowerState ( void );
	
	/*!
	@function TicklePowerManager
	@abstract Internal method. Do not use.
	@discussion Internal method. Do not use.
	*/
	virtual void		TicklePowerManager ( void );
	
	/*!
	@function HandlePowerOff
	@abstract Convenience method for a protocol service driver to handle a power off call (called
	on the way to sleep).
	@discussion Convenience method for a protocol service driver to handle a power off call (called
	on the way to sleep). This method is guaranteed to be called after application layer drivers
	have been put to sleep.
	@result A valid IOReturn code.
	*/
	virtual IOReturn	HandlePowerOff ( void );
	
	/*!
	@function HandlePowerOn
	@abstract Convenience method for a protocol service driver to handle a power on call (called
	on the way back up from sleep).
	@discussion Convenience method for a protocol service driver to handle a power on call (called
	on the way back up from sleep). Driver should perform any bus specific activity necessary to
	recover from power-on/wake from sleep (e.g. bus reset on ATAPI). This method is guaranteed to
	be called before application layer drivers have been awakened.
	@result A valid IOReturn code.
	*/
	virtual IOReturn	HandlePowerOn ( void );
	
	
public:
	

	/*!
	@function init
    @abstract Standard init method for all IORegistryEntry subclasses.
    @discussion A registry entry must be initialized with this method before it can be used. A property dictionary may passed and will be retained by this method for use as the registry entry's property table, or an empty one will be created.
    @param A dictionary that will become the registry entry's property table (retaining it), or zero which will cause an empty property table to be created.
    @result true on success, or false on a resource failure.
    */
	virtual bool	init ( OSDictionary * propTable = 0 );
	
	/*!
	@function start
	@abstract During an IOService object's instantiation, starts the IOService object that has been selected to run on the provider.
	@discussion The <code>start</code> method of an IOService instance is called by its provider when it has been selected (due to its probe score and match category) as the winning client. The client is already attached to the provider when <code>start</code> is called.<br>Implementations of <code>start</code> must call <code>start</code> on their superclass at an appropriate point. If an implementation of <code>start</code> has already called <code>super::start</code> but subsequently determines that it will fail, it must call <code>super::stop</code> to balance the prior call to <code>super::start</code> and prevent reference leaks.
	@result <code>true</code> if the start was successful; <code>false</code> otherwise (which will cause the instance to be detached and usually freed).
	*/
	virtual bool	start ( IOService * provider );
	
	
	/*!
	@function free
	@abstract Frees data structures that were allocated during start().
	@discussion Frees data structures that were allocated during start().
	*/
	virtual void	free ( void );
	
	/*!
	@function RegisterSCSITaskCompletionRoutine
	@abstract Used by IOSCSITargetDevice to register a completion routine.
	@discussion Used by IOSCSITargetDevice to register a completion routine. Internal use only.
	@param completion A SCSITaskCompletion routine.
	*/
	void	RegisterSCSITaskCompletionRoutine ( SCSITaskCompletion completion );
	
	// ------- SCSI Architecture Model Task Management Functions ------
	
	/*!
	@function ExecuteCommand
	@abstract ExecuteCommand method will take a SCSI Task and transport it across the physical
	wire(s) to the device.
	@discussion ExecuteCommand method will take a SCSI Task and transport it across the physical
	wire(s) to the device.
	@param request A valid SCSITaskIdentifier.
	*/
	void	ExecuteCommand ( SCSITaskIdentifier	request );
	
	/*!
	@function AbortTask
	@abstract The Task Management function to allow the SCSI Application Layer client to request
	that a specific task be aborted.
	@discussion The Task Management function to allow the SCSI Application Layer client to request
	that a specific task be aborted.
	@param theLogicalUnit A logical unit for which to abort a task.
	@param theTag A valid SCSITaggedTaskIdentifier used to identify which task to abort.
	@result A valid SCSIServiceResponse.
	*/
	SCSIServiceResponse		AbortTask ( UInt8 theLogicalUnit, SCSITaggedTaskIdentifier theTag );

	/*!
	@function AbortTaskSet
	@abstract The Task Management function to allow the SCSI Application Layer client to request
	that a complete task set be aborted.
	@discussion The Task Management function to allow the SCSI Application Layer client to request
	that a complete task set be aborted.
	@param theLogicalUnit A logical unit for which to abort the task set.
	@result A valid SCSIServiceResponse.
	*/
	SCSIServiceResponse		AbortTaskSet ( UInt8 theLogicalUnit );

	/*!
	@function ClearACA
	@abstract The Task Management function to clear an Auto-Contingent Allegiance condition.
	@discussion The Task Management function to clear an Auto-Contingent Allegiance condition.
	@param theLogicalUnit A logical unit for which to clear the ACA.
	@result A valid SCSIServiceResponse.
	*/
	SCSIServiceResponse		ClearACA ( UInt8 theLogicalUnit );

	/*!
	@function ClearTaskSet
	@abstract The Task Management function to clear a task set.
	@discussion The Task Management function to clear a task set.
	@param theLogicalUnit A logical unit for which to clear a task set.
	@result A valid SCSIServiceResponse.
	*/
	SCSIServiceResponse		ClearTaskSet ( UInt8 theLogicalUnit );
    
	/*!
	@function LogicalUnitReset
	@abstract The Task Management function to reset a logical unit.
	@discussion The Task Management function to reset a logical unit.
	@param theLogicalUnit A logical unit for which to clear a task set.
	@result A valid SCSIServiceResponse.
	*/
	SCSIServiceResponse		LogicalUnitReset ( UInt8 theLogicalUnit );

	/*!
	@function TargetReset
	@abstract The Task Management function to reset a target device.
	@discussion The Task Management function to reset a target device.
	@result A valid SCSIServiceResponse.
	*/
	SCSIServiceResponse		TargetReset ( void );
	
    // ************* Obsoleted Member Routine ****************
	/*!
	@function AbortCommand
	@abstract Deprecated. Do not use.
	@discussion Deprecated. Do not use.
	*/
	virtual SCSIServiceResponse		AbortCommand ( SCSITaskIdentifier	request ) __attribute__ ((deprecated));

	
	// ---- Method used for determining protocol or physical interconnect characteristics. ----
	/*!
	@function IsProtocolServiceSupported
	@abstract IsProtocolServiceSupported will return true if the specified
	feature is supported by the protocol layer.
	@discussion IsProtocolServiceSupported will return true if the specified
	feature is supported by the protocol layer.
	@param feature A valid SCSIProtocolFeature.
	@param serviceValue A pointer to a value for the protocol feature.
	@result True if the requested service is supported, otherwise false.
	*/
	virtual bool	IsProtocolServiceSupported ( SCSIProtocolFeature feature, void * serviceValue ) = 0;

	/*!
	@function HandleProtocolServiceFeature
	@abstract HandleProtocolServiceFeature instructs the Protocol Services driver to perform the
	necessary tasks for the indicated feature.
	@discussion HandleProtocolServiceFeature instructs the Protocol Services driver to perform the
	necessary tasks for the indicated feature.
	@param feature A valid SCSIProtocolFeature.
	@param serviceValue A pointer to a value for the protocol feature.
	@result True if successful, otherwise false.
	*/
	virtual bool	HandleProtocolServiceFeature ( SCSIProtocolFeature feature, void * serviceValue ) = 0;
	
	
protected:
	
	// ----- Protocol Services Driver request handlers for Task Management functions -----

	/*!
	@function HandleAbortTask
	@abstract HandleAbortTask instructs the Protocol Services driver to abort the task.
	@discussion HandleAbortTask instructs the Protocol Services driver to abort the task.
	@param theLogicalUnit A valid logical unit number.
	@param theTag The tag of the command to abort.
	@result A valid SCSIServiceResponse.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices, 1 );
	virtual SCSIServiceResponse		HandleAbortTask ( 
											UInt8 						theLogicalUnit, 
											SCSITaggedTaskIdentifier 	theTag );
    
	/*!
	@function HandleAbortTaskSet
	@abstract HandleAbortTaskSet instructs the Protocol Services driver to abort the task set.
	@discussion HandleAbortTaskSet instructs the Protocol Services driver to abort the task set.
	@param theLogicalUnit A valid logical unit number.
	@result A valid SCSIServiceResponse.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices, 2 );
	virtual SCSIServiceResponse		HandleAbortTaskSet ( 
											UInt8 						theLogicalUnit );
	
	/*!
	@function HandleClearACA
	@abstract HandleClearACA instructs the Protocol Services driver to clear an auto-contingent allegiance.
	@discussion HandleClearACA instructs the Protocol Services driver to clear an auto-contingent allegiance.
	@param theLogicalUnit A valid logical unit number.
	@result A valid SCSIServiceResponse.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices, 3 );
	virtual SCSIServiceResponse		HandleClearACA ( 
											UInt8 						theLogicalUnit );
	
	/*!
	@function HandleClearTaskSet
	@abstract HandleClearTaskSet instructs the Protocol Services driver to clear the task set.
	@discussion HandleClearTaskSet instructs the Protocol Services driver to clear the task set.
	@param theLogicalUnit A valid logical unit number.
	@result A valid SCSIServiceResponse.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices, 4 );
	virtual SCSIServiceResponse		HandleClearTaskSet (
											UInt8 						theLogicalUnit );
	
	/*!
	@function HandleLogicalUnitReset
	@abstract HandleLogicalUnitReset instructs the Protocol Services driver to reset the logical unit.
	@discussion HandleLogicalUnitReset instructs the Protocol Services driver to reset the logical unit.
	@param theLogicalUnit A valid logical unit number.
	@result A valid SCSIServiceResponse.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices, 5 );
	virtual SCSIServiceResponse		HandleLogicalUnitReset (
											UInt8 						theLogicalUnit );
											
	/*!
	@function HandleTargetReset
	@abstract HandleTargetReset instructs the Protocol Services driver to reset the target.
	@discussion HandleTargetReset instructs the Protocol Services driver to reset the target.
	@result A valid SCSIServiceResponse.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices, 6 );
	virtual SCSIServiceResponse		HandleTargetReset ( void );

#if !TARGET_OS_EMBEDDED
	/*!
	@function CreateSCSITargetDevice
	@abstract Used to create a SCSITargetDevice which will manage logical units.
	@discussion The CreateSCSITargetDevice member routine will create the appropriate object
	to represent the Target portion of a SCSI Device. This object is responsible
	for managing the Target functions of the SCSI Device including the Task Manager and
	Logical Units.
	@result True if successful, otherwise false.
	*/
    OSMetaClassDeclareReservedUsed ( IOSCSIProtocolServices,  7 );
	virtual bool	CreateSCSITargetDevice ( void );
#endif /* !TARGET_OS_EMBEDDED */
	
private:
	
	
#if !TARGET_OS_EMBEDDED
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices,  8 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 	9 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 10 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 11 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 12 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 13 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 14 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 15 );
    OSMetaClassDeclareReservedUnused ( IOSCSIProtocolServices, 16 );
#endif /* !TARGET_OS_EMBEDDED */
    
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_SCSI_PROTOCOL_SERVICES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         IOSCSIReducedBlockCommandsDevice.h                                                                  0100644 0001750 0001750 00000121131 12567470660 041203  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_SCSI_REDUCED_BLOCK_COMMANDS_DEVICE_H_
#define _IOKIT_IO_SCSI_REDUCED_BLOCK_COMMANDS_DEVICE_H_

#if defined(KERNEL) && defined(__cplusplus)


/*! @header SCSI Reduced Block Commands Device
 @discussion
 This file contains definitions for the IOSCSIReducedBlockCommandsDevice class,
 commands required for RBC devices, power management, and additional constants
 used by this class.
 */


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit headers
#include <IOKit/IOLib.h>
#include <IOKit/IOMemoryDescriptor.h>

// Generic IOKit storage related headers
#include <IOKit/storage/IOStorage.h>

// SCSI Architecture Model Family includes
#include <IOKit/scsi/IOSCSIPrimaryCommandsDevice.h>

// Build includes
#include <TargetConditionals.h>

//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------

// RBC power states as defined in T10:1240D SCSI Reduced Block Commands (RBC)
// Revision 10a, August 18, 1999, page 13.
enum
{
	kRBCPowerStateSystemSleep	= 0,
	kRBCPowerStateSleep 		= 1,
	kRBCPowerStateStandby 		= 2,
	kRBCPowerStateIdle			= 3,
	kRBCPowerStateActive		= 4,
	kRBCNumPowerStates			= 5
};

/*!
@enum Media lock state values
@discussion
Values used to set media lock state.
@constant kMediaStateUnlocked
Value to be passed in order to unlock media and make it availabe for writing.
@constant kMediaStateLocked
Value to be passed when the media is to be locked and made read-only. 
*/

enum
{
	kMediaStateUnlocked	= 0,
	kMediaStateLocked 	= 1
};

#define kCapacityDataBufferSize				8

// Forward declaration for the SCSIReducedBlockCommands that is used internally by the
// IOSCSIReducedBlockCommandsDevice class.
class SCSIReducedBlockCommands;

//-----------------------------------------------------------------------------
//	Class Declaration
//-----------------------------------------------------------------------------

/*!
@class IOSCSIReducedBlockCommandsDevice
@superclass IOSCSIPrimaryCommandsDevice
@discussion
Implementation of the T10 device Reduced Block Commands device. This is the base
driver for all subclasses implementing peripheral device type 0xE.
*/
class IOSCSIReducedBlockCommandsDevice : public IOSCSIPrimaryCommandsDevice
{
	
	OSDeclareAbstractStructors ( IOSCSIReducedBlockCommandsDevice );
	
private:
	
	static void			AsyncReadWriteComplete ( SCSITaskIdentifier completedTask );
	
protected:

	// Reserve space for future expansion.
	struct IOSCSIReducedBlockCommandsDeviceExpansionData
	{
		IONotifier *	fPowerDownNotifier;
		bool			fMediumRemovalPrevented;
		bool			fKnownManualEject;
		UInt32			fPollingMode;
		bool			fProtocolSpecificPowerControl;
	};
	IOSCSIReducedBlockCommandsDeviceExpansionData * fIOSCSIReducedBlockCommandsDeviceReserved;
	
	#define fPowerDownNotifier				fIOSCSIReducedBlockCommandsDeviceReserved->fPowerDownNotifier
	#define fMediumRemovalPrevented			fIOSCSIReducedBlockCommandsDeviceReserved->fMediumRemovalPrevented
	#define fKnownManualEject				fIOSCSIReducedBlockCommandsDeviceReserved->fKnownManualEject
	#define fPollingMode					fIOSCSIReducedBlockCommandsDeviceReserved->fPollingMode
	#define fProtocolSpecificPowerControl	fIOSCSIReducedBlockCommandsDeviceReserved->fProtocolSpecificPowerControl
	
	bool				fMediaChanged;
	bool				fMediaPresent;
	
	// The byte count of each physical block on the media.
	UInt32				fMediaBlockSize;
	
	// The total number of blocks of mediaBlockSize on the media.
	UInt32				fMediaBlockCount;
	
	// Flags used to indicate device features.
	bool				fMediaIsRemovable;
	bool				fMediaIsWriteProtected;
	
	thread_call_t		fPollingThread;
	
	enum
	{
		kPollingMode_Suspended			= 0,
		kPollingMode_NewMedia 			= 1,
		kPollingMode_MediaRemoval		= 2
	};
	
	/*!
	@function CreateStorageServiceNub
	@abstract Creates a nub which links the IOSCSIReducedBlockCommandsDevice to the IOStorageFamily.
	@discussion Creates a nub which links the IOSCSIReducedBlockCommandsDevice to the IOStorageFamily.
	*/
	virtual void 		CreateStorageServiceNub ( void );
	
	/*!
	@function DetermineDeviceCharacteristics
	@abstract Determine the characteristics of the device.
	@discussion Determine the characteristics, ANSI version, removability, etc., of the device via its INQUIRY data.
	@result <code>true</code> on success and <code>false</code> on failure.
	 */
	virtual bool		DetermineDeviceCharacteristics ( void );
	
	/*!
	@function PollForMedia
	@abstract Poll device for media insertion or removal depending on selected polling mode.
	@discussion Polls device for media insertion or removal depending on selected polling mode. 
	If a change in media state is detected the correct media inserted or removed API is called from within PollForMedia.
	*/
	virtual void		PollForMedia ( void );
	
	/*!
	@function EnablePolling
	@abstract Enables media polling.
	@discussion Schedules a thread to poll the device for media at the prescribed interval.
	*/
	virtual void		EnablePolling ( void );
	
	/*!
	@function DisablePolling
	@abstract Disables media polling.
	@discussion Cancels ( if running ) the media polling thread.
	*/
	virtual void		DisablePolling ( void );
	
	/*!
	@function CheckWriteProtection
	@abstract Ascertains whether or not media is locked.
	@discussion Determines the current write protection state of the media.
	Result stored in fMediaIsWriteProtected.
	*/
	virtual void		CheckWriteProtection ( void );
	
	/*!
	@function SetMediaCharacteristics
	@abstract Sets the block size and block count for the current media.
	@discussion Sets the block size and block count for the current media.
	@param blockSize The media's block size in bytes.
	@param blockCount The count of the media's blocks.
	*/
	virtual void		SetMediaCharacteristics ( UInt32 blockSize, UInt32 blockCount );
	
	/*!
	@function ResetMediaCharacteristics
	@abstract Resets the block size and block count.
	@discussion Resets the block size and block count.
	*/    
	virtual void		ResetMediaCharacteristics ( void );
	
	/*!
	@function ClearNotReadyStatus
	@abstract Clears any NOT_READY status for the device.
	@discussion Polls device with TEST_UNIT_READY until the device stops returning NOT_READY status. 
	Exits if device has become disconnected.
	@result <code>true</code> if able to clear the NOT_READY status and <code>false</code> if not.
	*/
	virtual bool		ClearNotReadyStatus ( void );
	
	/*!
	@function IssueRead
	@abstract DEPRECATED. Please do not use this method.
	@discussion DEPRECATED. Please do not use this method.
	@param buffer DEPRECATED. Please do not use this method.
	@param startBlock DEPRECATED. Please do not use this method.
	@param blockCount DEPRECATED. Please do not use this method.
	@result DEPRECATED. Please do not use this method.
	*/
	virtual IOReturn	IssueRead ( IOMemoryDescriptor *	buffer,
									UInt64					startBlock,
									UInt64					blockCount );
	
	/*!
	@function IssueWrite
	@abstract DEPRECATED. Please do not use this method.
	@discussion DEPRECATED. Please do not use this method.
	@param buffer DEPRECATED. Please do not use this method.
	@param startBlock DEPRECATED. Please do not use this method.
	@param blockCount DEPRECATED. Please do not use this method.
	@result DEPRECATED. Please do not use this method.
	*/
	virtual IOReturn	IssueWrite ( IOMemoryDescriptor*	buffer,
									 UInt64					startBlock,
									 UInt64					blockCount );
	
	/*!
	@function IssueRead
	@abstract Issues an asynchronous read command.
	@discussion Issues an asynchronous read command.
	@param buffer A pointer to a valid IOMemoryDescriptor to which the data can be copied to.
	@param startBlock Starting logical block address for the read operation.
	@param blockCount The number of blocks to be read.
	@param clientData A valid pointer to the client data to be used for callback completion. 
	@result A valid IOReturn value.
	*/
	virtual IOReturn	IssueRead ( IOMemoryDescriptor *	buffer,
									UInt64					startBlock,
									UInt64					blockCount,
									void *					clientData );
	
	/*!
	@function IssueWrite
	@abstract Issues an asynchronous write command.
	@discussion Issues an asynchronous write command.
	@param buffer A pointer to a valid IOMemoryDescriptor to which the data can be copied from.
	@param startBlock Starting logical block address for the write operation.
	@param blockCount The number of blocks to be written.
	@param clientData A valid pointer to the client data to be used for callback completion. 
	@result A valid IOReturn value.
	*/
	virtual IOReturn	IssueWrite ( IOMemoryDescriptor *	buffer,
									 UInt64					startBlock,
									 UInt64					blockCount,
									 void *					clientData );

	// ----- Power Management Support ------
		
	/*!
	@function InitializePowerManagement
	@abstract Called to initialize power management.
	@discussion Called by InitializeDeviceSupport() to initialize power management by, 
	joining the power management tree, registering power states, and setting the lowest idle 
	power state.
	@param A valid pointer to this object's provider.
	*/
	
	// We override this method to set our power states and register ourselves
	// as a power policy maker.
	virtual void 		InitializePowerManagement ( IOService * provider );
	
	/*!
	@function GetInitialPowerState
	@abstract Called by power management to determine initial power state.
	@discussion Called by power management to determine which power state is desired when 
	power management is initialized.
	@result Returns the initial power state desired when power management is initialized.
	*/
	
	// We override this method so that when we register for power management,
	// we go to our active power state (which the drive is definitely in
	// at startup time).
	virtual UInt32		GetInitialPowerState ( void );
	
	/*!
	@function GetNumberOfPowerStateTransitions
	@abstract Called by power management to determine this class's total 
	number of power state transitions.
	@discussion Called by power management to determine this class's total 
	number of power state transitions.
	@result Returns the number of power state transitions for this class.
	*/
	
	// We override this method in order to provide the number of transitions
	// from Fully active to Sleep state so that the idle timer can be adjusted
	// to the appropriate time period based on the disk spin down time set in
	// the Energy Saver prefs panel.
	virtual UInt32		GetNumberOfPowerStateTransitions ( void );
	
	/*!
	@function TicklePowerManager
	@abstract The TicklePowerManager() is called by CheckPowerState() and
	sends an activity tickle ( via activityTickle() ) to the power manager 
	so that the idle timer is reset.
	@discussion The TicklePowerManager() is called by CheckPowerState() and
	sends an activity tickle ( via activityTickle() ) to the power manager
	so that the idle timer is reset.
	Subclasses must override this method. Third party subclasses shouldn't need to override
	this method but can to alter the default behavior.
	*/

	// The TicklePowerManager method is called to tell the power manager that the
	// device needs to be in a certain power state to handle requests.
	virtual void		TicklePowerManager ( void );
	
	/*!
	@function HandlePowerChange
	@abstract Handles the state machine for power management state changes.
	@discussion Handles the state machine for power management state changes.
	*/
	
	// The HandlePowerChange method is the state machine for power management.
	// It is guaranteed to be on its own thread of execution (different from
	// the power manager thread AND the workloop thread. This routine can
	// send sync or async calls to the drive without worrying about threading
	// issues.
	virtual void		HandlePowerChange ( void );
	
	/*!
	@function HandleCheckPowerState(void)
	@abstract The HandleCheckPowerState (void) method is on the serialized side of the command
	gate and can change member variables safely without multi-threading issues.
	It's main purpose is to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState )
	with the max power state the class registered with.
	@discussion The HandleCheckPowerState (void) method is on the serialized side of the command
	gate and can change member variables safely without multi-threading issues.
	It's main purpose is to call the superclass' HandleCheckPowerState ( UInt32 maxPowerState )
	with the max power state the class registered with.
	Subclasses must override this method. Third party subclasses shouldn't need to override
	this method but can to alter the default behavior. The default behavior is to block until the 
	object transistions to its maximum power state.
	*/
	
	virtual void		HandleCheckPowerState ( void );
	
	/*!
	@function CheckMediaPresence
	@abstract Called to ascertain the current presence of media.
	@discussion Called to ascertain the current presence of media.
	@result <code>true</code> if media is present and <code>false</code> if media is not present.
	*/
	
	// The CheckMediaPresence method is called to see if the media which we
	// anticipated being there is still there.
	virtual bool		CheckMediaPresence ( void );
	
	/*!
	@function InitializeDeviceSupport
	@abstract Called in super class's start() to initialize device support.
	@discussion Called in super class's start() to initialize device support. The underlying infrastructure
	for supporting a device must be implemented here.
	@result <code>true</code> if device could be successfully configured <code>false</code> if not.
	*/    
	virtual bool		InitializeDeviceSupport ( void );
	
	/*!
	@function StartDeviceSupport
	@abstract Called in super class's start() to start device support.
	@discussion Called in super class's start() to start device support. Support for starting
	devices and making them usable must be implemented here. 
	*/  
	virtual void		StartDeviceSupport ( void );
	
	/*!
	@function SuspendDeviceSupport
	@abstract Called to temporarily suspend device support.
	@discussion Called to temporarily suspend device support. Support for suspending
	devices must be implemented here.
	*/ 
	virtual void		SuspendDeviceSupport ( void );
	
	/*!
	@function ResumeDeviceSupport
	@abstract Called to temporarily resume device support.
	@discussion Called to temporarily resume device support. Support for resuming
	devices must be implemented here.
	*/ 
	virtual void		ResumeDeviceSupport ( void );
	
	/*!
	@function StopDeviceSupport
	@abstract Called to stop device support.
	@discussion Called to stop device support. Support for stopping
	devices must be implemented here.
	*/ 
	virtual void		StopDeviceSupport ( void );
	
	/*!
	@function TerminateDeviceSupport
	@abstract Called to terminate device support.
	@discussion Called to terminate device support. The underlying infrastructure for
	support a device should be cleaned up here.
	*/ 
	virtual void		TerminateDeviceSupport ( void );
	
	/*!
	@function free
	@abstract Called to release all resources held by the object.
	@discussion Release all resources held by the object, then call super::free().  
	*/	
	virtual void 		free ( void );
	
public:
	
	/*!
	@function SyncReadWrite
	@abstract Translates a synchronous I/O request into a read or a write.
	@discussion Translates a synchronous I/O request into a read or a write.
	Default implementation always returns kIOReturnUnsupported.
	@param buffer A pointer to a valid IOMemoryDescriptor to which the 
	data can be copied to or from.
	@param startBlock Starting logical block address for the write operation.
	@param blockCount The number of block to be write.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	SyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt64					startBlock,
											UInt64					blockCount );
	
	/*!
	@function AsyncReadWrite
	@abstract Translates an asynchronous I/O request into a read or a write.
	@discussion Translates an asynchronous I/O request into a read or a write.
	@param buffer A pointer to a valid IOMemoryDescriptor to which the 
	data can be copied to or from.
	@param startBlock Starting logical block address for the write operation.
	@param blockCount The number of block to be write.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	AsyncReadWrite (	IOMemoryDescriptor *	buffer,
											UInt64					block,
											UInt64					nblks,
											void *					clientData );
	
	/*!
	@function EjectTheMedia
	@abstract Called to eject the inserted media from the drive.
	@discussion Called by IOBlockStorageDevice subclasses to eject the inserted 
	media from the drive.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	EjectTheMedia ( void );	
	
	/*!
	@function FormatMedia
	@abstract Called to perform a low level format of the inserted media.
	@discussion Called IOBlockStorageDevice subclasses to perform a low level 
	of the inserted media. Default implementation simply returns kIOReturnUnsupported 
	if not overridden.
	@param byteCapacity
	@result A valid IOReturn value.
	*/
	virtual IOReturn	FormatMedia ( UInt64 byteCapacity );
	
	/*!
	@function GetFormatCapacities
	@abstract Called to determine the formatted capacity of the inserted media.
	@discussion Called IOBlockStorageDevice subclasses to determine the formatted 
	capacity of the inserted media. Presently unsupported by default implementation. 
	Returns 0 unless overridden.
	@param capacities a pointer to a valid UInt64 array.
	@param capacitiesMaxCount the number of elements addressable within capacities.
	@result The number of elements assigned in capacities ( count is 1 based ).
	*/
	virtual UInt32		GetFormatCapacities ( 	UInt64 * capacities,
												UInt32   capacitiesMaxCount ) const;
	
	/*!
	@function LockUnlockMedia
	@abstract Called to lock or unlock the inserted media.
	@discussion Called by IOBlockStorageDevice subclasses to lock or unlock the inserted media. 
	@param doLock if true the media will be locked, if false the media will be unlocked.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	LockUnlockMedia ( bool doLock );
	
	/*!
	@function SynchronizeCache
	@abstract Called to synchronize the devices cache and thereby force its contents to be
	written out to the media.
	@discussion Called by IOBlockStorageDevice subclasses to synchronize the devices cache 
	and thereby force the cache's contents to be written out to the media.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	SynchronizeCache ( void );
	
	/*!
	@function ReportBlockSize
	@abstract Reports the logical block size of the media.
	@discussion Called by IOBlockStorageDevice subclasses to get the logical block size of the media.
	@param blockSize a valid pointer to a UInt64 in which the logical block size is to be stored.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	ReportBlockSize ( UInt64 * blockSize );
	
	/*!
	@function ReportEjectability
	@abstract Reports whether or not the media is ejectable.
	@discussion Called by IOBlockStorageDevice subclasses to determine wether or not the media is ejectable.
	@param isEjectable a valid pointer to a bool in which the ejectability of the media is to be stored.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	ReportEjectability ( bool * isEjectable );
	
	/*!
	@function ReportLockability
	@abstract Reports whether or not the media is lockable ( can be write protected ).
	@discussion Called by IOBlockStorageDevice subclasses to determine whether or not the media is lockable
	( can be write protected ).
	@param isLockable a valid pointer to a bool in which the lockability of the media is to be stored.
	@result A valid IOReturn value.
	*/  
	virtual IOReturn	ReportLockability ( bool * isLockable );
	
	/*!
	@function ReportPollRequirements
	@abstract Reports polling requirements to caller.
	@discussion Called by IOBlockStorageDevice subclasses to determine polling requirements. 
	Used to determine if polling for media is required and if polling is expensive. 
	@param pollIsRequired a pointer to a bool in which to store whether or not polling is required.
	@param pollIsExpensive a pointer to a bool in which to store whether or not polling is expensive.
	@result A valid IOReturn value.
	*/ 
	virtual IOReturn	ReportPollRequirements ( bool * pollIsRequired,
												 bool * pollIsExpensive );
	
	/*!
	@function ReportMaxReadTransfer
	@abstract Reports maximum read transfer size to caller.
	@discussion Called by IOBlockStorageDevice subclasses to determine the maximum size
	of a read transfer in bytes. 
	@param blockSize used to pass in the block size to be used for a follow up transfer.
	@param max a pointer to a UInt64 in which to store the maximum transfer size in bytes.
	@result A valid IOReturn value.
	*/ 
	virtual IOReturn	ReportMaxReadTransfer (  UInt64 	blockSize,
												 UInt64 * 	max );
	
	/*!
	@function ReportMaxValidBlock
	@abstract Reports the maximum valid block on the media.
	@discussion Called by IOBlockStorageDevice subclasses to determine the maximum valid 
	block of the media.
	@param maxBlock a pointer to a UInt64 in which the maximum valid block is to be stored.
	@result A valid IOReturn value.
	*/ 
	virtual IOReturn	ReportMaxValidBlock ( UInt64 * maxBlock );
	
	/*!
	@function ReportMaxWriteTransfer
	@abstract Reports maximum write transfer size to caller.
	@discussion Called by IOBlockStorageDevice subclasses to determine the maximum size
	of a write transfer in bytes.
	@param blockSize used to pass in the block size of the media.
	@param max a pointer to a UInt64 in which to store the maximum transfer size in bytes.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	ReportMaxWriteTransfer ( UInt64	blockSize,
												UInt64 * max );
	
	/*!
	@function ReportMediaState
	@abstract Reports the state of media in the device.
	@discussion Called by IOBlockStorageDevice subclasses to determine whether or not media is 
	present and if that media has changed.
	@param mediaPresent a pointer to a bool in which media presence will be stored.
	@param changed a pointer to a bool in which whether or not the media has changed will be stored.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	ReportMediaState ( 	bool * mediaPresent,
											bool * changed );
	
	/*!
	@function ReportRemovability
	@abstract Reports whether or not the media may be removed.
	@discussion Called by IOBlockStorageDevice subclasses to determine whether or not the media may be removed.
	@param isRemovable a pointer to a bool in which whether or not the media can be me removed 
	will be stored.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	ReportRemovability ( bool * isRemovable );
	
	/*!
	@function ReportWriteProtection
	@abstract Reports whether or not the media is write protected.
	@discussion Called by IOBlockStorageDevice subclasses to determine whether or not the media is write protected.
	@param isWriteProtected a pointer to a bool in which whether or not the media is write protected will be stored.
	@result A valid IOReturn value.
	*/
	virtual IOReturn	ReportWriteProtection ( bool * isWriteProtected );
	
	/*!
	@function sPollForMedia
	@abstract Static method called to poll for media.
	@discussion Static method called to poll for media.
	@param pdtDriver a pointer to a valid IOSCSIReducedBlockCommandsDevice ( or subclass ) which is to
	be polled.
	@param refCon a pointer to an additional object which can be determined by the implementer.
	*/
	static 	void		sPollForMedia ( void * pdtDriver, void * refCon );
	
	
protected:
	
	
	/*!
	@function FORMAT_UNIT
	@abstract Builds a FORMAT UNIT command.
	@discussion Builds a FORMAT UNIT command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param IMMED used to specify whether or not the immediate bit for the command needs to be set.
	@param PROGRESS used to specify whether or not the progress bit for the commands needs to be set. 
	@param PERCENT_TIME used to specify whether or not the percent time bit for the command needs to be set.
	@param INCREMENT used to specify whether or not the increment bit for the command needs to be set.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The FORMAT_UNIT command as defined in section 5.1
	virtual bool FORMAT_UNIT (
							SCSITaskIdentifier			request,
							SCSICmdField1Bit			IMMED,
							SCSICmdField1Bit			PROGRESS,
							SCSICmdField1Bit			PERCENT_TIME,
							SCSICmdField1Bit			INCREMENT );
	
	/*!
	@function INQUIRY
	@abstract Builds a INQUIRY command.
	@discussion Builds a INQUIRY command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the received INQUIRY data is to be stored.
	@param CMDDT used to specify whether or not the command support data ( CmdDT ) bit for the commands needs to be set. 
	@param EVPD used to specify whether or not the vital product data ( EVPD ) bit for the command needs to be set.
	@param PAGE_OR_OPERATION_CODE used to specify which INQUIRY data page is being requested of the device.
	@param ALLOCATION_LENGTH used to specify the maximum requested amount of INQUIRY data.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The INQUIRY command as defined in SPC-2 w/o CONTROL byte
	virtual bool INQUIRY (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit			CMDDT,
							SCSICmdField1Bit			EVPD,
							SCSICmdField1Byte			PAGE_OR_OPERATION_CODE,
							SCSICmdField1Byte			ALLOCATION_LENGTH );
	
	/*!
	@function MODE_SELECT_6
	@abstract Builds a MODE SELECT(6) command.
	@discussion Builds a MODE SELECT(6) command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the MODE SELECT data is stored.
	@param PF used to specify whether or not the page format ( PF ) bit for the commands needs to be set. 
	@param SP used to specify whether or not the saves pages ( SP ) bit for the command needs to be set.
	@param PARAMETER_LIST_LENGTH used to specify the length of the supplied data.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The MODE_SELECT(6) command as defined in SPC-2 w/o CONTROL byte
	virtual bool MODE_SELECT_6 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			PF,
							SCSICmdField1Bit 			SP,
							SCSICmdField1Byte 			PARAMETER_LIST_LENGTH );
	
	/*!
	@function MODE_SENSE_6
	@abstract Builds a MODE SENSE(6) command.
	@discussion Builds a MODE SENSE(6) command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the MODE SENSE data is to be stored.
	@param DBD used to specify whether or not the disable block descriptors ( DBD ) bit for the commands needs to be set. 
	@param PC used to specify the desired page control ( PC ) value.
	@param PAGE_CODE used to specify the desired page code.
	@param ALLOCATION_LENGTH used to specify the maximum requested amount of MODE_SENSE data.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The MODE_SENSE(6) command as defined in SPC-2 w/o CONTROL byte
	virtual bool MODE_SENSE_6 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Bit 			DBD,
							SCSICmdField2Bit 			PC,
							SCSICmdField6Bit 			PAGE_CODE,
							SCSICmdField1Byte 			ALLOCATION_LENGTH );
	
	/*!
	@function PERSISTENT_RESERVE_IN
	@abstract Builds a PERSISTENT RESERVE IN command.
	@discussion Builds a PERSISTENT RESERVE IN command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the reservation data is to be stored.
	@param SERVICE_ACTION used to specify the SERVICE ACTION code. 
	@param ALLOCATION_LENGTH used to specify the number of parameter data bytes available to be returned.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The PERSISTENT_RESERVE_IN command as defined in SPC-2 w/o CONTROL byte
	virtual bool PERSISTENT_RESERVE_IN (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField5Bit 			SERVICE_ACTION,
							SCSICmdField2Byte 			ALLOCATION_LENGTH );
	
	/*!
	@function PERSISTENT_RESERVE_OUT
	@abstract Builds a PERSISTENT RESERVE OUT command.
	@discussion Builds a PERSISTENT RESERVE OUT command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the reservation data is stored.
	@param SERVICE_ACTION used to specify the SERVICE ACTION code. 
	@param SCOPE used to specify the desired scope.
	@param TYPE used to specify the desired type.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The PERSISTENT_RESERVE_OUT command as defined in SPC-2 w/o CONTROL byte
	virtual bool PERSISTENT_RESERVE_OUT (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField5Bit			SERVICE_ACTION,
							SCSICmdField4Bit			SCOPE,
							SCSICmdField4Bit			TYPE );

	/*!
	@function PREVENT_ALLOW_MEDIUM_REMOVAL
	@abstract Builds a PREVENT ALLOW MEDIUM REMOVAL command.
	@discussion Builds a PREVENT ALLOW MEDIUM REMOVAL command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param PREVENT used to specify whether or not media removal shall be prevented or allowed. The caller
	uses kMediaStateUnlocked or kMediaStateLocked constant to set the state.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The PREVENT_ALLOW_MEDIUM_REMOVAL command as defined in SPC-2 w/o CONTROL byte
	virtual bool PREVENT_ALLOW_MEDIUM_REMOVAL ( 
							SCSITaskIdentifier			request,
							SCSICmdField2Bit			PREVENT );
	
	/*!
	@function READ_10
	@abstract Builds a READ(10) command.
	@discussion Builds a READ(10) command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the read data is to be stored.
	@param blockSize used to specify the block size to be used for the read.
	@param LOGICAL_BLOCK_ADDRESS used to specify the logical block address from which the read is to be initiated.
	@param TRANSFER_LENGTH the desired transfer length in blocks.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The READ_10 command as defined in section 5.2
	virtual bool READ_10 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							UInt32						blockSize,
							SCSICmdField4Byte			LOGICAL_BLOCK_ADDRESS,
							SCSICmdField2Byte			TRANSFER_LENGTH );
	
	/*!
	@function READ_CAPACITY
	@abstract Builds a READ CAPACITY command.
	@discussion Builds a READ CAPACITY command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the read capacity data is to be stored.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The READ_CAPACITY command as defined in section 5.3
	virtual bool READ_CAPACITY (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer );
	
	/*!
	@function RELEASE_6
	@abstract Builds a RELEASE(6) command.
	@discussion Builds a RELEASE(6) command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The RELEASE(6) command as defined in SPC-2 w/o CONTROL byte
	virtual bool RELEASE_6 (								
							SCSITaskIdentifier			request );
	
	/*!
	@function REQUEST_SENSE
	@abstract Builds a REQUEST SENSE command.
	@discussion Builds a REQUEST SENSE command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the sense data is to be stored.
	@param ALLOCATION_LENGTH the maximum size of sense data to be supplied.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The REQUEST_SENSE command as defined in SPC-2 w/o CONTROL byte
	virtual bool REQUEST_SENSE (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField1Byte 			ALLOCATION_LENGTH );
	
	/*!
	@function RESERVE_6
	@abstract Builds a RESERVE(6) command.
	@discussion Builds a RESERVE(6) command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The RESERVE(6) command as defined in SPC-2 w/o CONTROL byte
	virtual bool RESERVE_6 (	
							SCSITaskIdentifier			request );
	
	/*!
	@function START_STOP_UNIT
	@abstract Builds a START STOP UNIT command.
	@discussion Builds a START STOP UNIT command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param IMMED used to specify whether or not the immediate bit for the command needs to be set.
	@param POWER_CONDITIONS used to specify the desired POWER CONDITIONS code.
	@param LEOJ used to specify whether or not the LOAD/EJECT ( LEOJ ) bit for the command needs to be set.
	@param START used to specify whether or not the START bit for the command needs to be set.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The START_STOP_UNIT command as defined in section 5.4
	virtual bool START_STOP_UNIT (
							SCSITaskIdentifier			request,
							SCSICmdField1Bit			IMMED,
							SCSICmdField4Bit			POWER_CONDITIONS,
							SCSICmdField1Bit			LEOJ,
							SCSICmdField1Bit			START );
	
	/*!
	@function SYNCHRONIZE_CACHE
	@abstract Builds a SYNCHRONIZE CACHE command.
	@discussion Builds a SYNCHRONIZE CACHE command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The SYNCRONIZE_CACHE command as defined in section 5.5
	virtual bool SYNCHRONIZE_CACHE (
							SCSITaskIdentifier			request );
	
	/*!
	@function TEST_UNIT_READY
	@abstract Builds a TEST UNIT READY command.
	@discussion Builds a TEST UNIT READY command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The TEST_UNIT_READY command as defined in SPC-2 w/o CONTROL byte
	virtual bool TEST_UNIT_READY (
							SCSITaskIdentifier			request );
	
	/*!
	@function VERIFY
	@abstract Builds a VERIFY command.
	@discussion Builds a VERIFY command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param LOGICAL_BLOCK_ADDRESS used to specify the logical block address from which the verify should be initiated.
	@param VERIFICATION_LENGTH the desired length in blocks.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The VERIFY command as defined in section 5.7
	virtual bool VERIFY (
							SCSITaskIdentifier			request,
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
							SCSICmdField2Byte 			VERIFICATION_LENGTH );
	
	/*!
	@function WRITE_10
	@abstract Builds a WRITE(10) command.
	@discussion Builds a WRITE(10) command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the data to be written is stored.
	@param blockSize used to specify the block size to be used for the write.
	@param FUA used specify whether or not the force unit access ( FUA ) bit should be set.
	@param LOGICAL_BLOCK_ADDRESS used to specify the logical block address from which the write should be initiated.
	@param TRANSFER_LENGTH the desired transfer length in blocks.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The WRITE_10 command	as defined in section 5.6
	virtual bool WRITE_10 (
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							UInt32						blockSize,
							SCSICmdField1Bit			FUA,
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS,
							SCSICmdField2Byte 			TRANSFER_LENGTH );
	
	/*!
	@function WRITE_BUFFER
	@abstract Builds a WRITE BUFFER command.
	@discussion Builds a WRITE BUFFER command.
	@param request a SCSITaskIdentifier in which the built command will be stored.
	@param dataBuffer a point to a valid IOMemoryDescriptor in which the data to be written is stored.
	@param MODE used to specify which WRITE BUFFER mode is to be used.
	@param BUFFER_ID used to be specificy the desired buffer ID.
	@param BUFFER_OFFSET used to specify the desired buffer offset.
	@param PARAMETER_LIST_LENGTH the length of the buffer to be transferred.
	@result <code>true</code> if the command was successfully built and <code>false</code> if not.
	*/
	// The WRITE_BUFFER command as defined in SPC-2 w/o CONTROL byte
	virtual bool WRITE_BUFFER ( 
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer,
							SCSICmdField4Bit 			MODE,
							SCSICmdField1Byte 			BUFFER_ID,
							SCSICmdField3Byte 			BUFFER_OFFSET,
							SCSICmdField3Byte 			PARAMETER_LIST_LENGTH );
	
	

	/* Added with 10.2 */
	OSMetaClassDeclareReservedUsed ( IOSCSIReducedBlockCommandsDevice, 1 );
	
public:
	
	/*!
	@function PowerDownHandler
	@abstract Method called at sleep, restart, or shutdown time.
	@discussion Notification handler registered with registerPrioritySleepWakeInterest().
	@param refCon a pointer to an object which can be determined by the implementer when
	registerPrioritySleepWakeInterest() is called.
	@param messageType a constant defined in IOMessage.h ( kIOMessageSystemWillPowerOff, kIOMessageSystemWillRestart, etc. ).
	@param provider a pointer to the provider of the notification.
	@param messageArgument a pointer to the notification's argument.
	@param argSize the size of the argument.
	@result A valid IOReturn value.
    */
	virtual IOReturn	PowerDownHandler (	void * 			refCon,
											UInt32 			messageType,
											IOService * 	provider,
											void * 			messageArgument,
											vm_size_t 		argSize );
	
	
	/* Added with 10.2 */	
	OSMetaClassDeclareReservedUsed ( IOSCSIReducedBlockCommandsDevice, 2 );
	
protected:

	/*!
	@function SetMediaIcon
	@abstract Sets graphical icon for device's media objects.
	@discussion Provides an opportunity for the driver to select a more fitting icon then default icon. 
	*/
	virtual	void		SetMediaIcon ( void );
	

	/* Added with 10.3.3 */		
	OSMetaClassDeclareReservedUsed ( IOSCSIReducedBlockCommandsDevice, 3 );
	
protected:

	/*!
	@function AsyncReadWriteCompletion
	@abstract Completion routine for asynchronous read and write requests.
	@discussion Completion routine for asynchronous read and write requests.
	*/
	virtual	void AsyncReadWriteCompletion ( SCSITaskIdentifier completedTask );
	
	
private:
	
	// Space reserved for future expansion.
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice,  4 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice,  5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice,  6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice,  7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice,  8 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice,  9 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 10 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 11 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 12 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSIReducedBlockCommandsDevice, 16 );
	
};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_IO_SCSI_REDUCED_BLOCK_COMMANDS_DEVICE_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                       SCSICmds_INQUIRY_Definitions.h                                                                      0100644 0001750 0001750 00000100665 12567470660 040275  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_INQUIRY_H_
#define _IOKIT_SCSI_CMDS_INQUIRY_H_


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Inquiry Definitions
	@discussion
	This file contains all definitions for the data returned from
	the INQUIRY (0x12) command.
*/


/*!
 * @enum Payload sizes
 * @discussion
 * Definitions for sizes related to the INQUIRY data.
 * @constant kINQUIRY_StandardDataHeaderSize
 * INQUIRY data header size.
 * @constant kINQUIRY_MaximumDataSize
 * Maximum size for INQUIRY data.
*/
enum
{
	kINQUIRY_StandardDataHeaderSize			= 5,
	kINQUIRY_MaximumDataSize				= 255	
};


/*!
@enum INQUIRY field sizes
@discussion
Sizes for some of the inquiry data fields.
@constant kINQUIRY_VENDOR_IDENTIFICATION_Length
Size of VENDOR_IDENTIFICATION field.
@constant kINQUIRY_PRODUCT_IDENTIFICATION_Length
Size of PRODUCT_IDENTIFICATION field.
@constant kINQUIRY_PRODUCT_REVISION_LEVEL_Length
Size of PRODUCT_REVISION_LEVEL field.
*/
enum
{
	kINQUIRY_VENDOR_IDENTIFICATION_Length	= 8,
	kINQUIRY_PRODUCT_IDENTIFICATION_Length	= 16,
	kINQUIRY_PRODUCT_REVISION_LEVEL_Length	= 4
};


/*!
@struct SCSICmd_INQUIRY_StandardData
@discussion
This structure defines the format of the required standard data that is 
returned for the INQUIRY command.  This is the data that is required to
be returned from all devices.
*/
typedef struct SCSICmd_INQUIRY_StandardData
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		RMB;								// 7 = removable
	UInt8		VERSION;							// 7/6 = ISO/IEC, 5-3 = ECMA, 2-0 = ANSI.
	UInt8		RESPONSE_DATA_FORMAT;				// 7 = AERC, 6 = Obsolete, 5 = NormACA, 4 = HiSup 3-0 = Response data format. (SPC-3 obsoletes AERC)
													// If ANSI Version = 0, this is ATAPI and bits 7-4 = ATAPI version.
	UInt8		ADDITIONAL_LENGTH;					// Number of additional bytes available in inquiry data
	UInt8		SCCSReserved;						// SCC-2 device flag and reserved fields (SPC-3 adds PROTECT 3PC TPGS, and ACC)
	UInt8		flags1;								// First byte of support flags (See SPC-3 section 6.4.2)
	UInt8		flags2;								// Second byte of support flags (Byte 7) (See SPC-3 section 6.4.2)
	char		VENDOR_IDENTIFICATION[kINQUIRY_VENDOR_IDENTIFICATION_Length];
	char		PRODUCT_IDENTIFICATION[kINQUIRY_PRODUCT_IDENTIFICATION_Length];
	char		PRODUCT_REVISION_LEVEL[kINQUIRY_PRODUCT_REVISION_LEVEL_Length];
} SCSICmd_INQUIRY_StandardData;
typedef SCSICmd_INQUIRY_StandardData * SCSICmd_INQUIRY_StandardDataPtr;


/*!
@struct SCSICmd_INQUIRY_StandardDataAll
@discussion
This structure defines the all of the fields that can be returned in
repsonse to the INQUIRy request for the standard data.  There is no
requirement as to how much of the additional data must be returned by a device.
*/
typedef struct SCSICmd_INQUIRY_StandardDataAll
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		RMB;								// 7 = removable
	UInt8		VERSION;							// 7/6 = ISO/IEC, 5-3 = ECMA, 2-0 = ANSI.
	UInt8		RESPONSE_DATA_FORMAT;				// 7 = AERC, 6 = Obsolete, 5 = NormACA, 4 = HiSup 3-0 = Response data format.
													// If ANSI Version = 0, this is ATAPI and bits 7-4 = ATAPI version.
	UInt8		ADDITIONAL_LENGTH;					// Number of additional bytes available in inquiry data
	UInt8		SCCSReserved;						// SCC-2 device flag and reserved fields
	UInt8		flags1;								// First byte of support flags (Byte 6)
	UInt8		flags2;								// Second byte of support flags (Byte 7)
	char		VENDOR_IDENTIFICATION[kINQUIRY_VENDOR_IDENTIFICATION_Length];
	char		PRODUCT_IDENTIFICATION[kINQUIRY_PRODUCT_IDENTIFICATION_Length];
	char		PRODUCT_REVISION_LEVEL[kINQUIRY_PRODUCT_REVISION_LEVEL_Length];
	
	// Following is the optional data that may be returned by a device.
	UInt8		VendorSpecific1[20];
	UInt8		flags3;								// Third byte of support flags, mainly SPI-3 (Byte 56)
	UInt8		Reserved1;
	UInt16		VERSION_DESCRIPTOR[8];
	UInt8		Reserved2[22];
	UInt8		VendorSpecific2[160];
} SCSICmd_INQUIRY_StandardDataAll;


/*!
@enum Peripheral Qualifier
@discussion
Inquiry Peripheral Qualifier definitions
@constant kINQUIRY_PERIPHERAL_QUALIFIER_Connected
Peripheral Device is connected.
@constant kINQUIRY_PERIPHERAL_QUALIFIER_SupportedButNotConnected
Peripheral Device is supported, but not connected.
@constant kINQUIRY_PERIPHERAL_QUALIFIER_NotSupported
Peripheral Device is not supported.
@constant kINQUIRY_PERIPHERAL_QUALIFIER_Mask
Mask to use for PERIPHERAL_DEVICE_TYPE field.
*/
enum
{
	kINQUIRY_PERIPHERAL_QUALIFIER_Connected					= 0x00,
	kINQUIRY_PERIPHERAL_QUALIFIER_SupportedButNotConnected	= 0x20,
	kINQUIRY_PERIPHERAL_QUALIFIER_NotSupported				= 0x60,
	kINQUIRY_PERIPHERAL_QUALIFIER_Mask						= 0xE0
};


/*!
@enum Peripheral Device types
@discussion
Inquiry Peripheral Device type definitions
@constant kINQUIRY_PERIPHERAL_TYPE_DirectAccessSBCDevice
SBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_SequentialAccessSSCDevice
Sequential Access (Tape) SSC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_PrinterSSCDevice
SSC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_ProcessorSPCDevice
SPC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_WriteOnceSBCDevice
SBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_CDROM_MMCDevice
MMC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_ScannerSCSI2Device
SCSI2 Device.
@constant kINQUIRY_PERIPHERAL_TYPE_OpticalMemorySBCDevice
SBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_MediumChangerSMCDevice
SMC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_CommunicationsSSCDevice
Comms SSC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_StorageArrayControllerSCC2Device
SCC2 Device.
@constant kINQUIRY_PERIPHERAL_TYPE_EnclosureServicesSESDevice
SES Device.
@constant kINQUIRY_PERIPHERAL_TYPE_SimplifiedDirectAccessRBCDevice
RBC Device.
@constant kINQUIRY_PERIPHERAL_TYPE_OpticalCardReaderOCRWDevice
OCRW Device.
@constant kINQUIRY_PERIPHERAL_TYPE_ObjectBasedStorageDevice
OSD device.
@constant kINQUIRY_PERIPHERAL_TYPE_AutomationDriveInterface
Automation Drive Interface device.
@constant kINQUIRY_PERIPHERAL_TYPE_WellKnownLogicalUnit
Well known logical unit.
@constant kINQUIRY_PERIPHERAL_TYPE_UnknownOrNoDeviceType
Unknown or no device.
@constant kINQUIRY_PERIPHERAL_TYPE_Mask
Mask to use for PERIPHERAL_DEVICE_TYPE field.
*/
enum
{
	kINQUIRY_PERIPHERAL_TYPE_DirectAccessSBCDevice				= 0x00,
	kINQUIRY_PERIPHERAL_TYPE_SequentialAccessSSCDevice			= 0x01,
	kINQUIRY_PERIPHERAL_TYPE_PrinterSSCDevice					= 0x02,
	kINQUIRY_PERIPHERAL_TYPE_ProcessorSPCDevice					= 0x03,
	kINQUIRY_PERIPHERAL_TYPE_WriteOnceSBCDevice					= 0x04,
	kINQUIRY_PERIPHERAL_TYPE_CDROM_MMCDevice					= 0x05,
	kINQUIRY_PERIPHERAL_TYPE_ScannerSCSI2Device					= 0x06,
	kINQUIRY_PERIPHERAL_TYPE_OpticalMemorySBCDevice				= 0x07,
	kINQUIRY_PERIPHERAL_TYPE_MediumChangerSMCDevice				= 0x08,
	kINQUIRY_PERIPHERAL_TYPE_CommunicationsSSCDevice			= 0x09,
	/* 0x0A - 0x0B ASC IT8 Graphic Arts Prepress Devices */
	kINQUIRY_PERIPHERAL_TYPE_StorageArrayControllerSCC2Device	= 0x0C,
	kINQUIRY_PERIPHERAL_TYPE_EnclosureServicesSESDevice			= 0x0D,
	kINQUIRY_PERIPHERAL_TYPE_SimplifiedDirectAccessRBCDevice	= 0x0E,
	kINQUIRY_PERIPHERAL_TYPE_OpticalCardReaderOCRWDevice		= 0x0F,
	/* 0x10 - 0x1E Reserved Device Types */
	kINQUIRY_PERIPHERAL_TYPE_ObjectBasedStorageDevice			= 0x11,
	kINQUIRY_PERIPHERAL_TYPE_AutomationDriveInterface			= 0x12,
	kINQUIRY_PERIPHERAL_TYPE_WellKnownLogicalUnit				= 0x1E,
	kINQUIRY_PERIPHERAL_TYPE_UnknownOrNoDeviceType				= 0x1F,
	
	
	kINQUIRY_PERIPHERAL_TYPE_Mask								= 0x1F
};


/*!
@enum Removable Bit field definitions
@discussion
Inquiry Removable Bit field definitions
@constant kINQUIRY_PERIPHERAL_RMB_MediumFixed
Medium type is fixed disk.
@constant kINQUIRY_PERIPHERAL_RMB_MediumRemovable
Medium type is removable disk.
@constant kINQUIRY_PERIPHERAL_RMB_BitMask
Mask to use for RMB field.
*/
enum
{
	kINQUIRY_PERIPHERAL_RMB_MediumFixed 						= 0x00,
	kINQUIRY_PERIPHERAL_RMB_MediumRemovable 					= 0x80,
	kINQUIRY_PERIPHERAL_RMB_BitMask 							= 0x80
};


/*!
@enum Version field definitions
@discussion
Definitions for bits/masks in the INQUIRY Version field.
@constant kINQUIRY_ISO_IEC_VERSION_Mask
Mask for valid bits for ISO/IEC Version.
@constant kINQUIRY_ECMA_VERSION_Mask
Mask for valid bits for ECMA Version.
@constant kINQUIRY_ANSI_VERSION_NoClaimedConformance
No ANSI conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_1_Compliant
SCSI-1 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_2_Compliant
SCSI-2 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_SPC_Compliant
SPC conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_SPC_2_Compliant
SPC-2 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_SCSI_SPC_3_Compliant
SPC-3 conformance claimed by the device server.
@constant kINQUIRY_ANSI_VERSION_Mask
Mask for valid bits for ANSI Version.
*/
enum
{
	kINQUIRY_ISO_IEC_VERSION_Mask								= 0xC0,
	
	kINQUIRY_ECMA_VERSION_Mask									= 0x38,
	
	kINQUIRY_ANSI_VERSION_NoClaimedConformance					= 0x00,
	kINQUIRY_ANSI_VERSION_SCSI_1_Compliant						= 0x01,
	kINQUIRY_ANSI_VERSION_SCSI_2_Compliant						= 0x02,
	kINQUIRY_ANSI_VERSION_SCSI_SPC_Compliant					= 0x03,
	kINQUIRY_ANSI_VERSION_SCSI_SPC_2_Compliant					= 0x04,
	kINQUIRY_ANSI_VERSION_SCSI_SPC_3_Compliant					= 0x05,
	kINQUIRY_ANSI_VERSION_Mask									= 0x07
};


/*!
@enum Response Data Format field definitions
@discussion
Definitions for bits/masks in the INQUIRY RESPONSE_DATA_FORMAT field.
@constant kINQUIRY_Byte3_HISUP_Bit
HISUP bit definition.
@constant kINQUIRY_Byte3_NORMACA_Bit
NORMACA bit definition.
@constant kINQUIRY_Byte3_AERC_Bit
AERC bit definition.
@constant kINQUIRY_RESPONSE_DATA_FORMAT_Mask
Mask for valid bits for RESPONSE_DATA_FORMAT.
@constant kINQUIRY_Byte3_HISUP_Mask
Mask to use to test the HISUP bit.
@constant kINQUIRY_Byte3_NORMACA_Mask
Mask to use to test the NORMACA bit.
@constant kINQUIRY_Byte3_AERC_Mask
Mask to use to test the AERC bit.
*/
enum
{
	// Bit definitions
	// Bits 0-3: RESPONSE DATA FORMAT
	kINQUIRY_Byte3_HISUP_Bit				= 4,
	kINQUIRY_Byte3_NORMACA_Bit				= 5,
	// Bit 6 is Obsolete
	kINQUIRY_Byte3_AERC_Bit					= 7,
	
	// Masks
	kINQUIRY_RESPONSE_DATA_FORMAT_Mask		= 0x0F, // Bits 0-3
	kINQUIRY_Byte3_HISUP_Mask				= (1 << kINQUIRY_Byte3_HISUP_Bit),
	kINQUIRY_Byte3_NORMACA_Mask				= (1 << kINQUIRY_Byte3_NORMACA_Bit),
	// Bit 6 is Obsolete
	kINQUIRY_Byte3_AERC_Mask				= (1 << kINQUIRY_Byte3_AERC_Bit)
};


/*!
@enum SCCS field definitions
@discussion
Definitions for bits/masks in the INQUIRY SCCSReserved field.
@constant kINQUIRY_Byte5_SCCS_Bit
SCCS bit definition.
@constant kINQUIRY_Byte5_ACC_Bit
ACC bit definition.
@constant kINQUIRY_Byte5_ExplicitTPGS_Bit
Explicit TPGS bit definition.
@constant kINQUIRY_Byte5_ImplicitTPGS_Bit
Implicit TPGS bit definition.
@constant kINQUIRY_Byte5_3PC_Bit
3PC bit definition.
@constant kINQUIRY_Byte5_PROTECT_Bit
PROTECT bit definition.
@constant kINQUIRY_Byte5_SCCS_Mask
Mask to use to test the SCCS bit.
@constant kINQUIRY_Byte5_ACC_Mask
Mask to use to test the ACC bit.
@constant kINQUIRY_Byte5_ExplicitTPGS_Mask
Mask to use for the Explicit TPGS bits.
@constant kINQUIRY_Byte5_ImplicitTPGS_Mask
Mask to use for the Implicit TPGS bits.
@constant kINQUIRY_Byte5_3PC_Mask
Mask to use to test the 3PC bit.
@constant kINQUIRY_Byte5_PROTECT_Mask
Mask to use to test the PROTECT bit.
*/
enum
{
	// Bit definitions
	kINQUIRY_Byte5_SCCS_Bit					= 7,
	kINQUIRY_Byte5_ACC_Bit					= 6,
	kINQUIRY_Byte5_ExplicitTPGS_Bit			= 5,
	kINQUIRY_Byte5_ImplicitTPGS_Bit			= 4,
	kINQUIRY_Byte5_3PC_Bit					= 3,
	// Bits 1-2: Reserved
	kINQUIRY_Byte5_PROTECT_Bit				= 0,
	
	// Masks
	kINQUIRY_Byte5_SCCS_Mask				= (1 << kINQUIRY_Byte5_SCCS_Bit),
	kINQUIRY_Byte5_ACC_Mask					= (1 << kINQUIRY_Byte5_ACC_Bit),
	kINQUIRY_Byte5_ExplicitTPGS_Mask		= (1 << kINQUIRY_Byte5_ExplicitTPGS_Bit),
	kINQUIRY_Byte5_ImplicitTPGS_Mask		= (1 << kINQUIRY_Byte5_ImplicitTPGS_Bit),

	kINQUIRY_Byte5_3PC_Mask					= (1 << kINQUIRY_Byte5_3PC_Bit),
	// Bits 1-2: Reserved
	kINQUIRY_Byte5_PROTECT_Mask				= (1 << kINQUIRY_Byte5_PROTECT_Bit)
};


/*!
@enum flags1 field definitions
@discussion
Definitions for bits/masks in the INQUIRY flags1 field.
@constant kINQUIRY_Byte6_ADDR16_Bit
ADDR16 bit definition.
@constant kINQUIRY_Byte6_MCHNGR_Bit
MCHNGR bit definition.
@constant kINQUIRY_Byte6_MULTIP_Bit
MULTIP bit definition.
@constant kINQUIRY_Byte6_VS_Bit
VS bit definition.
@constant kINQUIRY_Byte6_ENCSERV_Bit
ENCSERV bit definition.
@constant kINQUIRY_Byte6_BQUE_Bit
BQUE bit definition.
@constant kINQUIRY_Byte6_ADDR16_Mask
Mask to use to test the ADDR16 bit.
@constant kINQUIRY_Byte6_MCHNGR_Mask
Mask to use to test the MCHNGR bit.
@constant kINQUIRY_Byte6_MULTIP_Mask
Mask to use to test the MULTIP bit.
@constant kINQUIRY_Byte6_VS_Mask
Mask to use to test the VS bit.
@constant kINQUIRY_Byte6_ENCSERV_Mask
Mask to use to test the ENCSERV bit.
@constant kINQUIRY_Byte6_BQUE_Mask
Mask to use to test the BQUE bit.
*/
enum
{
	// Byte offset
	kINQUIRY_Byte6_Offset					= 6,
	
	// Bit definitions
	kINQUIRY_Byte6_ADDR16_Bit				= 0,	// SPI Specific
	// Bit 1 is Obsolete
	// Bit 2 is Obsolete
	kINQUIRY_Byte6_MCHNGR_Bit				= 3,
	kINQUIRY_Byte6_MULTIP_Bit				= 4,
	kINQUIRY_Byte6_VS_Bit					= 5,	
	kINQUIRY_Byte6_ENCSERV_Bit				= 6,	
	kINQUIRY_Byte6_BQUE_Bit					= 7,	

	// Masks
	kINQUIRY_Byte6_ADDR16_Mask				= (1 << kINQUIRY_Byte6_ADDR16_Bit),	// SPI Specific
	// Bit 1 is Obsolete
	// Bit 2 is Obsolete
	kINQUIRY_Byte6_MCHNGR_Mask				= (1 << kINQUIRY_Byte6_MCHNGR_Bit),
	kINQUIRY_Byte6_MULTIP_Mask				= (1 << kINQUIRY_Byte6_MULTIP_Bit),
	kINQUIRY_Byte6_VS_Mask					= (1 << kINQUIRY_Byte6_VS_Bit),
	kINQUIRY_Byte6_ENCSERV_Mask				= (1 << kINQUIRY_Byte6_ENCSERV_Bit),
	kINQUIRY_Byte6_BQUE_Mask				= (1 << kINQUIRY_Byte6_BQUE_Bit)
};


/*!
@enum flags2 field definitions
@discussion
Definitions for bits/masks in the INQUIRY flags2 field.
@constant kINQUIRY_Byte7_VS_Bit
VS bit definition.
@constant kINQUIRY_Byte7_CMDQUE_Bit
CMDQUE bit definition.
@constant kINQUIRY_Byte7_TRANDIS_Bit
TRANDIS bit definition.
@constant kINQUIRY_Byte7_LINKED_Bit
LINKED bit definition.
@constant kINQUIRY_Byte7_SYNC_Bit
SYNC bit definition.
@constant kINQUIRY_Byte7_WBUS16_Bit
WBUS16 bit definition.
@constant kINQUIRY_Byte7_RELADR_Bit
RELADR bit definition.
@constant kINQUIRY_Byte7_VS_Mask
Mask to use to test the VS bit.
@constant kINQUIRY_Byte7_CMDQUE_Mask
Mask to use to test the CMDQUE bit.
@constant kINQUIRY_Byte7_TRANDIS_Mask
Mask to use to test the TRANDIS bit.
@constant kINQUIRY_Byte7_LINKED_Mask
Mask to use to test the LINKED bit.
@constant kINQUIRY_Byte7_SYNC_Mask
Mask to use to test the SYNC bit.
@constant kINQUIRY_Byte7_WBUS16_Mask
Mask to use to test the WBUS16 bit.
@constant kINQUIRY_Byte7_RELADR_Mask
Mask to use to test the RELADR bit.
*/
enum
{
	// Byte offset
	kINQUIRY_Byte7_Offset					= 7,
	
	// Bit definitions
	kINQUIRY_Byte7_VS_Bit					= 0,
	kINQUIRY_Byte7_CMDQUE_Bit				= 1,
	kINQUIRY_Byte7_TRANDIS_Bit				= 2,	// SPI Specific
	kINQUIRY_Byte7_LINKED_Bit				= 3,
	kINQUIRY_Byte7_SYNC_Bit					= 4,	// SPI Specific
	kINQUIRY_Byte7_WBUS16_Bit				= 5,	// SPI Specific
	// Bit 6 is Obsolete
	kINQUIRY_Byte7_RELADR_Bit				= 7,
	
	// Masks
	kINQUIRY_Byte7_VS_Mask					= (1 << kINQUIRY_Byte7_VS_Bit),
	kINQUIRY_Byte7_CMDQUE_Mask				= (1 << kINQUIRY_Byte7_CMDQUE_Bit),
	kINQUIRY_Byte7_TRANDIS_Mask				= (1 << kINQUIRY_Byte7_TRANDIS_Bit),// SPI Specific
	kINQUIRY_Byte7_LINKED_Mask				= (1 << kINQUIRY_Byte7_LINKED_Bit),
	kINQUIRY_Byte7_SYNC_Mask				= (1 << kINQUIRY_Byte7_SYNC_Bit),	// SPI Specific
	kINQUIRY_Byte7_WBUS16_Mask				= (1 << kINQUIRY_Byte7_WBUS16_Bit),	// SPI Specific
	// Bit 6 is Obsolete
	kINQUIRY_Byte7_RELADR_Mask				= (1 << kINQUIRY_Byte7_RELADR_Bit)
};


/*!
@enum Byte 56 features field definitions
@discussion
Definitions for bits/masks in the INQUIRY Byte 56 field.
Inquiry Byte 56 features (for devices that report an ANSI VERSION of
kINQUIRY_ANSI_VERSION_SCSI_SPC_Compliant or later).
These are SPI-3 Specific.
@constant kINQUIRY_Byte56_IUS_Bit
IUS bit definition.
@constant kINQUIRY_Byte56_QAS_Bit
QAS bit definition.
@constant kINQUIRY_Byte56_IUS_Mask
Mask to use to test the IUS bit.
@constant kINQUIRY_Byte56_QAS_Mask
Mask to use to test the QAS bit.
@constant kINQUIRY_Byte56_CLOCKING_Mask
Mask to use to test CLOCKING bits.
@constant kINQUIRY_Byte56_CLOCKING_ONLY_ST
Single-transition clocking only.
@constant kINQUIRY_Byte56_CLOCKING_ONLY_DT
Double-transition clocking only.
@constant kINQUIRY_Byte56_CLOCKING_ST_AND_DT
Single-transition and double-transition clocking.
*/
enum
{
	// Byte offset
	kINQUIRY_Byte56_Offset					= 56,

	// Bit definitions
	kINQUIRY_Byte56_IUS_Bit					= 0,
	kINQUIRY_Byte56_QAS_Bit					= 1,
	// Bits 2 and 3 are the CLOCKING bits
	// All other bits are reserved
	
	kINQUIRY_Byte56_IUS_Mask				= (1 << kINQUIRY_Byte56_IUS_Bit),
	kINQUIRY_Byte56_QAS_Mask				= (1 << kINQUIRY_Byte56_QAS_Bit),
	kINQUIRY_Byte56_CLOCKING_Mask			= 0x0C,

	// Definitions for the CLOCKING bits
	kINQUIRY_Byte56_CLOCKING_ONLY_ST		= 0x00,
	kINQUIRY_Byte56_CLOCKING_ONLY_DT		= 0x04,
	// kINQUIRY_Byte56_CLOCKING_RESERVED	= 0x08,
	kINQUIRY_Byte56_CLOCKING_ST_AND_DT		= 0x0C
};


/*!
@define kINQUIRY_VERSION_DESCRIPTOR_MaxCount
Maximum number of INQUIRY version descriptors supported.
*/
#define	kINQUIRY_VERSION_DESCRIPTOR_MaxCount		8


/*!
@enum kINQUIRY_VERSION_DESCRIPTOR_SAT
SAT specification version descriptor.
*/
enum
{
	kINQUIRY_VERSION_DESCRIPTOR_SAT					= 0x1EA0
};

/*!
 @enum kINQUIRY_VERSION_DESCRIPTOR_NVME
 NVMe specification version descriptor.
 */
enum
{
	kINQUIRY_VERSION_DESCRIPTOR_NVME				= 0x8080
};


/*
IORegistry property names for information derived from the Inquiry data.
The Peripheral Device Type is the only property that the 
generic Logical Unit Drivers will use to match. These properties are
listed in order of matching priority. First is the Peripheral Device Type.
Second is the Vendor Identification. Third is the Product Identification.
Last is the Product Revision Level. To match a particular product, you would
specify the Peripheral Device Type, Vendor Identification, and Product
Identification. To restrict the match to a particular firmware revision, you
would add the Product Revision Level. To not match on a particular product,
but on a particular vendor's products, you would only include the 
Peripheral Device Type and the Vendor Identification.
*/

/*!
@define kIOPropertySCSIPeripheralDeviceType
SCSI Peripheral Device Type as reported in the INQUIRY data.
*/
#define kIOPropertySCSIPeripheralDeviceType			"Peripheral Device Type"

/*!
@define kIOPropertySCSIPeripheralDeviceTypeSize
Size of the kIOPropertySCSIPeripheralDeviceType key.
*/
#define kIOPropertySCSIPeripheralDeviceTypeSize		8

/*!
@define kIOPropertyTPGSInfo
TPGS Info as reported in the INQUIRY data.
*/
#define kIOPropertyTPGSInfo							"TPGS Information"

/*!
@define kIOPropertyHiSup
Hierarchical LUN Support as reported in the INQUIRY data.
*/
#define kIOPropertyHiSup							"Hierarchical LUN Support"

/*!
@define kIOPropertyTPGSInfoSize
Size of the kIOPropertyTPGSInfo key.
*/
#define kIOPropertyTPGSInfoSize						8

/* These properties are listed in order of matching priority */

/*!
@define kIOPropertySCSIVendorIdentification
Vendor ID as reported in the INQUIRY data. Additional space characters (0x20)
are truncated.
*/
#define kIOPropertySCSIVendorIdentification			"Vendor Identification"

/*!
@define kIOPropertySCSIProductIdentification
Product ID as reported in the INQUIRY data. Additional space characters (0x20)
are truncated.
*/
#define kIOPropertySCSIProductIdentification		"Product Identification"

/*!
@define kIOPropertySCSIProductRevisionLevel
Product Revision Level as reported in the INQUIRY data.
*/
#define kIOPropertySCSIProductRevisionLevel			"Product Revision Level"


/*!
@enum INQUIRY Page Codes
@discussion INQUIRY Page Codes to be used when EVPD is set in the
INQUIRY command.
@constant kINQUIRY_Page00_PageCode
Page Code 00h.
@constant kINQUIRY_Page80_PageCode
Page Code 80h.
@constant kINQUIRY_Page83_PageCode
Page Code 83h.
@constant kINQUIRY_Page89_PageCode
Page Code 89h.
*/
enum
{
	kINQUIRY_Page00_PageCode				= 0x00,
	kINQUIRY_Page80_PageCode				= 0x80,
	kINQUIRY_Page83_PageCode				= 0x83,
	kINQUIRY_Page89_PageCode				= 0x89,
	kINQUIRY_PageB1_PageCode				= 0xB1
};	


/*!
@struct SCSICmd_INQUIRY_Page00_Header
@discussion INQUIRY Page 00h Header.
*/
typedef struct SCSICmd_INQUIRY_Page00_Header
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 00h
	UInt8		RESERVED;							// reserved field
	UInt8		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page00_Header;


/*!
@struct SCSICmd_INQUIRY_Page00_Header_SPC_16
@discussion INQUIRY Page 00h Header.
*/
typedef struct SCSICmd_INQUIRY_Page00_Header_SPC_16
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 00h
	UInt16		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page00_Header_SPC_16;

/*!
@struct SCSICmd_INQUIRY_Page80_Header
@discussion INQUIRY Page 80h Header.
*/
typedef struct SCSICmd_INQUIRY_Page80_Header
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 80h
	UInt8		RESERVED;							// reserved field
	UInt8		PAGE_LENGTH;						// n-3 bytes
	UInt8		PRODUCT_SERIAL_NUMBER;				// 4-n
} SCSICmd_INQUIRY_Page80_Header;


/*!
@struct SCSICmd_INQUIRY_Page80_Header_SPC_16
@discussion INQUIRY Page 80h Header with 16 bytes INQUIRY Command.
*/
typedef struct SCSICmd_INQUIRY_Page80_Header_SPC_16
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;					// Must be equal to 80h
	UInt16		PAGE_LENGTH;					// n-3 bytes
	UInt8		PRODUCT_SERIAL_NUMBER;				// 4-n
} SCSICmd_INQUIRY_Page80_Header_SPC_16;


/*!
@define kIOPropertySCSIINQUIRYUnitSerialNumber
Key that describes the INQUIRY Unit Serial Number in the IORegistry.
*/
#define kIOPropertySCSIINQUIRYUnitSerialNumber		"INQUIRY Unit Serial Number"


/*!
@struct SCSICmd_INQUIRY_Page83_Header
@discussion INQUIRY Page 83h Header.
*/
typedef struct SCSICmd_INQUIRY_Page83_Header
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 83h
	UInt8		RESERVED;							// reserved field
	UInt8		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page83_Header;


/*!
@struct SCSICmd_INQUIRY_Page83_Header_SPC_16
@discussion INQUIRY Page 83h Header used with the 16 byte INQUIRY command.
*/
typedef struct SCSICmd_INQUIRY_Page83_Header_SPC_16
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 83h
	UInt16		PAGE_LENGTH;						// n-3 bytes
} SCSICmd_INQUIRY_Page83_Header_SPC_16;


/*!
@struct SCSICmd_INQUIRY_Page83_Identification_Descriptor
@discussion INQUIRY Page 83h Identification Descriptor.
*/
typedef struct SCSICmd_INQUIRY_Page83_Identification_Descriptor
{
	UInt8		CODE_SET;							// 7-4 = Protocol Identifier. 3-0 = Code Set
	UInt8		IDENTIFIER_TYPE;					// 7 = PIV 5-4 = ASSOCIATION 3-0 = Identifier
	UInt8		RESERVED;							
	UInt8		IDENTIFIER_LENGTH;
	UInt8		IDENTIFIER;
} SCSICmd_INQUIRY_Page83_Identification_Descriptor;


/*!
@enum INQUIRY Page 83h Code Set
@discussion
Definitions for the Code Set field.
@constant kINQUIRY_Page83_CodeSetBinaryData
The identifier contains binary data.
@constant kINQUIRY_Page83_CodeSetASCIIData
The identifier contains ASCII data.
@constant kINQUIRY_Page83_CodeSetUTF8Data
The identifier contains UTF-8 data.
*/
enum
{
	kINQUIRY_Page83_CodeSetReserved			= 0x0,
	kINQUIRY_Page83_CodeSetBinaryData		= 0x1,
	kINQUIRY_Page83_CodeSetASCIIData		= 0x2,
	kINQUIRY_Page83_CodeSetUTF8Data			= 0x3,
	// 0x4 - 0xF reserved
	kINQUIRY_Page83_CodeSetMask				= 0xF
};	


/*!
@enum INQUIRY Page 83h Association
@discussion
Definitions for the Association field.
@constant kINQUIRY_Page83_AssociationLogicalUnit
Association of the identifier is with the logical unit.
@constant kINQUIRY_Page83_AssociationDevice
Association of the identifier is with the device (same as logical unit in SPC-2).
@constant kINQUIRY_Page83_AssociationTargetPort
Association of the identifier is with the target port.
@constant kINQUIRY_Page83_AssociationTargetDevice
Association of the identifier is with the target device (i.e. all ports).
@constant kINQUIRY_Page83_AssociationMask
Mask to use to determine association.
*/
enum
{	
	// SPC-3 - Association is changed to be specific to 
	// Logical Units
	kINQUIRY_Page83_AssociationLogicalUnit	= 0x00,
	
	// Backwards compatibility for SPC-2
	kINQUIRY_Page83_AssociationDevice 		= kINQUIRY_Page83_AssociationLogicalUnit,
	
	// Association is related to a Target Port
	kINQUIRY_Page83_AssociationTargetPort	= 0x10,
	
	// SPC-3 - Added as specific association to
	// a Target device.
	kINQUIRY_Page83_AssociationTargetDevice	= 0x20,
	
	kINQUIRY_Page83_AssociationMask			= 0x30,
	kINQUIRY_Page83_AssociationShift		= 4
};	
		

/*!
@enum INQUIRY Page 83h Identifier Type
@discussion
Definitions for the Identifier Type field.
@constant kINQUIRY_Page83_IdentifierTypeVendorSpecific
Vendor Specific Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeVendorID
Vendor Specific Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeIEEE_EUI64
EUI-64 Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeNAAIdentifier
NAA Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeRelativePortIdentifier
Relative Target Port Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeTargetPortGroup
Target Port Group Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeLogicalUnitGroup
Logical Unit Group Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeMD5LogicalUnitIdentifier
MD5 Logical Unit Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeSCSINameString
SCSI Name String Identifier Type.
@constant kINQUIRY_Page83_IdentifierTypeMask
Mask to use to determine association.
@constant kINQUIRY_Page83_ProtocolIdentifierValidBit
PIV Bit definition.
@constant kINQUIRY_Page83_ProtocolIdentifierValidMask
Mask to use to determine if PIV is set.
*/
enum
{
	kINQUIRY_Page83_IdentifierTypeVendorSpecific			= 0,
	kINQUIRY_Page83_IdentifierTypeVendorID					= 1,
	kINQUIRY_Page83_IdentifierTypeIEEE_EUI64				= 2,
	kINQUIRY_Page83_IdentifierTypeNAAIdentifier				= 3,
	kINQUIRY_Page83_IdentifierTypeRelativePortIdentifier	= 4,
	kINQUIRY_Page83_IdentifierTypeTargetPortGroup			= 5,
	kINQUIRY_Page83_IdentifierTypeLogicalUnitGroup			= 6,
	kINQUIRY_Page83_IdentifierTypeMD5LogicalUnitIdentifier  = 7,
	kINQUIRY_Page83_IdentifierTypeSCSINameString			= 8,
	// 0x9 - 0xF Reserved
	
	kINQUIRY_Page83_IdentifierTypeMask						= 0xF,
	
	kINQUIRY_Page83_ProtocolIdentifierValidBit				= 7,
	kINQUIRY_Page83_ProtocolIdentifierValidMask				= (1 << kINQUIRY_Page83_ProtocolIdentifierValidBit)
	
};	

// Backwards compatibility
#define kINQUIRY_Page83_IdentifierTypeFCNameIdentifier		kINQUIRY_Page83_IdentifierTypeNAAIdentifier
#define kINQUIRY_Page83_IdentifierTypeUndefined				kINQUIRY_Page83_IdentifierTypeVendorSpecific


/*!
@enum Protocol Identifier values
@discussion
Definitions for the protocol identifier values.
@constant kSCSIProtocolIdentifier_FibreChannel
FibreChannel Protocol Identifier.
@constant kSCSIProtocolIdentifier_ParallelSCSI
Parallel SCSI Protocol Identifier.
@constant kSCSIProtocolIdentifier_SSA
SSA Protocol Identifier.
@constant kSCSIProtocolIdentifier_FireWire
FireWire (IEEE-1394) Protocol Identifier.
@constant kSCSIProtocolIdentifier_RDMA
RDMA Protocol Identifier.
@constant kSCSIProtocolIdentifier_iSCSI
iSCSI Protocol Identifier.
@constant kSCSIProtocolIdentifier_SAS
SAS Protocol Identifier.
@constant kSCSIProtocolIdentifier_ADT
ADT Protocol Identifier.
@constant kSCSIProtocolIdentifier_ATAPI
ATAPI Protocol Identifier.
@constant kSCSIProtocolIdentifier_None
No Protocol Identifier.
*/
enum
{
	kSCSIProtocolIdentifier_FibreChannel					= 0,
	kSCSIProtocolIdentifier_ParallelSCSI					= 1,
	kSCSIProtocolIdentifier_SSA								= 2,
	kSCSIProtocolIdentifier_FireWire						= 3,
	kSCSIProtocolIdentifier_RDMA							= 4,
	kSCSIProtocolIdentifier_iSCSI							= 5,
	kSCSIProtocolIdentifier_SAS								= 6,
	kSCSIProtocolIdentifier_ADT								= 7,
	kSCSIProtocolIdentifier_ATAPI							= 8,
	// 0x9-0xE Reserved
	kSCSIProtocolIdentifier_None							= 0xF
};


/*!
@define kIOPropertySCSIINQUIRYDeviceIdentification
Device Identification key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdentification		"INQUIRY Device Identification"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdCodeSet
Code Set type key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdCodeSet			"Code Set"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdType
Identifier Type key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdType				"Identifier Type"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdAssociation
Association key.
*/
#define kIOPropertySCSIINQUIRYDeviceIdAssociation		"Association"


/*!
@define kIOPropertySCSIINQUIRYDeviceIdentifier
Identifier key (data or string).
*/
#define kIOPropertySCSIINQUIRYDeviceIdentifier			"Identifier"
		



/*!
@struct SCSICmd_INQUIRY_Page83_RelativeTargetPort_Identifier
@discussion INQUIRY Page 83h Relative Target Port Identifier.
*/
typedef struct SCSICmd_INQUIRY_Page83_RelativeTargetPort_Identifier
{
	UInt16		OBSOLETE;
	UInt16		RELATIVE_TARGET_PORT_IDENTIFIER;
} SCSICmd_INQUIRY_Page83_RelativeTargetPort_Identifier;


/*!
@struct SCSICmd_INQUIRY_Page83_TargetPortGroup_Identifier
@discussion INQUIRY Page 83h Target Port Group Identifier.
*/
typedef struct SCSICmd_INQUIRY_Page83_TargetPortGroup_Identifier
{
	UInt16		RESERVED;
	UInt16		TARGET_PORT_GROUP;
} SCSICmd_INQUIRY_Page83_TargetPortGroup_Identifier;


/*!
@struct SCSICmd_INQUIRY_Page83_LogicalUnitGroup_Identifier
@discussion INQUIRY Page 83h Logical Unit Group Identifier.
*/
typedef struct SCSICmd_INQUIRY_Page83_LogicalUnitGroup_Identifier
{
	UInt16		RESERVED;
	UInt16		LOGICAL_UNIT_GROUP;
} SCSICmd_INQUIRY_Page83_LogicalUnitGroup_Identifier;


/*!
@struct SCSICmd_INQUIRY_Page89_Data
@discussion INQUIRY Page 89h data as defined in the SAT 1.0
specification. This section contians all structures and
definitions used by the INQUIRY command in response to a request
for page 89h - ATA information VPD Page.
*/
typedef struct SCSICmd_INQUIRY_Page89_Data
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to 89h
	UInt16		PAGE_LENGTH;						// Must be equal to 238h
	UInt32		Reserved;
	UInt8		SAT_VENDOR_IDENTIFICATION[kINQUIRY_VENDOR_IDENTIFICATION_Length];
	UInt8		SAT_PRODUCT_IDENTIFICATION[kINQUIRY_PRODUCT_IDENTIFICATION_Length];
	UInt8		SAT_PRODUCT_REVISION_LEVEL[kINQUIRY_PRODUCT_REVISION_LEVEL_Length];
	UInt8		ATA_DEVICE_SIGNATURE[20];
	UInt8		COMMAND_CODE;
	UInt8		Reserved2[3];
	UInt8		IDENTIFY_DATA[512];
} SCSICmd_INQUIRY_Page89_Data;


/*!
@struct SCSICmd_INQUIRY_PageB1_Data
@discussion INQUIRY Page B1h data as defined in the SBC 
specification. This section contians all structures and
definitions used by the INQUIRY command in response to a request
for page B1h - Block Device Characteristics VPD Page.
*/
typedef struct SCSICmd_INQUIRY_PageB1_Data
{
	UInt8		PERIPHERAL_DEVICE_TYPE;				// 7-5 = Qualifier. 4-0 = Device type.
	UInt8		PAGE_CODE;							// Must be equal to B1h
	UInt8		Reserved;
	UInt8		PAGE_LENGTH;						// Must be equal to 3Ch
	UInt16		MEDIUM_ROTATION_RATE;	
	UInt8		Reserved2[58];
} SCSICmd_INQUIRY_PageB1_Data;

enum
{
	kINQUIRY_PageB1_Page_Length	= 0x3C
};


/*!
@define kIOPropertySATVendorIdentification
Vendor Identification of the SATL.
*/
#define kIOPropertySATVendorIdentification			"SAT Vendor Identification"


/*!
@define kIOPropertySATProductIdentification
Product Identification of the SATL.
*/
#define kIOPropertySATProductIdentification			"SAT Product Identification"


/*!
@define kIOPropertySATProductRevisonLevel
Product Revision Level of the SATL.
*/
#define kIOPropertySATProductRevisonLevel			"SAT Product Revision Level"


#endif	/* _IOKIT_SCSI_CMDS_INQUIRY_H_ */
                                                                           SCSICmds_MODE_Definitions.h                                                                         0100644 0001750 0001750 00000034741 12567470660 037662  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_MODE_DEFINITIONS_H_
#define _IOKIT_SCSI_CMDS_MODE_DEFINITIONS_H_


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the MODE_SENSE_6 and MODE_SENSE_10 commands.
*/

#pragma pack(1)

/*!
@struct SPCModeParameterHeader6
@discussion
Mode Parameter Header for the MODE_SENSE_6 command.
*/
typedef struct SPCModeParameterHeader6
{
	UInt8		MODE_DATA_LENGTH;
	UInt8		MEDIUM_TYPE;
	UInt8		DEVICE_SPECIFIC_PARAMETER;
	UInt8		BLOCK_DESCRIPTOR_LENGTH;
} SPCModeParameterHeader6;


/*!
@struct SPCModeParameterHeader10
@discussion
Mode Parameter Header for the MODE_SENSE_10 command.
*/
typedef struct SPCModeParameterHeader10
{
	UInt16		MODE_DATA_LENGTH;
	UInt8		MEDIUM_TYPE;
	UInt8		DEVICE_SPECIFIC_PARAMETER;
	UInt8		LONGLBA;
	UInt8		RESERVED;
	UInt16		BLOCK_DESCRIPTOR_LENGTH;
} SPCModeParameterHeader10;


/*!
@enum Long LBA Bitfield definitions
@discussion
Long LBA Bitfield definitions for Mode Parameter Header
for MODE_SENSE_10 command.
@constant kModeSenseParameterHeader10_LongLBABit
Bit to indicate Long LBA block descriptors follow.
@constant kModeSenseParameterHeader10_LongLBAMask
Mask to test for kModeSenseParameterHeader10_LongLBABit.
*/
enum
{
	kModeSenseParameterHeader10_LongLBABit	=  0,
	kModeSenseParameterHeader10_LongLBAMask	=  (1 << kModeSenseParameterHeader10_LongLBABit),
};


/*!
@enum Device Specific Parameter Bitfield definitions
@discussion
SBC definitions for Device Specific Parameter in the
Mode Sense Header Block.
@constant kModeSenseSBCDeviceSpecific_DPOFUABit
Bit to indicate DPO and FUA bits are accepted by the device server.
@constant kModeSenseSBCDeviceSpecific_WriteProtectBit
Bit to indicate medium is write protected.
@constant kModeSenseSBCDeviceSpecific_DPOFUAMask
Mask to test for kModeSenseSBCDeviceSpecific_DPOFUABit.
@constant kModeSenseSBCDeviceSpecific_WriteProtectMask
Mask to test for kModeSenseSBCDeviceSpecific_WriteProtectBit.
*/
enum
{
	kModeSenseSBCDeviceSpecific_DPOFUABit	 		=  4,
	kModeSenseSBCDeviceSpecific_WriteProtectBit	 	=  7,
	kModeSenseSBCDeviceSpecific_DPOFUAMask 			=  (1 << kModeSenseSBCDeviceSpecific_DPOFUABit),
	kModeSenseSBCDeviceSpecific_WriteProtectMask 	=  (1 << kModeSenseSBCDeviceSpecific_WriteProtectBit)
};


/*!
@struct ModeParameterBlockDescriptor
@discussion
General mode parameter block descriptor.
*/
typedef struct ModeParameterBlockDescriptor
{
	UInt8		DENSITY_CODE;
	UInt8		NUMBER_OF_BLOCKS[3];
	UInt8		RESERVED;
	UInt8		BLOCK_LENGTH[3];
} ModeParameterBlockDescriptor;


/*!
@struct DASDModeParameterBlockDescriptor
@discussion
Direct Access Storage Device mode parameter block descriptor.
*/
typedef struct DASDModeParameterBlockDescriptor
{
	UInt32		NUMBER_OF_BLOCKS;
	UInt8		DENSITY_CODE;
	UInt8		BLOCK_LENGTH[3];
} DASDModeParameterBlockDescriptor;


/*!
@struct LongLBAModeParameterBlockDescriptor
@discussion
Long LBA mode parameter block descriptor.
*/
typedef struct LongLBAModeParameterBlockDescriptor
{
	UInt64		NUMBER_OF_BLOCKS;
	UInt8		DENSITY_CODE;
	UInt8		RESERVED[3];
	UInt32		BLOCK_LENGTH;
} LongLBAModeParameterBlockDescriptor;


/*!
@struct ModePageFormatHeader
@discussion
Mode Page format header.
*/
typedef struct ModePageFormatHeader
{
	UInt8		PS_PAGE_CODE;
	UInt8		PAGE_LENGTH;
} ModePageFormatHeader;


/*!
@enum Mode Page Format bit definitions
@discussion
Mode Page Format bit definitions.
@constant kModePageFormat_PS_Bit
Bit to indicate Parameters Saveable.
@constant kModePageFormat_PAGE_CODE_Mask
Mask to obtain the PAGE_CODE from the PS_PAGE_CODE field.
@constant kModePageFormat_PS_Mask
Mask to test for kModePageFormat_PS_Bit.
*/
enum
{
	kModePageFormat_PS_Bit			= 7,
	
	kModePageFormat_PAGE_CODE_Mask	= 0x3F,
	kModePageFormat_PS_Mask			= (1 << kModePageFormat_PS_Bit)
};


#if 0
#pragma mark -
#pragma mark SPC Mode Pages
#pragma mark -
#endif


/*!
@enum SPC Mode Pages
@discussion
SPC Mode Page definitions.
@constant kSPCModePagePowerConditionCode
Power Conditions Mode Page value.
@constant kSPCModePageAllPagesCode
All Mode Pages value.
*/
enum
{
	kSPCModePagePowerConditionCode		= 0x1A,
	kSPCModePageAllPagesCode			= 0x3F
};

/*!
@struct SPCModePagePowerCondition
@discussion
Power Conditions Mode Page (PAGE CODE 0x1A) format.
*/
typedef struct SPCModePagePowerCondition
{
	ModePageFormatHeader	header;
	UInt8					RESERVED;
	UInt8					IDLE_STANDBY;
	UInt32					IDLE_CONDITION_TIMER;
	UInt32					STANDBY_CONDITION_TIMER;
} SPCModePagePowerCondition;


#if 0
#pragma mark -
#pragma mark 0x00 SBC Direct Access Mode Pages
#pragma mark -
#endif


/*!
@enum SBC Mode Pages
@discussion
SBC Mode Page definitions.
@constant kSBCModePageFormatDeviceCode
Format Device Mode Page value.
@constant kSBCModePageRigidDiskGeometryCode
Rigid Disk Geometry Page value.
@constant kSBCModePageFlexibleDiskCode
Flexible Disk Page value.
@constant kSBCModePageCachingCode
Caching Page value.
*/
enum
{
	kSBCModePageFormatDeviceCode		= 0x03,
	kSBCModePageRigidDiskGeometryCode	= 0x04,
	kSBCModePageFlexibleDiskCode		= 0x05,
	kSBCModePageCachingCode				= 0x08
};


/*!
@struct SBCModePageFormatDevice
@discussion
Format Device Mode Page (PAGE CODE 0x03) format.
*/
typedef struct SBCModePageFormatDevice
{
	ModePageFormatHeader	header;
	UInt16					TRACKS_PER_ZONE;
	UInt16					ALTERNATE_SECTORS_PER_ZONE;
	UInt16					ALTERNATE_TRACKS_PER_ZONE;
	UInt16					ALTERNATE_TRACKS_PER_LOGICAL_UNIT;
	UInt16					SECTORS_PER_TRACK;
	UInt16					DATA_BYTES_PER_PHYSICAL_SECTOR;
	UInt16					INTERLEAVE;
	UInt16					TRACK_SKEW_FACTOR;
	UInt16					CYLINDER_SKEW_FACTOR;
	UInt8					SSEC_HSEC_RMB_SURF;
	UInt8					RESERVED[3];
} SBCModePageFormatDevice;


/*!
@struct SBCModePageRigidDiskGeometry
@discussion
Rigid Disk Geometry Mode Page (PAGE CODE 0x04) format.
*/
typedef struct SBCModePageRigidDiskGeometry
{
	ModePageFormatHeader	header;
	UInt8					NUMBER_OF_CYLINDERS[3];
	UInt8					NUMBER_OF_HEADS;
	UInt8					STARTING_CYLINDER_WRITE_PRECOMPENSATION[3];
	UInt8					STARTING_CYLINDER_REDUCED_WRITE_CURRENT[3];
	UInt16					DEVICE_STEP_RATE;
	UInt8					LANDING_ZONE_CYLINDER[3];
	UInt8					RPL;
	UInt8					ROTATIONAL_OFFSET;
	UInt8					RESERVED;
	UInt16					MEDIUM_ROTATION_RATE;
	UInt8					RESERVED1[2];
} SBCModePageRigidDiskGeometry;


/*!
@enum Rigid Disk Geometry bitfields
@discussion
Bit field masks for Rigid Disk Geometry structure fields.
@constant kSBCModePageRigidDiskGeometry_RPL_Mask
Mask for use with the RPL field.
*/
enum
{
	kSBCModePageRigidDiskGeometry_RPL_Mask	= 0x03
};


/*!
@struct SBCModePageFlexibleDisk
@discussion
Flexible Disk Mode Page (PAGE CODE 0x05) format.
*/
typedef struct SBCModePageFlexibleDisk
{
	ModePageFormatHeader	header;
	UInt16					TRANSFER_RATE;
	UInt8					NUMBER_OF_HEADS;
	UInt8					SECTORS_PER_TRACK;
	UInt16					DATA_BYTES_PER_SECTOR;
	UInt16					NUMBER_OF_CYLINDERS;
	UInt16					STARTING_CYLINDER_WRITE_PRECOMPENSATION;
	UInt16					STARTING_CYLINDER_REDUCED_WRITE_CURRENT;
	UInt16					DEVICE_STEP_RATE;
	UInt8					DEVICE_STEP_PULSE_WIDTH;
	UInt16					HEAD_SETTLE_DELAY;
	UInt8					MOTOR_ON_DELAY;
	UInt8					MOTOR_OFF_DELAY;
	UInt8					TRDY_SSN_MO;
	UInt8					SPC;
	UInt8					WRITE_COMPENSATION;
	UInt8					HEAD_LOAD_DELAY;
	UInt8					HEAD_UNLOAD_DELAY;
	UInt8					PIN_34_PIN_2;
	UInt8					PIN_4_PIN_1;
	UInt16					MEDIUM_ROTATION_RATE;
	UInt8					RESERVED[2];
} SBCModePageFlexibleDisk;


/*!
@enum TRDY_SSN_MO bitfields
@discussion
Bit field definitions and masks for Flexible Disk TRDY_SSN_MO field.
@constant kSBCModePageFlexibleDisk_MO_Bit
MO Bit definition.
@constant kSBCModePageFlexibleDisk_SSN_Bit
SSN Bit definition.
@constant kSBCModePageFlexibleDisk_TRDY_Bit
TRDY Bit definition.
@constant kSBCModePageFlexibleDisk_MO_Mask
Mask for use with TRDY_SSN_MO field.
@constant kSBCModePageFlexibleDisk_SSN_Mask
Mask for use with TRDY_SSN_MO field.
@constant kSBCModePageFlexibleDisk_TRDY_Mask
Mask for use with TRDY_SSN_MO field.
*/
enum
{
	// Bits 0:4 Reserved
	kSBCModePageFlexibleDisk_MO_Bit		= 5,
	kSBCModePageFlexibleDisk_SSN_Bit	= 6,
	kSBCModePageFlexibleDisk_TRDY_Bit	= 7,
	
	kSBCModePageFlexibleDisk_MO_Mask	= (1 << kSBCModePageFlexibleDisk_MO_Bit),
	kSBCModePageFlexibleDisk_SSN_Mask	= (1 << kSBCModePageFlexibleDisk_SSN_Bit),
	kSBCModePageFlexibleDisk_TRDY_Mask	= (1 << kSBCModePageFlexibleDisk_TRDY_Bit)
};


/*!
@enum SPC bitfields
@discussion
Bit field definitions and masks for Flexible Disk SPC field.
@constant kSBCModePageFlexibleDisk_SPC_Mask
Mask for use with SPC field.
*/
enum
{
	kSBCModePageFlexibleDisk_SPC_Mask	= 0x0F
};


/*!
@enum PIN_34_PIN_2 bitfields
@discussion
Bit field definitions and masks for Flexible Disk PIN_34_PIN_2 field.
@constant kSBCModePageFlexibleDisk_PIN_2_Mask
Mask for use with PIN_34_PIN_2 field.
@constant kSBCModePageFlexibleDisk_PIN_34_Mask
Mask for use with PIN_34_PIN_2 field.
*/
enum
{
	kSBCModePageFlexibleDisk_PIN_2_Mask		= 0x0F,
	kSBCModePageFlexibleDisk_PIN_34_Mask	= 0xF0
};


/*!
@enum PIN_4_PIN_1 bitfields
@discussion
Bit field definitions and masks for Flexible Disk PIN_4_PIN_1 field.
@constant kSBCModePageFlexibleDisk_PIN_1_Mask
Mask for use with PIN_4_PIN_1 field.
@constant kSBCModePageFlexibleDisk_PIN_4_Mask
Mask for use with PIN_4_PIN_1 field.
*/
enum
{
	kSBCModePageFlexibleDisk_PIN_1_Mask		= 0x0F,
	kSBCModePageFlexibleDisk_PIN_4_Mask		= 0xF0
};


/*!
@struct SBCModePageCaching
@discussion
Caching Mode Page (PAGE CODE 0x08) format.
*/
typedef struct SBCModePageCaching
{
	ModePageFormatHeader	header;
	UInt8					flags;
	UInt8					DEMAND_READ_WRITE_RETENTION_PRIORITY;
	UInt16					DISABLE_PREFETCH_TRANSFER_LENGTH;
	UInt16					MINIMUM_PREFETCH;
	UInt16					MAXIMUM_PREFETCH;
	UInt16					MAXIMUM_PREFETCH_CEILING;
	UInt8					flags2;
	UInt8					NUMBER_OF_CACHE_SEGMENTS;
	UInt16					CACHE_SEGMENT_SIZE;
	UInt8					RESERVED;
	UInt8					NON_CACHE_SEGMENT_SIZE[3];
} SBCModePageCaching;


/*!
@enum Caching flags bitfields
@discussion
Bit field definitions and masks for Caching flags field.
@constant kSBCModePageCaching_RCD_Bit
RCD Bit definition.
@constant kSBCModePageCaching_MF_Bit
MF Bit definition.
@constant kSBCModePageCaching_WCE_Bit
WCE Bit definition.
@constant kSBCModePageCaching_SIZE_Bit
SIZE Bit definition.
@constant kSBCModePageCaching_DISC_Bit
DISC Bit definition.
@constant kSBCModePageCaching_CAP_Bit
CAP Bit definition.
@constant kSBCModePageCaching_ABPF_Bit
ABPF Bit definition.
@constant kSBCModePageCaching_IC_Bit
IC Bit definition.
@constant kSBCModePageCaching_RCD_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_MF_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_WCE_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_SIZE_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_DISC_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_CAP_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_ABPF_Mask
Mask for use with flags field.
@constant kSBCModePageCaching_IC_Mask
Mask for use with flags field.
*/
enum
{
	kSBCModePageCaching_RCD_Bit		= 0,
	kSBCModePageCaching_MF_Bit		= 1,
	kSBCModePageCaching_WCE_Bit		= 2,
	kSBCModePageCaching_SIZE_Bit	= 3,
	kSBCModePageCaching_DISC_Bit	= 4,
	kSBCModePageCaching_CAP_Bit		= 5,
	kSBCModePageCaching_ABPF_Bit	= 6,
	kSBCModePageCaching_IC_Bit		= 7,

	kSBCModePageCaching_RCD_Mask	= (1 << kSBCModePageCaching_RCD_Bit),
	kSBCModePageCaching_MF_Mask		= (1 << kSBCModePageCaching_MF_Bit),
	kSBCModePageCaching_WCE_Mask	= (1 << kSBCModePageCaching_WCE_Bit),
	kSBCModePageCaching_SIZE_Mask	= (1 << kSBCModePageCaching_SIZE_Bit),
	kSBCModePageCaching_DISC_Mask	= (1 << kSBCModePageCaching_DISC_Bit),
	kSBCModePageCaching_CAP_Mask	= (1 << kSBCModePageCaching_CAP_Bit),
	kSBCModePageCaching_ABPF_Mask	= (1 << kSBCModePageCaching_ABPF_Bit),
	kSBCModePageCaching_IC_Mask		= (1 << kSBCModePageCaching_IC_Bit)
};


/*!
@enum Demand Read/Write Retention masks
@discussion
Demand Read/Write Retention masks.
@constant kSBCModePageCaching_DEMAND_WRITE_Mask
Mask for the DEMAND_READ_WRITE_RETENTION_PRIORITY field.
@constant kSBCModePageCaching_DEMAND_READ_Mask
Mask for the DEMAND_READ_WRITE_RETENTION_PRIORITY field.
*/
enum
{
	kSBCModePageCaching_DEMAND_WRITE_Mask	= 0x00FF,
	kSBCModePageCaching_DEMAND_READ_Mask 	= 0xFF00
};

/*!
@enum Caching flags2 bitfields
@discussion
Bit field definitions and masks for Caching flags2 field.
@constant kSBCModePageCaching_VS1_Bit
VS1 Bit definition.
@constant kSBCModePageCaching_VS2_Bit
VS2 Bit definition.
@constant kSBCModePageCaching_DRA_Bit
DRA Bit definition.
@constant kSBCModePageCaching_LBCSS_Bit
LBCSS Bit definition.
@constant kSBCModePageCaching_FSW_Bit
FSW Bit definition.
@constant kSBCModePageCaching_VS1_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_VS2_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_DRA_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_LBCSS_Mask
Mask for use with flags2 field.
@constant kSBCModePageCaching_FSW_Mask
Mask for use with flags2 field.
*/
enum
{
	// Bits 0:2 Reserved
	kSBCModePageCaching_VS1_Bit		= 3,
	kSBCModePageCaching_VS2_Bit		= 4,
	kSBCModePageCaching_DRA_Bit		= 5,
	kSBCModePageCaching_LBCSS_Bit	= 6,
	kSBCModePageCaching_FSW_Bit		= 7,

	kSBCModePageCaching_VS1_Mask	= (1 << kSBCModePageCaching_VS1_Bit),
	kSBCModePageCaching_VS2_Mask	= (1 << kSBCModePageCaching_VS2_Bit),
	kSBCModePageCaching_DRA_Mask	= (1 << kSBCModePageCaching_DRA_Bit),
	kSBCModePageCaching_LBCSS_Mask	= (1 << kSBCModePageCaching_LBCSS_Bit),
	kSBCModePageCaching_FSW_Mask	= (1 << kSBCModePageCaching_FSW_Bit)
};

#pragma options align=reset

#endif	/* _IOKIT_SCSI_CMDS_MODE_DEFINITIONS_H_ */
                               SCSICmds_READ_CAPACITY_Definitions.h                                                                0100644 0001750 0001750 00000007072 12567470660 041123  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_READ_CAPACITY_H_
#define _IOKIT_SCSI_CMDS_READ_CAPACITY_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the READ CAPACITY 10 (0x25) and READ CAPACITY 16 (0x9E) commands.
*/

/*!
@enum READ CAPACITY Payload Sizes
@discussion
Sizes of the payload for the READ CAPACITY 10 and
READ CAPACITY 16 commands.
@constant kREPORT_CAPACITY_DataSize
Data size for a READ_CAPACITY command.
@constant kREPORT_CAPACITY_16_DataSize
Data size for a READ_CAPACITY_16 command.
*/
enum
{
	kREPORT_CAPACITY_DataSize		= 8,
	kREPORT_CAPACITY_16_DataSize	= 32
};


/*!
@constant kREPORT_CAPACITY_MaximumLBA
@discussion
Maximum LBA supported via READ CAPACITY 10 command.
*/
#define 	kREPORT_CAPACITY_MaximumLBA			0xFFFFFFFFUL


/*!
@constant kREPORT_CAPACITY_16_MaximumLBA
@discussion
Maximum LBA supported via READ CAPACITY 16 command.
*/
#define 	kREPORT_CAPACITY_16_MaximumLBA		0xFFFFFFFFFFFFFFFFULL


/*!
@struct SCSI_Capacity_Data
@discussion
Capacity return structure for READ CAPACITY 10 command.
*/
typedef struct SCSI_Capacity_Data
{
	UInt32		RETURNED_LOGICAL_BLOCK_ADDRESS;
	UInt32		BLOCK_LENGTH_IN_BYTES;
} SCSI_Capacity_Data;


/*!
@struct SCSI_Capacity_Data_Long
@discussion
Capacity return structure for READ CAPACITY 16 command.
*/
typedef struct SCSI_Capacity_Data_Long
{
	UInt64		RETURNED_LOGICAL_BLOCK_ADDRESS;
	UInt32		BLOCK_LENGTH_IN_BYTES;
	UInt8		RTO_EN_PROT_EN;
	UInt8		Reserved[19];
} SCSI_Capacity_Data_Long;


/*!
@enum RTO_EN definitions
@discussion
Values for the REFERENCE TAG OWN (RTO_EN) bit in the
READ CAPACITY Long Data structure.
@constant kREAD_CAPACITY_RTO_Enabled
Reference Tag Own enabled.
@constant kREAD_CAPACITY_RTO_Disabled
Reference Tag Own disabled.
@constant kREAD_CAPACITY_RTO_Mask
Mask to use when checking the RTO_EN_PROT_EN field.
*/
enum
{
	kREAD_CAPACITY_RTO_Enabled								= 0x02,
	kREAD_CAPACITY_RTO_Disabled								= 0x00,
	kREAD_CAPACITY_RTO_Mask									= 0x02
};


/*!
@enum PROTECTION INFORMATION definitions
@discussion
Values for the PROTECTION INFORMATION (PROT_EN) bit in the
READ CAPACITY Long Data structure.
@constant kREAD_CAPACITY_PROT_Enabled
Protection Information enabled.
@constant kREAD_CAPACITY_PROT_Disabled
Protection Information disabled.
@constant kREAD_CAPACITY_PROT_Mask
Mask to use when checking the RTO_EN_PROT_EN field.
*/

enum
{
	kREAD_CAPACITY_PROT_Enabled								= 0x01,
	kREAD_CAPACITY_PROT_Disabled							= 0x00,
	kREAD_CAPACITY_PROT_Mask								= 0x01
};


#endif	/* _IOKIT_SCSI_CMDS_READ_CAPACITY_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      SCSICmds_REPORT_LUNS_Definitions.h                                                                  0100644 0001750 0001750 00000010156 12567470660 041004  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 2004-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_REPORT_LUNS_DEFINITIONS_H_
#define _IOKIT_SCSI_CMDS_REPORT_LUNS_DEFINITIONS_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the REPORT_LUNS (0xA0) command.
*/


/*!
@struct SCSICmd_REPORT_LUNS_LUN_ENTRY
@discussion
This structure represents a single LUN entry in a LUN list
returned via the REPORT_LUNS command.
*/
typedef struct SCSICmd_REPORT_LUNS_LUN_ENTRY
{
	UInt16		FIRST_LEVEL_ADDRESSING;
	UInt16		SECOND_LEVEL_ADDRESSING;
	UInt16		THIRD_LEVEL_ADDRESSING;
	UInt16		FOURTH_LEVEL_ADDRESSING;
} SCSICmd_REPORT_LUNS_LUN_ENTRY;


/*!
@constant kREPORT_LUNS_HeaderSize
@discussion
Size of the REPORT_LUNS header as defined in the SPC-3 specification.
*/
#define kREPORT_LUNS_HeaderSize		8

/*!
@enum REPORT_LUNS addressing methods.
@discussion
REPORT_LUNS addressing methods described in
SAM-2 documents.
@constant kREPORT_LUNS_ADDRESS_METHOD_PERIPHERAL_DEVICE
Peripheral Device Addressing Method.
@constant kREPORT_LUNS_ADDRESS_DEVICE_TYPE_SPECIFIC
Device Type Specific Addressing Method.
@constant kREPORT_LUNS_ADDRESS_METHOD_LOGICAL_UNIT
Logical Unit Specific Addressing Method.
@constant kREPORT_LUNS_ADDRESS_METHOD_OFFSET
Offset to the address method data.
*/
enum
{
	kREPORT_LUNS_ADDRESS_METHOD_PERIPHERAL_DEVICE	= 0,
	kREPORT_LUNS_ADDRESS_METHOD_FLAT_SPACE			= 1,
	kREPORT_LUNS_ADDRESS_DEVICE_TYPE_SPECIFIC		= kREPORT_LUNS_ADDRESS_METHOD_FLAT_SPACE,
	kREPORT_LUNS_ADDRESS_METHOD_LOGICAL_UNIT 		= 2,
	// Reserved [3]
	kREPORT_LUNS_ADDRESS_METHOD_OFFSET				= 14
};


/*!
@struct REPORT_LUNS_LOGICAL_UNIT_ADDRESSING
@discussion
This structure represents a LUN Addressing scheme.
*/
typedef struct REPORT_LUNS_LOGICAL_UNIT_ADDRESSING
{
#ifdef __LITTLE_ENDIAN__
	UInt16		LUN			: 5;
	UInt16		BUS_NUMBER	: 3;
	UInt16		TARGET		: 6;
	UInt16		reserved2	: 1;
	UInt16		reserved	: 1;
#else /* !__LITTLE_ENDIAN__ */
	UInt16		reserved	: 1;
	UInt16		reserved2	: 1;
	UInt16		TARGET		: 6;
	UInt16		BUS_NUMBER	: 3;
	UInt16		LUN			: 5;
#endif /* !__LITTLE_ENDIAN__ */
} REPORT_LUNS_LOGICAL_UNIT_ADDRESSING;


/*!
@struct REPORT_LUNS_PERIPHERAL_DEVICE_ADDRESSING
@discussion
This structure represents a Peripheral Device Addressing scheme.
*/
typedef struct REPORT_LUNS_PERIPHERAL_DEVICE_ADDRESSING
{
#ifdef __LITTLE_ENDIAN__
	UInt16		TARGET_LUN		: 8;
	UInt16		BUS_IDENTIFIER	: 6;
	UInt16		reserved2		: 1;
	UInt16		reserved		: 1;
#else /* !__LITTLE_ENDIAN__ */
	UInt16		reserved		: 1;
	UInt16		reserved2		: 1;
	UInt16		BUS_IDENTIFIER	: 6;
	UInt16		TARGET_LUN		: 8;
#endif /* !__LITTLE_ENDIAN__ */
} REPORT_LUNS_PERIPHERAL_DEVICE_ADDRESSING;


/*!
@struct SCSICmd_REPORT_LUNS_Header
@discussion
This structure defines the format of the data that is returned for
the REPORT_LUNS command.
*/
typedef struct SCSICmd_REPORT_LUNS_Header
{
	UInt32							LUN_LIST_LENGTH;	// LUN list length in bytes.
	UInt32							RESERVED;
	SCSICmd_REPORT_LUNS_LUN_ENTRY	LUN[1];				// Variable length list. Must have at least LUN 0 if
} SCSICmd_REPORT_LUNS_Header;							// Target supports REPORT_LUNS command.


#endif	/* _IOKIT_SCSI_CMDS_REPORT_LUNS_DEFINITIONS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                  SCSICmds_REQUEST_SENSE_Defs.h                                                                       0100644 0001750 0001750 00000015760 12567470660 037631  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_CMDS_REQUEST_SENSE_H_
#define _IOKIT_SCSI_CMDS_REQUEST_SENSE_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSI Request Sense Definitions
	@discussion
	This file contains all definitions for the data returned from
	the REQUEST SENSE (0x03) command and from auto sense on protocols
	that support it.
*/


/*!
@enum kSenseDefaultSize
@discussion
The default size for SCSI Request Sense data.
*/
enum
{
	kSenseDefaultSize	= 18
};


/*!
@struct SCSI_Sense_Data
@discussion
The basic SCSI Request Sense data structure.
*/
typedef struct SCSI_Sense_Data
{
	UInt8		VALID_RESPONSE_CODE;				// 7 = Valid. 6-0 = Response Code.
	UInt8		SEGMENT_NUMBER;						// Segment number
	UInt8		SENSE_KEY;							// 7 = FILEMARK, 6 = EOM, 5 = ILI, 3-0 = SENSE KEY.
	UInt8		INFORMATION_1;						// INFORMATION.
	UInt8		INFORMATION_2;						// INFORMATION.
	UInt8		INFORMATION_3;						// INFORMATION.
	UInt8		INFORMATION_4;						// INFORMATION.
	UInt8		ADDITIONAL_SENSE_LENGTH;			// Number of additional bytes available in sense data
	UInt8		COMMAND_SPECIFIC_INFORMATION_1;		// Command Specific Information
	UInt8		COMMAND_SPECIFIC_INFORMATION_2;		// Command Specific Information
	UInt8		COMMAND_SPECIFIC_INFORMATION_3;		// Command Specific Information
	UInt8		COMMAND_SPECIFIC_INFORMATION_4;		// Command Specific Information
	UInt8		ADDITIONAL_SENSE_CODE;				// Additional Sense Code
	UInt8		ADDITIONAL_SENSE_CODE_QUALIFIER;	// Additional Sense Code Qualifier
	UInt8		FIELD_REPLACEABLE_UNIT_CODE;		// Field Replaceable Unit Code
	UInt8		SKSV_SENSE_KEY_SPECIFIC_MSB;		// 7 = Sense Key Specific Valid bit, 6-0 Sense Key Specific MSB
	UInt8		SENSE_KEY_SPECIFIC_MID;				// Sense Key Specific Middle
	UInt8		SENSE_KEY_SPECIFIC_LSB;				// Sense Key Specific LSB
} SCSI_Sense_Data;


/*!
@enum Sense Valid
@discussion
Masks to use to determine if sense data is valid or not.
@constant kSENSE_DATA_VALID
Sense data is valid.
@constant kSENSE_NOT_DATA_VALID
Sense data is not valid.
@constant kSENSE_DATA_VALID_Mask
Validity mask to use when checking the VALID_RESPONSE_CODE field.
*/
enum
{
	kSENSE_DATA_VALID										= 0x80,
	kSENSE_NOT_DATA_VALID									= 0x00,
	kSENSE_DATA_VALID_Mask									= 0x80
};


/*!
@enum Sense Response Codes
@discussion
Masks and values to determine the Response Code.
@constant kSENSE_RESPONSE_CODE_Current_Errors
Response code indicating current errors are reported.
@constant kSENSE_RESPONSE_CODE_Deferred_Errors
Response code indicating deferred errors are reported.
@constant kSENSE_RESPONSE_CODE_Mask
Mask to use when checking the VALID_RESPONSE_CODE field.
*/
enum
{
	kSENSE_RESPONSE_CODE_Current_Errors						= 0x70,
	kSENSE_RESPONSE_CODE_Deferred_Errors					= 0x71,
	kSENSE_RESPONSE_CODE_Mask								= 0x7F
};


/*!
@enum FILEMARK bit field definitions
@discussion
Masks and values to determine the FileMark bit field.
@constant kSENSE_FILEMARK_Set
Filemark bit is set.
@constant kSENSE_FILEMARK_Not_Set
Filemark bit is not set.
@constant kSENSE_FILEMARK_Mask
Mask to use when checking the SENSE_KEY field for the FILEMARK bit.
*/
enum
{
	kSENSE_FILEMARK_Set										= 0x80,
	kSENSE_FILEMARK_Not_Set 								= 0x00,
	kSENSE_FILEMARK_Mask 									= 0x80
};


/*!
@enum EOM bit field definitions
@discussion
Masks and values to determine the End Of Medium bit field.
@constant kSENSE_EOM_Set
End Of Medium bit is set.
@constant kSENSE_EOM_Not_Set
End Of Medium bit is not set.
@constant kSENSE_EOM_Mask
Mask to use when checking the SENSE_KEY field for the EOM bit.
*/
enum
{
	kSENSE_EOM_Set											= 0x40,
	kSENSE_EOM_Not_Set 										= 0x00,
	kSENSE_EOM_Mask 										= 0x40
};


/*!
@enum ILI bit field definitions
@discussion
Masks and values to determine the Incorrect Length Indicator bit field.
@constant kSENSE_ILI_Set
Incorrect Length Indicator bit is set.
@constant kSENSE_ILI_Not_Set
Incorrect Length Indicator bit is not set.
@constant kSENSE_ILI_Mask
Mask to use when checking the SENSE_KEY field for the ILI bit.
*/
enum
{
	kSENSE_ILI_Set											= 0x20,
	kSENSE_ILI_Not_Set 										= 0x00,
	kSENSE_ILI_Mask 										= 0x20
};


/*!
@enum Sense Key definitions
@discussion
Masks and values to determine the SENSE_KEY.
@constant kSENSE_KEY_NO_SENSE
No sense data is present.
@constant kSENSE_KEY_RECOVERED_ERROR
A recovered error has occurred.
@constant kSENSE_KEY_NOT_READY
Device server is not ready.
@constant kSENSE_KEY_MEDIUM_ERROR
Device server detected a medium error.
@constant kSENSE_KEY_HARDWARE_ERROR
Device server detected a hardware error.
@constant kSENSE_KEY_ILLEGAL_REQUEST
Device server detected an illegal request.
@constant kSENSE_KEY_UNIT_ATTENTION
Device server indicates a unit attention condition.
@constant kSENSE_KEY_DATA_PROTECT
Device server indicates a data protect condition.
@constant kSENSE_KEY_BLANK_CHECK
Device server indicates a blank check condition.
@constant kSENSE_KEY_VENDOR_SPECIFIC
Device server indicates a vendor specific condition.
@constant kSENSE_KEY_COPY_ABORTED
Device server indicates a copy aborted condition.
@constant kSENSE_KEY_ABORTED_COMMAND
Device server indicates an aborted command condition.
@constant kSENSE_KEY_VOLUME_OVERFLOW
Device server indicates a volume overflow condition.
@constant kSENSE_KEY_MISCOMPARE
Device server indicates a miscompare condition.
@constant kSENSE_KEY_Mask
Mask to use when checking the SENSE_KEY field for the SENSE_KEY value.
*/
enum
{
	kSENSE_KEY_NO_SENSE										= 0x00,
	kSENSE_KEY_RECOVERED_ERROR								= 0x01,
	kSENSE_KEY_NOT_READY									= 0x02,
	kSENSE_KEY_MEDIUM_ERROR									= 0x03,
	kSENSE_KEY_HARDWARE_ERROR								= 0x04,
	kSENSE_KEY_ILLEGAL_REQUEST								= 0x05,
	kSENSE_KEY_UNIT_ATTENTION								= 0x06,
	kSENSE_KEY_DATA_PROTECT									= 0x07,
	kSENSE_KEY_BLANK_CHECK									= 0x08,
	kSENSE_KEY_VENDOR_SPECIFIC								= 0x09,
	kSENSE_KEY_COPY_ABORTED									= 0x0A,
	kSENSE_KEY_ABORTED_COMMAND								= 0x0B,
	/* SENSE KEY 0x0C is obsoleted */
	kSENSE_KEY_VOLUME_OVERFLOW								= 0x0D,
	kSENSE_KEY_MISCOMPARE									= 0x0E,
	/* SENSE KEY 0x0F is reserved */
	kSENSE_KEY_Mask 										= 0x0F
};


#endif	/* _IOKIT_SCSI_CMDS_REQUEST_SENSE_H_ */
                SCSICommandDefinitions.h                                                                            0100644 0001750 0001750 00000031055 12567470660 037402  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 2001-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_COMMAND_DEFINITIONS_H_
#define _IOKIT_SCSI_COMMAND_DEFINITIONS_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSICommandDefinitions
	@discussion
	This file contains all the definitions for types and constants that are
	used by the command set classes for building CDBs. The field type
	definitions are used for the parameters passed to a method that builds and
	sends any SCSI defined command to clearly identify the type of value
	expected for a parameter.
	
	The command methods will then use the appropriate mask to verify that the
	value passed into a parameter is of the specified type.
	
	Currently only types and masks are defined for 8 bytes and smaller fields.
	If a command is defined that uses a larger field, these should be expanded
	to include those sizes.
*/ 

#pragma mark Field Type Definitions
/* These are the type definitions used for the parameters of methods that
 * build and send Command Descriptor Blocks.
 */

/* 1 Byte or smaller fields. */

/*! @typedef SCSICmdField1Bit */
typedef UInt8	SCSICmdField1Bit;

/*! @typedef SCSICmdField2Bit */
typedef UInt8	SCSICmdField2Bit;

/*! @typedef SCSICmdField3Bit */
typedef UInt8	SCSICmdField3Bit;

/*! @typedef SCSICmdField4Bit */
typedef UInt8	SCSICmdField4Bit;

/*! @typedef SCSICmdField5Bit */
typedef UInt8	SCSICmdField5Bit;

/*! @typedef SCSICmdField6Bit */
typedef UInt8	SCSICmdField6Bit;

/*! @typedef SCSICmdField7Bit */
typedef UInt8	SCSICmdField7Bit;

/*! @typedef SCSICmdField1Byte */
typedef UInt8	SCSICmdField1Byte;

/* 2 Bytes or smaller fields. */

/*! @typedef SCSICmdField9Bit */
typedef UInt16	SCSICmdField9Bit;

/*! @typedef SCSICmdField10Bit */
typedef UInt16	SCSICmdField10Bit;

/*! @typedef SCSICmdField11Bit */
typedef UInt16	SCSICmdField11Bit;

/*! @typedef SCSICmdField12Bit */
typedef UInt16	SCSICmdField12Bit;

/*! @typedef SCSICmdField13Bit */
typedef UInt16	SCSICmdField13Bit;

/*! @typedef SCSICmdField14Bit */
typedef UInt16	SCSICmdField14Bit;

/*! @typedef SCSICmdField15Bit */
typedef UInt16	SCSICmdField15Bit;

/*! @typedef SCSICmdField2Byte */
typedef UInt16	SCSICmdField2Byte;

/* 3 Bytes or smaller fields. */

/*! @typedef SCSICmdField17Bit */
typedef UInt32	SCSICmdField17Bit;

/*! @typedef SCSICmdField18Bit */
typedef UInt32	SCSICmdField18Bit;

/*! @typedef SCSICmdField19Bit */
typedef UInt32	SCSICmdField19Bit;

/*! @typedef SCSICmdField20Bit */
typedef UInt32	SCSICmdField20Bit;

/*! @typedef SCSICmdField21Bit */
typedef UInt32	SCSICmdField21Bit;

/*! @typedef SCSICmdField22Bit */
typedef UInt32	SCSICmdField22Bit;

/*! @typedef SCSICmdField23Bit */
typedef UInt32	SCSICmdField23Bit;

/*! @typedef SCSICmdField3Byte */
typedef UInt32	SCSICmdField3Byte;

/* 4 Bytes or smaller fields. */

/*! @typedef SCSICmdField25Bit */
typedef UInt32	SCSICmdField25Bit;

/*! @typedef SCSICmdField26Bit */
typedef UInt32	SCSICmdField26Bit;

/*! @typedef SCSICmdField27Bit */
typedef UInt32	SCSICmdField27Bit;

/*! @typedef SCSICmdField28Bit */
typedef UInt32	SCSICmdField28Bit;

/*! @typedef SCSICmdField29Bit */
typedef UInt32	SCSICmdField29Bit;

/*! @typedef SCSICmdField30Bit */
typedef UInt32	SCSICmdField30Bit;

/*! @typedef SCSICmdField31Bit */
typedef UInt32	SCSICmdField31Bit;

/*! @typedef SCSICmdField4Byte */
typedef UInt32	SCSICmdField4Byte;

/* 5 Bytes or smaller fields. */

/*! @typedef SCSICmdField33Bit */
typedef UInt64	SCSICmdField33Bit;

/*! @typedef SCSICmdField34Bit */
typedef UInt64	SCSICmdField34Bit;

/*! @typedef SCSICmdField35Bit */
typedef UInt64	SCSICmdField35Bit;

/*! @typedef SCSICmdField36Bit */
typedef UInt64	SCSICmdField36Bit;

/*! @typedef SCSICmdField37Bit */
typedef UInt64	SCSICmdField37Bit;

/*! @typedef SCSICmdField38Bit */
typedef UInt64	SCSICmdField38Bit;

/*! @typedef SCSICmdField39Bit */
typedef UInt64	SCSICmdField39Bit;

/*! @typedef SCSICmdField5Byte */
typedef UInt64	SCSICmdField5Byte;

/* 6 Bytes or smaller fields. */

/*! @typedef SCSICmdField41Bit */
typedef UInt64	SCSICmdField41Bit;

/*! @typedef SCSICmdField42Bit */
typedef UInt64	SCSICmdField42Bit;

/*! @typedef SCSICmdField43Bit */
typedef UInt64	SCSICmdField43Bit;

/*! @typedef SCSICmdField44Bit */
typedef UInt64	SCSICmdField44Bit;

/*! @typedef SCSICmdField45Bit */
typedef UInt64	SCSICmdField45Bit;

/*! @typedef SCSICmdField46Bit */
typedef UInt64	SCSICmdField46Bit;

/*! @typedef SCSICmdField47Bit */
typedef UInt64	SCSICmdField47Bit;

/*! @typedef SCSICmdField6Byte */
typedef UInt64	SCSICmdField6Byte;

/* 7 Bytes or smaller fields. */

/*! @typedef SCSICmdField49Bit */
typedef UInt64	SCSICmdField49Bit;

/*! @typedef SCSICmdField50Bit */
typedef UInt64	SCSICmdField50Bit;

/*! @typedef SCSICmdField51Bit */
typedef UInt64	SCSICmdField51Bit;

/*! @typedef SCSICmdField52Bit */
typedef UInt64	SCSICmdField52Bit;

/*! @typedef SCSICmdField53Bit */
typedef UInt64	SCSICmdField53Bit;

/*! @typedef SCSICmdField54Bit */
typedef UInt64	SCSICmdField54Bit;

/*! @typedef SCSICmdField55Bit */
typedef UInt64	SCSICmdField55Bit;

/*! @typedef SCSICmdField7Byte */
typedef UInt64	SCSICmdField7Byte;

/* 8 Bytes or smaller fields. */

/*! @typedef SCSICmdField57Bit */
typedef UInt64	SCSICmdField57Bit;

/*! @typedef SCSICmdField58Bit */
typedef UInt64	SCSICmdField58Bit;

/*! @typedef SCSICmdField59Bit */
typedef UInt64	SCSICmdField59Bit;

/*! @typedef SCSICmdField60Bit */
typedef UInt64	SCSICmdField60Bit;

/*! @typedef SCSICmdField61Bit */
typedef UInt64	SCSICmdField61Bit;

/*! @typedef SCSICmdField62Bit */
typedef UInt64	SCSICmdField62Bit;

/*! @typedef SCSICmdField63Bit */
typedef UInt64	SCSICmdField63Bit;

/*! @typedef SCSICmdField8Byte */
typedef UInt64	SCSICmdField8Byte;


#pragma mark Field Mask Definitions
/* These are masks that are used to verify that the values passed into the
 * parameters for the fields are not larger than the field size.
 *
 * NB: These have changed from enums to #define since enums greater than
 * 32 bits in size are not well-defined in C99.
 */

/* 1 Byte or smaller fields. */

/*! @constant kSCSICmdFieldMask1Bit */
#define 	kSCSICmdFieldMask1Bit		0x01

/*! @constant kSCSICmdFieldMask2Bit */
#define 	kSCSICmdFieldMask2Bit		0x03

/*! @constant kSCSICmdFieldMask3Bit */
#define 	kSCSICmdFieldMask3Bit		0x07

/*! @constant kSCSICmdFieldMask4Bit */
#define 	kSCSICmdFieldMask4Bit		0x0F

/*! @constant kSCSICmdFieldMask5Bit */
#define 	kSCSICmdFieldMask5Bit		0x1F

/*! @constant kSCSICmdFieldMask6Bit */
#define 	kSCSICmdFieldMask6Bit		0x3F

/*! @constant kSCSICmdFieldMask7Bit */
#define 	kSCSICmdFieldMask7Bit		0x7F

#define 	kSCSICmdFieldMask1Byte		0xFF

/* 2 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask9Bit */
#define 	kSCSICmdFieldMask9Bit		0x01FF

/*! @constant kSCSICmdFieldMask10Bit */
#define 	kSCSICmdFieldMask10Bit		0x03FF

/*! @constant kSCSICmdFieldMask11Bit */
#define 	kSCSICmdFieldMask11Bit		0x07FF

/*! @constant kSCSICmdFieldMask12Bit */
#define 	kSCSICmdFieldMask12Bit		0x0FFF

/*! @constant kSCSICmdFieldMask13Bit */
#define 	kSCSICmdFieldMask13Bit		0x1FFF

/*! @constant kSCSICmdFieldMask14Bit */
#define 	kSCSICmdFieldMask14Bit		0x3FFF

/*! @constant kSCSICmdFieldMask15Bit */
#define 	kSCSICmdFieldMask15Bit		0x7FFF

/*! @constant kSCSICmdFieldMask2Byte */
#define 	kSCSICmdFieldMask2Byte		0xFFFF

/* 3 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask17Bit */
#define 	kSCSICmdFieldMask17Bit		0x01FFFF

/*! @constant kSCSICmdFieldMask18Bit */
#define 	kSCSICmdFieldMask18Bit		0x03FFFF

/*! @constant kSCSICmdFieldMask19Bit */
#define 	kSCSICmdFieldMask19Bit		0x07FFFF

/*! @constant kSCSICmdFieldMask20Bit */
#define 	kSCSICmdFieldMask20Bit		0x0FFFFF

/*! @constant kSCSICmdFieldMask21Bit */
#define 	kSCSICmdFieldMask21Bit		0x1FFFFF

/*! @constant kSCSICmdFieldMask22Bit */
#define 	kSCSICmdFieldMask22Bit		0x3FFFFF

/*! @constant kSCSICmdFieldMask23Bit */
#define 	kSCSICmdFieldMask23Bit		0x7FFFFF

/*! @constant kSCSICmdFieldMask3Byte */
#define 	kSCSICmdFieldMask3Byte		0xFFFFFF

/* 4 Bytes or smaller fields. */
/*! @constant kSCSICmdFieldMask25Bit */
#define 	kSCSICmdFieldMask25Bit		0x01FFFFFFUL

/*! @constant kSCSICmdFieldMask26Bit */
#define 	kSCSICmdFieldMask26Bit		0x03FFFFFFUL

/*! @constant kSCSICmdFieldMask27Bit */
#define 	kSCSICmdFieldMask27Bit		0x07FFFFFFUL

/*! @constant kSCSICmdFieldMask28Bit */
#define 	kSCSICmdFieldMask28Bit		0x0FFFFFFFUL

/*! @constant kSCSICmdFieldMask29Bit */
#define 	kSCSICmdFieldMask29Bit		0x1FFFFFFFUL

/*! @constant kSCSICmdFieldMask30Bit */
#define 	kSCSICmdFieldMask30Bit		0x3FFFFFFFUL

/*! @constant kSCSICmdFieldMask31Bit */
#define 	kSCSICmdFieldMask31Bit		0x7FFFFFFFUL

/*! @constant kSCSICmdFieldMask4Byte */
#define 	kSCSICmdFieldMask4Byte		0xFFFFFFFFUL

/* 5 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask33Bit */
#define 	kSCSICmdFieldMask33Bit		0x01FFFFFFFFULL

/*! @constant kSCSICmdFieldMask34Bit */
#define 	kSCSICmdFieldMask34Bit		0x03FFFFFFFFULL

/*! @constant kSCSICmdFieldMask35Bit */
#define 	kSCSICmdFieldMask35Bit		0x07FFFFFFFFULL

/*! @constant kSCSICmdFieldMask36Bit */
#define 	kSCSICmdFieldMask36Bit		0x0FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask37Bit */
#define 	kSCSICmdFieldMask37Bit		0x1FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask38Bit */
#define 	kSCSICmdFieldMask38Bit		0x3FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask39Bit */
#define 	kSCSICmdFieldMask39Bit		0x7FFFFFFFFFULL

/*! @constant kSCSICmdFieldMask5Byte */
#define 	kSCSICmdFieldMask5Byte		0xFFFFFFFFFFULL

/* 6 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask41Bit */
#define 	kSCSICmdFieldMask41Bit		0x01FFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask42Bit */
#define 	kSCSICmdFieldMask42Bit		0x03FFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask43Bit */
#define 	kSCSICmdFieldMask43Bit		0x07FFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask44Bit */
#define 	kSCSICmdFieldMask44Bit		0x0FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask45Bit */
#define 	kSCSICmdFieldMask45Bit		0x1FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask46Bit */
#define 	kSCSICmdFieldMask46Bit		0x3FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask47Bit */
#define 	kSCSICmdFieldMask47Bit		0x7FFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask6Byte */
#define 	kSCSICmdFieldMask6Byte		0xFFFFFFFFFFFFULL

/* 7 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask49Bit */
#define 	kSCSICmdFieldMask49Bit		0x01FFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask50Bit */
#define 	kSCSICmdFieldMask50Bit		0x03FFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask51Bit */
#define 	kSCSICmdFieldMask51Bit		0x07FFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask52Bit */
#define 	kSCSICmdFieldMask52Bit		0x0FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask53Bit */
#define 	kSCSICmdFieldMask53Bit		0x1FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask54Bit */
#define 	kSCSICmdFieldMask54Bit		0x3FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask55Bit */
#define 	kSCSICmdFieldMask55Bit		0x7FFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask7Byte */
#define 	kSCSICmdFieldMask7Byte		0xFFFFFFFFFFFFFFULL

/* 8 Bytes or smaller fields. */

/*! @constant kSCSICmdFieldMask57Bit */
#define 	kSCSICmdFieldMask57Bit		0x01FFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask58Bit */
#define 	kSCSICmdFieldMask58Bit		0x03FFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask59Bit */
#define 	kSCSICmdFieldMask59Bit		0x07FFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask60Bit */
#define 	kSCSICmdFieldMask60Bit		0x0FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask61Bit */
#define 	kSCSICmdFieldMask61Bit		0x1FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask62Bit */
#define 	kSCSICmdFieldMask62Bit		0x3FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask63Bit */
#define 	kSCSICmdFieldMask63Bit		0x7FFFFFFFFFFFFFFFULL

/*! @constant kSCSICmdFieldMask8Byte */
#define 	kSCSICmdFieldMask8Byte		0xFFFFFFFFFFFFFFFFULL

#endif	/* _IOKIT_SCSI_COMMAND_DEFINITIONS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   SCSICommandOperationCodes.h                                                                         0100644 0001750 0001750 00000142433 12567470660 040050  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 2001-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCSI_COMMAND_OPERATION_CODES_H_
#define _SCSI_COMMAND_OPERATION_CODES_H_

#pragma mark About this file
/* This file contains the operation code definitions for all commands defined
 * by the SCSI specifications.  The commands are listed in three formats:
 * 1) All commands are listed in alphabetical order.  This list is the live
 * enumeration for all of the command constants.
 * 2) The commands are listed in ascending numerical order.
 * 3) The commands are grouped by Peripheral Device Type.
 * 
 * In the command listings by Peripheral Device Type, there will be a comment
 * following each command.  This comment indentifies the section of the related
 * specification where the commands is defined and the requirement type of the
 * command, Mandatory or Optional.
 * If a specification redefines an optional command from SPC as mandatory,
 * the command will be relisted in the Peripheral Device Type command list with
 * the mandatory tag next to it.
 * All commands that are listed in SPC as Device Type Specifc will be relisted
 * as a comment in all specifications lists that support that command with the
 * appropriate Mandatory or Optional tag for that specification.
 *
 * The section number and the requirement type of the command are based on the 
 * version of the specification listed in the header comment for the Peripheral
 * Device Type.  This data is provided for informational purposes only.  The 
 * specification document and version that the device adheres to as indicated 
 * by the data returned in response to the INQUIRY command should be used as
 * the authorative source for supported and required behavior of the device.
 * 
 * The SPC set is listed before all other Peripheral Device Type commands as
 * this is the base document from which all of the other documents are derived.  
 *
 * The Peripheral Device Types and associated command sets as defined by SPC-2,
 * section 7.4.1 are as follows:
 *  Peripheral Device Type                  Associated Command Specification
 *  ------------------------------------    -----------------------------------
 *  0x00 Direct Access Device               SBC - SCSI-3 Block Commands
 *  0x01 Sequential Access Device           SSC - SCSI-3 Stream Commands
 *  0x02 Printer Device                     SSC - SCSI-3 Stream Commands
 *  0x03 Processor Device                   SPC - SCSI Primary Commands-2
 *  0x04 Write Once Device                  SBC - SCSI-3 Block Commands
 *  0x05 CD-ROM Device                      MMC - SCSI Multimedia Commands-2
 *  0x06 Scanner Device                     SGC - SCSI-3 Graphics Commands
 *  0x07 Optical Memory Device              SBC - SCSI-3 Block Commands
 *  0x08 Medium Changer Device              SMC - SCSI-3 Medium Changer Cmds
 *  0x09 Communications Device              SSC - SCSI-3 Stream Commands
 *  0x0A - 0x0B Graphic Arts Prepress Dev   ASC IT8
 *  0x0C Storage Array Controller Device    SCC-2 - SCSI Controller Commands-2
 *  0x0D Enclosure Services                 SES - SCSI-3 Enclosure Services
 *  0x0E Simplified Direct Access Device    RBC - SCSI Reduced Block Commands
 *  0x0F Optical Card Reader/Writer Device  OCRW - SCSI Specification for 
 *                                              Optical Card Reader/Writer
 *  0x10 Reserved                    		No command specification
 *	0x11 Object-Based Storage Device		OSD - SCSI Object Based Storage 
 *												Device Commands
 *  0x12 - 0x14 Reserved                    No command specification
 *  0x15 Multimedia Media Access Engine     RMC - Reduced Multimedia Commands
 *  0x16 - 0x1E Reserved                    No command specification
 *  0x1F Unknown or No Device               No command specification
 */ 

#pragma mark -
#pragma mark Command Definitions by Name
/* All SCSI Commands listed in alphabetical order.  These are the live
 * definitions of the commands.  All other command lists are informative.
 */
enum 
{
    kSCSICmd_ACCESS_CONTROL_IN              = 0x86,
    kSCSICmd_ACCESS_CONTROL_OUT             = 0x87,
    kSCSICmd_BLANK                          = 0xA1,
    kSCSICmd_CHANGE_DEFINITION              = 0x40,
    kSCSICmd_CLOSE_TRACK_SESSION            = 0x5B,
    kSCSICmd_COMPARE                        = 0x39,
    kSCSICmd_COPY                           = 0x18,
    kSCSICmd_COPY_AND_VERIFY                = 0x3A,
    kSCSICmd_ERASE_10						= 0x2C,
    kSCSICmd_ERASE_12						= 0xAC,
    kSCSICmd_EXTENDED_COPY                  = 0x83,
    kSCSICmd_FORMAT_UNIT                    = 0x04,
    kSCSICmd_GET_CONFIGURATION              = 0x46,
    kSCSICmd_GET_EVENT_STATUS_NOTIFICATION  = 0x4A,
    kSCSICmd_GET_PERFORMANCE                = 0xAC,
    kSCSICmd_INQUIRY                        = 0x12,
    kSCSICmd_LOAD_UNLOAD_MEDIUM             = 0xA6,
    kSCSICmd_LOCK_UNLOCK_CACHE              = 0x36,
    kSCSICmd_LOCK_UNLOCK_CACHE_16           = 0x92,
    kSCSICmd_LOG_SELECT                     = 0x4C,
    kSCSICmd_LOG_SENSE                      = 0x4D,
    kSCSICmd_MAINTENANCE_IN               	= 0xA3,
    kSCSICmd_MAINTENANCE_OUT                = 0xA4,
    kSCSICmd_MECHANISM_STATUS               = 0xBD,
    kSCSICmd_MEDIUM_SCAN                    = 0x38,
    kSCSICmd_MODE_SELECT_6                  = 0x15,
    kSCSICmd_MODE_SELECT_10                 = 0x55,
    kSCSICmd_MODE_SENSE_6                   = 0x1A,
    kSCSICmd_MODE_SENSE_10                  = 0x5A,
    kSCSICmd_MOVE_MEDIUM_ATTACHED           = 0xA7,
    kSCSICmd_PAUSE_RESUME                   = 0x4B,
    kSCSICmd_PERSISTENT_RESERVE_IN          = 0x5E,
    kSCSICmd_PERSISTENT_RESERVE_OUT         = 0x5F,
    kSCSICmd_PLAY_AUDIO_10                  = 0x45,
    kSCSICmd_PLAY_AUDIO_12                  = 0xA5,
    kSCSICmd_PLAY_AUDIO_MSF                 = 0x47,
    kSCSICmd_PLAY_AUDIO_TRACK_INDEX         = 0x48,
    kSCSICmd_PLAY_CD                        = 0xBC,
    kSCSICmd_PLAY_RELATIVE_10               = 0x49,
    kSCSICmd_PLAY_RELATIVE_12               = 0xA9,
    kSCSICmd_PREFETCH                       = 0x34,
    kSCSICmd_PREFETCH_16                    = 0x90,
    kSCSICmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E,
    kSCSICmd_READ_6                         = 0x08,
    kSCSICmd_READ_10                        = 0x28,
    kSCSICmd_READ_12                        = 0xA8,
    kSCSICmd_READ_16                        = 0x88,
    kSCSICmd_READ_ATTRIBUTE                 = 0x8C,
    kSCSICmd_READ_BUFFER                    = 0x3C,
    kSCSICmd_READ_BUFFER_CAPACITY           = 0x5C,
    kSCSICmd_READ_CAPACITY                  = 0x25,
    kSCSICmd_READ_CD                        = 0xBE,
    kSCSICmd_READ_CD_MSF                    = 0xB9,
    kSCSICmd_READ_DEFECT_DATA_10            = 0x37,
    kSCSICmd_READ_DEFECT_DATA_12            = 0xB7,
    kSCSICmd_READ_DISC_INFORMATION          = 0x51,
    kSCSICmd_READ_DVD_STRUCTURE             = 0xAD,
    kSCSICmd_READ_DISC_STRUCTURE            = 0xAD,
    kSCSICmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4,
    kSCSICmd_READ_FORMAT_CAPACITIES         = 0x23,
    kSCSICmd_READ_GENERATION				= 0x29,
    kSCSICmd_READ_HEADER                    = 0x44,
    kSCSICmd_READ_LONG                      = 0x3E,
    kSCSICmd_READ_MASTER_CUE                = 0x59,
    kSCSICmd_READ_SUB_CHANNEL               = 0x42,
    kSCSICmd_READ_TOC_PMA_ATIP              = 0x43,
    kSCSICmd_READ_TRACK_INFORMATION         = 0x52,
    kSCSICmd_READ_UPDATED_BLOCK_10			= 0x2D,
    kSCSICmd_REASSIGN_BLOCKS                = 0x07,
    kSCSICmd_REBUILD                        = 0x81,
    kSCSICmd_RECEIVE                        = 0x08,
    kSCSICmd_RECEIVE_COPY_RESULTS           = 0x84,
    kSCSICmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C,
    kSCSICmd_REDUNDANCY_GROUP_IN			= 0xBA,
    kSCSICmd_REDUNDANCY_GROUP_OUT			= 0xBB,
    kSCSICmd_REGENERATE                     = 0x82,
    kSCSICmd_RELEASE_6                      = 0x17,
    kSCSICmd_RELEASE_10                     = 0x57,
    kSCSICmd_REPAIR_TRACK                   = 0x58,
    kSCSICmd_REPORT_DEVICE_IDENTIFIER    	= 0xA3,
    kSCSICmd_REPORT_KEY                     = 0xA4,
    kSCSICmd_REPORT_LUNS                    = 0xA0, 
    kSCSICmd_REQUEST_SENSE                  = 0x03,
    kSCSICmd_RESERVE_6                      = 0x16,
    kSCSICmd_RESERVE_10                     = 0x56,
    kSCSICmd_RESERVE_TRACK                  = 0x53,
    kSCSICmd_REZERO_UNIT                    = 0x01,
    kSCSICmd_SCAN_MMC                       = 0xBA,
    kSCSICmd_SEARCH_DATA_EQUAL_10           = 0x31,
    kSCSICmd_SEARCH_DATA_EQUAL_12           = 0xB1,
    kSCSICmd_SEARCH_DATA_HIGH_10            = 0x30,
    kSCSICmd_SEARCH_DATA_HIGH_12            = 0xB0,
    kSCSICmd_SEARCH_DATA_LOW_10             = 0x32,
    kSCSICmd_SEARCH_DATA_LOW_12             = 0xB2,
    kSCSICmd_SEEK_6                         = 0x0B,
    kSCSICmd_SEEK_10                        = 0x2B,
    kSCSICmd_SEND                           = 0x0A,
    kSCSICmd_SEND_CUE_SHEET                 = 0x5D,
    kSCSICmd_SEND_DIAGNOSTICS               = 0x1D,
    kSCSICmd_SEND_DVD_STRUCTURE             = 0xBF,
    kSCSICmd_SEND_EVENT                     = 0xA2,
    kSCSICmd_SEND_KEY                       = 0xA3,
    kSCSICmd_SEND_OPC_INFORMATION           = 0x54,
    kSCSICmd_SERVICE_ACTION_IN		        = 0x9E,
    kSCSICmd_SERVICE_ACTION_OUT		        = 0x9F,
    kSCSICmd_SET_CD_SPEED                   = 0xBB,
    kSCSICmd_SET_DEVICE_IDENTIFIER      	= 0xA4,
    kSCSICmd_SET_LIMITS_10                  = 0x33,
    kSCSICmd_SET_LIMITS_12                  = 0xB3,
    kSCSICmd_SET_READ_AHEAD                 = 0xA7,
    kSCSICmd_SET_STREAMING                  = 0xB6,
    kSCSICmd_SPARE_IN		                = 0xBC,
    kSCSICmd_SPARE_OUT		                = 0xBD,
    kSCSICmd_START_STOP_UNIT                = 0x1B,
    kSCSICmd_STOP_PLAY_SCAN                 = 0x4E,
    kSCSICmd_SYNCHRONIZE_CACHE              = 0x35,
    kSCSICmd_SYNCHRONIZE_CACHE_16           = 0x91,
    kSCSICmd_TEST_UNIT_READY                = 0x00,
	kSCSICmd_UPDATE_BLOCK					= 0x3D,
    kSCSICmd_VERIFY_10                      = 0x2F,
    kSCSICmd_VERIFY_12                      = 0xAF,
    kSCSICmd_VERIFY_16                      = 0x8F,
    kSCSICmd_VOLUME_SET_IN                  = 0xBE,
    kSCSICmd_VOLUME_SET_OUT                 = 0xBF,
    kSCSICmd_WRITE_6                        = 0x0A,
    kSCSICmd_WRITE_10                       = 0x2A,
    kSCSICmd_WRITE_12                       = 0xAA,
    kSCSICmd_WRITE_16                       = 0x8A,
    kSCSICmd_WRITE_AND_VERIFY_10            = 0x2E,
	kSCSICmd_WRITE_AND_VERIFY_12            = 0xAE,
	kSCSICmd_WRITE_AND_VERIFY_16            = 0x8E,
	kSCSICmd_WRITE_ATTRIBUTE	            = 0x8D,
    kSCSICmd_WRITE_BUFFER                   = 0x3B,
    kSCSICmd_WRITE_LONG                     = 0x3F,
    kSCSICmd_WRITE_SAME                     = 0x41,
    kSCSICmd_WRITE_SAME_16                  = 0x93,
    kSCSICmd_XDREAD                         = 0x52,
    kSCSICmd_XDWRITE                        = 0x50,
    kSCSICmd_XDWRITE_EXTENDED               = 0x80,
    kSCSICmd_XDWRITEREAD_10           		= 0x53,
    kSCSICmd_XPWRITE                        = 0x51,
    
    kSCSICmdVariableLengthCDB				= 0x7F
};

/* Service Action Definitions for the Variable Length CDB (7Fh) command */
enum
{
	kSCSIServiceAction_READ_32				= 0x0009,
	kSCSIServiceAction_VERIFY_32			= 0x000A,
	kSCSIServiceAction_WRITE_32				= 0x000B,
	kSCSIServiceAction_WRITE_AND_VERIFY_32	= 0x000C,
	kSCSIServiceAction_WRITE_SAME_32		= 0x000D,
	kSCSIServiceAction_XDREAD_32			= 0x0003,
	kSCSIServiceAction_XDWRITE_32			= 0x0004,
	kSCSIServiceAction_XDWRITEREAD_32		= 0x0007,
	kSCSIServiceAction_XPWRITE_32			= 0x0006
};

/* Service Action Definitions for the MAINTENANCE IN (A3h) command */
enum
{
	kSCSIServiceAction_REPORT_ALIASES								= 0x0B,
	kSCSIServiceAction_REPORT_DEVICE_IDENTIFIER						= 0x05,
	kSCSIServiceAction_REPORT_PRIORITY								= 0x0E,
	kSCSIServiceAction_REPORT_SUPPORTED_OPERATION_CODES				= 0x0C,
	kSCSIServiceAction_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS	= 0x0D,
	kSCSIServiceAction_REPORT_TARGET_PORT_GROUPS					= 0x0A
};

/* Service Action Definitions for the MAINTENANCE OUT (A4h) command */
enum
{
	kSCSIServiceAction_CHANGE_ALIASES			= 0x0B,
	kSCSIServiceAction_SET_DEVICE_IDENTIFIER	= 0x06,
	kSCSIServiceAction_SET_PRIORITY				= 0x0E,
	kSCSIServiceAction_SET_TARGET_PORT_GROUPS	= 0x0A	
};

/* Service Action Definitions for the SERVICE ACTION IN (9Eh) command */
enum
{
	kSCSIServiceAction_READ_CAPACITY_16		= 0x10,
	kSCSIServiceAction_READ_LONG_16			= 0x11	
};

/* Service Action Definitions for the SERVICE ACTION OUT (9Fh) command */
enum
{
	kSCSIServiceAction_WRITE_LONG_16		= 0x11	
};

#pragma mark -
#pragma mark Command Definitions by Number
#if 0
enum 
{
};
#endif


#pragma mark -
#pragma mark All Types SPC Commands
/* Commands defined by the T10:1236-D SCSI Primary Commands-2 (SPC-2) 
 * command specification.  The definitions and section numbers are based on
 * section 7 of the revision 18, 21 May 2000 version of the specification.
 *
 * These commands are defined for all devices.
 */
enum 
{
    kSPCCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSPCCmd_COMPARE                        = 0x39, /* Sec. 7.2: Optional */
    kSPCCmd_COPY                           = 0x18, /* Sec. 7.3: Optional */
    kSPCCmd_COPY_AND_VERIFY                = 0x3A, /* Sec. 7.4: Optional */
    kSPCCmd_EXTENDED_COPY                  = 0x83, /* Sec. 7.5: Optional */
    kSPCCmd_INQUIRY                        = 0x12, /* Sec. 7.6: Mandatory */
    kSPCCmd_LOG_SELECT                     = 0x4C, /* Sec. 7.7: Optional */
    kSPCCmd_LOG_SENSE                      = 0x4D, /* Sec. 7.8: Optional */
    kSPCCmd_MODE_SELECT_6                  = 0x15, /* Sec. 7.9: Device Type
													* Specific */
    kSPCCmd_MODE_SELECT_10                 = 0x55, /* Sec. 7.10: Device Type
													* Specific */
    kSPCCmd_MODE_SENSE_6                   = 0x1A, /* Sec. 7.11: Device Type
													* Specific */
    kSPCCmd_MODE_SENSE_10                  = 0x5A, /* Sec. 7.12: Device Type
													* Specific */
    kSPCCmd_MOVE_MEDIUM_ATTACHED           = 0xA7, /* Defined in SMC */
    kSPCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Sec. 7.13: Device Type
													* Specific */
    kSPCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Sec. 7.14: Device Type
													* Specific */
    kSPCCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* Sec. 7.15: Device Type
													* Specific */
    kSPCCmd_READ_BUFFER                    = 0x3C, /* Sec. 7.16: Optional */
    kSPCCmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4, /* Defined in SMC */
    kSPCCmd_RECEIVE_COPY_RESULTS           = 0x84, /* Sec. 7.17: Optional */
    kSPCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* Sec. 7.18: Optional */
    kSPCCmd_RELEASE_10                     = 0x57, /* Sec. 7.19: Device Type
													* Specific */
    kSPCCmd_RELEASE_6                      = 0x17, /* Sec. 7.20: Device Type
													* Specific */
    kSPCCmd_REPORT_DEVICE_IDENTIFIER       = 0xA3, /* Sec. 7.21: Optional */
    kSPCCmd_REPORT_LUNS                    = 0xA0, /* Sec. 7.22: Mandatory for
													* LUN Supporting devices*/
    kSPCCmd_REQUEST_SENSE                  = 0x03, /* Sec. 7.23: Device Type
													* Specific */
    kSPCCmd_RESERVE_10                     = 0x56, /* Sec. 7.24: Device Type
													* Specific */
    kSPCCmd_RESERVE_6                      = 0x16, /* Sec. 7.25: Device Type
													* Specific */
    kSPCCmd_SEND_DIAGNOSTICS               = 0x1D, /* Sec. 7.26: Optional */
    kSPCCmd_SET_DEVICE_IDENTIFIER          = 0xA4, /* Sec. 7.27: Optional */
    kSPCCmd_TEST_UNIT_READY                = 0x00, /* Sec. 7.28: Mandatory */
    kSPCCmd_WRITE_BUFFER                   = 0x3B  /* Sec. 7.29: Optional */
};

#pragma mark -
#pragma mark 0x00 SBC Direct Access Commands
/* Commands defined by the T10:990-D SCSI-3 Block Commands (SBC) command
 * specification.  The definitions and section numbers are based on section 6.1
 * of the revision 8c, 13 November 1997 version of the specification. 
 */
enum
{
    kSBCCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSBCCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSBCCmd_COPY                           = 0x18, /* SPC: Optional */
    kSBCCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional*/
    kSBCCmd_FORMAT_UNIT                    = 0x04, /* Sec. 6.1.1: Mandatory */
    kSBCCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSBCCmd_LOCK_UNLOCK_CACHE              = 0x36, /* Sec. 6.1.2: Optional */
    kSBCCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSBCCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSBCCmd_MODE_SELECT_6                  = 0x15, /* SPC: Optional */
    kSBCCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSBCCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Optional */
    kSBCCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSBCCmd_MOVE_MEDIUM_ATTACHED           = 0xA7, /* SMC: Optional */
    kSBCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSBCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSBCCmd_PREFETCH                       = 0x34, /* Sec. 6.1.3: Optional */
    kSBCCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* SPC: Optional */
    kSBCCmd_READ_6                         = 0x08, /* Sec. 6.1.4: Mandatory */
    kSBCCmd_READ_10                        = 0x28, /* Sec. 6.1.5: Mandatory */
    kSBCCmd_READ_12                        = 0xA8, /* Sec. 6.2.4: Optional */
    kSBCCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSBCCmd_READ_CAPACITY                  = 0x25, /* Sec. 6.1.6: Mandatory */
    kSBCCmd_READ_DEFECT_DATA_10            = 0x37, /* Sec. 6.1.7: Optional */
    kSBCCmd_READ_DEFECT_DATA_12            = 0xB7, /* Sec. 6.2.5: Optional */
    kSBCCmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4, /* SMC: Optional */
    kSBCCmd_READ_GENERATION			       = 0x29, /* Sec. 6.2.6: Optional */
    kSBCCmd_READ_LONG                      = 0x3E, /* Sec. 6.1.8: Optional */
    kSBCCmd_READ_UPDATED_BLOCK_10		   = 0x2D, /* Sec. 6.2.7: Optional */
    kSBCCmd_REASSIGN_BLOCKS                = 0x07, /* Sec. 6.1.9: Optional */
    kSBCCmd_REBUILD                        = 0x81, /* Sec. 6.1.10: Optional */
    kSBCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSBCCmd_REGENERATE                     = 0x82, /* Sec. 6.1.11: Optional */
    kSBCCmd_RELEASE_6                      = 0x17, /* SPC: Optional */
    kSBCCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSBCCmd_REPORT_LUNS                    = 0xA0, /* SPC: Optional */
    kSBCCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSBCCmd_RESERVE_6                      = 0x16, /* SPC: Optional */
    kSBCCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSBCCmd_REZERO_UNIT                    = 0x01, /* Obsolete */
    kSBCCmd_SEARCH_DATA_EQUAL_10           = 0x31, /* Obsolete */
    kSBCCmd_SEARCH_DATA_HIGH_10            = 0x30, /* Obsolete */
    kSBCCmd_SEARCH_DATA_LOW_10             = 0x32, /* Obsolete */
    kSBCCmd_SEEK_6                         = 0x0B, /* Obsolete */
    kSBCCmd_SEEK_10                        = 0x2B, /* Sec. 6.1.12: Optional */
    kSBCCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSBCCmd_SET_LIMITS_10                  = 0x33, /* Sec. 6.1.13: Optional */
    kSBCCmd_SET_LIMITS_12                  = 0xB3, /* Sec. 6.2.8: Optional */
    kSBCCmd_START_STOP_UNIT                = 0x1B, /* Sec. 6.1.14: Optional */
    kSBCCmd_SYNCHRONIZE_CACHE              = 0x35, /* Sec. 6.1.15: Optional */
    kSBCCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
	kSBCCmd_UPDATE_BLOCK                   = 0x3D, /* Sec. 6.2.9: Optional */
    kSBCCmd_VERIFY_10                      = 0x2F, /* Sec. 6.1.16: Optional */
    kSBCCmd_WRITE_6                        = 0x0A, /* Sec. 6.1.17: Optional */
    kSBCCmd_WRITE_10                       = 0x2A, /* Sec. 6.1.18: Optional */
    kSBCCmd_WRITE_12                       = 0xAA, /* Sec. 6.2.13: Optional */
    kSBCCmd_WRITE_AND_VERIFY_10            = 0x2E, /* Sec. 6.1.19: Optional */
    kSBCCmd_WRITE_AND_VERIFY_12            = 0xAE, /* Sec. 6.2.15: Optional */
    kSBCCmd_WRITE_BUFFER                   = 0x3B, /* SPC: Optional */
    kSBCCmd_WRITE_LONG                     = 0x3F, /* Sec. 6.1.20: Optional */
    kSBCCmd_WRITE_SAME                     = 0x41, /* Sec. 6.1.21: Optional */
    kSBCCmd_XDREAD                         = 0x52, /* Sec. 6.1.22: Optional */
    kSBCCmd_XDWRITE                        = 0x50, /* Sec. 6.1.23: Optional */
    kSBCCmd_XDWRITE_EXTENDED               = 0x80, /* Sec. 6.1.24: Optional */
    kSBCCmd_XPWRITE                        = 0x51  /* Sec. 6.1.25: Optional */
};

#pragma mark -
#pragma mark 0x01 SSC Sequential Access Commands
/* Commands defined by the T10:997-D SCSI-3 Stream Commands (SSC) command
 * specification.  The definitions and section numbers are based on section 5
 * of the revision 22, January 1, 2000 version of the specification. 
 */
enum
{
    kSSCSeqCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSSCSeqCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSSCSeqCmd_COPY                           = 0x18, /* SPC: Optional */
    kSSCSeqCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kSSCSeqCmd_ERASE                          = 0x19, /* Sec. 5.3.1: Mandatory */
    kSSCSeqCmd_FORMAT_MEDIUM                  = 0x04, /* Sec. 5.3.2: Optional */
    kSSCSeqCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSSCSeqCmd_LOAD_UNLOAD                    = 0x1B, /* Sec. 5.3.3: Optional */
    kSSCSeqCmd_LOCATE                         = 0x2B, /* Sec. 5.3.4: Optional */
    kSSCSeqCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSSCSeqCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSSCSeqCmd_MODE_SELECT_6                  = 0x15, /* SPC: Mandatory */
    kSSCSeqCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSSCSeqCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Mandatory */
    kSSCSeqCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSSCSeqCmd_MOVE_MEDIUM                    = 0xA5, /* SMC: Optional */
    kSSCSeqCmd_MOVE_MEDIUM_ATTACHED           = 0xA7, /* SMC: Optional */
    kSSCSeqCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSSCSeqCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSSCSeqCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* SPC: Optional */
    kSSCSeqCmd_READ_6                         = 0x08, /* Sec. 5.3.5: Mandatory */
    kSSCSeqCmd_READ_BLOCK_LIMITS              = 0x05, /* Sec. 5.3.6: Mandatory */
    kSSCSeqCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSSCSeqCmd_READ_ELEMENT_STATUS            = 0xB8, /* SMC: Optional */
    kSSCSeqCmd_READ_ELEMENT_STATUS_ATTACHED   = 0xB4, /* SMC: Optional */
    kSSCSeqCmd_READ_POSITION                  = 0x34, /* Sec. 5.3.7: Mandatory */
    kSSCSeqCmd_READ_REVERSE                   = 0x0F, /* Sec. 5.3.8: Optional */
    kSSCSeqCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSSCSeqCmd_RECOVER_BUFFERED_DATA          = 0x14, /* Sec. 5.3.9: Optional */
    kSSCSeqCmd_RELEASE_6                      = 0x17, /* SPC: Mandatory */
    kSSCSeqCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSSCSeqCmd_REPORT_DENSITY_SUPPORT         = 0x44, /* Sec. 5.3.10: Mandatory*/
    kSSCSeqCmd_REPORT_LUNS                    = 0xA0, /* SPC: Mandatory */
    kSSCSeqCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSSCSeqCmd_RESERVE_6                      = 0x16, /* SPC: Mandatory */
    kSSCSeqCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSSCSeqCmd_REWIND                         = 0x01, /* Sec. 5.3.11: Mandatory*/
    kSSCSeqCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSSCSeqCmd_SPACE                          = 0x11, /* Sec. 5.3.12: Mandatory*/
    kSSCSeqCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSSCSeqCmd_VERIFY_6                       = 0x13, /* Sec. 5.3.13: Optional */
    kSSCSeqCmd_WRITE_6                        = 0x0A, /* Sec. 5.3.14: Mandatory*/
    kSSCSeqCmd_WRITE_BUFFER                   = 0x3B, /* SPC: Optional */
    kSSCSeqCmd_WRITE_FILEMARKS                = 0x10  /* Sec. 5.3.15: Mandatory*/
};

#pragma mark -
#pragma mark 0x02 SSC Printer Commands
/* Commands defined by the T10:997-D SCSI-3 Stream Commands (SSC) command
 * specification.  The definitions and section numbers are based on section 6
 * of the revision 22, January 1, 2000 version of the specification. 
 */
enum 
{
    kSSCPrinterCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSSCPrinterCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSSCPrinterCmd_COPY                           = 0x18, /* SPC: Optional */
    kSSCPrinterCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kSSCPrinterCmd_FORMAT                         = 0x04, /* Sec. 6.2.1: Optional */
    kSSCPrinterCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSSCPrinterCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSSCPrinterCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSSCPrinterCmd_MODE_SELECT_6                  = 0x15, /* SPC: Mandatory */
    kSSCPrinterCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSSCPrinterCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Mandatory */
    kSSCPrinterCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSSCPrinterCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSSCPrinterCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSSCPrinterCmd_PRINT                          = 0x0A, /* Sec. 6.2.2: Mandatory */
    kSSCPrinterCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSSCPrinterCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSSCPrinterCmd_RECOVER_BUFFERED_DATA          = 0x14, /* Sec. 6.2.3: Optional */
    kSSCPrinterCmd_RELEASE_6                      = 0x17, /* SPC: Mandatory */
    kSSCPrinterCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSSCPrinterCmd_REPORT_LUNS                    = 0xA0, /* SPC: Mandatory */
    kSSCPrinterCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSSCPrinterCmd_RESERVE_6                      = 0x16, /* SPC: Mandatory */
    kSSCPrinterCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSSCPrinterCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSSCPrinterCmd_SLEW_AND_PRINT                 = 0x0B, /* Sec. 6.2.4: Optional */
    kSSCPrinterCmd_STOP_PRINT                     = 0x1B, /* Sec. 6.2.5: Optional */
    kSSCPrinterCmd_SYNCHRONIZE_BUFFER             = 0x10, /* Sec. 6.2.6: Optional */
    kSSCPrinterCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSSCPrinterCmd_WRITE_BUFFER                   = 0x3B  /* SPC: Optional */
};
  
#pragma mark -
#pragma mark 0x03 SPC Processor Commands
/* Commands defined by the T10:1236-D SCSI Primary Commands-2 (SPC-2) 
 * command specification.  The definitions and section numbers are based on
 * section 9 of the revision 18, 21 May 2000 version of the specification.
 */
enum 
{
    kSPCProcCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kSPCProcCmd_COMPARE                        = 0x39, /* Sec. 7.2: Optional */
    kSPCProcCmd_COPY                           = 0x18, /* Sec. 7.3: Optional */
    kSPCProcCmd_COPY_AND_VERIFY                = 0x3A, /* Sec. 7.4: Optional */
    kSPCProcCmd_EXTENDED_COPY                  = 0x83, /* Sec. 7.5: Optional */
    kSPCProcCmd_INQUIRY                        = 0x12, /* Sec. 7.6: Mandatory */
    kSPCProcCmd_LOG_SELECT                     = 0x4C, /* Sec. 7.7: Optional */
    kSPCProcCmd_LOG_SENSE                      = 0x4D, /* Sec. 7.8: Optional */
    kSPCProcCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Sec. 7.13: Optional */
    kSPCProcCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Sec. 7.14: Optional */
    kSPCProcCmd_READ_BUFFER                    = 0x3C, /* Sec. 7.16: Optional */
    kSPCProcCmd_RECEIVE                        = 0x08, /* Sec. 9.2: Optional */
    kSPCProcCmd_RECEIVE_COPY_RESULTS           = 0x84, /* Sec. 7.17: Optional */
    kSPCProcCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* Sec. 7.18: Optional */
    kSPCProcCmd_RELEASE_10                     = 0x57, /* Sec. 7.19: Optional */
    kSPCProcCmd_RELEASE_6                      = 0x17, /* Sec. 7.20: Optional */
    kSPCProcCmd_REPORT_LUNS                    = 0xA0, /* Sec. 7.22: Optional */
    kSPCProcCmd_REQUEST_SENSE                  = 0x03, /* Sec. 7.23: Mandatory */
    kSPCProcCmd_RESERVE_10                     = 0x56, /* Sec. 7.24: Optional */
    kSPCProcCmd_RESERVE_6                      = 0x16, /* Sec. 7.25: Optional */
    kSPCProcCmd_SEND                           = 0x0A, /* Sec. 9.3: Optional */
    kSPCProcCmd_SEND_DIAGNOSTICS               = 0x1D, /* Sec. 7.26: Mandatory */
    kSPCProcCmd_TEST_UNIT_READY                = 0x00, /* Sec. 7.27: Mandatory */
    kSPCProcCmd_WRITE_BUFFER                   = 0x3B  /* Sec. 7.29: Optional */
};

#pragma mark -
#pragma mark 0x04 SBC Write Once Commands
/* Commands defined by the T10:990-D SCSI-3 Block Commands (SBC) command
 * specification.  The definitions and section numbers are based on section 6.3
 * of the revision 8c, 13 November 1997 version of the specification. 
 */
enum
{
    kSBCWOCmd_CHANGE_DEFINITION              = 0x40, /* SPC: Optional */
    kSBCWOCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSBCWOCmd_COPY                           = 0x18, /* SPC: Optional */
    kSBCWOCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional*/
    kSBCWOCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSBCWOCmd_LOCK_UNLOCK_CACHE              = 0x36, /* Sec. 6.1.2: Optional */
    kSBCWOCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSBCWOCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSBCWOCmd_MEDIUM_SCAN                    = 0x38, /* Sec. 6.2.3: Optional */
    kSBCWOCmd_MODE_SELECT_6                  = 0x15, /* SPC: Optional */
    kSBCWOCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSBCWOCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Optional */
    kSBCWOCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSBCWOCmd_MOVE_MEDIUM                    = 0xA5, /* SMC: Optional */
    kSBCWOCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* SPC: Optional */
    kSBCWOCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* SPC: Optional */
    kSBCWOCmd_PREFETCH                       = 0x34, /* Sec. 6.1.3: Optional */
    kSBCWOCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* SPC: Optional */
    kSBCWOCmd_READ_6                         = 0x08, /* Sec. 6.1.4: Optional */
    kSBCWOCmd_READ_10                        = 0x28, /* Sec. 6.1.5: Mandatory */
    kSBCWOCmd_READ_12                        = 0xA8, /* Sec. 6.2.4: Optional */
    kSBCWOCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSBCWOCmd_READ_CAPACITY                  = 0x25, /* Sec. 6.1.6: Mandatory */
    kSBCWOCmd_READ_ELEMENT_STATUS            = 0xB8, /* SMC: Optional */
    kSBCWOCmd_READ_LONG                      = 0x3E, /* Sec. 6.1.8: Optional */
    kSBCWOCmd_REASSIGN_BLOCKS                = 0x07, /* Sec. 6.1.9: Optional */
    kSBCWOCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSBCWOCmd_RELEASE_6                      = 0x17, /* SPC: Optional */
    kSBCWOCmd_RELEASE_10                     = 0x57, /* SPC: Mandatory */
    kSBCWOCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSBCWOCmd_RESERVE_6                      = 0x16, /* SPC: Optional */
    kSBCWOCmd_RESERVE_10                     = 0x56, /* SPC: Mandatory */
    kSBCWOCmd_REZERO_UNIT                    = 0x01, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_EQUAL_10           = 0x31, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_EQUAL_12           = 0xB1, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_HIGH_10            = 0x30, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_HIGH_12            = 0xB0, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_LOW_10             = 0x32, /* Obsolete */
    kSBCWOCmd_SEARCH_DATA_LOW_12             = 0xB2, /* Obsolete */
    kSBCWOCmd_SEEK_6                         = 0x0B, /* Obsolete */
    kSBCWOCmd_SEEK_10                        = 0x2B, /* Sec. 6.1.12: Optional */
    kSBCWOCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSBCWOCmd_SET_LIMITS_10                  = 0x33, /* Sec. 6.1.13: Optional */
    kSBCWOCmd_SET_LIMITS_12                  = 0xB3, /* Sec. 6.2.8: Optional */
    kSBCWOCmd_START_STOP_UNIT                = 0x1B, /* Sec. 6.1.14: Optional */
    kSBCWOCmd_SYNCHRONIZE_CACHE              = 0x35, /* Sec. 6.1.15: Optional */
    kSBCWOCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSBCWOCmd_VERIFY_10                      = 0x2F, /* Sec. 6.2.10: Optional */
    kSBCWOCmd_VERIFY_12                      = 0xAF, /* Sec. 6.2.11: Optional */
    kSBCWOCmd_WRITE_6                        = 0x0A, /* Sec. 6.1.17: Optional */
    kSBCWOCmd_WRITE_10                       = 0x2A, /* Sec. 6.2.10: Mandatory*/
    kSBCWOCmd_WRITE_12                       = 0xAA, /* Sec. 6.2.13: Optional */
    kSBCWOCmd_WRITE_AND_VERIFY_10            = 0x2E, /* Sec. 6.2.14: Optional */
    kSBCWOCmd_WRITE_AND_VERIFY_12            = 0xAE, /* Sec. 6.2.15: Optional */
    kSBCWOCmd_WRITE_BUFFER                   = 0x3B, /* SPC: Optional */
    kSBCWOCmd_WRITE_LONG                     = 0x3F  /* Sec. 6.1.20: Optional */
};

#pragma mark -
#pragma mark 0x05 MMC CD-ROM Commands
/* Commands defined by the T10:1363-D SCSI Multimedia Commands-3 (MMC-3) 
 * specification.  The definitions and section numbers are based on section 6.1
 * of the revision 01, March 03, 2000 version of the specification. 
 *
 * NOTE: The comments following each command may not be accurate.  These are
 * not from the MMC-3 specification, but have been derived from the SCSI-2 and
 * original MMC specifications.  Unlike the other SCSI command specifications,
 * MMC-2 and MMC-3 do not provide a command requirement type and therefore does
 * not relist the SPC commands with these requirements as they apply to MMC
 * devices.  The MMC-2 and MMC-3 specifications also refer back to the SBC
 * specification which seems invalid since MMC devices do not represent a
 * Peripheral Device Type defined by SBC.  It is assumed that the SBC
 * references refer to the Peripheral Device Type 0x00 - Direct Access Commands
 * definitions from that specification.
 */
enum 
{
    kMMCCmd_BLANK                          = 0xA1, /* Sec. 6.1.1: */
    kMMCCmd_CHANGE_DEFINITION              = 0x40, /* Obsolete */
    kMMCCmd_CLOSE_TRACK_SESSION            = 0x5B, /* Sec. 6.1.2: */
    kMMCCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kMMCCmd_COPY                           = 0x18, /* SPC: Optional */
    kMMCCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kMMCCmd_ERASE                          = 0x2C, /* SBC: */
    kMMCCmd_FORMAT_UNIT                    = 0x04, /* Sec. 6.1.3: */
    kMMCCmd_GET_CONFIGURATION              = 0x46, /* Sec. 6.1.4: */
    kMMCCmd_GET_EVENT_STATUS_NOTIFICATION  = 0x4A, /* Sec. 6.1.5: */
    kMMCCmd_GET_PERFORMANCE                = 0xAC, /* Sec. 6.1.6: */
    kMMCCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kMMCCmd_LOAD_UNLOAD_MEDIUM             = 0xA6, /* Sec. 6.1.7: */
    kMMCCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kMMCCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kMMCCmd_MECHANISM_STATUS               = 0xBD, /* Sec. 6.1.8: */
    kMMCCmd_MODE_SELECT_6                  = 0x15, /* SPC: Mandatory */
    kMMCCmd_MODE_SELECT_10                 = 0x55, /* SPC: Mandatory */
    kMMCCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Mandatory */
    kMMCCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Mandatory */
    kMMCCmd_PAUSE_RESUME                   = 0x4B, /* Sec. 6.1.9: */
    kMMCCmd_PLAY_AUDIO_10                  = 0x45, /* Sec. 6.1.10: */
    kMMCCmd_PLAY_AUDIO_12                  = 0xA5, /* Sec. 6.1.11: */
    kMMCCmd_PLAY_AUDIO_MSF                 = 0x47, /* Sec. 6.1.12: */
    kMMCCmd_PLAY_AUDIO_TRACK_INDEX         = 0x48, /* Obsolete */
    kMMCCmd_PLAY_CD                        = 0xBC, /* Sec. 6.1.13: */
    kMMCCmd_PLAY_RELATIVE_10               = 0x49, /* Obsolete */
    kMMCCmd_PLAY_RELATIVE_12               = 0xA9, /* Obsolete */
    kMMCCmd_PREFETCH                       = 0x34, /* Optional */
    kMMCCmd_PREVENT_ALLOW_MEDIUM_REMOVAL   = 0x1E, /* Optional */
    kMMCCmd_READ_6                         = 0x08, /* Optional */
    kMMCCmd_READ_10                        = 0x28, /* Mandatory */
    kMMCCmd_READ_12                        = 0xA8, /* Optional */
    kMMCCmd_READ_BUFFER                    = 0x3C, /* Optional */
    kMMCCmd_READ_BUFFER_CAPACITY           = 0x5C, /* Sec. 6.1.15: */
    kMMCCmd_READ_CD                        = 0xBE, /* Sec. 6.1.16: */
    kMMCCmd_READ_CD_MSF                    = 0xB9, /* Sec. 6.1.17: */
    kMMCCmd_READ_CAPACITY                  = 0x25, /* Sec. 6.1.18: */
    kMMCCmd_READ_DISC_INFORMATION          = 0x51, /* Sec. 6.1.19: */
    kMMCCmd_READ_DVD_STRUCTURE             = 0xAD, /* Sec. 6.1.20: */
    kMMCCmd_READ_DISC_STRUCTURE            = 0xAD, /* Sec. 6.1.20: */
    kMMCCmd_READ_FORMAT_CAPACITIES         = 0x23, /* Sec. 6.1.21: */
    kMMCCmd_READ_HEADER                    = 0x44, /* Sec. 6.1.22: */
    kMMCCmd_READ_LONG                      = 0x3E, /* Optional */
    kMMCCmd_READ_MASTER_CUE                = 0x59, /* Sec. 6.1.23: */
    kMMCCmd_READ_SUB_CHANNEL               = 0x42, /* Sec. 6.1.24: */
    kMMCCmd_READ_TOC_PMA_ATIP              = 0x43, /* Sec. 6.1.25: */
    kMMCCmd_READ_TRACK_INFORMATION         = 0x52, /* Sec. 6.1.27: */
    kMMCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* Optional */
    kMMCCmd_RELEASE_6                      = 0x17, /* Mandatory */
    kMMCCmd_RELEASE_10                     = 0x57, /* Optional */
    kMMCCmd_REPAIR_TRACK                   = 0x58, /* Sec. 6.1.28: */
    kMMCCmd_REPORT_KEY                     = 0xA4, /* Sec. 6.1.29: */
    kMMCCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kMMCCmd_RESERVE_6                      = 0x16, /* Mandatory */
    kMMCCmd_RESERVE_10                     = 0x56, /* Optional */
    kMMCCmd_RESERVE_TRACK                  = 0x53, /* Sec. 6.1.30: */
    kMMCCmd_SCAN_MMC                       = 0xBA, /* Sec. 6.1.31: */
    kMMCCmd_SEARCH_DATA_EQUAL_10           = 0x31, /* Obsolete */
    kMMCCmd_SEARCH_DATA_EQUAL_12           = 0xB1, /* Obsolete */
    kMMCCmd_SEARCH_DATA_HIGH_10            = 0x30, /* Obsolete */
    kMMCCmd_SEARCH_DATA_HIGH_12            = 0xB0, /* Obsolete */
    kMMCCmd_SEARCH_DATA_LOW_10             = 0x32, /* Obsolete */
    kMMCCmd_SEARCH_DATA_LOW_12             = 0xB2, /* Obsolete */
    kMMCCmd_SEEK_6                         = 0x0B, /* Obsolete */
    kMMCCmd_SEEK_10                        = 0x2B, /* SBC: */
    kMMCCmd_SEND_CUE_SHEET                 = 0x5D, /* Sec. 6.1.32: */
    kMMCCmd_SEND_DIAGNOSTICS               = 0x1D, /* Mandatory */
    kMMCCmd_SEND_DVD_STRUCTURE             = 0xBF, /* Sec. 6.1.33: */
    kMMCCmd_SEND_EVENT                     = 0xA2, /* Sec. 6.1.34: */
    kMMCCmd_SEND_KEY                       = 0xA3, /* Sec. 6.1.35: */
    kMMCCmd_SEND_OPC_INFORMATION           = 0x54, /* Sec. 6.1.36: */
    kMMCCmd_SET_CD_SPEED                   = 0xBB, /* Sec. 6.1.37: */
    kMMCCmd_SET_LIMITS_10                  = 0x33, /* Optional */
    kMMCCmd_SET_LIMITS_12                  = 0xB3, /* Optional */
    kMMCCmd_SET_READ_AHEAD                 = 0xA7, /* Sec. 6.1.38: */
    kMMCCmd_SET_STREAMING                  = 0xB6, /* Sec. 6.1.39: */
    kMMCCmd_START_STOP_UNIT                = 0x1B, /* Optional */
    kMMCCmd_STOP_PLAY_SCAN                 = 0x4E, /* Sec. 6.1.40: */
    kMMCCmd_SYNCHRONIZE_CACHE              = 0x35, /* Sec. 6.1.41: */
    kMMCCmd_TEST_UNIT_READY                = 0x00, /* Mandatory */
    kMMCCmd_VERIFY_10                      = 0x2F, /* Optional */
    kMMCCmd_VERIFY_12                      = 0xAF, /* Optional */
    kMMCCmd_WRITE_10                       = 0x2A, /* Sec. 6.1.42: */
    kMMCCmd_WRITE_12                       = 0xAA, /* Sec. 6.1.43: */
    kMMCCmd_WRITE_AND_VERIFY_10            = 0x2E, /* Sec. 6.1.44: */
    kMMCCmd_WRITE_BUFFER                   = 0x3B  /* Optional */
};

#pragma mark -
#pragma mark 0x06 SGC Scanner Commands
/* Commands defined by the T10:998-D SCSI-3 Graphics Commands (SGC)
 * specification.  The definitions and section numbers are based on section 6
 * of the revision 0, April 1995 version of the specification. 
 */
enum 
{
    kSGCCmd_CHANGE_DEFINITION              = 0x40, /* SPC: Optional */
    kSGCCmd_COMPARE                        = 0x39, /* SPC: Optional */
    kSGCCmd_COPY                           = 0x18, /* SPC: Optional */
    kSGCCmd_COPY_AND_VERIFY                = 0x3A, /* SPC: Optional */
    kSGCCmd_GET_DATA_BUFFER_STATUS         = 0x34, /* Sec. 6.1.1: Optional */
    kSGCCmd_GET_WINDOW                     = 0x25, /* Sec. 6.1.2: Optional */
    kSGCCmd_INQUIRY                        = 0x12, /* SPC: Mandatory */
    kSGCCmd_LOG_SELECT                     = 0x4C, /* SPC: Optional */
    kSGCCmd_LOG_SENSE                      = 0x4D, /* SPC: Optional */
    kSGCCmd_MODE_SELECT_6                  = 0x15, /* SPC: Optional */
    kSGCCmd_MODE_SELECT_10                 = 0x55, /* SPC: Optional */
    kSGCCmd_MODE_SENSE_6                   = 0x1A, /* SPC: Optional */
    kSGCCmd_MODE_SENSE_10                  = 0x5A, /* SPC: Optional */
    kSGCCmd_OBJECT_POSITION                = 0x31, /* Sec. 6.1.3: Optional */
    kSGCCmd_PORT_STATUS                    = 0x11, /* SPC (??): Mandatory
													* for dual port devices */
    kSGCCmd_READ                           = 0x28, /* Sec. 6.1.4: Mandatory */
    kSGCCmd_READ_BUFFER                    = 0x3C, /* SPC: Optional */
    kSGCCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x1C, /* SPC: Optional */
    kSGCCmd_RELEASE_6                      = 0x17, /* SPC: Mandatory */
    kSGCCmd_REQUEST_SENSE                  = 0x03, /* SPC: Mandatory */
    kSGCCmd_RESERVE_6                      = 0x16, /* SPC: Mandatory */
    kSGCCmd_SCAN                           = 0x1B, /* Sec. 6.1.5: Optional */
    kSGCCmd_SEND                           = 0x1B, /* Sec. 6.1.6: Optional */
    kSGCCmd_SEND_DIAGNOSTICS               = 0x1D, /* SPC: Mandatory */
    kSGCCmd_SET_WINDOW                     = 0x24, /* Sec. 6.1.7: Mandatory */
    kSGCCmd_TEST_UNIT_READY                = 0x00, /* SPC: Mandatory */
    kSGCCmd_WRITE_BUFFER                   = 0x3B  /* SPC: Optional */
};

#pragma mark -
#pragma mark 0x07 SBC Optical Media Commands
/* Commands defined by the T10:990-D SCSI-3 Block Commands (SBC) 
 * (revision 8c, 13 November 1998) command specification.  
 */

#pragma mark -
#pragma mark 0x08 SMC Medium Changer Commands
/* Commands defined by the T10:1228-D SCSI-3 Medium Changer Commands-2 (SMC-2)
 * (revision 0, March 16, 2000) command specification.  
 */
enum
{
    /* Commands For Independent Medium Changers */
    kSMCCmd_EXCHANGE_MEDIUM                = 0xA6, /* Optional */
    kSMCCmd_INITIALIZE_ELEMENT_STATUS      = 0x07, /* Optional */
    kSMCCmd_MODE_SELECT_6                  = 0x15, /* Optional */
    kSMCCmd_MODE_SELECT_10                 = 0x55, /* Optional */
    kSMCCmd_MODE_SENSE_6                   = 0x1A, /* Optional */
    kSMCCmd_MODE_SENSE_10                  = 0x5A, /* Optional */
    kSMCCmd_MOVE_MEDIUM                    = 0xA5, /* Mandatory */
    kSMCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Optional */
    kSMCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Optional */
    kSMCCmd_POSITION_TO_ELEMENT            = 0x2B, /* Optional */
    kSMCCmd_READ_ELEMENT_STATUS            = 0xB8, /* Mandatory */
    kSMCCmd_RELEASE_ELEMENT_6              = 0x16, /* Optional */
    kSMCCmd_RELEASE_ELEMENT_10             = 0x56, /* Optional */
    kSMCCmd_REQUEST_VOLUME_ELEMENT_ADDRESS = 0xB5, /* Optional */
    kSMCCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kSMCCmd_RESERVE_ELEMENT_6              = 0x16, /* Optional */
    kSMCCmd_RESERVE_ELEMENT_10             = 0x56  /* Optional */
};

#pragma mark -
#pragma mark 0x09 SSC Communications Commands
/* Commands defined by the T10:997-D SCSI-3 Stream Commands (SSC) 
 * (revision 22, January 1, 2000) command specification. 
 */
  
#pragma mark -
#pragma mark 0x0A ASC IT8 Prepress Commands
#pragma mark 0x0B ASC IT8 Prepress Commands
/* Commands defined by the ASC IT8 <title goes here> specification
 * (revision xx, month day, year) command specification.  
 */
#if 0
enum
{
};
#endif

#pragma mark -
#pragma mark 0x0C SCC Array Controller Commands
/* Commands defined by the ANSI NCITS.318-199x SCSI Controller
 * Commands (SCC-2) ratified command specification.  
 */
enum
{
    kSCCCmd_MAINTENANCE_IN                 = 0xA3, /* Mandatory */
    kSCCCmd_MAINTENANCE_OUT                = 0xA4, /* Optional */
    kSCCCmd_MODE_SELECT_6                  = 0x15, /* Optional */
    kSCCCmd_MODE_SELECT_10                 = 0x55, /* Optional */
    kSCCCmd_MODE_SENSE_6                   = 0x1A, /* Optional */
    kSCCCmd_MODE_SENSE_10                  = 0x5A, /* Optional */
    kSCCCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Optional */
    kSCCCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Optional */
    kSCCCmd_PORT_STATUS                    = 0x1F, /* Optional */
    kSCCCmd_REDUNDANCY_GROUP_IN            = 0xBA, /* Mandatory */
    kSCCCmd_REDUNDANCY_GROUP_OUT           = 0xBB, /* Optional */
    kSCCCmd_RELEASE_6                      = 0x17, /* Optional */
    kSCCCmd_RELEASE_10                     = 0x57, /* Optional */
    kSCCCmd_REPORT_LUNS                    = 0xA0, /* Mandatory */
    kSCCCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kSCCCmd_RESERVE_6                      = 0x16, /* Optional */
    kSCCCmd_RESERVE_10                     = 0x56, /* Optional*/
    kSCCCmd_SEND_DIAGNOSTICS               = 0x1D, /* Optional */
    kSCCCmd_SPARE_IN                       = 0xBC, /* Mandatory */
    kSCCCmd_SPARE_OUT                      = 0xBD  /* Optional */
};

#pragma mark -
#pragma mark 0x0D SES Enclosure Services Commands
/* Commands defined by the T10:1212-D SCSI-3 Enclosure Services (SES) 
 * (revision 8b, February 11, 1998) command specification.  
 */
enum
{
    kSESCmd_MODE_SELECT_6                  = 0x15, /* Optional */
    kSESCmd_MODE_SELECT_10                 = 0x55, /* Optional */
    kSESCmd_MODE_SENSE_6                   = 0x1A, /* Optional */
    kSESCmd_MODE_SENSE_10                  = 0x5A, /* Optional */
    kSESCmd_PERSISTENT_RESERVE_IN          = 0x5E, /* Optional */
    kSESCmd_PERSISTENT_RESERVE_OUT         = 0x5F, /* Optional */
    kSESCmd_RECEIVE_DIAGNOSTICS_RESULTS    = 0x17, /* Mandatory */
    kSESCmd_RELEASE_6                      = 0x17, /* Optional */
    kSESCmd_RELEASE_10                     = 0x57, /* Optional */
    kSESCmd_REQUEST_SENSE                  = 0x03, /* Mandatory */
    kSESCmd_RESERVE_6                      = 0x16, /* Optional */
    kSESCmd_RESERVE_10                     = 0x56, /* Optional */
    kSESCmd_SEND_DIAGNOSTICS               = 0x1D  /* Mandatory */
};

#pragma mark -
#pragma mark 0x0E RBC Reduced Block Commands
/* Commands defined by the T10:1240-D Reduced Block Commands (RBC) 
 * (revision 10a, August 18, 1999) command specification.  
 */
enum
{
    kRBCCmd_FORMAT_UNIT                    = 0x04, /* Optional */
    kRBCCmd_READ_10                        = 0x28, /* Mandatory */
    kRBCCmd_READ_CAPACITY                  = 0x25, /* Mandatory */
    kRBCCmd_START_STOP_UNIT                = 0x1B, /* Mandatory */
    kRBCCmd_SYNCHRONIZE_CACHE              = 0x35, /* Optional */
    kRBCCmd_VERIFY_10                      = 0x2F, /* Mandatory */
    kRBCCmd_WRITE_10                       = 0x2A, /* Mandatory */
    kRBCCmd_WRITE_BUFFER                   = 0x3B  /* Mandatory for fixed media
												    * Optional for removable */
};

#pragma mark -
#pragma mark 0x0F OCRW Optical Card Commands
/* Commands defined by the ISO/IEC 14776-381 SCSI Specification for
 * Optical Card Reader/Writer (OCRW) ratified command specification.  
 */
#if 0
enum
{
};
#endif

#pragma mark -
#pragma mark 0x11 OSD Object-based Storage Commands
/* Commands defined by the T10:1355-D Object-based Storage Commands (OSD) 
 * (revision 1, 18 May 2000) command specification.  
 */
#if 0
enum
{
};
#endif

#pragma mark -
#pragma mark 0x15 RMC Simplified Multimedia Commands
/* Commands defined by the T10:1364-D Reduced Multimedia Commands (RMC) 
 * (revision 1, November 11, 1999) command specification.  
 */
#if 0
enum
{
};
#endif

#endif	/* _SCSI_COMMAND_OPERATION_CODES_H_ */
                                                                                                                                                                                                                                     SCSIPort.h                                                                                          0100644 0001750 0001750 00000003765 12567470660 034563  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 2004-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_SCSI_PORTS_H_
#define _IOKIT_SCSI_PORTS_H_


/*! @header SCSIPort
	@discussion
	This file contains all the definitions for SCSIPort notifications and status.
*/


/*!
@enum kSCSIPort_NotificationStatusChange
@discussion
Message definition to be used with the messageClients
call to inform of a change in port status.
*/
enum
{
	kSCSIPort_NotificationStatusChange		= 0x68000001
};


/*! @typedef SCSIPortStatus
	@abstract 32-bit number to represent a SCSIPortStatus.
	@discussion Type for SCSIPortStatus.
*/

typedef UInt32 SCSIPortStatus;

/*! @enum SCSI Port Status Values
	@discussion Definitions for the possible port status values
*/
enum
{
	/*!
	@constant kSCSIPort_StatusOnline
	The port is online.
	*/
	kSCSIPort_StatusOnline	= 0,

	/*!
	@constant kSCSIPort_StatusOffline
	The port is offline (e.g. unplugged cable).
	*/
	kSCSIPort_StatusOffline	= 1,

	/*!
	@constant kSCSIPort_StatusFailure
	Driver has detected unrecoverable port failure (e.g. hardware port failure)
	*/
	kSCSIPort_StatusFailure	= 2
};

#endif	/* _IOKIT_SCSI_PORTS_H_ */
           SCSITask.h                                                                                          0100644 0001750 0001750 00000035162 12567470660 034535  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_SCSI_TASK_H_
#define _IOKIT_SCSI_TASK_H_


#if KERNEL
#include <IOKit/IOTypes.h>
#else
#include <CoreFoundation/CoreFoundation.h>
#endif


/*! @header SCSITask
SCSITask typedefs and constants used inside the kernel and user space.

Note that the SCSITaskIdentifier is an opaque object and that directly
casting the SCSITaskIdentifier to any other type is discouraged. The SCSITask
implementation changes when necessary to accomodate architectural changes,
performance improvements, and bug fixes.

Device and protocol layer drivers that need to access information
contained in a SCSITask should use the appropriate accessor methods in
IOSCSIPrimaryCommandsDevice.h or IOSCSIProtocolServices.h
*/


/*! @typedef SCSIDeviceIdentifier
    @abstract 64-bit number to represent a SCSI Device.
	@discussion If the identifier can either be that of an initiator or a target,
    SCSIDeviceIdentifier should be used.
*/

typedef UInt64 					SCSIDeviceIdentifier;

/*! @typedef SCSITargetIdentifier
    @abstract 64-bit number to represent a SCSI Target Device.
	@discussion If the identifier is for a target only and not an initiator, then
	SCSITargetIdentifier should be used.
*/

typedef SCSIDeviceIdentifier 	SCSITargetIdentifier;

/*! @typedef SCSIInitiatorIdentifier
    @abstract 64-bit number to represent a SCSI Initiator Device.
	@discussion If the identifier is for an initiator only and not a target, then
	SCSIInitiatorIdentifier should be used.
*/

typedef SCSIDeviceIdentifier 	SCSIInitiatorIdentifier;

/*! @typedef SCSILogicalUnitBytes[8]
    @abstract 8-Byte array to represent LUN information
    @discussion The SCSI Primary Commands specification treats the 64-bits
	of LUN information as 4 2-byte structures.
	
	Use of the 64-bit SCSILogicalUnitNumber is now deprecated. Since it
	was not defined on Mac OS X how the 64-bits were encoded for hierarchical
	units and all usage was simply as a 64-bit number, changing the encoding
	scheme now would result in non-binary compatible code. New APIs have been
	added to retrieve the LUN bytes from the SCSITask and set them in the SCSITask.
 */
typedef UInt8					SCSILogicalUnitBytes[8];
typedef UInt64					SCSILogicalUnitNumber;          // DEPRECATED


/*! @typedef SCSITaggedTaskIdentifier
    @abstract 64-bit number to represent a unique task identifier.
	@discussion The Tagged Task Identifier is used when a Task has a Task Attribute other
	than SIMPLE. The SCSI Application Layer client that controls the Logical
	Unit for which a Task is intended is required to guarantee that the Task
	Tag Identifier is unique. Zero cannot be used a a Tag value as this is used
	to when a Tagged Task Identifier value is needed for a Task with a SIMPLE 
	attribute.
*/

typedef UInt64 SCSITaggedTaskIdentifier;

/*!
	@enum Untagged Task Identifier
	@discussion The Untagged Task Identifier is used to indicate no unique tag
	is associated with the Task.
	@constant kSCSIUntaggedTaskIdentifier This value means the task is untagged.
 */

enum
{
	kSCSIUntaggedTaskIdentifier = 0
};

/*!
	@typedef SCSITaskAttribute
	@abstract Attributes for task delivery.
	@discussion The Task Attribute defines how this task should be managed
	when determing order for queueing and submission to the 
	appropriate device server. The Task Attribute is set by the SCSI
	Application Layer and cannot be modified by the SCSI Protocol Layer.
	@constant kSCSITask_SIMPLE The task has a simple attribute.
	@constant kSCSITask_ORDERED The task has an ordered attribute.
	@constant kSCSITask_HEAD_OF_QUEUE The task has a head-of-queue attribute.
	@constant kSCSITask_ACA The task has an auto-contingent-allegiance attribute.
 */

typedef enum SCSITaskAttribute
{
	kSCSITask_SIMPLE			= 0,
	kSCSITask_ORDERED			= 1,
	kSCSITask_HEAD_OF_QUEUE		= 2,
	kSCSITask_ACA				= 3
} SCSITaskAttribute;

/*!
	@typedef SCSITaskState
	@abstract Attributes for task state.
	@discussion The Task State represents the current state of the task.
	The state is set to NEW_TASK when the task is created.  The SCSI Protocol
	Layer will then adjust the state as the task is queued and during
	execution. The SCSI Application Layer can examine the state to monitor
	the progress of a task. The Task State can only be modified by the SCSI
	Protocol Layer.  The SCSI Application Layer can only read the state.
	@constant kSCSITaskState_NEW_TASK The task state is new task.
	@constant kSCSITaskState_ENABLED The task is enabled and queued.
	@constant kSCSITaskState_BLOCKED The task is blocked.
	@constant kSCSITaskState_DORMANT The task is dormant.
	@constant kSCSITaskState_ENDED The task is complete.
 */

typedef enum SCSITaskState
{
	kSCSITaskState_NEW_TASK		= 0,
	kSCSITaskState_ENABLED		= 1,
	kSCSITaskState_BLOCKED		= 2,
	kSCSITaskState_DORMANT		= 3,
	kSCSITaskState_ENDED		= 4
} SCSITaskState;


/*!
	@typedef SCSIServiceResponse
	@abstract Attributes for task service response.
	@discussion The Service Response represents the execution status of
	a service request made to a Protocol Services Driver. The Service
	Response can only be modified by the SCSI Protocol Layer. The SCSI
	Application Layer can only read the state.
 */

typedef enum SCSIServiceResponse
{
	/*!
	@constant kSCSIServiceResponse_Request_In_Process
	Not defined in SAM specification, but is a service response used
	for asynchronous commands that are not yet completed.
	*/
	kSCSIServiceResponse_Request_In_Process					= 0,

	/*!
	@constant kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE
	The service request failed because of a delivery or target failure.
	*/
	kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE	= 1,

	/*!
	@constant kSCSIServiceResponse_TASK_COMPLETE
	The task completed.
	*/
	kSCSIServiceResponse_TASK_COMPLETE 						= 2,
	
	/*!
	@constant kSCSIServiceResponse_LINK_COMMAND_COMPLETE
	The linked command completed.
	*/
	kSCSIServiceResponse_LINK_COMMAND_COMPLETE				= 3,
	
	/*!
	@constant kSCSIServiceResponse_FUNCTION_COMPLETE
	The task management function completed.
	*/
	kSCSIServiceResponse_FUNCTION_COMPLETE					= 4,
	
	/*!
	@constant kSCSIServiceResponse_FUNCTION_REJECTED
	The task management function was rejected.
	*/
	kSCSIServiceResponse_FUNCTION_REJECTED					= 5
} SCSIServiceResponse;

/*!
	@typedef SCSITaskStatus
	@abstract Attributes for task status.
	@discussion The Task Status represents the completion status
	of the task which provides the  SCSI Application Layer with
	additional information about how to procede in handling a
	completed task.
	
	The SCSI Architecture Model specification only defines task
	status values for when a task completes with a service response
	of either TASK_COMPLETED or LINK_COMMAND_COMPLETE.
	
	Since additional information will aid in error recovery when
	a task fails to be completed by a device due to a service
	response of kSCSIServiceResponse_SERVICE_DELIVERY_OR_TARGET_FAILURE,
	additional values have been defined that can be returned by the
	SCSI Protocol Layer to inform the SCSI Application Layer of the
	cause of the delivery failure.
	
	The Task Status can only be modified by the SCSI Protocol Layer.
	The SCSI Application Layer can only read the status
*/
typedef enum SCSITaskStatus
{
	
	/*!
	@constant kSCSITaskStatus_GOOD
	The task completed with a status of GOOD.
	*/
	
	kSCSITaskStatus_GOOD						= 0x00,

	/*!
	@constant kSCSITaskStatus_CHECK_CONDITION
	The task completed with a status of CHECK_CONDITION. Additional
	information about the condition should be available in the sense data.
	*/
	
	kSCSITaskStatus_CHECK_CONDITION				= 0x02,
	
	/*!
	@constant kSCSITaskStatus_CONDITION_MET
	The task completed with a status of CONDITION_MET.
	*/
	
	kSCSITaskStatus_CONDITION_MET				= 0x04,
	
	/*!
	@constant kSCSITaskStatus_BUSY
	The task completed with a status of BUSY. The device server might need
	time to process a request and a delay may be required.
	*/
	kSCSITaskStatus_BUSY						= 0x08,

	/*!
	@constant kSCSITaskStatus_INTERMEDIATE
	The task completed with a status of INTERMEDIATE.
	*/
	kSCSITaskStatus_INTERMEDIATE				= 0x10,

	/*!
	@constant kSCSITaskStatus_INTERMEDIATE_CONDITION_MET
	The task completed with a status of INTERMEDIATE_CONDITION_MET.
	*/
	kSCSITaskStatus_INTERMEDIATE_CONDITION_MET	= 0x14,

	/*!
	@constant kSCSITaskStatus_RESERVATION_CONFLICT
	The task completed with a status of RESERVATION_CONFLICT.
	*/
	kSCSITaskStatus_RESERVATION_CONFLICT		= 0x18,

	/*!
	@constant kSCSITaskStatus_TASK_SET_FULL
	The task completed with a status of TASK_SET_FULL. The device server
	may need to complete a task before the initiator sends another.
	*/
	kSCSITaskStatus_TASK_SET_FULL				= 0x28,
	
	/*!
	@constant kSCSITaskStatus_ACA_ACTIVE
	The task completed with a status of ACA_ACTIVE. The device server may
	need the initiator to clear the Auto-Contingent Allegiance condition
	before it will respond to new commands.
	*/
	kSCSITaskStatus_ACA_ACTIVE					= 0x30,
	
	/*!
	@constant kSCSITaskStatus_TaskTimeoutOccurred
	If a task is aborted by the SCSI Protocol Layer due to it exceeding
	the timeout value specified by the task, the task status shall be
	set to kSCSITaskStatus_TaskTimeoutOccurred.
	*/
	
	kSCSITaskStatus_TaskTimeoutOccurred			= 0x01,
	
	/*!
	@constant kSCSITaskStatus_ProtocolTimeoutOccurred
	If a task is aborted by the SCSI Protocol Layer due to it exceeding a
	timeout value specified by the support for the protocol or a related
	specification, the task status shall be set to
	kSCSITaskStatus_ProtocolTimeoutOccurred.
	*/
	
	kSCSITaskStatus_ProtocolTimeoutOccurred		= 0x02,
	
	/*!
	@constant kSCSITaskStatus_DeviceNotResponding
	If a task is unable to be delivered due to a failure of the device not
	accepting the task or the device acknowledging the attempt to send it the
	device the task status shall be set to kSCSITaskStatus_DeviceNotResponding.
	This will allow the SCSI Application driver to perform the necessary steps
	to try to recover the device. This shall only be reported after the SCSI
	Protocol Layer driver has attempted all protocol specific attempts to recover
	the device.
	*/
	
	kSCSITaskStatus_DeviceNotResponding			= 0x03,
	
	/*!
	@constant kSCSITaskStatus_DeviceNotPresent
	If the task is unable to be delivered because the device has been
	detached, the task status shall be set to kSCSITaskStatus_DeviceNotPresent.
	This will allow the SCSI Application Layer to halt the sending of tasks
	to the device and, if supported, perform any device failover or system
	cleanup.
	*/
	kSCSITaskStatus_DeviceNotPresent			= 0x04,
	
	/*!
	@constant kSCSITaskStatus_DeliveryFailure
	If the task is unable to be
	delivered to the device due to a failure in the SCSI Protocol Layer,
	such as a bus reset or communications error, but the device is is
	known to be functioning properly, the task status shall be set to 
	kSCSITaskStatus_DeliveryFailure. This can also be reported if the
	task could not be delivered due to a protocol error that has since
	been corrected.
	 */
	kSCSITaskStatus_DeliveryFailure				= 0x05,
	
	/*!
	@constant kSCSITaskStatus_No_Status
	This status is not defined by
	the SCSI specifications, but is here to provide a status that can
	be returned in cases where there is not status available from the
	device or protocol, for example, when the service response is
	neither TASK_COMPLETED nor LINK_COMMAND_COMPLETE or when the
	service response is SERVICE_DELIVERY_OR_TARGET_FAILURE and the
	reason for failure could not be determined.
	*/
	kSCSITaskStatus_No_Status					= 0xFF
} SCSITaskStatus;

/*!
	@enum Command Descriptor Block Size
	@discussion Command Descriptor Block Size constants.
*/
enum
{
	/*!
	@constant kSCSICDBSize_Maximum This is the largest size a Command Descriptor
	Block can be as specified in SPC-2.
	*/
	kSCSICDBSize_Maximum 	= 16,

	/*!
	@constant kSCSICDBSize_6Byte Use this for a 6-byte CDB.
	*/
	kSCSICDBSize_6Byte 		= 6,

	/*!
	@constant kSCSICDBSize_10Byte Use this for a 10-byte CDB.
	*/
	kSCSICDBSize_10Byte 	= 10,

	/*!
	@constant kSCSICDBSize_12Byte Use this for a 12-byte CDB.
	*/
	kSCSICDBSize_12Byte 	= 12,

	/*!
	@constant kSCSICDBSize_16Byte Use this for a 16-byte CDB.
	*/
	kSCSICDBSize_16Byte 	= 16
};

typedef UInt8 SCSICommandDescriptorBlock[kSCSICDBSize_Maximum];

/*!
	@enum Data Transfer Direction
	@discussion DataTransferDirection constants.
*/
enum
{
	/*!
	@constant kSCSIDataTransfer_NoDataTransfer Use this for tasks
	that transfer no data.
	*/
	kSCSIDataTransfer_NoDataTransfer		= 0x00,

	/*!
	@constant kSCSIDataTransfer_FromInitiatorToTarget Use this for tasks that transfer
	data from the initiator to the target.
	*/
	kSCSIDataTransfer_FromInitiatorToTarget	= 0x01,

	/*!
	@constant kSCSIDataTransfer_FromTargetToInitiator Use this for tasks that transfer
	data from the target to the initiator.
	*/
	kSCSIDataTransfer_FromTargetToInitiator	= 0x02
};


#if defined(KERNEL) && defined(__cplusplus)

/* Libkern includes */
#include <libkern/c++/OSObject.h>


/*!
	@enum SCSITaskMode
	@discussion The SCSI Task mode is used by the SCSI
	Protocol Layer to indicate what mode the task is executing.
*/
typedef enum SCSITaskMode
{
	kSCSITaskMode_CommandExecution	= 1,
	kSCSITaskMode_Autosense			= 2
} SCSITaskMode;

/*!
	@typedef SCSITaskIdentifier
	@discussion This is an opaque object that represents a task.
	This is used so that drivers for both the SCSI Protocol Layer
	and the SCSI  Application Layer cannot modify the SCSITask object
	directly but must instead use the inherited methods to do so. This
	allows the implementation of SCSITask to change without directly
	impacting device and protocol layer drivers. In addition, it
	prevents changing of properties that are not allowed to be
	changed by a given layer.
*/
typedef OSObject *	SCSITaskIdentifier;


/*!
	@typedef SCSITaskCompletion
	@discussion This is the typedef for completion routines that
	work with SCSITaskIdentifiers.
*/
typedef void ( *SCSITaskCompletion )( SCSITaskIdentifier completedTask );


#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif /* _IOKIT_SCSI_TASK_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                              spi/                                                                                                0040755 0001750 0001750 00000000000 12612224742 033554  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi                                                           IOSCSIParallelInterfaceController.h                                                                 0100644 0001750 0001750 00000166057 12567471027 042305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/scsi/spi                                                       /*
 * Copyright (c) 2002-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __IOKIT_IO_SCSI_PARALLEL_INTERFACE_CONTROLLER_H__
#define __IOKIT_IO_SCSI_PARALLEL_INTERFACE_CONTROLLER_H__


 /*!
  @header IOSCSIParallelInterfaceController
	The IOSCSIParallelInterfaceController class and the associated HBA child
	class is responsible for the management of all related hardware. This
	includes the onboard HBA controller chip and the physical state of the
	bus. These classes are not responsible for any of the management of
	the SCSI Devices on the bus with the exception of maintaining the queue that 
	holds the objects representing those SCSI Devices.
*/


//-----------------------------------------------------------------------------
//	Includes
//-----------------------------------------------------------------------------

// General IOKit includes
#include <IOKit/IOService.h>
#include <IOKit/IOWorkLoop.h>
#include <IOKit/IOCommandGate.h>
#include <IOKit/IODMACommand.h>
#include <IOKit/IOInterruptEventSource.h>
#include <IOKit/IOFilterInterruptEventSource.h>
#include <IOKit/IOTimerEventSource.h>
#include <IOKit/IOCommandPool.h>

// IOKit SCSI ArchitectureModel Family includes
#include <IOKit/scsi/SCSITask.h>
#include <IOKit/scsi/SCSICmds_REQUEST_SENSE_Defs.h>
#include <IOKit/scsi/SCSIPort.h>

//-----------------------------------------------------------------------------
//	Constants
//-----------------------------------------------------------------------------


#define kIOPropertySCSIDeviceFeaturesKey			"SCSI Device Features"
#define kIOPropertySCSI_I_T_NexusFeaturesKey		"SCSI I_T Nexus Features"

// Set this key with a value of true in ReportHBAConstraints() to indicate support
// for full 8-byte LUN addressing and use GetLogicalUnitBytes() to obtain the
// full 8-byte LUN when processing commands in ProcessParallelTask().
#define kIOHierarchicalLogicalUnitSupportKey		"SCSI Hierarchical Logical Unit Support"

// This is the alignment mask used when allocating per-task HBA data. It allows
// the HBA to declare whether or not it supports 64-bit addressability and what the
// minimum byte alignment is for the data. E.g. By specifying 0x0000FFFFFFFFFFFEULL,
// the controller would be indicating that it supports 48-bits of addressability, but
// at a minimum of being 2-byte aligned.
#define kIOMinimumHBADataAlignmentMaskKey			"HBA Data Alignment"

// The Feature Selectors used to identify features of the SCSI Parallel
// Interface.  These are used by the DoesHBASupportSCSIParallelFeature
// to report whether the HBA supports a given SCSI Parallel Interface
// feature and are used for requesting negotiation and reporting negotiation
// results between the controller and the device.

// When the DoesHBASupportSCSIParallelFeature() member routine of the controller 
// child class is called, it will return true if the HBA that it controls 
// supports the specified SCSIParallelFeature or false if it does not.
typedef enum SCSIParallelFeature
{
	// The selector for support of Wide Data Transfers.  Only Wide16 is supported 
	// as Wide32 has been obsoleted by the SPI-3 specification.
	kSCSIParallelFeature_WideDataTransfer 					= 0,
	
	// The selector for support of Synchronous Data Transfers.
	kSCSIParallelFeature_SynchronousDataTransfer 			= 1,
	
	// The selector for support of Quick Arbitration and Selection (QAS).
	kSCSIParallelFeature_QuickArbitrationAndSelection 		= 2,
	
	// The selector for support of Double Transition (DT) data transfers.
	kSCSIParallelFeature_DoubleTransitionDataTransfers 		= 3,
	
	// The selector for SPI Information Unit (IU) transfers.
	kSCSIParallelFeature_InformationUnitTransfers 			= 4,
	
	// Since the Feature selectors are zero base, this will always have the 
	// correct total.
	kSCSIParallelFeature_TotalFeatureCount	
} SCSIParallelFeature;


typedef enum SCSIParallelFeatureRequest
{
	// This selector indicates that current negotiation 
	// should be used. 
	kSCSIParallelFeature_NoNegotiation 			= 0,
	
	// This selector indicates that the controller
	// should attempt negotiation for the feature
	kSCSIParallelFeature_AttemptNegotiation 	= 1,
	
	// This selector indicates that the controller
	// should clear any negotiation for the feature
	kSCSIParallelFeature_ClearNegotiation 		= 2
} SCSIParallelFeatureRequest;
	
typedef enum SCSIParallelFeatureResult
{
	kSCSIParallelFeature_NegotitiationUnchanged	= 0,
	kSCSIParallelFeature_NegotitiationCleared	= 1,
	kSCSIParallelFeature_NegotitiationSuccess	= 2
} SCSIParallelFeatureResult;


// The SCSI Message Codes used for MESSAGE IN and MESSAGE OUT phases.
enum SCSIParallelMessages
{
	// Link Control Messages
	kSCSIParallelMessage_TASK_COMPLETE						= 0x00,
	kSCSIParallelMessage_EXTENDED_MESSAGE					= 0x01,
	kSCSIParallelMessage_SAVE_DATA_POINTER	 				= 0x02,
	kSCSIParallelMessage_RESTORE_POINTERS					= 0x03,
	kSCSIParallelMessage_DISCONNECT							= 0x04,
	kSCSIParallelMessage_INITIATOR_DETECTED_ERROR 			= 0x05,
	kSCSIParallelMessage_MESSAGE_REJECT		 				= 0x07,
	kSCSIParallelMessage_NO_OPERATION		 				= 0x08,
	kSCSIParallelMessage_MESSAGE_PARITY_ERROR 				= 0x09,
	kSCSIParallelMessage_IGNORE_WIDE_RESIDUE				= 0x23,
	kSCSIParallelMessage_QAS_REQUEST		 				= 0x55,
	kSCSIParallelMessage_IDENTIFY							= 0x80,
	
	// The Message Codes used in the EXTENDED_MESSAGE message.
	kSCSIParallelMessage_MODIFY_DATA_POINTER				= 0x00,
	kSCSIParallelMessage_SYNCHONOUS_DATA_TRANSFER_REQUEST	= 0x01,
	// Reserved												= 0x02
	kSCSIParallelMessage_WIDE_DATA_TRANSFER_REQUEST			= 0x03,
	kSCSIParallelMessage_PARALLEL_PROTOCOL_REQUEST			= 0x04,
	// Reserved												= 0x05 through 0xFF
	
	// Task Attribute Message Codes
	kSCSIParallelMessage_ACA								= 0x24,
	kSCSIParallelMessage_HEAD_OF_QUEUE						= 0x21,
	kSCSIParallelMessage_LINKED_COMMAND_COMPLETE			= 0x0A,
	kSCSIParallelMessage_ORDERED							= 0x22,
	kSCSIParallelMessage_SIMPLE								= 0x20,
	
	// Task Management Message Codes
	kSCSIParallelMessage_ABORT_TASK							= 0x0D,
	kSCSIParallelMessage_ABORT_TASK_SET						= 0x06,
	kSCSIParallelMessage_CLEAR_ACA							= 0x16,
	kSCSIParallelMessage_CLEAR_TASK_SET						= 0x0E,
	kSCSIParallelMessage_LOGICAL_UNIT_RESET					= 0x17,
	kSCSIParallelMessage_TARGET_RESET						= 0x0C
};

enum
{
	kSCSIParallelTaskControllerIDQueueHead 		= 0
};

// Notifications
enum
{
	kSCSIControllerNotificationBusReset			= 0x68000000
};

// Forward declaration for the internally used Parallel Device object.
class IOSCSIParallelInterfaceDevice;

// This is the identifier that is used to specify a given parallel Task.
typedef OSObject *	SCSIParallelTaskIdentifier;


//-----------------------------------------------------------------------------
//	Class Declarations
//-----------------------------------------------------------------------------

/*! @class IOSCSIParallelInterfaceController
	@abstract Class that represents a SCSI Host Bus Adapter.
	@discussion Class that represents a SCSI Host Bus Adapter.
*/
class IOSCSIParallelInterfaceController : public IOService
{
	
	OSDeclareAbstractStructors ( IOSCSIParallelInterfaceController )
	
#if 0
#pragma mark -
#pragma mark Client API
#endif
	
	
public:
	
	/*!
		@function GetSCSIParallelTask
		@abstract Method to allow the client to get a SCSIParallelTask
		@discussion Get a SCSIParallelTask from the controller so that a request
		can be issued to the HBA driver.
		@param blockForCommand If the blockForCommand parameter is set to false
		and there are no free SCSIParallelTasks, this method will return NULL, 
		otherwise it will wait for one to become available before returning.
		@result If there is a SCSI Parallel Task available, a reference to it 
		will be returned.
	*/
	
	SCSIParallelTaskIdentifier	GetSCSIParallelTask ( bool blockForCommand );
	
	/*!
		@function FreeSCSIParallelTask
		@abstract Method to allow the client to release a SCSIParallelTask
		@discussion	The FreeSCSIParallelTask method is called by the client when 
		a SCSIParallelTask has been completed and the associated returnTask
		needs to be returned to the pool.
		@param returnTask is a reference to the SCSIParallelTaskIdentifier to be 
		returned.
	*/
	
	void FreeSCSIParallelTask ( SCSIParallelTaskIdentifier returnTask );
	
	/*!
		@function FindTaskForAddress
		@abstract Find a task for a given Task Address, if one exists.
		@discussion If a valid Tagged Task Identifier is specified, this method 
		will return the task specified by the Tagged Task Address if one is 
		found, or else NULL will be returned.  If zero is used as the Tagged 
		Task Identifier, then this routine will search for an outstanding task 
		based on the Untagged Task Address and return the task or else, if one 
		is not found, return NULL.
		@param theT is the Target component of the I_T_L or I_T_L_Q nexus.
		@param theL is the Logical Unit component of the I_T_L or I_T_L_Q nexus.
		@param theQ is the Queue Tag component of the I_T_L_Q nexus.  If this is
		an I_T_L nexus, then the kSCSIUntaggedTaskIdentifier constant should be
		used for theQ.
		@result returns a valid SCSIParallelTaskIdentifier or NULL if none 
		found.
	*/
	
	SCSIParallelTaskIdentifier	FindTaskForAddress ( 
							SCSIDeviceIdentifier 		theT,
							SCSILogicalUnitNumber		theL,
							SCSITaggedTaskIdentifier	theQ );
	
	
	/*!
		@function FindTaskForControllerIdentifier
		@abstract Find a task for a given Target and Controller Task Identifier
		@discussion Allows the controller child class to find an outstanding task
		for a specified target and controller task identifier
		@param theTarget is the Target that the task .
		@param theIdentifier is the controller task identifier set using the SCSI
		Parallel Task's SetControllerTaskIdentifier() method.
		@result returns a valid SCSIParallelTaskIdentifier or NULL if none 
		found.
	*/
	
	SCSIParallelTaskIdentifier	FindTaskForControllerIdentifier ( 
							SCSIDeviceIdentifier 		theTarget,
							UInt64						theIdentifier );
	
	
	/*!
		@function ExecuteParallelTask
		@abstract Submit a SCSIParallelTask for execution.
		@discussion	The ExecuteParallelTask call is made by the client to submit 
		a SCSIParallelTask for execution.
		@param parallelRequest is a reference to the SCSIParallelTaskIdentifier
		to be executed.
		@result is an appropriate SCSIServiceResponse which are defined in the
		file <IOKit/scsi/SCSITask.h>.
	*/
	
	SCSIServiceResponse ExecuteParallelTask ( 
							SCSIParallelTaskIdentifier	parallelRequest );
	
	// --- Public API methods provided by HBA child classes ----
	
	/*!
		@function ReportHBAHighestLogicalUnitNumber
		@abstract Gets the Highest Logical Unit Number.
		@discussion	This method is used to query the HBA child class to 
		determine what the highest Logical Unit Number that the controller can 
		address.
		@result returns a valid 64-bit logical unit number.
	*/
	
	virtual SCSILogicalUnitNumber	ReportHBAHighestLogicalUnitNumber ( void ) = 0;
	
	/*!
		@function DoesHBASupportSCSIParallelFeature
		@abstract Queries the HBA child class to determine if it supports a 
		specific SPI feature.
		@discussion	Queries the HBA child class to determine if it supports the 
		specified feature as defined by the SCSI Parallel Interconnect 
		specifications.
		@result Returns true if requested feature is supported.
	*/
	
	virtual bool	DoesHBASupportSCSIParallelFeature ( 
							SCSIParallelFeature 		theFeature ) = 0;
	
	/*!
		@function InitializeTargetForID
		@abstract Called to initialize a target device.
		@discussion	This method will be called to initialize a target device in 
		a single-threaded manner.  The HBA can use this method to probe the 
		target or do anything else necessary before the device object is 
		registered with IOKit for matching.
		@result Returns true if the target was successfully initialized.
	*/
	
	virtual bool	InitializeTargetForID (  
							SCSITargetIdentifier 		targetID ) = 0;
	
	// The SCSI Task Management Functions as defined in the SCSI Architecture
	// Model - 2 (SAM-2) specification.  These are used by the client to request
	// the specified function.  The controller can complete these immmediately 
	// by returning the appropriate SCSIServiceResponse, or these can be completed
	// asyncronously by the controller returning a SCSIServiceResponse of
	// kSCSIServiceResponse_Request_In_Process and then calling the appropriate
	// function complete member routine listed in the child class API section.
	
	virtual SCSIServiceResponse	AbortTaskRequest ( 	
							SCSITargetIdentifier 		theT,
							SCSILogicalUnitNumber		theL,
							SCSITaggedTaskIdentifier	theQ ) = 0;
	
	virtual	SCSIServiceResponse AbortTaskSetRequest (
							SCSITargetIdentifier 		theT,
							SCSILogicalUnitNumber		theL ) = 0;
	
	virtual	SCSIServiceResponse ClearACARequest (
							SCSITargetIdentifier 		theT,
							SCSILogicalUnitNumber		theL ) = 0;
	
	virtual	SCSIServiceResponse ClearTaskSetRequest (
							SCSITargetIdentifier 		theT,
							SCSILogicalUnitNumber		theL ) = 0;
	
	virtual	SCSIServiceResponse LogicalUnitResetRequest (
							SCSITargetIdentifier 		theT,
							SCSILogicalUnitNumber		theL ) = 0;
	
	virtual	SCSIServiceResponse TargetResetRequest (
							SCSITargetIdentifier 		theT ) = 0;
	
	

	/*!
		@function DoesHBAPerformAutoSense
		@abstract Queries the HBA child class to determine if it automatically
		performs AutoSense and provides AutoSense data for each I/O. If the HBA
		allocates space for AutoSense in its HBA specific data region on a per
		task basis, the HBA should respond true.
		@discussion	Queries the HBA child class to determine if it automatically
		performs AutoSense and provides AutoSense data for each I/O. If the HBA
		allocates space for AutoSense in its HBA specific data region on a per
		task basis, the HBA should respond true.
		@result Return true if HBA performs AutoSense into its own private data
		buffer.
	*/
	
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 1 );
	
	virtual bool	DoesHBAPerformAutoSense ( void );
	
	/*!
		@function ReportHBAConstraints
		@abstract Called to report the I/O constraints for this controller.
		A list of valid keys includes:
			kIOMaximumSegmentCountReadKey, (required)
			kIOMaximumSegmentCountWriteKey, (required)
			kIOMaximumSegmentByteCountReadKey, (required)
			kIOMaximumSegmentByteCountWriteKey, (required)
			kIOMinimumSegmentAlignmentByteCountKey, (required)
			kIOMaximumSegmentAddressableBitCountKey, (required)
			kIOMinimumHBADataAlignmentMaskKey (required)
			kIOHierarchicalLogicalUnitSupportKey (optional).
		NB: These keys and their values are described in this header and <IOKit/IOKitKeys.h>
		@param constraints. An OSDictionary object used to aggregate the key/value pairs.
		Subclasses must set the required keys if they override this method. If a subclass does
		not provide the required keys, the system will panic.
	*/
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 2 );
	
	virtual void	ReportHBAConstraints ( OSDictionary * constraints );
	
	/*!
		@function DoesHBASupportMultiPathing
		@abstract Queries the HBA child class to determine if it supports
		Multi-Pathing.
		@discussion	Queries the HBA child class to determine if it supports
		Multi-Pathing.
		@result Returns true if requested feature is supported.
	*/
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 3 );

	virtual bool	DoesHBASupportMultiPathing ( void );
							
	
	// Padding for the Client API
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 4 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 5 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 6 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 7 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 8 );
	
	
#if 0
#pragma mark -
#pragma mark Child Class API
#endif
	
	
protected:
	
	// ---- Target Creation and Destruction methods ---
	
	/*!
		@function CreateTargetForID
		@abstract Method to perform device creation.
		@discussion	For HBA child classes that report true to the 
		DoesHBAPerformDeviceManagement() method, the child class will be 
		responsible for all device management by using these methods;
		otherwise, the superclass will be responsible for all device management.
		This method must be used to perform SCSI Parallel Device creation and 
		cannot be overridden.
		@param  targetID SCSIDeviceIdentifier of desired targetID.
		@result returns true if successful.
	*/
	
	bool	CreateTargetForID ( SCSIDeviceIdentifier targetID );
	
	 /*!
		@function CreateTargetForID
		@abstract Method to perform device creation.
		@discussion	For HBA child classes that report true to the
		DoesHBAPerformDeviceManagement() method, the child class will be
		responsible for all device management by using these methods;
		otherwise, the superclass will be responsible for all device management.
		This method must be used to perform SCSI Parallel Device creation and
		cannot be overridden.
		@param  targetID SCSIDeviceIdentifier of desired targetID.
		@param	properties A dictionary of properties to associate with the device
				upon creation. The list of valid property keys is as follows:
				kIOPropertySASAddressKey,
				kIOPropertyFibreChannelNodeWorldWideNameKey,
				kIOPropertyFibreChannelPortWorldWideNameKey,
				kIOPropertyFibreChannelAddressIdentifierKey,
				kIOPropertyFibreChannelALPAKey, and
				kIOPropertyRetryCountKey
				These keys are defined in
				<IOKit/storage/IOStorageProtocolCharacteristics.h> and the values
				associated with these keys must be of the proper type/size,
				or the target creation will not succeed.
		@result returns true if successful.
	*/
	
	bool	CreateTargetForID ( SCSIDeviceIdentifier 	targetID,
								OSDictionary * 			properties );
	
	 /*!
		@function DestroyTargetForID
		@abstract Method to perform device destruction.
		@discussion	For HBA child classes that report true to the 
		DoesHBAPerformDeviceManagement() method, the child class will be 
		responsible for all device management by using these methods; otherwise, 
		the superclass will be responsible for all device management.
		This method must be used to perform SCSI Parallel Device destruction and
		cannot be overridden.
		@param  targetID SCSIDeviceIdentifier of desired targetID.
	*/
	
	void	DestroyTargetForID ( SCSIDeviceIdentifier targetID );
	
	/*!
		@function GetTargetForID
		@abstract Accessor for getting pointer to IOSCSIParallelInterfaceDevice.
		@param targetID SCSIDeviceIdentifier of desired targetID.
		@result returns pointer to IOSCSIParallelInterfaceDevice or NULL if not 
		found.
	*/
	
	IOSCSIParallelInterfaceDevice *	GetTargetForID ( 
							SCSIDeviceIdentifier 		targetID ); 
	
	/*!
		@function SetTargetProperty
		@abstract Accessor for setting a property for a specific target.
		@param device A pointer to a valid IOSCSIParallelInterfaceDevice.
		@param key A pointer to a valid OSString object which represents the key.
		A list of valid keys includes:
			kIOPropertySASAddressKey,
			kIOPropertyFibreChannelNodeWorldWideNameKey,
			kIOPropertyFibreChannelPortWorldWideNameKey,
			kIOPropertyFibreChannelAddressIdentifierKey, and
			kIOPropertyFibreChannelALPAKey.
		NB: These keys and their values are described in <IOKit/storage/IOStorageProtocolCharacteristics.h>
		@param value Pointer to an OSObject (one of type OSData, OSString, etc.)
		which represents the value for the property. The value must be of the proper type
		and size for the specified key.
		@result returns true if identifier was properly set, otherwise false. 
	*/
	
	bool	SetTargetProperty ( SCSIDeviceIdentifier 		targetID,
								const char *		 		key,
								OSObject *					value );

	/*!
		@function RemoveTargetProperty
		@abstract Accessor for removing a property from a specific target.
		@param device A pointer to a valid IOSCSIParallelInterfaceDevice.
		@param key A pointer to a valid OSString object which represents the key.
	*/
	
	void	RemoveTargetProperty ( SCSIDeviceIdentifier 		targetID,
								   const char *		 			key );
	
	// ---- Methods for HBA specifics. ----
	
	/*!
		@function SetHBAProperty
		@abstract Accessor for setting a property for this object.
		@param key A pointer to a valid OSString object which represents the key.
		A list of valid keys includes:
			kIOPropertyVendorNameKey,
			kIOPropertyProductNameKey,
			kIOPropertyProductRevisionLevelKey,
			kIOPropertyPortDescriptionKey,
			kIOPropertyPortSpeedKey,
			kIOPropertyPortTopologyKey,
			kIOPropertySCSIParallelSignalingTypeKey,
			kIOPropertyFibreChannelCableDescriptionKey,
			kIOPropertyFibreChannelNodeWorldWideNameKey,
			kIOPropertyFibreChannelPortWorldWideNameKey,
			kIOPropertyFibreChannelAddressIdentifierKey, 
			kIOPropertyFibreChannelALPAKey, and
			kIOPropertySASAddressKey.
		NB: These keys and their values are described in <IOKit/storage/IOStorageDeviceCharacteristics.h>
		and <IOKit/storage/IOStorageProtocolCharacteristics.h>
		@param value Pointer to an OSObject (one of type OSData, OSString, etc.)
		which represents the value for the property. The value must be of the proper type,
		and/or size for the specified key.
		@result returns true if identifier was properly set, otherwise false. 
	*/
	
	bool	SetHBAProperty ( const char *	key,
							 OSObject *	 	value );

	/*!
		@function RemoveHBAProperty
		@abstract Accessor for removing a property for this object.
		@param key A pointer to a valid OSString object which represents the key.
		See the SetHBAProperty() method for a list of valid keys.
	*/
	
	void	RemoveHBAProperty ( const char * key );
	
	// These methods will not be called before the InitializeController() call,
	// and will not be called after the TerminateController() call.  But in the
	// interval between those calls, they shall report the correct requested
	// information. They are implemented as seperate pure virtual methods
	// instead of a selector driven method because the HBA child class is
	// required to report this information.
	
	/*!
		@function ReportInitiatorIdentifier
		@abstract Get the SCSI Device Identifier for the HBA.
		@discussion This method will be called to determine the SCSI Device 
		Identifier that the Initiator has assigned for this HBA.
		@result returns SCSIInitiatorIdentifier.
	*/
	
	virtual SCSIInitiatorIdentifier	ReportInitiatorIdentifier ( void ) = 0;
	
	/*!
		@function ReportHighestSupportedDeviceID
		@abstract Get the highest supported SCSI Device Identifier.
		@discussion This method will be called to determine the value of the 
		highest SCSI Device Identifier supported by the HBA. This value will be 
		used to determine the last ID to process.
		@result returns highest SCSIDeviceIdentifier
	*/
	
	virtual SCSIDeviceIdentifier	ReportHighestSupportedDeviceID ( void ) = 0;
	
	/*!
		@function ReportMaximumTaskCount
		@abstract Report Maximum Task Count
		@discussion This method will be called to retrieve the maximum number of
		outstanding tasks the HBA can process. This number must be greater than
		zero or the controller driver will fail to match and load.
		@result returns maximum (non-zero) task count.
	*/
	
	virtual UInt32		ReportMaximumTaskCount ( void ) = 0;
	
  	/*!
		@function ReportHBASpecificTaskDataSize
		@abstract Determine memory needed for HBA Task specific use.
		@discussion This method is used to retrieve the amount of memory that 
		will be allocated in the SCSI Parallel Task for HBA specific use.
		@result returns memory required in bytes
	*/
	
	virtual UInt32		ReportHBASpecificTaskDataSize ( void ) = 0;
	
  	/*!
		@function ReportHBASpecificDeviceDataSize
		@abstract  Determine memory needed for HBA Device specific use.
		@discussion This method is used to retrieve the amount of memory that 
		will be allocated in the SCSI Parallel Device for HBA specific use.
		@result  returns memory required in bytes
	*/
	
	virtual UInt32		ReportHBASpecificDeviceDataSize ( void ) = 0;
	
  	/*!
		@function DoesHBAPerformDeviceManagement
		@abstract  Determine if HBA will manage devices.
		@discussion This method is used to determine if the HBA will manage 
		target device creation and destruction.  
		@result return true means objects for target devices will only be 	
		created when the child class calls the CreateTargetForID method.
	*/
	
	virtual bool		DoesHBAPerformDeviceManagement ( void ) = 0;
	
	// ---- Initialize and Terminate methods for the subclass to implement -----
	// The subclass shall not override the IOKit init and terminate methods,
	// but shall instead rely on these methods for initialization and
	// termination.
	
	// This is done to allow for this superclass to manage all IOKit specifics 
	// and to require only a Family specific API to be implemented by the
	// subclass drivers.
	
  	/*!
		@function InitializeController
		@abstract  Called to initialize the controller
		@discussion It is guaranteed that the InitializeController() will only be 
		called once per instantiation.  The InitializeController() methods allows 
		the subclass driver to do all the necessary initialization required by 
		the hardware before it is able to accept requests to execute. All 
		necessary allocation of resources should be made during this method 
		call. This is the first method that will be called in the subclass.
		@result return true means that initialization was successful.
	*/
	
	virtual bool	InitializeController ( void ) = 0;
	
  	/*!
		@function TerminateController
		@abstract  Called to terminate the controller
		@discussion It is guaranteed that the TerminateController() will only be 
		called once and only after the InitializeController() method and only if 
		true was returned in response to the InitializeController() method.
		The TerminateController() method allows the subclass to release all 
		resources that were acquired for operation of the hardware and shutdown 
		all hardware services.
		This is the last method of the subclass that will be called before the 		
		class is destroyed.
	*/
	
	virtual void	TerminateController ( void ) = 0;
	
	// ---- Start and Stop methods for the subclass ----
	
	/*!
		@function StartController
		@abstract Called to start the controller
		@discussion The StartController will always be called before any 
		requests are sent to the driver for execution. This method is called 
		after an initialize to start the services provided by the specific HBA 
		driver or called after a StopController call to restart those services. 
		After this call completes, all services provided by the HBA driver are 
		available to the client.
		@result return true means that start was successful.
	*/
	
	virtual bool	StartController ( void ) = 0;
	
	/*!
		@function StopController
		@abstract Called to stop the controller
		@discussion The StopController method will be called any time that the 
		system wants the card to stop accepting requests. ( See StartController 
		discussion ). The subclass should disable the hardware interrupt for
		the particular controller (if possible) in this method.
	*/
	
	virtual void	StopController ( void ) = 0;
	
	// ---- Suspend and Resume Methods for the subclass ----
	
	/*!
		@function SuspendServices
		@abstract Called to suspend controller services
		@discussion Method will be called when the system wants to suspend the
		services that are provided by the HBA driver. This call is not a reset
		and the driver shall retain all state data between this so that if a
		ResumeServices call is received, the driver can continue providing
		services without a visible difference to the client. The driver may 
		receive multiple SuspendServices calls without receiving a 
		ResumeServices call and should ignore any after the first until a 
		ResumeServices call is received.
	*/
	
	virtual void	SuspendServices ( void );
	
	/*!
		@function ResumeServices
		@abstract Called to resume controller services
		@discussion Method that will be called to resume services
		provided by the driver. ( See SuspendServices discussion )
	*/
	
	virtual void	ResumeServices ( void );
	
	/*!
		@function HandleInterruptRequest
		@abstract Handle Interrupt Request
		@discussion The HandleInterruptRequest is used to notify an HBA 
		specific subclass that an interrupt request needs to be serviced. It is 
		called on the workloop (it holds the gate) at secondary interrupt level.
	*/
	
	virtual void	HandleInterruptRequest ( void ) = 0;
	
	/*!
		@function EnableInterrupt
		@abstract Enable Interrupt
		@discussion Method that the HBA child class can call to enable 
		the associated IOInterruptEventSource.
	*/
	
	void	EnableInterrupt ( void );
	
	/*!
		@function DisableInterrupt
		@abstract Disable Interrupt
		@discussion Method that the HBA child class can call to disable 
		the associated IOInterruptEventSource.
	*/
	
	void	DisableInterrupt ( void );
	
	/*!
		@function SignalInterrupt
		@abstract Signals that an interrupt has occurred.
		@discussion Subclasses of IOSCSIParallelInterfaceController
		should call this method in order to get the secondary interrupt
		thread scheduled if and only if they will be returning false from
		their overriden FilterInterruptRequest() method. See the
		discussion for the FilterInterruptRequest() method for more
		details.
		
		NOTE: This method should only be called from within the
		FilterInterruptRequest() method and at no other time.
		
		Available in 10.3.3 or later.
		
	*/
	
	void	SignalInterrupt ( void );
	
	/*!
		@function ProcessParallelTask
		@abstract Called by client to process a parallel task.
		@discussion This method is called to process a parallel task (i.e. put
		the command on the bus). The HBA specific sublcass must implement this 
		method.
		@param parallelRequest A valid SCSIParallelTaskIdentifier.
		@result serviceResponse (see <IOKit/scsi/SCSITask.h>)
	*/
	
	virtual SCSIServiceResponse ProcessParallelTask (
							SCSIParallelTaskIdentifier parallelRequest ) = 0;
	
	/*!
		@function CompleteParallelTask
		@abstract Parallel Task Completion
		@discussion The HBA specific sublcass inherits the CompleteParallelTask() 
		method which shall be called when the HBA has completed the processing 
		of a parallel task.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param completionStatus The status of the SCSI bus.
		@param serviceResponse (see <IOKit/scsi/SCSITask.h>)
	*/
	
	void	CompleteParallelTask (
						SCSIParallelTaskIdentifier	parallelRequest,
						SCSITaskStatus 				completionStatus,
						SCSIServiceResponse 		serviceResponse );
	
	
	// Completion routines for the SCSI Task Management functions as described
	// in the SCSI ArchitectureModel - 2 (SAM-2) specification.  Each of these
	// correspond to a client request for the specific Task Management functions.
	// If the Controller Child Class completed the request by returning a 
	// SCSIServiceResponse of anything other than kSCSIServiceResponse_Request_In_Process,
	// then the controller class does not need to call the completion member routine.
	// If the controller did not complete the request immediately, then it will
	// need to call the appropriate completion member routine listed here.
	void	CompleteAbortTask ( 	
						SCSITargetIdentifier 		theT,
						SCSILogicalUnitNumber		theL,
						SCSITaggedTaskIdentifier	theQ,
						SCSIServiceResponse 		serviceResponse );
	
	void 	CompleteAbortTaskSet (
						SCSITargetIdentifier 		theT,
						SCSILogicalUnitNumber		theL,
						SCSIServiceResponse 		serviceResponse );
	
	void 	CompleteClearACA (
						SCSITargetIdentifier 		theT,
						SCSILogicalUnitNumber		theL,
						SCSIServiceResponse 		serviceResponse );
	
	void 	CompleteClearTaskSet (
						SCSITargetIdentifier 		theT,
						SCSILogicalUnitNumber		theL,
						SCSIServiceResponse 		serviceResponse );
	
	void 	CompleteLogicalUnitReset (
						SCSITargetIdentifier 		theT,
						SCSILogicalUnitNumber		theL,
						SCSIServiceResponse 		serviceResponse );
	
	void 	CompleteTargetReset (
						SCSITargetIdentifier 		theT,
						SCSIServiceResponse 		serviceResponse );
	
	/*!
		@function NotifyClientsOfBusReset
		@abstract Method called to notify clients that a bus reset has occurred.
		@discussion This method is used by the HBA child class to inform the 
		parent class and any clients that a bus reset has occurred.
	*/
	
	void	NotifyClientsOfBusReset ( void );
	
	/*!
		@function NotifyClientsOfPortStatusChange
		@abstract Method called to notify clients of port status change events.
		@discussion This method is used by the HBA child class to inform the 
		parent class and any clients that a port has changed status.
	*/
	
	void	NotifyClientsOfPortStatusChange ( SCSIPortStatus newStatus );
	
	/*!
		@function GetSCSIDomainIdentifier
		@abstract Accessor method to get the SCSI Domain Identifier.
		@discussion Accessor method to get the SCSI Domain Identifier.
		@result returns SCSI Domain Identifier.
	*/
	
	SInt32	GetSCSIDomainIdentifier ( void );
	
	/*!
		@function GetProvider
		@abstract Accessor method to get the IOService which is the controller's
		provider.
		@discussion Accessor method to get the IOService which is the 
		controller's provider.
		@result returns pointer to IOService.
	*/
	
	IOService *		GetProvider ( void );
	
	/*!
		@function GetWorkLoop
		@abstract Accessor method to get the IOWorkLoop associated with this 
		HBA.
		@discussion Accessor method to get the IOWorkLoop associated with this 
		HBA.
		@result returns pointer to IOWorkLoop.
	*/
	
	IOWorkLoop *	GetWorkLoop ( void ) const;
	
	/*!
		@function GetCommandGate
		@abstract Accessor to get an IOCommandGate associated with the workloop.
		@discussion Accessor to get an IOCommandGate associated with the 
		workloop.
		@result returns pointer to IOCommandGate.
	*/
	
	IOCommandGate *		GetCommandGate ( void );
	
	// ---- SCSI Parallel Task Object Accessors ----
	
	/*!
		@function GetSCSITaskIdentifier
		@abstract Method to retrieve a SCSITaskIdentifier from a valid 
		SCSIParallelTaskIdentifier.
		@discussion Method to retrieve a SCSITaskIdentifier from a valid 
		SCSIParallelTaskIdentifier.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns SCSITaskIdentifier that represents the original request 
		from the SCSI Application Layer client.
	*/
	
	SCSITaskIdentifier	GetSCSITaskIdentifier ( 
							SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetTargetIdentifier
		@abstract Method to get the SCSITargetIdentifier associated with a 
		request.
		@discussion	Method to get the SCSITargetIdentifier associated with a 
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns SCSITargetIdentifier 
	*/
	
	SCSITargetIdentifier	GetTargetIdentifier ( 
							SCSIParallelTaskIdentifier 	parallelTask );
	
	// ---- Methods for Accessing data in the client's SCSI Task Object ----	
	// Method to retrieve the LUN that identifies the Logical Unit whose Task
	// Set to which this task is to be added.
	
	/*!
		@function GetLogicalUnitNumber
		@abstract Method to get the logical unit number associated with a 
		request.
		@discussion Method to get the logical unit number associated with a 
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns a valid 64-bit logical unit number.
	*/
	
	SCSILogicalUnitNumber	GetLogicalUnitNumber ( 
							SCSIParallelTaskIdentifier 	parallelTask ); // DEPRECATED, use GetLogicalUnitBytes instead.
	
	/*!
		@function GetLogicalUnitBytes
		@abstract Method to get the logical unit bytes associated with a
		request.
		@discussion Method to get the logical unit bytes associated with a
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns a valid 8-byte logical unit address.
	*/

    void    GetLogicalUnitBytes (
                            SCSIParallelTaskIdentifier  parallelTask,
                            SCSILogicalUnitBytes *      logicalUnitBytes );

	/*!
		@function GetTaggedTaskIdentifier
		@abstract Method to retrieve the SCSI Tagged Task Identifier of the 
		task.  If the returned value is equal to kSCSIUntaggedTaskIdentifier,
		then this task is untagged.  
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result an SCSITaskAttribute value.
	*/
	
	SCSITaggedTaskIdentifier GetTaggedTaskIdentifier (
							SCSIParallelTaskIdentifier	parallelTask );
	
	/*!
		@function GetTaskAttribute
		@abstract Method to retrieve the SCSI Task Attribute of the task 
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result an SCSITaskAttribute value.
	*/
	
	SCSITaskAttribute		GetTaskAttribute (
							SCSIParallelTaskIdentifier	parallelTask );
	
	/*!
		@function GetCommandDescriptorBlockSize
		@abstract Method to retrieve the size of the SCSI Command Descriptor 
		Block (CDB).
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns the size of the SCSI Command Descriptor Block in bytes.
	*/
	
	UInt8	GetCommandDescriptorBlockSize ( 
							SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetCommandDescriptorBlock
		@abstract Method to retrieve the SCSI Command Descriptor Block (CDB).
		@discussion This will always return a 16 Byte CDB. If the Protocol Layer 
		driver does not support 16 Byte CDBs, it will have to create a local 
		SCSICommandDescriptorBlock variable to get the CDB data and then 
		transfer the needed bytes from there.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param cdbData is a SCSICommandDescriptorBlock pointer to 16 byte CDB
		@result returns true if data was copied to cdbData pointer
	*/
	
	bool	GetCommandDescriptorBlock (
							SCSIParallelTaskIdentifier 		parallelTask,
							SCSICommandDescriptorBlock * 	cdbData );
	
	/*!
		@function GetDataTransferDirection
		@abstract Retrieves the data transfer direction for any data associated
		with the request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result One of the valid data transfer directions described in 
		<IOKit/scsi/SCSITask.h>
	*/
	
	UInt8	GetDataTransferDirection ( SCSIParallelTaskIdentifier parallelTask );
	
	/*!
		@function GetRequestedDataTransferCount
		@abstract Retrieves the requested data transfer count for any data 
		associated with the request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result The requested data transfer count in bytes.
	*/
	
	UInt64	GetRequestedDataTransferCount ( 
							SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetRealizedDataTransferCount
		@abstract Retrieves the realized data transfer count for any data 
		associated with the request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result The realized data transfer count in bytes.
	*/
	
	UInt64	GetRealizedDataTransferCount (
							SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function SetRealizedDataTransferCount
		@abstract Sets the realized data transfer count in bytes.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param realizedTransferCountInBytes is the number of bytes actually 
		transferred.
		@result true means the data transfer count was successfully set.
	*/
	
	bool	SetRealizedDataTransferCount ( 
							SCSIParallelTaskIdentifier 	parallelTask,
							UInt64 		realizedTransferCountInBytes );
	
	/*!
		@function IncrementRealizedDataTransferCount
		@abstract Increments the realized data transfer count. This method is
		helpful for when the HBA has to do multiple passes of DMA because there 
		are more scatter-gather elements than it can process in one pass.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param realizedTransferCountInBytes is the number of bytes to add to the
		realized data count for the task.
	*/
	
	void	IncrementRealizedDataTransferCount (
							SCSIParallelTaskIdentifier 	parallelTask,
							UInt64 		realizedTransferCountInBytes );
	
	/*!
		@function GetDataBuffer
		@abstract Method to retrieve client buffer from the request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns pointer to an IOMemoryDescriptor which represents the 
		buffer.
	*/
	
	IOMemoryDescriptor * GetDataBuffer ( 
							SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetDataBufferOffset
		@abstract Method to retrieve offset into client buffer at which to start
		processing.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns offset in bytes
	*/
	
	UInt64	GetDataBufferOffset ( SCSIParallelTaskIdentifier parallelTask );

	/*!
		@function GetDMACommand
		@abstract Method to retrieve a pointer to an IODMACommand from the request.
		@discussion For devices utilizing DMA, the IODMACommand object should be 
		obtained via GetDMACommand(). The subclass is responsible for calling prepare()
		on the IODMACommand object using the proper offset obtained via GetDataBufferOffset()
		and correct size obtained via GetRequestedDataTransferCount(). The subclass
		is further responsible for calling complete() on the IODMACommand object once
		all DMA operations have finished.
		NB: Subclasses should not call IODMACommand::setMemoryDescriptor().
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns pointer to an IODMACommand which is used in conjunction
		with the task.
	*/
	
	IODMACommand * GetDMACommand ( 
							SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetTimeoutDuration
		@abstract Method to retrieve the timeout duration in milliseconds for a 
		request.
		@discussion Method to retrieve the timeout duration in milliseconds for
		a request. A value of zero represents an infinite timeout, or on 
		hardware where infinite timeouts are not possible, substitute the 
		longest timeout possible.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns timeout duration in milliseconds
	*/
	
	UInt32	GetTimeoutDuration ( SCSIParallelTaskIdentifier parallelTask );

	/*!
		@function SetAutoSenseData
		@abstract Method to set the auto sense data buffer associated with a 
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param newSensedata pointer to auto sense data buffer
		@result returns true if data in newSenseData was succesfully into the 
		task object
	*/
	
	bool	SetAutoSenseData ( 
							SCSIParallelTaskIdentifier 	parallelTask,
							SCSI_Sense_Data * 			newSenseData,
							UInt8						senseDataSize );
	
	/*!
		@function GetAutoSenseData
		@abstract Method to retrieve auto sense data buffer associated with a 
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param receivingBuffer pointer to auto sense data buffer
		@result returns true if successfully copied data into receivingBuffer
	*/
	
 	bool	GetAutoSenseData ( 
 							SCSIParallelTaskIdentifier 	parallelTask,
 							SCSI_Sense_Data * 			receivingBuffer,
 							UInt8						senseDataSize );
 	
	/*!
		@function GetAutoSenseDataSize
		@abstract Method to retrieve auto sense data buffer size associated with a 
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns Size of auto sense data buffer.
	*/
	
 	UInt8	GetAutoSenseDataSize ( 
 							SCSIParallelTaskIdentifier 	parallelTask );
 	
	
	/*!
		@function GetSCSIParallelFeatureNegotiation
		@abstract Method to retrieve the requested value for negotiation of the.
		@discussion Query as to whether the SCSI Parallel Device object has 
		negotiated wide data transfers.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result A valid SCSIParallelFeatureControl.
	*/
	
	SCSIParallelFeatureRequest		GetSCSIParallelFeatureNegotiation ( 
							SCSIParallelTaskIdentifier 	parallelTask,
							SCSIParallelFeature 		requestedFeature );
	
	/*!
		@function GetSCSIParallelFeatureNegotiationCount
		@abstract Method to retrieve the number of requested negotiations.
		@discussion Query as to the number of SCSI Parallel Features that are
		requested to either be negotitated or cleared.  These are all features
		that are set to either kSCSIParallelFeature_AttemptNegotiation or 
		kSCSIParallelFeature_ClearNegotiation.  If the return value is zero,
		then all features are set to kSCSIParallelFeature_NoNegotiation
		and all feature negotiations are to remain as they currently exist.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result an unsigned integer up to 64 bits in size.
	*/
	
	UInt64		GetSCSIParallelFeatureNegotiationCount ( 
							SCSIParallelTaskIdentifier 	parallelTask);
	
	/*!
		@function SetSCSIParallelFeatureNegotiationResult
		@abstract Method to set the wide data transfer negotiation result.
		@discussion Method to set the wide data transfer negotiation result.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param requestedFeature The SCSIParallelFeature that the has been set to 	
		newResult.
		@param newResult A valid SCSIParallelFeatureResult value.
	*/
	
	void		SetSCSIParallelFeatureNegotiationResult ( 
							SCSIParallelTaskIdentifier 	parallelTask,
							SCSIParallelFeature 		requestedFeature, 
							SCSIParallelFeatureResult 	newResult );
	
	/*!
		@function GetSCSIParallelFeatureNegotiationResult
		@abstract Method to retrieve the result of any wide transfer 
		negotiations.
		@discussion Query as to whether the SCSI Parallel Controller object has 
		negotiated wide data transfers.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result A valid SCSIParallelFeatureResult.
	*/
	
	SCSIParallelFeatureResult		GetSCSIParallelFeatureNegotiationResult ( 
							SCSIParallelTaskIdentifier 	parallelTask,
							SCSIParallelFeature 		requestedFeature );
	
	/*!
		@function GetSCSIParallelFeatureNegotiationResultCount
		@abstract Method to retrieve the number of changed negotiations.
		@discussion Query as to the number of SCSI Parallel Features that have
		been changed to either negotitated or cleared.  These are all features
		that are set to either kSCSIParallelFeature_NegotitiationCleared or 
		kSCSIParallelFeature_NegotitiationSuccess.  If the return value is zero,
		then all features are set to kSCSIParallelFeature_NegotitiationUnchanged.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result an unsigned integer up to 64 bits in size.
	*/
	
	UInt64		GetSCSIParallelFeatureNegotiationResultCount ( 
							SCSIParallelTaskIdentifier 	parallelTask);
	
	// Controller Task Identifier related member routines
	
	/*!
		@function SetControllerTaskIdentifier
		@abstract Method to set the Controller Task Identifier.
		@discussion This method allows the Controller Child Class
		driver to set a unique identifier to associate with the specified
		SCSI Parallel Task.  This identifier is designed to be used by
		controllers that do not have access to the LUN and Tag information
		when notified by the HBA that a request has completed.
		If the kSCSIParallelTaskControllerIDQueueHead is used, this
		member routine will return the first Task on the queue.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param newIdentifier unsigned 64 bit integer token.
		@result none
	*/
	
	void	SetControllerTaskIdentifier (
							SCSIParallelTaskIdentifier 	parallelTask,
							UInt64 						newIdentifier );
	
	UInt64	GetControllerTaskIdentifier (
							SCSIParallelTaskIdentifier 	parallelTask);
	
	
	// The HBA Data related fields
	
	/*!
		@function GetHBADataSize
		@abstract Method to retrieve the HBA Data Size in bytes.
		@discussion Method to retrieve the HBA Data Size in bytes.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns HBA Data size in bytes.
	*/
	
	UInt32	GetHBADataSize ( SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetHBADataPointer
		@abstract Method to retrieve the HBA Data pointer.
		@discussion Method to retrieve the HBA Data pointer.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns pointer to buffer for HBA specific data, NULL if 
		none found or GetHBADataSize() returns zero.
	*/
	
	void *	GetHBADataPointer ( SCSIParallelTaskIdentifier 	parallelTask );
	
	/*!
		@function GetHBADataDescriptor
		@abstract Method to retrieve the IOMemoryDescriptor associated with
		the HBA Data.
		@discussion Method to retrieve the IOMemoryDescriptor associated with
		the HBA Data.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@result returns pointer to an IOMemoryDescriptor that wraps the HBA 
		specific data buffer, NULL if none found or GetHBADataSize() returns zero.
	*/
	
	IOMemoryDescriptor *	GetHBADataDescriptor (
							SCSIParallelTaskIdentifier 	parallelTask );
	
	// ---- SCSI Parallel Device Object Accessors ----
	
	// The HBA Data related fields
	
	/*!
		@function GetHBATargetDataSize
		@abstract Method to retrieve the HBA Data Size in bytes.
		@discussion Method to retrieve the HBA Data Size in bytes.
		@param targetDevice A valid SCSITargetIdentifier.
		@result returns HBA Data size in bytes.
	*/
	
	UInt32	GetHBATargetDataSize ( SCSITargetIdentifier 	targetID );
	
	/*!
		@function GetHBATargetDataPointer
		@abstract Method to retrieve the HBA Data pointer.
		@discussion Method to retrieve the HBA Data pointer.
		@param targetDevice A valid SCSITargetIdentifier.
		@result returns pointer to buffer for HBA specific data, NULL if 
		none found or GetHBADataSize is zero.
	*/
	
	void *	GetHBATargetDataPointer ( SCSITargetIdentifier 	targetID );
	
	
#if 0
#pragma mark -
#pragma mark Additional Child Class APIs
#endif
	
	
	// ---- Timeout Related Methods ----
	
	/*!
		@function SetTimeoutForTask
		@abstract Method to set the timeout duration in milliseconds for a 
		request.
		@discussion Method to set the timeout duration in milliseconds for a 
		request.
		@param parallelTask A valid SCSIParallelTaskIdentifier.
		@param timeoutOverride A timeout value in milliseconds in case the
		HBA driver wishes to override the default value provided in the
		parallelTask.
	*/
	
	void	SetTimeoutForTask ( SCSIParallelTaskIdentifier 	parallelTask,
								UInt32						timeoutOverride = 0 );
	
	/*!
		@function HandleTimeout
		@abstract Method to handle command timeouts.
		@discussion Method to handle command timeouts. This should
		be overridden by the child class in order to clean up HBA
		specific structures after a timeout has occurred. This method
		is called on the workloop (it holds the gate).
		@param parallelRequest A valid SCSIParallelTaskIdentifier.
	*/
	
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 9 );
	
	virtual void		HandleTimeout (
							SCSIParallelTaskIdentifier parallelRequest );
	
	
	// ---- Filter Interrupt ----
	
	/*!
		@function FilterInterruptRequest
		@abstract Filter method called at primary interrupt time.
		@discussion Filter method called at primary interrupt time.
		This should only be overridden by the child class in order
		to determine if an interrupt occurred for this controller instance.
		Since all work occurs at primary interrupt time, this routine
		should be quick and efficient and defer as much processing as
		possible to the HandleInterruptRequest() method.
		
		NOTE: Unlike the HandleInterruptRequest() and HandleTimeout()
		methods, FilterInterruptRequest() is NOT called with the
		workloop lock held.
		
		If the value returned by FilterInterruptRequest() is true, the
		secondary interrupt thread will be scheduled and the hardware
		interrupt line will be disabled. If the controller instance shares
		that interrupt line with other devices, it can cause large
		interrupt latencies. If the controller instance can disable the
		interrupt in the chip itself, the following can be done to reduce
		interrupt latencies:
		
		- Interrupt occurs
		- FilterInterruptRequest() method is called.
			- If the interrupt is not for this controller, return false
			  immediately.
			- If the interrupt is for this controller, and the controller
			  can disable interrupts for this chip, the controller should
			  disable the interrupts for this chip, call SignalInterrupt(),
			  and return false. This causes the secondary interrupt thread
			  to get scheduled, yet does not disable the interrupt line for
			  all devices tied to that interrupt. This effectively allows
			  other devices to process their interrrupts, thus reducing
			  interrupt latency for those devices.
		- HandleInterruptRequest() method is called.
			- Controller processes interrupt and completes I/O requests.
			- Controller re-enables interrupts for the device.
		
		NOTE: If you use this approach, the interrupting condition MUST be
		cleared from the hardware, otherwise an infinite process interrupt
		loop will occur.
		
		If the controller cannot disable interrupts on the chip, it should
		simply return true if an interrupt has occurred for its device.
		
		@result True if the hardware interrupt line should be disabled,
		otherwise false.
	*/
	
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 10 );
	
	virtual bool		FilterInterruptRequest ( void );
	
	/*!
		@function InitializeDMASpecification
		@abstract Called to initialize an IODMACommand with a DMA specification.
		@param command A pointer to a valid IODMACommand object. Subclasses
		should override this method and call IODMACommand::initWithSpecification()
		supplying the proper arguments to that method based on the DMA strategy.
		@result boolean value indicating success or failure.
	*/
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 11 );
	
	virtual bool	InitializeDMASpecification ( IODMACommand * command );
	
	/*!
		@function CreateDeviceInterrupt
		@abstract Called to create an IOInterruptEventSource for the device. Subclasses
		may wish to use a different interrupt index than 0 (e.g. for using PCI Message
		Signaled Interrupts) or might not need an interrupt at all (virtual HBA).
		@param action A pointer to the action routine that should be passed to either
		IOInterruptEventSource::interruptEventSource() or
		IOFilterInterruptEventSource::filterInterruptEventSource as the method to call
		when an interrupt occurs for the device (sometimes called the "deferred procedure call"
		or the "secondary context method". By passing this routine along, it will
		properly wire up the HandleInterruptRequest() method you should override to handle
		interrupts.
		@param filter A pointer to the filter routine that should be passed to
		IOFilterInterruptEventSource::filterInterruptEventSource as the method to call
		at primary interrupt time when an interrupt occurs for the device.
		By passing this routine along, it will properly wire up the
		FilterInterruptRequest() method you may override to handle primary interrupts.
		@result IOInterruptEventSource. May return NULL if and only if there is no
		hardware interrupt associated with this device.
	*/
	OSMetaClassDeclareReservedUsed ( IOSCSIParallelInterfaceController, 12 );
	
	virtual IOInterruptEventSource *	CreateDeviceInterrupt (
											IOInterruptEventSource::Action			action,
											IOFilterInterruptEventSource::Filter	filter,
											IOService *								provider );
	
	// Padding for the Child Class API
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 13 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 14 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 15 );
	OSMetaClassDeclareReservedUnused ( IOSCSIParallelInterfaceController, 16 );
	
	
#if 0
#pragma mark -
#pragma mark Internal Use Only
#endif
	
private:
	
	// binary compatibility instance variable expansion
	struct ExpansionData { };
	ExpansionData * fIOSCSIParallelInterfaceControllerExpansionData;
	
	IOService *					fProvider;
	OSSet *						fClients;
	
	static SInt32				fSCSIParallelDomainCount;
	SInt32						fSCSIDomainIdentifier;
	
	// The HBA attributes
	SCSIInitiatorIdentifier		fInitiatorIdentifier;
	
	// The maximum SCSI Device Identifier support by the HBA
	// This is retreived from the child class via the 
	SCSIDeviceIdentifier		fHighestSupportedDeviceID;
	
	// The total number of tasks that the HBA can proccess at a time.
	// This is retrieved from the child class via ReportMaximumTaskCount
	UInt32						fSupportedTaskCount;
	
	// The Number of requests that are currently outstanding for the current
	// instantiation.
	UInt16						fOutstandingRequests;
	
	// The member variable to indicate if the current instantiation has been
	// succesfully intialized.
	bool						fHBAHasBeenInitialized;
	
	// The member variable to indicate if the current instantiation is running.
	// A true means that the last or only Start call made was successful.  A
	// false value means that either a successful Start has not been made or a
	// Stop call has been made.
	bool						fHBACanAcceptClientRequests;
	
	// The pool for the available SCSI Parallel Task objects
	IOCommandPool *				fParallelTaskPool;
	
	// WorkLoop variables
	IOWorkLoop *				fWorkLoop;
	IOTimerEventSource *		fTimerEvent;
	IOInterruptEventSource *	fDispatchEvent;
	
	IOCommandGate *				fControllerGate;
	
	bool						AllocateSCSIParallelTasks ( void );
	void						DeallocateSCSIParallelTasks ( void );
	
	IOWorkLoop *				getWorkLoop ( void ) const;
	bool 						CreateWorkLoop ( IOService * provider );
	void 						ReleaseWorkLoop ( void );
	
	// SCSI Parallel Device List
	// The SCSI Parallel Device List will consist of 16 elements to represent 
	// identifiers that end in 0h through Fh.  Each array element will point
	// to a device object that represents the beginning of a linked list of
	// device objects.  By using an array of linked lists, the traversal time
	// to find an object on a bus that supports a large number of devices, such
	// as Fibre Channel, will be significantly lower than having to walk a list 
	// that is comprised of all devices on the bus.  For parallel wide and 
	// narrow busses, which support 16 and 8 devices respectively, this will act 
	// like a simple array of device objects.
	enum
	{
		kSCSIParallelDeviceListArrayCount 	= 16,
		kSCSIParallelDeviceListIndexMask	= 0x0F
	};
	
	IOSimpleLock * 					fDeviceLock;
	IOSCSIParallelInterfaceDevice *	
					fParallelDeviceList[kSCSIParallelDeviceListArrayCount];
	
	void			InitializeDeviceList ( void );
	void			AddDeviceToTargetList ( 
							IOSCSIParallelInterfaceDevice *	newDevice );
	void			RemoveDeviceFromTargetList ( 
							IOSCSIParallelInterfaceDevice * victimDevice );
	
	// The Interrupt Service Routine for the controller.
	static void		ServiceInterrupt (
							OSObject *					theObject, 
							IOInterruptEventSource *	theSource,
							int							count );
	
	static void		TimeoutOccurred ( OSObject * owner, IOTimerEventSource * sender );
	
	static bool		FilterInterrupt (
							OSObject *						theObject,
							IOFilterInterruptEventSource *	theSource );
	
	// IOService support methods
	// These shall not be overridden by the HBA child classes.
	bool			start ( IOService * 				provider );
	void			stop ( 	IOService *  				provider );
	
	
protected:
	
	// These may be overriden by the HBA child classes if necessary, but should
	// call the superclass implementation.
	virtual bool	handleOpen ( 
							IOService * 				client, 
							IOOptionBits 				options, 
							void * 						arg );

	virtual void	handleClose ( 
							IOService * 				client, 
							IOOptionBits 				options );

	virtual bool	handleIsOpen ( 
							const IOService * 			client ) const;
	
	virtual bool	willTerminate ( IOService * provider, IOOptionBits options );
	virtual bool	didTerminate ( IOService * provider, IOOptionBits options, bool * defer );
    virtual void	free ( void );

	
};


#endif	/* __IOKIT_IO_SCSI_PARALLEL_INTERFACE_CONTROLLER_H__ */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 serial/                                                                                             0040755 0001750 0001750 00000000000 12612224742 033277  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOModemSerialStreamSync.h                                                                           0100644 0001750 0001750 00000002621 12567452410 040114  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/serial                                                         /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *
 * IOModemSerialStreamSync.h
 * This file contains Modem specific extensions to the IOSerialStreamSync class.
 *
 * 2000-10-21	gvdl	Initial real change to IOKit serial family.
 *
 */  

#ifndef _SERIAL_IOMODEMSERIALSTREAMSYNC_H
#define _SERIAL_IOMODEMSERIALSTREAMSYNC_H

#include <IOKit/serial/IOSerialStreamSync.h>

class IOModemSerialStreamSync : public IOSerialStreamSync
{
    OSDeclareDefaultStructors(IOModemSerialStreamSync)
};

#endif /* !_SERIAL_IOMODEMSERIALSTREAMSYNC_H */

                                                                                                               IORS232SerialStreamSync.h                                                                           0100644 0001750 0001750 00000016714 12567452410 037636  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/serial                                                         /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * IORS232SerialStreamSync.h
 * This file contains RS232 specific extensions to the IOSerialStreamSync class.
 *
 * 2000-10-21	gvdl	Initial real change to IOKit serial family.
 */  

#ifndef _SERIAL_IORS232SERIALSTREAMSYNC_H
#define _SERIAL_IORS232SERIALSTREAMSYNC_H

#include <sys/ioctl.h>
#include <IOKit/serial/IOSerialStreamSync.h>

/*
 * Extra events for RS232 based PortDevices
 */  

#define PD_RS232_E_RX_LINE_BREAK      (PD_DATA_VOID|PD_OP(63))  // line break was received
#define PD_RS232_E_LINE_BREAK         (PD_DATA_BYTE|PD_OP(62))  // BOOL set/clear line break    

#define PD_RS232_E_RX_STOP_BITS       (PD_DATA_LONG|PD_OP(61))  // half stop bits
#define PD_RS232_E_STOP_BITS          (PD_DATA_LONG|PD_OP(60))  // half stop bits

#define PD_RS232_E_XON_BYTE           (PD_DATA_BYTE|PD_OP(59))  // The XON char for TX&RX
#define PD_RS232_E_XOFF_BYTE          (PD_DATA_BYTE|PD_OP(58))  // The XOFF char for TX&RX

#define PD_RS232_E_MIN_LATENCY        (PD_DATA_BYTE|PD_OP(57))  // BOOL true if low latency req

/*
 * RS232 Parity stuff, used with the DATA_INTEGRITY event
 */  
#define PD_RS232_PARITY_DEFAULT	0	// Valid only for RX, means follow TX
#define PD_RS232_PARITY_NONE	1	// No Parity bit inserted or expected
#define PD_RS232_PARITY_ODD	2	// Odd Parity bit inserted or expected
#define PD_RS232_PARITY_EVEN	3	// Even Parity bit inserted or expected
#define PD_RS232_PARITY_MARK	4	// Mark inserted or expected
#define PD_RS232_PARITY_SPACE	5	// Space inserted or expected
#define PD_RS232_PARITY_ANY	6	// Valid only for RX, means discard parity

/*
 * RS232 Flow Control specifiers, used with the FLOW_CONTROL event
 * NB. The XON  character is set with FLOW_START_DATA
 * and the XOFF character is set with FLOW_STOP_DATA.
 *
 * Signal  Name                          Direction
 *  RFR     Ready For Receive             Output generated by UART
 *  RTS     Ready To Send (alias of RFR)  Output generated by UART
 *  CTS     Clear To Send		  Input sensed by UART
 *  DTR     Data Terminal Ready           Output generated by UART
 *  DSR     Data Set Ready                Input sensed by UART
 *  TXO     XON/XOFF/XANY protocol        Characters received by UART
 *  RXO     XON/XOFF protocol             Characters transmitted by UART
 *  DCD     Data Carrier Detect           Input sensed by UART
 */

/*
 * RS232 State Word extensions, based on <bsd/sys/ioctl.h>
 * Also the 'current state' bits for enq/deq of Flow Control event
 */  
#define PD_RS232_S_MASK   0x0000ffffUL
#define PD_RS232_S_SHIFT  0	// to align State bits for enq/deq event
#define PD_RS232_D_MASK   0xffff0000UL
#define PD_RS232_D_SHIFT  16	// to align Delta bits for enq/deq event
#define PD_RS232_A_MASK   0x0000ffffUL
#define PD_RS232_A_SHIFT  0	// to align Auto bits for req/exec event
#define PD_RS232_N_MASK   0xffff0000UL
#define PD_RS232_N_SHIFT  16	// to align Notify bits for req/exec event

#define	PD_RS232_S_LE	TIOCM_LE	// line enable
#define	PD_RS232_S_DTR	TIOCM_DTR	// data terminal ready
#define	PD_RS232_S_RTS	TIOCM_RTS	// request to send
#define	PD_RS232_S_RFR	PD_RS232_S_RTS	// ready for receive
#define	PD_RS232_S_TXO	TIOCM_ST	// TX XON/XOFF
#define	PD_RS232_S_RXO	TIOCM_SR	// RX XON/XOFF
#define	PD_RS232_S_CTS	TIOCM_CTS	// clear to send
#define	PD_RS232_S_CAR	TIOCM_CAR	// carrier detect
#define	PD_RS232_S_DCD	PD_RS232_S_CAR
#define	PD_RS232_S_RNG	TIOCM_RNG	// ring
#define	PD_RS232_S_RI	PD_RS232_S_RNG
#define	PD_RS232_S_DSR	TIOCM_DSR	// data set ready

#define	PD_RS232_S_BRK	0x00000800UL	// break active Extension to TIOCM   
#define	PD_RS232_S_LOOP	0x00001000UL	// LOOP back Extension to TIOCM
#define PD_RS232_S_TXQ	0x00002000UL	// User flowcontrol bit
#define PD_RS232_S_RXQ	0x00004000UL	// User flowcontrol bit

// The 'delta' bits for enq/deq of Flow Control event
#define	PD_RS232_D_LE	(PD_RS232_S_LE  << PD_RS232_D_SHIFT)
#define	PD_RS232_D_DTR	(PD_RS232_S_DTR << PD_RS232_D_SHIFT)
#define	PD_RS232_D_RTS	(PD_RS232_S_RTS << PD_RS232_D_SHIFT)
#define	PD_RS232_D_RFR	(PD_RS232_S_RFR << PD_RS232_D_SHIFT)
#define	PD_RS232_D_TXO	(PD_RS232_S_TXO << PD_RS232_D_SHIFT)
#define	PD_RS232_D_RXO	(PD_RS232_S_RXO << PD_RS232_D_SHIFT)
#define	PD_RS232_D_CTS	(PD_RS232_S_CTS << PD_RS232_D_SHIFT)
#define	PD_RS232_D_CAR	(PD_RS232_S_CAR << PD_RS232_D_SHIFT)
#define	PD_RS232_D_DCD	(PD_RS232_S_DCD << PD_RS232_D_SHIFT)
#define	PD_RS232_D_RNG	(PD_RS232_S_RNG << PD_RS232_D_SHIFT)
#define	PD_RS232_D_RI	(PD_RS232_S_RI  << PD_RS232_D_SHIFT)
#define	PD_RS232_D_DSR	(PD_RS232_S_DSR << PD_RS232_D_SHIFT)
 
#define	PD_RS232_D_BRK	(PD_RS232_S_BRK  << PD_RS232_D_SHIFT)
#define	PD_RS232_D_LOOP (PD_RS232_S_LOOP << PD_RS232_D_SHIFT)
#define PD_RS232_D_TXQ	(PD_RS232_S_TXQ  << PD_RS232_D_SHIFT)
#define PD_RS232_D_RXQ	(PD_RS232_S_RXQ  << PD_RS232_D_SHIFT)

// The 'auto' bits for exec/req of Flow Control event
#define	PD_RS232_A_LE	PD_RS232_S_LE
#define	PD_RS232_A_DTR	PD_RS232_S_DTR
#define	PD_RS232_A_RTS	PD_RS232_S_RTS
#define	PD_RS232_A_RFR	PD_RS232_S_RFR
#define	PD_RS232_A_TXO	PD_RS232_S_TXO
#define	PD_RS232_A_RXO	PD_RS232_S_RXO
#define	PD_RS232_A_CTS	PD_RS232_S_CTS
#define	PD_RS232_A_CAR	PD_RS232_S_CAR
#define	PD_RS232_A_DCD	PD_RS232_S_DCD
#define	PD_RS232_A_RNG	PD_RS232_S_RNG
#define	PD_RS232_A_RI	PD_RS232_S_RI
#define	PD_RS232_A_DSR	PD_RS232_S_DSR
#define PD_RS232_A_XANY	0x00000400	// changes _A_TXO from XON/XOFF to XANY/XOFF
#define	PD_RS232_A_BRK	PD_RS232_S_BRK   
#define	PD_RS232_A_LOOP PD_RS232_S_LOOP
#define PD_RS232_A_TXQ	PD_RS232_S_TXQ
#define PD_RS232_A_RXQ	PD_RS232_S_RXQ

// The 'notify' bits for exec/req of Flow Control event
#define	PD_RS232_N_LE	(PD_RS232_S_LE  << PD_RS232_N_SHIFT)
#define	PD_RS232_N_DTR	(PD_RS232_S_DTR << PD_RS232_N_SHIFT)
#define	PD_RS232_N_RTS	(PD_RS232_S_RTS << PD_RS232_N_SHIFT)
#define	PD_RS232_N_RFR	(PD_RS232_S_RFR << PD_RS232_N_SHIFT)
#define	PD_RS232_N_TXO	(PD_RS232_S_TXO << PD_RS232_N_SHIFT)
#define	PD_RS232_N_RXO	(PD_RS232_S_RXO << PD_RS232_N_SHIFT)
#define	PD_RS232_N_CTS	(PD_RS232_S_CTS << PD_RS232_N_SHIFT)
#define	PD_RS232_N_CAR	(PD_RS232_S_CAR << PD_RS232_N_SHIFT)
#define	PD_RS232_N_DCD	(PD_RS232_S_DCD << PD_RS232_N_SHIFT)
#define	PD_RS232_N_RNG	(PD_RS232_S_RNG << PD_RS232_N_SHIFT)
#define	PD_RS232_N_RI	(PD_RS232_S_RI  << PD_RS232_N_SHIFT)
#define	PD_RS232_N_DSR	(PD_RS232_S_DSR << PD_RS232_N_SHIFT)

#define	PD_RS232_N_BRK	(PD_RS232_S_BRK  << PD_RS232_N_SHIFT)
#define	PD_RS232_N_LOOP (PD_RS232_S_LOOP << PD_RS232_N_SHIFT)
#define PD_RS232_N_TXQ	(PD_RS232_S_TXQ  << PD_RS232_N_SHIFT)
#define PD_RS232_N_RXQ	(PD_RS232_S_RXQ  << PD_RS232_N_SHIFT)

class IORS232SerialStreamSync : public IOSerialStreamSync
{
    OSDeclareDefaultStructors(IORS232SerialStreamSync)
};

#endif /* !_SERIAL_IORS232SERIALSTREAMSYNC_H */

                                                    IOSerialDriverSync.h                                                                                0100644 0001750 0001750 00000006773 12567452410 037146  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/serial                                                         /*
 *Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 *@APPLE_LICENSE_HEADER_START@
 *
 *The contents of this file constitute Original Code as defined in and
 *are subject to the Apple Public Source License Version 1.1 (the
 *"License").  You may not use this file except in compliance with the
 *License.  Please obtain a copy of the License at
 *http://www.apple.com/publicsource and read it before using this file.
 *
 *This Original Code and all software distributed under the License are
 *distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 *EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 *INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 *License for the specific language governing rights and limitations
 *under the License.
 *
 *@APPLE_LICENSE_HEADER_END@
 */

/*  
 * IOSerialDriverSync.h
 * This file contains the abstract parent class for any IOSerialDriver
 * interface, which is a generic serial interface, designed for devices
 * that do character oriented transfers (async) rather than block or
 * packet transfers.  Most notably RS-232, Printer, Mouse, and Keyboard
 * type devices.
 *
 * 2000-10-21	gvdl	Initial real change to IOKit serial family.
 */

#ifndef _SERIAL_IOSERIALDRIVERSYNC_H
#define _SERIAL_IOSERIALDRIVERSYNC_H

#include <IOKit/IOService.h>

class IOSerialDriverSync : public IOService
{
    OSDeclareAbstractStructors(IOSerialDriverSync);

public:
    virtual IOReturn acquirePort(bool sleep, void *refCon) = 0;

    virtual IOReturn releasePort(void *refCon) = 0;

    virtual IOReturn setState(UInt32 state, UInt32 mask, void *refCon) = 0;

    virtual UInt32 getState(void *refCon) = 0;

    virtual IOReturn watchState(UInt32 *state, UInt32 mask, void *refCon) = 0;

    virtual UInt32 nextEvent(void *refCon) = 0;

    virtual IOReturn executeEvent(UInt32 event, UInt32 data, void *refCon) = 0;

    virtual IOReturn requestEvent(UInt32 event, UInt32 *data, void *refCon) = 0;

    virtual IOReturn enqueueEvent(UInt32 event, UInt32 data,
                                  bool sleep, void *refCon) = 0;

    virtual IOReturn dequeueEvent(UInt32 *event, UInt32 *data,
                                  bool sleep, void *refCon) = 0;

    virtual IOReturn enqueueData(UInt8 *buffer, UInt32 size, UInt32 *count,
                                 bool sleep, void *refCon) = 0;

    virtual IOReturn dequeueData(UInt8 *buffer, UInt32 size, UInt32 *count,
                                 UInt32 min, void *refCon) = 0;

OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  0);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  1);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  2);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  3);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  4);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  5);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  6);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  7);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  8);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync,  9);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync, 10);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync, 11);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync, 12);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync, 13);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync, 14);
OSMetaClassDeclareReservedUnused(IOSerialDriverSync, 15);

};

#endif /* !_SERIAL_IOSERIALDRIVERSYNC_H */
     IOSerialKeys.h                                                                                      0100644 0001750 0001750 00000005450 12567452410 035760  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/serial                                                         /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * IOSerialKeys.h
 *
 * 2000-10-21	gvdl	Initial real change to IOKit serial family.
 *
 */

/*
Sample Matching dictionary
{
    IOProviderClass = kIOSerialBSDServiceValue;
    kIOSerialBSDTypeKey = kIOSerialBSDAllTypes
			| kIOSerialBSDModemType
			| kIOSerialBSDRS232Type;
    kIOTTYDeviceKey = <Raw Unique Device Name>;
    kIOTTYBaseNameKey = <Raw Unique Device Name>;
    kIOTTYSuffixKey = <Raw Unique Device Name>;
    kIOCalloutDeviceKey = <Callout Device Name>;
    kIODialinDeviceKey = <Dialin Device Name>;
}

Note only the IOProviderClass is mandatory.  The other keys allow the searcher to reduce the size of the set of matching devices.
*/

/* Service Matching That is the 'IOProviderClass' */
#define kIOSerialBSDServiceValue	"IOSerialBSDClient"

/* Matching keys */
#define kIOSerialBSDTypeKey		"IOSerialBSDClientType"

/* Currently possible kIOSerialBSDTypeKey values. */
#define kIOSerialBSDAllTypes		"IOSerialStream"
#define kIOSerialBSDModemType		"IOModemSerialStream"
#define kIOSerialBSDRS232Type		"IORS232SerialStream"

// Properties that resolve to a /dev device node to open for
// a particular service
#define kIOTTYDeviceKey			"IOTTYDevice"
#define kIOTTYBaseNameKey		"IOTTYBaseName"
#define kIOTTYSuffixKey			"IOTTYSuffix"

#define kIOCalloutDeviceKey		"IOCalloutDevice"
#define kIODialinDeviceKey		"IODialinDevice"

// Property 'ioctl' wait for the tty device to go idle.
#define kIOTTYWaitForIdleKey		"IOTTYWaitForIdle"

#if KERNEL
extern const OSSymbol *gIOSerialBSDServiceValue;
extern const OSSymbol *gIOSerialBSDTypeKey;
extern const OSSymbol *gIOSerialBSDAllTypes;
extern const OSSymbol *gIOSerialBSDModemType;
extern const OSSymbol *gIOSerialBSDRS232Type;
extern const OSSymbol *gIOTTYDeviceKey;
extern const OSSymbol *gIOTTYBaseNameKey;
extern const OSSymbol *gIOTTYSuffixKey;
extern const OSSymbol *gIOCalloutDeviceKey;
extern const OSSymbol *gIODialinDeviceKey;
#endif /* KERNEL */
                                                                                                                                                                                                                        IOSerialStreamSync.h                                                                                0100644 0001750 0001750 00000027253 12567452410 037142  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/serial                                                         /*
 *Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 *@APPLE_LICENSE_HEADER_START@
 *
 *The contents of this file constitute Original Code as defined in and
 *are subject to the Apple Public Source License Version 1.1 (the
 *"License").  You may not use this file except in compliance with the
 *License.  Please obtain a copy of the License at
 *http://www.apple.com/publicsource and read it before using this file.
 *
 *This Original Code and all software distributed under the License are
 *distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 *EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 *INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 *License for the specific language governing rights and limitations
 *under the License.
 *
 *@APPLE_LICENSE_HEADER_END@
 */
/*
 *  IOSerialStreamSync.h
 *
 *  2000-10-21	gvdl	Initial real change to IOKit serial family.
 *
 */

#ifndef	_SERIAL_IOSERIALSTREAMSYNC_H
#define	_SERIAL_IOSERIALSTREAMSYNC_H

#include <IOKit/IOService.h>

#ifdef __LP64__

#define PD_DATA_MASK 0x03U
#define PD_DATA_VOID 0x00U
#define PD_DATA_BYTE 0x01U
#define PD_DATA_WORD 0x02U
#define PD_DATA_LONG 0x03U

#else

#define PD_DATA_MASK 0x03UL
#define PD_DATA_VOID 0x00UL
#define PD_DATA_BYTE 0x01UL
#define PD_DATA_WORD 0x02UL
#define PD_DATA_LONG 0x03UL

#endif

#define PD_OP(x)	((x) << 2)
#define PD_E_MASK	(~PD_DATA_MASK)

/* General Command & Status events */
#define PD_E_EOQ		(PD_DATA_VOID|PD_OP( 0))	// Always nextEvent on empty queue
#define PD_E_ACTIVE		(PD_DATA_BYTE|PD_OP( 1))	// BOOL start/shutdown chip

/* Queue management events - all units are multiples of characters
 *based on the current character size
 */
#define PD_E_TXQ_SIZE 		(PD_DATA_LONG|PD_OP( 2))
#define PD_E_RXQ_SIZE		(PD_DATA_LONG|PD_OP( 3))
#define PD_E_TXQ_LOW_WATER	(PD_DATA_LONG|PD_OP( 4))
#define PD_E_RXQ_LOW_WATER	(PD_DATA_LONG|PD_OP( 5))
#define PD_E_TXQ_HIGH_WATER	(PD_DATA_LONG|PD_OP( 6))
#define PD_E_RXQ_HIGH_WATER	(PD_DATA_LONG|PD_OP( 7))
#define PD_E_TXQ_AVAILABLE	(PD_DATA_LONG|PD_OP( 8))
#define PD_E_RXQ_AVAILABLE	(PD_DATA_LONG|PD_OP( 9))
#define PD_E_TXQ_FLUSH 		(PD_DATA_VOID|PD_OP(10))
#define PD_E_RXQ_FLUSH		(PD_DATA_LONG|PD_OP(11))

/* port & link characteristics - units are half bits */
#define PD_E_DATA_RATE 		(PD_DATA_LONG|PD_OP(12))	// raw bits of symbols per second
#define PD_E_RX_DATA_RATE	(PD_DATA_LONG|PD_OP(13))
#define PD_E_DATA_SIZE 		(PD_DATA_LONG|PD_OP(14))	// raw bits per symbol
#define PD_E_RX_DATA_SIZE	(PD_DATA_LONG|PD_OP(15))
#define PD_E_DATA_INTEGRITY	(PD_DATA_LONG|PD_OP(16))	// parity or ECC method
#define PD_E_RX_DATA_INTEGRITY	(PD_DATA_LONG|PD_OP(17))
#define PD_E_EXTERNAL_CLOCK_MODE (PD_DATA_LONG|PD_OP(28))	// multiplier between clock and data rates

/* timeout events */
#define PD_E_DELAY		(PD_DATA_LONG|PD_OP(18))	// inter-character delay (us)
#define PD_E_DATA_LATENCY	(PD_DATA_LONG|PD_OP(19))	// A dequeueData Latency timeout
								// rcs Secondary Timer mainly to fix performance 
								// problems with MIDI and IRDA drivers.
								// Midi and Irda drivers will issue an IOCTL
								// call with this as the selector and
								// the Data as the value they want the rate set
								// to (Typically 1 for IrDA devices) 
#define PD_E_FLOW_CONTROL       (PD_DATA_LONG|PD_OP(20))  	// enable/disable each flow mechanism

/* I/O events */
#define PD_E_VALID_DATA 	(PD_DATA_VOID|PD_OP(21))	// A valid frame was received
#define PD_E_VALID_DATA_BYTE 	(PD_DATA_BYTE|PD_E_VALID_DATA)
#define PD_E_VALID_DATA_WORD 	(PD_DATA_WORD|PD_E_VALID_DATA)
#define PD_E_VALID_DATA_LONG 	(PD_DATA_LONG|PD_E_VALID_DATA)

#define PD_E_SPECIAL		(PD_DATA_VOID|PD_OP(22))	// valid data received with 'special' value
#define PD_E_SPECIAL_BYTE 	(PD_DATA_BYTE|PD_E_SPECIAL)
#define PD_E_SPECIAL_WORD 	(PD_DATA_WORD|PD_E_SPECIAL)
#define PD_E_SPECIAL_LONG 	(PD_DATA_LONG|PD_E_SPECIAL)

#define PD_E_FRAMING_ERROR 	(PD_DATA_VOID|PD_OP(23))	// Failure occured assembling frame
#define PD_E_FRAMING_BYTE 	(PD_DATA_BYTE|PD_E_FRAMING_ERROR)
#define PD_E_FRAMING_WORD 	(PD_DATA_WORD|PD_E_FRAMING_ERROR)
#define PD_E_FRAMING_LONG 	(PD_DATA_LONG|PD_E_FRAMING_ERROR)

#define PD_E_INTEGRITY_ERROR 	(PD_DATA_VOID|PD_OP(24))	// An uncorrectable frame was received
#define PD_E_INTEGRITY_BYTE 	(PD_DATA_BYTE|PD_E_INTEGRITY_ERROR)
#define PD_E_INTEGRITY_WORD 	(PD_DATA_WORD|PD_E_INTEGRITY_ERROR)
#define PD_E_INTEGRITY_LONG 	(PD_DATA_LONG|PD_E_INTEGRITY_ERROR)

#define PD_E_INTEGRITY_WARNING 	(PD_DATA_VOID|PD_OP(25))	// A correctable frame was received
#define PD_E_HW_OVERRUN_ERROR 	(PD_DATA_VOID|PD_OP(26))	// Hardware's buffer overflowed, data lost
#define PD_E_SW_OVERRUN_ERROR 	(PD_DATA_VOID|PD_OP(27))	// Driver's buffer overflowed, data lost

/*
 *The variables below make up the bits returned
 *by the State methods:- getState, setState, watchState
 */
#define PD_S_MASK		0xffff0000UL
#define PD_S_RX_OFFSET		7

#define PD_S_ACQUIRED		0x80000000UL
#define PD_S_ACTIVE		0x40000000UL

#define PD_S_TX_ENABLE		0x20000000UL
#define PD_S_TX_BUSY		0x10000000UL
#define PD_S_TX_EVENT 		0x08000000UL
#define PD_S_TXQ_EMPTY 		0x04000000UL
#define PD_S_TXQ_LOW_WATER 	0x02000000UL
#define PD_S_TXQ_HIGH_WATER 	0x01000000UL
#define PD_S_TXQ_FULL 		0x00800000UL
#define PD_S_TXQ_MASK		( PD_S_TXQ_EMPTY | PD_S_TXQ_LOW_WATER \
                                | PD_S_TXQ_FULL  | PD_S_TXQ_HIGH_WATER )

#define PD_S_RX_ENABLE		(PD_S_TX_ENABLE      >> PD_S_RX_OFFSET)
#define PD_S_RX_BUSY		(PD_S_TX_BUSY        >> PD_S_RX_OFFSET)
#define PD_S_RX_EVENT		(PD_S_TX_EVENT       >> PD_S_RX_OFFSET)
#define PD_S_RXQ_EMPTY 		(PD_S_TXQ_EMPTY      >> PD_S_RX_OFFSET)
#define PD_S_RXQ_LOW_WATER	(PD_S_TXQ_LOW_WATER  >> PD_S_RX_OFFSET)
#define PD_S_RXQ_HIGH_WATER	(PD_S_TXQ_HIGH_WATER >> PD_S_RX_OFFSET)
#define PD_S_RXQ_FULL 		(PD_S_TXQ_FULL       >> PD_S_RX_OFFSET)
#define PD_S_RXQ_MASK		(PD_S_TXQ_MASK       >> PD_S_RX_OFFSET)

class IOSerialDriverSync;
class IOSerialStreamSync : public IOService
{
    OSDeclareDefaultStructors(IOSerialStreamSync);

protected:
    IOSerialDriverSync *fProvider;
    void *fRefCon;

public:
    /* acquire tests and sets the state of the port object.  If the port was
    *available, then the state is set to busy, and kIOReturnSuccess is returned.
    *If the port was already busy and sleep is YES, then the thread will sleep
    *until the port is freed, then re-attempts the acquire.  If the port was
    *already busy and sleep in NO, then kIOReturnExclusiveAccess is returned.
    */   
    virtual IOReturn acquirePort(bool sleep);
    
    /* release sets the state of the port object to available and wakes up any
    *threads sleeping for access to this port.  It will return kIOReturnSuccess
    *if the port was in a busy state, and kIOReturnNotOpen if it was available.
    */
    virtual IOReturn releasePort();
    
    /*
     *Set the state for the port device.
     */
    virtual IOReturn setState(UInt32 state, UInt32 mask);

    /*
     *Get the state for the port device.
     */
    virtual UInt32 getState();
    
    /*
     *Wait for the at least one of the state bits defined in mask to be equal
     *to the value defined in state.
     *Check on entry then sleep until necessary.
     */
    virtual IOReturn watchState(UInt32 *state, UInt32 mask);

    /* nextEvent returns the type of the next event on the RX queue.  If no
     *events are present on the RX queue, then EOQ is returned.
     */
    virtual UInt32 nextEvent();

    /* executeEvent causes the specified event to be processed immediately.
     *This is primarily used for channel control commands like START & STOP
     */
    virtual IOReturn executeEvent(UInt32 event, UInt32 data);

    /* requestEvent processes the specified event as an immediate request and
     *returns the results in data.  This is primarily used for getting link
     *status information and verifying baud rate and such.
     */
    virtual IOReturn requestEvent(UInt32 event, UInt32 *data);

    /* enqueueEvent will place the specified event into the TX queue.  The
     *sleep argument allows the caller to specify the enqueueEvent's
     *behaviour when the TX queue is full.  If sleep is true, then this
     *method will sleep until the event is enqueued.  If sleep is false,
     *then enqueueEvent will immediatly return kIOReturnNoResources.
     */
    virtual IOReturn enqueueEvent(UInt32 event, UInt32 data, bool sleep);

    /* dequeueEvent will remove the oldest event from the RX queue and return
     *it in event & data.  The sleep argument defines the behaviour if the RX
     *queue is empty.  If sleep is true, then this method will sleep until an
     *event is available.  If sleep is false, then an EOQ event will be
     *returned.  In either case kIOReturnSuccess is returned.
     */
    virtual IOReturn dequeueEvent(UInt32 *event, UInt32 *data, bool sleep);

    /* enqueueData will attempt to copy data from the specified buffer to the
     *TX queue as a sequence of VALID_DATA events.  The argument bufferSize
     *specifies the number of bytes to be sent.  The actual number of bytes
     *transferred is returned in transferCount.  If sleep is true, then this
     *method will sleep until all bytes can be transferred.  If sleep is
     *false, then as many bytes as possible will be copied to the TX queue.
     */
    virtual IOReturn enqueueData(UInt8 *buffer,  UInt32 size, UInt32 *count, bool sleep );

    /* dequeueData will attempt to copy data from the RX queue to the specified
     *buffer.  No more than bufferSize VALID_DATA events will be transferred.
     *In other words, copying will continue until either a non-data event is
     *encountered or the transfer buffer is full.  The actual number of bytes
     *transferred is returned in transferCount.
     *
     *The sleep semantics of this method are slightly more complicated than
     *other methods in this API:  Basically, this method will continue to
     *sleep until either minCount characters have been received or a non
     *data event is next in the RX queue.  If minCount is zero, then this
     *method never sleeps and will return immediatly if the queue is empty.
     *
     *The latency parameter specifies the maximum amount of time that should
     *pass after the first character is available before the routine returns.
     *This allows the caller to specify a 'packet' timeout.  The unit of the
     *latency parameter is microseconds, though the exact delay may vary
     *depending on the granularity of the timeout services available to the
     *driver.
     */
    virtual IOReturn dequeueData(UInt8 *buffer, UInt32 size, UInt32 *count, UInt32 min);

    /*	Internal for IOSerialDriver only */
    virtual bool init(OSDictionary *dictionary = 0, void *refCon = 0);
    virtual bool attach(IOService *provider);
    void *getRefCon() const { return fRefCon; }

OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  0);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  1);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  2);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  3);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  4);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  5);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  6);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  7);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  8);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync,  9);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync, 10);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync, 11);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync, 12);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync, 13);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync, 14);
OSMetaClassDeclareReservedUnused(IOSerialStreamSync, 15);
};

#endif /* !_SERIAL_IOSERIALSTREAMSYNC_H */


                                                                                                                                                                                                                                                                                                                                                     storage/                                                                                            0040755 0001750 0001750 00000000000 12612224742 033464  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOAppleLabelScheme.h                                                                                0100644 0001750 0001750 00000012525 12567452411 037222  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOAppleLabelScheme class definition.
 */

#ifndef _IOAPPLELABELSCHEME_H
#define _IOAPPLELABELSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOAppleLabelSchemeClass is the name of the IOAppleLabelScheme class.
 */

#define kIOAppleLabelSchemeClass "IOAppleLabelScheme"

/*
 * Apple Label Scheme Definitions
 */

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Label scheme. */

struct applelabel
{
    uint8_t  al_boot0[416];               /* (reserved for boot area)         */
    uint16_t al_magic;                    /* (the magic number)               */
    uint16_t al_type;                     /* (label type)                     */
    uint32_t al_flags;                    /* (generic flags)                  */
    uint64_t al_offset;                   /* (offset of property area, bytes) */
    uint32_t al_size;                     /* (size of property area, bytes)   */
    uint32_t al_checksum;                 /* (checksum of property area)      */
    uint8_t  al_boot1[72];                /* (reserved for boot area)         */
};

/* Label scheme signature (al_magic). */

#define AL_MAGIC 0x414C

/* Label scheme version (al_type). */

#define AL_TYPE_DEFAULT 0x0000

/* Label scheme flags (al_flags). */

#define AL_FLAG_DEFAULT 0x00000000

#pragma pack(pop)                        /* (reset to default struct packing) */

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOFilterScheme.h>

/*
 * Class
 */

class IOAppleLabelScheme : public IOFilterScheme
{
    OSDeclareDefaultStructors(IOAppleLabelScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    IOMedia * _content;

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free(void);

    /*
     * Scan the provider media for an Apple label scheme.
     */

    virtual IOMedia * scan(SInt32 * score);

    /*
     * Ask whether the given content appears to be corrupt.
     */

    virtual bool isContentCorrupt(OSDictionary * properties);

    /*
     * Ask whether the given content appears to be invalid.
     */

    virtual bool isContentInvalid(OSDictionary * properties);

    /*
     * Instantiate a new media object to represent the given content.
     */

    virtual IOMedia * instantiateMediaObject(OSDictionary * properties);

    /*
     * Allocate a new media object (called from instantiateMediaObject).
     */

    virtual IOMedia * instantiateDesiredMediaObject(OSDictionary * properties);

    /*
     * Attach the given media object to the device tree plane.
     */

    virtual bool attachMediaObjectToDeviceTree(IOMedia * media);

    /*
     * Detach the given media object from the device tree plane.
     */

    virtual void detachMediaObjectFromDeviceTree(IOMedia * media);

public:

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*
     * Determine whether the provider media contains an Apple label scheme.
     */

    virtual IOService * probe(IOService * provider, SInt32 * score);

    /*
     * Publish the new media object which represents our content.
     */

    virtual bool start(IOService * provider);

    /*
     * Clean up after the media object we published before terminating.
     */

    virtual void stop(IOService * provider);

    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  0);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  1);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  2);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  3);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  4);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  5);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  6);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  7);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  8);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme,  9);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme, 10);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme, 11);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme, 12);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme, 13);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme, 14);
    OSMetaClassDeclareReservedUnused(IOAppleLabelScheme, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOAPPLELABELSCHEME_H */
                                                                                                                                                                           IOApplePartitionScheme.h                                                                            0100644 0001750 0001750 00000022643 12567452411 040156  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOApplePartitionScheme class definition.
 */

#ifndef _IOAPPLEPARTITIONSCHEME_H
#define _IOAPPLEPARTITIONSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOApplePartitionSchemeClass is the name of the IOApplePartitionScheme class.
 */

#define kIOApplePartitionSchemeClass "IOApplePartitionScheme"

/*
 * Apple Partition Map Definitions
 */

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Structure constants. */

#define DPISTRLEN 32

/* Partition map entry, as found in blocks 1 to dpme_map_entries of the disk. */

typedef struct dpme
{
    UInt16  dpme_signature;       /* (unique value for partition entry, 'PM') */
    UInt16  dpme_reserved_1;      /* (reserved for future use)                */
    UInt32  dpme_map_entries;     /* (number of partition entries)            */
    UInt32  dpme_pblock_start;    /* (physical block start of partition)      */
    UInt32  dpme_pblocks;         /* (physical block count of partition)      */
    char    dpme_name[DPISTRLEN]; /* (name of partition)                      */
    char    dpme_type[DPISTRLEN]; /* (type of partition, eg. Apple_HFS)       */
    UInt32  dpme_lblock_start;    /* (logical block start of partition)       */
    UInt32  dpme_lblocks;         /* (logical block count of partition)       */
    UInt32  dpme_flags;           /* (partition flags, see defines below)     */
    UInt32  dpme_boot_block;      /* (logical block start of boot code)       */
    UInt32  dpme_boot_bytes;      /* (byte count of boot code)                */
    UInt32  dpme_load_addr;       /* (load address in memory of boot code)    */
    UInt32  dpme_load_addr_2;     /* (reserved for future use)                */
    UInt32  dpme_goto_addr;       /* (jump address in memory of boot code)    */
    UInt32  dpme_goto_addr_2;     /* (reserved for future use)                */
    UInt32  dpme_checksum;        /* (checksum of boot code)                  */
    UInt8   dpme_process_id[16];  /* (processor type)                         */
    UInt32  dpme_reserved_2[32];  /* (reserved for future use)                */
    UInt32  dpme_reserved_3[62];  /* (reserved for future use)                */
} DPME;

/* Driver descriptor map entry. */

typedef struct DDMap
{
    UInt32  ddBlock;              /* (driver's block start, sbBlkSize-blocks) */
    UInt16  ddSize;               /* (driver's block count, 512-blocks)       */
    UInt16  ddType;               /* (driver's system type)                   */
} DDMap;

/* Driver descriptor map, as found in block zero of the disk. */

typedef struct Block0
{
    UInt16  sbSig;                     /* (unique value for block zero, 'ER') */
    UInt16  sbBlkSize;                 /* (block size for this device)        */
    UInt32  sbBlkCount;                /* (block count for this device)       */
    UInt16  sbDevType;                 /* (device type)                       */
    UInt16  sbDevId;                   /* (device id)                         */
    UInt32  sbDrvrData;                /* (driver data)                       */
    UInt16  sbDrvrCount;               /* (driver descriptor count)           */
    DDMap   sbDrvrMap[8];              /* (driver descriptor table)           */
    UInt8   sbReserved[430];           /* (reserved for future use)           */
} Block0;

/* Partition map signature (sbSig). */

#define BLOCK0_SIGNATURE 0x4552

/* Partition map entry signature (dpme_signature). */

#define DPME_SIGNATURE 0x504D

/* Partition map entry flags (dpme_flags). */

#define DPME_FLAGS_VALID          0x00000001                   /* (bit 0)     */
#define DPME_FLAGS_ALLOCATED      0x00000002                   /* (bit 1)     */
#define DPME_FLAGS_IN_USE         0x00000004                   /* (bit 2)     */
#define DPME_FLAGS_BOOTABLE       0x00000008                   /* (bit 3)     */
#define DPME_FLAGS_READABLE       0x00000010                   /* (bit 4)     */
#define DPME_FLAGS_WRITABLE       0x00000020                   /* (bit 5)     */
#define DPME_FLAGS_OS_PIC_CODE    0x00000040                   /* (bit 6)     */
#define DPME_FLAGS_OS_SPECIFIC_2  0x00000080                   /* (bit 7)     */
#define DPME_FLAGS_OS_SPECIFIC_1  0x00000100                   /* (bit 8)     */
#define DPME_FLAGS_RESERVED_2     0xFFFFFE00                   /* (bit 9..31) */

#pragma pack(pop)                        /* (reset to default struct packing) */

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOPartitionScheme.h>

/*
 * Class
 */

class IOApplePartitionScheme : public IOPartitionScheme
{
    OSDeclareDefaultStructors(IOApplePartitionScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    OSSet * _partitions;    /* (set of media objects representing partitions) */

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free(void);

    /*
     * Scan the provider media for an Apple partition map.  Returns the set
     * of media objects representing each of the partitions (the retain for
     * the set is passed to the caller), or null should no partition map be
     * found.  The default probe score can be adjusted up or down, based on
     * the confidence of the scan.
     */

    virtual OSSet * scan(SInt32 * score);

    /*
     * Ask whether the given partition appears to be corrupt.  A partition that
     * is corrupt will cause the failure of the Apple partition map recognition
     * altogether.
     */

    virtual bool isPartitionCorrupt( dpme * partition,
                                     UInt32 partitionID,
                                     UInt32 partitionBlockSize );

    /*
     * Ask whether the given partition appears to be invalid.  A partition that
     * is invalid will cause it to be skipped in the scan, but will not cause a
     * failure of the Apple partition map recognition.
     */

    virtual bool isPartitionInvalid( dpme * partition,
                                     UInt32 partitionID,
                                     UInt32 partitionBlockSize );

    /*
     * Instantiate a new media object to represent the given partition.
     */

    virtual IOMedia * instantiateMediaObject( dpme * partition,
                                              UInt32 partitionID,
                                              UInt32 partitionBlockSize );

    /*
     * Allocate a new media object (called from instantiateMediaObject).
     */

    virtual IOMedia * instantiateDesiredMediaObject(
                                                    dpme * partition,
                                                    UInt32 partitionID,
                                                    UInt32 partitionBlockSize );

public:

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*
     * Determine whether the provider media contains an Apple partition map.
     */

    virtual IOService * probe(IOService * provider, SInt32 * score);

    /*
     * Publish the new media objects which represent our partitions.
     */

    virtual bool start(IOService * provider);

    /*
     * Clean up after the media objects we published before terminating.
     */

    virtual void stop(IOService * provider);

    /*
     * Request that the provider media be re-scanned for partitions.
     */

    virtual IOReturn requestProbe(IOOptionBits options);

    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  0);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  1);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  2);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  3);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  4);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  5);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  6);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  7);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  8);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme,  9);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme, 10);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme, 11);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme, 12);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme, 13);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme, 14);
    OSMetaClassDeclareReservedUnused(IOApplePartitionScheme, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOAPPLEPARTITIONSCHEME_H */
                                                                                             IOBDBlockStorageDevice.h                                                                            0100644 0001750 0001750 00000012105 12567452545 040003  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBDBlockStorageDevice
 * @abstract
 * This header contains the IOBDBlockStorageDevice class definition.
 */

#ifndef	_IOBDBLOCKSTORAGEDEVICE_H
#define	_IOBDBLOCKSTORAGEDEVICE_H

#include <IOKit/storage/IOBDTypes.h>

/*!
 * @defined kIOBDBlockStorageDeviceClass
 * @abstract
 * kIOBDBlockStorageDeviceClass is the name of the IOBDBlockStorageDevice class.
 * @discussion
 * kIOBDBlockStorageDeviceClass is the name of the IOBDBlockStorageDevice class.
 */

#define kIOBDBlockStorageDeviceClass "IOBDBlockStorageDevice"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IODVDBlockStorageDevice.h>

/* Property used for matching, so the generic driver gets the nub it wants. */
#define	kIOBlockStorageDeviceTypeBD	"BD"

/*!
 * @class
 * IOBDBlockStorageDevice
 * @abstract
 * The IOBDBlockStorageDevice class is a generic BD block storage device
 * abstraction.
 * @discussion
 * This class is the protocol for generic BD functionality, independent of
 * the physical connection protocol (e.g. SCSI, ATA, USB).
 *
 * The APIs are the union of CD APIs, DVD APIs, and all
 * necessary new low-level BD APIs.
 *
 * A subclass implements relay methods that translate our requests into
 * calls to a protocol- and device-specific provider.
 */

class IOBDBlockStorageDevice : public IODVDBlockStorageDevice
{
    OSDeclareAbstractStructors(IOBDBlockStorageDevice)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /*!
     * @function init
     * @discussion
     * Initialize this object's minimal state.
     * @param properties
     * Substitute property table for this object (optional).
     * @result
     * Returns true on success, false otherwise.
     */

    virtual bool init(OSDictionary * properties);

    /*!
     * @function readDiscStructure
     * @discussion
     * Issue an MMC READ DISC STRUCTURE command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param format
     * As documented by MMC.
     * @param address
     * As documented by MMC.
     * @param layer
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @param type
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readDiscStructure( IOMemoryDescriptor * buffer,
                                        UInt8                format,
                                        UInt32               address,
                                        UInt8                layer,
                                        UInt8                grantID,
                                        UInt8                type ) = 0;

    /*!
     * @function splitTrack
     * @discussion
     * Issue an MMC RESERVE TRACK command with the ARSV bit.
     * @param address
     * As documented by MMC.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn splitTrack(UInt32 address) = 0;

    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  0);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  1);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  2);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  3);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  4);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  5);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  6);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  7);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  8);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice,  9);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice, 10);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice, 11);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice, 12);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice, 13);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice, 14);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDevice, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOBDBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                           IOBDBlockStorageDriver.h                                                                            0100644 0001750 0001750 00000013637 12567452545 040052  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * @header IOBDBlockStorageDriver
 * @abstract
 * This header contains the IOBDBlockStorageDriver class definition.
 * @discussion
 * This class implements BD functionality, independent of
 * the physical connection protocol (e.g. SCSI, ATA, USB).
 *
 * A protocol-specific provider implements the functionality using an appropriate
 * protocol and commands.
 */

#ifndef	_IOBDBLOCKSTORAGEDRIVER_H
#define	_IOBDBLOCKSTORAGEDRIVER_H

#include <IOKit/storage/IOBDBlockStorageDevice.h>
#include <IOKit/storage/IODVDBlockStorageDriver.h>

/*
 * @defined kIOBDBlockStorageDriverClass
 * @abstract
 * kIOBDBlockStorageDriverClass is the name of the IOBDBlockStorageDriver class.
 * @discussion
 * kIOBDBlockStorageDriverClass is the name of the IOBDBlockStorageDriver class.
 */

#define kIOBDBlockStorageDriverClass "IOBDBlockStorageDriver"

/*
 * @class
 * IOBDBlockStorageDriver
 * @abstract
 * Generic BD Driver.
 * @discussion
 * Storage drivers are split into two parts: the Generic Driver handles
 * all generic device issues, independent of the lower-level transport
 * mechanism (e.g. SCSI, ATA, USB, FireWire). All storage operations
 * at the Generic Driver level are translated into a series of generic
 * device operations. These operations are passed via the Device Nub
 * to a Transport Driver, which implements the appropriate
 * transport-dependent protocol to execute these operations.
 * 
 * To determine the write-protect state of a device (or media), for
 * example, the generic driver would issue a call to the
 * Transport Driver's reportWriteProtection method. If this were a SCSI
 * device, its Transport Driver would issue a Mode Sense command to
 * extract the write-protection status bit. The Transport Driver then
 * reports true or false to the generic driver.
 * 
 * The generic driver therefore has no knowledge of, or involvement
 * with, the actual commands and mechanisms used to communicate with
 * the device. It is expected that the generic driver will rarely, if
 * ever, need to be subclassed to handle device idiosyncrasies; rather,
 * the Transport Driver should be changed via overrides.
 * 
 * A generic driver could be subclassed to create a different type of
 * generic device. The generic driver IOBDBlockStorageDriver class is a subclass
 * of IODVDBlockStorageDriver, adding BD functions. Similarly, the Transport Driver
 * IOBDBlockStorageDevice is a subclass of IODVDBlockStorageDevice, adding BD 
 * functions.
*/

class IOBDBlockStorageDriver : public IODVDBlockStorageDriver
{
    OSDeclareDefaultStructors(IOBDBlockStorageDriver)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    /* Overrides of IODVDBlockStorageDriver. */

    virtual IOReturn acceptNewMedia(void);

    /* End of IODVDBlockStorageDriver overrides. */

public:

    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of IOService -- IOBDBlockStorageDevice.
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IOBDBlockStorageDevice * getProvider() const;

    /* Overrides of IODVDBlockStorageDriver: */

    virtual const char * getDeviceTypeName(void);
    virtual IOMedia * instantiateDesiredMediaObject(void);
    virtual IOMedia * instantiateMediaObject(UInt64 base,UInt64 byteSize,
                                            UInt32 blockSize,char *mediaName);
    virtual IOReturn readStructure(IOMemoryDescriptor *buffer,const DVDStructureFormat format,
                                        const UInt32 address,const UInt8 layer,const UInt8 agid);

    /* End of IODVDBlockStorageDriver overrides. */

    /*
     * @function splitTrack
     * @discussion
     * Issue an MMC RESERVE TRACK command with the ARSV bit.
     * @param address
     * As documented by MMC.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn splitTrack(UInt32 address);

    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  0);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  1);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  2);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  3);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  4);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  5);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  6);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  7);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  8);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver,  9);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver, 10);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver, 11);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver, 12);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver, 13);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver, 14);
    OSMetaClassDeclareReservedUnused(IOBDBlockStorageDriver, 15);
};

#endif  /* !_IOBDBLOCKSTORAGEDRIVER_H */
                                                                                                 IOBDMedia.h                                                                                         0100644 0001750 0001750 00000021674 12567452545 035336  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBDMedia
 * @abstract
 * This header contains the IOBDMedia class definition.
 */

#ifndef _IOBDMEDIA_H
#define _IOBDMEDIA_H

/*!
 * @defined kIOBDMediaClass
 * @abstract
 * kIOBDMediaClass is the name of the IOBDMedia class.
 * @discussion
 * kIOBDMediaClass is the name of the IOBDMedia class.
 */

#define kIOBDMediaClass "IOBDMedia"

/*!
 * @defined kIOBDMediaTypeKey
 * @abstract
 * kIOBDMediaTypeKey is a property of IOBDMedia objects.  It has an OSString
 * value.
 * @discussion
 * The kIOBDMediaTypeKey property identifies the BD media type (BD-ROM, BD-R,
 * BD-RE, etc).  See the kIOBDMediaType contants for possible values.
 */

#define kIOBDMediaTypeKey "Type"

/*!
 * @defined kIOBDMediaTypeROM
 * The kIOBDMediaTypeKey constant for BD-ROM media.
 */

#define kIOBDMediaTypeROM "BD-ROM"

/*!
 * @defined kIOBDMediaTypeR
 * The kIOBDMediaTypeKey constant for BD-R media.
 */

#define kIOBDMediaTypeR "BD-R"

/*!
 * @defined kIOBDMediaTypeRE
 * The kIOBDMediaTypeKey constant for BD-RE media.
 */

#define kIOBDMediaTypeRE "BD-RE"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOBDBlockStorageDriver.h>
#include <IOKit/storage/IOMedia.h>

/*!
 * @class IOBDMedia
 * @abstract
 * The IOBDMedia class is a random-access disk device abstraction for BDs.
 * @discussion
 * The IOBDMedia class is a random-access disk device abstraction for BDs.
 */

class IOBDMedia : public IOMedia
{
    OSDeclareDefaultStructors(IOBDMedia)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /*
     * Obtain this object's provider.   We override the superclass's method to
     * return a more specific subclass of IOService -- IOBDBlockStorageDriver.
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IOBDBlockStorageDriver * getProvider() const;

    /*
     * Compare the properties in the supplied table to this object's properties.
     */

    virtual bool matchPropertyTable(OSDictionary * table, SInt32 * score);

    /*!
     * @function reportKey
     * @discussion
     * Issue an MMC REPORT KEY command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param keyClass
     * As documented by MMC.
     * @param address
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @param format
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn reportKey( IOMemoryDescriptor * buffer,
                                UInt8                keyClass,
                                UInt32               address,
                                UInt8                grantID,
                                UInt8                format );

    /*!
     * @function sendKey
     * @discussion
     * Issue an MMC SEND KEY command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param keyClass
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @param format
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn sendKey( IOMemoryDescriptor * buffer,
                              UInt8                keyClass,
                              UInt8                grantID,
                              UInt8                format );

    /*!
     * @function readStructure
     * @discussion
     * Issue an MMC READ DISC STRUCTURE command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param format
     * As documented by MMC.
     * @param address
     * As documented by MMC.
     * @param layer
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readStructure( IOMemoryDescriptor *     buffer,
                                    UInt8                    format,
                                    UInt32                   address,
                                    UInt8                    layer,
                                    UInt8                    grantID );

    /*!
     * @function getSpeed
     * @discussion
     * Get the current speed used for data transfers.
     * @param kilobytesPerSecond
     * Returns the current speed used for data transfers, in kB/s.
     *
     * kBDSpeedMin specifies the minimum speed for all BD media (1X).
     * kBDSpeedMax specifies the maximum speed supported in hardware.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn getSpeed(UInt16 * kilobytesPerSecond);

    /*!
     * @function setSpeed
     * @discussion
     * Set the speed to be used for data transfers.
     * @param kilobytesPerSecond
     * Speed to be used for data transfers, in kB/s.
     *
     * kBDSpeedMin specifies the minimum speed for all BD media (1X).
     * kBDSpeedMax specifies the maximum speed supported in hardware.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setSpeed(UInt16 kilobytesPerSecond);

    /*!
     * @function readDiscInfo
     * @discussion
     * Issue an MMC READ DISC INFORMATION command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param type
     * Reserved for future use.  Set to zero.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readDiscInfo( IOMemoryDescriptor * buffer,
                                   UInt8                type,
                                   UInt16 *             actualByteCount );

    /*!
     * @function readTrackInfo
     * @discussion
     * Issue an MMC READ TRACK INFORMATION command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param address
     * As documented by MMC.
     * @param addressType
     * As documented by MMC.
     * @param open
     * Reserved for future use.  Set to zero.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readTrackInfo( IOMemoryDescriptor * buffer,
                                    UInt32               address,
                                    UInt8                addressType,
                                    UInt8                open,
                                    UInt16 *             actualByteCount );

    /*!
     * @function splitTrack
     * @discussion
     * Issue an MMC RESERVE TRACK command with the ARSV bit.
     * @param address
     * As documented by MMC.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn splitTrack(UInt32 address);

    OSMetaClassDeclareReservedUnused(IOBDMedia,  0);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  1);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  2);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  3);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  4);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  5);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  6);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  7);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  8);
    OSMetaClassDeclareReservedUnused(IOBDMedia,  9);
    OSMetaClassDeclareReservedUnused(IOBDMedia, 10);
    OSMetaClassDeclareReservedUnused(IOBDMedia, 11);
    OSMetaClassDeclareReservedUnused(IOBDMedia, 12);
    OSMetaClassDeclareReservedUnused(IOBDMedia, 13);
    OSMetaClassDeclareReservedUnused(IOBDMedia, 14);
    OSMetaClassDeclareReservedUnused(IOBDMedia, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOBDMEDIA_H */
                                                                    IOBDMediaBSDClient.h                                                                                0100644 0001750 0001750 00000012402 12567452545 037013  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOBDMEDIABSDCLIENT_H
#define _IOBDMEDIABSDCLIENT_H

#include <sys/ioctl.h>
#include <sys/types.h>

#include <IOKit/storage/IOBDTypes.h>

/*
 * Definitions
 *
 * ioctl                        description
 * ---------------------------- ------------------------------------------------
 * DKIOCBDREADSTRUCTURE         see IOBDMedia::readStructure()    in IOBDMedia.h
 *
 * DKIOCBDREADDISCINFO          see IOBDMedia::readDiscInfo()     in IOBDMedia.h
 * DKIOCBDREADTRACKINFO         see IOBDMedia::readTrackInfo()    in IOBDMedia.h
 *
 * DKIOCBDREPORTKEY             see IOBDMedia::reportKey()        in IOBDMedia.h
 * DKIOCBDSENDKEY               see IOBDMedia::sendKey()          in IOBDMedia.h
 *
 * DKIOCBDGETSPEED              see IOBDMedia::getSpeed()         in IOBDMedia.h
 * DKIOCBDSETSPEED              see IOBDMedia::setSpeed()         in IOBDMedia.h
 *
 *         in /System/Library/Frameworks/Kernel.framework/Headers/IOKit/storage/
 */

typedef struct
{
    uint8_t  format;

    uint8_t  reserved0008[3];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;
    uint8_t  layer;

    uint8_t  reserved0080[4];                      /* reserved, clear to zero */

    uint16_t bufferLength;
    void *   buffer;
} dk_bd_read_structure_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[2];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;

    uint8_t  reserved0072[5];                      /* reserved, clear to zero */

    uint16_t bufferLength;
    void *   buffer;
} dk_bd_report_key_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[6];                      /* reserved, clear to zero */

    uint8_t  grantID;

    uint8_t  reserved0072[5];                      /* reserved, clear to zero */

    uint16_t bufferLength;
    void *   buffer;
} dk_bd_send_key_t;

typedef struct
{
    uint8_t  reserved0000[14];                     /* reserved, clear to zero */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_bd_read_disc_info_t;

typedef struct
{
    uint8_t  reserved0000[4];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  addressType;

    uint8_t  reserved0072[5];                      /* reserved, clear to zero */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_bd_read_track_info_t;

#define DKIOCBDREADSTRUCTURE   _IOW('d', 160, dk_bd_read_structure_t)
#define DKIOCBDREPORTKEY       _IOW('d', 161, dk_bd_report_key_t)
#define DKIOCBDSENDKEY         _IOW('d', 162, dk_bd_send_key_t)

#define DKIOCBDGETSPEED        _IOR('d', 163, uint16_t)
#define DKIOCBDSETSPEED        _IOW('d', 163, uint16_t)

#define DKIOCBDREADDISCINFO    _IOWR('d', 164, dk_bd_read_disc_info_t)
#define DKIOCBDREADTRACKINFO   _IOWR('d', 165, dk_bd_read_track_info_t)

#define DKIOCBDSPLITTRACK      _IOW('d', 166, uint32_t)

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOBDMedia.h>
#include <IOKit/storage/IOMediaBSDClient.h>

/*
 * Class
 */

class IOBDMediaBSDClient : public IOMediaBSDClient
{
    OSDeclareDefaultStructors(IOBDMediaBSDClient)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /*
     * Obtain this object's provider.  We override the superclass's method
     * to return a more specific subclass of IOService -- IOBDMedia.  This
     * method serves simply as a convenience to subclass developers.
     */

    virtual IOBDMedia * getProvider() const;

    /*
     * Process a BD-specific ioctl.
     */

    virtual int ioctl(dev_t dev, u_long cmd, caddr_t data, int flags, proc_t proc);

    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 0);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 1);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 2);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 3);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 4);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 5);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 6);
    OSMetaClassDeclareReservedUnused(IOBDMediaBSDClient, 7);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOBDMEDIABSDCLIENT_H */
                                                                                                                                                                                                                                                              IOBDTypes.h                                                                                         0100644 0001750 0001750 00000006537 12567452545 035424  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef	_BDTYPES_H
#define	_BDTYPES_H

#include <IOKit/IOTypes.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/*
 * Media Types
 */

enum
{
    kBDMediaTypeUnknown   = 0x0300,
    kBDMediaTypeROM       = 0x0302, /* BD-ROM */
    kBDMediaTypeRE        = 0x0303, /* BD-RE  */
    kBDMediaTypeR         = 0x0304, /* BD-R   */

    kBDMediaTypeMin       = 0x0300,
    kBDMediaTypeMax       = 0x03FF
};

typedef UInt32 BDMediaType;

/*
 * Media Speed (kB/s)
 */

#define kBDSpeedMin 0x1126
#define kBDSpeedMax 0xFFFF

/*
 * MMC Formats
 */

// Read Disc Information Format
struct BDDiscInfo
{
    UInt16 dataLength;
#ifdef __LITTLE_ENDIAN__
    UInt8  discStatus:2;
    UInt8  stateOfLastSession:2;
    UInt8  erasable:1;
    UInt8  dataType:3;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  dataType:3;
    UInt8  erasable:1;
    UInt8  stateOfLastSession:2;
    UInt8  discStatus:2;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved2;
    UInt8  numberOfSessionsLSB;
    UInt8  firstTrackNumberInLastSessionLSB;
    UInt8  lastTrackNumberInLastSessionLSB;
    UInt8  reserved4[2];
    UInt8  numberOfSessionsMSB;
    UInt8  firstTrackNumberInLastSessionMSB;
    UInt8  lastTrackNumberInLastSessionMSB;
    UInt8  reserved6[22];
};
typedef struct BDDiscInfo BDDiscInfo;

// Read Track Information Format
struct BDTrackInfo
{
    UInt16 dataLength;
    UInt8  trackNumberLSB;
    UInt8  sessionNumberLSB;
    UInt8  reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved2:5;
    UInt8  damage:1;
    UInt8  reserved3:2;

    UInt8  reserved4:6;
    UInt8  blank:1;
    UInt8  reservedTrack:1;

    UInt8  nextWritableAddressValid:1;
    UInt8  lastRecordedAddressValid:1;
    UInt8  reserved5:6;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved3:2;
    UInt8  damage:1;
    UInt8  reserved2:5;

    UInt8  reservedTrack:1;
    UInt8  blank:1;
    UInt8  reserved4:6;

    UInt8  reserved5:6;
    UInt8  lastRecordedAddressValid:1;
    UInt8  nextWritableAddressValid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt32 trackStartAddress;
    UInt32 nextWritableAddress;
    UInt32 freeBlocks;
    UInt32 clusterSize;
    UInt32 trackSize;
    UInt32 lastRecordedAddress;
    UInt8  trackNumberMSB;
    UInt8  sessionNumberMSB;
    UInt8  reserved6;
    UInt8  reserved7;
};
typedef struct BDTrackInfo BDTrackInfo;

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* _BDTYPES_H */
                                                                                                                                                                 IOBlockStorageDevice.h                                                                              0100644 0001750 0001750 00000042726 12567452411 037601  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBlockStorageDevice
 * @abstract
 * This header contains the IOBlockStorageDevice class definition.
 */

#ifndef _IOBLOCKSTORAGEDEVICE_H
#define _IOBLOCKSTORAGEDEVICE_H

#include <IOKit/IOTypes.h>
#include <IOKit/storage/IOStorageDeviceCharacteristics.h>

/*!
 * @defined kIOBlockStorageDeviceClass
 * @abstract
 * The name of the IOBlockStorageDevice class.
 */

#define kIOBlockStorageDeviceClass "IOBlockStorageDevice"

/*!
 * @defined kIOBlockStorageDeviceWriteCacheStateKey
 * @abstract
 * The name of the property used to get or set the write cache state of the
 * block storage device.
 */
#define kIOBlockStorageDeviceWriteCacheStateKey	"WriteCacheState"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOService.h>
#include <IOKit/storage/IOMedia.h>

/*!
 * @defined kIOMessageMediaParametersHaveChanged
 * @abstract
 * The message ID which indicates that the media parameters, such as the highest valid block
 * for the device, have changed.
 * @discussion
 * The message is passed to all clients of the IOBlockStorageDevice via the message() method.
 */
#define kIOMessageMediaParametersHaveChanged iokit_family_msg(sub_iokit_block_storage, 2)

/*!
 * @defined kIOMessageMediaStateHasChanged
 * @abstract
 * The message ID which indicates that the media state has changed.
 * @discussion
 * The message is passed to all clients of the IOBlockStorageDevice via the message() method.
 * The argument that is passed along with this message is an IOMediaState value.
 */
#define kIOMessageMediaStateHasChanged iokit_family_msg(sub_iokit_block_storage, 1)

/* Property used for matching, so the generic driver gets the nub it wants. */
/*!
 * @defined kIOBlockStorageDeviceTypeKey
 * @abstract The name of the property tested for nub type matching by the generic block
 * storage driver.
 */
#define	kIOBlockStorageDeviceTypeKey	"device-type"
/*!
 * @defined kIOBlockStorageDeviceTypeGeneric
 * @abstract A character string used for nub matching.
 */
#define	kIOBlockStorageDeviceTypeGeneric	"Generic"

/*!
 * @struct IOBlockStorageDeviceExtent
 * @abstract
 * Extent for unmap storage requests.
 * @field blockStart
 * The starting block number of the operation.
 * @field blockCount
 * The integral number of blocks to be deleted.
 */

struct IOBlockStorageDeviceExtent
{
    UInt64 blockStart;
    UInt64 blockCount;
};

/*!
 * @class
 * IOBlockStorageDevice
 * @abstract
 * A generic block storage device abstraction.
 * @discussion
 * The IOBlockStorageDevice class exports the generic block storage protocol,
 * independent of the physical connection protocol (e.g. SCSI, ATA, USB),
 * forwarding all requests to its provider (the Transport Driver).
 * Though the nub does no actual processing of requests, it is necessary
 * in a C++ environment. The Transport Driver can be of any type, as
 * long as it inherits from IOService. Because Transport Drivers needn't
 * derive from a type known to IOBlockStorageDriver, it isn't possible for
 * IOBlockStorageDriver to include the appropriate header file to allow direct
 * communication with the Transport Driver. Thus we achieve polymorphism by 
 * having the Transport Driver instantiate a subclass of IOBlockStorageDevice.
 * A typical implementation for a concrete subclass of IOBlockStorageDevice
 * simply relays all methods to its provider (the Transport Driver), which
 * implements the protocol- and device-specific behavior.
 * 
 * All pure-virtual functions must be implemented by the Transport Driver, which
 * is responsible for instantiating the Nub.
 */

class IOBlockStorageDevice : public IOService {

    OSDeclareAbstractStructors(IOBlockStorageDevice)
    
protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /* Overrides from IORegistryEntry */

    using IORegistryEntry::getProperty;

    /*!
     * @function init
     * @discussion
     * This function is overridden so that IOBlockStorageDevice can set a
     * property, used by IOBlockStorageDriver for matching. Since the concrete
     * subclass of IOBlockStorageDevice can be of any class type, the property
     * is used for matching.
     * 
     * This function is usually not overridden by developers.
     */    
    virtual bool	init(OSDictionary * properties);

    virtual OSObject *	getProperty(const OSSymbol * key) const;

    virtual IOReturn	setProperties(OSObject * properties);

    /* --- A subclass must implement the the following methods: --- */

    /*!
     * @function doEjectMedia
     * @abstract
     * Eject the media.
     */
    virtual IOReturn	doEjectMedia(void)	= 0;

    /*!
     * @function doFormatMedia
     * @abstract
     * Format the media to the specified byte capacity.
     * @discussion
     * The specified byte capacity must be one supported by the device.
     * Supported capacities can be obtained by calling doGetFormatCapacities.
     * @param byteCapacity
     * The byte capacity to which the device is to be formatted, if possible.
     */
    virtual IOReturn	doFormatMedia(UInt64 byteCapacity)	= 0;

    /*!
     * @function doGetFormatCapacities
     * @abstract
     * Return the allowable formatting byte capacities.
     * @discussion
     * This function returns the supported byte capacities for the device.
     * @param capacities
     * Pointer for returning the list of capacities.
     * @param capacitiesMaxCount
     * The number of capacity values returned in "capacities," or if no buffer
     * is given, the total number of capacity values available.
     */
    virtual UInt32	doGetFormatCapacities(UInt64 * capacities,
                                            UInt32   capacitiesMaxCount) const	= 0;

#ifdef __x86_64__
    virtual IOReturn	doLockUnlockMedia(bool doLock) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    virtual IOReturn	doSynchronizeCache(void) __attribute__ ((deprecated));

    /*!
     * @function getVendorString
     * @abstract
     * Return Vendor Name string for the device.
     * @result
     * A pointer to a static character string.
     */
    virtual char *	getVendorString(void)	= 0;
    
    /*!
     * @function getProductString
     * @abstract
     * Return Product Name string for the device.
     * @result
     * A pointer to a static character string.
     */
    virtual char *	getProductString(void)	= 0;
    
    /*!
     * @function getRevisionString
     * @abstract
     * Return Product Revision string for the device.
     * @result
     * A pointer to a static character string.
     */
    virtual char *	getRevisionString(void)	= 0;
    
    /*!
     * @function getAdditionalDeviceInfoString
     * @abstract
     * Return additional informational string for the device.
     * @result
     * A pointer to a static character string.
     */
    virtual char *	getAdditionalDeviceInfoString(void)	= 0;

    /*!
     * @function reportBlockSize
     * @abstract
     * Report the block size for the device, in bytes.
     * @param blockSize
     * Pointer to returned block size value.
     */    
    virtual IOReturn	reportBlockSize(UInt64 *blockSize)	= 0;

    /*!
     * @function reportEjectability
     * @abstract
     * Report if the media is ejectable under software control.
     * @discussion
     * This method should only be called if the media is known to be removable.
     * @param isEjectable
     * Pointer to returned result. True indicates the media is ejectable, False indicates
     * the media cannot be ejected under software control.
     */
    virtual IOReturn	reportEjectability(bool *isEjectable)	= 0;

#ifdef __x86_64__
    virtual IOReturn	reportLockability(bool *isLockable) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function reportMaxValidBlock
     * @abstract
     * Report the highest valid block for the device.
     * @param maxBlock
     * Pointer to returned result
     */    
    virtual IOReturn	reportMaxValidBlock(UInt64 *maxBlock)	= 0;

    /*!
     * @function reportMediaState
     * @abstract
     * Report the device's media state.
     * @discussion
     * This method reports whether we have media in the drive or not, and
     * whether the state has changed from the previously reported state.
     * 
     * A result of kIOReturnSuccess is always returned if the test for media is successful,
     * regardless of media presence. The mediaPresent result should be used to determine
     * whether media is present or not. A return other than kIOReturnSuccess indicates that
     * the Transport Driver was unable to interrogate the device. In this error case, the
     * outputs mediaState and changedState will *not* be stored.
     * @param mediaPresent Pointer to returned media state. True indicates media is present
     * in the device; False indicates no media is present.
     */
    virtual IOReturn	reportMediaState(bool *mediaPresent,bool *changedState = 0)	= 0;
    
#ifdef __x86_64__
    virtual IOReturn	reportPollRequirements(bool *pollRequired,
                                            bool *pollIsExpensive) __attribute__ ((deprecated));
#endif /* __x86_64__ */
    
    /*!
     * @function reportRemovability
     * @abstract
     * Report whether the media is removable or not.
     * @discussion
     * This method reports whether the media is removable, but it does not
     * provide detailed information regarding software eject or lock/unlock capability.
     * @param isRemovable
     * Pointer to returned result. True indicates that the media is removable; False
     * indicates the media is not removable.
     */
    virtual IOReturn	reportRemovability(bool *isRemovable)  	= 0;
    
    /*!
     * @function reportWriteProtection
     * @abstract
     * Report whether the media is write-protected or not.
     * @param isWriteProtected
     * Pointer to returned result. True indicates that the media is write-protected (it
     * cannot be written); False indicates that the media is not write-protected (it
     * is permissible to write).
     */
    virtual IOReturn	reportWriteProtection(bool *isWriteProtected)	= 0;

    /*!
     * @function getWriteCacheState
     * @abstract
     * Reports the current write cache state of the device.
     * @discussion
     * Reports the current write cache state of the device.  The write cache
     * state is not guaranteed to persist across reboots and detaches.
     * @param enabled
     * Pointer to returned result. True indicates the write cache is enabled;
     * False indicates the write cache is disabled.
     */
    virtual IOReturn	getWriteCacheState(bool *enabled);

    /*!
     * @function setWriteCacheState
     * @abstract
     * Sets the write cache state of the device.
     * @discussion
     * Sets the write cache state of the device.  The write cache state
     * is not guaranteed to persist across reboots and detaches.
     * @param enabled
     * True to enable the write cache; False to disable the write cache.
     */
    virtual IOReturn	setWriteCacheState(bool enabled);

    /*!
     * @function doAsyncReadWrite
     * @abstract
     * Start an asynchronous read or write operation.
     * @param buffer
     * An IOMemoryDescriptor describing the data-transfer buffer. The data direction
     * is contained in the IOMemoryDescriptor. Responsibility for releasing the descriptor
     * rests with the caller.
     * @param block
     * The starting block number of the data transfer.
     * @param nblks
     * The integral number of blocks to be transferred.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.
     * @param completion
     * The completion routine to call once the data transfer is complete.
     */
    virtual IOReturn	doAsyncReadWrite(IOMemoryDescriptor *buffer,
                                            UInt64 block, UInt64 nblks,
                                            IOStorageAttributes *attributes,
                                            IOStorageCompletion *completion)	= 0;

    /*!
     * @function requestIdle
     * @abstract
     * Request that the device enter an idle state.
     * @discussion
     * Request that the device enter an idle state.  The device will exit this state on the
     * next read or write request, or as it sees necessary.  One example is for a DVD drive
     * to spin down when it enters such an idle state, and spin up on the next read request
     * from the system.
     */
    virtual IOReturn	requestIdle(void);

#ifdef __x86_64__
    virtual IOReturn doDiscard(UInt64 block, UInt64 nblks) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function doUnmap
     * @abstract
     * Delete unused data blocks from the media.
     * @param extents
     * List of extents.  See IOBlockStorageDeviceExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param options
     * Options for the unmap.  See IOStorageUnmapOptions.
     */
    virtual IOReturn doUnmap(IOBlockStorageDeviceExtent * extents,
                             UInt32                       extentsCount,
                             IOStorageUnmapOptions        options = 0); /* 10.6.6 */

    /*!
     * @function doSetPriority
     * @abstract
     * Reprioritize read or write operations.
     * @param extents
     * List of extents.  See IOBlockStorageDeviceExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param priority
     * New priority.  See IOStoragePriority.
     */
    virtual IOReturn doSetPriority(IOBlockStorageDeviceExtent * extents,
                                   UInt32                       extentsCount,
                                   IOStoragePriority            priority); /* 10.10.0 */

    /*!
     * @function doSynchronize
     * @abstract
     * Force data blocks in the hardware's buffer to be flushed to the media.
     * @discussion
     * This method should only be called if the media is writable.
     * @param block
     * The starting block number of the synchronization.
     * @param nblks
     * The integral number of blocks to be synchronized.  Set to zero to specify the
     * end-of-media.
     * @param options
     * Options for the synchronization.  See IOStorageSynchronizeOptions.
     */
    virtual IOReturn	doSynchronize(UInt64                      block,
                                      UInt64                      nblks,
                                      IOStorageSynchronizeOptions options = 0); /* 10.11.0 */

    OSMetaClassDeclareReservedUsed(IOBlockStorageDevice,  0);
    OSMetaClassDeclareReservedUsed(IOBlockStorageDevice,  1);
    OSMetaClassDeclareReservedUsed(IOBlockStorageDevice,  2);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  3);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  4);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  5);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  6);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  7);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  8);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice,  9);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 10);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 11);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 12);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 13);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 14);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 15);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 16);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 17);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 18);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 19);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 20);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 21);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 22);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 23);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 24);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 25);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 26);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 27);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 28);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 29);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 30);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDevice, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOBLOCKSTORAGEDEVICE_H */
                                          IOBlockStorageDriver.h                                                                              0100644 0001750 0001750 00000157167 12567452411 037643  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOBlockStorageDriver
 * @abstract
 * This header contains the IOBlockStorageDriver class definition.
 */

#ifndef _IOBLOCKSTORAGEDRIVER_H
#define _IOBLOCKSTORAGEDRIVER_H

#include <IOKit/IOTypes.h>

/*!
 * @defined kIOBlockStorageDriverClass
 * @abstract
 * The name of the IOBlockStorageDriver class.
 */

#define kIOBlockStorageDriverClass "IOBlockStorageDriver"

/*!
 * @defined kIOBlockStorageDriverStatisticsKey
 * @abstract
 * Holds a table of numeric values describing the driver's
 * operating statistics.
 * @discussion
 * This property holds a table of numeric values describing the driver's
 * operating statistics.  The table is an OSDictionary, where each entry
 * describes one given statistic.
 */

#define kIOBlockStorageDriverStatisticsKey "Statistics"

/*!
 * @defined kIOBlockStorageDriverStatisticsBytesReadKey
 * @abstract
 * Describes the number of bytes read since the block storage
 * driver was instantiated.
 * @discussion
 * This property describes the number of bytes read since the block storage
 * driver was instantiated.  It is one of the statistic entries listed under
 * the top-level kIOBlockStorageDriverStatisticsKey property table.  It has
 * an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsBytesReadKey "Bytes (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsBytesWrittenKey
 * @abstract
 * Describes the number of bytes written since the block storage
 * driver was instantiated. 
 * @discussion
 * This property describes the number of bytes written since the block storage
 * driver was instantiated.  It is one of the statistic entries listed under the
 * top-level kIOBlockStorageDriverStatisticsKey property table.  It has an
 * OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsBytesWrittenKey "Bytes (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsReadErrorsKey
 * @abstract
 * Describes the number of read errors encountered since the block
 * storage driver was instantiated. 
 * @discussion
 * This property describes the number of read errors encountered since the block
 * storage driver was instantiated.  It is one of the statistic entries listed
 * under the top-level kIOBlockStorageDriverStatisticsKey property table.  It
 * has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsReadErrorsKey "Errors (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsWriteErrorsKey
 * @abstract
 * Describes the number of write errors encountered since the
 * block storage driver was instantiated.
 * @discussion
 * This property describes the number of write errors encountered since the
 * block storage driver was instantiated.  It is one of the statistic entries
 * listed under the top-level kIOBlockStorageDriverStatisticsKey property table. 
 * It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsWriteErrorsKey "Errors (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsLatentReadTimeKey
 * @abstract
 * Describes the number of nanoseconds of latency during reads
 * since the block storage driver was instantiated. 
 * @discussion
 * This property describes the number of nanoseconds of latency during reads
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsLatentReadTimeKey "Latency Time (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsLatentWriteTimeKey
 * @abstract
 * Describes the number of nanoseconds of latency during writes
 * since the block storage driver was instantiated. 
 * @discussion
 * This property describes the number of nanoseconds of latency during writes
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsLatentWriteTimeKey "Latency Time (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsReadsKey
 * @abstract
 * Describes the number of read operations processed since the
 * block storage driver was instantiated.
 * @discussion
 * This property describes the number of read operations processed since the
 * block storage driver was instantiated.  It is one of the statistic entries
 * listed under the top-level kIOBlockStorageDriverStatisticsKey property table.
 * It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsReadsKey "Operations (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsWritesKey
 * @abstract
 * Describes the number of write operations processed since the
 * block storage driver was instantiated.
 * @discussion
 * This property describes the number of write operations processed since the
 * block storage driver was instantiated.  It is one of the statistic entries
 * listed under the top-level kIOBlockStorageDriverStatisticsKey property table.
 * It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsWritesKey "Operations (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsReadRetriesKey
 * @abstract
 * Describes the number of read retries required since the block
 * storage driver was instantiated.
 * @discussion
 * This property describes the number of read retries required since the block
 * storage driver was instantiated.  It is one of the statistic entries listed
 * under the top-level kIOBlockStorageDriverStatisticsKey property table.  It
 * has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsReadRetriesKey "Retries (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsWriteRetriesKey
 * @abstract
 * Describes the number of write retries required since the block
 * storage driver was instantiated.
 * @discussion
 * This property describes the number of write retries required since the block
 * storage driver was instantiated.  It is one of the statistic entries listed
 * under the top-level kIOBlockStorageDriverStatisticsKey property table.  It
 * has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsWriteRetriesKey "Retries (Write)"

/*!
 * @defined kIOBlockStorageDriverStatisticsTotalReadTimeKey
 * @abstract
 * Describes the number of nanoseconds spent performing reads
 * since the block storage driver was instantiated.
 * @discussion
 * This property describes the number of nanoseconds spent performing reads
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsTotalReadTimeKey "Total Time (Read)"

/*!
 * @defined kIOBlockStorageDriverStatisticsTotalWriteTimeKey
 * @abstract
 * Describes the number of nanoseconds spent performing writes
 * since the block storage driver was instantiated.
 * @discussion
 * This property describes the number of nanoseconds spent performing writes
 * since the block storage driver was instantiated.  It is one of the statistic
 * entries listed under the top-level kIOBlockStorageDriverStatisticsKey
 * property table.  It has an OSNumber value.
 */

#define kIOBlockStorageDriverStatisticsTotalWriteTimeKey "Total Time (Write)"

/*!
 * @enum IOMediaState
 * @abstract
 * The different states that getMediaState() can report.
 * @constant kIOMediaStateOffline
 * Media is not available.
 * @constant kIOMediaStateOnline
 * Media is available and ready for operations.
 * @constant kIOMediaStateBusy
 * Media is available, but not ready for operations.
 */

enum
{
    kIOMediaStateOffline = 0,
    kIOMediaStateOnline  = 1,
    kIOMediaStateBusy    = 2
};

typedef UInt32 IOMediaState;

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOBlockStorageDevice.h>
#include <IOKit/storage/IOMedia.h>
#include <IOKit/storage/IOStorage.h>

/*!
 * @class IOBlockStorageDriver
 * @abstract
 * The common base class for generic block storage drivers.
 * @discussion
 * The IOBlockStorageDriver class is the common base class for generic block
 * storage drivers.  It matches and communicates via an IOBlockStorageDevice
 * interface, and connects to the remainder of the storage framework via the
 * IOStorage protocol. It extends the IOStorage protocol by implementing the
 * appropriate open and close semantics, deblocking for unaligned transfers,
 * polling for ejectable media, locking and ejection policies, media object
 * creation and tear-down, and statistics gathering and reporting.
 *
 * Block storage drivers are split into two parts: the generic driver handles
 * all generic device issues, independent of the lower-level transport
 * mechanism (e.g. SCSI, ATA, USB, FireWire). All storage operations
 * at the generic driver level are translated into a series of generic
 * device operations. These operations are passed via the IOBlockStorageDevice
 * nub to a transport driver, which implements the appropriate
 * transport-dependent protocol to execute these operations.
 *
 * To determine the write-protect state of a device (or media), for
 * example, the generic driver would issue a call to the
 * Transport Driver's reportWriteProtection method. If this were a SCSI
 * device, its transport driver would issue a Mode Sense command to
 * extract the write-protection status bit. The transport driver then
 * reports true or false to the generic driver.
 * 
 * The generic driver therefore has no knowledge of, or involvement
 * with, the actual commands and mechanisms used to communicate with
 * the device. It is expected that the generic driver will rarely, if
 * ever, need to be subclassed to handle device idiosyncrasies; rather,
 * the transport driver should be changed via overrides.
 * 
 * A generic driver could be subclassed to create a different type of
 * generic device. The generic driver IOCDBlockStorageDriver class is
 * a subclass of IOBlockStorageDriver, adding CD functions.
 */

class IOBlockStorageDriver : public IOStorage
{
    OSDeclareDefaultStructors(IOBlockStorageDriver);

public:

    /*!
     * @enum Statistics
     * @abstract
     * Indices for the different statistics that getStatistics() can report.
     * @constant kStatisticsReads Number of read operations thus far.
     * @constant kStatisticsBytesRead Number of bytes read thus far.
     * @constant kStatisticsTotalReadTime Nanoseconds spent performing reads thus far.
     * @constant kStatisticsLatentReadTime Nanoseconds of latency during reads thus far.
     * @constant kStatisticsReadRetries Number of read retries thus far.
     * @constant kStatisticsReadErrors Number of read errors thus far.
     * @constant kStatisticsWrites Number of write operations thus far.
     * @constant kStatisticsSingleBlockWrites Number of write operations for a single block thus far.
     * @constant kStatisticsBytesWritten Number of bytes written thus far.
     * @constant kStatisticsTotalWriteTime Nanoseconds spent performing writes thus far.
     * @constant kStatisticsLatentWriteTime Nanoseconds of latency during writes thus far.
     * @constant kStatisticsWriteRetries Number of write retries thus far.
     * @constant kStatisticsWriteErrors Number of write errors thus far.
     */

    enum Statistics
    {
        kStatisticsReads,
        kStatisticsBytesRead,
        kStatisticsTotalReadTime,
        kStatisticsLatentReadTime,
        kStatisticsReadRetries,
        kStatisticsReadErrors,

        kStatisticsWrites,
        kStatisticsSingleBlockWrites,
        kStatisticsBytesWritten,
        kStatisticsTotalWriteTime,
        kStatisticsLatentWriteTime,
        kStatisticsWriteRetries,
        kStatisticsWriteErrors
    };

    static const UInt32 kStatisticsCount = kStatisticsWriteErrors + 1;

protected:

    struct Context;

    struct ExpansionData
    {
        UInt64         reserved0000;
        UInt64         maxReadBlockTransfer;
        UInt64         maxWriteBlockTransfer;
        IONotifier *   powerEventNotifier;
        UInt32         deblockRequestWriteLockCount;
        UInt64         maxReadSegmentTransfer;
        UInt64         maxWriteSegmentTransfer;
        UInt64         maxReadSegmentByteTransfer;
        UInt64         maxWriteSegmentByteTransfer;
        UInt64         minSegmentAlignmentByteTransfer;
        UInt64         maxSegmentWidthByteTransfer;
        Context *      contexts;
        IOSimpleLock * contextsLock;
        UInt32         contextsCount;
        UInt32         contextsMaxCount;
    };
    ExpansionData * _expansionData;

    #define _maxReadBlockTransfer            \
              IOBlockStorageDriver::_expansionData->maxReadBlockTransfer
    #define _maxWriteBlockTransfer           \
              IOBlockStorageDriver::_expansionData->maxWriteBlockTransfer
    #define _powerEventNotifier              \
              IOBlockStorageDriver::_expansionData->powerEventNotifier
    #define _deblockRequestWriteLockCount    \
              IOBlockStorageDriver::_expansionData->deblockRequestWriteLockCount
    #define _maxReadSegmentTransfer          \
              IOBlockStorageDriver::_expansionData->maxReadSegmentTransfer
    #define _maxWriteSegmentTransfer         \
              IOBlockStorageDriver::_expansionData->maxWriteSegmentTransfer
    #define _maxReadSegmentByteTransfer      \
              IOBlockStorageDriver::_expansionData->maxReadSegmentByteTransfer
    #define _maxWriteSegmentByteTransfer     \
              IOBlockStorageDriver::_expansionData->maxWriteSegmentByteTransfer
    #define _minSegmentAlignmentByteTransfer \
              IOBlockStorageDriver::_expansionData->minSegmentAlignmentByteTransfer
    #define _maxSegmentWidthByteTransfer     \
              IOBlockStorageDriver::_expansionData->maxSegmentWidthByteTransfer
    #define _contexts                        \
              IOBlockStorageDriver::_expansionData->contexts
    #define _contextsLock                    \
              IOBlockStorageDriver::_expansionData->contextsLock
    #define _contextsCount                   \
              IOBlockStorageDriver::_expansionData->contextsCount
    #define _contextsMaxCount                \
              IOBlockStorageDriver::_expansionData->contextsMaxCount

    OSSet *         _openClients;
    OSNumber *      _statistics[kStatisticsCount];

    /*
     * @struct Context
     * @discussion
     * Context structure for a read/write operation.  It describes the block size,
     * and where applicable, a block type and block sub-type, for a data transfer,
     * as well as the completion information for the original request.  Note that
     * the block type field is unused in the IOBlockStorageDriver class.
     * @field block.size
     * Block size for the operation.
     * @field block.type
     * Block type for the operation.  Unused in IOBlockStorageDriver.  The default
     * value for this field is IOBlockStorageDriver::kBlockTypeStandard.
     * @field block.typeSub
     * Block sub-type for the operation.  It's definition depends on block.type.
     * Unused in IOBlockStorageDriver.
     * @field request.byteStart
     * Starting byte offset for the data transfer.
     * @param request.buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param request.attributes
     * Attributes of the data transfer.  See IOStorageAttributes.
     * @param request.completion
     * Completion routine to call once the data transfer is complete.
     */

    struct Context
    {
        struct
        {
            UInt64               byteStart;
            IOMemoryDescriptor * buffer;
            IOStorageAttributes  attributes;
            IOStorageCompletion  completion;
        } request;

        struct
        {
            UInt32               size;
            UInt8                type;
            UInt8                typeSub[3];
        } block;

        AbsoluteTime timeStart;

        UInt64 reserved0704;
        UInt64 reserved0768;
        UInt64 reserved0832;
        UInt64 reserved0896;

        Context * next;
    };

    static const UInt8 kBlockTypeStandard = 0x00;

    using IOService::open;

    /*
     * Free all of this object's outstanding resources.
     *
     * This method's implementation is not typically overridden.
     */

    void free();

    /*!
     * @function handleOpen
     * @discussion
     * The handleOpen method grants or denies permission to access this object
     * to an interested client.  The argument is an IOStorageAccess value that
     * specifies the level of access desired -- reader or reader-writer.
     *
     * This method can be invoked to upgrade or downgrade the access level for
     * an existing client as well.  The previous access level will prevail for
     * upgrades that fail, of course.   A downgrade should never fail.  If the
     * new access level should be the same as the old for a given client, this
     * method will do nothing and return success.  In all cases, one, singular
     * close-per-client is expected for all opens-per-client received.
     *
     * This implementation replaces the IOService definition of handleIsOpen().
     * @param client
     * Client requesting the open.
     * @param options
     * Options for the open.  Set to zero.
     * @param access
     * Access level for the open.  Set to kIOStorageAccessReader or
     * kIOStorageAccessReaderWriter.
     * @result
     * Returns true if the open was successful, false otherwise.
     */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       access);

    /*!
     * @function handleIsOpen
     * @discussion
     * The handleIsOpen method determines whether the specified client, or any
     * client if none is specified, presently has an open on this object.
     *
     * This implementation replaces the IOService definition of handleIsOpen().
     * @param client
     * Client to check the open state of.  Set to zero to check the open state
     * of all clients.
     * @result
     * Returns true if the client was (or clients were) open, false otherwise.
     */

    virtual bool handleIsOpen(const IOService * client) const;

    /*!
     * @function handleClose
     * @discussion
     * The handleClose method closes the client's access to this object.
     *
     * This implementation replaces the IOService definition of handleIsOpen().
     * @param client
     * Client requesting the close.
     * @param options
     * Options for the close.  Set to zero.
     */

    virtual void handleClose(IOService * client, IOOptionBits options);

    /*!
     * @function addToBytesTransferred
     * @discussion
     * Update the total number of bytes transferred, the total transfer time,
     * and the total latency time -- used for statistics.
     *
     * This method's implementation is not typically overridden.
     * @param bytesTransferred
     * Number of bytes transferred in this operation.
     * @param totalTime
     * Nanoseconds spent performing this operation.
     * @param latentTime
     * Nanoseconds of latency during this operation.
     * @param isWrite
     * Indicates whether this operation was a write, otherwise is was a read.
     */

    virtual void addToBytesTransferred(UInt64 bytesTransferred,
                                       UInt64 totalTime,
                                       UInt64 latentTime,
                                       bool   isWrite);

    /*!
     * @function incrementErrors
     * @discussion
     * Update the total error count -- used for statistics.
     *
     * This method's implementation is not typically overridden.
     * @param isWrite
     * Indicates whether this operation was a write, otherwise is was a read.
     */

    virtual void incrementErrors(bool isWrite);

    /*!
     * @function incrementRetries
     * @discussion
     * Update the total retry count -- used for statistics.
     *
     * This method's implementation is not typically overridden.
     * @param isWrite
     * Indicates whether this operation was a write, otherwise is was a read.
     */

    virtual void incrementRetries(bool isWrite);

    /*!
     * @function allocateContext
     * @discussion
     * Allocate a context structure for a read/write operation.
     * @result
     * Context structure.
     */

    virtual Context * allocateContext();

    /*!
     * @function deleteContext
     * @discussion
     * Delete a context structure from a read/write operation.
     * @param context
     * Context structure to be deleted.
     */

    virtual void deleteContext(Context * context);

    /*!
     * @function deblockRequest
     * @discussion
     * The deblockRequest method checks to see if the incoming request rests
     * on the media's block boundaries, and if not, deblocks it.  Deblocking
     * involves rounding out the request to the nearest block boundaries and
     * transferring the excess bytes into a scratch buffer.
     *
     * This method is part of a sequence of methods invoked for each read/write
     * request.  The first is prepareRequest, which allocates and prepares some
     * context for the transfer; the second is deblockRequest, which aligns the
     * transfer at the media's block boundaries; third is breakUpRequest, which
     * breaks up the transfer into multiple sub-transfers when certain hardware
     * constraints are exceeded; fourth is executeRequest, which implements the
     * actual transfer from the block storage device.
     *
     * This method's implementation is not typically overridden.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param context
     * Additional context information for the data transfer (e.g. block size).
     */

    virtual void deblockRequest(UInt64                byteStart,
                                IOMemoryDescriptor *  buffer,
                                IOStorageAttributes * attributes,
                                IOStorageCompletion * completion,
                                Context *             context);

    /*!
     * @function executeRequest
     * @discussion
     * Execute an asynchronous storage request.  The request is guaranteed to be
     * block-aligned.
     *
     * This method is part of a sequence of methods invoked for each read/write
     * request.  The first is prepareRequest, which allocates and prepares some
     * context for the transfer; the second is deblockRequest, which aligns the
     * transfer at the media's block boundaries; third is breakUpRequest, which
     * breaks up the transfer into multiple sub-transfers when certain hardware
     * constraints are exceeded; fourth is executeRequest, which implements the
     * actual transfer from the block storage device.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param context
     * Additional context information for the data transfer (e.g. block size).
     */

    virtual void executeRequest(UInt64                byteStart,
                                IOMemoryDescriptor *  buffer,
                                IOStorageAttributes * attributes,
                                IOStorageCompletion * completion,
                                Context *             context);

    /*!
     * @function handleStart
     * @discussion
     * Prepare the block storage driver for operation.
     *
     * This is where a media object needs to be created for fixed media, and
     * optionally for removable media.
     *
     * Note that this method is called from within the start() routine;
     * if this method returns successfully,  it should be prepared to accept
     * any of IOBlockStorageDriver's APIs.
     * @param provider
     * This object's provider.
     * @result
     * Returns true on success, false otherwise.
     */

    virtual bool handleStart(IOService * provider);

#ifdef __x86_64__
    virtual bool handleYield(IOService *  provider,
                             IOOptionBits options  = 0,
                             void *       argument = 0) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function getMediaBlockSize
     * @discussion
     * Ask the driver about the media's natural block size.
     * @result
     * Natural block size, in bytes.
     */

    virtual UInt64 getMediaBlockSize() const;

public:

    using IOStorage::open;
    using IOStorage::read;
    using IOStorage::write;

    /*
     * Initialize this object's minimal state.
     *
     * This method's implementation is not typically overridden.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*
     * This method is called once we have been attached to the provider object.
     *
     * This method's implementation is not typically overridden.
     */

    virtual bool start(IOService * provider);

    /*
     * This method is called before we are detached from the provider object.
     *
     * This method's implementation is not typically overridden.
     */

    virtual void stop(IOService * provider);

    virtual bool didTerminate(IOService *  provider,
                              IOOptionBits options,
                              bool *       defer);

#ifdef __x86_64__
    virtual bool yield(IOService *  provider,
                       IOOptionBits options  = 0,
                       void *       argument = 0) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function read
     * @discussion
     * The read method is the receiving end for all read requests from the
     * storage framework (through the media object created by this driver).
     *
     * This method initiates a sequence of methods (stages) for each read/write
     * request.  The first is prepareRequest, which allocates and prepares some
     * context for the transfer; the second is deblockRequest, which aligns the
     * transfer at the media's block boundaries; third is breakUpRequest, which
     * breaks up the transfer into multiple sub-transfers when certain hardware
     * constraints are exceeded; fourth is executeRequest, which implements the
     * actual transfer from the block storage device.
     *
     * This method's implementation is not typically overridden.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion);

    /*!
     * @function write
     * @discussion
     * The write method is the receiving end for all write requests from the
     * storage framework (through the media object created by this driver).
     *
     * This method initiates a sequence of methods (stages) for each read/write
     * request.  The first is prepareRequest, which allocates and prepares some
     * context for the transfer; the second is deblockRequest, which aligns the
     * transfer at the media's block boundaries; third is breakUpRequest, which
     * breaks up the transfer into multiple sub-transfers when certain hardware
     * constraints are exceeded; fourth is executeRequest, which implements the
     * actual transfer from the block storage device.
     *
     * This method's implementation is not typically overridden.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion);

    /*!
     * @function synchronize
     * @discussion
     * Flush the cached data in the storage object, if any.
     * @param client
     * Client requesting the synchronization.
     * @param byteStart
     * Starting byte offset for the synchronization.
     * @param byteCount
     * Size of the synchronization.  Set to zero to specify the end-of-media.
     * @param options
     * Options for the synchronization.  See IOStorageSynchronizeOptions.
     * @result
     * Returns the status of the synchronization.
     */

    virtual IOReturn synchronize(IOService *                 client,
                                 UInt64                      byteStart,
                                 UInt64                      byteCount,
                                 IOStorageSynchronizeOptions options = 0);

    /*!
     * @function unmap
     * @discussion
     * Delete unused data from the storage object at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param options
     * Options for the unmap.  See IOStorageUnmapOptions.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn unmap(IOService *           client,
                           IOStorageExtent *     extents,
                           UInt32                extentsCount,
                           IOStorageUnmapOptions options = 0);

    /*!
     * @function lockPhysicalExtents
     * @discussion
     * Lock the contents of the storage object against relocation temporarily,
     * for the purpose of getting physical extents.
     * @param client
     * Client requesting the operation.
     * @result
     * Returns true if the lock was successful, false otherwise.
     */

    virtual bool lockPhysicalExtents(IOService * client);

    /*!
     * @function copyPhysicalExtent
     * @discussion
     * Convert the specified byte offset into a physical byte offset, relative
     * to a physical storage object.  This call should only be made within the
     * context of lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     * @param byteStart
     * Starting byte offset for the operation.  Returns a physical byte offset,
     * relative to the physical storage object, on success.
     * @param byteCount
     * Size of the operation.  Returns the actual number of bytes which can be
     * transferred, relative to the physical storage object, on success. 
     * @result
     * A reference to the physical storage object, which should be released by
     * the caller, or a null on error.
     */

    virtual IOStorage * copyPhysicalExtent(IOService * client,
                                           UInt64 *    byteStart,
                                           UInt64 *    byteCount);

    /*!
     * @function unlockPhysicalExtents
     * @discussion
     * Unlock the contents of the storage object for relocation again.  This
     * call must balance a successful call to lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     */

    virtual void unlockPhysicalExtents(IOService * client);

    /*!
     * @function setPriority
     * @discussion
     * Reprioritize read or write requests at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param priority
     * New priority.  See IOStoragePriority.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setPriority(IOService *       client,
                                 IOStorageExtent * extents,
                                 UInt32            extentsCount,
                                 IOStoragePriority priority);

    /*!
     * @function ejectMedia
     * @discussion
     * Eject the media from the device.  The driver is responsible for tearing
     * down the media object it created before proceeding with the eject.   If
     * the tear-down fails, an error should be returned.
     * @result
     * An IOReturn code.
     */

    virtual IOReturn ejectMedia();

    /*!
     * @function formatMedia
     * @discussion
     * Format the media with the specified byte capacity.  The driver is
     * responsible for tearing down the media object and recreating it.
     * @param byteCapacity
     * Number of bytes to format media to.
     * @result
     * An IOReturn code.
     */

    virtual IOReturn formatMedia(UInt64 byteCapacity);

#ifdef __x86_64__
    virtual IOReturn lockMedia(bool lock) __attribute__ ((deprecated));

    virtual IOReturn pollMedia() __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function isMediaEjectable
     * @discussion
     * Ask the driver whether the media is ejectable.
     * @result
     * Returns true if the media is ejectable, false otherwise.
     */

    virtual bool isMediaEjectable() const;

    /*!
     * @function isMediaRemovable
     * @discussion
     * Ask the driver whether the media is ejectable.
     * @result
     * Returns true if the media is ejectable, false otherwise.
     */

    virtual bool isMediaRemovable() const;

#ifdef __x86_64__
    virtual bool isMediaPollExpensive() const __attribute__ ((deprecated));

    virtual bool isMediaPollRequired() const __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function isMediaWritable
     * @discussion
     * Ask the driver whether the media is writable.
     * @result
     * Returns true if the media is writable, false otherwise.
     */

    virtual bool isMediaWritable() const;

    /*!
     * @function getMediaState
     * @discussion
     * Ask the driver about the media's current state.
     * @result
     * An IOMediaState value.
     */

    virtual IOMediaState getMediaState() const;

    /*!
     * @function getFormatCapacities
     * @discussion
     * Ask the driver to report the feasible formatting capacities for the
     * inserted media (in bytes).  This routine fills the caller's buffer,
     * up to the maximum count specified if the real number of capacities
     * would overflow the buffer.   The return value indicates the actual
     * number of capacities copied to the buffer.
     *
     * If the capacities buffer is not supplied or if the maximum count is
     * zero, the routine returns the proposed count of capacities instead.
     * @param capacities
     * Buffer that will receive the UInt64 capacity values.
     * @param capacitiesMaxCount
     * Maximum number of capacity values that can be held in the buffer.
     * @result
     * Actual number of capacity values copied to the buffer, or if no buffer
     * is given, the total number of capacity values available.
     */

    virtual UInt32 getFormatCapacities(UInt64 * capacities,
                                       UInt32   capacitiesMaxCount) const;

    /*!
     * @function getStatistics
     * @discussion
     * Ask the driver to report its operating statistics.
     *
     * The statistics are each indexed by IOBlockStorageDriver::Statistics
     * indices.  This routine fills the caller's buffer, up to the maximum
     * count specified if the real number of statistics would overflow the
     * buffer.  The return value indicates the actual number of statistics
     * copied to the buffer.
     *
     * If the statistics buffer is not supplied or if the maximum count is
     * zero, the routine returns the proposed count of statistics instead.
     * @param statistics
     * Buffer that will receive the UInt64 statistic values.
     * @param statisticsMaxCount
     * Maximum number of statistic values that can be held in the buffer.
     * @result
     * Actual number of statistic values copied to the buffer, or if no buffer
     * is given, the total number of statistic values available.
     */

    virtual UInt32 getStatistics(UInt64 * statistics,
                                 UInt32   statisticsMaxCount) const;

    /*!
     * @function getStatistic
     * @discussion
     * Ask the driver to report one of its operating statistics.
     * @param statistic
     * Statistic index (an IOBlockStorageDriver::Statistics index).
     * @result
     * Statistic value.
     */

    virtual UInt64 getStatistic(Statistics statistic) const;

    /*
     * Generic entry point for calls from the provider.  A return value of
     * kIOReturnSuccess indicates that the message was received, and where
     * applicable, that it was successful.
     */

    virtual IOReturn message(UInt32 type, IOService * provider, void * argument);

    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of IOService -- IOBlockStorageDevice.  
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IOBlockStorageDevice * getProvider() const;

protected:

    IOLock *      _deblockRequestWriteLock;

    UInt64        _reserved1024;

    static void breakUpRequestExecute(void * parameter, void * target);

    static void deblockRequestExecute(void * parameter, void * target);

    /*
     * This is the completion routine for the broken up breaker sub-requests.
     * It verifies the success of the just-completed stage,  transitions to
     * the next stage, then builds and issues a transfer for the next stage.
     */

    static void breakUpRequestCompletion(void *   target,
                                         void *   parameter,
                                         IOReturn status,
                                         UInt64   actualByteCount);

    /*
     * This is the completion routine for the aligned deblocker sub-requests.
     * It verifies the success of the just-completed stage,  transitions to
     * the next stage, then builds and issues a transfer for the next stage.
     */

    static void deblockRequestCompletion(void *   target,
                                         void *   parameter,
                                         IOReturn status,
                                         UInt64   actualByteCount);

    /*
     * This is the completion routine for the prepared request.  It updates
     * the driver's statistics, performs some clean up work, then calls the
     * original request's completion routine.
     */

    static void prepareRequestCompletion(void *   target,
                                         void *   parameter,
                                         IOReturn status,
                                         UInt64   actualByteCount);

#ifdef __x86_64__
    virtual void schedulePoller() __attribute__ ((deprecated));

    virtual void unschedulePoller() __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*
     * This method is the power event handler for restarts and shutdowns.
     */

    static IOReturn handlePowerEvent(void *      target,
                                     void *      parameter,
                                     UInt32      messageType,
                                     IOService * provider,
                                     void *      messageArgument,
                                     vm_size_t   messageArgumentSize);

protected:

    /* Device info: */

    /*!
     * @var _removable
     * True if the media is removable; False if it is fixed (not removable).
     */
    bool		_removable;

    /*!
     * @var _ejectable
     * True if the media is ejectable under software control.
     */
    bool		_ejectable;		/* software-ejectable */

    UInt16		_reserved1104;

    UInt32		_openAssertions;

    /* Media info and states: */

    /*!
     * @var _mediaObject
     * A pointer to the media object we have instantiated (if any).
     */
    IOMedia *		_mediaObject;

    /*!
     * @var _mediaType
     * Type of the media (can be used to differentiate between the
     * different types of CD media, DVD media, etc).
     */
    UInt32		_mediaType;

    bool		_solidState;

    /*!
     * @var _writeProtected
     * True if the media is write-protected; False if not.
     */
    bool		_writeProtected;

    UInt16		_reserved1264;
    UInt64		_reserved1280;

    /*!
     * @var _mediaBlockSize
     * The block size of the media, in bytes.
     */
    UInt64		_mediaBlockSize;

    /*!
     * @var _maxBlockNumber
     * The maximum allowable block number for the media, zero-based.
     */
    UInt64		_maxBlockNumber;

    /*!
     * @var _maxReadByteTransfer
     * The maximum byte transfer allowed for read operations.
     */
    UInt64		_maxReadByteTransfer;

    /*!
     * @var _maxWriteByteTransfer
     * The maximum byte transfer allowed for write operations.
     */
    UInt64		_maxWriteByteTransfer;

    /*!
     * @function acceptNewMedia
     * @abstract
     * React to new media insertion.
     * @discussion
     * This method logs the media block size and block count, then calls
     * instantiateMediaObject to get a media object instantiated. The
     * media object is then attached above us and registered.
     * 
     * This method can be overridden to control what happens when new media
     * is inserted. The default implementation deals with one IOMedia object.
     */
    virtual IOReturn	acceptNewMedia(void);
    
#ifdef __x86_64__
    virtual UInt64	constrainByteCount(UInt64 requestedCount,bool isWrite) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function decommissionMedia
     * @abstract
     * Decommission an existing piece of media that has gone away.
     * @discussion
     * This method wraps a call to terminate, to tear down the stack and
     * the IOMedia object for the media. If "forcible" is true, the media
     * object will be forgotten, and initMediaState will be called. A
     * forcible decommission would occur when an unrecoverable error
     * happens during tear-down (e.g. perhaps a client is still open), but
     * we must still forget about the media.
     * @param forcible
     * True to force forgetting of the media object even if terminate reports
     * that there was an active client.
     */
    virtual IOReturn	decommissionMedia(bool forcible);

    /*!
     * @function instantiateDesiredMediaObject
     * @abstract
     * Create an IOMedia object for media.
     * @discussion
     * This method creates the exact type of IOMedia object desired. It is called by
     * instantiateMediaObject. A subclass may override this one-line method to change
     * the type of media object actually instantiated.
     */
    virtual IOMedia *	instantiateDesiredMediaObject(void);

    /*!
     * @function instantiateMediaObject
     * @abstract
     * Create an IOMedia object for media.
     * @discussion
     * This method creates an IOMedia object from the supplied parameters. It is a
     * convenience method to wrap the handful of steps to do the job.
     * @param base
     * Byte number of beginning of active data area of the media. Usually zero.
     * @param byteSize
     * Size of the data area of the media, in bytes.
     * @param blockSize
     * Block size of the media, in bytes.
     * @param mediaName
     * Name of the IOMedia object.
     * @result
     * A pointer to the created IOMedia object, or a null on error.
     */
    virtual IOMedia *	instantiateMediaObject(UInt64 base,UInt64 byteSize,
                                            UInt32 blockSize,char *mediaName);

    /*!
     * @function recordMediaParameters
     * @abstract
     * Obtain media-related parameters on media insertion.
     * @discussion
     * This method obtains media-related parameters via calls to the
     * Transport Driver's reportBlockSize, reportMaxValidBlock,
     * and reportWriteProtection methods.
     */
    virtual IOReturn	recordMediaParameters(void);

    /*!
     * @function rejectMedia
     * @abstract
     * Reject new media.
     * @discussion
     * This method will be called if validateNewMedia returns False (thus rejecting
     * the new media. A vendor may choose to override this method to control behavior
     * when media is rejected.
     * 
     * The default implementation simply calls ejectMedia.
     */
    virtual void	rejectMedia(void);	/* default ejects */
    
    /*!
     * @function validateNewMedia
     * @abstract
     * Verify that new media is acceptable.
     * @discussion
     * This method will be called whenever new media is detected. Return true to accept
     * the media, or false to reject it (and call rejectMedia). Vendors might override
     * this method to handle password-protection for new media.
     * 
     * The default implementation always returns True, indicating media is accepted.
     */
    virtual bool	validateNewMedia(void);

    /* --- Internally used methods. --- */

    /*
     * @group
     * Internally Used Methods
     * @discussion
     * These methods are used internally, and will not generally be modified.
     */
    
    /*!
     * @function checkForMedia
     * @abstract
     * Check if media has newly arrived or disappeared.
     * @discussion
     * This method does most of the work in polling for media, first
     * calling the block storage device's reportMediaState method. If
     * reportMediaState reports no change in the media state, kIOReturnSuccess
     * is returned. If the media state has indeed changed, a call is made to
     * mediaStateHasChanged to act on the event.
     */
    virtual IOReturn	checkForMedia(void);

    /*!
     * @function getDeviceTypeName
     * @abstract
     * Return the desired device name.
     * @discussion
     * This method returns a string, used to compare the 
     * kIOBlockStorageDeviceTypeKey of our provider. This method is called from
     * probe.
     *  
     * The default implementation of this method returns 
     * kIOBlockStorageDeviceTypeGeneric.
     */
    virtual const char * getDeviceTypeName(void);

    /*!
     * @function initMediaState
     * @abstract
     * Initialize media-related instance variables.
     * @discussion
     * Called when media is not present, this method marks the device state
     * as not having media present, not spun up, and write-enabled.
     */
    virtual void	initMediaState(void);
    
    /*!
     * @function mediaStateHasChanged
     * @abstract
     * React to a new media insertion or a media removal.
     * @discussion
     * This method is called on a media state change, that is, an arrival
     * or removal. If media has just become available, calls are made to
     * recordMediaParameters and acceptNewMedia. If media has just gone
     * away, a call is made to decommissionMedia, with the forcible
     * parameter set to true. The forcible tear-down is needed to enforce
     * the disappearance of media, regardless of interested clients.
     */
    virtual IOReturn	mediaStateHasChanged(IOMediaState state);

    /*
     * @endgroup
     */

protected:

    /*!
     * @function breakUpRequest
     * @discussion
     * The breakUpRequest method checks to see if the incoming request exceeds
     * our transfer constraints, and if so, breaks up the request into smaller
     * sub-requests.
     *
     * This method is part of a sequence of methods invoked for each read/write
     * request.  The first is prepareRequest, which allocates and prepares some
     * context for the transfer; the second is deblockRequest, which aligns the
     * transfer at the media's block boundaries; third is breakUpRequest, which
     * breaks up the transfer into multiple sub-transfers when certain hardware
     * constraints are exceeded; fourth is executeRequest, which implements the
     * actual transfer from the block storage device.
     *
     * This method's implementation is not typically overridden.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param context
     * Additional context information for the data transfer (e.g. block size).
     */

    virtual void breakUpRequest(UInt64                byteStart,
                                IOMemoryDescriptor *  buffer,
                                IOStorageAttributes * attributes,
                                IOStorageCompletion * completion,
                                Context *             context);

    /*!
     * @function prepareRequest
     * @discussion
     * The prepareRequest method allocates and prepares state for the transfer.
     *
     * This method is part of a sequence of methods invoked for each read/write
     * request.  The first is prepareRequest, which allocates and prepares some
     * context for the transfer; the second is deblockRequest, which aligns the
     * transfer at the media's block boundaries; third is breakUpRequest, which
     * breaks up the transfer into multiple sub-transfers when certain hardware
     * constraints are exceeded; fourth is executeRequest, which implements the
     * actual transfer from the block storage device.
     *
     * This method's implementation is not typically overridden.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void prepareRequest(UInt64                byteStart,
                                IOMemoryDescriptor *  buffer,
                                IOStorageAttributes * attributes,
                                IOStorageCompletion * completion);

public:

    /*!
     * @function requestIdle
     * @abstract
     * Request that the device enter an idle state.
     * @discussion
     * Request that the device enter an idle state.  The device will exit this state on the
     * next read or write request, or as it sees necessary.  One example is for a DVD drive
     * to spin down when it enters such an idle state, and spin up on the next read request
     * from the system.
     */
    virtual IOReturn	requestIdle(void);

    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  0);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  1);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  2);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  3);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  4);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  5);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  6);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  7);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  8);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver,  9);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 10);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 11);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 12);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 13);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 14);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 15);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 16);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 17);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 18);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 19);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 20);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 21);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 22);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 23);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 24);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 25);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 26);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 27);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 28);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 29);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 30);
    OSMetaClassDeclareReservedUnused(IOBlockStorageDriver, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOBLOCKSTORAGEDRIVER_H */
                                                                                                                                                                                                                                                                                                                                                                                                         IOCDBlockStorageDevice.h                                                                            0100644 0001750 0001750 00000012213 12567452642 040002  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOCDBlockStorageDevice
 * @abstract
 * This header contains the IOCDBlockStorageDevice class definition.
 */

#ifndef _IOCDBLOCKSTORAGEDEVICE_H
#define _IOCDBLOCKSTORAGEDEVICE_H

#include <IOKit/storage/IOCDTypes.h>

/*!
 * @defined kIOCDBlockStorageDeviceClass
 * @abstract
 * kIOCDBlockStorageDeviceClass is the name of the IOCDBlockStorageDevice class.
 * @discussion
 * kIOCDBlockStorageDeviceClass is the name of the IOCDBlockStorageDevice class.
 */

#define kIOCDBlockStorageDeviceClass "IOCDBlockStorageDevice"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOBlockStorageDevice.h>

/* Property used for matching, so the generic driver gets the nub it wants. */
#define	kIOBlockStorageDeviceTypeCDROM	"CDROM"

/*!
 * @class
 * IOCDBlockStorageDevice : public IOBlockStorageDevice
 * @abstract
 * The IOCDBlockStorageDevice class is a generic CD block storage device
 * abstraction.
 * @discussion
 * This class is the protocol for generic CD functionality, independent of
 * the physical connection protocol (e.g. SCSI, ATA, USB).
 *
 * The APIs are the union of CD (block storage) data APIs and all
 * necessary low-level CD APIs.
 *
 * A subclass implements relay methods that translate our requests into
 * calls to a protocol- and device-specific provider.
 */

class IOCDBlockStorageDevice : public IOBlockStorageDevice {

    OSDeclareAbstractStructors(IOCDBlockStorageDevice)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /* Overrides from IORegistryEntry */
    
    virtual bool	init(OSDictionary * properties);

    /*-----------------------------------------*/
    /* CD APIs                                 */
    /*-----------------------------------------*/

    virtual IOReturn	doAsyncReadCD(IOMemoryDescriptor *buffer,
                    	              UInt32 block,UInt32 nblks,
                    	              CDSectorArea sectorArea,
                    	              CDSectorType sectorType,
                    	              IOStorageCompletion completion) = 0;
    virtual UInt32	getMediaType(void)					= 0;
    virtual IOReturn	readISRC(UInt8 track,CDISRC isrc)			= 0;
    virtual IOReturn	readMCN(CDMCN mcn)					= 0;
    virtual IOReturn	readTOC(IOMemoryDescriptor *buffer) = 0;

    /*-----------------------------------------*/
    /* CD APIs                                 */
    /*-----------------------------------------*/

    virtual IOReturn	getSpeed(UInt16 * kilobytesPerSecond)	= 0;

    virtual IOReturn	setSpeed(UInt16 kilobytesPerSecond)	= 0;

    virtual IOReturn	readTOC(IOMemoryDescriptor *buffer,CDTOCFormat format,
                    	        UInt8 msf,UInt8 trackSessionNumber,
                    	        UInt16 *actualByteCount)	= 0;

    virtual IOReturn	readDiscInfo(IOMemoryDescriptor *buffer,
                    	             UInt16 *actualByteCount)	= 0;

    virtual IOReturn	readTrackInfo(IOMemoryDescriptor *buffer,UInt32 address,
                    	              CDTrackInfoAddressType addressType,
                    	              UInt16 *actualByteCount)	= 0;

    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  0);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  1);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  2);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  3);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  4);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  5);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  6);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  7);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  8);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice,  9);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice, 10);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice, 11);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice, 12);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice, 13);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice, 14);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDevice, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOCDBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                                                                                                                                                                                                                     IOCDBlockStorageDriver.h                                                                            0100644 0001750 0001750 00000020124 12567452642 040036  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * IOCDBlockStorageDriver.h
 *
 * This class implements  CD functionality, independent of
 * the physical connection protocol (e.g. SCSI, ATA, USB).
 *
 * A protocol-specific provider implements the functionality using an appropriate
 * protocol and commands.
 */

#ifndef	_IOCDBLOCKSTORAGEDRIVER_H
#define	_IOCDBLOCKSTORAGEDRIVER_H

#include <IOKit/IOTypes.h>
#include <IOKit/storage/IOCDBlockStorageDevice.h>
#include <IOKit/storage/IOCDTypes.h>
#include <IOKit/storage/IOBlockStorageDriver.h>

/*
 * @defined kIOCDBlockStorageDriverClass
 * @abstract
 * kIOCDBlockStorageDriverClass is the name of the IOCDBlockStorageDriver class.
 * @discussion
 * kIOCDBlockStorageDriverClass is the name of the IOCDBlockStorageDriver class.
 */

#define kIOCDBlockStorageDriverClass "IOCDBlockStorageDriver"

class IOCDBlockStorageDriver : public IOBlockStorageDriver {

    OSDeclareDefaultStructors(IOCDBlockStorageDriver)

public:

    static const UInt64 kBlockSizeCD = 2352;
    static const UInt8  kBlockTypeCD = 0x01;

    /* Overrides of IORegistryEntry */
    
    virtual bool	init(OSDictionary * properties);
    virtual void	free(void);

    /* Overrides of IOBlockStorageDriver: */

    virtual IOReturn	ejectMedia(void);
    virtual void 	executeRequest(UInt64 byteStart,
                	               IOMemoryDescriptor *buffer,
                	               IOStorageAttributes *attributes,
                	               IOStorageCompletion *completion,
                	               Context *context);
    virtual const char * getDeviceTypeName(void);
    virtual IOMedia *	instantiateDesiredMediaObject(void);
    virtual IOMedia *	instantiateMediaObject(UInt64 base,UInt64 byteSize,
                                            UInt32 blockSize,char *mediaName);
    virtual IOReturn	recordMediaParameters(void);
    
    /* End of IOBlockStorageDriver overrides. */

    /*
     * @function getMediaType
     * @abstract
     * Get the current type of media inserted in the CD drive.
     * @discussion
     * Certain I/O operations may not be allowed depending on the type of
     * media currently inserted. For example, one cannot issue write operations
     * if CD-ROM media is inserted.
     * @result
     * See the kCDMediaType constants in IOCDTypes.h.
     */
    virtual UInt32	getMediaType(void);

    /* -------------------------------------------------*/
    /* APIs implemented here, exported by IOCDMedia:    */
    /* -------------------------------------------------*/

    virtual CDTOC *	getTOC(void);
    virtual void	readCD(IOService *client,
                	       UInt64 byteStart,
                	       IOMemoryDescriptor *buffer,
                	       CDSectorArea sectorArea,
                	       CDSectorType sectorType,
                	       IOStorageAttributes *attributes,
                	       IOStorageCompletion *completion);
    virtual IOReturn	readISRC(UInt8 track,CDISRC isrc);
    virtual IOReturn	readMCN(CDMCN mcn);

    /* end of IOCDMedia APIs */
    
    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of IOService -- IOCDBlockStorageDevice.  
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IOCDBlockStorageDevice * getProvider() const;

protected:
        
    /* Overrides of IOBlockStorageDriver behavior. */

    /* When CD media is inserted, we want to create multiple nubs for the data and
     * audio tracks, for sessions, and the entire media. We override the methods
     * that manage nubs.
     */
    virtual IOReturn	acceptNewMedia(void);
    virtual IOReturn	decommissionMedia(bool forcible);

    /* End of IOBlockStorageDriver overrides. */

    /* Internally used methods: */

    using	IOBlockStorageDriver::getMediaBlockSize;

    virtual IOReturn	cacheTocInfo(void);
    virtual UInt64	getMediaBlockSize(CDSectorArea area,CDSectorType type);
    virtual void	prepareRequest(UInt64 byteStart,
                	               IOMemoryDescriptor *buffer,
                	               CDSectorArea sectorArea,
                	               CDSectorType sectorType,
                	               IOStorageAttributes *attributes,
                	               IOStorageCompletion *completion);

    /* ------- */

    struct ExpansionData
    {
        UInt32 minBlockNumberAudio;
        UInt32 maxBlockNumberAudio;
    };
    ExpansionData * _expansionData;

    #define _minBlockNumberAudio \
                IOCDBlockStorageDriver::_expansionData->minBlockNumberAudio
    #define _maxBlockNumberAudio \
                IOCDBlockStorageDriver::_expansionData->maxBlockNumberAudio

    UInt32				_reserved0032;

    /* We keep the TOC here because we'll always need it, so what the heck.
     *
     * There are possible "point" track entries for 0xa0..a2, 0xb0..b4, and 0xc0..0xc1.
     * Tracks need not start at 1, as long as they're between 1 and 99, and have contiguous
     * numbers.
     */

    CDTOC *				_toc;
    UInt32				_tocSize;

    /* ------- */

    IOReturn	reportDiscInfo(CDDiscInfo *discInfo);
    IOReturn	reportTrackInfo(UInt16 track,CDTrackInfo *trackInfo);

public:

    virtual IOReturn	getSpeed(UInt16 * kilobytesPerSecond);

    virtual IOReturn	setSpeed(UInt16 kilobytesPerSecond);

    virtual IOReturn	readTOC(IOMemoryDescriptor *buffer,CDTOCFormat format,
                    	        UInt8 formatAsTime,UInt8 trackOrSessionNumber,
                    	        UInt16 *actualByteCount);

    virtual IOReturn	readDiscInfo(IOMemoryDescriptor *buffer,
                    	             UInt16 *actualByteCount);

    virtual IOReturn	readTrackInfo(IOMemoryDescriptor *buffer,UInt32 address,
                    	              CDTrackInfoAddressType addressType,
                    	              UInt16 *actualByteCount);

    virtual void	writeCD(IOService *client,
                	        UInt64 byteStart,
                	        IOMemoryDescriptor *buffer,
                	        CDSectorArea sectorArea,
                	        CDSectorType sectorType,
                	        IOStorageAttributes *attributes,
                	        IOStorageCompletion *completion);

    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  0);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  1);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  2);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  3);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  4);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  5);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  6);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  7);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  8);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver,  9);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver, 10);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver, 11);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver, 12);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver, 13);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver, 14);
    OSMetaClassDeclareReservedUnused(IOCDBlockStorageDriver, 15);
};
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                            IOCDMedia.h                                                                                         0100644 0001750 0001750 00000045211 12567452642 035326  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOCDMedia
 * @abstract
 * This header contains the IOCDMedia class definition.
 */

#ifndef _IOCDMEDIA_H
#define _IOCDMEDIA_H

/*!
 * @defined kIOCDMediaClass
 * @abstract
 * kIOCDMediaClass is the name of the IOCDMedia class.
 * @discussion
 * kIOCDMediaClass is the name of the IOCDMedia class.
 */

#define kIOCDMediaClass "IOCDMedia"

/*!
 * @defined kIOCDMediaTOCKey
 * @abstract
 * kIOCDMediaTOCKey is a property of IOCDMedia objects.  It has an OSData value
 * and a CDTOC structure.
 * @discussion
 * The kIOCDMediaTOCKey property contains the CD's full table of contents,
 * formatted as a CDTOC structure.  The CDTOC structure is same as what is
 * returned by a READ TOC command, format 0x02.  All fields in the TOC are
 * guaranteed to be binary-encoded (no BCD-encoded numbers are ever passed).
 */

#define kIOCDMediaTOCKey "TOC"

/*!
 * @defined kIOCDMediaTypeKey
 * @abstract
 * kIOCDMediaTypeKey is a property of IOCDMedia objects.  It has an OSString
 * value.
 * @discussion
 * The kIOCDMediaTypeKey property identifies the CD media type (CD-ROM, CD-R,
 * CD-RW, etc).  See the kIOCDMediaType contants for possible values.
 */

#define kIOCDMediaTypeKey "Type"

/*!
 * @defined kIOCDMediaTypeROM
 * The kIOCDMediaTypeKey constant for CD-ROM media (inclusive of the CD-I,
 * CD-ROM XA, and CD Audio standards, and mixed mode combinations thereof).
 */

#define kIOCDMediaTypeROM "CD-ROM"

/*!
 * @defined kIOCDMediaTypeR
 * The kIOCDMediaTypeKey constant for CD Recordable (CD-R) media.
 */

#define kIOCDMediaTypeR "CD-R"

/*!
 * @defined kIOCDMediaTypeRW
 * The kIOCDMediaTypeKey constant for CD ReWritable (CD-RW) media.
 */

#define kIOCDMediaTypeRW "CD-RW"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOCDBlockStorageDriver.h>
#include <IOKit/storage/IOMedia.h>

/*!
 * @class IOCDMedia
 * @abstract
 * The IOCDMedia class is a random-access disk device abstraction for CDs.
 * @discussion
 * The IOCDMedia class is a random-access disk device abstraction for CDs. It
 * extends the IOMedia class by implementing special CD APIs, such as readCD,
 * and publishing the TOC as a property of the IOCDMedia object.
 */

class IOCDMedia : public IOMedia
{
    OSDeclareDefaultStructors(IOCDMedia)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    using IOStorage::read;
    using IOStorage::write;

    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of IOService -- IOCDBlockStorageDriver.  
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IOCDBlockStorageDriver * getProvider() const;

    /*
     * Compare the properties in the supplied table to this object's properties.
     */

    virtual bool matchPropertyTable(OSDictionary * table, SInt32 * score);

    /*!
     * @function read
     * @discussion
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, asynchronously.   When the read completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the read.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion);

    /*
     * @function write
     * @discussion
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, asynchronously.   When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion);

    /*!
     * @function readCD
     * @discussion
     * Read data from the CD media object at the specified byte offset into the
     * specified buffer, asynchronously.  Special areas of the CD sector can be
     * read via this method, such as the header and subchannel data.   When the
     * read completes, the caller will be notified via the specified completion
     * action.
     *
     * The buffer will be retained for the duration of the read.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer (see sectorArea parameter).
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param sectorArea
     * Sector area(s) to read.  The sum of each area's size defines the natural
     * block size of the media for the call.  This should be taken into account
     * when computing the address of byteStart.  See IOCDTypes.h.
     * @param sectorType
     * Sector type that is expected.  The data transfer is terminated as soon as
     * data is encountered that does not match the expected type.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void readCD(IOService *           client,
                        UInt64                byteStart,
                        IOMemoryDescriptor *  buffer,
                        CDSectorArea          sectorArea,
                        CDSectorType          sectorType,
                        IOStorageAttributes * attributes,
                        IOStorageCompletion * completion);

    /*!
     * @function readCD
     * @discussion
     * Read data from the CD media object at the specified byte offset into the
     * specified buffer, synchronously.   Special areas of the CD sector can be
     * read via this method, such as the header and subchannel data.   When the
     * read completes, this method will return to the caller.   The actual byte
     * count field is optional.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer (see sectorArea parameter).
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param sectorArea
     * Sector area(s) to read.  The sum of each area's size defines the natural
     * block size of the media for the call.  This should be taken into account
     * when computing the address of byteStart.  See IOCDTypes.h.
     * @param sectorType
     * Sector type that is expected.  The data transfer is terminated as soon as
     * data is encountered that does not match the expected type.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readCD(IOService *           client,
                            UInt64                byteStart,
                            IOMemoryDescriptor *  buffer,
                            CDSectorArea          sectorArea,
                            CDSectorType          sectorType,
                            IOStorageAttributes * attributes      = 0,
                            UInt64 *              actualByteCount = 0);

    /*!
     * @function readISRC
     * @discussion
     * Read the International Standard Recording Code for the specified track.
     * @param track
     * Track number from which to read the ISRC.
     * @param isrc
     * Buffer for the ISRC data.  Buffer contents will be zero-terminated.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn readISRC(UInt8 track, CDISRC isrc);
    
    /*!
     * @function readMCN
     * @discussion
     * Read the Media Catalog Number (also known as the Universal Product Code).
     * @param mcn
     * Buffer for the MCN data.  Buffer contents will be zero-terminated.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn readMCN(CDMCN mcn);

    /*!
     * @function getTOC
     * @discussion
     * Get the full Table Of Contents.
     *
     * All CDTOC fields passed across I/O Kit APIs are guaranteed to be
     * binary-encoded (no BCD-encoded numbers are ever passed).
     * @result
     * Returns a pointer to the TOC buffer (do not deallocate).
     */
     
    virtual CDTOC * getTOC();

    /*!
     * @function getSpeed
     * @discussion
     * Get the current speed used for data transfers.
     * @param kilobytesPerSecond
     * Returns the current speed used for data transfers, in kB/s.
     *
     * kCDSpeedMin specifies the minimum speed for all CD media (1X).
     * kCDSpeedMax specifies the maximum speed supported in hardware.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn getSpeed(UInt16 * kilobytesPerSecond);

    /*!
     * @function setSpeed
     * @discussion
     * Set the speed to be used for data transfers.
     * @param kilobytesPerSecond
     * Speed to be used for data transfers, in kB/s.
     *
     * kCDSpeedMin specifies the minimum speed for all CD media (1X).
     * kCDSpeedMax specifies the maximum speed supported in hardware.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setSpeed(UInt16 kilobytesPerSecond);

    /*!
     * @function readTOC
     * @discussion
     * Issue an MMC READ TOC/PMA/ATIP command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param format
     * As documented by MMC.
     * @param formatAsTime
     * As documented by MMC.
     * @param trackOrSessionNumber
     * As documented by MMC.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readTOC(IOMemoryDescriptor * buffer,
                             CDTOCFormat          format,
                             UInt8                formatAsTime,
                             UInt8                trackOrSessionNumber,
                             UInt16 *             actualByteCount);

    /*!
     * @function readDiscInfo
     * @discussion
     * Issue an MMC READ DISC INFORMATION command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readDiscInfo(IOMemoryDescriptor * buffer,
                                  UInt16 *             actualByteCount);

    /*!
     * @function readTrackInfo
     * @discussion
     * Issue an MMC READ TRACK INFORMATION command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param address
     * As documented by MMC.
     * @param addressType
     * As documented by MMC.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readTrackInfo(IOMemoryDescriptor *   buffer,
                                   UInt32                 address,
                                   CDTrackInfoAddressType addressType,
                                   UInt16 *               actualByteCount);

    /*
     * @function writeCD
     * @discussion
     * Write data into the CD media object at the specified byte offset from the
     * specified buffer, asynchronously.    When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer (see sectorArea parameter).
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param sectorArea
     * Sector area(s) to write.  The sum of each area's size defines the natural
     * block size of the media for the call.   This should be taken into account
     * when computing the address of byteStart.  See IOCDTypes.h.
     * @param sectorType
     * Sector type that is expected.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void writeCD(IOService *           client,
                         UInt64                byteStart,
                         IOMemoryDescriptor *  buffer,
                         CDSectorArea          sectorArea,
                         CDSectorType          sectorType,
                         IOStorageAttributes * attributes,
                         IOStorageCompletion * completion);

    /*
     * @function writeCD
     * @discussion
     * Write data into the CD media object at the specified byte offset from the
     * specified buffer, synchronously.    When the write completes, this method
     * will return to the caller.  The actual byte count field is optional.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer (see sectorArea parameter).
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param sectorArea
     * Sector area(s) to write.  The sum of each area's size defines the natural
     * block size of the media for the call.   This should be taken into account
     * when computing the address of byteStart.  See IOCDTypes.h.
     * @param sectorType
     * Sector type that is expected.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn writeCD(IOService *           client,
                             UInt64                byteStart,
                             IOMemoryDescriptor *  buffer,
                             CDSectorArea          sectorArea,
                             CDSectorType          sectorType,
                             IOStorageAttributes * attributes      = 0,
                             UInt64 *              actualByteCount = 0);

    OSMetaClassDeclareReservedUnused(IOCDMedia,  0);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  1);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  2);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  3);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  4);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  5);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  6);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  7);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  8);
    OSMetaClassDeclareReservedUnused(IOCDMedia,  9);
    OSMetaClassDeclareReservedUnused(IOCDMedia, 10);
    OSMetaClassDeclareReservedUnused(IOCDMedia, 11);
    OSMetaClassDeclareReservedUnused(IOCDMedia, 12);
    OSMetaClassDeclareReservedUnused(IOCDMedia, 13);
    OSMetaClassDeclareReservedUnused(IOCDMedia, 14);
    OSMetaClassDeclareReservedUnused(IOCDMedia, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOCDMEDIA_H */
                                                                                                                                                                                                                                                                                                                                                                                       IOCDMediaBSDClient.h                                                                                0100644 0001750 0001750 00000013564 12567452642 037024  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOCDMEDIABSDCLIENT_H
#define _IOCDMEDIABSDCLIENT_H

#include <sys/ioctl.h>

#include <IOKit/storage/IOCDTypes.h>

/*
 * Definitions
 *
 * ioctl                        description
 * ---------------------------- ------------------------------------------------
 * DKIOCCDREAD                  see IOCDMedia::readCD()           in IOCDMedia.h
 * DKIOCCDREADTOC               see IOCDMedia::readTOC()          in IOCDMedia.h
 *
 * DKIOCCDREADDISCINFO          see IOCDMedia::readDiscInfo()     in IOCDMedia.h
 * DKIOCCDREADTRACKINFO         see IOCDMedia::readTrackInfo()    in IOCDMedia.h
 *
 * DKIOCCDREADISRC              see IOCDMedia::readISRC()         in IOCDMedia.h
 * DKIOCCDREADMCN               see IOCDMedia::readMCN()          in IOCDMedia.h
 *
 * DKIOCCDGETSPEED              see IOCDMedia::getSpeed()         in IOCDMedia.h
 * DKIOCCDSETSPEED              see IOCDMedia::setSpeed()         in IOCDMedia.h
 *
 *         in /System/Library/Frameworks/Kernel.framework/Headers/IOKit/storage/
 */

typedef struct
{
    uint64_t offset;

    uint8_t  sectorArea;
    uint8_t  sectorType;

#ifdef __LP64__
    uint8_t  reserved0080[10];                     /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0080[6];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint32_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_t;

typedef struct
{
    CDISRC   isrc;
    uint8_t  track;

    uint8_t  reserved0112[2];                      /* reserved, clear to zero */
} dk_cd_read_isrc_t;

typedef struct
{
    CDMCN    mcn;

    uint8_t  reserved0112[2];                      /* reserved, clear to zero */
} dk_cd_read_mcn_t;

typedef struct
{
    uint8_t  format;
    uint8_t  formatAsTime;

    uint8_t  reserved0016[5];                      /* reserved, clear to zero */

    union
    {
        uint8_t session;
        uint8_t track;
    } address;

#ifdef __LP64__
    uint8_t  reserved0064[6];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0064[2];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_toc_t;

typedef struct
{
#ifdef __LP64__
    uint8_t  reserved0000[14];                     /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0000[10];                     /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_disc_info_t;

typedef struct
{
    uint8_t  reserved0000[4];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  addressType;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_cd_read_track_info_t;

#define DKIOCCDREAD          _IOWR('d', 96, dk_cd_read_t)

#define DKIOCCDREADISRC      _IOWR('d', 97, dk_cd_read_isrc_t)
#define DKIOCCDREADMCN       _IOWR('d', 98, dk_cd_read_mcn_t)

#define DKIOCCDGETSPEED      _IOR('d', 99, uint16_t)
#define DKIOCCDSETSPEED      _IOW('d', 99, uint16_t)

#define DKIOCCDREADTOC       _IOWR('d', 100, dk_cd_read_toc_t)

#define DKIOCCDREADDISCINFO  _IOWR('d', 101, dk_cd_read_disc_info_t)
#define DKIOCCDREADTRACKINFO _IOWR('d', 102, dk_cd_read_track_info_t)

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOCDMedia.h>
#include <IOKit/storage/IOMediaBSDClient.h>

/*
 * Class
 */

class IOCDMediaBSDClient : public IOMediaBSDClient
{
    OSDeclareDefaultStructors(IOCDMediaBSDClient)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /*
     * Obtain this object's provider.  We override the superclass's method
     * to return a more specific subclass of IOService -- IOCDMedia.  This
     * method serves simply as a convenience to subclass developers.
     */

    virtual IOCDMedia * getProvider() const;

    /*
     * Process a CD-specific ioctl.
     */

    virtual int ioctl(dev_t dev, u_long cmd, caddr_t data, int flags, proc_t proc);

    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 0);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 1);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 2);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 3);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 4);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 5);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 6);
    OSMetaClassDeclareReservedUnused(IOCDMediaBSDClient, 7);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOCDMEDIABSDCLIENT_H */
                                                                                                                                            IOCDPartitionScheme.h                                                                               0100644 0001750 0001750 00000017725 12567452642 037416  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * @header IOCDPartitionScheme
 * @abstract
 * This header contains the IOCDPartitionScheme class definition.
 */

#ifndef _IOCDPARTITIONSCHEME_H
#define _IOCDPARTITIONSCHEME_H

#include <IOKit/storage/IOCDTypes.h>

/*
 * @defined kIOCDPartitionSchemeClass
 * @abstract
 * kIOCDPartitionSchemeClass is the name of the IOCDPartitionScheme class.
 * @discussion
 * kIOCDPartitionSchemeClass is the name of the IOCDPartitionScheme class.
 */

#define kIOCDPartitionSchemeClass "IOCDPartitionScheme"

/*
 * @defined kIOMediaSessionIDKey
 * @abstract
 * kIOMediaSessionIDKey is property of IOMedia objects.  It has an OSNumber
 * value.
 * @discussion
 * The kIOMediaSessionIDKey property is placed into each IOMedia instance
 * created by the CD partition scheme.  It identifies the session number
 * the track was recorded on.
 */

#define kIOMediaSessionIDKey "Session ID"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOCDMedia.h>
#include <IOKit/storage/IOPartitionScheme.h>

/*
 * Class
 */

class IOCDPartitionScheme : public IOPartitionScheme
{
    OSDeclareDefaultStructors(IOCDPartitionScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    OSSet * _partitions;    /* (set of media objects representing partitions) */

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free(void);

    /*
     * Scan the provider media for CD partitions (in TOC).  Returns the set
     * of media objects representing each of the partitions (the retain for
     * the set is passed to the caller), or null should no CD partitions be
     * found.  The default probe score can be adjusted up or down, based on
     * the confidence of the scan.
     */

    virtual OSSet * scan(SInt32 * score);

    /*
     * Ask whether the given partition appears to be corrupt.  A partition that
     * is corrupt will cause the failure of the CD partition scheme altogether.
     */

    virtual bool isPartitionCorrupt( CDTOCDescriptor * partition,
                                     UInt64            partitionSize,
                                     UInt32            partitionBlockSize,
                                     CDSectorType      partitionBlockType,
                                     CDTOC *           toc );

    /*
     * Ask whether the given partition appears to be invalid.  A partition that
     * is invalid will cause it to be skipped in the scan, but will not cause a
     * failure of the CD partition scheme.
     */

    virtual bool isPartitionInvalid( CDTOCDescriptor * partition,
                                     UInt64            partitionSize,
                                     UInt32            partitionBlockSize,
                                     CDSectorType      partitionBlockType,
                                     CDTOC *           toc );

    /*
     * Instantiate a new media object to represent the given partition.
     */

    virtual IOMedia * instantiateMediaObject(
                                           CDTOCDescriptor * partition,
                                           UInt64            partitionSize,
                                           UInt32            partitionBlockSize,
                                           CDSectorType      partitionBlockType,
                                           CDTOC *           toc );

    /*
     * Allocate a new media object (called from instantiateMediaObject).
     */

    virtual IOMedia * instantiateDesiredMediaObject(
                                           CDTOCDescriptor * partition,
                                           UInt64            partitionSize,
                                           UInt32            partitionBlockSize,
                                           CDSectorType      partitionBlockType,
                                           CDTOC *           toc );

public:

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*
     * Scan the provider media for CD partitions.
     */

    virtual IOService * probe(IOService * provider, SInt32 * score);

    /*
     * Determine whether the provider media contains CD partitions.
     */

    virtual bool start(IOService * provider);

    /*
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, asynchronously.   When the read completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the read.
     *
     * For the CD partition scheme, we convert the read from a partition
     * object into the appropriate readCD command to our provider media.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion);

    /*
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, asynchronously.   When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     *
     * For the CD partition scheme, we convert the write from a partition
     * object into the appropriate writeCD command to our provider media.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion);

    /*
     * Obtain this object's provider.  We override the superclass's method
     * to return a more specific subclass of OSObject -- IOCDMedia.   This
     * method serves simply as a convenience to subclass developers.
     */

    virtual IOCDMedia * getProvider() const;

    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  0);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  1);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  2);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  3);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  4);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  5);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  6);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  7);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  8);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme,  9);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme, 10);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme, 11);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme, 12);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme, 13);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme, 14);
    OSMetaClassDeclareReservedUnused(IOCDPartitionScheme, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOCDPARTITIONSCHEME_H */
                                           IOCDTypes.h                                                                                         0100644 0001750 0001750 00000030010 12567452642 035402  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef	_IOCDTYPES_H
#define	_IOCDTYPES_H

#include <IOKit/IOTypes.h>
#include <libkern/OSByteOrder.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/*
 * Minutes, Seconds, Frames (M:S:F)
 *
 * All M:S:F values passed across I/O Kit APIs are guaranteed to be
 * binary-encoded numbers (no BCD-encoded numbers are ever passed).
 */

typedef struct
{
    UInt8 minute;
    UInt8 second;
    UInt8 frame;
} CDMSF;

/*
 * Media Catalogue Numbers (MCN), International Standard Recording Codes (ISRC)
 *
 * All MCN and ISRC values passed across I/O Kit APIs are guaranteed
 * to have a zero-terminating byte, for convenient use as C strings.
 */

#define kCDMCNMaxLength  13
#define kCDISRCMaxLength 12

typedef char CDMCN [kCDMCNMaxLength  + 1];
typedef char CDISRC[kCDISRCMaxLength + 1];

/*
 * Audio Status
 *
 * All CDAudioStatus fields passed across I/O Kit APIs are guaranteed to
 * be binary-encoded numbers (no BCD-encoded numbers are ever passed).
 */

#define kCDAudioStatusUnsupported 0x00
#define kCDAudioStatusActive      0x11
#define kCDAudioStatusPaused      0x12
#define kCDAudioStatusSuccess     0x13
#define kCDAudioStatusFailure     0x14
#define kCDAudioStatusNone        0x15

typedef struct
{
    UInt8 status;
    struct
    {
        CDMSF time;
        struct
        {
            UInt8 index;
            UInt8 number;
            CDMSF time;
        } track;
    } position;
} CDAudioStatus;

/*
 * Table Of Contents
 *
 * All CDTOC fields passed across I/O Kit APIs are guaranteed to be
 * binary-encoded numbers (no BCD-encoded numbers are ever passed).
 */

typedef struct
{
    UInt8 session;
#ifdef __LITTLE_ENDIAN__
    UInt8 control:4, adr:4;
#else /* !__LITTLE_ENDIAN__ */
    UInt8 adr:4, control:4;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8 tno;
    UInt8 point;
    CDMSF address;
    UInt8 zero;
    CDMSF p;
} CDTOCDescriptor;

typedef struct
{
    UInt16          length;
    UInt8           sessionFirst;
    UInt8           sessionLast;
    CDTOCDescriptor descriptors[0];
} CDTOC;

/*
 * Table Of Contents Descriptor Count Convenience Function
 */

static inline UInt32 CDTOCGetDescriptorCount(CDTOC * toc)
{
    UInt32 tocSize = OSSwapBigToHostInt16(toc->length) + (UInt32) sizeof(toc->length);

    return (tocSize < (UInt32) sizeof(CDTOC)) ? 0 : 
           (tocSize - (UInt32) sizeof(CDTOC)) / (UInt32) sizeof(CDTOCDescriptor);
}

/*
 * M:S:F To LBA Convenience Function
 */

static inline UInt32 CDConvertMSFToLBA(CDMSF msf)
{
    return (((msf.minute * 60U) + msf.second) * 75U) + msf.frame - 150U;
}

/*
 * M:S:F To Clipped LBA Convenience Function
 */

static inline UInt32 CDConvertMSFToClippedLBA(CDMSF msf)
{
    return (msf.minute == 0 && msf.second <= 1) ? 0 : CDConvertMSFToLBA(msf);
}

/*
 * LBA To M:S:F Convenience Function
 */

static inline CDMSF CDConvertLBAToMSF(UInt32 lba)
{
    CDMSF msf;

    lba += 150;
    msf.minute = (lba / (75 * 60));
    msf.second = (lba % (75 * 60)) / 75;
    msf.frame  = (lba % (75     ));
    
    return msf;
}

/*
 * Track Number To M:S:F Convenience Function
 *
 * The CDTOC structure is assumed to be complete, that is, none of
 * the descriptors are missing or clipped due to an insufficiently
 * sized buffer holding the CDTOC contents.
 */

static inline CDMSF CDConvertTrackNumberToMSF(UInt8 track, CDTOC * toc)
{
    UInt32 count = CDTOCGetDescriptorCount(toc);
    UInt32 i;
    CDMSF  msf   = { 0xFF, 0xFF, 0xFF };

    for (i = 0; i < count; i++)
    {
        if (toc->descriptors[i].point == track && toc->descriptors[i].adr == 1)
        {
            msf = toc->descriptors[i].p;
            break;
        }
    }

    return msf;
}

/*
 * Sector Areas, Sector Types
 *
 * Bytes Per Type      CDDA       Mode1      Mode2   Mode2Form1 Mode2Form2
 *       Per Area  +----------+----------+----------+----------+----------+
 * Sync            | 0        | 12       | 12       | 12       | 12       |
 * Header          | 0        | 4        | 4        | 4        | 4        |
 * SubHeader       | 0        | 0        | 0        | 8        | 8        |
 * User            | 2352     | 2048     | 2336     | 2048     | 2328     |
 * Auxiliary       | 0        | 288      | 0        | 280      | 0        |
 * ErrorFlags      | 294      | 294      | 294      | 294      | 294      |
 * SubChannel      | 96       | 96       | 96       | 96       | 96       |
 * SubChannelQ     | 16       | 16       | 16       | 16       | 16       |
 *                 +----------+----------+----------+----------+----------+
 */

typedef enum
{
    kCDSectorAreaSync        = 0x80,
    kCDSectorAreaHeader      = 0x20,
    kCDSectorAreaSubHeader   = 0x40,
    kCDSectorAreaUser        = 0x10,
    kCDSectorAreaAuxiliary   = 0x08,
    kCDSectorAreaErrorFlags  = 0x02,
    kCDSectorAreaSubChannel  = 0x01,
    kCDSectorAreaSubChannelQ = 0x04
} CDSectorArea;

typedef enum
{
    kCDSectorTypeUnknown     = 0x00,
    kCDSectorTypeCDDA        = 0x01,
    kCDSectorTypeMode1       = 0x02,
    kCDSectorTypeMode2       = 0x03,
    kCDSectorTypeMode2Form1  = 0x04,
    kCDSectorTypeMode2Form2  = 0x05,
    kCDSectorTypeCount       = 0x06
} CDSectorType;

typedef enum
{
    kCDSectorSizeCDDA        = 2352,
    kCDSectorSizeMode1       = 2048,
    kCDSectorSizeMode2       = 2336,
    kCDSectorSizeMode2Form1  = 2048,
    kCDSectorSizeMode2Form2  = 2328,
    kCDSectorSizeWhole       = 2352
} CDSectorSize;

/*
 * Media Types
 */

enum
{
    kCDMediaTypeUnknown      = 0x0100,
    kCDMediaTypeROM          = 0x0102, /* CD-ROM */
    kCDMediaTypeR            = 0x0104, /* CD-R   */
    kCDMediaTypeRW           = 0x0105, /* CD-RW  */

    kCDMediaTypeMin          = 0x0100,
    kCDMediaTypeMax          = 0x01FF
};

typedef UInt32 CDMediaType;

/*
 * Media Speed (kB/s)
 */

#define kCDSpeedMin 0x00B0
#define kCDSpeedMax 0xFFFF

/*
 * MMC Formats
 */

// Read Table Of Contents Format Types
typedef UInt8 CDTOCFormat;
enum
{
    kCDTOCFormatTOC  = 0x02, // CDTOC
    kCDTOCFormatPMA  = 0x03, // CDPMA
    kCDTOCFormatATIP = 0x04, // CDATIP
    kCDTOCFormatTEXT = 0x05  // CDTEXT
};

// Read Table Of Contents Format 0x03
struct CDPMADescriptor
{
    UInt8 reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8 control:4, adr:4;
#else /* !__LITTLE_ENDIAN__ */
    UInt8 adr:4, control:4;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8 tno;
    UInt8 point;
    CDMSF address;
    UInt8 zero;
    CDMSF p;
};
typedef struct CDPMADescriptor CDPMADescriptor;

struct CDPMA
{
    UInt16          dataLength;
    UInt8           reserved;
    UInt8           reserved2;
    CDPMADescriptor descriptors[0];
};
typedef struct CDPMA CDPMA;

// Read Table Of Contents Format 0x04
struct CDATIP
{
    UInt16 dataLength;
    UInt8  reserved[2];
#ifdef __LITTLE_ENDIAN__
    UInt8  referenceSpeed:3;
    UInt8  reserved3:1;
    UInt8  indicativeTargetWritingPower:3;
    UInt8  reserved2:1;

    UInt8  reserved5:6;
    UInt8  unrestrictedUse:1;
    UInt8  reserved4:1;

    UInt8  a3Valid:1;
    UInt8  a2Valid:1;
    UInt8  a1Valid:1;
    UInt8  discSubType:3;
    UInt8  discType:1;
    UInt8  reserved6:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved2:1;
    UInt8  indicativeTargetWritingPower:3;
    UInt8  reserved3:1;
    UInt8  referenceSpeed:3;

    UInt8  reserved4:1;
    UInt8  unrestrictedUse:1;
    UInt8  reserved5:6;

    UInt8  reserved6:1;
    UInt8  discType:1;
    UInt8  discSubType:3;
    UInt8  a1Valid:1;
    UInt8  a2Valid:1;
    UInt8  a3Valid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved7;
    CDMSF  startTimeOfLeadIn;
    UInt8  reserved8;
    CDMSF  lastPossibleStartTimeOfLeadOut;
    UInt8  reserved9;
    UInt8  a1[3];
    UInt8  reserved10;
    UInt8  a2[3];
    UInt8  reserved11;
    UInt8  a3[3];
    UInt8  reserved12;
};
typedef struct CDATIP CDATIP;

// Read Table Of Contents Format 0x05
struct CDTEXTDescriptor
{
    UInt8 packType;
    UInt8 trackNumber;
    UInt8 sequenceNumber;
#ifdef __LITTLE_ENDIAN__
    UInt8 characterPosition:4;
    UInt8 blockNumber:3;
    UInt8 doubleByteCharacterCode:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8 doubleByteCharacterCode:1;
    UInt8 blockNumber:3;
    UInt8 characterPosition:4;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8 textData[12];
    UInt8 reserved[2];
};
typedef struct CDTEXTDescriptor CDTEXTDescriptor;

struct CDTEXT
{
    UInt16           dataLength;
    UInt8            reserved;
    UInt8            reserved2;
    CDTEXTDescriptor descriptors[0];
};
typedef struct CDTEXT CDTEXT;

// Read Disc Information Format
struct CDDiscInfo
{
    UInt16 dataLength;
#ifdef __LITTLE_ENDIAN__
    UInt8  discStatus:2;
    UInt8  stateOfLastSession:2;
    UInt8  erasable:1;
    UInt8  reserved:3;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved:3;
    UInt8  erasable:1;
    UInt8  stateOfLastSession:2;
    UInt8  discStatus:2;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  numberOfFirstTrack;
    UInt8  numberOfSessionsLSB;
    UInt8  firstTrackNumberInLastSessionLSB;
    UInt8  lastTrackNumberInLastSessionLSB;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved3:5;
    UInt8  unrestrictedUse:1;
    UInt8  discBarCodeValid:1;
    UInt8  discIdentificationValid:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  discIdentificationValid:1;
    UInt8  discBarCodeValid:1;
    UInt8  unrestrictedUse:1;
    UInt8  reserved3:5;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  discType;
    UInt8  numberOfSessionsMSB;
    UInt8  firstTrackNumberInLastSessionMSB;
    UInt8  lastTrackNumberInLastSessionMSB;
    UInt32 discIdentification;
    UInt8  reserved7;
    CDMSF  lastSessionLeadInStartTime;
    UInt8  reserved8;
    CDMSF  lastPossibleStartTimeOfLeadOut;
    UInt8  discBarCode[8];
    UInt8  reserved9;
    UInt8  numberOfOPCTableEntries;
    UInt8  opcTableEntries[0];
};
typedef struct CDDiscInfo CDDiscInfo;

// Read Track Information Address Types
typedef UInt8 CDTrackInfoAddressType;
enum
{
    kCDTrackInfoAddressTypeLBA           = 0x00,
    kCDTrackInfoAddressTypeTrackNumber   = 0x01,
    kCDTrackInfoAddressTypeSessionNumber = 0x02,
};

// Read Track Information Format
struct CDTrackInfo
{
    UInt16 dataLength;
    UInt8  trackNumberLSB;
    UInt8  sessionNumberLSB;
    UInt8  reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8  trackMode:4;
    UInt8  copy:1;
    UInt8  damage:1;
    UInt8  reserved3:2;

    UInt8  dataMode:4;
    UInt8  fixedPacket:1;
    UInt8  packet:1;
    UInt8  blank:1;
    UInt8  reservedTrack:1;

    UInt8  nextWritableAddressValid:1;
    UInt8  lastRecordedAddressValid:1;
    UInt8  reserved5:6;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved3:2;
    UInt8  damage:1;
    UInt8  copy:1;
    UInt8  trackMode:4;

    UInt8  reservedTrack:1;
    UInt8  blank:1;
    UInt8  packet:1;
    UInt8  fixedPacket:1;
    UInt8  dataMode:4;

    UInt8  reserved5:6;
    UInt8  lastRecordedAddressValid:1;
    UInt8  nextWritableAddressValid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt32 trackStartAddress;
    UInt32 nextWritableAddress;
    UInt32 freeBlocks;
    UInt32 fixedPacketSize;
    UInt32 trackSize;
    UInt32 lastRecordedAddress;
    UInt8  trackNumberMSB;
    UInt8  sessionNumberMSB;
    UInt8  reserved6;
    UInt8  reserved7;
};
typedef struct CDTrackInfo CDTrackInfo;

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* _IOCDTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        IODVDBlockStorageDevice.h                                                                           0100644 0001750 0001750 00000012503 12567452466 040137  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IODVDBlockStorageDevice
 * @abstract
 * This header contains the IODVDBlockStorageDevice class definition.
 */

#ifndef	_IODVDBLOCKSTORAGEDEVICE_H
#define	_IODVDBLOCKSTORAGEDEVICE_H

#include <IOKit/storage/IODVDTypes.h>

/*!
 * @defined kIODVDBlockStorageDeviceClass
 * @abstract
 * kIODVDBlockStorageDeviceClass is the name of the IODVDBlockStorageDevice class.
 * @discussion
 * kIODVDBlockStorageDeviceClass is the name of the IODVDBlockStorageDevice class.
 */

#define kIODVDBlockStorageDeviceClass "IODVDBlockStorageDevice"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOCDBlockStorageDevice.h>

/* Property used for matching, so the generic driver gets the nub it wants. */
#define	kIOBlockStorageDeviceTypeDVD	"DVD"

/*!
 * @class
 * IODVDBlockStorageDevice : public IOCDBlockStorageDevice
 * @abstract
 * The IODVDBlockStorageDevice class is a generic DVD block storage device
 * abstraction.
 * @discussion
 * This class is the protocol for generic DVD functionality, independent of
 * the physical connection protocol (e.g. SCSI, ATA, USB).
 *
 * The APIs are the union of CD APIs and all
 * necessary new low-level DVD APIs.
 *
 * A subclass implements relay methods that translate our requests into
 * calls to a protocol- and device-specific provider.
 */

class IODVDBlockStorageDevice : public IOCDBlockStorageDevice {

    OSDeclareAbstractStructors(IODVDBlockStorageDevice)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /* Overrides from IORegistryEntry */
    
    virtual bool	init(OSDictionary * properties);

    /* New APIs for DVD */

    virtual IOReturn	reportKey(IOMemoryDescriptor *buffer,const DVDKeyClass keyClass,
                                        const UInt32 lba,const UInt8 agid,const DVDKeyFormat keyFormat)	= 0;

    virtual IOReturn	sendKey(IOMemoryDescriptor *buffer,const DVDKeyClass keyClass,
                                        const UInt8 agid,const DVDKeyFormat keyFormat)	= 0;

    virtual IOReturn	readDVDStructure(IOMemoryDescriptor *buffer,const DVDStructureFormat format,
                                        const UInt32 address,const UInt8 layer,const UInt8 agid)	= 0;

    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  0);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  1);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  2);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  3);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  4);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  5);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  6);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  7);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  8);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice,  9);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 10);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 11);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 12);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 13);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 14);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 15);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 16);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 17);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 18);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 19);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 20);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 21);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 22);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 23);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 24);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 25);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 26);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 27);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 28);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 29);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 30);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDevice, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IODVDBLOCKSTORAGEDEVICE_H */
                                                                                                                                                                                             IODVDBlockStorageDriver.h                                                                           0100644 0001750 0001750 00000021411 12567452466 040171  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * IODVDBlockStorageDriver.h
 *
 * This class implements DVD functionality, independent of
 * the physical connection protocol (e.g. SCSI, ATA, USB).
 *
 * A protocol-specific provider implements the functionality using an appropriate
 * protocol and commands.
 */

#ifndef	_IODVDBLOCKSTORAGEDRIVER_H
#define	_IODVDBLOCKSTORAGEDRIVER_H

#include <IOKit/IOTypes.h>
#include <IOKit/storage/IOCDBlockStorageDriver.h>
#include <IOKit/storage/IODVDBlockStorageDevice.h>
#include <IOKit/storage/IODVDTypes.h>

/*
 * @defined kIODVDBlockStorageDriverClass
 * @abstract
 * kIODVDBlockStorageDriverClass is the name of the IODVDBlockStorageDriver class.
 * @discussion
 * kIODVDBlockStorageDriverClass is the name of the IODVDBlockStorageDriver class.
 */

#define kIODVDBlockStorageDriverClass "IODVDBlockStorageDriver"

class IODVDBlockStorageDevice;

/*
 * @class
 * IODVDBlockStorageDriver : public IOCDBlockStorageDriver
 * @abstract
 * Generic DVD Driver.
 * @discussion
 * Storage drivers are split into two parts: the Generic Driver handles
 * all generic device issues, independent of the lower-level transport
 * mechanism (e.g. SCSI, ATA, USB, FireWire). All storage operations
 * at the Generic Driver level are translated into a series of generic
 * device operations. These operations are passed via the Device Nub
 * to a Transport Driver, which implements the appropriate
 * transport-dependent protocol to execute these operations.
 * 
 * To determine the write-protect state of a device (or media), for
 * example, the generic driver would issue a call to the
 * Transport Driver's reportWriteProtection method. If this were a SCSI
 * device, its Transport Driver would issue a Mode Sense command to
 * extract the write-protection status bit. The Transport Driver then
 * reports true or false to the generic driver.
 * 
 * The generic driver therefore has no knowledge of, or involvement
 * with, the actual commands and mechanisms used to communicate with
 * the device. It is expected that the generic driver will rarely, if
 * ever, need to be subclassed to handle device idiosyncrasies; rather,
 * the Transport Driver should be changed via overrides.
 * 
 * A generic driver could be subclassed to create a different type of
 * generic device. The generic driver IODVDBlockStorageDriver class is a subclass
 * of IOCDBlockStorageDriver, adding DVD functions. Similarly, the Transport Driver
 * IODVDBlockStorageDevice is a subclass of IOCDBlockStorageDevice, adding DVD 
 * functions.
*/

class IODVDBlockStorageDriver : public IOCDBlockStorageDriver {

    OSDeclareDefaultStructors(IODVDBlockStorageDriver)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    /* Overrides of IOCDBlockStorageDriver. */

    virtual IOReturn	acceptNewMedia(void);

    /* End of IOCDBlockStorageDriver overrides. */

public:

    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of IOService -- IODVDBlockStorageDevice.
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IODVDBlockStorageDevice * getProvider() const;

    /* Overrides of IOCDBlockStorageDriver: */

    virtual const char * getDeviceTypeName(void);
    virtual IOMedia *	instantiateDesiredMediaObject(void);
    virtual IOMedia *	instantiateMediaObject(UInt64 base,UInt64 byteSize,
                                            UInt32 blockSize,char *mediaName);

    /* End of IOCDBlockStorageDriver overrides. */

    /*
     * @function reportKey
     * @abstract
     * Get key info from the DVD drive.
     * @discussion
     * This function handles the getting of key- and encryption-related data for the drive.
     * @param buffer
     * A buffer containing information, as documented in the specification
     * "MtFuji Commands For Multimedia Devices."
     * @param keyClass
     * As documented by MtFuji. See DVDKeyClass.
     * @param lba
     * As documented by MtFuji.
     * @param agid
     * As documented by MtFuji.
     * @param keyFormat
     * As documented by MtFuji. See DVDKeyFormat.
     */
    virtual IOReturn	reportKey(IOMemoryDescriptor *buffer,const DVDKeyClass keyClass,
                                        const UInt32 lba,const UInt8 agid,const DVDKeyFormat keyFormat);

    /*
     * @function sendKey
     * @abstract
     * Send key info to the DVD drive.
     * @discussion
     * This function handles the setting of key- and encryption-related data for the drive.
     * @param buffer
     * A buffer containing information, as documented in the specification
     * "MtFuji Commands For Multimedia Devices."
     * @param keyClass
     * As documented by MtFuji. See DVDKeyClass.
     * @param agid
     * As documented by MtFuji.
     * @param keyFormat
     * As documented by MtFuji. See DVDKeyFormat.
     */
    virtual IOReturn	sendKey(IOMemoryDescriptor *buffer,const DVDKeyClass keyClass,
                                        const UInt8 agid,const DVDKeyFormat keyFormat);

    /*
     * @function readStructure
     * @abstract
     * Get control structures from the DVD media.
     * @discussion
     * This function handles the getting of control structure data for the media.
     * @param buffer
     * A buffer containing information, as documented in the specification
     * "MtFuji Commands For Multimedia Devices."
     * @param format
     * As documented by MtFuji. See DVDStructureFormat.
     * @param address
     * As documented by MtFuji.
     * @param layer
     * As documented by MtFuji.
     * @param agid
     * As documented by MtFuji.
     */
    virtual IOReturn	readStructure(IOMemoryDescriptor *buffer,const DVDStructureFormat format,
                                        const UInt32 address,const UInt8 layer,const UInt8 agid);

    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  0);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  1);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  2);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  3);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  4);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  5);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  6);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  7);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  8);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver,  9);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 10);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 11);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 12);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 13);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 14);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 15);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 16);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 17);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 18);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 19);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 20);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 21);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 22);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 23);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 24);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 25);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 26);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 27);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 28);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 29);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 30);
    OSMetaClassDeclareReservedUnused(IODVDBlockStorageDriver, 31);
};
#endif
                                                                                                                                                                                                                                                       IODVDMedia.h                                                                                        0100644 0001750 0001750 00000025073 12567452466 035465  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IODVDMedia
 * @abstract
 * This header contains the IODVDMedia class definition.
 */

#ifndef _IODVDMEDIA_H
#define _IODVDMEDIA_H

/*!
 * @defined kIODVDMediaClass
 * @abstract
 * kIODVDMediaClass is the name of the IODVDMedia class.
 * @discussion
 * kIODVDMediaClass is the name of the IODVDMedia class.
 */

#define kIODVDMediaClass "IODVDMedia"

/*!
 * @defined kIODVDMediaTypeKey
 * @abstract
 * kIODVDMediaTypeKey is a property of IODVDMedia objects.  It has an OSString
 * value.
 * @discussion
 * The kIODVDMediaTypeKey property identifies the DVD media type (DVD-ROM,
 * DVD-R, DVD-RW, DVD+RW, DVD-RAM, etc).  See the kIODVDMediaType contants
 * for possible values.
 */

#define kIODVDMediaTypeKey "Type"

/*!
 * @defined kIODVDMediaTypeROM
 * The kIODVDMediaTypeKey constant for DVD-ROM media.
 */

#define kIODVDMediaTypeROM "DVD-ROM"

/*!
 * @defined kIODVDMediaTypeR
 * The kIODVDMediaTypeKey constant for DVD Recordable (DVD-R) media.
 */

#define kIODVDMediaTypeR "DVD-R"

/*!
 * @defined kIODVDMediaTypeRW
 * The kIODVDMediaTypeKey constant for DVD ReWritable (DVD-RW) media.
 */

#define kIODVDMediaTypeRW "DVD-RW"

/*!
 * @defined kIODVDMediaTypePlusR
 * The kIODVDMediaTypeKey constant for DVD "Plus" Recordable (DVD+R) media.
 */

#define kIODVDMediaTypePlusR "DVD+R"

/*!
 * @defined kIODVDMediaTypePlusRW
 * The kIODVDMediaTypeKey constant for DVD "Plus" ReWritable (DVD+RW) media.
 */

#define kIODVDMediaTypePlusRW "DVD+RW"

/*!
 * @defined kIODVDMediaTypeRAM
 * The kIODVDMediaTypeKey constant for DVD-RAM media.
 */

#define kIODVDMediaTypeRAM "DVD-RAM"

/*!
 * @defined kIODVDMediaTypeHDROM
 * The kIODVDMediaTypeKey constant for HD DVD-ROM media.
 */

#define kIODVDMediaTypeHDROM "HD DVD-ROM"

/*!
 * @defined kIODVDMediaTypeHDR
 * The kIODVDMediaTypeKey constant for HD DVD Recordable (HD DVD-R) media.
 */

#define kIODVDMediaTypeHDR "HD DVD-R"

/*!
 * @defined kIODVDMediaTypeHDRW
 * The kIODVDMediaTypeKey constant for HD DVD ReWritable (HD DVD-RW) media.
 */

#define kIODVDMediaTypeHDRW "HD DVD-RW"

/*!
 * @defined kIODVDMediaTypeHDRAM
 * The kIODVDMediaTypeKey constant for HD DVD-RAM media.
 */

#define kIODVDMediaTypeHDRAM "HD DVD-RAM"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IODVDBlockStorageDriver.h>
#include <IOKit/storage/IOMedia.h>

/*!
 * @class IODVDMedia
 * @abstract
 * The IODVDMedia class is a random-access disk device abstraction for DVDs.
 * @discussion
 * The IODVDMedia class is a random-access disk device abstraction for DVDs.
 */

class IODVDMedia : public IOMedia
{
    OSDeclareDefaultStructors(IODVDMedia)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /*
     * Obtain this object's provider.   We override the superclass's method to
     * return a more specific subclass of IOService -- IODVDBlockStorageDriver.
     * This method serves simply as a convenience to subclass developers.
     */

    virtual IODVDBlockStorageDriver * getProvider() const;

    /*
     * Compare the properties in the supplied table to this object's properties.
     */

    virtual bool matchPropertyTable(OSDictionary * table, SInt32 * score);

    /*!
     * @function reportKey
     * @discussion
     * Issue an MMC REPORT KEY command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.  Pass null for the kDVDKeyFormatAGID_Invalidate format
     * case.
     * @param keyClass
     * As documented by MMC.
     * @param address
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @param format
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn reportKey( IOMemoryDescriptor * buffer,
                                const DVDKeyClass    keyClass,
                                const UInt32         address,
                                const UInt8          grantID,
                                const DVDKeyFormat   format );

    /*!
     * @function sendKey
     * @discussion
     * Issue an MMC SEND KEY command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.  Pass null for the kDVDKeyFormatAGID_Invalidate format
     * case.
     * @param keyClass
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @param format
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn sendKey( IOMemoryDescriptor * buffer,
                              const DVDKeyClass    keyClass,
                              const UInt8          grantID,
                              const DVDKeyFormat   format );

    /*!
     * @function readStructure
     * @discussion
     * Issue an MMC READ DVD STRUCTURE command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param format
     * As documented by MMC.
     * @param address
     * As documented by MMC.
     * @param layer
     * As documented by MMC.
     * @param grantID
     * As documented by MMC.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readStructure( IOMemoryDescriptor *     buffer,
                                    const DVDStructureFormat format,
                                    const UInt32             address,
                                    const UInt8              layer,
                                    const UInt8              grantID );

    /*!
     * @function getSpeed
     * @discussion
     * Get the current speed used for data transfers.
     * @param kilobytesPerSecond
     * Returns the current speed used for data transfers, in kB/s.
     *
     * kDVDSpeedMin specifies the minimum speed for all DVD media (1X).
     * kDVDSpeedMax specifies the maximum speed supported in hardware.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn getSpeed(UInt16 * kilobytesPerSecond);

    /*!
     * @function setSpeed
     * @discussion
     * Set the speed to be used for data transfers.
     * @param kilobytesPerSecond
     * Speed to be used for data transfers, in kB/s.
     *
     * kDVDSpeedMin specifies the minimum speed for all DVD media (1X).
     * kDVDSpeedMax specifies the maximum speed supported in hardware.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setSpeed(UInt16 kilobytesPerSecond);

    /*!
     * @function readDiscInfo
     * @discussion
     * Issue an MMC READ DISC INFORMATION command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readDiscInfo( IOMemoryDescriptor * buffer,
                                   UInt16 *             actualByteCount );

    /*!
     * @function readRZoneInfo
     * @discussion
     * Issue an MMC READ RZONE INFORMATION (READ TRACK INFORMATION) command.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param address
     * As documented by MMC.
     * @param addressType
     * As documented by MMC.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn readRZoneInfo( IOMemoryDescriptor *    buffer,
                                    UInt32                  address,
                                    DVDRZoneInfoAddressType addressType,
                                    UInt16 *                actualByteCount );

    OSMetaClassDeclareReservedUnused(IODVDMedia,  0);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  1);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  2);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  3);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  4);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  5);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  6);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  7);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  8);
    OSMetaClassDeclareReservedUnused(IODVDMedia,  9);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 10);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 11);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 12);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 13);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 14);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 15);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 16);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 17);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 18);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 19);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 20);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 21);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 22);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 23);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 24);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 25);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 26);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 27);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 28);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 29);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 30);
    OSMetaClassDeclareReservedUnused(IODVDMedia, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IODVDMEDIA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     IODVDMediaBSDClient.h                                                                               0100644 0001750 0001750 00000013464 12567452466 037156  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IODVDMEDIABSDCLIENT_H
#define _IODVDMEDIABSDCLIENT_H

#include <sys/ioctl.h>

#include <IOKit/storage/IODVDTypes.h>

/*
 * Definitions
 *
 * ioctl                        description
 * ---------------------------- ------------------------------------------------
 * DKIOCDVDREADSTRUCTURE        see IODVDMedia::readStructure()  in IODVDMedia.h
 *
 * DKIOCDVDREADDISCINFO         see IODVDMedia::readDiscInfo()   in IODVDMedia.h
 * DKIOCDVDREADRZONEINFO        see IODVDMedia::readRZoneInfo()  in IODVDMedia.h
 *
 * DKIOCDVDREPORTKEY            see IODVDMedia::reportKey()      in IODVDMedia.h
 * DKIOCDVDSENDKEY              see IODVDMedia::sendKey()        in IODVDMedia.h
 *
 * DKIOCDVDGETSPEED             see IODVDMedia::getSpeed()       in IODVDMedia.h
 * DKIOCDVDSETSPEED             see IODVDMedia::setSpeed()       in IODVDMedia.h
 *
 *         in /System/Library/Frameworks/Kernel.framework/Headers/IOKit/storage/
 */

typedef struct
{
    uint8_t  format;

    uint8_t  reserved0008[3];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;
    uint8_t  layer;

#ifdef __LP64__
    uint8_t  reserved0080[4];                      /* reserved, clear to zero */
#endif /* __LP64__ */

    uint16_t bufferLength;
    void *   buffer;
} dk_dvd_read_structure_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[2];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  grantID;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;
    void *   buffer;
} dk_dvd_report_key_t;

typedef struct
{
    uint8_t  format;
    uint8_t  keyClass;

    uint8_t  reserved0016[6];                      /* reserved, clear to zero */

    uint8_t  grantID;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;
    void *   buffer;
} dk_dvd_send_key_t;

typedef struct
{
#ifdef __LP64__
    uint8_t  reserved0000[14];                     /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0000[10];                     /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_dvd_read_disc_info_t;

typedef struct
{
    uint8_t  reserved0000[4];                      /* reserved, clear to zero */

    uint32_t address;
    uint8_t  addressType;

#ifdef __LP64__
    uint8_t  reserved0072[5];                      /* reserved, clear to zero */
#else /* !__LP64__ */
    uint8_t  reserved0072[1];                      /* reserved, clear to zero */
#endif /* !__LP64__ */

    uint16_t bufferLength;                         /* actual length on return */
    void *   buffer;
} dk_dvd_read_rzone_info_t;

#define DKIOCDVDREADSTRUCTURE   _IOW('d', 128, dk_dvd_read_structure_t)
#define DKIOCDVDREPORTKEY       _IOW('d', 129, dk_dvd_report_key_t)
#define DKIOCDVDSENDKEY         _IOW('d', 130, dk_dvd_send_key_t)

#define DKIOCDVDGETSPEED        _IOR('d', 131, uint16_t)
#define DKIOCDVDSETSPEED        _IOW('d', 131, uint16_t)

#define DKIOCDVDREADDISCINFO    _IOWR('d', 132, dk_dvd_read_disc_info_t)
#define DKIOCDVDREADRZONEINFO   _IOWR('d', 133, dk_dvd_read_rzone_info_t)

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IODVDMedia.h>
#include <IOKit/storage/IOMediaBSDClient.h>

/*
 * Class
 */

class IODVDMediaBSDClient : public IOMediaBSDClient
{
    OSDeclareDefaultStructors(IODVDMediaBSDClient)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

public:

    /*
     * Obtain this object's provider.   We override the superclass's method
     * to return a more specific subclass of IOService -- IODVDMedia.  This
     * method serves simply as a convenience to subclass developers.
     */

    virtual IODVDMedia * getProvider() const;

    /*
     * Process a DVD-specific ioctl.
     */

    virtual int ioctl(dev_t dev, u_long cmd, caddr_t data, int flags, proc_t proc);

    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 0);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 1);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 2);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 3);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 4);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 5);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 6);
    OSMetaClassDeclareReservedUnused(IODVDMediaBSDClient, 7);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IODVDMEDIABSDCLIENT_H */
                                                                                                                                                                                                            IODVDTypes.h                                                                                        0100644 0001750 0001750 00000024337 12567452466 035554  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef	_IODVDTYPES_H
#define	_IODVDTYPES_H

#include <IOKit/IOTypes.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/*
 * Media Types
 */

enum
{
    kDVDMediaTypeUnknown   = 0x0200,
    kDVDMediaTypeROM       = 0x0202, /* DVD-ROM    */
    kDVDMediaTypeRAM       = 0x0203, /* DVD-RAM    */
    kDVDMediaTypeR         = 0x0204, /* DVD-R      */
    kDVDMediaTypeRW        = 0x0205, /* DVD-RW     */
    kDVDMediaTypePlusRW    = 0x0206, /* DVD+RW     */
    kDVDMediaTypePlusR     = 0x0207, /* DVD+R      */
    kDVDMediaTypeHDROM     = 0x0212, /* HD DVD-ROM */
    kDVDMediaTypeHDRAM     = 0x0213, /* HD DVD-RAM */
    kDVDMediaTypeHDR       = 0x0214, /* HD DVD-R   */
    kDVDMediaTypeHDRW      = 0x0215, /* HD DVD-RW  */

    kDVDMediaTypeMin       = 0x0200,
    kDVDMediaTypeMax       = 0x02FF
};

typedef UInt32 DVDMediaType;

/*
 * Media Speed (kB/s)
 */

#define kDVDSpeedMin 0x0546
#define kDVDSpeedMax 0xFFFF

/*
 * MMC Formats
 */

typedef UInt8	DVDCPRMRegionCode;
enum
{
	kDVDCPRMRegion1		= 0xFE,
	kDVDCPRMRegion2		= 0xFD,
	kDVDCPRMRegion3		= 0xFB,
	kDVDCPRMRegion4		= 0xF7,
	kDVDCPRMRegion5		= 0xEF,
	kDVDCPRMRegion6		= 0xDF
};

typedef UInt8	DVDRegionalPlaybackControlScheme;
enum
{
	kDVDRegionalPlaybackControlSchemePhase1		= 0x00,
	kDVDRegionalPlaybackControlSchemePhase2		= 0x01
};

typedef UInt8	DVDBookType;
enum
{
	kDVDBookTypeROM					= 0x0,
	kDVDBookTypeRAM					= 0x1,
	kDVDBookTypeR					= 0x2,
	kDVDBookTypeRW					= 0x3,
	kDVDBookTypeHDROM				= 0x4,
	kDVDBookTypeHDRAM				= 0x5,
	kDVDBookTypeHDR					= 0x6,
	kDVDBookTypeHDRW				= 0x7,
	kDVDBookTypePlusRW				= 0x9,
	kDVDBookTypePlusR				= 0xA,
	kDVDBookTypePlusRWDoubleLayer	= 0xD,
	kDVDBookTypePlusRDoubleLayer	= 0xE
};

typedef UInt8	DVDKeyClass;
enum
{
	kDVDKeyClassCSS_CPPM_CPRM	= 0x00,
	kDVDKeyClassRSSA			= 0x01
};

typedef UInt8	DVDKeyFormat;
enum
{
	kDVDKeyFormatAGID_CSS			= 0x00,
	kDVDKeyFormatChallengeKey		= 0x01,
	kDVDKeyFormatKey1				= 0x02,
	kDVDKeyFormatKey2				= 0x03,
	kDVDKeyFormatTitleKey			= 0x04,
	kDVDKeyFormatASF				= 0x05,
	kDVDKeyFormatSetRegion			= 0x06,
	kDVDKeyFormatRegionState		= 0x08,
	kDVDKeyFormatAGID_CSS2			= 0x10,
	kDVDKeyFormatAGID_CPRM			= 0x11,
	kDVDKeyFormatAGID_Invalidate	= 0x3F
};	

typedef UInt8	DVDStructureFormat;
enum
{
	kDVDStructureFormatPhysicalFormatInfo			= 0x00,
	kDVDStructureFormatCopyrightInfo				= 0x01,
	kDVDStructureFormatDiscKeyInfo					= 0x02,
	// skip BCA
	kDVDStructureFormatManufacturingInfo			= 0x04
};

// Read DVD Structures Format 0x00
struct DVDPhysicalFormatInfo
{
	UInt8		dataLength[2];
	UInt8		reserved[2];
#ifdef __LITTLE_ENDIAN__
	// Byte 0
	UInt8		partVersion:4;
	UInt8		bookType:4;
	
	// Byte 1
	UInt8		minimumRate:4;
	UInt8		discSize:4;
	
	// Byte 2
	UInt8		layerType:4;
	UInt8		trackPath:1;
	UInt8		numberOfLayers:2;
	UInt8		reserved2:1;
	
	// Byte 3
	UInt8		trackDensity:4;
	UInt8		linearDensity:4;
#else /* !__LITTLE_ENDIAN__ */
	// Byte 0
	UInt8		bookType:4;
	UInt8		partVersion:4;
	
	// Byte 1
	UInt8		discSize:4;
	UInt8		minimumRate:4;
	
	// Byte 2
	UInt8		reserved2:1;
	UInt8		numberOfLayers:2;
	UInt8		trackPath:1;
	UInt8		layerType:4;
	
	// Byte 3
	UInt8		linearDensity:4;
	UInt8		trackDensity:4;
#endif /* !__LITTLE_ENDIAN__ */
	
	// Bytes 4-15
	UInt8		zero1;		// always 0x00
	UInt8		startingPhysicalSectorNumberOfDataArea[3];
	UInt8		zero2;		// always 0x00
	UInt8		endPhysicalSectorNumberOfDataArea[3];
	UInt8		zero3;		// always 0x00
	UInt8		endSectorNumberInLayerZero[3];
	
	// Byte 16
#ifdef __LITTLE_ENDIAN__
	UInt8		reserved1:7;
	UInt8		bcaFlag:1;
#else /* !__LITTLE_ENDIAN__ */
	UInt8		bcaFlag:1;
	UInt8		reserved1:7;
#endif /* !__LITTLE_ENDIAN__ */
	
	// Bytes 17-2047
	UInt8		mediaSpecific[2031];
};
typedef struct DVDPhysicalFormatInfo DVDPhysicalFormatInfo;

// Read DVD Structures Format 0x01
struct DVDCopyrightInfo
{
	UInt8				dataLength[2];
	UInt8				reserved[2];
	UInt8				copyrightProtectionSystemType;
	DVDCPRMRegionCode	regionMask;
	UInt8				reserved2[2];
};
typedef struct DVDCopyrightInfo DVDCopyrightInfo;

// Read DVD Structures Format 0x02
struct DVDDiscKeyInfo
{
	UInt8		dataLength[2];
	UInt8		reserved[2];
	UInt8		discKeyStructures[2048];
};
typedef struct DVDDiscKeyInfo DVDDiscKeyInfo;

// Read DVD Structures Format 0x04
struct DVDManufacturingInfo
{
	UInt8		dataLength[2];
	UInt8		reserved[2];
	UInt8		discManufacturingInfo[2048];
};
typedef struct DVDManufacturingInfo DVDManufacturingInfo;

// ReportKey Format 0x00
struct DVDAuthenticationGrantIDInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	reserved2[3];
#ifdef __LITTLE_ENDIAN__
	UInt8	reservedBits:6;
	UInt8	grantID:2;
#else /* !__LITTLE_ENDIAN__ */
	UInt8	grantID:2;
	UInt8	reservedBits:6;
#endif /* !__LITTLE_ENDIAN__ */
};
typedef struct DVDAuthenticationGrantIDInfo DVDAuthenticationGrantIDInfo;

// ReportKey and SendKey Format 0x01
struct DVDChallengeKeyInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	challengeKeyValue[10];
	UInt8	reserved2[2];
};
typedef struct DVDChallengeKeyInfo DVDChallengeKeyInfo;

// ReportKey Format 0x02
struct DVDKey1Info
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	key1Value[5];
	UInt8	reserved2[3];
};
typedef struct DVDKey1Info DVDKey1Info;

// SendKey Format 0x03
struct DVDKey2Info
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	key2Value[5];
	UInt8	reserved2[3];
};
typedef struct DVDKey2Info DVDKey2Info;

// ReportKey Format 0x04
struct DVDTitleKeyInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
#ifdef __LITTLE_ENDIAN__
	UInt8	CP_MOD:4;
	UInt8	CGMS:2;
	UInt8	CP_SEC:1;
	UInt8	CPM:1;
#else /* !__LITTLE_ENDIAN__ */
	UInt8	CPM:1;
	UInt8	CP_SEC:1;
	UInt8	CGMS:2;
	UInt8	CP_MOD:4;
#endif /* !__LITTLE_ENDIAN__ */
	UInt8	titleKeyValue[5];
	UInt8	reserved2[2];
};
typedef struct DVDTitleKeyInfo DVDTitleKeyInfo;

// ReportKey Format 0x05
struct DVDAuthenticationSuccessFlagInfo
{
	UInt8	dataLength[2];
	UInt8	reserved[2];
	UInt8	reserved2[3];
#ifdef __LITTLE_ENDIAN__
	UInt8	successFlag:1;
	UInt8	reservedBits:7;
#else /* !__LITTLE_ENDIAN__ */
	UInt8	reservedBits:7;
	UInt8	successFlag:1;
#endif /* !__LITTLE_ENDIAN__ */
};
typedef struct DVDAuthenticationSuccessFlagInfo DVDAuthenticationSuccessFlagInfo;

// ReportKey Format 0x08
struct DVDRegionPlaybackControlInfo
{
	UInt8									dataLength[2];
	UInt8									reserved[2];
#ifdef __LITTLE_ENDIAN__
	UInt8									numberUserResets:3;
	UInt8									numberVendorResets:3;
	UInt8									typeCode:2;
#else /* !__LITTLE_ENDIAN__ */
	UInt8									typeCode:2;
	UInt8									numberVendorResets:3;
	UInt8									numberUserResets:3;
#endif /* !__LITTLE_ENDIAN__ */
	DVDCPRMRegionCode						driveRegion;
	DVDRegionalPlaybackControlScheme		rpcScheme;
	UInt8									reserved2;
};
typedef struct DVDRegionPlaybackControlInfo DVDRegionPlaybackControlInfo;

// Read Disc Information Format
struct DVDDiscInfo
{
    UInt16 dataLength;
#ifdef __LITTLE_ENDIAN__
    UInt8  discStatus:2;
    UInt8  stateOfLastBorder:2;
    UInt8  erasable:1;
    UInt8  reserved:3;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved:3;
    UInt8  erasable:1;
    UInt8  stateOfLastBorder:2;
    UInt8  discStatus:2;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved2;
    UInt8  numberOfBordersLSB;
    UInt8  firstRZoneNumberInLastBorderLSB;
    UInt8  lastRZoneNumberInLastBorderLSB;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved3:5;
    UInt8  unrestrictedUse:1;
    UInt8  discBarCodeValid:1;
    UInt8  reserved4:1;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved4:1;
    UInt8  discBarCodeValid:1;
    UInt8  unrestrictedUse:1;
    UInt8  reserved3:5;
#endif /* !__LITTLE_ENDIAN__ */
    UInt8  reserved5;
    UInt8  numberOfBordersMSB;
    UInt8  firstRZoneNumberInLastBorderMSB;
    UInt8  lastRZoneNumberInLastBorderMSB;
    UInt8  reserved6[4];
    UInt8  reserved7[4];
    UInt8  reserved8[4];
    UInt8  discBarCode[8];
    UInt8  reserved9;
    UInt8  numberOfOPCTableEntries;
    UInt8  opcTableEntries[0];
};
typedef struct DVDDiscInfo DVDDiscInfo;

// Read RZone Information Address Types
typedef UInt8 DVDRZoneInfoAddressType;
enum
{
    kDVDRZoneInfoAddressTypeLBA          = 0x00,
    kDVDRZoneInfoAddressTypeRZoneNumber  = 0x01,
    kDVDRZoneInfoAddressTypeBorderNumber = 0x02,
};

// Read RZone Information Format
struct DVDRZoneInfo
{
    UInt16 dataLength;
    UInt8  rzoneNumberLSB;
    UInt8  borderNumberLSB;
    UInt8  reserved;
#ifdef __LITTLE_ENDIAN__
    UInt8  reserved2:4;
    UInt8  copy:1;
    UInt8  damage:1;
    UInt8  reserved3:2;

    UInt8  reserved4:4;
    UInt8  restrictedOverwrite:1;
    UInt8  incremental:1;
    UInt8  blank:1;
    UInt8  reservedRZone:1;

    UInt8  nextWritableAddressValid:1;
    UInt8  lastRecordedAddressValid:1;
    UInt8  reserved5:6;
#else /* !__LITTLE_ENDIAN__ */
    UInt8  reserved3:2;
    UInt8  damage:1;
    UInt8  copy:1;
    UInt8  reserved2:4;

    UInt8  reservedRZone:1;
    UInt8  blank:1;
    UInt8  incremental:1;
    UInt8  restrictedOverwrite:1;
    UInt8  reserved4:4;

    UInt8  reserved5:6;
    UInt8  lastRecordedAddressValid:1;
    UInt8  nextWritableAddressValid:1;
#endif /* !__LITTLE_ENDIAN__ */
    UInt32 rzoneStartAddress;
    UInt32 nextWritableAddress;
    UInt32 freeBlocks;
    UInt32 blockingFactor;
    UInt32 rzoneSize;
    UInt32 lastRecordedAddress;
    UInt8  rzoneNumberMSB;
    UInt8  borderNumberMSB;
    UInt8  reserved6;
    UInt8  reserved7;
};
typedef struct DVDRZoneInfo DVDRZoneInfo;

#pragma pack(pop)                        /* (reset to default struct packing) */

#endif /* _IODVDTYPES_H */
                                                                                                                                                                                                                                                                                                 IOFDiskPartitionScheme.h                                                                            0100644 0001750 0001750 00000020376 12567452411 040116  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOFDiskPartitionScheme class definition.
 */

#ifndef _IOFDISKPARTITIONSCHEME_H
#define _IOFDISKPARTITIONSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOFDiskPartitionSchemeClass is the name of the IOFDiskPartitionScheme class.
 */

#define kIOFDiskPartitionSchemeClass "IOFDiskPartitionScheme"

/*
 * FDisk Partition Map Definitions
 */

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Structure constants. */

#define DISK_BLK0SZ sizeof(struct disk_blk0)    /* (size of partition map)    */
#define DISK_BOOTSZ 446                         /* (size of boot code in map) */
#define DISK_NPART  4                           /* (number of entries in map) */

/* Partition map entry. */

struct fdisk_part
{
    UInt8   bootid;    /* (is active boot partition?)                         */
    UInt8   beghead;   /* (beginning head)                                    */
    UInt8   begsect;   /* (beginning sector; beginning cylinder, high 2 bits) */
    UInt8   begcyl;    /* (beginning cylinder, low 8 bits)                    */
    UInt8   systid;    /* (type)                                              */
    UInt8   endhead;   /* (ending head)                                       */
    UInt8   endsect;   /* (ending sector; ending cylinder, high 2 bits)       */
    UInt8   endcyl;    /* (ending cylinder, low 8 bits)                       */
    UInt32  relsect;   /* (block start)                                       */
    UInt32  numsect;   /* (block count)                                       */
};

/* Partition map, as found in block zero of the disk (or extended partition). */

struct disk_blk0
{
    UInt8             bootcode[DISK_BOOTSZ];    /* (boot code)                */
    struct fdisk_part parts[DISK_NPART];        /* (partition entries)        */
    UInt16            signature;                /* (unique signature for map) */
};

/* Partition map signature (signature). */

#define DISK_SIGNATURE 0xAA55

/* Partition map entry types (systid). */

#define FDISK_PARTITION_TYPE_01 "DOS_FAT_12"
#define FDISK_PARTITION_TYPE_04 "DOS_FAT_16_S"
#define FDISK_PARTITION_TYPE_06 "DOS_FAT_16"
#define FDISK_PARTITION_TYPE_07 "Windows_NTFS"
#define FDISK_PARTITION_TYPE_0B "DOS_FAT_32"
#define FDISK_PARTITION_TYPE_0C "Windows_FAT_32"
#define FDISK_PARTITION_TYPE_0E "Windows_FAT_16"
#define FDISK_PARTITION_TYPE_42 "Windows_LDM"
#define FDISK_PARTITION_TYPE_82 "Linux_Swap"
#define FDISK_PARTITION_TYPE_83 "Linux"
#define FDISK_PARTITION_TYPE_8E "Linux_LVM"
#define FDISK_PARTITION_TYPE_A5 "FreeBSD"
#define FDISK_PARTITION_TYPE_A6 "OpenBSD"
#define FDISK_PARTITION_TYPE_A7 "Apple_Rhapsody_UFS"
#define FDISK_PARTITION_TYPE_A8 "Apple_UFS"
#define FDISK_PARTITION_TYPE_A9 "NetBSD"
#define FDISK_PARTITION_TYPE_AB "Apple_Boot"
#define FDISK_PARTITION_TYPE_AE "Apple_Encrypted"
#define FDISK_PARTITION_TYPE_AF "Apple_HFS"
#define FDISK_PARTITION_TYPE_FD "Linux_RAID"

#pragma pack(pop)                        /* (reset to default struct packing) */

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOPartitionScheme.h>

/*
 * Class
 */

class IOFDiskPartitionScheme : public IOPartitionScheme
{
    OSDeclareDefaultStructors(IOFDiskPartitionScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    OSSet * _partitions;    /* (set of media objects representing partitions) */

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free(void);

    /*
     * Scan the provider media for an FDisk partition map.  Returns the set
     * of media objects representing each of the partitions (the retain for
     * the set is passed to the caller), or null should no partition map be
     * found.  The default probe score can be adjusted up or down, based on
     * the confidence of the scan.
     */

    virtual OSSet * scan(SInt32 * score);

    /*
     * Ask whether the given partition is extended.
     */

    virtual bool isPartitionExtended(fdisk_part * partition);

    /*
     * Ask whether the given partition is used.
     */

    virtual bool isPartitionUsed(fdisk_part * partition);

    /*
     * Ask whether the given partition appears to be corrupt.  A partition that
     * is corrupt will cause the failure of the FDisk partition map recognition
     * altogether.
     */

    virtual bool isPartitionCorrupt( fdisk_part * partition,
                                     UInt32       partitionID,
                                     UInt32       fdiskBlock );

    /*
     * Ask whether the given partition appears to be invalid.  A partition that
     * is invalid will cause it to be skipped in the scan, but will not cause a
     * failure of the FDisk partition map recognition.
     */

    virtual bool isPartitionInvalid( fdisk_part * partition,
                                     UInt32       partitionID,
                                     UInt32       fdiskBlock );

    /*
     * Instantiate a new media object to represent the given partition.
     */

    virtual IOMedia * instantiateMediaObject( fdisk_part * partition,
                                              UInt32       partitionID,
                                              UInt32       fdiskBlock );

    /*
     * Allocate a new media object (called from instantiateMediaObject).
     */

    virtual IOMedia * instantiateDesiredMediaObject( fdisk_part * partition,
                                                     UInt32       partitionID,
                                                     UInt32       fdiskBlock );

public:

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*
     * Determine whether the provider media contains an FDisk partition map.
     */

    virtual IOService * probe(IOService * provider, SInt32 * score);

    /*
     * Publish the new media objects which represent our partitions.
     */

    virtual bool start(IOService * provider);

    /*
     * Clean up after the media objects we published before terminating.
     */

    virtual void stop(IOService * provider);

    /*
     * Request that the provider media be re-scanned for partitions.
     */

    virtual IOReturn requestProbe(IOOptionBits options);

    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  0);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  1);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  2);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  3);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  4);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  5);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  6);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  7);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  8);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme,  9);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme, 10);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme, 11);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme, 12);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme, 13);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme, 14);
    OSMetaClassDeclareReservedUnused(IOFDiskPartitionScheme, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOFDISKPARTITIONSCHEME_H */
                                                                                                                                                                                                                                                                  IOFilterScheme.h                                                                                    0100644 0001750 0001750 00000033752 12567452411 036453  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOFilterScheme
 * @abstract
 * This header contains the IOFilterScheme class definition.
 */

#ifndef _IOFILTERSCHEME_H
#define _IOFILTERSCHEME_H

/*!
 * @defined kIOFilterSchemeClass
 * @abstract
 * The name of the IOFilterScheme class.
 * @discussion
 * kIOFilterSchemeClass is the name of the IOFilterScheme class.
 */

#define kIOFilterSchemeClass "IOFilterScheme"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOMedia.h>
#include <IOKit/storage/IOStorage.h>

/*!
 * @class IOFilterScheme
 * @abstract
 * The common base class for all filter scheme
 * objects.
 * @discussion
 * The IOFilterScheme class is the common base class for all filter scheme
 * objects.  It extends the IOStorage class by implementing the appropriate
 * open and close semantics for filter objects (standard semantics are act
 * as a relay for incoming opens, producing one outgoing open for each
 * incoming open).  It also implements the default read and write semantics,
 * which pass all reads and writes through to the provider media unprocessed.
 * For simple schemes, the default behavior is sufficient.  More complex
 * filter schemes such as RAID will want to do extra processing for reads
 * and writes.
 */

class IOFilterScheme : public IOStorage
{
    OSDeclareDefaultStructors(IOFilterScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    /*!
     * @function handleOpen
     * @discussion
     * The handleOpen method grants or denies permission to access this object
     * to an interested client.  The argument is an IOStorageAccess value that
     * specifies the level of access desired -- reader or reader-writer.
     *
     * This method can be invoked to upgrade or downgrade the access level for
     * an existing client as well.  The previous access level will prevail for
     * upgrades that fail, of course.   A downgrade should never fail.  If the
     * new access level should be the same as the old for a given client, this
     * method will do nothing and return success.  In all cases, one, singular
     * close-per-client is expected for all opens-per-client received.
     *
     * This implementation replaces the IOService definition of handleOpen().
     * @param client
     * Client requesting the open.
     * @param options
     * Options for the open.  Set to zero.
     * @param access
     * Access level for the open.  Set to kIOStorageAccessReader or
     * kIOStorageAccessReaderWriter.
     * @result
     * Returns true if the open was successful, false otherwise.
     */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       access);

    /*!
     * @function handleIsOpen
     * @discussion
     * The handleIsOpen method determines whether the specified client, or any
     * client if none is specified, presently has an open on this object.
     *
     * This implementation replaces the IOService definition of handleIsOpen().
     * @param client
     * Client to check the open state of.  Set to zero to check the open state
     * of all clients.
     * @result
     * Returns true if the client was (or clients were) open, false otherwise.
     */

    virtual bool handleIsOpen(const IOService * client) const;

    /*!
     * @function handleClose
     * @discussion
     * The handleClose method closes the client's access to this object.
     *
     * This implementation replaces the IOService definition of handleClose().
     * @param client
     * Client requesting the close.
     * @param options
     * Options for the close.  Set to zero.
     */

    virtual void handleClose(IOService * client, IOOptionBits options);

public:

    using IOStorage::read;
    using IOStorage::write;

    /*!
     * @function read
     * @discussion
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, asynchronously.   When the read completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the read.
     *
     * For simple filter schemes, the default behavior is to simply pass the
     * read through to the provider media.  More complex filter schemes such
     * as RAID will need to do extra processing here.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion);

    /*!
     * @function write
     * @discussion
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, asynchronously.   When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     *
     * For simple filter schemes, the default behavior is to simply pass the
     * write through to the provider media. More complex filter schemes such
     * as RAID will need to do extra processing here.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion);

    /*!
     * @function synchronize
     * @discussion
     * Flush the cached data in the storage object, if any.
     * @param client
     * Client requesting the synchronization.
     * @param byteStart
     * Starting byte offset for the synchronization.
     * @param byteCount
     * Size of the synchronization.  Set to zero to specify the end-of-media.
     * @param options
     * Options for the synchronization.  See IOStorageSynchronizeOptions.
     * @result
     * Returns the status of the synchronization.
     */

    virtual IOReturn synchronize(IOService *                 client,
                                 UInt64                      byteStart,
                                 UInt64                      byteCount,
                                 IOStorageSynchronizeOptions options = 0);

    /*!
     * @function unmap
     * @discussion
     * Delete unused data from the storage object at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param options
     * Options for the unmap.  See IOStorageUnmapOptions.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn unmap(IOService *           client,
                           IOStorageExtent *     extents,
                           UInt32                extentsCount,
                           IOStorageUnmapOptions options = 0);

    /*!
     * @function lockPhysicalExtents
     * @discussion
     * Lock the contents of the storage object against relocation temporarily,
     * for the purpose of getting physical extents.
     * @param client
     * Client requesting the operation.
     * @result
     * Returns true if the lock was successful, false otherwise.
     */

    virtual bool lockPhysicalExtents(IOService * client);

    /*!
     * @function copyPhysicalExtent
     * @discussion
     * Convert the specified byte offset into a physical byte offset, relative
     * to a physical storage object.  This call should only be made within the
     * context of lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     * @param byteStart
     * Starting byte offset for the operation.  Returns a physical byte offset,
     * relative to the physical storage object, on success.
     * @param byteCount
     * Size of the operation.  Returns the actual number of bytes which can be
     * transferred, relative to the physical storage object, on success. 
     * @result
     * A reference to the physical storage object, which should be released by
     * the caller, or a null on error.
     */

    virtual IOStorage * copyPhysicalExtent(IOService * client,
                                           UInt64 *    byteStart,
                                           UInt64 *    byteCount);

    /*!
     * @function unlockPhysicalExtents
     * @discussion
     * Unlock the contents of the storage object for relocation again.  This
     * call must balance a successful call to lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     */

    virtual void unlockPhysicalExtents(IOService * client);

    /*!
     * @function setPriority
     * @discussion
     * Reprioritize read or write requests at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param priority
     * New priority.  See IOStoragePriority.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setPriority(IOService *       client,
                                 IOStorageExtent * extents,
                                 UInt32            extentsCount,
                                 IOStoragePriority priority);

    /*
     * Obtain this object's provider.  We override the superclass's method
     * to return a more specific subclass of OSObject -- an IOMedia.  This
     * method serves simply as a convenience to subclass developers.
     */

    virtual IOMedia * getProvider() const;

    OSMetaClassDeclareReservedUnused(IOFilterScheme,  0);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  1);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  2);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  3);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  4);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  5);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  6);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  7);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  8);
    OSMetaClassDeclareReservedUnused(IOFilterScheme,  9);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 10);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 11);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 12);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 13);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 14);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 15);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 16);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 17);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 18);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 19);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 20);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 21);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 22);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 23);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 24);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 25);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 26);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 27);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 28);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 29);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 30);
    OSMetaClassDeclareReservedUnused(IOFilterScheme, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOFILTERSCHEME_H */
                      IOFireWireStorageCharacteristics.h                                                                  0100644 0001750 0001750 00000004011 12567471025 042162  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IO_FIREWIRE_STORAGE_DEVICE_CHARACTERISTICS_H_
#define _IOKIT_IO_FIREWIRE_STORAGE_DEVICE_CHARACTERISTICS_H_

//
//	Bridge Characteristics - Characteristics defined for FireWire bridges.
//

/*!
@defined kIOPropertyBridgeCharacteristicsKey
@discussion This key is used to define Bridge Characteristics for a particular
devices's bridge chipset. It has an associated dictionary which lists the
bridge characteristics.

Requirement: Optional

Example:
<pre>
@textblock
<dict>
	<key>Bridge Characteristics</key>
	<dict>
		<key>Bridge Vendor Name</key>
		<string>Oxford Semiconductor</string>
		<key>Bridge Model Name</key>
		<string>FW911</string>
		<key>Bridge Revision Level</key>
		<string>3.7</string>
	</dict>
</dict>
@/textblock
</pre>
*/

#define kIOPropertyBridgeCharacteristicsKey		"Bridge Characteristics"
#define kIOPropertyBridgeVendorNameKey			"Bridge Vendor Name"
#define kIOPropertyBridgeModelNameKey			"Bridge Model Name"
#define kIOPropertyBridgeRevisionLevelKey		"Bridge Revision Level"

#endif	/* _IOKIT_IO_FIREWIRE_STORAGE_DEVICE_CHARACTERISTICS_H_ */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IOGUIDPartitionScheme.h                                                                             0100644 0001750 0001750 00000014340 12567452411 037640  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This header contains the IOGUIDPartitionScheme class definition.
 */

#ifndef _IOGUIDPARTITIONSCHEME_H
#define _IOGUIDPARTITIONSCHEME_H

#include <IOKit/IOTypes.h>

/*
 * kIOGUIDPartitionSchemeClass is the name of the IOGUIDPartitionScheme class.
 */

#define kIOGUIDPartitionSchemeClass "IOGUIDPartitionScheme"

/*
 * GUID Partition Map Definitions
 */

#include <uuid/uuid.h>

#pragma pack(push, 1)                        /* (enable 8-bit struct packing) */

/* Partition map. */

struct gpt_hdr
{
    uint8_t  hdr_sig[8];
    uint32_t hdr_revision;
    uint32_t hdr_size;
    uint32_t hdr_crc_self;
    uint32_t __reserved;
    uint64_t hdr_lba_self;
    uint64_t hdr_lba_alt;
    uint64_t hdr_lba_start;
    uint64_t hdr_lba_end;
    uuid_t   hdr_uuid;
    uint64_t hdr_lba_table;
    uint32_t hdr_entries;
    uint32_t hdr_entsz;
    uint32_t hdr_crc_table;
    uint32_t padding;
};

/* Partition map entry. */

struct gpt_ent
{
    uuid_t   ent_type;
    uuid_t   ent_uuid;
    uint64_t ent_lba_start;
    uint64_t ent_lba_end;
    uint64_t ent_attr;
    uint16_t ent_name[36];
};

/* Partition map signature (hdr_sig). */

#define GPT_HDR_SIG "EFI PART"

/* Partition map version (hdr_revision). */

#define GPT_HDR_REVISION 0x00010000

/* Partition map entry flags (ent_attr). */

#define GPT_ENT_ATTR_PLATFORM 0x00000001

#pragma pack(pop)                        /* (reset to default struct packing) */

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOPartitionScheme.h>

/*
 * Class
 */

class IOGUIDPartitionScheme : public IOPartitionScheme
{
    OSDeclareDefaultStructors(IOGUIDPartitionScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    OSSet * _partitions;    /* (set of media objects representing partitions) */

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free(void);

    /*
     * Scan the provider media for a GUID partition map.    Returns the set
     * of media objects representing each of the partitions (the retain for
     * the set is passed to the caller), or null should no partition map be
     * found.  The default probe score can be adjusted up or down, based on
     * the confidence of the scan.
     */

    virtual OSSet * scan(SInt32 * score);

    /*
     * Ask whether the given partition is used.
     */

    virtual bool isPartitionUsed(gpt_ent * partition);

    /*
     * Ask whether the given partition appears to be corrupt. A partition that
     * is corrupt will cause the failure of the GUID partition map recognition
     * altogether.
     */

    virtual bool isPartitionCorrupt( gpt_ent * partition,
                                     UInt32    partitionID );

    /*
     * Ask whether the given partition appears to be invalid.  A partition that
     * is invalid will cause it to be skipped in the scan, but will not cause a
     * failure of the GUID partition map recognition.
     */

    virtual bool isPartitionInvalid( gpt_ent * partition,
                                     UInt32    partitionID );

    /*
     * Instantiate a new media object to represent the given partition.
     */

    virtual IOMedia * instantiateMediaObject( gpt_ent * partition,
                                              UInt32    partitionID );

    /*
     * Allocate a new media object (called from instantiateMediaObject).
     */

    virtual IOMedia * instantiateDesiredMediaObject( gpt_ent * partition,
                                                     UInt32    partitionID );

public:

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*
     * Determine whether the provider media contains a GUID partition map.
     */

    virtual IOService * probe(IOService * provider, SInt32 * score);

    /*
     * Publish the new media objects which represent our partitions.
     */

    virtual bool start(IOService * provider);

    /*
     * Clean up after the media objects we published before terminating.
     */

    virtual void stop(IOService * provider);

    /*
     * Request that the provider media be re-scanned for partitions.
     */

    virtual IOReturn requestProbe(IOOptionBits options);

    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  0);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  1);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  2);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  3);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  4);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  5);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  6);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  7);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  8);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme,  9);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme, 10);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme, 11);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme, 12);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme, 13);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme, 14);
    OSMetaClassDeclareReservedUnused(IOGUIDPartitionScheme, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOGUIDPARTITIONSCHEME_H */
                                                                                                                                                                                                                                                                                                IOMedia.h                                                                                           0100644 0001750 0001750 00000060222 12567452411 035110  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOMedia
 * @abstract
 * This header contains the IOMedia class definition.
 */

#ifndef _IOMEDIA_H
#define _IOMEDIA_H

#include <IOKit/IOTypes.h>

/*!
 * @defined kIOMediaClass
 * @abstract
 * The name of the IOMedia class.
 */

#define kIOMediaClass "IOMedia"

/*!
 * @defined kIOMediaContentKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaContentKey property has an OSString
 * value and contains a description of the media's
 * contents.  The description is the same as the hint at the time of the
 * object's creation, but it is possible that the description has been overridden
 * by a client (which has probed the media and identified the content correctly)
 * of the media object.  It is more accurate than the hint for this reason.  The
 * string is formed in the likeness of Apple's "Apple_HFS" strings or in the
 * likeness of a UUID.
 */

#define kIOMediaContentKey "Content"

/*!
 * @defined kIOMediaContentHintKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaContentHintKey property has an OSString
 * value and contains a hint of the media's contents.
 * The hint is set at the time of the object's creation, should the creator have
 * a clue as to what it may contain.  The hint string does not change for the
 * lifetime of the object and is formed in the likeness of Apple's "Apple_HFS"
 * strings or in the likeness of a UUID.
 */

#define kIOMediaContentHintKey "Content Hint"

/*!
 * @defined kIOMediaEjectableKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaEjectableKey property has an OSBoolean
 * value and describes whether the media is ejectable
 * from the drive mechanism under software control.  Implies IOMediaRemovable
 * is also true.
 */

#define kIOMediaEjectableKey "Ejectable"

/*!
 * @defined kIOMediaLeafKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaLeafKey property has an OSBoolean value and describes whether the media is a leaf, that is,
 * it is the deepest media object in this branch of the I/O Registry.
 */

#define kIOMediaLeafKey "Leaf"

/*!
 * @defined kIOMediaOpenKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaOpenKey property has an OSBoolean value and describes whether
 * a client presently has an open on this media.
 */

#define kIOMediaOpenKey "Open"

/*!
 * @defined kIOMediaPreferredBlockSizeKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaPreferredBlockSizeKey property has an
 * OSNumber value and describes the media's natural
 * block size in bytes.  This information is useful to clients that want to
 * optimize access to the media.
 */

#define kIOMediaPreferredBlockSizeKey "Preferred Block Size"

/*!
 * @defined kIOMediaRemovableKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaRemovableKey property has an OSBoolean
 * value and describes whether the media is removable
 * from the drive mechanism.
 */

#define kIOMediaRemovableKey "Removable"

/*!
 * @defined kIOMediaSizeKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaSizeKey property has an OSNumber value and describes the total length of the media in
 * bytes.
 */

#define kIOMediaSizeKey "Size"

/*!
 * @defined kIOMediaUUIDKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaUUIDKey property has an OSString value and contains a persistent
 * Universal Unique Identifier for the media if such an identifier is available.
 */

#define kIOMediaUUIDKey "UUID"

/*!
 * @defined kIOMediaWholeKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaWholeKey property has an OSBoolean
 * value and describes whether the media is whole, that is,
 * it represents the whole disk (the physical disk, or a virtual replica
 * thereof).
 */

#define kIOMediaWholeKey "Whole"

/*!
 * @defined kIOMediaWritableKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaWritableKey property has an OSBoolean
 * value and describes whether the media is writable.
 */

#define kIOMediaWritableKey "Writable"

/*!
 * @defined kIOMediaContentMaskKey
 * @abstract
 * A property of IOMedia clients.
 * @discussion
 * The kIOMediaContentMaskKey property has an OSString
 * value and must exist in all IOMedia clients that
 * drive new content (that is, produce new media objects).  When the client
 * matches against the provider media, the value of the client's
 * kIOMediaContentMaskKey property is used to replace the provider's
 * kIOMediaContentKey property.
 */

#define kIOMediaContentMaskKey "Content Mask"

/*!
 * @defined kIOMediaIconKey
 * @abstract
 * A property of any object in the media stack.
 * @discussion
 * kIOMediaIconKey is a property of any object in the media stack that wishes
 * to override the default icon shown for the media objects in the stack.  It
 * is usually defined in a provider object below the media object.  It has an
 * OSDictionary value, with properties identical to the kIOIconKey definition,
 * that is, kCFBundleIdentifierKey and kIOBundleResourceFileKey.
 */

#define kIOMediaIconKey "IOMediaIcon"

/*!
 * @enum IOMediaAttributeMask
 * @discussion
 * The IOMediaAttributeMask bit mask describes various attributes of
 * the media object, such as its ejectability and its removability.
 * @constant kIOMediaAttributeEjectableMask
 * Indicates whether the media is ejectable from the drive mechanism
 * under software control.  Implies kIOMediaAttributeRemovableMask.
 * @constant kIOMediaAttributeRemovableMask
 * Indicates whether the media is removable from the drive mechanism.
 */

enum
{
    kIOMediaAttributeEjectableMask = 0x00000001,
    kIOMediaAttributeRemovableMask = 0x00000002,
    kIOMediaAttributeReservedMask  = 0xFFFFFFFC
};

typedef UInt32 IOMediaAttributeMask;

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOStorage.h>

/*!
 * @class IOMedia
 * @abstract
 * A random-access disk device abstraction.
 * @discussion
 * The IOMedia class is a random-access disk device abstraction.   It provides a
 * consistent interface for both real and virtual disk devices, for subdivisions
 * of disks such as partitions, for supersets of disks such as RAID volumes, and
 * so on.   It extends the IOStorage class by implementing the appropriate open,
 * close, read, write, and matching semantics for media objects.  The properties
 * it has reflect the properties of real disk devices,  such as ejectability and
 * writability.
 *
 * The read and write interfaces support byte-level access to the storage space,
 * with the appropriate deblocking handled by the block storage driver, however,
 * a typical client will want to get the natural block size in order to optimize
 * access to the real disk device.  A read or write is accepted so long as the
 * client's access is valid, the media is formatted and the transfer is within
 * the bounds of the media.  An optional non-zero base (offset) is then applied
 * before the read or write is passed to the provider object.
 */

class IOMedia : public IOStorage
{
    OSDeclareDefaultStructors(IOMedia)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    UInt32          _attributes;

    bool            _isWhole;
    bool            _isWritable;

    UInt64          _mediaBase;  /* (relative to the storage object below us) */
    UInt64          _mediaSize;

    IOStorageAccess _openLevel;
    OSDictionary *  _openClients;

    UInt32          _reserved0320;

    UInt64          _preferredBlockSize;

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free();

    /*!
     * @function handleOpen
     * @discussion
     * The handleOpen method grants or denies permission to access this object
     * to an interested client.  The argument is an IOStorageAccess value that
     * specifies the level of access desired -- reader or reader-writer.
     *
     * This method can be invoked to upgrade or downgrade the access level for
     * an existing client as well.  The previous access level will prevail for
     * upgrades that fail, of course.   A downgrade should never fail.  If the
     * new access level should be the same as the old for a given client, this
     * method will do nothing and return success.  In all cases, one, singular
     * close-per-client is expected for all opens-per-client received.
     *
     * This implementation replaces the IOService definition of handleOpen().
     * @param client
     * Client requesting the open.
     * @param options
     * Options for the open.  Set to zero.
     * @param access
     * Access level for the open.  Set to kIOStorageAccessReader or
     * kIOStorageAccessReaderWriter.
     * @result
     * Returns true if the open was successful, false otherwise.
     */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       access);

    /*!
     * @function handleIsOpen
     * @discussion
     * The handleIsOpen method determines whether the specified client, or any
     * client if none is specified, presently has an open on this object.
     *
     * This implementation replaces the IOService definition of handleIsOpen().
     * @param client
     * Client to check the open state of.  Set to zero to check the open state
     * of all clients.
     * @result
     * Returns true if the client was (or clients were) open, false otherwise.
     */

    virtual bool handleIsOpen(const IOService * client) const;

    /*!
     * @function handleClose
     * @discussion
     * The handleClose method closes the client's access to this object.
     *
     * This implementation replaces the IOService definition of handleClose().
     * @param client
     * Client requesting the close.
     * @param options
     * Options for the close.  Set to zero.
     */

    virtual void handleClose(IOService * client, IOOptionBits options);

public:

    using IOStorage::read;
    using IOStorage::write;

    /*
     * This method is called for each client interested in the services we
     * provide.  The superclass links us as a parent to this client in the
     * I/O Kit registry on success.
     */

    virtual bool attachToChild(IORegistryEntry *       client,
                               const IORegistryPlane * plane);

    /*
     * This method is called for each client that loses interest in the
     * services we provide.  The superclass unlinks us from this client
     * in the I/O Kit registry on success.
     */

    virtual void detachFromChild(IORegistryEntry *       client,
                                 const IORegistryPlane * plane);

    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of OSObject -- IOStorage.  This method
     * serves simply as a convenience to subclass developers.
     */

    virtual IOStorage * getProvider() const;

    /*
     * Compare the properties in the supplied table to this object's properties.
     */

    virtual bool matchPropertyTable(OSDictionary * table, SInt32 * score);

    /*!
     * @function read
     * @discussion
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, asynchronously.   When the read completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the read.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion);

    /*!
     * @function write
     * @discussion
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, asynchronously.   When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion);

    /*!
     * @function synchronize
     * @discussion
     * Flush the cached data in the storage object, if any.
     * @param client
     * Client requesting the synchronization.
     * @param byteStart
     * Starting byte offset for the synchronization.
     * @param byteCount
     * Size of the synchronization.  Set to zero to specify the end-of-media.
     * @param options
     * Options for the synchronization.  See IOStorageSynchronizeOptions.
     * @result
     * Returns the status of the synchronization.
     */

    virtual IOReturn synchronize(IOService *                 client,
                                 UInt64                      byteStart,
                                 UInt64                      byteCount,
                                 IOStorageSynchronizeOptions options = 0);

    /*!
     * @function unmap
     * @discussion
     * Delete unused data from the storage object at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param options
     * Options for the unmap.  See IOStorageUnmapOptions.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn unmap(IOService *           client,
                           IOStorageExtent *     extents,
                           UInt32                extentsCount,
                           IOStorageUnmapOptions options = 0);

    /*!
     * @function lockPhysicalExtents
     * @discussion
     * Lock the contents of the storage object against relocation temporarily,
     * for the purpose of getting physical extents.
     * @param client
     * Client requesting the operation.
     * @result
     * Returns true if the lock was successful, false otherwise.
     */

    virtual bool lockPhysicalExtents(IOService * client);

    /*!
     * @function copyPhysicalExtent
     * @discussion
     * Convert the specified byte offset into a physical byte offset, relative
     * to a physical storage object.  This call should only be made within the
     * context of lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     * @param byteStart
     * Starting byte offset for the operation.  Returns a physical byte offset,
     * relative to the physical storage object, on success.
     * @param byteCount
     * Size of the operation.  Returns the actual number of bytes which can be
     * transferred, relative to the physical storage object, on success. 
     * @result
     * A reference to the physical storage object, which should be released by
     * the caller, or a null on error.
     */

    virtual IOStorage * copyPhysicalExtent(IOService * client,
                                           UInt64 *    byteStart,
                                           UInt64 *    byteCount);

    /*!
     * @function unlockPhysicalExtents
     * @discussion
     * Unlock the contents of the storage object for relocation again.  This
     * call must balance a successful call to lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     */

    virtual void unlockPhysicalExtents(IOService * client);

    /*!
     * @function setPriority
     * @discussion
     * Reprioritize read or write requests at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param priority
     * New priority.  See IOStoragePriority.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setPriority(IOService *       client,
                                 IOStorageExtent * extents,
                                 UInt32            extentsCount,
                                 IOStoragePriority priority);

    /*!
     * @function getPreferredBlockSize
     * @discussion
     * Ask the media object for its natural block size.  This information
     * is useful to clients that want to optimize access to the media.
     * @result
     * Natural block size, in bytes.
     */

    virtual UInt64 getPreferredBlockSize() const;

    /*!
     * @function getSize
     * @discussion
     * Ask the media object for its total length in bytes.
     * @result
     * Media size, in bytes.
     */

    virtual UInt64 getSize() const;

    /*!
     * @function getBase
     * @discussion
     * Ask the media object for its byte offset relative to the provider media.
     * @result
     * Media offset, in bytes.
     */

    virtual UInt64 getBase() const;

    /*!
     * @function isEjectable
     * @discussion
     * Ask the media object whether it is ejectable.
     * @result
     * Returns true if the media is ejectable, false otherwise.
     */

    virtual bool isEjectable() const;

    /*!
     * @function isFormatted
     * @discussion
     * Ask the media object whether it is formatted.
     * @result
     * Returns true if the media is formatted, false otherwise.
     */

    virtual bool isFormatted() const;

    /*!
     * @function isWhole
     * @discussion
     * Ask the media object whether it represents the whole disk.
     * @result
     * Returns true if the media represents the whole disk, false otherwise.
     */

    virtual bool isWhole() const;

    /*!
     * @function isWritable
     * @discussion
     * Ask the media object whether it is writable.
     * @result
     * Returns true if the media is writable, false otherwise.
     */

    virtual bool isWritable() const;

    /*!
     * @function getContent
     * @discussion
     * Ask the media object for a description of its contents.  The description
     * is the same as the hint at the time of the object's creation,  but it is
     * possible that the description has been overridden by a client (which has probed
     * the media and identified the content correctly) of the media object.  It
     * is more accurate than the hint for this reason.  The string is formed in
     * the likeness of Apple's "Apple_HFS" strings or in the likeness of a UUID.
     *
     * The content description can be overridden by any client that matches onto
     * this media object with a match category of kIOStorageCategory.  The media
     * object checks for a kIOMediaContentMaskKey property in the client, and if
     * it finds one, it copies it into kIOMediaContentKey property.
     * @result
     * Description of media's contents.
     */

    virtual const char * getContent() const;

    /*!
     * @function getContentHint
     * @discussion
     * Ask the media object for a hint of its contents.  The hint is set at the
     * time of the object's creation, should the creator have a clue as to what
     * it may contain.  The hint string does not change for the lifetime of the
     * object and is also formed in the likeness of Apple's "Apple_HFS" strings
     * or in the likeness of a UUID.
     * @result
     * Hint of media's contents.
     */

    virtual const char * getContentHint() const;

    /*!
     * @function init
     * @discussion
     * Initialize this object's minimal state.
     * @param base
     * Media offset, in bytes.
     * @param size
     * Media size, in bytes.
     * @param preferredBlockSize
     * Natural block size, in bytes.
     * @param attributes
     * Media attributes, such as ejectability and removability.  See
     * IOMediaAttributeMask.
     * @param isWhole
     * Indicates whether the media represents the whole disk.
     * @param isWritable
     * Indicates whether the media is writable.
     * @param contentHint
     * Hint of media's contents (optional).  See getContentHint().
     * @param properties
     * Substitute property table for this object (optional).
     * @result
     * Returns true on success, false otherwise.
     */

    virtual bool init(UInt64               base,
                      UInt64               size,
                      UInt64               preferredBlockSize,
                      IOMediaAttributeMask attributes,
                      bool                 isWhole,
                      bool                 isWritable,
                      const char *         contentHint = 0,
                      OSDictionary *       properties  = 0);

    /*!
     * @function getAttributes
     * @discussion
     * Ask the media object for its attributes.
     * @result
     * Media attributes, such as ejectability and removability.  See
     * IOMediaAttributeMask.
     */

    virtual IOMediaAttributeMask getAttributes() const;

    OSMetaClassDeclareReservedUnused(IOMedia,  0);
    OSMetaClassDeclareReservedUnused(IOMedia,  1);
    OSMetaClassDeclareReservedUnused(IOMedia,  2);
    OSMetaClassDeclareReservedUnused(IOMedia,  3);
    OSMetaClassDeclareReservedUnused(IOMedia,  4);
    OSMetaClassDeclareReservedUnused(IOMedia,  5);
    OSMetaClassDeclareReservedUnused(IOMedia,  6);
    OSMetaClassDeclareReservedUnused(IOMedia,  7);
    OSMetaClassDeclareReservedUnused(IOMedia,  8);
    OSMetaClassDeclareReservedUnused(IOMedia,  9);
    OSMetaClassDeclareReservedUnused(IOMedia, 10);
    OSMetaClassDeclareReservedUnused(IOMedia, 11);
    OSMetaClassDeclareReservedUnused(IOMedia, 12);
    OSMetaClassDeclareReservedUnused(IOMedia, 13);
    OSMetaClassDeclareReservedUnused(IOMedia, 14);
    OSMetaClassDeclareReservedUnused(IOMedia, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOMEDIA_H */
                                                                                                                                                                                                                                                                                                                                                                              IOMediaBSDClient.h                                                                                  0100644 0001750 0001750 00000010006 12567452411 036573  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOMEDIABSDCLIENT_H
#define _IOMEDIABSDCLIENT_H

#include <sys/disk.h>

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <sys/conf.h>
#include <IOKit/storage/IOMedia.h>

class  AnchorTable;
class  MinorTable;
struct MinorSlot;

UInt64 _IOMediaBSDClientGetThrottleMask(IOMedia * media);

/*
 * Class
 */

class IOMediaBSDClient : public IOService
{
    OSDeclareDefaultStructors(IOMediaBSDClient)

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

private:

    AnchorTable * _anchors;
    UInt32        _reserved0064 __attribute__ ((unused));
    UInt32        _reserved0096 __attribute__ ((unused));
    MinorTable *  _minors;
    UInt32        _reserved0160 __attribute__ ((unused));

protected:

    /*
     * Find the whole media that roots the given media tree.
     */

    virtual IOMedia * getWholeMedia( IOMedia * media,
                                     UInt32 *  slicePathSize = 0,
                                     char *    slicePath     = 0 );

    /*
     * Create bdevsw and cdevsw nodes for the given media object.
     */

    virtual bool createNodes(IOMedia * media);

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free();

public:

    /*
     * Obtain this object's provider.  We override the superclass's method to
     * return a more specific subclass of IOService -- IOMedia.   This method
     * method serves simply as a convenience to subclass developers.
     */

    virtual IOMedia * getProvider() const;

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties  = 0);

    /*
     * This method is called once we have been attached to the provider object.
     */

    virtual bool start(IOService * provider);

    /*
     * This method is called when we are to terminate from the provider object.
     */

    virtual bool terminate(IOOptionBits options);

    /*
     * Process a foreign ioctl.
     */

    virtual int ioctl(dev_t dev, u_long cmd, caddr_t data, int flags, proc_t proc);

    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  0);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  1);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  2);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  3);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  4);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  5);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  6);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  7);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  8);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient,  9);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient, 10);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient, 11);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient, 12);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient, 13);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient, 14);
    OSMetaClassDeclareReservedUnused(IOMediaBSDClient, 15);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOMEDIABSDCLIENT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          IOPartitionScheme.h                                                                                 0100644 0001750 0001750 00000041000 12567452411 037160  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOPartitionScheme
 * @abstract
 * This header contains the IOPartitionScheme class definition.
 */

#ifndef _IOPARTITIONSCHEME_H
#define _IOPARTITIONSCHEME_H

/*!
 * @defined kIOPartitionSchemeClass
 * @abstract
 * The name of the IOPartitionScheme class.
 * @discussion
 * kIOPartitionSchemeClass is the name of the IOPartitionScheme class.
 */

#define kIOPartitionSchemeClass "IOPartitionScheme"

/*!
 * @defined kIOMediaBaseKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaBaseKey property has an OSNumber value and is placed into an
 * IOMedia instance created via the partition scheme. It describes the byte
 * offset of the partition relative to the provider media.
 */

#define kIOMediaBaseKey "Base"

/*!
 * @defined kIOMediaLiveKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaLiveKey property has an OSBoolean
 * value and is placed into an IOMedia instance
 * created via the partition scheme.  It describes whether the
 * partition is live, that is, it is up-to-date with respect
 * to the on-disk partition table.
 */

#define kIOMediaLiveKey "Live"

/*!
 * @defined kIOMediaPartitionIDKey
 * @abstract
 * A property of IOMedia objects.
 * @discussion
 * The kIOMediaPartitionIDKey property has an OSNumber
 * value and is placed into an IOMedia instance
 * created via the partition scheme.  It is an ID that differentiates one 
 * partition from the other (within a given scheme).  It is typically an index
 * into the on-disk partition table.
 */

#define kIOMediaPartitionIDKey "Partition ID"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/storage/IOMedia.h>
#include <IOKit/storage/IOStorage.h>

/*!
 * @class IOPartitionScheme
 * @abstract
 * The common base class for all partition scheme
 * objects.
 * @discussion
 * The IOPartitionScheme class is the common base class for all partition scheme
 * objects.  It extends the IOStorage class by implementing the appropriate open
 * and close semantics for partition objects (standard semantics are to act as a
 * multiplexor for incoming opens,  producing one outgoing open with the correct
 * access).  It also implements the default read and write semantics, which pass
 * all reads and writes through to the provider media unprocessed.    For simple
 * schemes, the default behavior is sufficient.   More complex partition schemes
 * such as RAID will want to do extra processing for reads and writes.
 */

class IOPartitionScheme : public IOStorage
{
    OSDeclareDefaultStructors(IOPartitionScheme);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    IOStorageAccess _openLevel;
    OSSet *         _openReaders;
    OSSet *         _openReaderWriters;

    /*
     * Free all of this object's outstanding resources.
     */

    virtual void free();

    /*!
     * @function handleOpen
     * @discussion
     * The handleOpen method grants or denies permission to access this object
     * to an interested client.  The argument is an IOStorageAccess value that
     * specifies the level of access desired -- reader or reader-writer.
     *
     * This method can be invoked to upgrade or downgrade the access level for
     * an existing client as well.  The previous access level will prevail for
     * upgrades that fail, of course.   A downgrade should never fail.  If the
     * new access level should be the same as the old for a given client, this
     * method will do nothing and return success.  In all cases, one, singular
     * close-per-client is expected for all opens-per-client received.
     *
     * This implementation replaces the IOService definition of handleOpen().
     * @param client
     * Client requesting the open.
     * @param options
     * Options for the open.  Set to zero.
     * @param access
     * Access level for the open.  Set to kIOStorageAccessReader or
     * kIOStorageAccessReaderWriter.
     * @result
     * Returns true if the open was successful, false otherwise.
     */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       access);

    /*!
     * @function handleIsOpen
     * @discussion
     * The handleIsOpen method determines whether the specified client, or any
     * client if none is specified, presently has an open on this object.
     *
     * This implementation replaces the IOService definition of handleIsOpen().
     * @param client
     * Client to check the open state of.  Set to zero to check the open state
     * of all clients.
     * @result
     * Returns true if the client was (or clients were) open, false otherwise.
     */

    virtual bool handleIsOpen(const IOService * client) const;

    /*!
     * @function handleClose
     * @discussion
     * The handleClose method closes the client's access to this object.
     *
     * This implementation replaces the IOService definition of handleClose().
     * @param client
     * Client requesting the close.
     * @param options
     * Options for the close.  Set to zero.
     */

    virtual void handleClose(IOService * client, IOOptionBits options);

    /*
     * Attach the given media object to the device tree plane.
     */

    virtual bool attachMediaObjectToDeviceTree(IOMedia * media);

    /*
     * Detach the given media object from the device tree plane.
     */

    virtual void detachMediaObjectFromDeviceTree(IOMedia * media);

    /*
     * Updates a set of existing partitions, represented by partitionsOld,
     * with possible updates from a rescan of the disk, represented by
     * partitionsNew.  It returns a new set of partitions with the results,
     * removing partitions from partitionsOld where applicable, adding
     * partitions from partitionsNew where applicable, and folding in property
     * changes to partitions from partitionsNew into partitionsOld where
     * applicable.
     */

    virtual OSSet * juxtaposeMediaObjects(OSSet * partitionsOld,
                                          OSSet * partitionsNew);

public:

    using IOStorage::read;
    using IOStorage::write;

    /*
     * Initialize this object's minimal state.
     */

    virtual bool init(OSDictionary * properties = 0);

    /*!
     * @function read
     * @discussion
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, asynchronously.   When the read completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the read.
     *
     * For simple partition schemes, the default behavior is to simply pass the
     * read through to the provider media.  More complex partition schemes such
     * as RAID will need to do extra processing here.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion);

    /*!
     * @function write
     * @discussion
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, asynchronously.   When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     *
     * For simple partition schemes, the default behavior is to simply pass the
     * write through to the provider media. More complex partition schemes such
     * as RAID will need to do extra processing here.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion);

    /*!
     * @function synchronize
     * @discussion
     * Flush the cached data in the storage object, if any.
     * @param client
     * Client requesting the synchronization.
     * @param byteStart
     * Starting byte offset for the synchronization.
     * @param byteCount
     * Size of the synchronization.  Set to zero to specify the end-of-media.
     * @param options
     * Options for the synchronization.  See IOStorageSynchronizeOptions.
     * @result
     * Returns the status of the synchronization.
     */

    virtual IOReturn synchronize(IOService *                 client,
                                 UInt64                      byteStart,
                                 UInt64                      byteCount,
                                 IOStorageSynchronizeOptions options = 0);

    /*!
     * @function unmap
     * @discussion
     * Delete unused data from the storage object at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param options
     * Options for the unmap.  See IOStorageUnmapOptions.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn unmap(IOService *           client,
                           IOStorageExtent *     extents,
                           UInt32                extentsCount,
                           IOStorageUnmapOptions options = 0);

    /*!
     * @function lockPhysicalExtents
     * @discussion
     * Lock the contents of the storage object against relocation temporarily,
     * for the purpose of getting physical extents.
     * @param client
     * Client requesting the operation.
     * @result
     * Returns true if the lock was successful, false otherwise.
     */

    virtual bool lockPhysicalExtents(IOService * client);

    /*!
     * @function copyPhysicalExtent
     * @discussion
     * Convert the specified byte offset into a physical byte offset, relative
     * to a physical storage object.  This call should only be made within the
     * context of lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     * @param byteStart
     * Starting byte offset for the operation.  Returns a physical byte offset,
     * relative to the physical storage object, on success.
     * @param byteCount
     * Size of the operation.  Returns the actual number of bytes which can be
     * transferred, relative to the physical storage object, on success. 
     * @result
     * A reference to the physical storage object, which should be released by
     * the caller, or a null on error.
     */

    virtual IOStorage * copyPhysicalExtent(IOService * client,
                                           UInt64 *    byteStart,
                                           UInt64 *    byteCount);

    /*!
     * @function unlockPhysicalExtents
     * @discussion
     * Unlock the contents of the storage object for relocation again.  This
     * call must balance a successful call to lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     */

    virtual void unlockPhysicalExtents(IOService * client);

    /*!
     * @function setPriority
     * @discussion
     * Reprioritize read or write requests at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param priority
     * New priority.  See IOStoragePriority.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setPriority(IOService *       client,
                                 IOStorageExtent * extents,
                                 UInt32            extentsCount,
                                 IOStoragePriority priority);

    /*
     * Obtain this object's provider.  We override the superclass's method
     * to return a more specific subclass of OSObject -- an IOMedia.  This
     * method serves simply as a convenience to subclass developers.
     */

    virtual IOMedia * getProvider() const;

    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  0);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  1);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  2);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  3);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  4);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  5);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  6);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  7);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  8);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme,  9);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 10);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 11);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 12);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 13);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 14);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 15);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 16);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 17);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 18);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 19);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 20);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 21);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 22);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 23);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 24);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 25);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 26);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 27);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 28);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 29);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 30);
    OSMetaClassDeclareReservedUnused(IOPartitionScheme, 31);
};

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOPARTITIONSCHEME_H */
IOStorage.h                                                                                         0100644 0001750 0001750 00000061640 12567452411 035502  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOStorage
 * @abstract
 * This header contains the IOStorage class definition.
 */

#ifndef _IOSTORAGE_H
#define _IOSTORAGE_H

#include <sys/kernel_types.h>
#include <IOKit/IOTypes.h>

/*!
 * @defined kIOStorageClass
 * @abstract
 * The name of the IOStorage class.
 */

#define kIOStorageClass "IOStorage"

/*!
 * @defined kIOStorageCategory
 * @abstract
 * kIOStorageCategory is a value for IOService's kIOMatchCategoryKey property.
 * @discussion
 * The kIOStorageCategory value is the standard value for the IOService property
 * kIOMatchCategoryKey ("IOMatchCategory") for all storage drivers.  All storage
 * objects that expect to drive new content (that is, produce new media objects)
 * are expected to compete within the kIOStorageCategory namespace.
 *
 * See the IOService documentation for more information on match categories.
 */

#define kIOStorageCategory "IOStorage"                /* (as IOMatchCategory) */

/*!
 * @defined kIOStorageFeaturesKey
 * @abstract
 * A property of any object in the storage stack.
 * @discussion
 * kIOStorageFeaturesKey is a property of any object in the storage stack that
 * wishes to express support of additional features, such as Force Unit Access.
 * It is typically defined in the device object below the block storage driver
 * object.  It has an OSDictionary value, where each entry describes one given
 * feature.
 */

#define kIOStorageFeaturesKey "IOStorageFeatures"

/*!
 * @defined kIOStorageFeatureBarrier
 * @abstract
 * Describes the presence of the Barrier feature.
 * @discussion
 * This property describes the ability of the storage stack to honor a write
 * barrier, guaranteeing that on power loss, writes after the barrier will not
 * be visible until all writes before the barrier are visible.  It is one of the
 * feature entries listed under the top-level kIOStorageFeaturesKey property
 * table.  It has an OSBoolean value.
 */

#define kIOStorageFeatureBarrier "Barrier"

/*!
 * @defined kIOStorageFeatureForceUnitAccess
 * @abstract
 * Describes the presence of the Force Unit Access feature.
 * @discussion
 * This property describes the ability of the storage stack to force a request
 * to access the media.  It is one of the feature entries listed under the top-
 * level kIOStorageFeaturesKey property table.  It has an OSBoolean value.
 */

#define kIOStorageFeatureForceUnitAccess "Force Unit Access"

/*!
 * @defined kIOStorageFeaturePriority
 * @abstract
 * Describes the presence of the Priority feature.
 * @discussion
 * This property describes the ability of the storage stack to enforce the
 * priority of a request.  It is one of the feature entries listed under the
 * top-level kIOStorageFeaturesKey property table.  It has an OSBoolean value.
 */

#define kIOStorageFeaturePriority "Priority"

/*!
 * @defined kIOStorageFeatureUnmap
 * @abstract
 * Describes the presence of the Unmap feature.
 * @discussion
 * This property describes the ability of the storage stack to delete unused
 * data from the media.  It is one of the feature entries listed under the top-
 * level kIOStorageFeaturesKey property table.  It has an OSBoolean value.
 */

#define kIOStorageFeatureUnmap "Unmap"

#ifdef KERNEL
#ifdef __cplusplus

/*
 * Kernel
 */

#include <IOKit/assert.h>
#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/IOService.h>

/*!
 * @enum IOStorageAccess
 * @discussion
 * The IOStorageAccess enumeration describes the possible access levels for open
 * requests.
 * @constant kIOStorageAccessNone
 * No access is requested; should not be passed to open().
 * @constant kIOStorageAccessReader
 * Read-only access is requested.
 * @constant kIOStorageAccessReaderWriter
 * Read and write access is requested.
 * @constant kIOStorageAccessSharedLock
 * Shared access is requested.
 * @constant kIOStorageAccessExclusiveLock
 * Exclusive access is requested.
 */

enum
{
    kIOStorageAccessNone          = 0x00,
    kIOStorageAccessReader        = 0x01,
    kIOStorageAccessReaderWriter  = 0x03,
    kIOStorageAccessSharedLock    = 0x04,
    kIOStorageAccessExclusiveLock = 0x08
};

typedef UInt32 IOStorageAccess;

/*!
 * @enum IOStorageOptions
 * @discussion
 * Options for read and write storage requests.
 * @constant kIOStorageOptionForceUnitAccess
 * Force the request to access the media.
 * @constant kIOStorageOptionIsEncrypted
 * The data is already encrypted.
 * @constant kIOStorageOptionIsStatic
 * The data is likely to remain unaltered.
 */

enum
{
    kIOStorageOptionNone            = 0x0000,
    kIOStorageOptionForceUnitAccess = 0x0001,
    kIOStorageOptionIsEncrypted     = 0x0010,
    kIOStorageOptionIsStatic        = 0x0020,
    kIOStorageOptionReserved        = 0xFFCE
};

typedef UInt16 IOStorageOptions;

/*!
 * @enum IOStoragePriority
 * @discussion
 * Priority of read and write storage requests.  The lower the value, the
 * higher the priority.
 * @constant kIOStoragePriorityHigh
 * This priority should only be used for I/O that is critical to system
 * responsiveness.
 * @constant kIOStoragePriorityDefault
 * This priority is for work requested by the user, but that is not the user's
 * current focus.
 * @constant kIOStoragePriorityLow
 * This priority is for short-running background work.
 * @constant kIOStoragePriorityBackground
 * This priority is for long-running, I/O intensive background work, such as
 * backups, search indexing, or file synchronization.
 */

enum
{
    kIOStoragePriorityHigh       =  63,                         /*   0 to  63 */
    kIOStoragePriorityDefault    = 127,                         /*  64 to 127 */
    kIOStoragePriorityLow        = 191,                         /* 128 to 191 */
    kIOStoragePriorityBackground = 255                          /* 192 to 255 */
};

typedef UInt8 IOStoragePriority;

/*!
 * @enum IOStorageSynchronizeOptions
 * @discussion
 * Options for synchronize storage requests.
 * @constant kIOStorageSynchronizeOptionBarrier
 * Issue a write barrier only.
 */

enum
{
    kIOStorageSynchronizeOptionNone     = 0x00000000,
    kIOStorageSynchronizeOptionBarrier  = 0x00000002,
    kIOStorageSynchronizeOptionReserved = 0xFFFFFFFD
};

typedef UInt32 IOStorageSynchronizeOptions;

/*!
 * @enum IOStorageUnmapOptions
 * @discussion
 * Options for unmap storage requests.
 */

enum
{
    kIOStorageUnmapOptionReserved = 0xFFFFFFFF
};

typedef UInt32 IOStorageUnmapOptions;

/*!
 * @struct IOStorageAttributes
 * @discussion
 * Attributes of read and write storage requests.
 * @field options
 * Options for the request.  See IOStorageOptions.
 * @field priority
 * Priority of the request.  See IOStoragePriority.
 * @field bufattr
 * Reserved for future use.  Set to zero.
 */

struct IOStorageAttributes
{
    IOStorageOptions  options;
    IOStoragePriority priority;
    UInt8             reserved0024;
    UInt32            reserved0032;
    UInt64            reserved0064;
    UInt64            reserved0128;
    bufattr_t         bufattr;
#if TARGET_OS_EMBEDDED
    UInt64            adjustedOffset;
#endif /* TARGET_OS_EMBEDDED */
};

/*!
 * @struct IOStorageExtent
 * @discussion
 * Extent for unmap storage requests.
 * @field byteStart
 * Starting byte offset for the operation.
 * @field byteCoun