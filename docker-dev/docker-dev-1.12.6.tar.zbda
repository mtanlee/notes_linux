nature):
        l = ['AWS4-HMAC-SHA256 Credential=%s' % self.scope(request)]
        headers_to_sign = self.headers_to_sign(request)
        l.append('SignedHeaders=%s' % self.signed_headers(headers_to_sign))
        l.append('Signature=%s' % signature)
        request.headers['Authorization'] = ', '.join(l)
        return request

    def _modify_request_before_signing(self, request):
        if 'Authorization' in request.headers:
            del request.headers['Authorization']
        self._set_necessary_date_headers(request)
        if self.credentials.token:
            if 'X-Amz-Security-Token' in request.headers:
                del request.headers['X-Amz-Security-Token']
            request.headers['X-Amz-Security-Token'] = self.credentials.token

    def _set_necessary_date_headers(self, request):
        # The spec allows for either the Date _or_ the X-Amz-Date value to be
        # used so we check both.  If there's a Date header, we use the date
        # header.  Otherwise we use the X-Amz-Date header.
        if 'Date' in request.headers:
            del request.headers['Date']
            datetime_timestamp = datetime.datetime.strptime(
                request.context['timestamp'], SIGV4_TIMESTAMP)
            request.headers['Date'] = formatdate(
                int(calendar.timegm(datetime_timestamp.timetuple())))
            if 'X-Amz-Date' in request.headers:
                del request.headers['X-Amz-Date']
        else:
            if 'X-Amz-Date' in request.headers:
                del request.headers['X-Amz-Date']
            request.headers['X-Amz-Date'] = request.context['timestamp']


class S3SigV4Auth(SigV4Auth):

    def _modify_request_before_signing(self, request):
        super(S3SigV4Auth, self)._modify_request_before_signing(request)
        if 'X-Amz-Content-SHA256' in request.headers:
            del request.headers['X-Amz-Content-SHA256']
        request.headers['X-Amz-Content-SHA256'] = self.payload(request)

    def _normalize_url_path(self, path):
        # For S3, we do not normalize the path.
        return path


class SigV4QueryAuth(SigV4Auth):
    DEFAULT_EXPIRES = 3600

    def __init__(self, credentials, service_name, region_name,
                 expires=DEFAULT_EXPIRES):
        super(SigV4QueryAuth, self).__init__(credentials, service_name,
                                             region_name)
        self._expires = expires

    def _modify_request_before_signing(self, request):
        # Note that we're not including X-Amz-Signature.
        # From the docs: "The Canonical Query String must include all the query
        # parameters from the preceding table except for X-Amz-Signature.
        signed_headers = self.signed_headers(self.headers_to_sign(request))
        auth_params = {
            'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',
            'X-Amz-Credential': self.scope(request),
            'X-Amz-Date': request.context['timestamp'],
            'X-Amz-Expires': self._expires,
            'X-Amz-SignedHeaders': signed_headers,
        }
        if self.credentials.token is not None:
            auth_params['X-Amz-Security-Token'] = self.credentials.token
        # Now parse the original query string to a dict, inject our new query
        # params, and serialize back to a query string.
        url_parts = urlsplit(request.url)
        # parse_qs makes each value a list, but in our case we know we won't
        # have repeated keys so we know we have single element lists which we
        # can convert back to scalar values.
        query_dict = dict(
            [(k, v[0]) for k, v in parse_qs(url_parts.query).items()])
        # The spec is particular about this.  It *has* to be:
        # https://<endpoint>?<operation params>&<auth params>
        # You can't mix the two types of params together, i.e just keep doing
        # new_query_params.update(op_params)
        # new_query_params.update(auth_params)
        # percent_encode_sequence(new_query_params)
        operation_params = ''
        if request.data:
            # We also need to move the body params into the query string.
            # request.data will be populated, for example, with query services
            # which normally form encode the params into the body.
            # This means that request.data is a dict() of the operation params.
            query_dict.update(request.data)
            request.data = ''
        if query_dict:
            operation_params = percent_encode_sequence(query_dict) + '&'
        new_query_string = (operation_params +
                            percent_encode_sequence(auth_params))
        # url_parts is a tuple (and therefore immutable) so we need to create
        # a new url_parts with the new query string.
        # <part>   - <index>
        # scheme   - 0
        # netloc   - 1
        # path     - 2
        # query    - 3  <-- we're replacing this.
        # fragment - 4
        p = url_parts
        new_url_parts = (p[0], p[1], p[2], new_query_string, p[4])
        request.url = urlunsplit(new_url_parts)

    def _inject_signature_to_request(self, request, signature):
        # Rather than calculating an "Authorization" header, for the query
        # param quth, we just append an 'X-Amz-Signature' param to the end
        # of the query string.
        request.url += '&X-Amz-Signature=%s' % signature


class S3SigV4QueryAuth(SigV4QueryAuth):
    """S3 SigV4 auth using query parameters.

    This signer will sign a request using query parameters and signature
    version 4, i.e a "presigned url" signer.

    Based off of:

    http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html

    """
    def _normalize_url_path(self, path):
        # For S3, we do not normalize the path.
        return path

    def payload(self, request):
        # From the doc link above:
        # "You don't include a payload hash in the Canonical Request, because
        # when you create a presigned URL, you don't know anything about the
        # payload. Instead, you use a constant string "UNSIGNED-PAYLOAD".
        return "UNSIGNED-PAYLOAD"


class S3SigV4PostAuth(SigV4Auth):
    """
    Presigns a s3 post

    Implementation doc here:
    http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-UsingHTTPPOST.html
    """
    def add_auth(self, request):
        datetime_now = datetime.datetime.utcnow()
        request.context['timestamp'] = datetime_now.strftime(SIGV4_TIMESTAMP)

        fields = {}
        if request.context.get('s3-presign-post-fields', None) is not None:
            fields = request.context['s3-presign-post-fields']

        policy = {}
        conditions = []
        if request.context.get('s3-presign-post-policy', None) is not None:
            policy = request.context['s3-presign-post-policy']
            if policy.get('conditions', None) is not None:
                conditions = policy['conditions']

        policy['conditions'] = conditions

        fields['x-amz-algorithm'] = 'AWS4-HMAC-SHA256'
        fields['x-amz-credential'] = self.scope(request)
        fields['x-amz-date'] = request.context['timestamp']

        conditions.append({'x-amz-algorithm': 'AWS4-HMAC-SHA256'})
        conditions.append({'x-amz-credential': self.scope(request)})
        conditions.append({'x-amz-date': request.context['timestamp']})

        if self.credentials.token is not None:
            fields['x-amz-security-token'] = self.credentials.token
            conditions.append({'x-amz-security-token': self.credentials.token})

        # Dump the base64 encoded policy into the fields dictionary.
        fields['policy'] = base64.b64encode(
            json.dumps(policy).encode('utf-8')).decode('utf-8')

        fields['x-amz-signature'] = self.signature(fields['policy'], request)

        request.context['s3-presign-post-fields'] = fields
        request.context['s3-presign-post-policy'] = policy


class HmacV1Auth(BaseSigner):

    # List of Query String Arguments of Interest
    QSAOfInterest = ['acl', 'cors', 'defaultObjectAcl', 'location', 'logging',
                     'partNumber', 'policy', 'requestPayment', 'torrent',
                     'versioning', 'versionId', 'versions', 'website',
                     'uploads', 'uploadId', 'response-content-type',
                     'response-content-language', 'response-expires',
                     'response-cache-control', 'response-content-disposition',
                     'response-content-encoding', 'delete', 'lifecycle',
                     'tagging', 'restore', 'storageClass', 'notification',
                     'replication', 'requestPayment']

    def __init__(self, credentials, service_name=None, region_name=None):
        self.credentials = credentials

    def sign_string(self, string_to_sign):
        new_hmac = hmac.new(self.credentials.secret_key.encode('utf-8'),
                            digestmod=sha1)
        new_hmac.update(string_to_sign.encode('utf-8'))
        return encodebytes(new_hmac.digest()).strip().decode('utf-8')

    def canonical_standard_headers(self, headers):
        interesting_headers = ['content-md5', 'content-type', 'date']
        hoi = []
        if 'Date' in headers:
            del headers['Date']
        headers['Date'] = self._get_date()
        for ih in interesting_headers:
            found = False
            for key in headers:
                lk = key.lower()
                if headers[key] is not None and lk == ih:
                    hoi.append(headers[key].strip())
                    found = True
            if not found:
                hoi.append('')
        return '\n'.join(hoi)

    def canonical_custom_headers(self, headers):
        hoi = []
        custom_headers = {}
        for key in headers:
            lk = key.lower()
            if headers[key] is not None:
                if lk.startswith('x-amz-'):
                    custom_headers[lk] = ','.join(v.strip() for v in
                                                  headers.get_all(key))
        sorted_header_keys = sorted(custom_headers.keys())
        for key in sorted_header_keys:
            hoi.append("%s:%s" % (key, custom_headers[key]))
        return '\n'.join(hoi)

    def unquote_v(self, nv):
        """
        TODO: Do we need this?
        """
        if len(nv) == 1:
            return nv
        else:
            return (nv[0], unquote(nv[1]))

    def canonical_resource(self, split, auth_path=None):
        # don't include anything after the first ? in the resource...
        # unless it is one of the QSA of interest, defined above
        # NOTE:
        # The path in the canonical resource should always be the
        # full path including the bucket name, even for virtual-hosting
        # style addressing.  The ``auth_path`` keeps track of the full
        # path for the canonical resource and would be passed in if
        # the client was using virtual-hosting style.
        if auth_path is not None:
            buf = auth_path
        else:
            buf = split.path
        if split.query:
            qsa = split.query.split('&')
            qsa = [a.split('=', 1) for a in qsa]
            qsa = [self.unquote_v(a) for a in qsa
                   if a[0] in self.QSAOfInterest]
            if len(qsa) > 0:
                qsa.sort(key=itemgetter(0))
                qsa = ['='.join(a) for a in qsa]
                buf += '?'
                buf += '&'.join(qsa)
        return buf

    def canonical_string(self, method, split, headers, expires=None,
                         auth_path=None):
        cs = method.upper() + '\n'
        cs += self.canonical_standard_headers(headers) + '\n'
        custom_headers = self.canonical_custom_headers(headers)
        if custom_headers:
            cs += custom_headers + '\n'
        cs += self.canonical_resource(split, auth_path=auth_path)
        return cs

    def get_signature(self, method, split, headers, expires=None,
                      auth_path=None):
        if self.credentials.token:
            del headers['x-amz-security-token']
            headers['x-amz-security-token'] = self.credentials.token
        string_to_sign = self.canonical_string(method,
                                               split,
                                               headers,
                                               auth_path=auth_path)
        logger.debug('StringToSign:\n%s', string_to_sign)
        return self.sign_string(string_to_sign)

    def add_auth(self, request):
        if self.credentials is None:
            raise NoCredentialsError
        logger.debug("Calculating signature using hmacv1 auth.")
        split = urlsplit(request.url)
        logger.debug('HTTP request method: %s', request.method)
        signature = self.get_signature(request.method, split,
                                       request.headers,
                                       auth_path=request.auth_path)
        self._inject_signature(request, signature)

    def _get_date(self):
        return formatdate(usegmt=True)

    def _inject_signature(self, request, signature):
        if 'Authorization' in request.headers:
            # We have to do this because request.headers is not
            # normal dictionary.  It has the (unintuitive) behavior
            # of aggregating repeated setattr calls for the same
            # key value.  For example:
            # headers['foo'] = 'a'; headers['foo'] = 'b'
            # list(headers) will print ['foo', 'foo'].
            del request.headers['Authorization']
        request.headers['Authorization'] = (
            "AWS %s:%s" % (self.credentials.access_key, signature))


class HmacV1QueryAuth(HmacV1Auth):
    """
    Generates a presigned request for s3.

    Spec from this document:

    http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html
    #RESTAuthenticationQueryStringAuth

    """
    DEFAULT_EXPIRES = 3600

    def __init__(self, credentials, expires=DEFAULT_EXPIRES):
        self.credentials = credentials
        self._expires = expires

    def _get_date(self):
        return str(int(time.time() + int(self._expires)))

    def _inject_signature(self, request, signature):
        query_dict = {}
        query_dict['AWSAccessKeyId'] = self.credentials.access_key
        query_dict['Signature'] = signature

        for header_key in request.headers:
            lk = header_key.lower()
            # For query string requests, Expires is used instead of the
            # Date header.
            if header_key == 'Date':
                query_dict['Expires'] = request.headers['Date']
            # We only want to include relevant headers in the query string.
            # These can be anything that starts with x-amz, is Content-MD5,
            # or is Content-Type.
            elif lk.startswith('x-amz-') or lk in ['content-md5',
                                                   'content-type']:
                query_dict[lk] = request.headers[lk]
        # Combine all of the identified headers into an encoded
        # query string
        new_query_string = percent_encode_sequence(query_dict)

        # Create a new url with the presigned url.
        p = urlsplit(request.url)
        if p[3]:
            # If there was a pre-existing query string, we should
            # add that back before injecting the new query string.
            new_query_string ='%s&%s' % (p[3], new_query_string)
        new_url_parts = (p[0], p[1], p[2], new_query_string, p[4])
        request.url = urlunsplit(new_url_parts)


class HmacV1PostAuth(HmacV1Auth):
    """
    Generates a presigned post for s3.

    Spec from this document:

    http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingHTTPPOST.html
    """
    def add_auth(self, request):
        fields = {}
        if request.context.get('s3-presign-post-fields', None) is not None:
            fields = request.context['s3-presign-post-fields']

        policy = {}
        conditions = []
        if request.context.get('s3-presign-post-policy', None) is not None:
            policy = request.context['s3-presign-post-policy']
            if policy.get('conditions', None) is not None:
                conditions = policy['conditions']

        policy['conditions'] = conditions

        fields['AWSAccessKeyId'] = self.credentials.access_key

        if self.credentials.token is not None:
            fields['x-amz-security-token'] = self.credentials.token
            conditions.append({'x-amz-security-token': self.credentials.token})

        # Dump the base64 encoded policy into the fields dictionary.
        fields['policy'] = base64.b64encode(
            json.dumps(policy).encode('utf-8')).decode('utf-8')

        fields['signature'] = self.sign_string(fields['policy'])

        request.context['s3-presign-post-fields'] = fields
        request.context['s3-presign-post-policy'] = policy


# Defined at the bottom instead of the top of the module because the Auth
# classes weren't defined yet.
AUTH_TYPE_MAPS = {
    'v2': SigV2Auth,
    'v4': SigV4Auth,
    'v4-query': SigV4QueryAuth,
    'v3': SigV3Auth,
    'v3https': SigV3Auth,
    's3': HmacV1Auth,
    's3-query': HmacV1QueryAuth,
    's3-presign-post': HmacV1PostAuth,
    's3v4': S3SigV4Auth,
    's3v4-query': S3SigV4QueryAuth,
    's3v4-presign-post': S3SigV4PostAuth,

}
                                         usr/local/lib/python2.7/dist-packages/botocore/auth.pyc                                             0100644 0000000 0000062 00000061247 13077704401 021524  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   sú  d  d l  Z  d  d l Z d  d l m Z d  d l m Z d  d l Z d  d l Z d  d l m Z d  d l	 m
 Z
 d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z m Z d  d l m Z d  d	 l m Z m Z m Z m Z d  d
 l m Z d  d l m Z d  d l m Z d  d l m Z e j e É Z d Z  d3 Z! d Z" d Z# d e$ f d Ñ  É  YZ% d e% f d Ñ  É  YZ& d e% f d Ñ  É  YZ' d e% f d Ñ  É  YZ( d e( f d Ñ  É  YZ) d e( f d Ñ  É  YZ* d e* f d Ñ  É  YZ+ d  e( f d! Ñ  É  YZ, d" e% f d# Ñ  É  YZ- d$ e- f d% Ñ  É  YZ. d& e- f d' Ñ  É  YZ/ i e& d( 6e( d) 6e* d* 6e' d+ 6e' d, 6e- d- 6e. d. 6e/ d/ 6e) d0 6e+ d1 6e, d2 6Z0 d S(4   iˇˇˇˇN(   t   sha256(   t   sha1(   t
   formatdate(   t
   itemgetter(   t   NoCredentialsError(   t   normalize_url_patht   percent_encode_sequence(   t   HTTPHeaders(   t   quotet   unquotet   urlsplitt   parse_qs(   t
   urlunsplit(   t   encodebytes(   t   six(   t   jsont@   e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855i   s   %Y-%m-%dT%H:%M:%SZs   %Y%m%dT%H%M%SZt
   BaseSignerc           B   s   e  Z e Z d  Ñ  Z RS(   c         C   s   t  d É Ç d  S(   Nt   add_auth(   t   NotImplementedError(   t   selft   request(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   4   s    (   t   __name__t
   __module__t   Falset   REQUIRES_REGIONR   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   1   s   t	   SigV2Authc           B   s)   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s+   
    Sign a request with Signature V2.
    c         C   s   | |  _  d  S(   N(   t   credentials(   R   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   __init__=   s    c         C   sk  t  j d É t | j É } | j } t | É d k r@ d } n  d | j | j | f } t j	 |  j
 j j d É d t É} g  } xx t | É D]j } | d k r® qê n  t j | | É }	 | j t | j d É d d	 Éd
 t |	 j d É d d ÉÉ qê Wd j | É }
 | |
 7} t  j d | É | j | j d É É t j | j É  É j É  j d É } |
 | f S(   Ns$   Calculating signature using v2 auth.i    t   /s	   %s
%s
%s
s   utf-8t	   digestmodt	   Signaturet   safet    t   =s   -_~t   &s   String to sign: %s(   t   loggert   debugR
   t   urlt   patht   lent   methodt   netloct   hmact   newR   t
   secret_keyt   encodeR    t   sortedR   t	   text_typet   appendR   t   joint   updatet   base64t	   b64encodet   digestt   stript   decode(   R   R   t   paramst   splitR'   t   string_to_signt   lhmact   pairst   keyt   valuet   qst   b64(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   calc_signature@   s.    			
	"!
$c         C   sª   |  j  d  k r t Ç n  | j r- | j } n	 | j } |  j  j | d <d | d <d | d <t j t t j	 É  É | d <|  j  j
 rï |  j  j
 | d <n  |  j | | É \ } } | | d <| S(	   Nt   AWSAccessKeyIdt   2t   SignatureVersiont
   HmacSHA256t   SignatureMethodt	   Timestampt   SecurityTokenR   (   R   t   NoneR   t   datat   paramt
   access_keyt   timet   strftimet   ISO8601t   gmtimet   tokenRB   (   R   R   R9   R@   t	   signature(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   \   s    			


(   R   R   t   __doc__R   RB   R   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   8   s   		t	   SigV3Authc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  d  S(   N(   R   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   v   s    c         C   s0  |  j  d  k r t Ç n  d | j k r4 | j d =n  t d t É | j d <|  j  j rà d | j k rr | j d =n  |  j  j | j d <n  t j |  j  j	 j
 d É d t É} | j | j d j
 d É É t | j É  É j É  } d |  j  j d | j d É f } d | j k r| j d =n  | | j d <d  S(	   Nt   Datet   usegmts   X-Amz-Security-Tokens   utf-8R   s6   AWS3-HTTPS AWSAccessKeyId=%s,Algorithm=%s,Signature=%sRF   s   X-Amzn-Authorization(   R   RJ   R   t   headersR   t   TrueRR   R+   R,   R-   R.   R    R3   R   R6   R7   RM   R8   (   R   R   t   new_hmact   encoded_signatureRS   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   y   s&    		(   R   R   R   R   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRU   u   s   	t	   SigV4Authc           B   s¬   e  Z d  Z e Z d Ñ  Z e d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s+   
    Sign a request with Signature V4.
    c         C   s   | |  _  | |  _ | |  _ d  S(   N(   R   t   _region_namet   _service_name(   R   R   t   service_namet   region_name(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   ï   s    		c         C   sU   | r- t  j | | j d É t É j É  } n$ t  j | | j d É t É j É  } | S(   Ns   utf-8(   R+   R,   R.   R    t	   hexdigestR6   (   R   R>   t   msgt   hext   sig(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   _signù   s    '$c         C   sn   t  É  } t | j É } x3 | j j É  D]" \ } } | j É  } | | | <q( Wd | k rj | j | d <n  | S(   sk   
        Select the headers from the request that need to be included
        in the StringToSign.
        t   host(   R   R
   R&   RX   t   itemst   lowerR*   (   R   R   t
   header_mapR:   t   nameR?   t   lname(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   headers_to_sign§   s    	c         C   s3   | j  r |  j | j  É S|  j t | j É É Sd  S(   N(   R9   t   _canonical_query_string_paramst   _canonical_query_string_urlR
   R&   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_query_string≤   s    	c         C   so   g  } xS t  | É D]E } t | | É } | j d t | d d Ét | d d Éf É q Wd j | É } | S(   Ns   %s=%sR    s   -_.~R#   (   R/   t   strR1   R   R2   (   R   R9   t   lRL   R?   t   cqs(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRm   º   s    c   	      C   s≠   d } | j  r© g  } xE | j  j d É D]1 } | j d É \ } } } | j | | f É q( Wg  } x1 t | É D]# \ } } | j d | | f É qp Wd j | É } n  | S(   NR!   R#   R"   s   %s=%s(   t   queryR:   t	   partitionR1   R/   R2   (	   R   t   partsRo   t   key_val_pairst   pairR>   t   _R?   t   sorted_key_vals(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRn   ≈   s    	c         C   su   g  } t  t | É É } xM | D]E } d j d Ñ  t  | j | É É DÉ É } | j d | | f É q Wd j | É S(   s  
        Return the headers that need to be included in the StringToSign
        in their canonical form by converting all header keys to lower
        case, sorting them in alphabetical order and then joining
        them into a string, separated by newlines.
        t   ,c         s   s   |  ] } | j  É  Vq d  S(   N(   R7   (   t   .0t   v(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pys	   <genexpr>ﬂ   s    s   %s:%ss   
(   R/   t   setR2   t   get_allR1   (   R   Rl   RX   t   sorted_header_namesR>   R?   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_headers’   s    c         C   sH   g  t  | É D] } d | j É  j É  ^ q } t | É } d j | É S(   Ns   %st   ;(   R}   Rh   R7   R/   R2   (   R   Rl   t   nRq   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   signed_headers‰   s    /c         C   s∂   | j  rí t | j  d É rí | j  j É  } t j | j  j t É } t É  } x$ t | d É D] } | j	 | É q[ W| j
 É  } | j  j | É | S| j  rÆ t | j  É j
 É  St Sd  S(   Nt   seekR!   (   t   bodyt   hasattrt   tellt	   functoolst   partialt   readt   PAYLOAD_BUFFERR    t   iterR3   Ra   RÑ   t   EMPTY_SHA256_HASH(   R   R   t   positiont   read_chunksizet   checksumt   chunkt   hex_checksum(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   payloadÈ   s    			c         C   s◊   | j  j É  g } |  j t | j É j É } | j | É | j |  j | É É |  j | É } | j |  j	 | É d É | j |  j
 | É É d | j k rÆ | j d } n |  j | É } | j | É d j | É S(   Ns   
s   X-Amz-Content-SHA256(   R)   t   uppert   _normalize_url_pathR
   R&   R'   R1   Ro   Rl   RÄ   RÉ   RX   Rì   R2   (   R   R   t   crR'   Rl   t   body_checksum(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_request˚   s    c         C   s   t  t | É d d É} | S(   NR    s   /~(   R   R   (   R   R'   t   normalized_path(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRï   
  s    c         C   sd   |  j  j g } | j | j d d d !É | j |  j É | j |  j É | j d É d j | É S(   Nt	   timestampi    i   t   aws4_requestR   (   R   RM   R1   t   contextR]   R^   R2   (   R   R   t   scope(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRù     s    c         C   s[   g  } | j  | j d d d !É | j  |  j É | j  |  j É | j  d É d j | É S(   NRö   i    i   Rõ   R   (   R1   Rú   R]   R^   R2   (   R   R   Rù   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   credential_scope  s    c         C   sb   d g } | j  | j d É | j  |  j | É É | j  t | j d É É j É  É d j | É S(   s¨   
        Return the canonical StringToSign as well as a dict
        containing the original version of all headers that
        were included in the StringToSign.
        s   AWS4-HMAC-SHA256Rö   s   utf-8s   
(   R1   Rú   Rû   R    R.   Ra   R2   (   R   R   Rò   t   sts(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR;     s
    	"c         C   sã   |  j  j } |  j d | j d É | j d d d !É } |  j | |  j É } |  j | |  j É } |  j | d É } |  j | | d t ÉS(   Nt   AWS4s   utf-8Rö   i    i   Rõ   Rc   (   R   R-   Re   R.   Rú   R]   R^   RY   (   R   R;   R   R>   t   k_datet   k_regiont	   k_servicet	   k_signing(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRS   *  s    c         C   sŒ   |  j  d  k r t Ç n  t j j É  } | j t É | j d <|  j | É |  j	 | É } t
 j d É t
 j d | É |  j | | É } t
 j d | É |  j | | É } t
 j d | É |  j | | É d  S(   NRö   s$   Calculating signature using v4 auth.s   CanonicalRequest:
%ss   StringToSign:
%ss   Signature:
%s(   R   RJ   R   t   datetimet   utcnowRO   t   SIGV4_TIMESTAMPRú   t   _modify_request_before_signingRò   R$   R%   R;   RS   t   _inject_signature_to_request(   R   R   t   datetime_nowRò   R;   RS   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   3  s    	c         C   sj   d |  j  | É g } |  j | É } | j d |  j | É É | j d | É d j | É | j d <| S(   Ns   AWS4-HMAC-SHA256 Credential=%ss   SignedHeaders=%ss   Signature=%ss   , t   Authorization(   Rù   Rl   R1   RÉ   R2   RX   (   R   R   RS   Rq   Rl   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR©   E  s    c         C   sk   d | j  k r | j  d =n  |  j | É |  j j rg d | j  k rQ | j  d =n  |  j j | j  d <n  d  S(   NR´   s   X-Amz-Security-Token(   RX   t   _set_necessary_date_headersR   RR   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR®   M  s    c         C   s∞   d | j  k r| | j  d =t j j | j d t É } t t t j | j	 É  É É É | j  d <d | j  k r¨ | j  d =q¨ n0 d | j  k rò | j  d =n  | j d | j  d <d  S(   NRV   Rö   s
   X-Amz-Date(
   RX   R•   t   strptimeRú   Rß   R   t   intt   calendart   timegmt	   timetuple(   R   R   t   datetime_timestamp(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR¨   V  s    
	%(   R   R   RT   RY   R   R   R   Re   Rl   Ro   Rm   Rn   RÄ   RÉ   Rì   Rò   Rï   Rù   Rû   R;   RS   R   R©   R®   R¨   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR\   è   s*   			
																	t   S3SigV4Authc           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         C   sL   t  t |  É j | É d | j k r2 | j d =n  |  j | É | j d <d  S(   Ns   X-Amz-Content-SHA256(   t   superR≥   R®   RX   Rì   (   R   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR®   j  s    c         C   s   | S(   N(    (   R   R'   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRï   p  s    (   R   R   R®   Rï   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR≥   h  s   	t   SigV4QueryAuthc           B   s,   e  Z d  Z e d Ñ Z d Ñ  Z d Ñ  Z RS(   i  c         C   s)   t  t |  É j | | | É | |  _ d  S(   N(   R¥   Rµ   R   t   _expires(   R   R   R_   R`   t   expires(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   x  s    c         C   sX  |  j  |  j | É É } i d d 6|  j | É d 6| j d d 6|  j d 6| d 6} |  j j d  k	 ry |  j j | d <n  t | j	 É } t
 g  t | j É j É  D] \ } } | | d	 f ^ q° É } d
 } | j rÒ | j | j É d
 | _ n  | r
t | É d } n  | t | É }	 | }
 |
 d	 |
 d |
 d |	 |
 d f } t | É | _	 d  S(   Ns   AWS4-HMAC-SHA256s   X-Amz-Algorithms   X-Amz-CredentialRö   s
   X-Amz-Dates   X-Amz-Expiress   X-Amz-SignedHeaderss   X-Amz-Security-Tokeni    R!   R#   i   i   i   (   RÉ   Rl   Rù   Rú   R∂   R   RR   RJ   R
   R&   t   dictR   Rs   Rg   RK   R3   R   R   (   R   R   RÉ   t   auth_paramst	   url_partst   kR|   t
   query_dictt   operation_paramst   new_query_stringt   pt   new_url_parts(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR®   ~  s.    

;		%c         C   s   | j  d | 7_  d  S(   Ns   &X-Amz-Signature=%s(   R&   (   R   R   RS   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR©   ≤  s    (   R   R   t   DEFAULT_EXPIRESR   R®   R©   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRµ   u  s   	4t   S3SigV4QueryAuthc           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s  S3 SigV4 auth using query parameters.

    This signer will sign a request using query parameters and signature
    version 4, i.e a "presigned url" signer.

    Based off of:

    http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html

    c         C   s   | S(   N(    (   R   R'   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRï   ƒ  s    c         C   s   d S(   Ns   UNSIGNED-PAYLOAD(    (   R   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyRì   »  s    (   R   R   RT   Rï   Rì   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR¬   π  s   
	t   S3SigV4PostAuthc           B   s   e  Z d  Z d Ñ  Z RS(   sÜ   
    Presigns a s3 post

    Implementation doc here:
    http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-UsingHTTPPOST.html
    c         C   s€  t  j  j É  } | j t É | j d <i  } | j j d d  É d  k	 rV | j d } n  i  } g  } | j j d d  É d  k	 r≤ | j d } | j d d  É d  k	 r≤ | d } q≤ n  | | d <d | d <|  j | É | d <| j d | d <| j i d d 6É | j i |  j | É d 6É | j i | j d d 6É |  j	 j
 d  k	 ru|  j	 j
 | d	 <| j i |  j	 j
 d	 6É n  t j t j | É j d
 É É j d
 É | d <|  j | d | É | d <| | j d <| | j d <d  S(   NRö   s   s3-presign-post-fieldss   s3-presign-post-policyt
   conditionss   AWS4-HMAC-SHA256s   x-amz-algorithms   x-amz-credentials
   x-amz-dates   x-amz-security-tokens   utf-8t   policys   x-amz-signature(   R•   R¶   RO   Rß   Rú   t   getRJ   Rù   R1   R   RR   R4   R5   R   t   dumpsR.   R8   RS   (   R   R   R™   t   fieldsR≈   Rƒ   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   ◊  s4    

((   R   R   RT   R   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR√   –  s   t
   HmacV1Authc           B   s›   e  Z d  d d d d d d d d d	 d
 d d d d d d d d d d d d d d d d d d g Z d' d' d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z d  Ñ  Z d' d! Ñ Z	 d' d' d" Ñ Z
 d' d' d# Ñ Z d$ Ñ  Z d% Ñ  Z d& Ñ  Z RS((   t   aclt   corst   defaultObjectAclt   locationt   loggingt
   partNumberR≈   t   requestPaymentt   torrentt
   versioningt	   versionIdt   versionst   websitet   uploadst   uploadIds   response-content-types   response-content-languages   response-expiress   response-cache-controls   response-content-dispositions   response-content-encodingt   deletet	   lifecyclet   taggingt   restoret   storageClasst   notificationt   replicationc         C   s   | |  _  d  S(   N(   R   (   R   R   R_   R`   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR     s    c         C   sY   t  j |  j j j d É d t É} | j | j d É É t | j É  É j	 É  j
 d É S(   Ns   utf-8R   (   R+   R,   R   R-   R.   R   R3   R   R6   R7   R8   (   R   R;   RZ   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   sign_string  s    	c         C   sŒ   d d d g } g  } d | k r+ | d =n  |  j  É  | d <xÉ | D]{ } t } xV | D]N } | j É  } | | d  k	 rU | | k rU | j | | j É  É t } qU qU W| sB | j d É qB qB Wd j | É S(   Ns   content-md5s   content-typet   dateRV   R!   s   
(   t	   _get_dateR   Rh   RJ   R1   R7   RY   R2   (   R   RX   t   interesting_headerst   hoit   iht   foundR>   t   lk(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_standard_headers  s    
c         C   sø   g  } i  } xe | D]] } | j  É  } | | d  k	 r | j d É rp d j d Ñ  | j | É DÉ É | | <qp q q Wt | j É  É } x) | D]! } | j d | | | f É qç Wd j | É S(   Ns   x-amz-Rz   c         s   s   |  ] } | j  É  Vq d  S(   N(   R7   (   R{   R|   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pys	   <genexpr>,  s    s   %s:%ss   
(   Rh   RJ   t
   startswithR2   R~   R/   t   keysR1   (   R   RX   R„   t   custom_headersR>   RÊ   t   sorted_header_keys(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_custom_headers%  s    $c         C   s2   t  | É d k r | S| d t | d É f Sd S(   s(   
        TODO: Do we need this?
        i   i    N(   R(   R	   (   R   t   nv(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt	   unquote_v3  s    c         C   s  | d  k	 r | } n	 | j } | j r | j j d É } g  | D] } | j d d É ^ q@ } g  | D]( } | d |  j k re |  j | É ^ qe } t | É d k r | j d t d É É g  | D] } d j	 | É ^ q¬ } | d 7} | d j	 | É 7} q n  | S(   NR#   R"   i   i    R>   t   ?(
   RJ   R'   Rs   R:   t   QSAOfInterestRÓ   R(   t   sortR   R2   (   R   R:   t	   auth_patht   buft   qsat   a(    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_resource<  s    				%("
c         C   sj   | j  É  d } | |  j | É d 7} |  j | É } | rM | | d 7} n  | |  j | d | É7} | S(   Ns   
RÚ   (   Rî   RÁ   RÏ   Rˆ   (   R   R)   R:   RX   R∑   RÚ   t   csRÍ   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   canonical_stringU  s    c         C   s^   |  j  j r& | d =|  j  j | d <n  |  j | | | d | É} t j d | É |  j | É S(   Ns   x-amz-security-tokenRÚ   s   StringToSign:
%s(   R   RR   R¯   R$   R%   Rﬂ   (   R   R)   R:   RX   R∑   RÚ   R;   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   get_signature_  s    		c         C   s   |  j  d  k r t Ç n  t j d É t | j É } t j d | j É |  j | j | | j	 d | j
 É} |  j | | É d  S(   Ns(   Calculating signature using hmacv1 auth.s   HTTP request method: %sRÚ   (   R   RJ   R   R$   R%   R
   R&   R)   R˘   RX   RÚ   t   _inject_signature(   R   R   R:   RS   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   k  s    		c         C   s   t  d t É S(   NRW   (   R   RY   (   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR·   v  s    c         C   s=   d | j  k r | j  d =n  d |  j j | f | j  d <d  S(   NR´   s	   AWS %s:%s(   RX   R   RM   (   R   R   RS   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR˙   y  s    N(   R   R   R   RJ   R   Rﬂ   RÁ   RÏ   RÓ   Rˆ   R¯   R˘   R   R·   R˙   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR…   ˛  s,   										t   HmacV1QueryAuthc           B   s2   e  Z d  Z d Z e d Ñ Z d Ñ  Z d Ñ  Z RS(   s¡   
    Generates a presigned request for s3.

    Spec from this document:

    http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html
    #RESTAuthenticationQueryStringAuth

    i  c         C   s   | |  _  | |  _ d  S(   N(   R   R∂   (   R   R   R∑   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   í  s    	c         C   s#   t  t t j É  t |  j É É É S(   N(   Rp   RÆ   RN   R∂   (   R   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR·   ñ  s    c   	      C   s  i  } |  j  j | d <| | d <xl | j D]a } | j É  } | d k r\ | j d | d <q* | j d É sw | d k r* | j | | | <q* q* Wt | É } t | j É } | d rÀ d	 | d | f } n  | d
 | d | d | | d f } t | É | _ d  S(   NRC   R   RV   t   Expiress   x-amz-s   content-md5s   content-typei   s   %s&%si    i   i   i   (   s   content-md5s   content-type(	   R   RM   RX   Rh   RË   R   R
   R&   R   (	   R   R   RS   Rº   t
   header_keyRÊ   Ræ   Rø   R¿   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR˙   ô  s     
	
%(   R   R   RT   R¡   R   R·   R˙   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR˚   Ü  s
   		t   HmacV1PostAuthc           B   s   e  Z d  Z d Ñ  Z RS(   së   
    Generates a presigned post for s3.

    Spec from this document:

    http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingHTTPPOST.html
    c         C   sI  i  } | j  j d d  É d  k	 r1 | j  d } n  i  } g  } | j  j d d  É d  k	 rç | j  d } | j d d  É d  k	 rç | d } qç n  | | d <|  j j | d <|  j j d  k	 rÊ |  j j | d <| j i |  j j d 6É n  t j t	 j
 | É j d É É j d É | d <|  j | d É | d <| | j  d <| | j  d <d  S(	   Ns   s3-presign-post-fieldss   s3-presign-post-policyRƒ   RC   s   x-amz-security-tokens   utf-8R≈   RS   (   Rú   R∆   RJ   R   RM   RR   R1   R4   R5   R   R«   R.   R8   Rﬂ   (   R   R   R»   R≈   Rƒ   (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR   ¿  s&    
((   R   R   RT   R   (    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyR˛   ∏  s   t   v2t   v4s   v4-queryt   v3t   v3httpst   s3s   s3-querys   s3-presign-postt   s3v4s
   s3v4-querys   s3v4-presign-posti   (1   R4   R•   t   hashlibR    R   R+   RŒ   t   email.utilsR   t   operatorR   Rà   RN   RØ   t   botocore.exceptionsR   t   botocore.utilsR   R   t   botocore.compatR   R   R	   R
   R   R   R   R   R   t	   getLoggerR   R$   Rç   Rã   RP   Rß   t   objectR   R   RU   R\   R≥   Rµ   R¬   R√   R…   R˚   R˛   t   AUTH_TYPE_MAPS(    (    (    s/   /tmp/pip-build-awuatQ/botocore/botocore/auth.pyt   <module>   s\   "=ŸD.à2(                                                                                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/botocore/awsrequest.py                                        0100644 0000000 0000062 00000044325 13077704371 022627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import sys
import logging
import select
import functools
import socket
import inspect

from botocore.compat import six
from botocore.compat import HTTPHeaders, HTTPResponse, urlunsplit, urlsplit
from botocore.exceptions import UnseekableStreamError
from botocore.utils import percent_encode_sequence
from botocore.vendored.requests import models
from botocore.vendored.requests.sessions import REDIRECT_STATI
from botocore.vendored.requests.packages.urllib3.connection import \
    VerifiedHTTPSConnection
from botocore.vendored.requests.packages.urllib3.connection import \
    HTTPConnection
from botocore.vendored.requests.packages.urllib3.connectionpool import \
    HTTPConnectionPool
from botocore.vendored.requests.packages.urllib3.connectionpool import \
    HTTPSConnectionPool


logger = logging.getLogger(__name__)


class AWSHTTPResponse(HTTPResponse):
    # The *args, **kwargs is used because the args are slightly
    # different in py2.6 than in py2.7/py3.
    def __init__(self, *args, **kwargs):
        self._status_tuple = kwargs.pop('status_tuple')
        HTTPResponse.__init__(self, *args, **kwargs)

    def _read_status(self):
        if self._status_tuple is not None:
            status_tuple = self._status_tuple
            self._status_tuple = None
            return status_tuple
        else:
            return HTTPResponse._read_status(self)


class AWSHTTPConnection(HTTPConnection):
    """HTTPConnection that supports Expect 100-continue.

    This is conceptually a subclass of httplib.HTTPConnection (though
    technically we subclass from urllib3, which subclasses
    httplib.HTTPConnection) and we only override this class to support Expect
    100-continue, which we need for S3.  As far as I can tell, this is
    general purpose enough to not be specific to S3, but I'm being
    tentative and keeping it in botocore because I've only tested
    this against AWS services.

    """
    def __init__(self, *args, **kwargs):
        HTTPConnection.__init__(self, *args, **kwargs)
        self._original_response_cls = self.response_class
        # We'd ideally hook into httplib's states, but they're all
        # __mangled_vars so we use our own state var.  This variable is set
        # when we receive an early response from the server.  If this value is
        # set to True, any calls to send() are noops.  This value is reset to
        # false every time _send_request is called.  This is to workaround the
        # fact that py2.6 (and only py2.6) has a separate send() call for the
        # body in _send_request, as opposed to endheaders(), which is where the
        # body is sent in all versions > 2.6.
        self._response_received = False
        self._expect_header_set = False

    def close(self):
        HTTPConnection.close(self)
        # Reset all of our instance state we were tracking.
        self._response_received = False
        self._expect_header_set = False
        self.response_class = self._original_response_cls

    def _tunnel(self):
        # Works around a bug in py26 which is fixed in later versions of
        # python. Bug involves hitting an infinite loop if readline() returns
        # nothing as opposed to just ``\r\n``.
        # As much as I don't like having if py2: <foo> code blocks, this seems
        # the cleanest way to handle this workaround.  Fortunately, the
        # difference from py26 to py3 is very minimal.  We're essentially
        # just overriding the while loop.
        if sys.version_info[:2] != (2, 6):
            return HTTPConnection._tunnel(self)

        # Otherwise we workaround the issue.
        self._set_hostport(self._tunnel_host, self._tunnel_port)
        self.send("CONNECT %s:%d HTTP/1.0\r\n" % (self.host, self.port))
        for header, value in self._tunnel_headers.iteritems():
            self.send("%s: %s\r\n" % (header, value))
        self.send("\r\n")
        response = self.response_class(self.sock, strict=self.strict,
                                       method=self._method)
        (version, code, message) = response._read_status()

        if code != 200:
            self.close()
            raise socket.error("Tunnel connection failed: %d %s" %
                               (code, message.strip()))
        while True:
            line = response.fp.readline()
            if not line:
                break
            if line in (b'\r\n', b'\n', b''):
                break

    def _send_request(self, method, url, body, headers):
        self._response_received = False
        if headers.get('Expect', b'') == b'100-continue':
            self._expect_header_set = True
        else:
            self._expect_header_set = False
            self.response_class = self._original_response_cls
        rval = HTTPConnection._send_request(
            self, method, url, body, headers)
        self._expect_header_set = False
        return rval

    def _convert_to_bytes(self, mixed_buffer):
        # Take a list of mixed str/bytes and convert it
        # all into a single bytestring.
        # Any six.text_types will be encoded as utf-8.
        bytes_buffer = []
        for chunk in mixed_buffer:
            if isinstance(chunk, six.text_type):
                bytes_buffer.append(chunk.encode('utf-8'))
            else:
                bytes_buffer.append(chunk)
        msg = b"\r\n".join(bytes_buffer)
        return msg

    def _send_output(self, message_body=None):
        self._buffer.extend((b"", b""))
        msg = self._convert_to_bytes(self._buffer)
        del self._buffer[:]
        # If msg and message_body are sent in a single send() call,
        # it will avoid performance problems caused by the interaction
        # between delayed ack and the Nagle algorithm.
        if isinstance(message_body, bytes):
            msg += message_body
            message_body = None
        self.send(msg)
        if self._expect_header_set:
            # This is our custom behavior.  If the Expect header was
            # set, it will trigger this custom behavior.
            logger.debug("Waiting for 100 Continue response.")
            # Wait for 1 second for the server to send a response.
            read, write, exc = select.select([self.sock], [], [self.sock], 1)
            if read:
                self._handle_expect_response(message_body)
                return
            else:
                # From the RFC:
                # Because of the presence of older implementations, the
                # protocol allows ambiguous situations in which a client may
                # send "Expect: 100-continue" without receiving either a 417
                # (Expectation Failed) status or a 100 (Continue) status.
                # Therefore, when a client sends this header field to an origin
                # server (possibly via a proxy) from which it has never seen a
                # 100 (Continue) status, the client SHOULD NOT wait for an
                # indefinite period before sending the request body.
                logger.debug("No response seen from server, continuing to "
                             "send the response body.")
        if message_body is not None:
            # message_body was not a string (i.e. it is a file), and
            # we must run the risk of Nagle.
            self.send(message_body)

    def _consume_headers(self, fp):
        # Most servers (including S3) will just return
        # the CLRF after the 100 continue response.  However,
        # some servers (I've specifically seen this for squid when
        # used as a straight HTTP proxy) will also inject a
        # Connection: keep-alive header.  To account for this
        # we'll read until we read '\r\n', and ignore any headers
        # that come immediately after the 100 continue response.
        current = None
        while current != b'\r\n':
            current = fp.readline()

    def _handle_expect_response(self, message_body):
        # This is called when we sent the request headers containing
        # an Expect: 100-continue header and received a response.
        # We now need to figure out what to do.
        fp = self.sock.makefile('rb', 0)
        try:
            maybe_status_line = fp.readline()
            parts = maybe_status_line.split(None, 2)
            if self._is_100_continue_status(maybe_status_line):
                self._consume_headers(fp)
                logger.debug("100 Continue response seen, "
                             "now sending request body.")
                self._send_message_body(message_body)
            elif len(parts) == 3 and parts[0].startswith(b'HTTP/'):
                # From the RFC:
                # Requirements for HTTP/1.1 origin servers:
                #
                # - Upon receiving a request which includes an Expect
                #   request-header field with the "100-continue"
                #   expectation, an origin server MUST either respond with
                #   100 (Continue) status and continue to read from the
                #   input stream, or respond with a final status code.
                #
                # So if we don't get a 100 Continue response, then
                # whatever the server has sent back is the final response
                # and don't send the message_body.
                logger.debug("Received a non 100 Continue response "
                             "from the server, NOT sending request body.")
                status_tuple = (parts[0].decode('ascii'),
                                int(parts[1]), parts[2].decode('ascii'))
                response_class = functools.partial(
                    AWSHTTPResponse, status_tuple=status_tuple)
                self.response_class = response_class
                self._response_received = True
        finally:
            fp.close()

    def _send_message_body(self, message_body):
        if message_body is not None:
            self.send(message_body)

    def send(self, str):
        if self._response_received:
            logger.debug("send() called, but reseponse already received. "
                         "Not sending data.")
            return
        return HTTPConnection.send(self, str)

    def _is_100_continue_status(self, maybe_status_line):
        parts = maybe_status_line.split(None, 2)
        # Check for HTTP/<version> 100 Continue\r\n
        return (
            len(parts) >= 3 and parts[0].startswith(b'HTTP/') and
            parts[1] == b'100')


class AWSHTTPSConnection(VerifiedHTTPSConnection):
    pass


# Now we need to set the methods we overrode from AWSHTTPConnection
# onto AWSHTTPSConnection.  This is just a shortcut to avoid
# copy/pasting the same code into AWSHTTPSConnection.
for name, function in AWSHTTPConnection.__dict__.items():
    if inspect.isfunction(function):
        setattr(AWSHTTPSConnection, name, function)


def prepare_request_dict(request_dict, endpoint_url, user_agent=None):
    """
    This method prepares a request dict to be created into an
    AWSRequestObject. This prepares the request dict by adding the
    url and the user agent to the request dict.

    :type request_dict: dict
    :param request_dict:  The request dict (created from the
        ``serialize`` module).

    :type user_agent: string
    :param user_agent: The user agent to use for this request.

    :type endpoint_url: string
    :param endpoint_url: The full endpoint url, which contains at least
        the scheme, the hostname, and optionally any path components.
    """
    r = request_dict
    if user_agent is not None:
        headers = r['headers']
        headers['User-Agent'] = user_agent
    url = _urljoin(endpoint_url, r['url_path'])
    if r['query_string']:
        encoded_query_string = percent_encode_sequence(r['query_string'])
        if '?' not in url:
            url += '?%s' % encoded_query_string
        else:
            url += '&%s' % encoded_query_string
    r['url'] = url


def create_request_object(request_dict):
    """
    This method takes a request dict and creates an AWSRequest object
    from it.

    :type request_dict: dict
    :param request_dict:  The request dict (created from the
        ``prepare_request_dict`` method).

    :rtype: ``botocore.awsrequest.AWSRequest``
    :return: An AWSRequest object based on the request_dict.

    """
    r = request_dict
    return AWSRequest(method=r['method'], url=r['url'],
                      data=r['body'],
                      headers=r['headers'])


def _urljoin(endpoint_url, url_path):
    p = urlsplit(endpoint_url)
    # <part>   - <index>
    # scheme   - p[0]
    # netloc   - p[1]
    # path     - p[2]
    # query    - p[3]
    # fragment - p[4]
    if not url_path or url_path == '/':
        # If there's no path component, ensure the URL ends with
        # a '/' for backwards compatibility.
        if not p[2]:
            return endpoint_url + '/'
        return endpoint_url
    if p[2].endswith('/') and url_path.startswith('/'):
        new_path = p[2][:-1] + url_path
    else:
        new_path = p[2] + url_path
    reconstructed = urlunsplit((p[0], p[1], new_path, p[3], p[4]))
    return reconstructed


class AWSRequest(models.RequestEncodingMixin, models.Request):
    def __init__(self, *args, **kwargs):
        self.auth_path = None
        if 'auth_path' in kwargs:
            self.auth_path = kwargs['auth_path']
            del kwargs['auth_path']
        models.Request.__init__(self, *args, **kwargs)
        headers = HTTPHeaders()
        if self.headers is not None:
            for key, value in self.headers.items():
                headers[key] = value
        self.headers = headers
        # This is a dictionary to hold information that is used when
        # processing the request. What is inside of ``context`` is open-ended.
        # For example, it may have a timestamp key that is used for holding
        # what the timestamp is when signing the request. Note that none
        # of the information that is inside of ``context`` is directly
        # sent over the wire; the information is only used to assist in
        # creating what is sent over the wire.
        self.context = {}

    def prepare(self):
        """Constructs a :class:`AWSPreparedRequest <AWSPreparedRequest>`."""
        # Eventually I think it would be nice to add hooks into this process.
        p = AWSPreparedRequest(self)
        p.prepare_method(self.method)
        p.prepare_url(self.url, self.params)
        p.prepare_headers(self.headers)
        p.prepare_cookies(self.cookies)
        p.prepare_body(self.data, self.files)
        p.prepare_auth(self.auth)
        return p

    @property
    def body(self):
        p = models.PreparedRequest()
        p.prepare_headers({})
        p.prepare_body(self.data, self.files)
        if isinstance(p.body, six.text_type):
            p.body = p.body.encode('utf-8')
        return p.body


class AWSPreparedRequest(models.PreparedRequest):
    """Represents a prepared request.

    :ivar method: HTTP Method
    :ivar url: The full url
    :ivar headers: The HTTP headers to send.
    :ivar body: The HTTP body.
    :ivar hooks: The set of callback hooks.

    In addition to the above attributes, the following attributes are
    available:

    :ivar query_params: The original query parameters.
    :ivar post_param: The original POST params (dict).

    """
    def __init__(self, original_request):
        self.original = original_request
        super(AWSPreparedRequest, self).__init__()
        self.hooks.setdefault('response', []).append(
            self.reset_stream_on_redirect)

    def reset_stream_on_redirect(self, response, **kwargs):
        if response.status_code in REDIRECT_STATI and \
                self._looks_like_file(self.body):
            logger.debug("Redirect received, rewinding stream: %s", self.body)
            self.reset_stream()

    def _looks_like_file(self, body):
        return hasattr(body, 'read') and hasattr(body, 'seek')

    def reset_stream(self):
        # Trying to reset a stream when there is a no stream will
        # just immediately return.  It's not an error, it will produce
        # the same result as if we had actually reset the stream (we'll send
        # the entire body contents again if we need to).
        # Same case if the body is a string/bytes type.
        if self.body is None or isinstance(self.body, six.text_type) or \
                isinstance(self.body, six.binary_type):
            return
        try:
            logger.debug("Rewinding stream: %s", self.body)
            self.body.seek(0)
        except Exception as e:
            logger.debug("Unable to rewind stream: %s", e)
            raise UnseekableStreamError(stream_object=self.body)

    def prepare_body(self, data, files, json=None):
        """Prepares the given HTTP body data."""
        super(AWSPreparedRequest, self).prepare_body(data, files, json)

        # Calculate the Content-Length by trying to seek the file as
        # requests cannot determine content length for some seekable file-like
        # objects.
        if 'Content-Length' not in self.headers:
            if hasattr(data, 'seek') and hasattr(data, 'tell'):
                orig_pos = data.tell()
                data.seek(0, 2)
                end_file_pos = data.tell()
                self.headers['Content-Length'] = str(end_file_pos - orig_pos)
                data.seek(orig_pos)
                # If the Content-Length was added this way, a
                # Transfer-Encoding was added by requests because it did
                # not add a Content-Length header. However, the
                # Transfer-Encoding header is not supported for
                # AWS Services so remove it if it is added.
                if 'Transfer-Encoding' in self.headers:
                    self.headers.pop('Transfer-Encoding')

HTTPSConnectionPool.ConnectionCls = AWSHTTPSConnection
HTTPConnectionPool.ConnectionCls = AWSHTTPConnection
                                                                                                                                                                                                                                                                                                           usr/local/lib/python2.7/dist-packages/botocore/awsrequest.pyc                                       0100644 0000000 0000062 00000033476 13077704401 022771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   s˘  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z m	 Z	 m
 Z
 m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d	 l m Z d  d
 l m Z d  d l m Z e j e É Z d e	 f d Ñ  É  YZ d e f d Ñ  É  YZ d e f d Ñ  É  YZ x? e j  j! É  D]. \ Z" Z# e j$ e# É r[e% e e" e# É q[q[Wd d Ñ Z' d Ñ  Z( d Ñ  Z) d e j* e j+ f d Ñ  É  YZ, d e j- f d Ñ  É  YZ. e e _/ e e _/ d S(   iˇˇˇˇN(   t   six(   t   HTTPHeaderst   HTTPResponset
   urlunsplitt   urlsplit(   t   UnseekableStreamError(   t   percent_encode_sequence(   t   models(   t   REDIRECT_STATI(   t   VerifiedHTTPSConnection(   t   HTTPConnection(   t   HTTPConnectionPool(   t   HTTPSConnectionPoolt   AWSHTTPResponsec           B   s   e  Z d  Ñ  Z d Ñ  Z RS(   c         O   s)   | j  d É |  _ t j |  | | é d  S(   Nt   status_tuple(   t   popt   _status_tupleR   t   __init__(   t   selft   argst   kwargs(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   +   s    c         C   s6   |  j  d  k	 r% |  j  } d  |  _  | St j |  É Sd  S(   N(   R   t   NoneR   t   _read_status(   R   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   /   s
    		(   t   __name__t
   __module__R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   (   s   	t   AWSHTTPConnectionc           B   st   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z	 d Ñ  Z
 d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z RS(   sÚ  HTTPConnection that supports Expect 100-continue.

    This is conceptually a subclass of httplib.HTTPConnection (though
    technically we subclass from urllib3, which subclasses
    httplib.HTTPConnection) and we only override this class to support Expect
    100-continue, which we need for S3.  As far as I can tell, this is
    general purpose enough to not be specific to S3, but I'm being
    tentative and keeping it in botocore because I've only tested
    this against AWS services.

    c         O   s5   t  j |  | | é |  j |  _ t |  _ t |  _ d  S(   N(   R
   R   t   response_classt   _original_response_clst   Falset   _response_receivedt   _expect_header_set(   R   R   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   D   s    		c         C   s/   t  j |  É t |  _ t |  _ |  j |  _ d  S(   N(   R
   t   closeR   R   R   R   R   (   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   R   s    		c         C   sB  t  j d  d k r  t j |  É S|  j |  j |  j É |  j d |  j |  j	 f É x4 |  j
 j É  D]# \ } } |  j d | | f É qc W|  j d É |  j |  j d |  j d |  j É} | j É  \ } } } | d k r|  j É  t j d	 | | j É  f É Ç n  x3 t r=| j j É  } | s*Pn  | d k rPqqWd  S(   Ni   i   s   CONNECT %s:%d HTTP/1.0
s   %s: %s
s   
t   strictt   methodi»   s   Tunnel connection failed: %d %ss   
t    (   i   i   (   s   
s   
R"   (   t   syst   version_infoR
   t   _tunnelt   _set_hostportt   _tunnel_hostt   _tunnel_portt   sendt   hostt   portt   _tunnel_headerst	   iteritemsR   t   sockR    t   _methodR   R   t   sockett   errort   stript   Truet   fpt   readline(   R   t   headert   valuet   responset   versiont   codet   messaget   line(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR%   Y   s(    
		c         C   sj   t  |  _ | j d d É d k r- t |  _ n t  |  _ |  j |  _ t j |  | | | | É } t  |  _ | S(   Nt   ExpectR"   s   100-continue(	   R   R   t   getR3   R   R   R   R
   t   _send_request(   R   R!   t   urlt   bodyt   headerst   rval(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR?   y   s    			c         C   sb   g  } xF | D]> } t  | t j É r> | j | j d É É q | j | É q Wd j | É } | S(   Ns   utf-8s   
(   t
   isinstanceR    t	   text_typet   appendt   encodet   join(   R   t   mixed_buffert   bytes_buffert   chunkt   msg(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   _convert_to_bytesÖ   s    c         C   s‚   |  j  j d É |  j |  j  É } |  j  2t | t É rK | | 7} d  } n  |  j | É |  j r¬ t j	 d É t
 j
 |  j g g  |  j g d É \ } } } | r≤ |  j | É d  St j	 d É n  | d  k	 rﬁ |  j | É n  d  S(   NR"   s"   Waiting for 100 Continue response.i   sC   No response seen from server, continuing to send the response body.(   R"   R"   (   t   _buffert   extendRM   RD   t   bytesR   R)   R   t   loggert   debugt   selectR.   t   _handle_expect_response(   R   t   message_bodyRL   t   readt   writet   exc(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   _send_outputí   s     
		-c         C   s)   d  } x | d k r$ | j É  } q	 Wd  S(   Ns   
(   R   R5   (   R   R4   t   current(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   _consume_headers∑   s    c         C   s  |  j  j d d É } zÍ | j É  } | j d  d É } |  j | É ro |  j | É t j d É |  j	 | É nè t
 | É d k r˛ | d j d É r˛ t j d É | d j d É t | d	 É | d j d É f } t j t d
 | É} | |  _ t |  _ n  Wd  | j É  Xd  S(   Nt   rbi    i   s5   100 Continue response seen, now sending request body.i   s   HTTP/sO   Received a non 100 Continue response from the server, NOT sending request body.t   asciii   R   (   R.   t   makefileR5   t   splitR   t   _is_100_continue_statusR[   RQ   RR   t   _send_message_bodyt   lent
   startswitht   decodet   intt	   functoolst   partialR   R   R3   R   R   (   R   RU   R4   t   maybe_status_linet   partsR   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRT   √   s"    %#	c         C   s    | d  k	 r |  j | É n  d  S(   N(   R   R)   (   R   RU   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRa   Ë   s    c         C   s*   |  j  r t j d É d  St j |  | É S(   Ns@   send() called, but reseponse already received. Not sending data.(   R   RQ   RR   R
   R)   (   R   t   str(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR)   Ï   s    	c         C   sE   | j  d  d É } t | É d k oD | d j d É oD | d d k S(   Ni   i   i    s   HTTP/i   t   100(   R_   R   Rb   Rc   (   R   Rh   Ri   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR`   Û   s    %N(   R   R   t   __doc__R   R   R%   R?   RM   R   RY   R[   RT   Ra   R)   R`   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   8   s   			 		%		%		t   AWSHTTPSConnectionc           B   s   e  Z RS(    (   R   R   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRm   ˚   s   c         C   sí   |  } | d	 k	 r) | d } | | d <n  t | | d É } | d rÑ t | d É } d | k rs | d | 7} qÑ | d | 7} n  | | d <d	 S(
   s;  
    This method prepares a request dict to be created into an
    AWSRequestObject. This prepares the request dict by adding the
    url and the user agent to the request dict.

    :type request_dict: dict
    :param request_dict:  The request dict (created from the
        ``serialize`` module).

    :type user_agent: string
    :param user_agent: The user agent to use for this request.

    :type endpoint_url: string
    :param endpoint_url: The full endpoint url, which contains at least
        the scheme, the hostname, and optionally any path components.
    RB   s
   User-Agentt   url_patht   query_stringt   ?s   ?%ss   &%sR@   N(   R   t   _urljoinR   (   t   request_dictt   endpoint_urlt
   user_agentt   rRB   R@   t   encoded_query_string(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   prepare_request_dict  s    

c      
   C   s5   |  } t  d | d d | d d | d d | d É S(   sK  
    This method takes a request dict and creates an AWSRequest object
    from it.

    :type request_dict: dict
    :param request_dict:  The request dict (created from the
        ``prepare_request_dict`` method).

    :rtype: ``botocore.awsrequest.AWSRequest``
    :return: An AWSRequest object based on the request_dict.

    R!   R@   t   dataRA   RB   (   t
   AWSRequest(   Rr   Ru   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   create_request_object&  s    
c         C   s©   t  |  É } | s | d k r5 | d s1 |  d S|  S| d j d É rl | j d É rl | d d  | } n | d | } t | d | d | | d | d f É } | S(   Nt   /i   iˇˇˇˇi    i   i   i   (   R   t   endswithRc   R   (   Rs   Rn   t   pt   new_patht   reconstructed(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRq   9  s    
"+Ry   c           B   s)   e  Z d  Ñ  Z d Ñ  Z e d Ñ  É Z RS(   c         O   sù   d  |  _ d | k r, | d |  _ | d =n  t j j |  | | é t É  } |  j d  k	 rá x* |  j j É  D] \ } } | | | <qj Wn  | |  _ i  |  _ d  S(   Nt	   auth_path(	   R   RÄ   R   t   RequestR   R   RB   t   itemst   context(   R   R   R   RB   t   keyR7   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   P  s    	
		c         C   s|   t  |  É } | j |  j É | j |  j |  j É | j |  j É | j |  j	 É | j
 |  j |  j É | j |  j É | S(   s>   Constructs a :class:`AWSPreparedRequest <AWSPreparedRequest>`.(   t   AWSPreparedRequestt   prepare_methodR!   t   prepare_urlR@   t   paramst   prepare_headersRB   t   prepare_cookiest   cookiest   prepare_bodyRx   t   filest   prepare_autht   auth(   R   R}   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   prepared  s    c         C   sc   t  j É  } | j i  É | j |  j |  j É t | j t j	 É r\ | j j
 d É | _ n  | j S(   Ns   utf-8(   R   t   PreparedRequestRâ   Rå   Rx   Rç   RD   RA   R    RE   RG   (   R   R}   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRA   p  s    (   R   R   R   Rê   t   propertyRA   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRy   O  s   		RÖ   c           B   s>   e  Z d  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d d Ñ Z RS(   sú  Represents a prepared request.

    :ivar method: HTTP Method
    :ivar url: The full url
    :ivar headers: The HTTP headers to send.
    :ivar body: The HTTP body.
    :ivar hooks: The set of callback hooks.

    In addition to the above attributes, the following attributes are
    available:

    :ivar query_params: The original query parameters.
    :ivar post_param: The original POST params (dict).

    c         C   s?   | |  _  t t |  É j É  |  j j d g  É j |  j É d  S(   NR8   (   t   originalt   superRÖ   R   t   hookst
   setdefaultRF   t   reset_stream_on_redirect(   R   t   original_request(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyR   ä  s    	c         K   sE   | j  t k rA |  j |  j É rA t j d |  j É |  j É  n  d  S(   Ns'   Redirect received, rewinding stream: %s(   t   status_codeR   t   _looks_like_fileRA   RQ   RR   t   reset_stream(   R   R8   R   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRó   ê  s    c         C   s   t  | d É o t  | d É S(   NRV   t   seek(   t   hasattr(   R   RA   (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRö   ñ  s    c         C   s†   |  j  d  k s9 t |  j  t j É s9 t |  j  t j É r= d  Sy' t j d |  j  É |  j  j d É Wn5 t	 k
 rõ } t j d | É t
 d |  j  É Ç n Xd  S(   Ns   Rewinding stream: %si    s   Unable to rewind stream: %st   stream_object(   RA   R   RD   R    RE   t   binary_typeRQ   RR   Rú   t	   ExceptionR   (   R   t   e(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRõ   ô  s    $c         C   s¡   t  t |  É j | | | É d |  j k rΩ t | d É rΩ t | d É rΩ | j É  } | j d d É | j É  } t | | É |  j d <| j | É d |  j k r∫ |  j j d É q∫ qΩ n  d S(   s"   Prepares the given HTTP body data.s   Content-LengthRú   t   telli    i   s   Transfer-EncodingN(	   Rî   RÖ   Rå   RB   Rù   R¢   Rú   Rj   R   (   R   Rx   Rç   t   jsont   orig_post   end_file_pos(    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRå   ©  s    N(	   R   R   Rl   R   Ró   Rö   Rõ   R   Rå   (    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyRÖ   z  s   				(0   R#   t   loggingRS   Rf   R0   t   inspectt   botocore.compatR    R   R   R   R   t   botocore.exceptionsR   t   botocore.utilsR   t   botocore.vendored.requestsR   t#   botocore.vendored.requests.sessionsR   t6   botocore.vendored.requests.packages.urllib3.connectionR	   R
   t:   botocore.vendored.requests.packages.urllib3.connectionpoolR   R   t	   getLoggerR   RQ   R   R   Rm   t   __dict__RÇ   t   namet   functiont
   isfunctiont   setattrR   Rw   Rz   Rq   t   RequestEncodingMixinRÅ   Ry   Rë   RÖ   t   ConnectionCls(    (    (    s5   /tmp/pip-build-awuatQ/botocore/botocore/awsrequest.pyt   <module>   s:   "√		+E	                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/botocore/client.py                                            0100644 0000000 0000062 00000073560 13077704371 021705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import copy
import logging

import botocore.serialize
import botocore.validate
from botocore import waiter, xform_name
from botocore.auth import AUTH_TYPE_MAPS
from botocore.awsrequest import prepare_request_dict
from botocore.config import Config
from botocore.docs.docstring import ClientMethodDocstring
from botocore.docs.docstring import PaginatorDocstring
from botocore.endpoint import EndpointCreator
from botocore.exceptions import ClientError, DataNotFoundError
from botocore.exceptions import OperationNotPageableError
from botocore.exceptions import UnknownSignatureVersionError
from botocore.hooks import first_non_none_response
from botocore.model import ServiceModel
from botocore.paginate import Paginator
from botocore.signers import RequestSigner
from botocore.utils import CachedProperty
from botocore.utils import fix_s3_host
from botocore.utils import get_service_module_name
from botocore.utils import switch_to_virtual_host_style

logger = logging.getLogger(__name__)


class ClientCreator(object):
    """Creates client objects for a service."""
    def __init__(self, loader, endpoint_resolver, user_agent, event_emitter,
                 retry_handler_factory, retry_config_translator,
                 response_parser_factory=None):
        self._loader = loader
        self._endpoint_resolver = endpoint_resolver
        self._user_agent = user_agent
        self._event_emitter = event_emitter
        self._retry_handler_factory = retry_handler_factory
        self._retry_config_translator = retry_config_translator
        self._response_parser_factory = response_parser_factory

    def create_client(self, service_name, region_name, is_secure=True,
                      endpoint_url=None, verify=None,
                      credentials=None, scoped_config=None,
                      api_version=None,
                      client_config=None):
        service_model = self._load_service_model(service_name, api_version)
        cls = self._create_client_class(service_name, service_model)
        client_args = self._get_client_args(
            service_model, region_name, is_secure, endpoint_url,
            verify, credentials, scoped_config, client_config)
        return cls(**client_args)

    def create_client_class(self, service_name, api_version=None):
        service_model = self._load_service_model(service_name, api_version)
        return self._create_client_class(service_name, service_model)

    def _create_client_class(self, service_name, service_model):
        class_attributes = self._create_methods(service_model)
        py_name_to_operation_name = self._create_name_mapping(service_model)
        class_attributes['_PY_TO_OP_NAME'] = py_name_to_operation_name
        bases = [BaseClient]
        self._event_emitter.emit('creating-client-class.%s' % service_name,
                                 class_attributes=class_attributes,
                                 base_classes=bases)
        class_name = get_service_module_name(service_model)
        cls = type(str(class_name), tuple(bases), class_attributes)
        return cls

    def _load_service_model(self, service_name, api_version=None):
        json_model = self._loader.load_service_model(service_name, 'service-2',
                                                     api_version=api_version)
        service_model = ServiceModel(json_model, service_name=service_name)
        self._register_retries(service_model)
        return service_model

    def _register_retries(self, service_model):
        endpoint_prefix = service_model.endpoint_prefix

        # First, we load the entire retry config for all services,
        # then pull out just the information we need.
        original_config = self._loader.load_data('_retry')
        if not original_config:
            return

        retry_config = self._retry_config_translator.build_retry_config(
            endpoint_prefix, original_config.get('retry', {}),
            original_config.get('definitions', {}))

        logger.debug("Registering retry handlers for service: %s",
                     service_model.service_name)
        handler = self._retry_handler_factory.create_retry_handler(
            retry_config, endpoint_prefix)
        unique_id = 'retry-config-%s' % endpoint_prefix
        self._event_emitter.register('needs-retry.%s' % endpoint_prefix,
                                     handler, unique_id=unique_id)

    def _inject_s3_configuration(self, config_kwargs, scoped_config,
                                 client_config):
        s3_configuration = None

        # Check the scoped config first
        if scoped_config is not None:
            s3_configuration = scoped_config.get('s3')

        # Next specfic client config values takes precedence over
        # specific values in the scoped config.
        if client_config is not None:
            if client_config.s3 is not None:
                if s3_configuration is None:
                    s3_configuration = client_config.s3
                else:
                    # The current s3_configuration dictionary may be
                    # from a source that only should be read from so
                    # we want to be safe and just make a copy of it to modify
                    # before it actually gets updated.
                    s3_configuration = s3_configuration.copy()
                    s3_configuration.update(client_config.s3)

        config_kwargs['s3'] = s3_configuration

    def _get_client_args(self, service_model, region_name, is_secure,
                         endpoint_url, verify, credentials,
                         scoped_config, client_config):
        service_name = service_model.endpoint_prefix
        protocol = service_model.metadata['protocol']
        parameter_validation = True
        if client_config:
            parameter_validation = client_config.parameter_validation
        serializer = botocore.serialize.create_serializer(
            protocol, parameter_validation)

        event_emitter = copy.copy(self._event_emitter)
        response_parser = botocore.parsers.create_parser(protocol)
        endpoint_bridge = ClientEndpointBridge(
            self._endpoint_resolver, scoped_config, client_config,
            service_signing_name=service_model.metadata.get('signingName'))
        endpoint_config = endpoint_bridge.resolve(
            service_name, region_name, endpoint_url, is_secure)

        # Override the user agent if specified in the client config.
        user_agent = self._user_agent
        if client_config is not None:
            if client_config.user_agent is not None:
                user_agent = client_config.user_agent
            if client_config.user_agent_extra is not None:
                user_agent += ' %s' % client_config.user_agent_extra

        signer = RequestSigner(
            service_name, endpoint_config['signing_region'],
            endpoint_config['signing_name'],
            endpoint_config['signature_version'],
            credentials, event_emitter)

        # Create a new client config to be passed to the client based
        # on the final values. We do not want the user to be able
        # to try to modify an existing client with a client config.
        config_kwargs = dict(
            region_name=endpoint_config['region_name'],
            signature_version=endpoint_config['signature_version'],
            user_agent=user_agent)
        if client_config is not None:
            config_kwargs.update(
                connect_timeout=client_config.connect_timeout,
                read_timeout=client_config.read_timeout)

        # Add any additional s3 configuration for client
        self._inject_s3_configuration(
            config_kwargs, scoped_config, client_config)

        new_config = Config(**config_kwargs)
        endpoint_creator = EndpointCreator(event_emitter)
        endpoint = endpoint_creator.create_endpoint(
            service_model, region_name=endpoint_config['region_name'],
            endpoint_url=endpoint_config['endpoint_url'], verify=verify,
            response_parser_factory=self._response_parser_factory,
            timeout=(new_config.connect_timeout, new_config.read_timeout))

        return {
            'serializer': serializer,
            'endpoint': endpoint,
            'response_parser': response_parser,
            'event_emitter': event_emitter,
            'request_signer': signer,
            'service_model': service_model,
            'loader': self._loader,
            'client_config': new_config
        }

    def _create_methods(self, service_model):
        op_dict = {}
        for operation_name in service_model.operation_names:
            py_operation_name = xform_name(operation_name)
            op_dict[py_operation_name] = self._create_api_method(
                py_operation_name, operation_name, service_model)
        return op_dict

    def _create_name_mapping(self, service_model):
        # py_name -> OperationName, for every operation available
        # for a service.
        mapping = {}
        for operation_name in service_model.operation_names:
            py_operation_name = xform_name(operation_name)
            mapping[py_operation_name] = operation_name
        return mapping

    def _create_api_method(self, py_operation_name, operation_name,
                           service_model):
        def _api_call(self, *args, **kwargs):
            # We're accepting *args so that we can give a more helpful
            # error message than TypeError: _api_call takes exactly
            # 1 argument.
            if args:
                raise TypeError(
                    "%s() only accepts keyword arguments." % py_operation_name)
            # The "self" in this scope is referring to the BaseClient.
            return self._make_api_call(operation_name, kwargs)

        _api_call.__name__ = str(py_operation_name)

        # Add the docstring to the client method
        operation_model = service_model.operation_model(operation_name)
        docstring = ClientMethodDocstring(
            operation_model=operation_model,
            method_name=operation_name,
            event_emitter=self._event_emitter,
            method_description=operation_model.documentation,
            example_prefix='response = client.%s' % py_operation_name,
            include_signature=False
        )
        _api_call.__doc__ = docstring
        return _api_call


class ClientEndpointBridge(object):
    """Bridges endpoint data and client creation

    This class handles taking out the relevant arguments from the endpoint
    resolver and determining which values to use, taking into account any
    client configuration options and scope configuration options.

    This class also handles determining what, if any, region to use if no
    explicit region setting is provided. For example, Amazon S3 client will
    utilize "us-east-1" by default if no region can be resolved."""

    DEFAULT_ENDPOINT = '{service}.{region}.amazonaws.com'

    def __init__(self, endpoint_resolver, scoped_config=None,
                 client_config=None, default_endpoint=None,
                 service_signing_name=None):
        self.service_signing_name = service_signing_name
        self.endpoint_resolver = endpoint_resolver
        self.scoped_config = scoped_config
        self.client_config = client_config
        self.default_endpoint = default_endpoint or self.DEFAULT_ENDPOINT

    def resolve(self, service_name, region_name=None, endpoint_url=None,
                is_secure=True):
        region_name = self._check_default_region(service_name, region_name)
        resolved = self.endpoint_resolver.construct_endpoint(
            service_name, region_name)
        if resolved:
            return self._create_endpoint(
                resolved, service_name, region_name, endpoint_url, is_secure)
        else:
            return self._assume_endpoint(service_name, region_name,
                                         endpoint_url, is_secure)

    def _check_default_region(self, service_name, region_name):
        if region_name is not None:
            return region_name
        # Use the client_config region if no explicit region was provided.
        if self.client_config and self.client_config.region_name is not None:
            return self.client_config.region_name

    def _create_endpoint(self, resolved, service_name, region_name,
                         endpoint_url, is_secure):
        region_name, signing_region = self._pick_region_values(
            resolved, region_name, endpoint_url)
        if endpoint_url is None:
            # Use the sslCommonName over the hostname for Python 2.6 compat.
            hostname = resolved.get('sslCommonName', resolved.get('hostname'))
            endpoint_url = self._make_url(hostname, is_secure,
                                          resolved.get('protocols', []))
        signature_version = self._resolve_signature_version(
            service_name, resolved)
        signing_name = self._resolve_signing_name(service_name, resolved)
        return self._create_result(
            service_name=service_name, region_name=region_name,
            signing_region=signing_region, signing_name=signing_name,
            endpoint_url=endpoint_url, metadata=resolved,
            signature_version=signature_version)

    def _assume_endpoint(self, service_name, region_name, endpoint_url,
                         is_secure):
        if endpoint_url is None:
            # Expand the default hostname URI template.
            hostname = self.default_endpoint.format(
                service=service_name, region=region_name)
            endpoint_url = self._make_url(hostname, is_secure,
                                          ['http', 'https'])
        logger.debug('Assuming an endpoint for %s, %s: %s',
                     service_name, region_name, endpoint_url)
        # We still want to allow the user to provide an explicit version.
        signature_version = self._resolve_signature_version(
            service_name, {'signatureVersions': ['v4']})
        signing_name = self._resolve_signing_name(service_name, resolved={})
        return self._create_result(
            service_name=service_name, region_name=region_name,
            signing_region=region_name, signing_name=signing_name,
            signature_version=signature_version, endpoint_url=endpoint_url,
            metadata={})

    def _create_result(self, service_name, region_name, signing_region,
                       signing_name, endpoint_url, signature_version,
                       metadata):
        return {
            'service_name': service_name,
            'region_name': region_name,
            'signing_region': signing_region,
            'signing_name': signing_name,
            'endpoint_url': endpoint_url,
            'signature_version': signature_version,
            'metadata': metadata
        }

    def _make_url(self, hostname, is_secure, supported_protocols):
        if is_secure and 'https' in supported_protocols:
            scheme ='https'
        else:
            scheme = 'http'
        return '%s://%s' % (scheme, hostname)

    def _resolve_signing_name(self, service_name, resolved):
        # CredentialScope overrides everything else.
        if 'credentialScope' in resolved \
                and 'service' in resolved['credentialScope']:
            return resolved['credentialScope']['service']
        # Use the signingName from the model if present.
        if self.service_signing_name:
            return self.service_signing_name
        # Just assume is the same as the service name.
        return service_name

    def _pick_region_values(self, resolved, region_name, endpoint_url):
        signing_region = region_name
        if endpoint_url is None:
            # Do not use the region name or signing name from the resolved
            # endpoint if the user explicitly provides an endpoint_url. This
            # would happen if we resolve to an endpoint where the service has
            # a "defaults" section that overrides all endpoint with a single
            # hostname and credentialScope. This has been the case historically
            # for how STS has worked. The only way to resolve an STS endpoint
            # was to provide a region_name and an endpoint_url. In that case,
            # we would still resolve an endpoint, but we would not use the
            # resolved endpointName or signingRegion because we want to allow
            # custom endpoints.
            region_name = resolved['endpointName']
            signing_region = region_name
            if 'credentialScope' in resolved \
                    and 'region' in resolved['credentialScope']:
                signing_region = resolved['credentialScope']['region']
        return region_name, signing_region

    def _resolve_signature_version(self, service_name, resolved):
        # Client config overrides everything.
        client = self.client_config
        if client and client.signature_version is not None:
            return client.signature_version
        # Scoped config overrides picking from the endpoint metadata.
        scoped = self.scoped_config
        if scoped is not None:
            service_config = scoped.get(service_name)
            if service_config is not None and isinstance(service_config, dict):
                version = service_config.get('signature_version')
                if version:
                    logger.debug(
                        "Switching signature version for service %s "
                        "to version %s based on config file override.",
                        service_name, version)
                    return version
        # Pick a signature version from the endpoint metadata if present.
        if 'signatureVersions' in resolved:
            potential_versions = resolved['signatureVersions']
            if service_name == 's3':
                # We currently prefer s3 over s3v4.
                if 's3' in potential_versions:
                    return 's3'
                elif 's3v4' in potential_versions:
                    return 's3v4'
            if 'v4' in potential_versions:
                return 'v4'
            # Now just iterate over the signature versions in order until we
            # find the first one that is known to Botocore.
            for known in AUTH_TYPE_MAPS:
                if known in potential_versions:
                    return known
        raise UnknownSignatureVersionError(
            signature_version=resolved.get('signatureVersions'))


class BaseClient(object):

    # This is actually reassigned with the py->op_name mapping
    # when the client creator creates the subclass.  This value is used
    # because calls such as client.get_paginator('list_objects') use the
    # snake_case name, but we need to know the ListObjects form.
    # xform_name() does the ListObjects->list_objects conversion, but
    # we need the reverse mapping here.
    _PY_TO_OP_NAME = {}

    def __init__(self, serializer, endpoint, response_parser,
                 event_emitter, request_signer, service_model, loader,
                 client_config):
        self._serializer = serializer
        self._endpoint = endpoint
        self._response_parser = response_parser
        self._request_signer = request_signer
        self._cache = {}
        self._loader = loader
        self._client_config = client_config
        self.meta = ClientMeta(event_emitter, self._client_config,
                               endpoint.host, service_model,
                               self._PY_TO_OP_NAME)
        self._register_handlers()

    def _register_handlers(self):
        # Register the handler required to sign requests.
        self.meta.events.register('request-created.%s' %
                                  self.meta.service_model.endpoint_prefix,
                                  self._request_signer.handler)

        # If the virtual host addressing style is being forced,
        # switch the default fix_s3_host handler for the more general
        # switch_to_virtual_host_style handler that does not have opt out
        # cases (other than throwing an error if the name is DNS incompatible)
        if self.meta.config.s3 is None:
            s3_addressing_style = None
        else:
            s3_addressing_style = self.meta.config.s3.get('addressing_style')

        if s3_addressing_style == 'path':
            self.meta.events.unregister('before-sign.s3', fix_s3_host)
        elif s3_addressing_style == 'virtual':
            self.meta.events.unregister('before-sign.s3', fix_s3_host)
            self.meta.events.register(
                'before-sign.s3', switch_to_virtual_host_style)

    @property
    def _service_model(self):
        return self.meta.service_model

    def _make_api_call(self, operation_name, api_params):
        request_context = {}
        operation_model = self._service_model.operation_model(operation_name)
        request_dict = self._convert_to_request_dict(
            api_params, operation_model, context=request_context)

        handler, event_response = self.meta.events.emit_until_response(
            'before-call.{endpoint_prefix}.{operation_name}'.format(
                endpoint_prefix=self._service_model.endpoint_prefix,
                operation_name=operation_name),
            model=operation_model, params=request_dict,
            request_signer=self._request_signer, context=request_context)

        if event_response is not None:
            http, parsed_response = event_response
        else:
            http, parsed_response = self._endpoint.make_request(
                operation_model, request_dict)

        self.meta.events.emit(
            'after-call.{endpoint_prefix}.{operation_name}'.format(
                endpoint_prefix=self._service_model.endpoint_prefix,
                operation_name=operation_name),
            http_response=http, parsed=parsed_response,
            model=operation_model, context=request_context
        )

        if http.status_code >= 300:
            raise ClientError(parsed_response, operation_name)
        else:
            return parsed_response

    def _convert_to_request_dict(self, api_params, operation_model,
                                 context=None):
        # Given the API params provided by the user and the operation_model
        # we can serialize the request to a request_dict.
        operation_name = operation_model.name

        # Emit an event that allows users to modify the parameters at the
        # beginning of the method. It allows handlers to modify existing
        # parameters or return a new set of parameters to use.
        responses = self.meta.events.emit(
            'provide-client-params.{endpoint_prefix}.{operation_name}'.format(
                endpoint_prefix=self._service_model.endpoint_prefix,
                operation_name=operation_name),
            params=api_params, model=operation_model, context=context)
        api_params = first_non_none_response(responses, default=api_params)

        event_name = (
            'before-parameter-build.{endpoint_prefix}.{operation_name}')
        self.meta.events.emit(
            event_name.format(
                endpoint_prefix=self._service_model.endpoint_prefix,
                operation_name=operation_name),
            params=api_params, model=operation_model, context=context)

        request_dict = self._serializer.serialize_to_request(
            api_params, operation_model)
        prepare_request_dict(request_dict, endpoint_url=self._endpoint.host,
                             user_agent=self._client_config.user_agent)
        return request_dict

    def get_paginator(self, operation_name):
        """Create a paginator for an operation.

        :type operation_name: string
        :param operation_name: The operation name.  This is the same name
            as the method name on the client.  For example, if the
            method name is ``create_foo``, and you'd normally invoke the
            operation as ``client.create_foo(**kwargs)``, if the
            ``create_foo`` operation can be paginated, you can use the
            call ``client.get_paginator("create_foo")``.

        :raise OperationNotPageableError: Raised if the operation is not
            pageable.  You can use the ``client.can_paginate`` method to
            check if an operation is pageable.

        :rtype: L{botocore.paginate.Paginator}
        :return: A paginator object.

        """
        if not self.can_paginate(operation_name):
            raise OperationNotPageableError(operation_name=operation_name)
        else:
            actual_operation_name = self._PY_TO_OP_NAME[operation_name]

            # Create a new paginate method that will serve as a proxy to
            # the underlying Paginator.paginate method. This is needed to
            # attach a docstring to the method.
            def paginate(self, **kwargs):
                return Paginator.paginate(self, **kwargs)

            paginator_config = self._cache['page_config'][
                actual_operation_name]
            # Add the docstring for the paginate method.
            paginate.__doc__ = PaginatorDocstring(
                paginator_name=actual_operation_name,
                event_emitter=self.meta.events,
                service_model=self.meta.service_model,
                paginator_config=paginator_config,
                include_signature=False
            )

            # Rename the paginator class based on the type of paginator.
            paginator_class_name = str('%s.Paginator.%s' % (
                get_service_module_name(self.meta.service_model),
                actual_operation_name))

            # Create the new paginator class
            documented_paginator_cls = type(
                paginator_class_name, (Paginator,), {'paginate': paginate})

            paginator = documented_paginator_cls(
                getattr(self, operation_name),
                paginator_config)
            return paginator

    def can_paginate(self, operation_name):
        """Check if an operation can be paginated.

        :type operation_name: string
        :param operation_name: The operation name.  This is the same name
            as the method name on the client.  For example, if the
            method name is ``create_foo``, and you'd normally invoke the
            operation as ``client.create_foo(**kwargs)``, if the
            ``create_foo`` operation can be paginated, you can use the
            call ``client.get_paginator("create_foo")``.

        :return: ``True`` if the operation can be paginated,
            ``False`` otherwise.

        """
        if 'page_config' not in self._cache:
            try:
                page_config = self._loader.load_service_model(
                    self._service_model.service_name,
                    'paginators-1',
                    self._service_model.api_version)['pagination']
                self._cache['page_config'] = page_config
            except DataNotFoundError:
                self._cache['page_config'] = {}
        actual_operation_name = self._PY_TO_OP_NAME[operation_name]
        return actual_operation_name in self._cache['page_config']

    def _get_waiter_config(self):
        if 'waiter_config' not in self._cache:
            try:
                waiter_config = self._loader.load_service_model(
                    self._service_model.service_name,
                    'waiters-2',
                    self._service_model.api_version)
                self._cache['waiter_config'] = waiter_config
            except DataNotFoundError:
                self._cache['waiter_config'] = {}
        return self._cache['waiter_config']

    def get_waiter(self, waiter_name):
        config = self._get_waiter_config()
        if not config:
            raise ValueError("Waiter does not exist: %s" % waiter_name)
        model = waiter.WaiterModel(config)
        mapping = {}
        for name in model.waiter_names:
            mapping[xform_name(name)] = name
        if waiter_name not in mapping:
            raise ValueError("Waiter does not exist: %s" % waiter_name)

        return waiter.create_waiter_with_client(
            mapping[waiter_name], model, self)

    @CachedProperty
    def waiter_names(self):
        """Returns a list of all available waiters."""
        config = self._get_waiter_config()
        if not config:
            return []
        model = waiter.WaiterModel(config)
        # Waiter configs is a dict, we just want the waiter names
        # which are the keys in the dict.
        return [xform_name(name) for name in model.waiter_names]


class ClientMeta(object):
    """Holds additional client methods.

    This class holds additional information for clients.  It exists for
    two reasons:

        * To give advanced functionality to clients
        * To namespace additional client attributes from the operation
          names which are mapped to methods at runtime.  This avoids
          ever running into collisions with operation names.

    """

    def __init__(self, events, client_config, endpoint_url, service_model,
                 method_to_api_mapping):
        self.events = events
        self._client_config = client_config
        self._endpoint_url = endpoint_url
        self._service_model = service_model
        self._method_to_api_mapping = method_to_api_mapping

    @property
    def service_model(self):
        return self._service_model

    @property
    def region_name(self):
        return self._client_config.region_name

    @property
    def endpoint_url(self):
        return self._endpoint_url

    @property
    def config(self):
        return self._client_config

    @property
    def method_to_api_mapping(self):
        return self._method_to_api_mapping
                                                                                                                                                usr/local/lib/python2.7/dist-packages/botocore/client.pyc                                           0100644 0000000 0000062 00000051144 13077704401 022034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   s«  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l m Z m Z d  d l m Z d  d l	 m
 Z
 d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d	 l m Z m Z d  d
 l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m  Z  d  d l m! Z! d  d l m" Z" d  d l m# Z# e j$ e% É Z& d e' f d Ñ  É  YZ( d e' f d Ñ  É  YZ) d e' f d Ñ  É  YZ* d e' f d Ñ  É  YZ+ d S(   iˇˇˇˇN(   t   waitert
   xform_name(   t   AUTH_TYPE_MAPS(   t   prepare_request_dict(   t   Config(   t   ClientMethodDocstring(   t   PaginatorDocstring(   t   EndpointCreator(   t   ClientErrort   DataNotFoundError(   t   OperationNotPageableError(   t   UnknownSignatureVersionError(   t   first_non_none_response(   t   ServiceModel(   t	   Paginator(   t   RequestSigner(   t   CachedProperty(   t   fix_s3_host(   t   get_service_module_name(   t   switch_to_virtual_host_stylet   ClientCreatorc           B   sè   e  Z d  Z d d Ñ Z e d d d d d d d Ñ Z d d Ñ Z d Ñ  Z d d Ñ Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z RS(   s%   Creates client objects for a service.c         C   sC   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ | |  _ d  S(   N(   t   _loadert   _endpoint_resolvert   _user_agentt   _event_emittert   _retry_handler_factoryt   _retry_config_translatort   _response_parser_factory(   t   selft   loadert   endpoint_resolvert
   user_agentt   event_emittert   retry_handler_factoryt   retry_config_translatort   response_parser_factory(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   __init__*   s    						c
      	   C   sR   |  j  | | É }
 |  j | |
 É } |  j |
 | | | | | | |	 É } | | ç  S(   N(   t   _load_service_modelt   _create_client_classt   _get_client_args(   R   t   service_namet   region_namet	   is_securet   endpoint_urlt   verifyt   credentialst   scoped_configt   api_versiont   client_configt   service_modelt   clst   client_args(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   create_client5   s    c         C   s"   |  j  | | É } |  j | | É S(   N(   R%   R&   (   R   R(   R/   R1   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   create_client_classA   s    c         C   s   |  j  | É } |  j | É } | | d <t g } |  j j d | d | d | Ét | É } t t | É t | É | É } | S(   Nt   _PY_TO_OP_NAMEs   creating-client-class.%st   class_attributest   base_classes(	   t   _create_methodst   _create_name_mappingt
   BaseClientR   t   emitR   t   typet   strt   tuple(   R   R(   R1   R7   t   py_name_to_operation_namet   basest
   class_nameR2   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR&   E   s    
	c         C   s>   |  j  j | d d | É} t | d | É} |  j | É | S(   Ns	   service-2R/   R(   (   R   t   load_service_modelR   t   _register_retries(   R   R(   R/   t
   json_modelR1   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR%   Q   s
    	c         C   s®   | j  } |  j j d É } | s% d  S|  j j | | j d i  É | j d i  É É } t j d | j É |  j	 j
 | | É } d | } |  j j d | | d | Éd  S(   Nt   _retryt   retryt   definitionss*   Registering retry handlers for service: %ss   retry-config-%ss   needs-retry.%st	   unique_id(   t   endpoint_prefixR   t	   load_dataR   t   build_retry_configt   gett   loggert   debugR(   R   t   create_retry_handlerR   t   register(   R   R1   RJ   t   original_configt   retry_configt   handlerRI   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRD   X   s    			
	
c         C   sá   d  } | d  k	 r$ | j d É } n  | d  k	 ry | j d  k	 ry | d  k rW | j } qv | j É  } | j | j É qy n  | | d <d  S(   Nt   s3(   t   NoneRM   RU   t   copyt   update(   R   t   config_kwargsR.   R0   t   s3_configuration(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   _inject_s3_configurationm   s    c	         C   s  | j  }	 | j d }
 t } | r. | j } n  t j j |
 | É } t j |  j É } t j	 j
 |
 É } t |  j | | d | j j d É É} | j |	 | | | É } |  j } | d  k	 r¸ | j d  k	 r÷ | j } n  | j d  k	 r¸ | d | j 7} q¸ n  t |	 | d | d | d | | É } t d | d d | d d	 | É } | d  k	 rq| j d
 | j d | j É n  |  j | | | É t | ç  } t | É } | j | d | d d | d d | d |  j d | j | j f É} i | d 6| d 6| d 6| d 6| d 6| d 6|  j d 6| d 6S(   Nt   protocolt   service_signing_namet   signingNames    %st   signing_regiont   signing_namet   signature_versionR)   R   t   connect_timeoutt   read_timeoutR+   R,   R#   t   timeoutt
   serializert   endpointt   response_parserR    t   request_signerR1   R   R0   (   RJ   t   metadatat   Truet   parameter_validationt   botocoret	   serializet   create_serializerRW   R   t   parserst   create_parsert   ClientEndpointBridgeR   RM   t   resolveR   RV   R   t   user_agent_extraR   t   dictRX   Rb   Rc   R[   R   R   t   create_endpointR   R   (   R   R1   R)   R*   R+   R,   R-   R.   R0   R(   R\   Rk   Re   R    Rg   t   endpoint_bridget   endpoint_configR   t   signerRY   t
   new_configt   endpoint_creatorRf   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR'   Ö   sf    			


				
c         C   sC   i  } x6 | j  D]+ } t | É } |  j | | | É | | <q W| S(   N(   t   operation_namesR   t   _create_api_method(   R   R1   t   op_dictt   operation_namet   py_operation_name(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR9   …   s    c         C   s4   i  } x' | j  D] } t | É } | | | <q W| S(   N(   R{   R   (   R   R1   t   mappingR~   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR:   —   s
    c            st   á  á f d Ü  } t  à É | _ | j à  É } t d | d à  d |  j d | j d d à d t É } | | _ | S(	   Nc            s)   | r t  d à É Ç n  |  j à  | É S(   Ns$   %s() only accepts keyword arguments.(   t	   TypeErrort   _make_api_call(   R   t   argst   kwargs(   R~   R   (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt	   _api_call‹   s    t   operation_modelt   method_nameR    t   method_descriptiont   example_prefixs   response = client.%st   include_signature(   R>   t   __name__RÜ   R   R   t   documentationt   Falset   __doc__(   R   R   R~   R1   RÖ   RÜ   t	   docstring(    (   R~   R   s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR|   ⁄   s    
		
		N(   Rã   t
   __module__Ré   RV   R$   Rj   R4   R5   R&   R%   RD   R[   R'   R9   R:   R|   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR   (   s    					D			Rq   c           B   sÉ   e  Z d  Z d Z d d d d d Ñ Z d d e d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d	 Ñ  Z d
 Ñ  Z d Ñ  Z RS(   sŸ  Bridges endpoint data and client creation

    This class handles taking out the relevant arguments from the endpoint
    resolver and determining which values to use, taking into account any
    client configuration options and scope configuration options.

    This class also handles determining what, if any, region to use if no
    explicit region setting is provided. For example, Amazon S3 client will
    utilize "us-east-1" by default if no region can be resolved.s    {service}.{region}.amazonaws.comc         C   s:   | |  _  | |  _ | |  _ | |  _ | p0 |  j |  _ d  S(   N(   R]   R   R.   R0   t   DEFAULT_ENDPOINTt   default_endpoint(   R   R   R.   R0   Rí   R]   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR$     s
    				c         C   s`   |  j  | | É } |  j j | | É } | rF |  j | | | | | É S|  j | | | | É Sd  S(   N(   t   _check_default_regionR   t   construct_endpointt   _create_endpointt   _assume_endpoint(   R   R(   R)   R+   R*   t   resolved(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRr     s    	c         C   s9   | d  k	 r | S|  j r5 |  j j d  k	 r5 |  j j Sd  S(   N(   RV   R0   R)   (   R   R(   R)   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRì     s    c   
      C   sæ   |  j  | | | É \ } } | d  k rf | j d | j d É É } |  j | | | j d g  É É } n  |  j | | É } |  j | | É }	 |  j d | d | d | d |	 d | d	 | d
 | É S(   Nt   sslCommonNamet   hostnamet	   protocolsR(   R)   R_   R`   R+   Ri   Ra   (   t   _pick_region_valuesRV   RM   t	   _make_urlt   _resolve_signature_versiont   _resolve_signing_namet   _create_result(
   R   Ró   R(   R)   R+   R*   R_   Rô   Ra   R`   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRï     s    	c         C   s¿   | d  k rE |  j j d | d | É } |  j | | d d g É } n  t j d | | | É |  j | i d g d 6É } |  j | d i  É} |  j d	 | d
 | d | d | d | d | d i  É S(   Nt   servicet   regiont   httpt   httpss#   Assuming an endpoint for %s, %s: %st   v4t   signatureVersionsRó   R(   R)   R_   R`   Ra   R+   Ri   (	   RV   Rí   t   formatRú   RN   RO   Rù   Rû   Rü   (   R   R(   R)   R+   R*   Rô   Ra   R`   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRñ   1  s    		c         C   s5   i | d 6| d 6| d 6| d 6| d 6| d 6| d 6S(   NR(   R)   R_   R`   R+   Ra   Ri   (    (   R   R(   R)   R_   R`   R+   Ra   Ri   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRü   E  s    c         C   s/   | r d | k r d } n d } d | | f S(   NR£   R¢   s   %s://%s(    (   R   Rô   R*   t   supported_protocolst   scheme(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRú   R  s    	c         C   s<   d | k r( d | d k r( | d d S|  j  r8 |  j  S| S(   Nt   credentialScopeR†   (   R]   (   R   R(   Ró   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRû   Y  s    	c         C   s\   | } | d  k rR | d } | } d | k rR d | d k rR | d d } qR n  | | f S(   Nt   endpointNameR©   R°   (   RV   (   R   Ró   R)   R+   R_   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRõ   d  s    
c   	      C   s+  |  j  } | r% | j d  k	 r% | j S|  j } | d  k	 rñ | j | É } | d  k	 rñ t | t É rñ | j d É } | rì t j d | | É | Sqñ n  d | k r| d } | d k r€ d | k r» d Sd | k r€ d Sn  d | k rÎ d Sx! t	 D] } | | k rÚ | SqÚ Wn  t
 d | j d É É Ç d  S(   NRa   sW   Switching signature version for service %s to version %s based on config file override.R•   RU   t   s3v4R§   (   R0   Ra   RV   R.   RM   t
   isinstanceRt   RN   RO   R   R   (	   R   R(   Ró   t   clientt   scopedt   service_configt   versiont   potential_versionst   known(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRù   x  s6    		


N(   Rã   Rê   Ré   Rë   RV   R$   Rj   Rr   Rì   Rï   Rñ   Rü   Rú   Rû   Rõ   Rù   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRq   ˆ   s   								R;   c           B   sw   e  Z i  Z d  Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z d
 d Ñ Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d Ñ  Z e d	 Ñ  É Z RS(   c	   	      C   sq   | |  _  | |  _ | |  _ | |  _ i  |  _ | |  _ | |  _ t | |  j | j | |  j	 É |  _
 |  j É  d  S(   N(   t   _serializert	   _endpointt   _response_parsert   _request_signert   _cacheR   t   _client_configt
   ClientMetat   hostR6   t   metat   _register_handlers(	   R   Re   Rf   Rg   R    Rh   R1   R   R0   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR$   ß  s    								c         C   s√   |  j  j j d |  j  j j |  j j É |  j  j j d  k rG d  } n |  j  j j j
 d É } | d k rÑ |  j  j j d t É n; | d k rø |  j  j j d t É |  j  j j d t É n  d  S(   Ns   request-created.%st   addressing_stylet   paths   before-sign.s3t   virtual(   Rª   t   eventsRQ   R1   RJ   R∂   RT   t   configRU   RV   RM   t
   unregisterR   R   (   R   t   s3_addressing_style(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRº   ∂  s    	c         C   s
   |  j  j S(   N(   Rª   R1   (   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   _service_modelÃ  s    c   
   
   C   s   i  } |  j  j | É } |  j | | d | É} |  j j j d j d |  j  j d | É d | d | d |  j d | É\ } } | d  k	 rô | \ } }	 n |  j
 j | | É \ } }	 |  j j j d j d |  j  j d | É d	 | d
 |	 d | d | É| j d k rt |	 | É Ç n |	 Sd  S(   Nt   contexts.   before-call.{endpoint_prefix}.{operation_name}RJ   R~   t   modelt   paramsRh   s-   after-call.{endpoint_prefix}.{operation_name}t   http_responset   parsedi,  (   Rƒ   RÜ   t   _convert_to_request_dictRª   R¿   t   emit_until_responseR¶   RJ   R∂   RV   R¥   t   make_requestR<   t   status_codeR   (
   R   R~   t
   api_paramst   request_contextRÜ   t   request_dictRT   t   event_responseR¢   t   parsed_response(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRÇ   –  s.    					c         C   sÿ   | j  } |  j j j d j d |  j j d | É d | d | d | É} t | d | É} d } |  j j j | j d |  j j d | É d | d | d | É|  j j	 | | É } t
 | d	 |  j j d
 |  j j É| S(   Ns8   provide-client-params.{endpoint_prefix}.{operation_name}RJ   R~   R«   R∆   R≈   t   defaults9   before-parameter-build.{endpoint_prefix}.{operation_name}R+   R   (   t   nameRª   R¿   R<   R¶   Rƒ   RJ   R   R≥   t   serialize_to_requestR   R¥   R∫   R∏   R   (   R   RŒ   RÜ   R≈   R~   t	   responsest
   event_nameR–   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR      s$    						c         C   s‹   |  j  | É s! t d | É Ç n∑ |  j | } d Ñ  } |  j d | } t d | d |  j j d |  j j d | d t É | _	 t
 d	 t |  j j É | f É } t | t f i | d
 6É } | t |  | É | É } | Sd S(   s  Create a paginator for an operation.

        :type operation_name: string
        :param operation_name: The operation name.  This is the same name
            as the method name on the client.  For example, if the
            method name is ``create_foo``, and you'd normally invoke the
            operation as ``client.create_foo(**kwargs)``, if the
            ``create_foo`` operation can be paginated, you can use the
            call ``client.get_paginator("create_foo")``.

        :raise OperationNotPageableError: Raised if the operation is not
            pageable.  You can use the ``client.can_paginate`` method to
            check if an operation is pageable.

        :rtype: L{botocore.paginate.Paginator}
        :return: A paginator object.

        R~   c         [   s   t  j |  | ç S(   N(   R   t   paginate(   R   RÑ   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRÿ   )  s    t   page_configt   paginator_nameR    R1   t   paginator_configRä   s   %s.Paginator.%sRÿ   N(   t   can_paginateR
   R6   R∑   R   Rª   R¿   R1   Rç   Ré   R>   R   R=   R   t   getattr(   R   R~   t   actual_operation_nameRÿ   R€   t   paginator_class_namet   documented_paginator_clst	   paginator(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   get_paginator  s*    	
	c         C   sä   d |  j  k rl y9 |  j j |  j j d |  j j É d } | |  j  d <Wql t k
 rh i  |  j  d <ql Xn  |  j | } | |  j  d k S(   sM  Check if an operation can be paginated.

        :type operation_name: string
        :param operation_name: The operation name.  This is the same name
            as the method name on the client.  For example, if the
            method name is ``create_foo``, and you'd normally invoke the
            operation as ``client.create_foo(**kwargs)``, if the
            ``create_foo`` operation can be paginated, you can use the
            call ``client.get_paginator("create_foo")``.

        :return: ``True`` if the operation can be paginated,
            ``False`` otherwise.

        RŸ   s   paginators-1t
   pagination(   R∑   R   RC   Rƒ   R(   R/   R	   R6   (   R   R~   RŸ   Rﬁ   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR‹   E  s    		c         C   ss   d |  j  k rh y5 |  j j |  j j d |  j j É } | |  j  d <Wqh t k
 rd i  |  j  d <qh Xn  |  j  d S(   Nt   waiter_configs	   waiters-2(   R∑   R   RC   Rƒ   R(   R/   R	   (   R   R‰   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   _get_waiter_config`  s    		c         C   sî   |  j  É  } | s% t d | É Ç n  t j | É } i  } x! | j D] } | | t | É <qD W| | k r} t d | É Ç n  t j | | | |  É S(   Ns   Waiter does not exist: %s(   RÂ   t
   ValueErrorR    t   WaiterModelt   waiter_namesR   t   create_waiter_with_client(   R   t   waiter_nameR¡   R∆   RÄ   R‘   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt
   get_waiterl  s    c         C   sE   |  j  É  } | s g  St j | É } g  | j D] } t | É ^ q/ S(   s(   Returns a list of all available waiters.(   RÂ   R    RÁ   RË   R   (   R   R¡   R∆   R‘   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRË   z  s
    N(   Rã   Rê   R6   R$   Rº   t   propertyRƒ   RÇ   RV   R    R‚   R‹   RÂ   RÎ   R   RË   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR;   ù  s   			!	7			Rπ   c           B   sb   e  Z d  Z d Ñ  Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z e d Ñ  É Z	 RS(   s~  Holds additional client methods.

    This class holds additional information for clients.  It exists for
    two reasons:

        * To give advanced functionality to clients
        * To namespace additional client attributes from the operation
          names which are mapped to methods at runtime.  This avoids
          ever running into collisions with operation names.

    c         C   s1   | |  _  | |  _ | |  _ | |  _ | |  _ d  S(   N(   R¿   R∏   t   _endpoint_urlRƒ   t   _method_to_api_mapping(   R   R¿   R0   R+   R1   t   method_to_api_mapping(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR$   ì  s
    				c         C   s   |  j  S(   N(   Rƒ   (   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR1   õ  s    c         C   s
   |  j  j S(   N(   R∏   R)   (   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR)   ü  s    c         C   s   |  j  S(   N(   RÌ   (   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR+   £  s    c         C   s   |  j  S(   N(   R∏   (   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyR¡   ß  s    c         C   s   |  j  S(   N(   RÓ   (   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRÔ   ´  s    (
   Rã   Rê   Ré   R$   RÏ   R1   R)   R+   R¡   RÔ   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyRπ   Ü  s   	(,   RW   t   loggingt   botocore.serializeRl   t   botocore.validateR    R   t   botocore.authR   t   botocore.awsrequestR   t   botocore.configR   t   botocore.docs.docstringR   R   t   botocore.endpointR   t   botocore.exceptionsR   R	   R
   R   t   botocore.hooksR   t   botocore.modelR   t   botocore.paginateR   t   botocore.signersR   t   botocore.utilsR   R   R   R   t	   getLoggerRã   RN   t   objectR   Rq   R;   Rπ   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/client.pyt   <module>   s4   ŒßÈ                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/botocore/compat.py                                            0100644 0000000 0000062 00000022044 13077704371 021701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.

import copy
import datetime
import sys
import inspect
import warnings
import hashlib
import logging

from botocore.vendored import six
from botocore.exceptions import MD5UnavailableError
from botocore.vendored.requests.packages.urllib3 import exceptions

logger = logging.getLogger(__name__)


if six.PY3:
    from six.moves import http_client
    class HTTPHeaders(http_client.HTTPMessage):
        pass
    from urllib.parse import quote
    from urllib.parse import urlencode
    from urllib.parse import unquote
    from urllib.parse import unquote_plus
    from urllib.parse import urlparse
    from urllib.parse import urlsplit
    from urllib.parse import urlunsplit
    from urllib.parse import urljoin
    from urllib.parse import parse_qsl
    from urllib.parse import parse_qs
    from http.client import HTTPResponse
    from io import IOBase as _IOBase
    from base64 import encodebytes
    from email.utils import formatdate
    from itertools import zip_longest
    file_type = _IOBase
    zip = zip

    # In python3, unquote takes a str() object, url decodes it,
    # then takes the bytestring and decodes it to utf-8.
    # Python2 we'll have to do this ourself (see below).
    unquote_str = unquote_plus

    def set_socket_timeout(http_response, timeout):
        """Set the timeout of the socket from an HTTPResponse.

        :param http_response: An instance of ``httplib.HTTPResponse``

        """
        http_response._fp.fp.raw._sock.settimeout(timeout)

    def accepts_kwargs(func):
        # In python3.4.1, there's backwards incompatible
        # changes when using getargspec with functools.partials.
        return inspect.getfullargspec(func)[2]

    def ensure_unicode(s, encoding=None, errors=None):
        # NOOP in Python 3, because every string is already unicode
        return s

    def ensure_bytes(s, encoding='utf-8', errors='strict'):
        if isinstance(s, str):
            return s.encode(encoding, errors)
        if isinstance(s, bytes):
            return s
        raise ValueError("Expected str or bytes, received %s." % type(s))

else:
    from urllib import quote
    from urllib import urlencode
    from urllib import unquote
    from urllib import unquote_plus
    from urlparse import urlparse
    from urlparse import urlsplit
    from urlparse import urlunsplit
    from urlparse import urljoin
    from urlparse import parse_qsl
    from urlparse import parse_qs
    from email.message import Message
    from email.Utils import formatdate
    file_type = file
    from itertools import izip as zip
    from itertools import izip_longest as zip_longest
    from httplib import HTTPResponse
    from base64 import encodestring as encodebytes

    class HTTPHeaders(Message):

        # The __iter__ method is not available in python2.x, so we have
        # to port the py3 version.
        def __iter__(self):
            for field, value in self._headers:
                yield field

    def unquote_str(value, encoding='utf-8'):
        # In python2, unquote() gives us a string back that has the urldecoded
        # bits, but not the unicode parts.  We need to decode this manually.
        # unquote has special logic in which if it receives a unicode object it
        # will decode it to latin1.  This is hard coded.  To avoid this, we'll
        # encode the string with the passed in encoding before trying to
        # unquote it.
        byte_string = value.encode(encoding)
        return unquote_plus(byte_string).decode(encoding)

    def set_socket_timeout(http_response, timeout):
        """Set the timeout of the socket from an HTTPResponse.

        :param http_response: An instance of ``httplib.HTTPResponse``

        """
        http_response._fp.fp._sock.settimeout(timeout)

    def accepts_kwargs(func):
        return inspect.getargspec(func)[2]

    def ensure_unicode(s, encoding='utf-8', errors='strict'):
        if isinstance(s, six.text_type):
            return s
        return unicode(s, encoding, errors)

    def ensure_bytes(s, encoding='utf-8', errors='strict'):
        if isinstance(s, unicode):
            return s.encode(encoding, errors)
        if isinstance(s, str):
            return s
        raise ValueError("Expected str or unicode, received %s." % type(s))

try:
    from collections import OrderedDict
except ImportError:
    # Python2.6 we use the 3rd party back port.
    from ordereddict import OrderedDict


if sys.version_info[:2] == (2, 6):
    import simplejson as json
    # In py26, invalid xml parsed by element tree
    # will raise a plain old SyntaxError instead of
    # a real exception, so we need to abstract this change.
    XMLParseError = SyntaxError

    # Handle https://github.com/shazow/urllib3/issues/497 for py2.6.  In
    # python2.6, there is a known issue where sometimes we cannot read the SAN
    # from an SSL cert (http://bugs.python.org/issue13034).  However, newer
    # versions of urllib3 will warn you when there is no SAN.  While we could
    # just turn off this warning in urllib3 altogether, we _do_ want warnings
    # when they're legitimate warnings.  This method tries to scope the warning
    # filter to be as specific as possible.
    def filter_ssl_san_warnings():
        warnings.filterwarnings(
            'ignore',
            message="Certificate has no.*subjectAltName.*",
            category=exceptions.SecurityWarning,
            module=".*urllib3\.connection")
else:
    import xml.etree.cElementTree
    XMLParseError = xml.etree.cElementTree.ParseError
    import json

    def filter_ssl_san_warnings():
        # Noop for non-py26 versions.  We will parse the SAN
        # appropriately.
        pass


def filter_ssl_warnings():
    # Ignore warnings related to SNI as it is not being used in validations.
    warnings.filterwarnings(
        'ignore',
        message="A true SSLContext object is not available.*",
        category=exceptions.InsecurePlatformWarning,
        module=".*urllib3\.util\.ssl_")
    filter_ssl_san_warnings()


@classmethod
def from_dict(cls, d):
    new_instance = cls()
    for key, value in d.items():
        new_instance[key] = value
    return new_instance


@classmethod
def from_pairs(cls, pairs):
    new_instance = cls()
    for key, value in pairs:
        new_instance[key] = value
    return new_instance

HTTPHeaders.from_dict = from_dict
HTTPHeaders.from_pairs = from_pairs


def copy_kwargs(kwargs):
    """
    There is a bug in Python versions < 2.6.5 that prevents you
    from passing unicode keyword args (#4978).  This function
    takes a dictionary of kwargs and returns a copy.  If you are
    using Python < 2.6.5, it also encodes the keys to avoid this bug.
    Oh, and version_info wasn't a namedtuple back then, either!
    """
    vi = sys.version_info
    if vi[0] == 2 and vi[1] <= 6 and vi[3] < 5:
        copy_kwargs = {}
        for key in kwargs:
            copy_kwargs[key.encode('utf-8')] = kwargs[key]
    else:
        copy_kwargs = copy.copy(kwargs)
    return copy_kwargs


def total_seconds(delta):
    """
    Returns the total seconds in a ``datetime.timedelta``.

    Python 2.6 does not have ``timedelta.total_seconds()``, so we have
    to calculate this ourselves. On 2.7 or better, we'll take advantage of the
    built-in method.

    The math was pulled from the ``datetime`` docs
    (http://docs.python.org/2.7/library/datetime.html#datetime.timedelta.total_seconds).

    :param delta: The timedelta object
    :type delta: ``datetime.timedelta``
    """
    if sys.version_info[:2] != (2, 6):
        return delta.total_seconds()

    day_in_seconds = delta.days * 24 * 3600.0
    micro_in_seconds = delta.microseconds / 10.0**6
    return day_in_seconds + delta.seconds + micro_in_seconds


# Checks to see if md5 is available on this system. A given system might not
# have access to it for various reasons, such as FIPS mode being enabled.
try:
    hashlib.md5()
    MD5_AVAILABLE = True
except ValueError:
    MD5_AVAILABLE = False


def get_md5(*args, **kwargs):
    """
    Attempts to get an md5 hashing object.

    :param raise_error_if_unavailable: raise an error if md5 is unavailable on
        this system. If False, None will be returned if it is unavailable.
    :type raise_error_if_unavailable: bool
    :param args: Args to pass to the MD5 constructor
    :param kwargs: Key word arguments to pass to the MD5 constructor
    :return: An MD5 hashing object if available. If it is unavailable, None
        is returned if raise_error_if_unavailable is set to False.
    """
    if MD5_AVAILABLE:
        return hashlib.md5(*args, **kwargs)
    else:
        raise MD5UnavailableError()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/lib/python2.7/dist-packages/botocore/compat.pyc                                           0100644 0000000 0000062 00000021616 13077704401 022042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   sq  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l	 m
 Z
 d  d l m Z e j e É Z e j r˙d  d l m Z d e j f d Ñ  É  YZ d  d l m Z d  d	 l m Z d  d
 l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l  m! Z! d  d l" m# Z$ d  d l% m& Z& d  d l' m( Z( d  d l) m* Z* e$ Z+ e, Z, e Z- d Ñ  Z. d Ñ  Z/ d d d Ñ Z1 d d d Ñ Z2 nXd  d l3 m Z d  d	 l3 m Z d  d
 l3 m Z d  d l3 m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l4 m5 Z5 d  d l6 m( Z( e7 Z+ d  d l) m8 Z, d  d l) m9 Z* d  d l: m! Z! d  d  l% m; Z& d e5 f d! Ñ  É  YZ d d" Ñ Z- d# Ñ  Z. d$ Ñ  Z/ d d d% Ñ Z1 d d d& Ñ Z2 y d  d' l< m= Z= Wn! e> k
 râd  d' l? m= Z= n Xe j@ d(  d2 k rªd  d lA ZB eC ZD d* Ñ  ZE n0 d  d lF ZG eG jH jI jJ ZD d  d lB ZB d+ Ñ  ZE d, Ñ  ZK eL d- Ñ  É ZM eL d. Ñ  É ZN eM e _M eN e _N d/ Ñ  ZO d0 Ñ  ZP y e jQ É  eR ZS Wn eT k
 rceU ZS n Xd1 Ñ  ZV d S(3   iˇˇˇˇN(   t   six(   t   MD5UnavailableError(   t
   exceptions(   t   http_clientt   HTTPHeadersc           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyR      s   (   t   quote(   t	   urlencode(   t   unquote(   t   unquote_plus(   t   urlparse(   t   urlsplit(   t
   urlunsplit(   t   urljoin(   t	   parse_qsl(   t   parse_qs(   t   HTTPResponse(   t   IOBase(   t   encodebytes(   t
   formatdate(   t   zip_longestc         C   s   |  j  j j j j | É d S(   sÑ   Set the timeout of the socket from an HTTPResponse.

        :param http_response: An instance of ``httplib.HTTPResponse``

        N(   t   _fpt   fpt   rawt   _sockt
   settimeout(   t   http_responset   timeout(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   set_socket_timeout8   s    c         C   s   t  j |  É d S(   Ni   (   t   inspectt   getfullargspec(   t   func(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   accepts_kwargs@   s    c         C   s   |  S(   N(    (   t   st   encodingt   errors(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   ensure_unicodeE   s    s   utf-8t   strictc         C   sL   t  |  t É r |  j | | É St  |  t É r2 |  St d t |  É É Ç d  S(   Ns#   Expected str or bytes, received %s.(   t
   isinstancet   strt   encodet   bytest
   ValueErrort   type(   R"   R#   R$   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   ensure_bytesI   s
    (   t   Message(   t   izip(   t   izip_longest(   t   encodestringc           B   s   e  Z d  Ñ  Z RS(   c         c   s#   x |  j  D] \ } } | Vq
 Wd  S(   N(   t   _headers(   t   selft   fieldt   value(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   __iter__g   s    (   R   R   R6   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyR   c   s   c         C   s"   |  j  | É } t | É j | É S(   N(   R)   R
   t   decode(   R5   R#   t   byte_string(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   unquote_strk   s    c         C   s   |  j  j j j | É d S(   sÑ   Set the timeout of the socket from an HTTPResponse.

        :param http_response: An instance of ``httplib.HTTPResponse``

        N(   R   R   R   R   (   R   R   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyR   u   s    c         C   s   t  j |  É d S(   Ni   (   R   t
   getargspec(   R    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyR!   }   s    c         C   s&   t  |  t j É r |  St |  | | É S(   N(   R'   R    t	   text_typet   unicode(   R"   R#   R$   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyR%   Ä   s    c         C   sL   t  |  t É r |  j | | É St  |  t É r2 |  St d t |  É É Ç d  S(   Ns%   Expected str or unicode, received %s.(   R'   R<   R)   R(   R+   R,   (   R"   R#   R$   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyR-   Ö   s
    (   t   OrderedDicti   i   c           C   s&   t  j d d d d t j d d Éd  S(   Nt   ignoret   messages$   Certificate has no.*subjectAltName.*t   categoryt   modules   .*urllib3\.connection(   t   warningst   filterwarningsR   t   SecurityWarning(    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   filter_ssl_san_warnings°   s
    	c           C   s   d  S(   N(    (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyRE   ¨   s    c           C   s-   t  j d d d d t j d d Ét É  d  S(   NR>   R?   s+   A true SSLContext object is not available.*R@   RA   s   .*urllib3\.util\.ssl_(   RB   RC   R   t   InsecurePlatformWarningRE   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   filter_ssl_warnings≤   s    	c         C   s4   |  É  } x$ | j  É  D] \ } } | | | <q W| S(   N(   t   items(   t   clst   dt   new_instancet   keyR5   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt	   from_dictº   s    	c         C   s.   |  É  } x | D] \ } } | | | <q W| S(   N(    (   RI   t   pairsRK   RL   R5   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt
   from_pairsƒ   s    	c         C   s}   t  j } | d d k rj | d d k rj | d d k  rj i  } x7 |  D] } |  | | | j d É <qF Wn t j |  É } | S(   sJ  
    There is a bug in Python versions < 2.6.5 that prevents you
    from passing unicode keyword args (#4978).  This function
    takes a dictionary of kwargs and returns a copy.  If you are
    using Python < 2.6.5, it also encodes the keys to avoid this bug.
    Oh, and version_info wasn't a namedtuple back then, either!
    i    i   i   i   i   i   s   utf-8(   t   syst   version_infoR)   t   copy(   t   kwargst   vit   copy_kwargsRL   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyRU   œ   s    	0c         C   sJ   t  j d  d k r |  j É  S|  j d d } |  j d } | |  j | S(   s…  
    Returns the total seconds in a ``datetime.timedelta``.

    Python 2.6 does not have ``timedelta.total_seconds()``, so we have
    to calculate this ourselves. On 2.7 or better, we'll take advantage of the
    built-in method.

    The math was pulled from the ``datetime`` docs
    (http://docs.python.org/2.7/library/datetime.html#datetime.timedelta.total_seconds).

    :param delta: The timedelta object
    :type delta: ``datetime.timedelta``
    i   i   i   g      ¨@g      $@(   i   i   g    ÄÑ.A(   RP   RQ   t   total_secondst   dayst   microsecondst   seconds(   t   deltat   day_in_secondst   micro_in_seconds(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyRV   ·   s
    
c          O   s#   t  r t j |  | é  St É  Ç d S(   sˇ  
    Attempts to get an md5 hashing object.

    :param raise_error_if_unavailable: raise an error if md5 is unavailable on
        this system. If False, None will be returned if it is unavailable.
    :type raise_error_if_unavailable: bool
    :param args: Args to pass to the MD5 constructor
    :param kwargs: Key word arguments to pass to the MD5 constructor
    :return: An MD5 hashing object if available. If it is unavailable, None
        is returned if raise_error_if_unavailable is set to False.
    N(   t   MD5_AVAILABLEt   hashlibt   md5R   (   t   argsRS   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   get_md5   s    (   i   i   (W   RR   t   datetimeRP   R   RB   R^   t   loggingt   botocore.vendoredR    t   botocore.exceptionsR   t+   botocore.vendored.requests.packages.urllib3R   t	   getLoggerR   t   loggert   PY3t	   six.movesR   t   HTTPMessageR   t   urllib.parseR   R   R	   R
   R   R   R   R   R   R   t   http.clientR   t   ioR   t   _IOBaset   base64R   t   email.utilsR   t	   itertoolsR   t	   file_typet   zipR9   R   R!   t   NoneR%   R-   t   urllibt   email.messageR.   t   email.Utilst   fileR/   R0   t   httplibR1   t   collectionsR=   t   ImportErrort   ordereddictRQ   t
   simplejsont   jsont   SyntaxErrort   XMLParseErrorRE   t   xml.etree.cElementTreet   xmlt   etreet   cElementTreet
   ParseErrorRG   t   classmethodRM   RO   RU   RV   R_   t   TrueR]   R+   t   FalseRa   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/compat.pyt   <module>   s¶   			
					
				


                                                                                                                  usr/local/lib/python2.7/dist-packages/botocore/config.py                                            0100644 0000000 0000062 00000014173 13077704371 021667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import copy
from botocore.compat import OrderedDict

from botocore.endpoint import DEFAULT_TIMEOUT
from botocore.exceptions import InvalidS3AddressingStyleError


class Config(object):
    """Advanced configuration for Botocore clients.

    :type region_name: str
    :param region_name: The region to use in instantiating the client

    :type signature_version: str
    :param signature_version: The signature version when signing requests.

    :type user_agent: str
    :param user_agent: The value to use in the User-Agent header.

    :type user_agent_extra: str
    :param user_agent_extra: The value to append to the current User-Agent
        header value.

    :type connect_timeout: int
    :param connect_timeout: The time in seconds till a timeout exception is
        thrown when attempting to make a connection. The default is 60
        seconds.

    :type read_timeout: int
    :param read_timeout: The time in seconds till a timeout exception is
        thrown when attempting to read from a connection. The default is
        60 seconds.

    :type parameter_validation: bool
    :param parameter_validation: Whether parameter validation should occur
        when serializing requests. The default is True.  You can disable
        parameter validation for performance reasons.  Otherwise, it's
        recommended to leave parameter validation enabled.

    :type s3: dict
    :param s3: A dictionary of s3 specific configurations.
        Valid keys are:

        * 'addressing_style' -- Refers to the style in which to address
          s3 endpoints. Values must be a string that equals:

          * auto -- Addressing style is chosen for user. Depending
            on the configuration of client, the endpoint may be addressed in
            the virtual or the path style. Note that this is the default
            behavior if no style is specified.

          * virtual -- Addressing style is always virtual. The name of the
            bucket must be DNS compatible or an exception will be thrown.
            Endpoints will be addressed as such: mybucket.s3.amazonaws.com

          * path -- Addressing style is always by path. Endpoints will be
            addressed as such: s3.amazonaws.com/mybucket
    """
    OPTION_DEFAULTS = OrderedDict([
        ('region_name', None),
        ('signature_version', None),
        ('user_agent', None),
        ('user_agent_extra', None),
        ('connect_timeout', DEFAULT_TIMEOUT),
        ('read_timeout', DEFAULT_TIMEOUT),
        ('parameter_validation', True),
        ('s3', None)
    ])

    def __init__(self, *args, **kwargs):
        self._user_provided_options = self._record_user_provided_options(
            args, kwargs)

        # Merge the user_provided options onto the default options
        config_vars = copy.copy(self.OPTION_DEFAULTS)
        config_vars.update(self._user_provided_options)

        # Set the attributes based on the config_vars
        for key, value in config_vars.items():
            setattr(self, key, value)

        # Validate the s3 options
        self._validate_s3_configuration(self.s3)

    def _record_user_provided_options(self, args, kwargs):
        option_order = list(self.OPTION_DEFAULTS)
        user_provided_options = {}

        # Iterate through the kwargs passed through to the constructor and
        # map valid keys to the dictionary
        for key, value in kwargs.items():
            if key in self.OPTION_DEFAULTS:
                user_provided_options[key] = value
            # The key must exist in the available options
            else:
                raise TypeError(
                    'Got unexpected keyword argument \'%s\'' % key)

        # The number of args should not be longer than the allowed
        # options
        if len(args) > len(option_order):
            raise TypeError(
                'Takes at most %s arguments (%s given)' % (
                    len(option_order), len(args)))

        # Iterate through the args passed through to the constructor and map
        # them to appropriate keys.
        for i, arg in enumerate(args):
            # If it a kwarg was specified for the arg, then error out
            if option_order[i] in user_provided_options:
                raise TypeError(
                    'Got multiple values for keyword argument \'%s\'' % (
                        option_order[i]))
            user_provided_options[option_order[i]] = arg

        return user_provided_options

    def _validate_s3_configuration(self, s3):
        if s3 is not None:
            addressing_style = s3.get('addressing_style')
            if addressing_style not in ['virtual', 'auto', 'path', None]:
                raise InvalidS3AddressingStyleError(
                    s3_addressing_style=addressing_style)

    def merge(self, other_config):
        """Merges the config object with another config object

        This will merge in all non-default values from the provided config
        and return a new config object

        :type other_config: botocore.config.Config
        :param other config: Another config object to merge with. The values
            in the provided config object will take precedence in the merging

        :returns: A config object built from the merged values of both
            config objects.
        """
        # Make a copy of the current attributes in the config object.
        config_options = copy.copy(self._user_provided_options)

        # Merge in the user provided options from the other config
        config_options.update(other_config._user_provided_options)

        # Return a new config object with the merged properties.
        return Config(**config_options)                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/lib/python2.7/dist-packages/botocore/config.pyc                                           0100644 0000000 0000062 00000012136 13077704401 022021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   sV   d  d l  Z  d  d l m Z d  d l m Z d  d l m Z d e f d Ñ  É  YZ d S(   iˇˇˇˇN(   t   OrderedDict(   t   DEFAULT_TIMEOUT(   t   InvalidS3AddressingStyleErrort   Configc        
   B   sh   e  Z d  Z e d d d d d e f d e f d e f d g É Z d	 Ñ  Z d
 Ñ  Z	 d Ñ  Z
 d Ñ  Z RS(   s˝  Advanced configuration for Botocore clients.

    :type region_name: str
    :param region_name: The region to use in instantiating the client

    :type signature_version: str
    :param signature_version: The signature version when signing requests.

    :type user_agent: str
    :param user_agent: The value to use in the User-Agent header.

    :type user_agent_extra: str
    :param user_agent_extra: The value to append to the current User-Agent
        header value.

    :type connect_timeout: int
    :param connect_timeout: The time in seconds till a timeout exception is
        thrown when attempting to make a connection. The default is 60
        seconds.

    :type read_timeout: int
    :param read_timeout: The time in seconds till a timeout exception is
        thrown when attempting to read from a connection. The default is
        60 seconds.

    :type parameter_validation: bool
    :param parameter_validation: Whether parameter validation should occur
        when serializing requests. The default is True.  You can disable
        parameter validation for performance reasons.  Otherwise, it's
        recommended to leave parameter validation enabled.

    :type s3: dict
    :param s3: A dictionary of s3 specific configurations.
        Valid keys are:

        * 'addressing_style' -- Refers to the style in which to address
          s3 endpoints. Values must be a string that equals:

          * auto -- Addressing style is chosen for user. Depending
            on the configuration of client, the endpoint may be addressed in
            the virtual or the path style. Note that this is the default
            behavior if no style is specified.

          * virtual -- Addressing style is always virtual. The name of the
            bucket must be DNS compatible or an exception will be thrown.
            Endpoints will be addressed as such: mybucket.s3.amazonaws.com

          * path -- Addressing style is always by path. Endpoints will be
            addressed as such: s3.amazonaws.com/mybucket
    t   region_namet   signature_versiont
   user_agentt   user_agent_extrat   connect_timeoutt   read_timeoutt   parameter_validationt   s3c         O   sx   |  j  | | É |  _ t j |  j É } | j |  j É x* | j É  D] \ } } t |  | | É qD W|  j |  j É d  S(   N(	   t   _record_user_provided_optionst   _user_provided_optionst   copyt   OPTION_DEFAULTSt   updatet   itemst   setattrt   _validate_s3_configurationR   (   t   selft   argst   kwargst   config_varst   keyt   value(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/config.pyt   __init__R   s    c   	      C   sÒ   t  |  j É } i  } xF | j É  D]8 \ } } | |  j k rJ | | | <q" t d | É Ç q" Wt | É t | É k rõ t d t | É t | É f É Ç n  xO t | É D]A \ } } | | | k r€ t d | | É Ç n  | | | | <q® W| S(   Ns$   Got unexpected keyword argument '%s's%   Takes at most %s arguments (%s given)s-   Got multiple values for keyword argument '%s'(   t   listR   R   t	   TypeErrort   lent	   enumerate(	   R   R   R   t   option_ordert   user_provided_optionsR   R   t   it   arg(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/config.pyR   a   s$    c         C   s@   | d  k	 r< | j d É } | d k r< t d | É Ç q< n  d  S(   Nt   addressing_stylet   virtualt   autot   patht   s3_addressing_style(   R$   R%   s   pathN(   t   Nonet   getR   (   R   R   R#   (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/config.pyR   Ç   s
    c         C   s,   t  j  |  j É } | j | j É t | ç  S(   s‚  Merges the config object with another config object

        This will merge in all non-default values from the provided config
        and return a new config object

        :type other_config: botocore.config.Config
        :param other config: Another config object to merge with. The values
            in the provided config object will take precedence in the merging

        :returns: A config object built from the merged values of both
            config objects.
        (   R   R   R   R   (   R   t   other_configt   config_options(    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/config.pyt   mergeâ   s    N(   R   N(   R   N(   s
   user_agentN(   R   N(   s   s3N(   t   __name__t
   __module__t   __doc__R    R(   R   t   TrueR   R   R   R   R,   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/config.pyR      s   2					!	(	   R   t   botocore.compatR    t   botocore.endpointR   t   botocore.exceptionsR   t   objectR   (    (    (    s1   /tmp/pip-build-awuatQ/botocore/botocore/config.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/lib/python2.7/dist-packages/botocore/configloader.py                                      0100644 0000000 0000062 00000020203 13077704371 023045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import os
import shlex
import copy

from six.moves import configparser

import botocore.exceptions


def multi_file_load_config(*filenames):
    """Load and combine multiple INI configs with profiles.

    This function will take a list of filesnames and return
    a single dictionary that represents the merging of the loaded
    config files.

    If any of the provided filenames does not exist, then that file
    is ignored.  It is therefore ok to provide a list of filenames,
    some of which may not exist.

    Configuration files are **not** deep merged, only the top level
    keys are merged.  The filenames should be passed in order of
    precedence.  The first config file has precedence over the
    second config file, which has precedence over the third config file,
    etc.  The only exception to this is that the "profiles" key is
    merged to combine profiles from multiple config files into a
    single profiles mapping.  However, if a profile is defined in
    multiple config files, then the config file with the highest
    precedence is used.  Profile values themselves are not merged.
    For example::

        FileA              FileB                FileC
        [foo]             [foo]                 [bar]
        a=1               a=2                   a=3
                          b=2

        [bar]             [baz]                [profile a]
        a=2               a=3                  region=e

        [profile a]       [profile b]          [profile c]
        region=c          region=d             region=f

    The final result of ``multi_file_load_config(FileA, FileB, FileC)``
    would be::

        {"foo": {"a": 1}, "bar": {"a": 2}, "baz": {"a": 3},
        "profiles": {"a": {"region": "c"}}, {"b": {"region": d"}},
                    {"c": {"region": "f"}}}

    Note that the "foo" key comes from A, even though it's defined in both
    FileA and FileB.  Because "foo" was defined in FileA first, then the values
    for "foo" from FileA are used and the values for "foo" from FileB are
    ignored.  Also note where the profiles originate from.  Profile "a"
    comes FileA, profile "b" comes from FileB, and profile "c" comes
    from FileC.

    """
    configs = []
    profiles = []
    for filename in filenames:
        try:
            loaded = load_config(filename)
        except botocore.exceptions.ConfigNotFound:
            continue
        profiles.append(loaded.pop('profiles'))
        configs.append(loaded)
    merged_config = _merge_list_of_dicts(configs)
    merged_profiles = _merge_list_of_dicts(profiles)
    merged_config['profiles'] = merged_profiles
    return merged_config


def _merge_list_of_dicts(list_of_dicts):
    merged_dicts = {}
    for single_dict in list_of_dicts:
        for key, value in single_dict.items():
            if key not in merged_dicts:
                merged_dicts[key] = value
    return merged_dicts


def load_config(config_filename):
    """Parse a INI config with profiles.

    This will parse an INI config file and map top level profiles
    into a top level "profile" key.

    If you want to parse an INI file and map all section names to
    top level keys, use ``raw_config_parse`` instead.

    """
    parsed = raw_config_parse(config_filename)
    return build_profile_map(parsed)


def raw_config_parse(config_filename):
    """Returns the parsed INI config contents.

    Each section name is a top level key.

    :returns: A dict with keys for each profile found in the config
        file and the value of each key being a dict containing name
        value pairs found in that profile.

    :raises: ConfigNotFound, ConfigParseError
    """
    config = {}
    path = config_filename
    if path is not None:
        path = os.path.expandvars(path)
        path = os.path.expanduser(path)
        if not os.path.isfile(path):
            raise botocore.exceptions.ConfigNotFound(path=path)
        cp = configparser.RawConfigParser()
        try:
            cp.read(path)
        except configparser.Error:
            raise botocore.exceptions.ConfigParseError(path=path)
        else:
            for section in cp.sections():
                config[section] = {}
                for option in cp.options(section):
                    config_value = cp.get(section, option)
                    if config_value.startswith('\n'):
                        # Then we need to parse the inner contents as
                        # hierarchical.  We support a single level
                        # of nesting for now.
                        try:
                            config_value = _parse_nested(config_value)
                        except ValueError:
                            raise botocore.exceptions.ConfigParseError(
                                path=path)
                    config[section][option] = config_value
    return config


def _parse_nested(config_value):
    # Given a value like this:
    # \n
    # foo = bar
    # bar = baz
    # We need to parse this into
    # {'foo': 'bar', 'bar': 'baz}
    parsed = {}
    for line in config_value.splitlines():
        line = line.strip()
        if not line:
            continue
        # The caller will catch ValueError
        # and raise an appropriate error
        # if this fails.
        key, value = line.split('=', 1)
        parsed[key.strip()] = value.strip()
    return parsed


def build_profile_map(parsed_ini_config):
    """Convert the parsed INI config into a profile map.

    The config file format requires that every profile except the
    default to be prepended with "profile", e.g.::

        [profile test]
        aws_... = foo
        aws_... = bar

        [profile bar]
        aws_... = foo
        aws_... = bar

        # This is *not* a profile
        [preview]
        otherstuff = 1

        # Neither is this
        [foobar]
        morestuff = 2

    The build_profile_map will take a parsed INI config file where each top
    level key represents a section name, and convert into a format where all
    the profiles are under a single top level "profiles" key, and each key in
    the sub dictionary is a profile name.  For example, the above config file
    would be converted from::

        {"profile test": {"aws_...": "foo", "aws...": "bar"},
         "profile bar": {"aws...": "foo", "aws...": "bar"},
         "preview": {"otherstuff": ...},
         "foobar": {"morestuff": ...},
         }

    into::

        {"profiles": {"test": {"aws_...": "foo", "aws...": "bar"},
                      "bar": {"aws...": "foo", "aws...": "bar"},
         "preview": {"otherstuff": ...},
         "foobar": {"morestuff": ...},
        }

    If there are no profiles in the provided parsed INI contents, then
    an empty dict will be the value associated with the ``profiles`` key.

    .. note::

        This will not mutate the passed in parsed_ini_config.  Instead it will
        make a deepcopy and return that value.

    """
    parsed_config = copy.deepcopy(parsed_ini_config)
    profiles = {}
    final_config = {}
    for key, values in parsed_config.items():
        if key.startswith("profile"):
            try:
                parts = shlex.split(key)
            except ValueError:
                continue
            if len(parts) == 2:
                profiles[parts[1]] = values
        elif key == 'default':
            # default section is special and is considered a profile
            # name but we don't require you use 'profile "default"'
            # as a section.
            profiles[key] = values
        else:
            final_config[key] = values
    final_config['profiles'] = profiles
    return final_config
                                                                                                                                                                                                                                                                                                                                                                                             usr/local/lib/python2.7/dist-packages/botocore/configloader.pyc                                     0100644 0000000 0000062 00000016215 13077704401 023212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   sz   d  d l  Z  d  d l Z d  d l Z d  d l m Z d  d l Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d Ñ  Z d Ñ  Z d S(	   iˇˇˇˇN(   t   configparserc          G   sì   g  } g  } x^ |  D]V } y t  | É } Wn t j j k
 rE q n X| j | j d É É | j | É q Wt | É } t | É } | | d <| S(   s  Load and combine multiple INI configs with profiles.

    This function will take a list of filesnames and return
    a single dictionary that represents the merging of the loaded
    config files.

    If any of the provided filenames does not exist, then that file
    is ignored.  It is therefore ok to provide a list of filenames,
    some of which may not exist.

    Configuration files are **not** deep merged, only the top level
    keys are merged.  The filenames should be passed in order of
    precedence.  The first config file has precedence over the
    second config file, which has precedence over the third config file,
    etc.  The only exception to this is that the "profiles" key is
    merged to combine profiles from multiple config files into a
    single profiles mapping.  However, if a profile is defined in
    multiple config files, then the config file with the highest
    precedence is used.  Profile values themselves are not merged.
    For example::

        FileA              FileB                FileC
        [foo]             [foo]                 [bar]
        a=1               a=2                   a=3
                          b=2

        [bar]             [baz]                [profile a]
        a=2               a=3                  region=e

        [profile a]       [profile b]          [profile c]
        region=c          region=d             region=f

    The final result of ``multi_file_load_config(FileA, FileB, FileC)``
    would be::

        {"foo": {"a": 1}, "bar": {"a": 2}, "baz": {"a": 3},
        "profiles": {"a": {"region": "c"}}, {"b": {"region": d"}},
                    {"c": {"region": "f"}}}

    Note that the "foo" key comes from A, even though it's defined in both
    FileA and FileB.  Because "foo" was defined in FileA first, then the values
    for "foo" from FileA are used and the values for "foo" from FileB are
    ignored.  Also note where the profiles originate from.  Profile "a"
    comes FileA, profile "b" comes from FileB, and profile "c" comes
    from FileC.

    t   profiles(   t   load_configt   botocoret
   exceptionst   ConfigNotFoundt   appendt   popt   _merge_list_of_dicts(   t	   filenamest   configsR   t   filenamet   loadedt   merged_configt   merged_profiles(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyt   multi_file_load_config   s    0
c         C   sQ   i  } xD |  D]< } x3 | j  É  D]% \ } } | | k r  | | | <q  q  Wq W| S(   N(   t   items(   t   list_of_dictst   merged_dictst   single_dictt   keyt   value(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyR   V   s    c         C   s   t  |  É } t | É S(   s  Parse a INI config with profiles.

    This will parse an INI config file and map top level profiles
    into a top level "profile" key.

    If you want to parse an INI file and map all section names to
    top level keys, use ``raw_config_parse`` instead.

    (   t   raw_config_parset   build_profile_map(   t   config_filenamet   parsed(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyR   _   s    
c         C   s\  i  } |  } | d k	 rXt j j | É } t j j | É } t j j | É sf t j j d | É Ç n  t	 j
 É  } y | j | É Wn) t	 j k
 rÆ t j j d | É Ç qXXx¶ | j É  D]ï } i  | | <xÇ | j | É D]q } | j | | É } | j d É r?y t | É } Wq?t k
 r;t j j d | É Ç q?Xn  | | | | <q‹ Wqº Wn  | S(   s:  Returns the parsed INI config contents.

    Each section name is a top level key.

    :returns: A dict with keys for each profile found in the config
        file and the value of each key being a dict containing name
        value pairs found in that profile.

    :raises: ConfigNotFound, ConfigParseError
    t   paths   
N(   t   Nonet   osR   t
   expandvarst
   expandusert   isfileR   R   R   R    t   RawConfigParsert   readt   Errort   ConfigParseErrort   sectionst   optionst   gett
   startswitht   _parse_nestedt
   ValueError(   R   t   configR   t   cpt   sectiont   optiont   config_value(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyR   m   s0    
c         C   sg   i  } xZ |  j  É  D]L } | j É  } | s1 q n  | j d d É \ } } | j É  | | j É  <q W| S(   Nt   =i   (   t
   splitlinest   stript   split(   R.   R   t   lineR   R   (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyR(   ñ   s    c         C   s»   t  j |  É } i  } i  } xú | j É  D]é \ } } | j d É rì y t j | É } Wn t k
 rl q( n Xt | É d k r∂ | | | d <q∂ q( | d k r¨ | | | <q( | | | <q( W| | d <| S(   s˜  Convert the parsed INI config into a profile map.

    The config file format requires that every profile except the
    default to be prepended with "profile", e.g.::

        [profile test]
        aws_... = foo
        aws_... = bar

        [profile bar]
        aws_... = foo
        aws_... = bar

        # This is *not* a profile
        [preview]
        otherstuff = 1

        # Neither is this
        [foobar]
        morestuff = 2

    The build_profile_map will take a parsed INI config file where each top
    level key represents a section name, and convert into a format where all
    the profiles are under a single top level "profiles" key, and each key in
    the sub dictionary is a profile name.  For example, the above config file
    would be converted from::

        {"profile test": {"aws_...": "foo", "aws...": "bar"},
         "profile bar": {"aws...": "foo", "aws...": "bar"},
         "preview": {"otherstuff": ...},
         "foobar": {"morestuff": ...},
         }

    into::

        {"profiles": {"test": {"aws_...": "foo", "aws...": "bar"},
                      "bar": {"aws...": "foo", "aws...": "bar"},
         "preview": {"otherstuff": ...},
         "foobar": {"morestuff": ...},
        }

    If there are no profiles in the provided parsed INI contents, then
    an empty dict will be the value associated with the ``profiles`` key.

    .. note::

        This will not mutate the passed in parsed_ini_config.  Instead it will
        make a deepcopy and return that value.

    t   profilei   i   t   defaultR   (   t   copyt   deepcopyR   R'   t   shlexR2   R)   t   len(   t   parsed_ini_configt   parsed_configR   t   final_configR   t   valuest   parts(    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyR   ™   s     3
(   R   R8   R6   t	   six.movesR    t   botocore.exceptionsR   R   R   R   R   R(   R   (    (    (    s7   /tmp/pip-build-awuatQ/botocore/botocore/configloader.pyt   <module>   s   	?				)	                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/python2.7/dist-packages/botocore/credentials.py                                       0100644 0000000 0000062 00000115252 13077704371 022717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/
# Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"). You
# may not use this file except in compliance with the License. A copy of
# the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific
# language governing permissions and limitations under the License.
import time
import datetime
import logging
import os
import getpass
import threading
from collections import namedtuple

from dateutil.parser import parse
from dateutil.tz import tzlocal

import botocore.configloader
import botocore.compat
from botocore.compat import total_seconds
from botocore.exceptions import UnknownCredentialError
from botocore.exceptions import PartialCredentialsError
from botocore.exceptions import ConfigNotFound
from botocore.exceptions import InvalidConfigError
from botocore.exceptions import RefreshWithMFAUnsupportedError
from botocore.utils import InstanceMetadataFetcher, parse_key_val_file


logger = logging.getLogger(__name__)
ReadOnlyCredentials = namedtuple('ReadOnlyCredentials',
                                 ['access_key', 'secret_key', 'token'])


def create_credential_resolver(session):
    """Create a default credential resolver.

    This creates a pre-configured credential resolver
    that includes the default lookup chain for
    credentials.

    """
    profile_name = session.get_config_variable('profile') or 'default'
    credential_file = session.get_config_variable('credentials_file')
    config_file = session.get_config_variable('config_file')
    metadata_timeout = session.get_config_variable('metadata_service_timeout')
    num_attempts = session.get_config_variable('metadata_service_num_attempts')

    env_provider = EnvProvider()
    providers = [
        env_provider,
        AssumeRoleProvider(
            load_config=lambda: session.full_config,
            client_creator=session.create_client,
            cache={},
            profile_name=profile_name,
        ),
        SharedCredentialProvider(
            creds_filename=credential_file,
            profile_name=profile_name
        ),
        # The new config file has precedence over the legacy
        # config file.
        ConfigProvider(config_filename=config_file, profile_name=profile_name),
        OriginalEC2Provider(),
        BotoProvider(),
        InstanceMetadataProvider(
            iam_role_fetcher=InstanceMetadataFetcher(
                timeout=metadata_timeout,
                num_attempts=num_attempts)
        )
    ]

    explicit_profile = session.get_config_variable('profile',
                                                   methods=('instance',))
    if explicit_profile is not None:
        # An explicitly provided profile will negate an EnvProvider.
        # We will defer to providers that understand the "profile"
        # concept to retrieve credentials.
        # The one edge case if is all three values are provided via
        # env vars:
        # export AWS_ACCESS_KEY_ID=foo
        # export AWS_SECRET_ACCESS_KEY=bar
        # export AWS_PROFILE=baz
        # Then, just like our client() calls, the explicit credentials
        # will take precedence.
        #
        # This precedence is enforced by leaving the EnvProvider in the chain.
        # This means that the only way a "profile" would win is if the
        # EnvProvider does not return credentials, which is what we want
        # in this scenario.
        providers.remove(env_provider)
    else:
        logger.debug('Skipping environment variable credential check'
                     ' because profile name was explicitly set.')

    resolver = CredentialResolver(providers=providers)
    return resolver


def get_credentials(session):
    resolver = create_credential_resolver(session)
    return resolver.load_credentials()


def _local_now():
    return datetime.datetime.now(tzlocal())


def _parse_if_needed(value):
    if isinstance(value, datetime.datetime):
        return value
    return parse(value)


def _serialize_if_needed(value):
    if isinstance(value, datetime.datetime):
        return value.strftime('%Y-%m-%dT%H:%M:%SZ')
    return value


def create_assume_role_refresher(client, params):
    def refresh():
        response = client.assume_role(**params)
        credentials = response['Credentials']
        # We need to normalize the credential names to
        # the values expected by the refresh creds.
        return {
            'access_key': credentials['AccessKeyId'],
            'secret_key': credentials['SecretAccessKey'],
            'token': credentials['SessionToken'],
            'expiry_time': _serialize_if_needed(credentials['Expiration']),
        }
    return refresh


def create_mfa_serial_refresher():
    def _refresher():
        # We can explore an option in the future to support
        # reprompting for MFA, but for now we just error out
        # when the temp creds expire.
        raise RefreshWithMFAUnsupportedError()
    return _refresher


class Credentials(object):
    """
    Holds the credentials needed to authenticate requests.

    :ivar access_key: The access key part of the credentials.
    :ivar secret_key: The secret key part of the credentials.
    :ivar token: The security token, valid only for session credentials.
    :ivar method: A string which identifies where the credentials
        were found.
    """

    def __init__(self, access_key, secret_key, token=None,
                 method=None):
        self.access_key = access_key
        self.secret_key = secret_key
        self.token = token

        if method is None:
            method = 'explicit'
        self.method = method

        self._normalize()

    def _normalize(self):
        # Keys would sometimes (accidentally) contain non-ascii characters.
        # It would cause a confusing UnicodeDecodeError in Python 2.
        # We explicitly convert them into unicode to avoid such error.
        #
        # Eventually the service will decide whether to accept the credential.
        # This also complies with the behavior in Python 3.
        self.access_key = botocore.compat.ensure_unicode(self.access_key)
        self.secret_key = botocore.compat.ensure_unicode(self.secret_key)

    def get_frozen_credentials(self):
        return ReadOnlyCredentials(self.access_key,
                                   self.secret_key,
                                   self.token)


class RefreshableCredentials(Credentials):
    """
    Holds the credentials needed to authenticate requests. In addition, it
    knows how to refresh itself.

    :ivar refresh_timeout: How long a given set of credentials are valid for.
        Useful for credentials fetched over the network.
    :ivar access_key: The access key part of the credentials.
    :ivar secret_key: The secret key part of the credentials.
    :ivar token: The security token, valid only for session credentials.
    :ivar method: A string which identifies where the credentials
        were found.
    """
    # The time at which we'll attempt to refresh, but not
    # block if someone else is refreshing.
    _advisory_refresh_timeout = 15 * 60
    # The time at which all threads will block waiting for
    # refreshed credentials.
    _mandatory_refresh_timeout = 10 * 60

    def __init__(self, access_key, secret_key, token,
                 expiry_time, refresh_using, method,
                 time_fetcher=_local_now):
        self._refresh_using = refresh_using
        self._access_key = access_key
        self._secret_key = secret_key
        self._token = token
        self._expiry_time = expiry_time
        self._time_fetcher = time_fetcher
        self._refresh_lock = threading.Lock()
        self.method = method
        self._frozen_credentials = ReadOnlyCredentials(
            access_key, secret_key, token)
        self._normalize()

    def _normalize(self):
        self._access_key = botocore.compat.ensure_unicode(self._access_key)
        self._secret_key = botocore.compat.ensure_unicode(self._secret_key)

    @classmethod
    def create_from_metadata(cls, metadata, refresh_using, method):
        instance = cls(
            access_key=metadata['access_key'],
            secret_key=metadata['secret_key'],
            token=metadata['token'],
            expiry_time=cls._expiry_datetime(metadata['expiry_time']),
            method=method,
            refresh_using=refresh_using
        )
        return instance

    @property
    def access_key(self):
        self._refresh()
        return self._access_key

    @access_key.setter
    def access_key(self, value):
        self._access_key = value

    @property
    def secret_key(self):
        self._refresh()
        return self._secret_key

    @secret_key.setter
    def secret_key(self, value):
        self._secret_key = value

    @property
    def token(self):
        self._refresh()
        return self._token

    @token.setter
    def token(self, value):
        self._token = value

    def _seconds_remaining(self):
        delta = self._expiry_time - self._time_fetcher()
        return total_seconds(delta)

    def refresh_needed(self, refresh_in=None):
        """Check if a refresh is needed.

        A refresh is needed if the expiry time associated
        with the temporary credentials is less than the
        provided ``refresh_in``.  If ``time_delta`` is not
        provided, ``self.advisory_refresh_needed`` will be used.

        For example, if your temporary credentials expire
        in 10 minutes and the provided ``refresh_in`` is
        ``15 * 60``, then this function will return ``True``.

        :type refresh_in: int
        :param refresh_in: The number of seconds before the
            credentials expire in which refresh attempts should
            be made.

        :return: True if refresh neeeded, False otherwise.

        """
        if self._expiry_time is None:
            # No expiration, so assume we don't need to refresh.
            return False

        if refresh_in is None:
            refresh_in = self._advisory_refresh_timeout
        # The credentials should be refreshed if they're going to expire
        # in less than 5 minutes.
        if self._seconds_remaining() >= refresh_in:
            # There's enough time left. Don't refresh.
            return False
        logger.debug("Credentials need to be refreshed.")
        return True

    def _is_expired(self):
        # Checks if the current credentials are expired.
        return self.refresh_needed(refresh_in=0)

    def _refresh(self):
        # In the common case where we don't need a refresh, we
        # can immediately exit and not require acquiring the
        # refresh lock.
        if not self.refresh_needed(self._advisory_refresh_timeout):
            return

        # acquire() doesn't accept kwargs, but False is indicating
        # that we should not block if we can't acquire the lock.
        # If we aren't able to acquire the lock, we'll trigger
        # the else clause.
        if self._refresh_lock.acquire(False):
            try:
                if not self.refresh_needed(self._advisory_refresh_timeout):
                    return
                is_mandatory_refresh = self.refresh_needed(
                    self._mandatory_refresh_timeout)
                self._protected_refresh(is_mandatory=is_mandatory_refresh)
                return
            finally:
                self._refresh_lock.release()
        elif self.refresh_needed(self._mandatory_refresh_timeout):
            # If we're within the mandatory refresh window,
            # we must block until we get refreshed credentials.
            with self._refresh_lock:
                if not self.refresh_needed(self._mandatory_refresh_timeout):
                    return
                self._protected_refresh(is_mandatory=True)

    def _protected_refresh(self, is_mandatory):
        # precondition: this method should only be called if you've acquired
        # the self._refresh_lock.
        try:
            metadata = self._refresh_using()
        except Exception as e:
            period_name = 'mandatory' if is_mandatory else 'advisory'
            logger.warning("Refreshing temporary credentials failed "
                           "during %s refresh period.",
                           period_name, exc_info=True)
            if is_mandatory:
                # If this is a mandatory refresh, then
                # all errors that occur when we attempt to refresh
                # credentials are propagated back to the user.
                raise
            # Otherwise we'll just return.
            # The end result will be that we'll use the current
            # set of temporary credentials we have.
            return
        self._set_from_data(metadata)
        if self._is_expired():
            # We successfully refreshed credentials but for whatever
            # reason, our refreshing function returned credentials
            # that are still expired.  In this scenario, the only
            # thing we can do is let the user know and raise
            # an exception.
            msg = ("Credentials were refreshed, but the "
                   "refreshed credentials are still expired.")
            logger.warning(msg)
            raise RuntimeError(msg)
        self._frozen_credentials = ReadOnlyCredentials(
            self._access_key, self._secret_key, self._token)

    @staticmethod
    def _expiry_datetime(time_str):
        return parse(time_str)

    def _set_from_data(self, data):
        self.access_key = data['access_key']
        self.secret_key = data['secret_key']
        self.token = data['token']
        self._expiry_time = parse(data['expiry_time'])
        logger.debug("Retrieved credentials will expire at: %s", self._expiry_time)
        self._normalize()

    def get_frozen_credentials(self):
        """Return immutable credentials.

        The ``access_key``, ``secret_key``, and ``token`` properties
        on this class will always check and refresh credentials if
        needed before returning the particular credentials.

        This has an edge case where you can get inconsistent
        credentials.  Imagine this:

            # Current creds are "t1"
            tmp.access_key  ---> expired? no, so return t1.access_key
            # ---- time is now expired, creds need refreshing to "t2" ----
            tmp.secret_key  ---> expired? yes, refresh and return t2.secret_key

        This means we're using the access key from t1 with the secret key
        from t2.  To fix this issue, you can request a frozen credential object
        which is guaranteed not to change.

        The frozen credentials returned from this method should be used
        immediately and then discarded.  The typical usage pattern would
        be::

            creds = RefreshableCredentials(...)
            some_code = SomeSignerObject()
            # I'm about to sign the request.
            # The frozen credentials are only used for the
            # duration of generate_presigned_url and will be
            # immediately thrown away.
            request = some_code.sign_some_request(
                with_credentials=creds.get_frozen_credentials())
            print("Signed request:", request)

        """
        self._refresh()
        return self._frozen_credentials


class CredentialProvider(object):

    # Implementations must provide a method.
    METHOD = None

    def __init__(self, session=None):
        self.session = session

    def load(self):
        """
        Loads the credentials from their source & sets them on the object.

        Subclasses should implement this method (by reading from disk, the
        environment, the network or wherever), returning ``True`` if they were
        found & loaded.

        If not found, this method should return ``False``, indictating that the
        ``CredentialResolver`` should fall back to the next available method.

        The default implementation does nothing, assuming the user has set the
        ``access_key/secret_key/token`` themselves.

        :returns: Whether credentials were found & set
        :rtype: boolean
        """
        return True

    def _extract_creds_from_mapping(self, mapping, *key_names):
        found = []
        for key_name in key_names:
            try:
                found.append(mapping[key_name])
            except KeyError:
                raise PartialCredentialsError(provider=self.METHOD,
                                              cred_var=key_name)
        return found


class InstanceMetadataProvider(CredentialProvider):
    METHOD = 'iam-role'

    def __init__(self, iam_role_fetcher):
        self._role_fetcher = iam_role_fetcher

    def load(self):
        fetcher = self._role_fetcher
        # We do the first request, to see if we get useful data back.
        # If not, we'll pass & move on to whatever's next in the credential
        # chain.
        metadata = fetcher.retrieve_iam_role_credentials()
        if not metadata:
            return None
        logger.info('Found credentials from IAM Role: %s', metadata['role_name'])
        # We manually set the data here, since we already made the request &
        # have it. When the expiry is hit, the credentials will auto-refresh
        # themselves.
        creds = RefreshableCredentials.create_from_metadata(
            metadata,
            method=self.METHOD,
            refresh_using=fetcher.retrieve_iam_role_credentials,
        )
        return creds


class EnvProvider(CredentialProvider):
    METHOD = 'env'
    ACCESS_KEY = 'AWS_ACCESS_KEY_ID'
    SECRET_KEY = 'AWS_SECRET_ACCESS_KEY'
    # The token can come from either of these env var.
    # AWS_SESSION_TOKEN is what other AWS SDKs have standardized on.
    TOKENS = ['AWS_SECURITY_TOKEN', 'AWS_SESSION_TOKEN']

    def __init__(self, environ=None, mapping=None):
        """

        :param environ: The environment variables (defaults to
            ``os.environ`` if no value is provided).
        :param mapping: An optional mapping of variable names to
            environment variable names.  Use this if you want to
            change the mapping of access_key->AWS_ACCESS_KEY_ID, etc.
            The dict can have up to 3 keys: ``access_key``, ``secret_key``,
            ``session_token``.
        """
        if environ is None:
            environ = os.environ
        self.environ = environ
        self._mapping = self._build_mapping(mapping)

    def _build_mapping(self, mapping):
        # Mapping of variable name to env var name.
        var_mapping = {}
        if mapping is None:
            # Use the class var default.
            var_mapping['access_key'] = self.ACCESS_KEY
            var_mapping['secret_key'] = self.SECRET_KEY
            var_mapping['token'] = self.TOKENS
        else:
            var_mapping['access_key'] = mapping.get(
                'access_key', self.ACCESS_KEY)
            var_mapping['secret_key'] = mapping.get(
                'secret_key', self.SECRET_KEY)
            var_mapping['token'] = mapping.get(
                'token', self.TOKENS)
            if not isinstance(var_mapping['token'], list):
                var_mapping['token'] = [var_mapping['token']]
        return var_mapping

    def load(self):
        """
        Search for credentials in explicit environment variables.
        """
        if self._mapping['access_key'] in self.environ:
            logger.info('Found credentials in environment variables.')
            access_key, secret_key = self._extract_creds_from_mapping(
                self.environ, self._mapping['access_key'],
                self._mapping['secret_key'])
            token = self._get_session_token()
            return Credentials(access_key, secret_key, token,
                               method=self.METHOD)
        else:
            return None

    def _get_session_token(self):
        for token_envvar in self._mapping['token']:
            if token_envvar in self.environ:
                return self.environ[token_envvar]


class OriginalEC2Provider(CredentialProvider):
    METHOD = 'ec2-credentials-file'

    CRED_FILE_ENV = 'AWS_CREDENTIAL_FILE'
    ACCESS_KEY = 'AWSAccessKeyId'
    SECRET_KEY = 'AWSSecretKey'

    def __init__(self, environ=None, parser=None):
        if environ is None:
            environ = os.environ
        if parser is None:
            parser = parse_key_val_file
        self._environ = environ
        self._parser = parser

    def load(self):
        """
        Search for a credential file used by original EC2 CLI tools.
        """
        if 'AWS_CREDENTIAL_FILE' in self._environ:
            full_path = os.path.expanduser(self._environ['AWS_CREDENTIAL_FILE'])
            creds = self._parser(full_path)
            if self.ACCESS_KEY in creds:
                logger.info('Found credentials in AWS_CREDENTIAL_FILE.')
                access_key = creds[self.ACCESS_KEY]
                secret_key = creds[self.SECRET_KEY]
                # EC2 creds file doesn't support session tokens.
                return Credentials(access_key, secret_key, method=self.METHOD)
        else:
            return None


class SharedCredentialProvider(CredentialProvider):
    METHOD = 'shared-credentials-file'

    ACCESS_KEY = 'aws_access_key_id'
    SECRET_KEY = 'aws_secret_access_key'
    # Same deal as the EnvProvider above.  Botocore originally supported
    # aws_security_token, but the SDKs are standardizing on aws_session_token
    # so we support both.
    TOKENS = ['aws_security_token', 'aws_session_token']

    def __init__(self, creds_filename, profile_name=None, ini_parser=None):
        self._creds_filename = creds_filename
        if profile_name is None:
            profile_name = 'default'
        self._profile_name = profile_name
        if ini_parser is None:
            ini_parser = botocore.configloader.raw_config_parse
        self._ini_parser = ini_parser

    def load(self):
        try:
            available_creds = self._ini_parser(self._creds_filename)
        except ConfigNotFound:
            return None
        if self._profile_name in available_creds:
            config = available_creds[self._profile_name]
            if self.ACCESS_KEY in config:
                logger.info("Found credentials in shared credentials file: %s",
                            self._creds_filename)
                access_key, secret_key = self._extract_creds_from_mapping(
                    config, self.ACCESS_KEY, self.SECRET_KEY)
                token =  self._get_session_token(config)
                return Credentials(access_key, secret_key, token,
                                   method=self.METHOD)

    def _get_session_token(self, config):
        for token_envvar in self.TOKENS:
            if token_envvar in config:
                return config[token_envvar]


class ConfigProvider(CredentialProvider):
    """INI based config provider with profile sections."""
    METHOD = 'config-file'

    ACCESS_KEY = 'aws_access_key_id'
    SECRET_KEY = 'aws_secret_access_key'
    # Same deal as the EnvProvider above.  Botocore originally supported
    # aws_security_token, but the SDKs are standardizing on aws_session_token
    # so we support both.
    TOKENS = ['aws_security_token', 'aws_session_token']

    def __init__(self, config_filename, profile_name, config_parser=None):
        """

        :param config_filename: The session configuration scoped to the current
            profile.  This is available via ``session.config``.
        :param profile_name: The name of the current profile.
        :param config_parser: A config parser callable.

        """
        self._config_filename = config_filename
        self._profile_name = profile_name
        if config_parser is None:
            config_parser = botocore.configloader.load_config
        self._config_parser = config_parser

    def load(self):
        """
        If there is are credentials in the configuration associated with
        the session, use those.
        """
        try:
            full_config = self._config_parser(self._config_filename)
        except ConfigNotFound:
            return None
        if self._profile_name in full_config['profiles']:
            profile_config = full_config['profiles'][self._profile_name]
            if self.ACCESS_KEY in profile_config:
                logger.info("Credentials found in config file: %s",
                            self._config_filename)
                access_key, secret_key = self._extract_creds_from_mapping(
                    profile_config, self.ACCESS_KEY, self.SECRET_KEY)
                token = self._get_session_token(profile_config)
                return Credentials(access_key, secret_key, token,
                                method=self.METHOD)
        else:
            return None

    def _get_session_token(self, profile_config):
        for token_name in self.TOKENS:
            if token_name in profile_config:
                return profile_config[token_name]


class BotoProvider(CredentialProvider):
    METHOD = 'boto-config'

    BOTO_CONFIG_ENV = 'BOTO_CONFIG'
    DEFAULT_CONFIG_FILENAMES = ['/etc/boto.cfg', '~/.boto']
    ACCESS_KEY = 'aws_access_key_id'
    SECRET_KEY = 'aws_secret_access_key'

    def __init__(self, environ=None, ini_parser=None):
        if environ is None:
            environ = os.environ
        if ini_parser is None:
            ini_parser = botocore.configloader.raw_config_parse
        self._environ = environ
        self._ini_parser = ini_parser

    def load(self):
        """
        Look for credentials in boto config file.
        """
        if self.BOTO_CONFIG_ENV in self._environ:
            potential_locations = [self._environ[self.BOTO_CONFIG_ENV]]
        else:
            potential_locations = self.DEFAULT_CONFIG_FILENAMES
        for filename in potential_locations:
            try:
                config = self._ini_parser(filename)
            except ConfigNotFound:
                # Move on to the next potential config file name.
                continue
            if 'Credentials' in config:
                credentials = config['Credentials']
                if self.ACCESS_KEY in credentials:
                    logger.info("Found credentials in boto config file: %s",
                                filename)
                    access_key, secret_key = self._extract_creds_from_mapping(
                        credentials, self.ACCESS_KEY, self.SECRET_KEY)
                    return Credentials(access_key, secret_key,
                                       method=self.METHOD)


class AssumeRoleProvider(CredentialProvider):

    METHOD = 'assume-role'
    ROLE_CONFIG_VAR = 'role_arn'
    # Credentials are considered expired (and will be refreshed) once the total
    # remaining time left until the credentials expires is less than the
    # EXPIRY_WINDOW.
    EXPIRY_WINDOW_SECONDS = 60 * 15

    def __init__(self, load_config, client_creator, cache, profile_name,
                 prompter=getpass.getpass):
        """

        :type load_config: callable
        :param load_config: A function that accepts no arguments, and
            when called, will return the full configuration dictionary
            for the session (``session.full_config``).

        :type client_creator: callable
        :param client_creator: A factory function that will create
            a client when called.  Has the same interface as
            ``botocore.session.Session.create_client``.

        :type cache: JSONFileCache
        :param cache: An object that supports ``__getitem__``,
            ``__setitem__``, and ``__contains__``.  An example
            of this is the ``JSONFileCache`` class.

        :type profile_name: str
        :param profile_name: The name of the profile.

        :type prompter: callable
        :param prompter: A callable that returns input provided
            by the user (i.e raw_input, getpass.getpass, etc.).

        """
        #: The cache used to first check for assumed credentials.
        #: This is checked before making the AssumeRole API
        #: calls and can be useful if you have short lived
        #: scripts and you'd like to avoid calling AssumeRole
        #: until the credentials are expired.
        self.cache = cache
        self._load_config = load_config
        # client_creator is a callable that creates function.
        # It's basically session.create_client
        self._client_creator = client_creator
        self._profile_name = profile_name
        self._prompter = prompter
        # The _loaded_config attribute will be populated from the
        # load_config() function once the configuration is actually
        # loaded.  The reason we go through all this instead of just
        # requiring that the loaded_config be passed to us is to that
        # we can defer configuration loaded until we actually try
        # to load credentials (as opposed to when the object is
        # instantiated).
        self._loaded_config = {}

    def load(self):
        self._loaded_config = self._load_config()
        if self._has_assume_role_config_vars():
            return self._load_creds_via_assume_role()

    def _has_assume_role_config_vars(self):
        profiles = self._loaded_config.get('profiles', {})
        return self.ROLE_CONFIG_VAR in profiles.get(self._profile_name, {})

    def _load_creds_via_assume_role(self):
        # We can get creds in one of two ways:
        # * It can either be cached on disk from an pre-existing session
        # * Cache doesn't have the creds (or is expired) so we need to make
        #   an assume role call to get temporary creds, which we then cache
        #   for subsequent requests.
        creds = self._load_creds_from_cache()
        if creds is not None:
            logger.debug("Credentials for role retrieved from cache.")
            return creds
        else:
            # We get the Credential used by botocore as well
            # as the original parsed response from the server.
            creds, response = self._retrieve_temp_credentials()
            cache_key = self._create_cache_key()
            self._write_cached_credentials(response, cache_key)
            return creds

    def _load_creds_from_cache(self):
        cache_key = self._create_cache_key()
        try:
            from_cache = self.cache[cache_key]
            if self._is_expired(from_cache):
                # Don't need to delete the cache entry,
                # when we refresh via AssumeRole, we'll
                # update the cache with the new entry.
                logger.debug("Credentials were found in cache, but they are expired.")
                return None
            else:
                return self._create_creds_from_response(from_cache)
        except KeyError:
            return None

    def _is_expired(self, credentials):
        end_time = parse(credentials['Credentials']['Expiration'])
        now = datetime.datetime.now(tzlocal())
        seconds = total_seconds(end_time - now)
        return seconds < self.EXPIRY_WINDOW_SECONDS

    def _create_cache_key(self):
        role_config = self._get_role_config_values()
        # On windows, ':' is not allowed in filenames, so we'll
        # replace them with '_' instead.
        role_arn = role_config['role_arn'].replace(':', '_')
        role_session_name=role_config.get('role_session_name')
        if role_session_name:
            cache_key = '%s--%s--%s' % (self._profile_name, role_arn, role_session_name)
        else:
            cache_key = '%s--%s' % (self._profile_name, role_arn)

        return cache_key.replace('/', '-')

    def _write_cached_credentials(self, creds, cache_key):
        self.cache[cache_key] = creds

    def _get_role_config_values(self):
        # This returns the role related configuration.
        profiles = self._loaded_config.get('profiles', {})
        try:
            source_profile = profiles[self._profile_name]['source_profile']
            role_arn = profiles[self._profile_name]['role_arn']
            mfa_serial = profiles[self._profile_name].get('mfa_serial')
        except KeyError as e:
            raise PartialCredentialsError(provider=self.METHOD,
                                          cred_var=str(e))
        external_id = profiles[self._profile_name].get('external_id')
        role_session_name = profiles[self._profile_name].get('role_session_name')
        if source_profile not in profiles:
            raise InvalidConfigError(
                error_msg=(
                    'The source_profile "%s" referenced in '
                    'the profile "%s" does not exist.' % (
                        source_profile, self._profile_name)))
        source_cred_values = profiles[source_profile]
        return {
            'role_arn': role_arn,
            'external_id': external_id,
            'source_profile': source_profile,
            'mfa_serial': mfa_serial,
            'source_cred_values': source_cred_values,
            'role_session_name': role_session_name
        }

    def _create_creds_from_response(self, response):
        config = self._get_role_config_values()
        if config.get('mfa_serial') is not None:
            # MFA would require getting a new TokenCode which would require
            # prompting the user for a new token, so we use a different
            # refresh_func.
            refresh_func = create_mfa_serial_refresher()
        else:
            refresh_func = create_assume_role_refresher(
                self._create_client_from_config(config),
                self._assume_role_base_kwargs(config))
        return RefreshableCredentials(
            access_key=response['Credentials']['AccessKeyId'],
            secret_key=response['Credentials']['SecretAccessKey'],
            token=response['Credentials']['SessionToken'],
            method=self.METHOD,
            expiry_time=_parse_if_needed(
                response['Credentials']['Expiration']),
            refresh_using=refresh_func)

    def _create_client_from_config(self, config):
        source_cred_values = config['source_cred_values']
        client = self._client_creator(
            'sts', aws_access_key_id=source_cred_values['aws_access_key_id'],
            aws_secret_access_key=source_cred_values['aws_secret_access_key'],
            aws_session_token=source_cred_values.get('aws_session_token'),
        )
        return client

    def _retrieve_temp_credentials(self):
        logger.debug("Retrieving credentials via AssumeRole.")
        config = self._get_role_config_values()
        client = self._create_client_from_config(config)

        assume_role_kwargs = self._assume_role_base_kwargs(config)

        response = client.assume_role(**assume_role_kwargs)
        creds = self._create_creds_from_response(response)
        return creds, response

    def _assume_role_base_kwargs(self, config):
        assume_role_kwargs = {'RoleArn': config['role_arn']}
        if config['external_id'] is not None:
            assume_role_kwargs['ExternalId'] = config['external_id']
        if config['mfa_serial'] is not None:
            token_code = self._prompter("Enter MFA code: ")
            assume_role_kwargs['SerialNumber'] = config['mfa_serial']
            assume_role_kwargs['TokenCode'] = token_code
        if config['role_session_name'] is not None:
            assume_role_kwargs['RoleSessionName'] = config['role_session_name']
        else:
            role_session_name = 'AWS-CLI-session-%s' % (int(time.time()))
            assume_role_kwargs['RoleSessionName'] = role_session_name
        return assume_role_kwargs


class CredentialResolver(object):

    def __init__(self, providers):
        """

        :param providers: A list of ``CredentialProvider`` instances.

        """
        self.providers = providers

    def insert_before(self, name, credential_provider):
        """
        Inserts a new instance of ``CredentialProvider`` into the chain that will
        be tried before an existing one.

        :param name: The short name of the credentials you'd like to insert the
            new credentials before. (ex. ``env`` or ``config``). Existing names
            & ordering can be discovered via ``self.available_methods``.
        :type name: string

        :param cred_instance: An instance of the new ``Credentials`` object
            you'd like to add to the chain.
        :type cred_instance: A subclass of ``Credentials``
        """
        try:
            offset = [p.METHOD for p in self.providers].index(name)
        except ValueError:
            raise UnknownCredentialError(name=name)
        self.providers.insert(offset, credential_provider)

    def insert_after(self, name, credential_provider):
        """
        Inserts a new type of ``Credentials`` instance into the chain that will
        be tried after an existing one.

        :param name: The short name of the credentials you'd like to insert the
            new credentials after. (ex. ``env`` or ``config``). Existing names
            & ordering can be discovered via ``self.available_methods``.
        :type name: string

        :param cred_instance: An instance of the new ``Credentials`` object
            you'd like to add to the chain.
        :type cred_instance: A subclass of ``Credentials``
        """
        offset = self._get_provider_offset(name)
        self.providers.insert(offset + 1, credential_provider)

    def remove(self, name):
        """
        Removes a given ``Credentials`` instance from the chain.

        :param name: The short name of the credentials instance to remove.
        :type name: string
        """
        available_methods = [p.METHOD for p in self.providers]
        if not name in available_methods:
            # It's not present. Fail silently.
            return

        offset = available_methods.index(name)
        self.providers.pop(offset)

    def get_provider(self, name):
        """Return a credential provider by name.

        :type name: str
        :param name: The name of the provider.

        :raises UnknownCredentialError: Raised if no
            credential provider by the provided name
            is found.
        """
        return self.providers[self._get_provider_offset(name)]

    def _get_provider_offset(self, name):
        try:
            return [p.METHOD for p in self.providers].index(name)
        except ValueError:
            raise UnknownCredentialError(name=name)

    def load_credentials(self):
        """
        Goes through the credentials chain, returning the first ``Credentials``
        that could be loaded.
        """
        # First provider to return a non-None response wins.
        for provider in self.providers:
            logger.debug("Looking for credentials via: %s", provider.METHOD)
            creds = provider.load()
            if creds is not None:
                return creds

        # If we got here, no credentials could be found.
        # This feels like it should be an exception, but historically, ``None``
        # is returned.
        #
        # +1
        # -js
        return None
                                                                                                                                                                                                                                                                                                                                                      usr/local/lib/python2.7/dist-packages/botocore/credentials.pyc                                      0100644 0000000 0000062 00000102570 13077704401 023053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Û
˘àˇXc           @   sb  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m	 Z	 d  d l
 m Z d  d l Z d  d l Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d	 l m Z d  d
 l m Z d  d l m Z m Z e j e É Z e d d d d g É Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z  d Ñ  Z! d Ñ  Z" d Ñ  Z# d e$ f d Ñ  É  YZ% d e% f d Ñ  É  YZ& d e$ f d Ñ  É  YZ' d e' f d Ñ  É  YZ( d e' f d  Ñ  É  YZ) d! e' f d" Ñ  É  YZ* d# e' f d$ Ñ  É  YZ+ d% e' f d& Ñ  É  YZ, d' e' f d( Ñ  É  YZ- d) e' f d* Ñ  É  YZ. d+ e$ f d, Ñ  É  YZ/ d S(-   iˇˇˇˇN(   t
   namedtuple(   t   parse(   t   tzlocal(   t   total_seconds(   t   UnknownCredentialError(   t   PartialCredentialsError(   t   ConfigNotFound(   t   InvalidConfigError(   t   RefreshWithMFAUnsupportedError(   t   InstanceMetadataFetchert   parse_key_val_filet   ReadOnlyCredentialst
   access_keyt
   secret_keyt   tokenc   
         s)  à  j  d É p d } à  j  d É } à  j  d É } à  j  d É } à  j  d É } t É  } | t d á  f d Ü  d	 à  j d
 i  d | É t d | d | É t d | d | É t É  t É  t d t	 d | d | É É g } à  j  d d d É} | d k	 r	| j | É n t j d É t d | É }	 |	 S(   s¢   Create a default credential resolver.

    This creates a pre-configured credential resolver
    that includes the default lookup chain for
    credentials.

    t   profilet   defaultt   credentials_filet   config_filet   metadata_service_timeoutt   metadata_service_num_attemptst   load_configc              s   à  j  S(   N(   t   full_config(    (   t   session(    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   <lambda>;   s    t   client_creatort   cachet   profile_namet   creds_filenamet   config_filenamet   iam_role_fetchert   timeoutt   num_attemptst   methodst   instancesW   Skipping environment variable credential check because profile name was explicitly set.t	   providers(   s   instanceN(   t   get_config_variablet   EnvProvidert   AssumeRoleProvidert   create_clientt   SharedCredentialProvidert   ConfigProvidert   OriginalEC2Providert   BotoProvidert   InstanceMetadataProviderR	   t   Nonet   removet   loggert   debugt   CredentialResolver(
   R   R   t   credential_fileR   t   metadata_timeoutR    t   env_providerR#   t   explicit_profilet   resolver(    (   R   s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   create_credential_resolver)   s:    			c         C   s   t  |  É } | j É  S(   N(   R7   t   load_credentials(   R   R6   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   get_credentialsk   s    c           C   s   t  j  j t É  É S(   N(   t   datetimet   nowR   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt
   _local_nowp   s    c         C   s    t  |  t j É r |  St |  É S(   N(   t
   isinstanceR:   R   (   t   value(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   _parse_if_neededt   s    c         C   s#   t  |  t j É r |  j d É S|  S(   Ns   %Y-%m-%dT%H:%M:%SZ(   R=   R:   t   strftime(   R>   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   _serialize_if_neededz   s    c            s   á  á f d Ü  } | S(   Nc             sO   à  j  à ç  }  |  d } i | d d 6| d d 6| d d 6t | d É d	 6S(
   Nt   Credentialst   AccessKeyIdR   t   SecretAccessKeyR   t   SessionTokenR   t
   Expirationt   expiry_time(   t   assume_roleRA   (   t   responset   credentials(   t   clientt   params(    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   refreshÅ   s    
(    (   RK   RL   RM   (    (   RK   RL   s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   create_assume_role_refresherÄ   s    c          C   s   d Ñ  }  |  S(   Nc           S   s   t  É  Ç d  S(   N(   R   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt
   _refresherê   s    (    (   RO   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   create_mfa_serial_refresherè   s    	RB   c           B   s/   e  Z d  Z d d d Ñ Z d Ñ  Z d Ñ  Z RS(   s\  
    Holds the credentials needed to authenticate requests.

    :ivar access_key: The access key part of the credentials.
    :ivar secret_key: The secret key part of the credentials.
    :ivar token: The security token, valid only for session credentials.
    :ivar method: A string which identifies where the credentials
        were found.
    c         C   sG   | |  _  | |  _ | |  _ | d  k r0 d } n  | |  _ |  j É  d  S(   Nt   explicit(   R   R   R   R-   t   methodt
   _normalize(   t   selfR   R   R   RR   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   __init__£   s    					c         C   s4   t  j j |  j É |  _ t  j j |  j É |  _ d  S(   N(   t   botocoret   compatt   ensure_unicodeR   R   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRS   Ø   s    c         C   s   t  |  j |  j |  j É S(   N(   R   R   R   R   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   get_frozen_credentialsπ   s    	N(   t   __name__t
   __module__t   __doc__R-   RU   RS   RY   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRB   ò   s
   		
t   RefreshableCredentialsc           B   sÚ   e  Z d  Z d Z d Z e d Ñ Z d Ñ  Z e d Ñ  É Z	 e
 d Ñ  É Z e j d Ñ  É Z e
 d	 Ñ  É Z e j d
 Ñ  É Z e
 d Ñ  É Z e j d Ñ  É Z d Ñ  Z d d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z e d Ñ  É Z d Ñ  Z d Ñ  Z RS(   s  
    Holds the credentials needed to authenticate requests. In addition, it
    knows how to refresh itself.

    :ivar refresh_timeout: How long a given set of credentials are valid for.
        Useful for credentials fetched over the network.
    :ivar access_key: The access key part of the credentials.
    :ivar secret_key: The secret key part of the credentials.
    :ivar token: The security token, valid only for session credentials.
    :ivar method: A string which identifies where the credentials
        were found.
    i   i<   i
   c         C   sq   | |  _  | |  _ | |  _ | |  _ | |  _ | |  _ t j É  |  _ | |  _	 t
 | | | É |  _ |  j É  d  S(   N(   t   _refresh_usingt   _access_keyt   _secret_keyt   _tokent   _expiry_timet   _time_fetchert	   threadingt   Lockt   _refresh_lockRR   R   t   _frozen_credentialsRS   (   RT   R   R   R   RG   t   refresh_usingRR   t   time_fetcher(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   ”   s    							c         C   s4   t  j j |  j É |  _ t  j j |  j É |  _ d  S(   N(   RV   RW   RX   R_   R`   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRS   ‚   s    c         C   sJ   |  d | d d | d d | d d |  j  | d É d | d | É } | S(   NR   R   R   RG   RR   Rh   (   t   _expiry_datetime(   t   clst   metadataRh   RR   R"   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   create_from_metadataÊ   s    


	c         C   s   |  j  É  |  j S(   N(   t   _refreshR_   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR   Ú   s    
c         C   s   | |  _  d  S(   N(   R_   (   RT   R>   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR   ˜   s    c         C   s   |  j  É  |  j S(   N(   Rn   R`   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR   ˚   s    
c         C   s   | |  _  d  S(   N(   R`   (   RT   R>   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR      s    c         C   s   |  j  É  |  j S(   N(   Rn   Ra   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR     s    
c         C   s   | |  _  d  S(   N(   Ra   (   RT   R>   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR   	  s    c         C   s   |  j  |  j É  } t | É S(   N(   Rb   Rc   R   (   RT   t   delta(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   _seconds_remaining  s    c         C   sR   |  j  d k r t S| d k r+ |  j } n  |  j É  | k rA t St j d É t S(   s¥  Check if a refresh is needed.

        A refresh is needed if the expiry time associated
        with the temporary credentials is less than the
        provided ``refresh_in``.  If ``time_delta`` is not
        provided, ``self.advisory_refresh_needed`` will be used.

        For example, if your temporary credentials expire
        in 10 minutes and the provided ``refresh_in`` is
        ``15 * 60``, then this function will return ``True``.

        :type refresh_in: int
        :param refresh_in: The number of seconds before the
            credentials expire in which refresh attempts should
            be made.

        :return: True if refresh neeeded, False otherwise.

        s!   Credentials need to be refreshed.N(   Rb   R-   t   Falset   _advisory_refresh_timeoutRp   R/   R0   t   True(   RT   t
   refresh_in(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   refresh_needed  s    c         C   s   |  j  d d É S(   NRt   i    (   Ru   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   _is_expired3  s    c         C   sÀ   |  j  |  j É s d  S|  j j t É r| z@ |  j  |  j É sA d  S|  j  |  j É } |  j d | É d  SWd  |  j j É  XnK |  j  |  j É r« |  j è+ |  j  |  j É sÆ d  S|  j d t É Wd  QXn  d  S(   Nt   is_mandatory(	   Ru   Rr   Rf   t   acquireRq   t   _mandatory_refresh_timeoutt   _protected_refresht   releaseRs   (   RT   t   is_mandatory_refresh(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRn   7  s     
c         C   s∏   y |  j  É  } WnH t k
 rZ } | r. d n d } t j d | d t É| rV Ç  n  d  SX|  j | É |  j É  rñ d } t j | É t | É Ç n  t |  j	 |  j
 |  j É |  _ d  S(   Nt	   mandatoryt   advisorysA   Refreshing temporary credentials failed during %s refresh period.t   exc_infosL   Credentials were refreshed, but the refreshed credentials are still expired.(   R^   t	   ExceptionR/   t   warningRs   t   _set_from_dataRv   t   RuntimeErrorR   R_   R`   Ra   Rg   (   RT   Rw   Rl   t   et   period_namet   msg(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRz   T  s     	c         C   s
   t  |  É S(   N(   R   (   t   time_str(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRj   u  s    c         C   s[   | d |  _  | d |  _ | d |  _ t | d É |  _ t j d |  j É |  j É  d  S(   NR   R   R   RG   s(   Retrieved credentials will expire at: %s(   R   R   R   R   Rb   R/   R0   RS   (   RT   t   data(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÇ   y  s    c         C   s   |  j  É  |  j S(   sÑ  Return immutable credentials.

        The ``access_key``, ``secret_key``, and ``token`` properties
        on this class will always check and refresh credentials if
        needed before returning the particular credentials.

        This has an edge case where you can get inconsistent
        credentials.  Imagine this:

            # Current creds are "t1"
            tmp.access_key  ---> expired? no, so return t1.access_key
            # ---- time is now expired, creds need refreshing to "t2" ----
            tmp.secret_key  ---> expired? yes, refresh and return t2.secret_key

        This means we're using the access key from t1 with the secret key
        from t2.  To fix this issue, you can request a frozen credential object
        which is guaranteed not to change.

        The frozen credentials returned from this method should be used
        immediately and then discarded.  The typical usage pattern would
        be::

            creds = RefreshableCredentials(...)
            some_code = SomeSignerObject()
            # I'm about to sign the request.
            # The frozen credentials are only used for the
            # duration of generate_presigned_url and will be
            # immediately thrown away.
            request = some_code.sign_some_request(
                with_credentials=creds.get_frozen_credentials())
            print("Signed request:", request)

        (   Rn   Rg   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRY   Å  s    "
iÑ  iX  N(   RZ   R[   R\   Rr   Ry   R<   RU   RS   t   classmethodRm   t   propertyR   t   setterR   R   Rp   R-   Ru   Rv   Rn   Rz   t   staticmethodRj   RÇ   RY   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR]   ø   s(   		"			!	t   CredentialProviderc           B   s,   e  Z d Z d d  Ñ Z d Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  d  S(   N(   R   (   RT   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   ¨  s    c         C   s   t  S(   sz  
        Loads the credentials from their source & sets them on the object.

        Subclasses should implement this method (by reading from disk, the
        environment, the network or wherever), returning ``True`` if they were
        found & loaded.

        If not found, this method should return ``False``, indictating that the
        ``CredentialResolver`` should fall back to the next available method.

        The default implementation does nothing, assuming the user has set the
        ``access_key/secret_key/token`` themselves.

        :returns: Whether credentials were found & set
        :rtype: boolean
        (   Rs   (   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   loadØ  s    c         G   s\   g  } xO | D]G } y | j  | | É Wq t k
 rS t d |  j d | É Ç q Xq W| S(   Nt   providert   cred_var(   t   appendt   KeyErrorR   t   METHOD(   RT   t   mappingt	   key_namest   foundt   key_name(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   _extract_creds_from_mapping¬  s    N(   RZ   R[   R-   Rì   RU   Ré   Rò   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRç   ß  s   	R,   c           B   s    e  Z d  Z d Ñ  Z d Ñ  Z RS(   s   iam-rolec         C   s   | |  _  d  S(   N(   t   _role_fetcher(   RT   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   –  s    c         C   sX   |  j  } | j É  } | s d  St j d | d É t j | d |  j d | j É} | S(   Ns#   Found credentials from IAM Role: %st	   role_nameRR   Rh   (   Rô   t   retrieve_iam_role_credentialsR-   R/   t   infoR]   Rm   Rì   (   RT   t   fetcherRl   t   creds(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé   ”  s    		(   RZ   R[   Rì   RU   Ré   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR,   Õ  s   	R%   c           B   sP   e  Z d  Z d Z d Z d d g Z d	 d	 d Ñ Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 RS(
   t   envt   AWS_ACCESS_KEY_IDt   AWS_SECRET_ACCESS_KEYt   AWS_SECURITY_TOKENt   AWS_SESSION_TOKENc         C   s7   | d k r t j } n  | |  _ |  j | É |  _ d S(   s±  

        :param environ: The environment variables (defaults to
            ``os.environ`` if no value is provided).
        :param mapping: An optional mapping of variable names to
            environment variable names.  Use this if you want to
            change the mapping of access_key->AWS_ACCESS_KEY_ID, etc.
            The dict can have up to 3 keys: ``access_key``, ``secret_key``,
            ``session_token``.
        N(   R-   t   ost   environt   _build_mappingt   _mapping(   RT   R•   Rî   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   Ô  s    	c         C   s≤   i  } | d  k r< |  j | d <|  j | d <|  j | d <nr | j d |  j É | d <| j d |  j É | d <| j d |  j É | d <t | d t É sÆ | d g | d <n  | S(   NR   R   R   (   R-   t
   ACCESS_KEYt
   SECRET_KEYt   TOKENSt   getR=   t   list(   RT   Rî   t   var_mapping(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR¶   ˇ  s    c         C   s|   |  j  d |  j k rt t j d É |  j |  j |  j  d |  j  d É \ } } |  j É  } t | | | d |  j ÉSd Sd S(   sK   
        Search for credentials in explicit environment variables.
        R   s+   Found credentials in environment variables.R   RR   N(	   Rß   R•   R/   Rú   Rò   t   _get_session_tokenRB   Rì   R-   (   RT   R   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé     s    
c         C   s6   x/ |  j  d D]  } | |  j k r |  j | Sq Wd  S(   NR   (   Rß   R•   (   RT   t   token_envvar(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÆ   !  s    N(   RZ   R[   Rì   R®   R©   R™   R-   RU   R¶   Ré   RÆ   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR%   Á  s   		R*   c           B   s8   e  Z d  Z d Z d Z d Z d d d Ñ Z d Ñ  Z RS(   s   ec2-credentials-filet   AWS_CREDENTIAL_FILEt   AWSAccessKeyIdt   AWSSecretKeyc         C   sC   | d  k r t j } n  | d  k r- t } n  | |  _ | |  _ d  S(   N(   R-   R§   R•   R
   t   _environt   _parser(   RT   R•   t   parser(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   .  s    		c         C   sé   d |  j  k rÜ t j j |  j  d É } |  j | É } |  j | k rä t j d É | |  j } | |  j } t	 | | d |  j
 ÉSn d Sd S(   sN   
        Search for a credential file used by original EC2 CLI tools.
        R∞   s)   Found credentials in AWS_CREDENTIAL_FILE.RR   N(   R≥   R§   t   patht
   expanduserR¥   R®   R/   Rú   R©   RB   Rì   R-   (   RT   t	   full_pathRû   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé   6  s    N(	   RZ   R[   Rì   t   CRED_FILE_ENVR®   R©   R-   RU   Ré   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR*   '  s   R(   c           B   sG   e  Z d  Z d Z d Z d d g Z d d d Ñ Z d Ñ  Z d Ñ  Z	 RS(	   s   shared-credentials-filet   aws_access_key_idt   aws_secret_access_keyt   aws_security_tokent   aws_session_tokenc         C   sO   | |  _  | d  k r d } n  | |  _ | d  k rB t j j } n  | |  _ d  S(   NR   (   t   _creds_filenameR-   t   _profile_nameRV   t   configloadert   raw_config_parset   _ini_parser(   RT   R   R   t
   ini_parser(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   Q  s    			c         C   sπ   y |  j  |  j É } Wn t k
 r* d  SX|  j | k rµ | |  j } |  j | k rµ t j d |  j É |  j | |  j |  j	 É \ } } |  j
 | É } t | | | d |  j ÉSn  d  S(   Ns0   Found credentials in shared credentials file: %sRR   (   R¬   Ræ   R   R-   Rø   R®   R/   Rú   Rò   R©   RÆ   RB   Rì   (   RT   t   available_credst   configR   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé   Z  s    	
c         C   s,   x% |  j  D] } | | k r
 | | Sq
 Wd  S(   N(   R™   (   RT   R≈   RØ   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÆ   j  s    N(
   RZ   R[   Rì   R®   R©   R™   R-   RU   Ré   RÆ   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR(   G  s   		R)   c           B   sJ   e  Z d  Z d Z d Z d Z d d g Z d	 d Ñ Z d Ñ  Z	 d Ñ  Z
 RS(
   s0   INI based config provider with profile sections.s   config-fileR∫   Rª   Rº   RΩ   c         C   s:   | |  _  | |  _ | d k r- t j j } n  | |  _ d S(   s  

        :param config_filename: The session configuration scoped to the current
            profile.  This is available via ``session.config``.
        :param profile_name: The name of the current profile.
        :param config_parser: A config parser callable.

        N(   t   _config_filenameRø   R-   RV   R¿   R   t   _config_parser(   RT   R   R   t   config_parser(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   {  s
    			c         C   s≈   y |  j  |  j É } Wn t k
 r* d SX|  j | d k rΩ | d |  j } |  j | k r¡ t j d |  j É |  j | |  j |  j	 É \ } } |  j
 | É } t | | | d |  j ÉSn d Sd S(   sr   
        If there is are credentials in the configuration associated with
        the session, use those.
        t   profiless$   Credentials found in config file: %sRR   N(   R«   R∆   R   R-   Rø   R®   R/   Rú   Rò   R©   RÆ   RB   Rì   (   RT   R   t   profile_configR   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé   ä  s    	
c         C   s,   x% |  j  D] } | | k r
 | | Sq
 Wd  S(   N(   R™   (   RT   R    t
   token_name(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÆ   †  s    N(   RZ   R[   R\   Rì   R®   R©   R™   R-   RU   Ré   RÆ   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR)   p  s   	R+   c           B   sD   e  Z d  Z d Z d d g Z d Z d Z d d d Ñ Z d Ñ  Z	 RS(	   s   boto-configt   BOTO_CONFIGs   /etc/boto.cfgs   ~/.botoR∫   Rª   c         C   sI   | d  k r t j } n  | d  k r3 t j j } n  | |  _ | |  _ d  S(   N(   R-   R§   R•   RV   R¿   R¡   R≥   R¬   (   RT   R•   R√   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   Æ  s    	c         C   sﬂ   |  j  |  j k r( |  j |  j  g } n	 |  j } xß | D]ü } y |  j | É } Wn t k
 rg q8 n Xd | k r8 | d } |  j | k r◊ t j d | É |  j | |  j |  j	 É \ } } t
 | | d |  j ÉSq8 q8 Wd S(   s;   
        Look for credentials in boto config file.
        RB   s)   Found credentials in boto config file: %sRR   N(   t   BOTO_CONFIG_ENVR≥   t   DEFAULT_CONFIG_FILENAMESR¬   R   R®   R/   Rú   Rò   R©   RB   Rì   (   RT   t   potential_locationst   filenameR≈   RJ   R   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé   ∂  s"    	
	N(
   RZ   R[   Rì   RÕ   RŒ   R®   R©   R-   RU   Ré   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR+   ¶  s   R&   c           B   sï   e  Z d  Z d Z d Z e j d Ñ Z d Ñ  Z d Ñ  Z d Ñ  Z	 d Ñ  Z
 d	 Ñ  Z d
 Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   s   assume-rolet   role_arni<   i   c         C   s:   | |  _  | |  _ | |  _ | |  _ | |  _ i  |  _ d S(   s¢  

        :type load_config: callable
        :param load_config: A function that accepts no arguments, and
            when called, will return the full configuration dictionary
            for the session (``session.full_config``).

        :type client_creator: callable
        :param client_creator: A factory function that will create
            a client when called.  Has the same interface as
            ``botocore.session.Session.create_client``.

        :type cache: JSONFileCache
        :param cache: An object that supports ``__getitem__``,
            ``__setitem__``, and ``__contains__``.  An example
            of this is the ``JSONFileCache`` class.

        :type profile_name: str
        :param profile_name: The name of the profile.

        :type prompter: callable
        :param prompter: A callable that returns input provided
            by the user (i.e raw_input, getpass.getpass, etc.).

        N(   R   t   _load_configt   _client_creatorRø   t	   _promptert   _loaded_config(   RT   R   R   R   R   t   prompter(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   ÿ  s     					c         C   s)   |  j  É  |  _ |  j É  r% |  j É  Sd  S(   N(   R“   R’   t   _has_assume_role_config_varst   _load_creds_via_assume_role(   RT   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRé     s    c         C   s1   |  j  j d i  É } |  j | j |  j i  É k S(   NR…   (   R’   R´   t   ROLE_CONFIG_VARRø   (   RT   R…   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR◊     s    c         C   s_   |  j  É  } | d  k	 r) t j d É | S|  j É  \ } } |  j É  } |  j | | É | Sd  S(   Ns*   Credentials for role retrieved from cache.(   t   _load_creds_from_cacheR-   R/   R0   t   _retrieve_temp_credentialst   _create_cache_keyt   _write_cached_credentials(   RT   Rû   RI   t	   cache_key(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÿ     s    c         C   sc   |  j  É  } y> |  j | } |  j | É r< t j d É d  S|  j | É SWn t k
 r^ d  SXd  S(   Ns6   Credentials were found in cache, but they are expired.(   R‹   R   Rv   R/   R0   R-   t   _create_creds_from_responseRí   (   RT   Rﬁ   t
   from_cache(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR⁄   #  s    c         C   sF   t  | d d É } t j j t É  É } t | | É } | |  j k  S(   NRB   RF   (   R   R:   R;   R   R   t   EXPIRY_WINDOW_SECONDS(   RT   RJ   t   end_timeR;   t   seconds(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRv   2  s    c         C   ss   |  j  É  } | d j d d É } | j d É } | rP d |  j | | f } n d |  j | f } | j d d É S(	   NR—   t   :t   _t   role_session_names
   %s--%s--%ss   %s--%st   /t   -(   t   _get_role_config_valuest   replaceR´   Rø   (   RT   t   role_configR—   RÊ   Rﬁ   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR‹   8  s    c         C   s   | |  j  | <d  S(   N(   R   (   RT   Rû   Rﬁ   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR›   E  s    c   	      C   s  |  j  j d i  É } y< | |  j d } | |  j d } | |  j j d É } Wn1 t k
 rÑ } t d |  j d t | É É Ç n X| |  j j d É } | |  j j d É } | | k r‹ t d	 d
 | |  j f É Ç n  | | } i | d 6| d 6| d 6| d 6| d 6| d 6S(   NR…   t   source_profileR—   t
   mfa_serialRè   Rê   t   external_idRÊ   t	   error_msgsF   The source_profile "%s" referenced in the profile "%s" does not exist.t   source_cred_values(   R’   R´   Rø   Rí   R   Rì   t   strR   (	   RT   R…   RÏ   R—   RÌ   RÑ   RÓ   RÊ   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÈ   H  s,    
c         C   s¢   |  j  É  } | j d É d  k	 r- t É  } n! t |  j | É |  j | É É } t d | d d d | d d d | d d d	 |  j d
 t	 | d d É d | É S(   NRÌ   R   RB   RC   R   RD   R   RE   RR   RG   RF   Rh   (
   RÈ   R´   R-   RP   RN   t   _create_client_from_configt   _assume_role_base_kwargsR]   Rì   R?   (   RT   RI   R≈   t   refresh_func(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRﬂ   d  s    	c      	   C   s@   | d } |  j  d d | d d | d d | j d É É} | S(   NR   t   stsR∫   Rª   RΩ   (   R”   R´   (   RT   R≈   R   RK   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÚ   x  s    

c         C   s_   t  j d É |  j É  } |  j | É } |  j | É } | j | ç  } |  j | É } | | f S(   Ns&   Retrieving credentials via AssumeRole.(   R/   R0   RÈ   RÚ   RÛ   RH   Rﬂ   (   RT   R≈   RK   t   assume_role_kwargsRI   Rû   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR€   Å  s    c         C   s±   i | d d 6} | d d  k	 r2 | d | d <n  | d d  k	 rl |  j d É } | d | d <| | d <n  | d	 d  k	 rç | d	 | d
 <n  d t t j É  É } | | d
 <| S(   NR—   t   RoleArnRÓ   t
   ExternalIdRÌ   s   Enter MFA code: t   SerialNumbert	   TokenCodeRÊ   t   RoleSessionNames   AWS-CLI-session-%s(   R-   R‘   t   intt   time(   RT   R≈   Rˆ   t
   token_codeRÊ   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRÛ   å  s    
iÑ  (   RZ   R[   Rì   RŸ   R·   t   getpassRU   Ré   R◊   Rÿ   R⁄   Rv   R‹   R›   RÈ   Rﬂ   RÚ   R€   RÛ   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR&   œ  s    /												R1   c           B   sG   e  Z d  Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z d Ñ  Z RS(   c         C   s   | |  _  d S(   sQ   

        :param providers: A list of ``CredentialProvider`` instances.

        N(   R#   (   RT   R#   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyRU   û  s    c         C   sf   y, g  |  j  D] } | j ^ q j | É } Wn  t k
 rN t d | É Ç n X|  j  j | | É d S(   s=  
        Inserts a new instance of ``CredentialProvider`` into the chain that will
        be tried before an existing one.

        :param name: The short name of the credentials you'd like to insert the
            new credentials before. (ex. ``env`` or ``config``). Existing names
            & ordering can be discovered via ``self.available_methods``.
        :type name: string

        :param cred_instance: An instance of the new ``Credentials`` object
            you'd like to add to the chain.
        :type cred_instance: A subclass of ``Credentials``
        t   nameN(   R#   Rì   t   indext
   ValueErrorR   t   insert(   RT   R   t   credential_providert   pt   offset(    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   insert_before¶  s
    ,c         C   s*   |  j  | É } |  j j | d | É d S(   s9  
        Inserts a new type of ``Credentials`` instance into the chain that will
        be tried after an existing one.

        :param name: The short name of the credentials you'd like to insert the
            new credentials after. (ex. ``env`` or ``config``). Existing names
            & ordering can be discovered via ``self.available_methods``.
        :type name: string

        :param cred_instance: An instance of the new ``Credentials`` object
            you'd like to add to the chain.
        :type cred_instance: A subclass of ``Credentials``
        i   N(   t   _get_provider_offsetR#   R  (   RT   R   R  R  (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   insert_after∫  s    c         C   sR   g  |  j  D] } | j ^ q
 } | | k r/ d S| j | É } |  j  j | É d S(   s±   
        Removes a given ``Credentials`` instance from the chain.

        :param name: The short name of the credentials instance to remove.
        :type name: string
        N(   R#   Rì   R  t   pop(   RT   R   R  t   available_methodsR  (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR.   À  s
    c         C   s   |  j  |  j | É S(   s˜   Return a credential provider by name.

        :type name: str
        :param name: The name of the provider.

        :raises UnknownCredentialError: Raised if no
            credential provider by the provided name
            is found.
        (   R#   R  (   RT   R   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   get_provider⁄  s    
c         C   sQ   y* g  |  j  D] } | j ^ q j | É SWn  t k
 rL t d | É Ç n Xd  S(   NR   (   R#   Rì   R  R  R   (   RT   R   R  (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR  Ê  s    *c         C   sG   x@ |  j  D]5 } t j d | j É | j É  } | d k	 r
 | Sq
 Wd S(   sw   
        Goes through the credentials chain, returning the first ``Credentials``
        that could be loaded.
        s   Looking for credentials via: %sN(   R#   R/   R0   Rì   Ré   R-   (   RT   Rè   Rû   (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR8   Ï  s    (	   RZ   R[   RU   R  R	  R.   R  R  R8   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyR1   ú  s   						(0   R˝   R:   t   loggingR§   Rˇ   Rd   t   collectionsR    t   dateutil.parserR   t   dateutil.tzR   t   botocore.configloaderRV   t   botocore.compatR   t   botocore.exceptionsR   R   R   R   R   t   botocore.utilsR	   R
   t	   getLoggerRZ   R/   R   R7   R9   R<   R?   RA   RN   RP   t   objectRB   R]   Rç   R,   R%   R*   R(   R)   R+   R&   R1   (    (    (    s6   /tmp/pip-build-awuatQ/botocore/botocore/credentials.pyt   <module>   sL   	B							'Ë&@ )6)Õ                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/                                                0042755 0000000 0000062 00000000000 13077704402 020753  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/_retry.json                                     0100644 0000000 0000062 00000011156 13077704371 023156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "definitions": {
    "throttling": {
      "applies_when": {
        "response": {
          "service_error_code": "Throttling",
          "http_status_code": 400
        }
      }
    },
    "throttling_exception": {
      "applies_when": {
        "response": {
          "service_error_code": "ThrottlingException",
          "http_status_code": 400
        }
      }
    },
    "too_many_requests": {
      "applies_when": {
        "response": {
          "http_status_code": 429
        }
      }
    },
    "general_socket_errors": {
      "applies_when": {
        "socket_errors": ["GENERAL_CONNECTION_ERROR"]
      }
    },
    "general_server_error": {
      "applies_when": {
        "response": {
          "http_status_code": 500
        }
      }
    },
    "service_unavailable": {
      "applies_when": {
        "response": {
          "http_status_code": 503
        }
      }
    },
    "limit_exceeded": {
      "applies_when": {
        "response": {
          "http_status_code": 509
        }
      }
    }
  },
  "retry": {
    "__default__": {
      "max_attempts": 5,
      "delay": {
        "type": "exponential",
        "base": "rand",
        "growth_factor": 2
      },
      "policies": {
          "general_socket_errors": {"$ref": "general_socket_errors"},
          "general_server_error": {"$ref": "general_server_error"},
          "service_unavailable": {"$ref": "service_unavailable"},
          "limit_exceeded": {"$ref": "limit_exceeded"},
          "throttling_exception": {"$ref": "throttling_exception"},
          "throttling": {"$ref": "throttling"},
          "too_many_requests": {"$ref": "too_many_requests"}
      }
    },
    "dynamodb": {
      "__default__": {
        "max_attempts": 10,
        "delay": {
          "type": "exponential",
          "base": 0.05,
          "growth_factor": 2
        },
        "policies": {
          "throughput_exceeded": {
            "applies_when": {
              "response": {
                "service_error_code": "ProvisionedThroughputExceededException",
                "http_status_code": 400
              }
            }
          },
          "crc32": {
            "applies_when": {
              "response": {
                "crc32body": "x-amz-crc32"
              }
            }
          }
        }
      }
    },
    "ec2": {
      "__default__": {
        "policies": {
          "request_limit_exceeded": {
            "applies_when": {
              "response": {
                "service_error_code": "RequestLimitExceeded",
                "http_status_code": 503
              }
            }
          }
        }
      }
    },
    "cloudsearch": {
      "__default__": {
        "policies": {
          "request_limit_exceeded": {
            "applies_when": {
              "response": {
                "service_error_code": "BandwidthLimitExceeded",
                "http_status_code": 509
              }
            }
          }
        }
      }
    },
    "kinesis": {
      "DescribeStream": {
        "policies": {
          "request_limit_exceeded": {
            "applies_when": {
              "response": {
                "service_error_code": "LimitExceededException",
                "http_status_code": 400
              }
            }
          }
        }
      }
    },
    "sqs": {
      "__default__": {
        "policies": {
          "request_limit_exceeded": {
            "applies_when": {
              "response": {
                "service_error_code": "RequestThrottled",
                "http_status_code": 403
              }
            }
          }
        }
      }
    },
    "s3": {
      "__default__": {
        "policies": {
          "timeouts": {
            "applies_when": {
              "response": {
                "http_status_code": 400,
                "service_error_code": "RequestTimeout"
              }
            }
          },
          "contentmd5": {
            "applies_when": {
              "response": {
                "http_status_code": 400,
                "service_error_code": "BadDigest"
              }
            }
          }
        }
      }
    },
    "route53": {
      "__default__": {
        "policies": {
          "request_limit_exceeded": {
            "applies_when": {
              "response": {
                "service_error_code": "Throttling",
                "http_status_code": 400
              }
            }
          },
          "still_processing": {
            "applies_when": {
              "response": {
                "service_error_code": "PriorRequestNotComplete",
                "http_status_code": 400
              }
            }
          }
        }
      }
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/botocore/data/acm/                                            0042755 0000000 0000062 00000000000 13077704402 021513  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/acm/2015-12-08/                                 0042755 0000000 0000062 00000000000 13077704402 022547  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/acm/2015-12-08/service-2.json                   0100644 0000000 0000062 00000076131 13077704371 025251  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2015-12-08",
    "endpointPrefix":"acm",
    "jsonVersion":"1.1",
    "serviceAbbreviation":"ACM",
    "serviceFullName":"AWS Certificate Manager",
    "signatureVersion":"v4",
    "targetPrefix":"CertificateManager",
    "protocol":"json"
  },
  "documentation":"<fullname>AWS Certificate Manager</fullname> <p>Welcome to the AWS Certificate Manager (ACM) Command Reference. This guide provides descriptions, syntax, and usage examples for each ACM command. You can use AWS Certificate Manager to request ACM Certificates for your AWS-based websites and applications. For general information about using ACM and for more information about using the console, see the <a href=\"http://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html\">AWS Certificate Manager User Guide</a>. For more information about using the ACM API, see the <a href=\"http://docs.aws.amazon.com/acm/latest/APIReference/Welcome.html\"> AWS Certificate Manager API Reference</a>. </p>",
  "operations":{
    "DeleteCertificate":{
      "name":"DeleteCertificate",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteCertificateRequest"},
      "errors":[
        {
          "shape":"ResourceNotFoundException",
          "exception":true,
          "documentation":"<p> The specified certificate cannot be found in the caller's account, or the caller's account cannot be found. </p>"
        },
        {
          "shape":"ResourceInUseException",
          "exception":true,
          "documentation":"<p> The certificate is in use by another AWS service in the caller's account. Remove the association and try again. </p>"
        },
        {
          "shape":"InvalidArnException",
          "exception":true,
          "documentation":"<p> The requested Amazon Resource Name (ARN) does not refer to an existing resource. </p>"
        }
      ],
      "documentation":"<p> Deletes an ACM Certificate and its associated private key. If this action succeeds, the certificate no longer appears in the list of ACM Certificates that can be displayed by calling the <a>ListCertificates</a> action or be retrieved by calling the <a>GetCertificate</a> action. The certificate will not be available for use by other AWS services.</p> <note>You cannot delete an ACM Certificate that is being used by another AWS service. To delete a certificate that is in use, the certificate association must first be removed. </note>"
    },
    "DescribeCertificate":{
      "name":"DescribeCertificate",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeCertificateRequest"},
      "output":{"shape":"DescribeCertificateResponse"},
      "errors":[
        {
          "shape":"ResourceNotFoundException",
          "exception":true,
          "documentation":"<p> The specified certificate cannot be found in the caller's account, or the caller's account cannot be found. </p>"
        },
        {
          "shape":"InvalidArnException",
          "exception":true,
          "documentation":"<p> The requested Amazon Resource Name (ARN) does not refer to an existing resource. </p>"
        }
      ],
      "documentation":"<p> Returns a list of the fields contained in the specified ACM Certificate. For example, this action returns the certificate status, a flag that indicates whether the certificate is associated with any other AWS service, and the date at which the certificate request was created. The ACM Certificate is specified on input by its Amazon Resource Name (ARN). </p>"
    },
    "GetCertificate":{
      "name":"GetCertificate",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetCertificateRequest"},
      "output":{"shape":"GetCertificateResponse"},
      "errors":[
        {
          "shape":"ResourceNotFoundException",
          "exception":true,
          "documentation":"<p> The specified certificate cannot be found in the caller's account, or the caller's account cannot be found. </p>"
        },
        {
          "shape":"RequestInProgressException",
          "exception":true,
          "documentation":"<p> The certificate request is in process and the certificate in your account has not yet been issued. </p>"
        },
        {
          "shape":"InvalidArnException",
          "exception":true,
          "documentation":"<p> The requested Amazon Resource Name (ARN) does not refer to an existing resource. </p>"
        }
      ],
      "documentation":"<p> Retrieves an ACM Certificate and certificate chain for the certificate specified by an ARN. The chain is an ordered list of certificates that contains the root certificate, intermediate certificates of subordinate CAs, and the ACM Certificate. The certificate and certificate chain are base64 encoded. If you want to decode the certificate chain to see the individual certificate fields, you can use OpenSSL. </p> <note> Currently, ACM Certificates can be used only with Elastic Load Balancing and Amazon CloudFront. </note>"
    },
    "ListCertificates":{
      "name":"ListCertificates",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListCertificatesRequest"},
      "output":{"shape":"ListCertificatesResponse"},
      "documentation":"<p> Retrieves a list of the ACM Certificate ARNs, and the domain name for each ARN, owned by the calling account. You can filter the list based on the <code>CertificateStatuses</code> parameter, and you can display up to <code>MaxItems</code> certificates at one time. If you have more than <code>MaxItems</code> certificates, use the <code>NextToken</code> marker from the response object in your next call to the <code>ListCertificates</code> action to retrieve the next set of certificate ARNs. </p>"
    },
    "RequestCertificate":{
      "name":"RequestCertificate",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"RequestCertificateRequest"},
      "output":{"shape":"RequestCertificateResponse"},
      "errors":[
        {
          "shape":"LimitExceededException",
          "exception":true,
          "documentation":"<p> An ACM limit has been exceeded. For example, you may have input more domains than are allowed or you've requested too many certificates for your account. See the exception message returned by ACM to determine which limit you have violated. For more information about ACM limits, see the <a href=\"http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html\">Limits</a> topic. </p>"
        },
        {
          "shape":"InvalidDomainValidationOptionsException",
          "exception":true,
          "documentation":"<p> One or more values in the <a>DomainValidationOption</a> structure is incorrect. </p>"
        }
      ],
      "documentation":"<p> Requests an ACM Certificate for use with other AWS services. To request an ACM Certificate, you must specify the fully qualified domain name (FQDN) for your site. You can also specify additional FQDNs if users can reach your site by using other names. For each domain name you specify, email is sent to the domain owner to request approval to issue the certificate. After receiving approval from the domain owner, the ACM Certificate is issued. For more information, see the <a href=\"http://docs.aws.amazon.com/acm/latest/userguide/overview.html\"> AWS Certificate Manager User Guide </a>. </p>"
    },
    "ResendValidationEmail":{
      "name":"ResendValidationEmail",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ResendValidationEmailRequest"},
      "errors":[
        {
          "shape":"ResourceNotFoundException",
          "exception":true,
          "documentation":"<p> The specified certificate cannot be found in the caller's account, or the caller's account cannot be found. </p>"
        },
        {
          "shape":"InvalidStateException",
          "exception":true,
          "documentation":"<p> Processing has reached an invalid state. For example, this exception can occur if the specified domain is not using email validation, or the current certificate status does not permit the requested operation. See the exception message returned by ACM to determine which state is not valid. </p>"
        },
        {
          "shape":"InvalidArnException",
          "exception":true,
          "documentation":"<p> The requested Amazon Resource Name (ARN) does not refer to an existing resource. </p>"
        },
        {
          "shape":"InvalidDomainValidationOptionsException",
          "exception":true,
          "documentation":"<p> One or more values in the <a>DomainValidationOption</a> structure is incorrect. </p>"
        }
      ],
      "documentation":"<p> Resends the email that requests domain ownership validation. The domain owner or an authorized representative must approve the ACM Certificate before it can be issued. The certificate can be approved by clicking a link in the mail to navigate to the Amazon certificate approval website and then clicking <b>I Approve</b>. However, the validation email can be blocked by spam filters. Therefore, if you do not receive the original mail, you can request that the mail be resent within 72 hours of requesting the ACM Certificate. If more than 72 hours have elapsed since your original request or since your last attempt to resend validation mail, you must request a new certificate. </p>"
    }
  },
  "shapes":{
    "Arn":{
      "type":"string",
      "min":20,
      "max":2048,
      "pattern":"arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]+:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*"
    },
    "CertificateBody":{
      "type":"string",
      "min":1,
      "max":524288,
      "pattern":"-{5}BEGIN CERTIFICATE-{5}\\u000D?\\u000A([A-Za-z0-9/+]{64}\\u000D?\\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\\u000D?\\u000A-{5}END CERTIFICATE-{5}(\\u000D?\\u000A)?"
    },
    "CertificateChain":{
      "type":"string",
      "min":1,
      "max":2097152,
      "pattern":"(-{5}BEGIN CERTIFICATE-{5}\\u000D?\\u000A([A-Za-z0-9/+]{64}\\u000D?\\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\\u000D?\\u000A-{5}END CERTIFICATE-{5}\\u000D?\\u000A)*-{5}BEGIN CERTIFICATE-{5}\\u000D?\\u000A([A-Za-z0-9/+]{64}\\u000D?\\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\\u000D?\\u000A-{5}END CERTIFICATE-{5}(\\u000D?\\u000A)?"
    },
    "CertificateDetail":{
      "type":"structure",
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> Amazon Resource Name (ARN) of the certificate. This is of the form: </p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p> For more information about ARNs, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html\">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>. </p>"
        },
        "DomainName":{
          "shape":"DomainNameString",
          "documentation":"<p> Fully qualified domain name (FQDN), such as www.example.com or example.com, for the certificate. </p>"
        },
        "SubjectAlternativeNames":{
          "shape":"DomainList",
          "documentation":"<p> One or more domain names (subject alternative names) included in the certificate request. After the certificate is issued, this list includes the domain names bound to the public key contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website. </p>"
        },
        "DomainValidationOptions":{
          "shape":"DomainValidationList",
          "documentation":"<p> References a <a>DomainValidation</a> structure that contains the domain name in the certificate and the email address that can be used for validation. </p>"
        },
        "Serial":{
          "shape":"String",
          "documentation":"<p> String that contains the serial number of the certificate. </p>"
        },
        "Subject":{
          "shape":"String",
          "documentation":"<p> The X.500 distinguished name of the entity associated with the public key contained in the certificate. </p>"
        },
        "Issuer":{
          "shape":"String",
          "documentation":"<p> The X.500 distinguished name of the CA that issued and signed the certificate. </p>"
        },
        "CreatedAt":{
          "shape":"TStamp",
          "documentation":"<p> Time at which the certificate was requested. </p>"
        },
        "IssuedAt":{
          "shape":"TStamp",
          "documentation":"<p> Time at which the certificate was issued. </p>"
        },
        "Status":{
          "shape":"CertificateStatus",
          "documentation":"<p> A <code>CertificateStatus</code> enumeration value that can contain one of the following: <ul> <li>PENDING_VALIDATION</li> <li>ISSUED</li> <li>INACTIVE</li> <li>EXPIRED</li> <li>REVOKED</li> <li>FAILED</li> <li>VALIDATION_TIMED_OUT</li> </ul> </p>"
        },
        "RevokedAt":{
          "shape":"TStamp",
          "documentation":"<p> The time, if any, at which the certificate was revoked. This value exists only if the certificate has been revoked. </p>"
        },
        "RevocationReason":{
          "shape":"RevocationReason",
          "documentation":"<p> A <code>RevocationReason</code> enumeration value that indicates why the certificate was revoked. This value exists only if the certificate has been revoked. This can be one of the following vales: <ul> <li>UNSPECIFIED</li> <li>KEY_COMPROMISE</li> <li>CA_COMPROMISE</li> <li>AFFILIATION_CHANGED</li> <li>SUPERCEDED</li> <li>CESSATION_OF_OPERATION</li> <li>CERTIFICATE_HOLD</li> <li>REMOVE_FROM_CRL</li> <li>PRIVILEGE_WITHDRAWN</li> <li>A_A_COMPROMISE</li> </ul> </p>"
        },
        "NotBefore":{
          "shape":"TStamp",
          "documentation":"<p> Time before which the certificate is not valid. </p>"
        },
        "NotAfter":{
          "shape":"TStamp",
          "documentation":"<p> Time after which the certificate is not valid. </p>"
        },
        "KeyAlgorithm":{
          "shape":"KeyAlgorithm",
          "documentation":"<p> Asymmetric algorithm used to generate the public and private key pair. Currently the only supported value is <code>RSA_2048</code>. </p>"
        },
        "SignatureAlgorithm":{
          "shape":"String",
          "documentation":"<p> Algorithm used to generate a signature. Currently the only supported value is <code>SHA256WITHRSA</code>. </p>"
        },
        "InUseBy":{
          "shape":"InUseList",
          "documentation":"<p> List that identifies ARNs that are using the certificate. A single ACM Certificate can be used by multiple AWS resources. </p>"
        }
      },
      "documentation":"<p> This structure is returned in the response object of the <a>DescribeCertificate</a> action. </p>"
    },
    "CertificateStatus":{
      "type":"string",
      "enum":[
        "PENDING_VALIDATION",
        "ISSUED",
        "INACTIVE",
        "EXPIRED",
        "VALIDATION_TIMED_OUT",
        "REVOKED",
        "FAILED"
      ]
    },
    "CertificateStatuses":{
      "type":"list",
      "member":{"shape":"CertificateStatus"}
    },
    "CertificateSummary":{
      "type":"structure",
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> Amazon Resource Name (ARN) of the certificate. This is of the form: </p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p> For more information about ARNs, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html\">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>. </p>"
        },
        "DomainName":{
          "shape":"DomainNameString",
          "documentation":"<p> Fully qualified domain name (FQDN), such as www.example.com or example.com, for the certificate. </p>"
        }
      },
      "documentation":"<p> This structure is returned in the response object of <a>ListCertificates</a> action. </p>"
    },
    "CertificateSummaryList":{
      "type":"list",
      "member":{"shape":"CertificateSummary"}
    },
    "DeleteCertificateRequest":{
      "type":"structure",
      "required":["CertificateArn"],
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> String that contains the ARN of the ACM Certificate to be deleted. This must be of the form: </p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p> For more information about ARNs, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html\">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>. </p>"
        }
      }
    },
    "DescribeCertificateRequest":{
      "type":"structure",
      "required":["CertificateArn"],
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> String that contains an ACM Certificate ARN. The ARN must be of the form: </p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p> For more information about ARNs, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html\">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>. </p>"
        }
      }
    },
    "DescribeCertificateResponse":{
      "type":"structure",
      "members":{
        "Certificate":{
          "shape":"CertificateDetail",
          "documentation":"<p>Contains a <a>CertificateDetail</a> structure that lists the fields of an ACM Certificate.</p>"
        }
      }
    },
    "DomainList":{
      "type":"list",
      "member":{"shape":"DomainNameString"},
      "min":1,
      "max":1000
    },
    "DomainNameString":{
      "type":"string",
      "min":1,
      "max":253,
      "pattern":"^(\\*\\.)?(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$"
    },
    "DomainValidation":{
      "type":"structure",
      "required":["DomainName"],
      "members":{
        "DomainName":{
          "shape":"DomainNameString",
          "documentation":"<p> Fully Qualified Domain Name (FQDN) of the form <code>www.example.com or </code><code>example.com</code> </p>"
        },
        "ValidationEmails":{
          "shape":"ValidationEmailList",
          "documentation":"<p> A list of contact address for the domain registrant. </p>"
        },
        "ValidationDomain":{
          "shape":"DomainNameString",
          "documentation":"<p> The base validation domain that acts as the suffix of the email addresses that are used to send the emails. </p>"
        }
      },
      "documentation":"<p> Structure that contains the domain name, the base validation domain to which validation email is sent, and the email addresses used to validate the domain identity. </p>"
    },
    "DomainValidationList":{
      "type":"list",
      "member":{"shape":"DomainValidation"},
      "min":1,
      "max":1000
    },
    "DomainValidationOption":{
      "type":"structure",
      "required":[
        "DomainName",
        "ValidationDomain"
      ],
      "members":{
        "DomainName":{
          "shape":"DomainNameString",
          "documentation":"<p> Fully Qualified Domain Name (FQDN) of the certificate being requested. </p>"
        },
        "ValidationDomain":{
          "shape":"DomainNameString",
          "documentation":"<p> The domain to which validation email is sent. This is the base validation domain that will act as the suffix of the email addresses. This must be the same as the <code>DomainName</code> value or a superdomain of the <code>DomainName</code> value. For example, if you requested a certificate for <code>site.subdomain.example.com</code> and specify a <b>ValidationDomain</b> of <code>subdomain.example.com</code>, ACM sends email to the domain registrant, technical contact, and administrative contact in WHOIS for the base domain and the and the following five addresses: <ul> <li>admin@subdomain.example.com</li> <li>administrator@subdomain.example.com</li> <li>hostmaster@subdomain.example.com</li> <li>postmaster@subdomain.example.com</li> <li>webmaster@subdomain.example.com</li> </ul> </p>"
        }
      },
      "documentation":"<p> This structure is used in the request object of the <a>RequestCertificate</a> action. </p>"
    },
    "DomainValidationOptionList":{
      "type":"list",
      "member":{"shape":"DomainValidationOption"},
      "min":1,
      "max":1000
    },
    "GetCertificateRequest":{
      "type":"structure",
      "required":["CertificateArn"],
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> String that contains a certificate ARN in the following format: </p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p> For more information about ARNs, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html\">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>. </p>"
        }
      }
    },
    "GetCertificateResponse":{
      "type":"structure",
      "members":{
        "Certificate":{
          "shape":"CertificateBody",
          "documentation":"<p> String that contains the ACM Certificate represented by the ARN specified at input. </p>"
        },
        "CertificateChain":{
          "shape":"CertificateChain",
          "documentation":"<p> The certificate chain that contains the root certificate issued by the certificate authority (CA). </p>"
        }
      }
    },
    "IdempotencyToken":{
      "type":"string",
      "min":1,
      "max":32,
      "pattern":"\\w+"
    },
    "InUseList":{
      "type":"list",
      "member":{"shape":"String"}
    },
    "InvalidArnException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> The requested Amazon Resource Name (ARN) does not refer to an existing resource. </p>"
    },
    "InvalidDomainValidationOptionsException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> One or more values in the <a>DomainValidationOption</a> structure is incorrect. </p>"
    },
    "InvalidStateException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> Processing has reached an invalid state. For example, this exception can occur if the specified domain is not using email validation, or the current certificate status does not permit the requested operation. See the exception message returned by ACM to determine which state is not valid. </p>"
    },
    "KeyAlgorithm":{
      "type":"string",
      "enum":[
        "RSA_2048",
        "EC_prime256v1"
      ]
    },
    "LimitExceededException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> An ACM limit has been exceeded. For example, you may have input more domains than are allowed or you've requested too many certificates for your account. See the exception message returned by ACM to determine which limit you have violated. For more information about ACM limits, see the <a href=\"http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html\">Limits</a> topic. </p>"
    },
    "ListCertificatesRequest":{
      "type":"structure",
      "members":{
        "CertificateStatuses":{
          "shape":"CertificateStatuses",
          "documentation":"<p> Identifies the statuses of the ACM Certificates for which you want to retrieve the ARNs. This can be one or more of the following values: <ul> <li><code>PENDING_VALIDATION</code></li> <li><code>ISSUED</code></li> <li><code>INACTIVE</code></li> <li><code>EXPIRED</code></li> <li><code>VALIDATION_TIMED_OUT</code></li> <li><code>REVOKED</code></li> <li><code>FAILED</code></li> </ul> </p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p> String that contains an opaque marker of the next ACM Certificate ARN to be displayed. Use this parameter when paginating results, and only in a subsequent request after you've received a response where the results have been truncated. Set it to an empty string the first time you call this action, and set it to the value of the <code>NextToken</code> element you receive in the response object for subsequent calls. </p>"
        },
        "MaxItems":{
          "shape":"MaxItems",
          "documentation":"<p> Specify this parameter when paginating results to indicate the maximum number of ACM Certificates that you want to display for each response. If there are additional certificates beyond the maximum you specify, use the <code>NextToken</code> value in your next call to the <code>ListCertificates</code> action. </p>"
        }
      }
    },
    "ListCertificatesResponse":{
      "type":"structure",
      "members":{
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p> If the list has been truncated, this value is present and should be used for the <code>NextToken</code> input parameter on your next call to <code>ListCertificates</code>. </p>"
        },
        "CertificateSummaryList":{
          "shape":"CertificateSummaryList",
          "documentation":"<p> A list of the certificate ARNs. </p>"
        }
      }
    },
    "MaxItems":{
      "type":"integer",
      "min":1,
      "max":1000
    },
    "NextToken":{
      "type":"string",
      "min":1,
      "max":320,
      "pattern":"[\\u0009\\u000A\\u000D\\u0020-\\u00FF]*"
    },
    "RequestCertificateRequest":{
      "type":"structure",
      "required":["DomainName"],
      "members":{
        "DomainName":{
          "shape":"DomainNameString",
          "documentation":"<p> Fully qualified domain name (FQDN), such as www.example.com, of the site you want to secure with an ACM Certificate. Use an asterisk (*) to create a wildcard certificate that protects several sites in the same domain. For example, *.example.com protects www.example.com, site.example.com, and images.example.com. </p>"
        },
        "SubjectAlternativeNames":{
          "shape":"DomainList",
          "documentation":"<p> Additional FQDNs to be included in the Subject Alternative Name extension of the ACM Certificate. For example, add the name www.example.net to a certificate for which the <code>DomainName</code> field is www.example.com if users can reach your site by using either name. </p>"
        },
        "IdempotencyToken":{
          "shape":"IdempotencyToken",
          "documentation":"<p> Customer chosen string that can be used to distinguish between calls to <code>RequestCertificate</code>. Idempotency tokens time out after one hour. Therefore, if you call <code>RequestCertificate</code> multiple times with the same idempotency token within one hour, ACM recognizes that you are requesting only one certificate and will issue only one. If you change the idempotency token for each call, ACM recognizes that you are requesting multiple certificates. </p>"
        },
        "DomainValidationOptions":{
          "shape":"DomainValidationOptionList",
          "documentation":"<p> The base validation domain that will act as the suffix of the email addresses that are used to send the emails. This must be the same as the <code>Domain</code> value or a superdomain of the <code>Domain</code> value. For example, if you requested a certificate for <code>test.example.com</code> and specify <b>DomainValidationOptions</b> of <code>example.com</code>, ACM sends email to the domain registrant, technical contact, and administrative contact in WHOIS and the following five addresses: <ul> <li>admin@example.com</li> <li>administrator@example.com</li> <li>hostmaster@example.com</li> <li>postmaster@example.com</li> <li>webmaster@example.com</li> </ul> </p>"
        }
      }
    },
    "RequestCertificateResponse":{
      "type":"structure",
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> String that contains the ARN of the issued certificate. This must be of the form: </p> <p> <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p>"
        }
      }
    },
    "RequestInProgressException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> The certificate request is in process and the certificate in your account has not yet been issued. </p>"
    },
    "ResendValidationEmailRequest":{
      "type":"structure",
      "required":[
        "CertificateArn",
        "Domain",
        "ValidationDomain"
      ],
      "members":{
        "CertificateArn":{
          "shape":"Arn",
          "documentation":"<p> String that contains the ARN of the requested certificate. The certificate ARN is generated and returned by <a>RequestCertificate</a> as soon as the request is made. By default, using this parameter causes email to be sent to all top-level domains you specified in the certificate request. </p> <p> The ARN must be of the form: </p> <p> <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p>"
        },
        "Domain":{
          "shape":"DomainNameString",
          "documentation":"<p> The Fully Qualified Domain Name (FQDN) of the certificate that needs to be validated. </p>"
        },
        "ValidationDomain":{
          "shape":"DomainNameString",
          "documentation":"<p> The base validation domain that will act as the suffix of the email addresses that are used to send the emails. This must be the same as the <code>Domain</code> value or a superdomain of the <code>Domain</code> value. For example, if you requested a certificate for <code>site.subdomain.example.com</code> and specify a <b>ValidationDomain</b> of <code>subdomain.example.com</code>, ACM sends email to the domain registrant, technical contact, and administrative contact in WHOIS and the following five addresses: <ul> <li>admin@subdomain.example.com</li> <li>administrator@subdomain.example.com</li> <li>hostmaster@subdomain.example.com</li> <li>postmaster@subdomain.example.com</li> <li>webmaster@subdomain.example.com</li> </ul> </p>"
        }
      }
    },
    "ResourceInUseException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> The certificate is in use by another AWS service in the caller's account. Remove the association and try again. </p>"
    },
    "ResourceNotFoundException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "exception":true,
      "documentation":"<p> The specified certificate cannot be found in the caller's account, or the caller's account cannot be found. </p>"
    },
    "RevocationReason":{
      "type":"string",
      "enum":[
        "UNSPECIFIED",
        "KEY_COMPROMISE",
        "CA_COMPROMISE",
        "AFFILIATION_CHANGED",
        "SUPERCEDED",
        "CESSATION_OF_OPERATION",
        "CERTIFICATE_HOLD",
        "REMOVE_FROM_CRL",
        "PRIVILEGE_WITHDRAWN",
        "A_A_COMPROMISE"
      ]
    },
    "String":{"type":"string"},
    "TStamp":{"type":"timestamp"},
    "ValidationEmailList":{
      "type":"list",
      "member":{"shape":"String"}
    }
  },
  "examples":{
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/lib/python2.7/dist-packages/botocore/data/apigateway/                                     0042755 0000000 0000062 00000000000 13077704402 023106  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/apigateway/2015-07-09/                          0042755 0000000 0000062 00000000000 13077704402 024147  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/apigateway/2015-07-09/paginators-1.json         0100644 0000000 0000062 00000002347 13077704371 027355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "pagination": {
    "GetApiKeys": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetBasePathMappings": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetClientCertificates": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetDeployments": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetDomainNames": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetModels": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetResources": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    },
    "GetRestApis": {
      "input_token": "position",
      "output_token": "position",
      "limit_key": "limit",
      "result_key": "items"
    }
  }
}
                                                                                                                                                                                                                                                                                         usr/local/lib/python2.7/dist-packages/botocore/data/apigateway/2015-07-09/service-2.json            0100644 0000000 0000062 00000450575 13077704371 026661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2015-07-09",
    "endpointPrefix":"apigateway",
    "protocol":"rest-json",
    "serviceFullName":"Amazon API Gateway",
    "signatureVersion":"v4"
  },
  "operations":{
    "CreateApiKey":{
      "name":"CreateApiKey",
      "http":{
        "method":"POST",
        "requestUri":"/apikeys",
        "responseCode":201
      },
      "input":{"shape":"CreateApiKeyRequest"},
      "output":{"shape":"ApiKey"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"LimitExceededException"},
        {"shape":"BadRequestException"}
      ]
    },
    "CreateAuthorizer":{
      "name":"CreateAuthorizer",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/authorizers",
        "responseCode":201
      },
      "input":{"shape":"CreateAuthorizerRequest"},
      "output":{"shape":"Authorizer"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"LimitExceededException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "CreateBasePathMapping":{
      "name":"CreateBasePathMapping",
      "http":{
        "method":"POST",
        "requestUri":"/domainnames/{domain_name}/basepathmappings",
        "responseCode":201
      },
      "input":{"shape":"CreateBasePathMappingRequest"},
      "output":{"shape":"BasePathMapping"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"ConflictException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Creates a new <a>BasePathMapping</a> resource.</p>"
    },
    "CreateDeployment":{
      "name":"CreateDeployment",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/deployments",
        "responseCode":201
      },
      "input":{"shape":"CreateDeploymentRequest"},
      "output":{"shape":"Deployment"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"ServiceUnavailableException"}
      ],
      "documentation":"<p>Creates a <a>Deployment</a> resource, which makes a specified <a>RestApi</a> callable over the internet.</p>"
    },
    "CreateDomainName":{
      "name":"CreateDomainName",
      "http":{
        "method":"POST",
        "requestUri":"/domainnames",
        "responseCode":201
      },
      "input":{"shape":"CreateDomainNameRequest"},
      "output":{"shape":"DomainName"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Creates a new domain name.</p>"
    },
    "CreateModel":{
      "name":"CreateModel",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/models",
        "responseCode":201
      },
      "input":{"shape":"CreateModelRequest"},
      "output":{"shape":"Model"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Adds a new <a>Model</a> resource to an existing <a>RestApi</a> resource.</p>"
    },
    "CreateResource":{
      "name":"CreateResource",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/resources/{parent_id}",
        "responseCode":201
      },
      "input":{"shape":"CreateResourceRequest"},
      "output":{"shape":"Resource"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Creates a <a>Resource</a> resource.</p>"
    },
    "CreateRestApi":{
      "name":"CreateRestApi",
      "http":{
        "method":"POST",
        "requestUri":"/restapis",
        "responseCode":201
      },
      "input":{"shape":"CreateRestApiRequest"},
      "output":{"shape":"RestApi"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"LimitExceededException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Creates a new <a>RestApi</a> resource.</p>"
    },
    "CreateStage":{
      "name":"CreateStage",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/stages",
        "responseCode":201
      },
      "input":{"shape":"CreateStageRequest"},
      "output":{"shape":"Stage"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Creates a new <a>Stage</a> resource that references a pre-existing <a>Deployment</a> for the API. </p>"
    },
    "DeleteApiKey":{
      "name":"DeleteApiKey",
      "http":{
        "method":"DELETE",
        "requestUri":"/apikeys/{api_Key}",
        "responseCode":202
      },
      "input":{"shape":"DeleteApiKeyRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes the <a>ApiKey</a> resource.</p>"
    },
    "DeleteAuthorizer":{
      "name":"DeleteAuthorizer",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/authorizers/{authorizer_id}",
        "responseCode":202
      },
      "input":{"shape":"DeleteAuthorizerRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"BadRequestException"},
        {"shape":"ConflictException"}
      ],
      "documentation":"<p>Deletes an existing <a>Authorizer</a> resource.</p>"
    },
    "DeleteBasePathMapping":{
      "name":"DeleteBasePathMapping",
      "http":{
        "method":"DELETE",
        "requestUri":"/domainnames/{domain_name}/basepathmappings/{base_path}",
        "responseCode":202
      },
      "input":{"shape":"DeleteBasePathMappingRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes the <a>BasePathMapping</a> resource.</p>"
    },
    "DeleteClientCertificate":{
      "name":"DeleteClientCertificate",
      "http":{
        "method":"DELETE",
        "requestUri":"/clientcertificates/{clientcertificate_id}",
        "responseCode":202
      },
      "input":{"shape":"DeleteClientCertificateRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"}
      ]
    },
    "DeleteDeployment":{
      "name":"DeleteDeployment",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/deployments/{deployment_id}",
        "responseCode":202
      },
      "input":{"shape":"DeleteDeploymentRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes a <a>Deployment</a> resource. Deleting a deployment will only succeed if there are no <a>Stage</a> resources associated with it.</p>"
    },
    "DeleteDomainName":{
      "name":"DeleteDomainName",
      "http":{
        "method":"DELETE",
        "requestUri":"/domainnames/{domain_name}",
        "responseCode":202
      },
      "input":{"shape":"DeleteDomainNameRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes the <a>DomainName</a> resource.</p>"
    },
    "DeleteIntegration":{
      "name":"DeleteIntegration",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
        "responseCode":204
      },
      "input":{"shape":"DeleteIntegrationRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a delete integration.</p>"
    },
    "DeleteIntegrationResponse":{
      "name":"DeleteIntegrationResponse",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
        "responseCode":204
      },
      "input":{"shape":"DeleteIntegrationResponseRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a delete integration response.</p>"
    },
    "DeleteMethod":{
      "name":"DeleteMethod",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
        "responseCode":204
      },
      "input":{"shape":"DeleteMethodRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes an existing <a>Method</a> resource.</p>"
    },
    "DeleteMethodResponse":{
      "name":"DeleteMethodResponse",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
        "responseCode":204
      },
      "input":{"shape":"DeleteMethodResponseRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes an existing <a>MethodResponse</a> resource.</p>"
    },
    "DeleteModel":{
      "name":"DeleteModel",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/models/{model_name}",
        "responseCode":202
      },
      "input":{"shape":"DeleteModelRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"BadRequestException"},
        {"shape":"ConflictException"}
      ],
      "documentation":"<p>Deletes a model.</p>"
    },
    "DeleteResource":{
      "name":"DeleteResource",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}",
        "responseCode":202
      },
      "input":{"shape":"DeleteResourceRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes a <a>Resource</a> resource.</p>"
    },
    "DeleteRestApi":{
      "name":"DeleteRestApi",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}",
        "responseCode":202
      },
      "input":{"shape":"DeleteRestApiRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes the specified API.</p>"
    },
    "DeleteStage":{
      "name":"DeleteStage",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}",
        "responseCode":202
      },
      "input":{"shape":"DeleteStageRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Deletes a <a>Stage</a> resource.</p>"
    },
    "FlushStageAuthorizersCache":{
      "name":"FlushStageAuthorizersCache",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}/cache/authorizers",
        "responseCode":202
      },
      "input":{"shape":"FlushStageAuthorizersCacheRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Flushes all authorizer cache entries on a stage.</p>"
    },
    "FlushStageCache":{
      "name":"FlushStageCache",
      "http":{
        "method":"DELETE",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}/cache/data",
        "responseCode":202
      },
      "input":{"shape":"FlushStageCacheRequest"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Flushes a stage's cache.</p>"
    },
    "GenerateClientCertificate":{
      "name":"GenerateClientCertificate",
      "http":{
        "method":"POST",
        "requestUri":"/clientcertificates",
        "responseCode":201
      },
      "input":{"shape":"GenerateClientCertificateRequest"},
      "output":{"shape":"ClientCertificate"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"LimitExceededException"}
      ]
    },
    "GetAccount":{
      "name":"GetAccount",
      "http":{
        "method":"GET",
        "requestUri":"/account"
      },
      "input":{"shape":"GetAccountRequest"},
      "output":{"shape":"Account"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Gets information about the current <a>Account</a> resource.</p>"
    },
    "GetApiKey":{
      "name":"GetApiKey",
      "http":{
        "method":"GET",
        "requestUri":"/apikeys/{api_Key}"
      },
      "input":{"shape":"GetApiKeyRequest"},
      "output":{"shape":"ApiKey"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Gets information about the current <a>ApiKey</a> resource.</p>"
    },
    "GetApiKeys":{
      "name":"GetApiKeys",
      "http":{
        "method":"GET",
        "requestUri":"/apikeys"
      },
      "input":{"shape":"GetApiKeysRequest"},
      "output":{"shape":"ApiKeys"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Gets information about the current <a>ApiKeys</a> resource.</p>"
    },
    "GetAuthorizer":{
      "name":"GetAuthorizer",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/authorizers/{authorizer_id}"
      },
      "input":{"shape":"GetAuthorizerRequest"},
      "output":{"shape":"Authorizer"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describe an existing <a>Authorizer</a> resource.</p>"
    },
    "GetAuthorizers":{
      "name":"GetAuthorizers",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/authorizers"
      },
      "input":{"shape":"GetAuthorizersRequest"},
      "output":{"shape":"Authorizers"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describe an existing <a>Authorizers</a> resource.</p>"
    },
    "GetBasePathMapping":{
      "name":"GetBasePathMapping",
      "http":{
        "method":"GET",
        "requestUri":"/domainnames/{domain_name}/basepathmappings/{base_path}"
      },
      "input":{"shape":"GetBasePathMappingRequest"},
      "output":{"shape":"BasePathMapping"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describe a <a>BasePathMapping</a> resource.</p>"
    },
    "GetBasePathMappings":{
      "name":"GetBasePathMappings",
      "http":{
        "method":"GET",
        "requestUri":"/domainnames/{domain_name}/basepathmappings"
      },
      "input":{"shape":"GetBasePathMappingsRequest"},
      "output":{"shape":"BasePathMappings"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a collection of <a>BasePathMapping</a> resources.</p>"
    },
    "GetClientCertificate":{
      "name":"GetClientCertificate",
      "http":{
        "method":"GET",
        "requestUri":"/clientcertificates/{clientcertificate_id}"
      },
      "input":{"shape":"GetClientCertificateRequest"},
      "output":{"shape":"ClientCertificate"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "GetClientCertificates":{
      "name":"GetClientCertificates",
      "http":{
        "method":"GET",
        "requestUri":"/clientcertificates"
      },
      "input":{"shape":"GetClientCertificatesRequest"},
      "output":{"shape":"ClientCertificates"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "GetDeployment":{
      "name":"GetDeployment",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/deployments/{deployment_id}"
      },
      "input":{"shape":"GetDeploymentRequest"},
      "output":{"shape":"Deployment"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"ServiceUnavailableException"}
      ],
      "documentation":"<p>Gets information about a <a>Deployment</a> resource.</p>"
    },
    "GetDeployments":{
      "name":"GetDeployments",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/deployments"
      },
      "input":{"shape":"GetDeploymentsRequest"},
      "output":{"shape":"Deployments"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"ServiceUnavailableException"}
      ],
      "documentation":"<p>Gets information about a <a>Deployments</a> collection.</p>"
    },
    "GetDomainName":{
      "name":"GetDomainName",
      "http":{
        "method":"GET",
        "requestUri":"/domainnames/{domain_name}"
      },
      "input":{"shape":"GetDomainNameRequest"},
      "output":{"shape":"DomainName"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ServiceUnavailableException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a domain name that is contained in a simpler, more intuitive URL that can be called.</p>"
    },
    "GetDomainNames":{
      "name":"GetDomainNames",
      "http":{
        "method":"GET",
        "requestUri":"/domainnames"
      },
      "input":{"shape":"GetDomainNamesRequest"},
      "output":{"shape":"DomainNames"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a collection of <a>DomainName</a> resources.</p>"
    },
    "GetExport":{
      "name":"GetExport",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}",
        "responseCode":200
      },
      "input":{"shape":"GetExportRequest"},
      "output":{"shape":"ExportResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "GetIntegration":{
      "name":"GetIntegration",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration"
      },
      "input":{"shape":"GetIntegrationRequest"},
      "output":{"shape":"Integration"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a get integration.</p>"
    },
    "GetIntegrationResponse":{
      "name":"GetIntegrationResponse",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}"
      },
      "input":{"shape":"GetIntegrationResponseRequest"},
      "output":{"shape":"IntegrationResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a get integration response.</p>"
    },
    "GetMethod":{
      "name":"GetMethod",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}"
      },
      "input":{"shape":"GetMethodRequest"},
      "output":{"shape":"Method"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describe an existing <a>Method</a> resource.</p>"
    },
    "GetMethodResponse":{
      "name":"GetMethodResponse",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}"
      },
      "input":{"shape":"GetMethodResponseRequest"},
      "output":{"shape":"MethodResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describes a <a>MethodResponse</a> resource.</p>"
    },
    "GetModel":{
      "name":"GetModel",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/models/{model_name}"
      },
      "input":{"shape":"GetModelRequest"},
      "output":{"shape":"Model"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describes an existing model defined for a <a>RestApi</a> resource.</p>"
    },
    "GetModelTemplate":{
      "name":"GetModelTemplate",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/models/{model_name}/default_template"
      },
      "input":{"shape":"GetModelTemplateRequest"},
      "output":{"shape":"Template"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Generates a sample mapping template that can be used to transform a payload into the structure of a model.</p>"
    },
    "GetModels":{
      "name":"GetModels",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/models"
      },
      "input":{"shape":"GetModelsRequest"},
      "output":{"shape":"Models"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Describes existing <a>Models</a> defined for a <a>RestApi</a> resource.</p>"
    },
    "GetResource":{
      "name":"GetResource",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}"
      },
      "input":{"shape":"GetResourceRequest"},
      "output":{"shape":"Resource"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Lists information about a resource.</p>"
    },
    "GetResources":{
      "name":"GetResources",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/resources"
      },
      "input":{"shape":"GetResourcesRequest"},
      "output":{"shape":"Resources"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Lists information about a collection of <a>Resource</a> resources.</p>"
    },
    "GetRestApi":{
      "name":"GetRestApi",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}"
      },
      "input":{"shape":"GetRestApiRequest"},
      "output":{"shape":"RestApi"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Lists the <a>RestApi</a> resource in the collection.</p>"
    },
    "GetRestApis":{
      "name":"GetRestApis",
      "http":{
        "method":"GET",
        "requestUri":"/restapis"
      },
      "input":{"shape":"GetRestApisRequest"},
      "output":{"shape":"RestApis"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Lists the <a>RestApis</a> resources for your collection.</p>"
    },
    "GetSdk":{
      "name":"GetSdk",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}",
        "responseCode":200
      },
      "input":{"shape":"GetSdkRequest"},
      "output":{"shape":"SdkResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "GetStage":{
      "name":"GetStage",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}"
      },
      "input":{"shape":"GetStageRequest"},
      "output":{"shape":"Stage"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Gets information about a <a>Stage</a> resource.</p>"
    },
    "GetStages":{
      "name":"GetStages",
      "http":{
        "method":"GET",
        "requestUri":"/restapis/{restapi_id}/stages"
      },
      "input":{"shape":"GetStagesRequest"},
      "output":{"shape":"Stages"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Gets information about one or more <a>Stage</a> resources.</p>"
    },
    "PutIntegration":{
      "name":"PutIntegration",
      "http":{
        "method":"PUT",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
        "responseCode":201
      },
      "input":{"shape":"PutIntegrationRequest"},
      "output":{"shape":"Integration"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a put integration.</p>"
    },
    "PutIntegrationResponse":{
      "name":"PutIntegrationResponse",
      "http":{
        "method":"PUT",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
        "responseCode":201
      },
      "input":{"shape":"PutIntegrationResponseRequest"},
      "output":{"shape":"IntegrationResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"LimitExceededException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents a put integration.</p>"
    },
    "PutMethod":{
      "name":"PutMethod",
      "http":{
        "method":"PUT",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
        "responseCode":201
      },
      "input":{"shape":"PutMethodRequest"},
      "output":{"shape":"Method"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Add a method to an existing <a>Resource</a> resource.</p>"
    },
    "PutMethodResponse":{
      "name":"PutMethodResponse",
      "http":{
        "method":"PUT",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
        "responseCode":201
      },
      "input":{"shape":"PutMethodResponseRequest"},
      "output":{"shape":"MethodResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Adds a <a>MethodResponse</a> to an existing <a>Method</a> resource.</p>"
    },
    "TestInvokeAuthorizer":{
      "name":"TestInvokeAuthorizer",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/authorizers/{authorizer_id}"
      },
      "input":{"shape":"TestInvokeAuthorizerRequest"},
      "output":{"shape":"TestInvokeAuthorizerResponse"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "TestInvokeMethod":{
      "name":"TestInvokeMethod",
      "http":{
        "method":"POST",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}"
      },
      "input":{"shape":"TestInvokeMethodRequest"},
      "output":{"shape":"TestInvokeMethodResponse"},
      "errors":[
        {"shape":"BadRequestException"},
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ]
    },
    "UpdateAccount":{
      "name":"UpdateAccount",
      "http":{
        "method":"PATCH",
        "requestUri":"/account"
      },
      "input":{"shape":"UpdateAccountRequest"},
      "output":{"shape":"Account"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about the current <a>Account</a> resource.</p>"
    },
    "UpdateApiKey":{
      "name":"UpdateApiKey",
      "http":{
        "method":"PATCH",
        "requestUri":"/apikeys/{api_Key}"
      },
      "input":{"shape":"UpdateApiKeyRequest"},
      "output":{"shape":"ApiKey"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about an <a>ApiKey</a> resource.</p>"
    },
    "UpdateAuthorizer":{
      "name":"UpdateAuthorizer",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/authorizers/{authorizer_id}"
      },
      "input":{"shape":"UpdateAuthorizerRequest"},
      "output":{"shape":"Authorizer"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Updates an existing <a>Authorizer</a> resource.</p>"
    },
    "UpdateBasePathMapping":{
      "name":"UpdateBasePathMapping",
      "http":{
        "method":"PATCH",
        "requestUri":"/domainnames/{domain_name}/basepathmappings/{base_path}"
      },
      "input":{"shape":"UpdateBasePathMappingRequest"},
      "output":{"shape":"BasePathMapping"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about the <a>BasePathMapping</a> resource.</p>"
    },
    "UpdateClientCertificate":{
      "name":"UpdateClientCertificate",
      "http":{
        "method":"PATCH",
        "requestUri":"/clientcertificates/{clientcertificate_id}"
      },
      "input":{"shape":"UpdateClientCertificateRequest"},
      "output":{"shape":"ClientCertificate"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"BadRequestException"},
        {"shape":"NotFoundException"}
      ]
    },
    "UpdateDeployment":{
      "name":"UpdateDeployment",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/deployments/{deployment_id}"
      },
      "input":{"shape":"UpdateDeploymentRequest"},
      "output":{"shape":"Deployment"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"},
        {"shape":"ServiceUnavailableException"}
      ],
      "documentation":"<p>Changes information about a <a>Deployment</a> resource.</p>"
    },
    "UpdateDomainName":{
      "name":"UpdateDomainName",
      "http":{
        "method":"PATCH",
        "requestUri":"/domainnames/{domain_name}"
      },
      "input":{"shape":"UpdateDomainNameRequest"},
      "output":{"shape":"DomainName"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about the <a>DomainName</a> resource.</p>"
    },
    "UpdateIntegration":{
      "name":"UpdateIntegration",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration"
      },
      "input":{"shape":"UpdateIntegrationRequest"},
      "output":{"shape":"Integration"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents an update integration.</p>"
    },
    "UpdateIntegrationResponse":{
      "name":"UpdateIntegrationResponse",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}"
      },
      "input":{"shape":"UpdateIntegrationResponseRequest"},
      "output":{"shape":"IntegrationResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Represents an update integration response.</p>"
    },
    "UpdateMethod":{
      "name":"UpdateMethod",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}"
      },
      "input":{"shape":"UpdateMethodRequest"},
      "output":{"shape":"Method"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Updates an existing <a>Method</a> resource.</p>"
    },
    "UpdateMethodResponse":{
      "name":"UpdateMethodResponse",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
        "responseCode":201
      },
      "input":{"shape":"UpdateMethodResponseRequest"},
      "output":{"shape":"MethodResponse"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"LimitExceededException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Updates an existing <a>MethodResponse</a> resource.</p>"
    },
    "UpdateModel":{
      "name":"UpdateModel",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/models/{model_name}"
      },
      "input":{"shape":"UpdateModelRequest"},
      "output":{"shape":"Model"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about a model.</p>"
    },
    "UpdateResource":{
      "name":"UpdateResource",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/resources/{resource_id}"
      },
      "input":{"shape":"UpdateResourceRequest"},
      "output":{"shape":"Resource"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about a <a>Resource</a> resource.</p>"
    },
    "UpdateRestApi":{
      "name":"UpdateRestApi",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}"
      },
      "input":{"shape":"UpdateRestApiRequest"},
      "output":{"shape":"RestApi"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about the specified API.</p>"
    },
    "UpdateStage":{
      "name":"UpdateStage",
      "http":{
        "method":"PATCH",
        "requestUri":"/restapis/{restapi_id}/stages/{stage_name}"
      },
      "input":{"shape":"UpdateStageRequest"},
      "output":{"shape":"Stage"},
      "errors":[
        {"shape":"UnauthorizedException"},
        {"shape":"NotFoundException"},
        {"shape":"ConflictException"},
        {"shape":"BadRequestException"},
        {"shape":"TooManyRequestsException"}
      ],
      "documentation":"<p>Changes information about a <a>Stage</a> resource.</p>"
    }
  },
  "shapes":{
    "Account":{
      "type":"structure",
      "members":{
        "cloudwatchRoleArn":{
          "shape":"String",
          "documentation":"<p>Specifies the Amazon resource name (ARN) of an Amazon CloudWatch role for the current <a>Account</a> resource.</p>"
        },
        "throttleSettings":{
          "shape":"ThrottleSettings",
          "documentation":"<p>Specifies the application programming interface (API) throttle settings for the current <a>Account</a> resource.</p>"
        }
      },
      "documentation":"<p>Represents an AWS account that is associated with Amazon API Gateway.</p>"
    },
    "ApiKey":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The identifier of the API Key.</p>"
        },
        "name":{
          "shape":"String",
          "documentation":"<p>The name of the API Key.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description of the API Key.</p>"
        },
        "enabled":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether the API Key can be used by callers.</p>"
        },
        "stageKeys":{
          "shape":"ListOfString",
          "documentation":"<p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>"
        },
        "createdDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date when the API Key was created, in <a href=\"http://www.iso.org/iso/home/standards/iso8601.htm\" target=\"_blank\">ISO 8601 format</a>.</p>"
        },
        "lastUpdatedDate":{
          "shape":"Timestamp",
          "documentation":"<p>When the API Key was last updated, in ISO 8601 format.</p>"
        }
      },
      "documentation":"<p>A resource that can be distributed to callers for executing <a>Method</a> resources that require an API key. API keys can be mapped to any <a>Stage</a> on any <a>RestApi</a>, which indicates that the callers with the API key can make requests to that stage.</p>"
    },
    "ApiKeys":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfApiKey",
          "documentation":"<p>The current page of any <a>ApiKey</a> resources in the collection of <a>ApiKey</a> resources.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection of <a>ApiKey</a> resources.</p>"
    },
    "Authorizer":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The identifier for the authorizer resource.</p>"
        },
        "name":{
          "shape":"String",
          "documentation":"<p>[Required] The name of the authorizer.</p>"
        },
        "type":{
          "shape":"AuthorizerType",
          "documentation":"<p>[Required] The type of the authorizer. Currently, the only valid type is TOKEN.</p>"
        },
        "authorizerUri":{
          "shape":"String",
          "documentation":"<p>[Required] Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN authorizers, this must be a well-formed Lambda function URI. The URI should be of the form <code>arn:aws:apigateway:{region}:lambda:path/{service_api}</code>. <code>Region</code> is used to determine the right endpoint. In this case, <code>path</code> is used to indicate that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations</p>"
        },
        "authorizerCredentials":{
          "shape":"String",
          "documentation":"<p>Specifies the credentials required for the authorizer, if any. Two options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.</p>"
        },
        "identitySource":{
          "shape":"String",
          "documentation":"<p>[Required] The source of the identity in an incoming request. For TOKEN authorizers, this value is a mapping expression with the same syntax as integration parameter mappings. The only valid source for tokens is 'header', so the expression should match 'method.request.header.[headerName]'. The value of the header '[headerName]' will be interpreted as the incoming token.</p>"
        },
        "identityValidationExpression":{
          "shape":"String",
          "documentation":"<p>A validation expression for the incoming identity. For TOKEN authorizers, this value should be a regular expression. The incoming token from the client is matched against this expression, and will proceed if the token matches. If the token doesn't match, the client receives a 401 Unauthorized response.</p>"
        },
        "authorizerResultTtlInSeconds":{
          "shape":"NullableInteger",
          "documentation":"<p>The TTL in seconds of cached authorizer results. If greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.</p>"
        }
      },
      "documentation":"<p>Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.</p>"
    },
    "AuthorizerType":{
      "type":"string",
      "enum":["TOKEN"]
    },
    "Authorizers":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfAuthorizer",
          "documentation":"<p>Gets the current list of <a>Authorizer</a> resources in the collection.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection of <a>Authorizer</a> resources.</p>"
    },
    "BadRequestException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "BasePathMapping":{
      "type":"structure",
      "members":{
        "basePath":{
          "shape":"String",
          "documentation":"<p>The base path name that callers of the API must provide as part of the URL after the domain name.</p>"
        },
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The name of the API.</p>"
        },
        "stage":{
          "shape":"String",
          "documentation":"<p>The name of the API's stage.</p>"
        }
      },
      "documentation":"<p>Represents the base path that callers of the API that must provide as part of the URL after the domain name.</p>"
    },
    "BasePathMappings":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfBasePathMapping",
          "documentation":"<p>The current page of any <a>BasePathMapping</a> resources in the collection of base path mapping resources.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection of <a>BasePathMapping</a> resources.</p>"
    },
    "Blob":{"type":"blob"},
    "Boolean":{"type":"boolean"},
    "CacheClusterSize":{
      "type":"string",
      "documentation":"<p>Returns the size of the <b>CacheCluster</b>.</p>",
      "enum":[
        "0.5",
        "1.6",
        "6.1",
        "13.5",
        "28.4",
        "58.2",
        "118",
        "237"
      ]
    },
    "CacheClusterStatus":{
      "type":"string",
      "documentation":"<p>Returns the status of the <b>CacheCluster</b>.</p>",
      "enum":[
        "CREATE_IN_PROGRESS",
        "AVAILABLE",
        "DELETE_IN_PROGRESS",
        "NOT_AVAILABLE",
        "FLUSH_IN_PROGRESS"
      ]
    },
    "ClientCertificate":{
      "type":"structure",
      "members":{
        "clientCertificateId":{"shape":"String"},
        "description":{"shape":"String"},
        "pemEncodedCertificate":{"shape":"String"},
        "createdDate":{"shape":"Timestamp"},
        "expirationDate":{"shape":"Timestamp"}
      }
    },
    "ClientCertificates":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfClientCertificate",
          "locationName":"item"
        }
      }
    },
    "ConflictException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "CreateApiKeyRequest":{
      "type":"structure",
      "members":{
        "name":{
          "shape":"String",
          "documentation":"<p>The name of the <a>ApiKey</a>.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description of the <a>ApiKey</a>.</p>"
        },
        "enabled":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether the <a>ApiKey</a> can be used by callers.</p>"
        },
        "stageKeys":{
          "shape":"ListOfStageKeys",
          "documentation":"<p>Specifies whether the <a>ApiKey</a> can be used by callers.</p>"
        }
      }
    },
    "CreateAuthorizerRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "name",
        "type",
        "authorizerUri",
        "identitySource"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "name":{
          "shape":"String",
          "documentation":"<p>[Required] The name of the authorizer.</p>"
        },
        "type":{
          "shape":"AuthorizerType",
          "documentation":"<p>[Required] The type of the authorizer.</p>"
        },
        "authorizerUri":{
          "shape":"String",
          "documentation":"<p>[Required] Specifies the authorizer's Uniform Resource Identifier (URI).</p>"
        },
        "authorizerCredentials":{
          "shape":"String",
          "documentation":"<p>Specifies the credentials required for the authorizer, if any.</p>"
        },
        "identitySource":{
          "shape":"String",
          "documentation":"<p>[Required] The source of the identity in an incoming request.</p>"
        },
        "identityValidationExpression":{
          "shape":"String",
          "documentation":"<p>A validation expression for the incoming identity.</p>"
        },
        "authorizerResultTtlInSeconds":{
          "shape":"NullableInteger",
          "documentation":"<p>The TTL of cached authorizer results.</p>"
        }
      }
    },
    "CreateBasePathMappingRequest":{
      "type":"structure",
      "required":[
        "domainName",
        "restApiId"
      ],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The domain name of the <a>BasePathMapping</a> resource to create.</p>",
          "location":"uri",
          "locationName":"domain_name"
        },
        "basePath":{
          "shape":"String",
          "documentation":"<p>The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Leave this blank if you do not want callers to specify a base path name after the domain name.</p>"
        },
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The name of the API that you want to apply this mapping to.</p>"
        },
        "stage":{
          "shape":"String",
          "documentation":"<p>The name of the API's stage that you want to use for this mapping. Leave this blank if you do not want callers to explicitly specify the stage name after any base path name.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to create a new <a>BasePathMapping</a> resource.</p>"
    },
    "CreateDeploymentRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> resource identifier for the <a>Deployment</a> resource to create.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>Stage</a> resource for the <a>Deployment</a> resource to create.</p>"
        },
        "stageDescription":{
          "shape":"String",
          "documentation":"<p>The description of the <a>Stage</a> resource for the <a>Deployment</a> resource to create.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description for the <a>Deployment</a> resource to create.</p>"
        },
        "cacheClusterEnabled":{
          "shape":"NullableBoolean",
          "documentation":"<p>Enables a cache cluster for the <a>Stage</a> resource specified in the input.</p>"
        },
        "cacheClusterSize":{
          "shape":"CacheClusterSize",
          "documentation":"<p>Specifies the cache cluster size for the <a>Stage</a> resource specified in the input, if a cache cluster is enabled.</p>"
        },
        "variables":{
          "shape":"MapOfStringToString",
          "documentation":"<p>A map that defines the stage variables for the <a>Stage</a> resource that is associated with the new deployment. Variable names can have alphanumeric characters, and the values must match <code>[A-Za-z0-9-._~:/?#&amp;=,]+</code>.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to create a <a>Deployment</a> resource.</p>"
    },
    "CreateDomainNameRequest":{
      "type":"structure",
      "required":[
        "domainName",
        "certificateName",
        "certificateBody",
        "certificatePrivateKey",
        "certificateChain"
      ],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>DomainName</a> resource.</p>"
        },
        "certificateName":{
          "shape":"String",
          "documentation":"<p>The name of the certificate.</p>"
        },
        "certificateBody":{
          "shape":"String",
          "documentation":"<p>The body of the server certificate provided by your certificate authority.</p>"
        },
        "certificatePrivateKey":{
          "shape":"String",
          "documentation":"<p>Your certificate's private key.</p>"
        },
        "certificateChain":{
          "shape":"String",
          "documentation":"<p>The intermediate certificates and optionally the root certificate, one after the other without any blank lines. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.</p>"
        }
      },
      "documentation":"<p>A request to create a new domain name.</p>"
    },
    "CreateModelRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "name",
        "contentType"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier under which the <a>Model</a> will be created.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "name":{
          "shape":"String",
          "documentation":"<p>The name of the model.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description of the model.</p>"
        },
        "schema":{
          "shape":"String",
          "documentation":"<p>The schema for the model. For <code>application/json</code> models, this should be <a href=\"http://json-schema.org/documentation.html\" target=\"_blank\">JSON-schema draft v4</a> model.</p>"
        },
        "contentType":{
          "shape":"String",
          "documentation":"<p>The content-type for the model.</p>"
        }
      },
      "documentation":"<p>Request to add a new <a>Model</a> to an existing <a>RestApi</a> resource.</p>"
    },
    "CreateResourceRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "parentId",
        "pathPart"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> for the resource. </p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "parentId":{
          "shape":"String",
          "documentation":"<p>The parent resource's identifier.</p>",
          "location":"uri",
          "locationName":"parent_id"
        },
        "pathPart":{
          "shape":"String",
          "documentation":"<p>The last path segment for this resource.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to create a <a>Resource</a> resource.</p>"
    },
    "CreateRestApiRequest":{
      "type":"structure",
      "required":["name"],
      "members":{
        "name":{
          "shape":"String",
          "documentation":"<p>The name of the <a>RestApi</a>.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description of the <a>RestApi</a>.</p>"
        },
        "cloneFrom":{
          "shape":"String",
          "documentation":"<p>The Id of the <a>RestApi</a> that you want to clone from.</p>"
        }
      },
      "documentation":"<p>Request to add a new <a>RestApi</a> resource to your collection.</p>"
    },
    "CreateStageRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName",
        "deploymentId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the <a>Stage</a> resource to create.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name for the <a>Stage</a> resource.</p>"
        },
        "deploymentId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Deployment</a> resource for the <a>Stage</a> resource.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description of the <a>Stage</a> resource.</p>"
        },
        "cacheClusterEnabled":{
          "shape":"Boolean",
          "documentation":"<p>Whether cache clustering is enabled for the stage.</p>"
        },
        "cacheClusterSize":{
          "shape":"CacheClusterSize",
          "documentation":"<p>The stage's cache cluster size.</p>"
        },
        "variables":{
          "shape":"MapOfStringToString",
          "documentation":"<p>A map that defines the stage variables for the new <a>Stage</a> resource. Variable names can have alphanumeric characters, and the values must match <code>[A-Za-z0-9-._~:/?#&amp;=,]+</code>.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to create a <a>Stage</a> resource.</p>"
    },
    "DeleteApiKeyRequest":{
      "type":"structure",
      "required":["apiKey"],
      "members":{
        "apiKey":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>ApiKey</a> resource to be deleted.</p>",
          "location":"uri",
          "locationName":"api_Key"
        }
      },
      "documentation":"<p>A request to delete the <a>ApiKey</a> resource.</p>"
    },
    "DeleteAuthorizerRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "authorizerId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Authorizer</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "authorizerId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Authorizer</a> resource.</p>",
          "location":"uri",
          "locationName":"authorizer_id"
        }
      },
      "documentation":"<p>Request to delete an existing <a>Authorizer</a> resource.</p>"
    },
    "DeleteBasePathMappingRequest":{
      "type":"structure",
      "required":[
        "domainName",
        "basePath"
      ],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The domain name of the <a>BasePathMapping</a> resource to delete.</p>",
          "location":"uri",
          "locationName":"domain_name"
        },
        "basePath":{
          "shape":"String",
          "documentation":"<p>The base path name of the <a>BasePathMapping</a> resource to delete.</p>",
          "location":"uri",
          "locationName":"base_path"
        }
      },
      "documentation":"<p>A request to delete the <a>BasePathMapping</a> resource.</p>"
    },
    "DeleteClientCertificateRequest":{
      "type":"structure",
      "required":["clientCertificateId"],
      "members":{
        "clientCertificateId":{
          "shape":"String",
          "location":"uri",
          "locationName":"clientcertificate_id"
        }
      }
    },
    "DeleteDeploymentRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "deploymentId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the <a>Deployment</a> resource to delete.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "deploymentId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Deployment</a> resource to delete.</p>",
          "location":"uri",
          "locationName":"deployment_id"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to delete a <a>Deployment</a> resource.</p>"
    },
    "DeleteDomainNameRequest":{
      "type":"structure",
      "required":["domainName"],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>DomainName</a> resource to be deleted.</p>",
          "location":"uri",
          "locationName":"domain_name"
        }
      },
      "documentation":"<p>A request to delete the <a>DomainName</a> resource.</p>"
    },
    "DeleteIntegrationRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies a delete integration request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies a delete integration request's resource identifier.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a delete integration request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        }
      },
      "documentation":"<p>Represents a delete integration request.</p>"
    },
    "DeleteIntegrationResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies a delete integration response request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies a delete integration response request's resource identifier.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a delete integration response request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>Specifies a delete integration response request's status code.</p>",
          "location":"uri",
          "locationName":"status_code"
        }
      },
      "documentation":"<p>Represents a delete integration response request.</p>"
    },
    "DeleteMethodRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP verb that identifies the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"http_method"
        }
      },
      "documentation":"<p>Request to delete an existing <a>Method</a> resource.</p>"
    },
    "DeleteMethodResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP verb identifier for the parent <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>The status code identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"status_code"
        }
      },
      "documentation":"<p>A request to delete an existing <a>MethodResponse</a> resource.</p>"
    },
    "DeleteModelRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "modelName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> under which the model will be deleted.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "modelName":{
          "shape":"String",
          "documentation":"<p>The name of the model to delete.</p>",
          "location":"uri",
          "locationName":"model_name"
        }
      },
      "documentation":"<p>Request to delete an existing model in an existing <a>RestApi</a> resource.</p>"
    },
    "DeleteResourceRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Resource</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Resource</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        }
      },
      "documentation":"<p>Request to delete a <a>Resource</a>.</p>"
    },
    "DeleteRestApiRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The ID of the <a>RestApi</a> you want to delete.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        }
      },
      "documentation":"<p>Request to delete the specified API from your collection.</p>"
    },
    "DeleteStageRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the <a>Stage</a> resource to delete.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>Stage</a> resource to delete.</p>",
          "location":"uri",
          "locationName":"stage_name"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to delete a <a>Stage</a> resource.</p>"
    },
    "Deployment":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The identifier for the deployment resource.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description for the deployment resource.</p>"
        },
        "createdDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date and time that the deployment resource was created.</p>"
        },
        "apiSummary":{
          "shape":"PathToMapOfMethodSnapshot",
          "documentation":"<p>Gets a summary of the <a>RestApi</a> at the date and time that the deployment resource was created.</p>"
        }
      },
      "documentation":"<p>An immutable representation of a <a>RestApi</a> resource that can be called by users using <a>Stages</a>. A deployment must be associated with a <a>Stage</a> for it to be callable over the Internet.</p>"
    },
    "Deployments":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfDeployment",
          "documentation":"<p>The current page of any <a>Deployment</a> resources in the collection of deployment resources.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection resource that contains zero or more references to your existing deployments, and links that guide you on ways to interact with your collection. The collection offers a paginated view of the contained deployments.</p>"
    },
    "DomainName":{
      "type":"structure",
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>DomainName</a> resource.</p>"
        },
        "certificateName":{
          "shape":"String",
          "documentation":"<p>The name of the certificate.</p>"
        },
        "certificateUploadDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date when the certificate was uploaded, in <a href=\"http://www.iso.org/iso/home/standards/iso8601.htm\" target=\"_blank\">ISO 8601 format</a>.</p>"
        },
        "distributionDomainName":{
          "shape":"String",
          "documentation":"<p>The domain name of the Amazon CloudFront distribution. For more information, see the <a href=\"http://aws.amazon.com/documentation/cloudfront/\" target=\"_blank\">Amazon CloudFront documentation</a>.</p>"
        }
      },
      "documentation":"<p>Represents a domain name that is contained in a simpler, more intuitive URL that can be called.</p>"
    },
    "DomainNames":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfDomainName",
          "documentation":"<p>The current page of any <a>DomainName</a> resources in the collection of <a>DomainName</a> resources.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection of <a>DomainName</a> resources.</p>"
    },
    "Double":{"type":"double"},
    "ExportResponse":{
      "type":"structure",
      "members":{
        "contentType":{
          "shape":"String",
          "location":"header",
          "locationName":"Content-Type"
        },
        "contentDisposition":{
          "shape":"String",
          "location":"header",
          "locationName":"Content-Disposition"
        },
        "body":{"shape":"Blob"}
      },
      "payload":"body"
    },
    "FlushStageAuthorizersCacheRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The API identifier of the stage to flush.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the stage to flush.</p>",
          "location":"uri",
          "locationName":"stage_name"
        }
      },
      "documentation":"<p>Request to flush authorizer cache entries on a specified stage.</p>"
    },
    "FlushStageCacheRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The API identifier of the stage to flush its cache.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the stage to flush its cache.</p>",
          "location":"uri",
          "locationName":"stage_name"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to flush a stage's cache.</p>"
    },
    "GenerateClientCertificateRequest":{
      "type":"structure",
      "members":{
        "description":{"shape":"String"}
      }
    },
    "GetAccountRequest":{
      "type":"structure",
      "members":{
      },
      "documentation":"<p>Requests Amazon API Gateway to get information about the current <a>Account</a> resource.</p>"
    },
    "GetApiKeyRequest":{
      "type":"structure",
      "required":["apiKey"],
      "members":{
        "apiKey":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>ApiKey</a> resource.</p>",
          "location":"uri",
          "locationName":"api_Key"
        }
      },
      "documentation":"<p>A request to get information about the current <a>ApiKey</a> resource.</p>"
    },
    "GetApiKeysRequest":{
      "type":"structure",
      "members":{
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the current <a>ApiKeys</a> resource to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of <a>ApiKeys</a> to get information about.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>A request to get information about the current <a>ApiKeys</a> resource.</p>"
    },
    "GetAuthorizerRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "authorizerId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Authorizer</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "authorizerId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Authorizer</a> resource.</p>",
          "location":"uri",
          "locationName":"authorizer_id"
        }
      },
      "documentation":"<p>Request to describe an existing <a>Authorizer</a> resource.</p>"
    },
    "GetAuthorizersRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Authorizers</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "position":{
          "shape":"String",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>Request to describe an existing <a>Authorizers</a> resource.</p>"
    },
    "GetBasePathMappingRequest":{
      "type":"structure",
      "required":[
        "domainName",
        "basePath"
      ],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The domain name of the <a>BasePathMapping</a> resource to be described.</p>",
          "location":"uri",
          "locationName":"domain_name"
        },
        "basePath":{
          "shape":"String",
          "documentation":"<p>The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Leave this blank if you do not want callers to specify any base path name after the domain name.</p>",
          "location":"uri",
          "locationName":"base_path"
        }
      },
      "documentation":"<p>Request to describe a <a>BasePathMapping</a> resource.</p>"
    },
    "GetBasePathMappingsRequest":{
      "type":"structure",
      "required":["domainName"],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The domain name of a <a>BasePathMapping</a> resource.</p>",
          "location":"uri",
          "locationName":"domain_name"
        },
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the current <a>BasePathMapping</a> resource in the collection to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of <a>BasePathMapping</a> resources in the collection to get information about. The default limit is 25. It should be an integer between 1 - 500.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>A request to get information about a collection of <a>BasePathMapping</a> resources.</p>"
    },
    "GetClientCertificateRequest":{
      "type":"structure",
      "required":["clientCertificateId"],
      "members":{
        "clientCertificateId":{
          "shape":"String",
          "location":"uri",
          "locationName":"clientcertificate_id"
        }
      }
    },
    "GetClientCertificatesRequest":{
      "type":"structure",
      "members":{
        "position":{
          "shape":"String",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "location":"querystring",
          "locationName":"limit"
        }
      }
    },
    "GetDeploymentRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "deploymentId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the <a>Deployment</a> resource to get information about.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "deploymentId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Deployment</a> resource to get information about.</p>",
          "location":"uri",
          "locationName":"deployment_id"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to get information about a <a>Deployment</a> resource.</p>"
    },
    "GetDeploymentsRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the collection of <a>Deployment</a> resources to get information about.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the current <a>Deployment</a> resource in the collection to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of <a>Deployment</a> resources in the collection to get information about. The default limit is 25. It should be an integer between 1 - 500.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to get information about a <a>Deployments</a> collection.</p>"
    },
    "GetDomainNameRequest":{
      "type":"structure",
      "required":["domainName"],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>DomainName</a> resource.</p>",
          "location":"uri",
          "locationName":"domain_name"
        }
      },
      "documentation":"<p>Request to get the name of a <a>DomainName</a> resource.</p>"
    },
    "GetDomainNamesRequest":{
      "type":"structure",
      "members":{
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the current domain names to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of <a>DomainName</a> resources in the collection to get information about. The default limit is 25. It should be an integer between 1 - 500.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>Request to describe a collection of <a>DomainName</a> resources.</p>"
    },
    "GetExportRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName",
        "exportType"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "location":"uri",
          "locationName":"stage_name"
        },
        "exportType":{
          "shape":"String",
          "location":"uri",
          "locationName":"export_type"
        },
        "parameters":{
          "shape":"MapOfStringToString",
          "location":"querystring"
        },
        "accepts":{
          "shape":"String",
          "location":"header",
          "locationName":"Accept"
        }
      }
    },
    "GetIntegrationRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies a get integration request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies a get integration request's resource identifier</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a get integration request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        }
      },
      "documentation":"<p>Represents a get integration request.</p>"
    },
    "GetIntegrationResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies a get integration response request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies a get integration response request's resource identifier.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a get integration response request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>Specifies a get integration response request's status code.</p>",
          "location":"uri",
          "locationName":"status_code"
        }
      },
      "documentation":"<p>Represents a get integration response request.</p>"
    },
    "GetMethodRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies the put method request's HTTP method type.</p>",
          "location":"uri",
          "locationName":"http_method"
        }
      },
      "documentation":"<p>Request to describe an existing <a>Method</a> resource.</p>"
    },
    "GetMethodResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP verb identifier for the parent <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>The status code identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"status_code"
        }
      },
      "documentation":"<p>Request to describe a <a>MethodResponse</a> resource.</p>"
    },
    "GetModelRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "modelName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier under which the <a>Model</a> exists.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "modelName":{
          "shape":"String",
          "documentation":"<p>The name of the model as an identifier.</p>",
          "location":"uri",
          "locationName":"model_name"
        },
        "flatten":{
          "shape":"Boolean",
          "documentation":"<p>Resolves all external model references and returns a flattened model schema.</p>",
          "location":"querystring",
          "locationName":"flatten"
        }
      },
      "documentation":"<p>Request to list information about a model in an existing <a>RestApi</a> resource.</p>"
    },
    "GetModelTemplateRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "modelName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The ID of the <a>RestApi</a> under which the model exists.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "modelName":{
          "shape":"String",
          "documentation":"<p>The name of the model for which to generate a template.</p>",
          "location":"uri",
          "locationName":"model_name"
        }
      },
      "documentation":"<p>Request to generate a sample mapping template used to transform the payload.</p>"
    },
    "GetModelsRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the next set of results in the <a>Models</a> resource to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of models in the collection to get information about. The default limit is 25. It should be an integer between 1 - 500.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>Request to list existing <a>Models</a> defined for a <a>RestApi</a> resource.</p>"
    },
    "GetResourceRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The identifier for the <a>Resource</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        }
      },
      "documentation":"<p>Request to list information about a resource.</p>"
    },
    "GetResourcesRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the Resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the next set of results in the current <a>Resources</a> resource to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of <a>Resource</a> resources in the collection to get information about. The default limit is 25. It should be an integer between 1 - 500.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>Request to list information about a collection of resources.</p>"
    },
    "GetRestApiRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        }
      },
      "documentation":"<p>Request to list an existing <a>RestApi</a> defined for your collection. </p>"
    },
    "GetRestApisRequest":{
      "type":"structure",
      "members":{
        "position":{
          "shape":"String",
          "documentation":"<p>The position of the current <a>RestApis</a> resource in the collection to get information about.</p>",
          "location":"querystring",
          "locationName":"position"
        },
        "limit":{
          "shape":"NullableInteger",
          "documentation":"<p>The maximum number of <a>RestApi</a> resources in the collection to get information about. The default limit is 25. It should be an integer between 1 - 500.</p>",
          "location":"querystring",
          "locationName":"limit"
        }
      },
      "documentation":"<p>Request to list existing <a>RestApis</a> defined for your collection.</p>"
    },
    "GetSdkRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName",
        "sdkType"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "location":"uri",
          "locationName":"stage_name"
        },
        "sdkType":{
          "shape":"String",
          "location":"uri",
          "locationName":"sdk_type"
        },
        "parameters":{
          "shape":"MapOfStringToString",
          "location":"querystring"
        }
      }
    },
    "GetStageRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the <a>Stage</a> resource to get information about.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>Stage</a> resource to get information about.</p>",
          "location":"uri",
          "locationName":"stage_name"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to get information about a <a>Stage</a> resource.</p>"
    },
    "GetStagesRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The stages' API identifiers.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "deploymentId":{
          "shape":"String",
          "documentation":"<p>The stages' deployment identifiers.</p>",
          "location":"querystring",
          "locationName":"deploymentId"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to get information about one or more <a>Stage</a> resources.</p>"
    },
    "Integer":{"type":"integer"},
    "Integration":{
      "type":"structure",
      "members":{
        "type":{
          "shape":"IntegrationType",
          "documentation":"<p>Specifies the integration's type.</p>"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies the integration's HTTP method type.</p>"
        },
        "uri":{
          "shape":"String",
          "documentation":"<p>Specifies the integration's Uniform Resource Identifier (URI). For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the <a href=\"https://www.ietf.org/rfc/rfc3986.txt\" target=\"_blank\">RFC-3986 specification</a>. For AWS integrations, the URI should be of the form <code>arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}</code>. <code>Region</code>, <code>subdomain</code> and <code>service</code> are used to determine the right endpoint. For AWS services that use the <code>Action=</code> query string parameter, <code>service_api</code> should be a valid action for the desired service. For RESTful AWS service APIs, <code>path</code> is used to indicate that the remaining substring in the URI should be treated as the path to the resource, including the initial <code>/</code>.</p>"
        },
        "credentials":{
          "shape":"String",
          "documentation":"<p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string <code>arn:aws:iam::\\*:user/\\*</code>. To use resource-based permissions on supported AWS services, specify null.</p>"
        },
        "requestParameters":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Represents requests parameters that are sent with the backend request. Request parameters are represented as a key/value map, with a destination as the key and a source as the value. A source must match an existing method request parameter, or a static value. Static values must be enclosed with single quotes, and be pre-encoded based on their destination in the request. The destination must match the pattern <code>integration.request.{location}.{name}</code>, where <code>location</code> is either querystring, path, or header. <code>name</code> must be a valid, unique parameter name.</p>"
        },
        "requestTemplates":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the integration's request templates.</p>"
        },
        "cacheNamespace":{
          "shape":"String",
          "documentation":"<p>Specifies the integration's cache namespace.</p>"
        },
        "cacheKeyParameters":{
          "shape":"ListOfString",
          "documentation":"<p>Specifies the integration's cache key parameters.</p>"
        },
        "integrationResponses":{
          "shape":"MapOfIntegrationResponse",
          "documentation":"<p>Specifies the integration's responses.</p>"
        }
      },
      "documentation":"<p>Represents a HTTP, AWS, or Mock integration.</p>"
    },
    "IntegrationResponse":{
      "type":"structure",
      "members":{
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>"
        },
        "selectionPattern":{
          "shape":"String",
          "documentation":"<p>Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the backend. If the backend is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS backends, the HTTP status code is matched.</p>"
        },
        "responseParameters":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Represents response parameters that can be read from the backend response. Response parameters are represented as a key/value map, with a destination as the key and a source as the value. A destination must match an existing response parameter in the <a>MethodResponse</a>. The source can be a header from the backend response, or a static value. Static values are specified using enclosing single quotes, and backend response headers can be read using the pattern <code>integration.response.header.{name}</code>.</p>"
        },
        "responseTemplates":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>"
        }
      },
      "documentation":"<p>Represents an integration response. The status code must map to an existing <a>MethodResponse</a>, and parameters and templates can be used to transform the backend response.</p>"
    },
    "IntegrationType":{
      "type":"string",
      "documentation":"<p>The integration type. Possible values are HTTP, AWS, or Mock.</p>",
      "enum":[
        "HTTP",
        "AWS",
        "MOCK"
      ]
    },
    "LimitExceededException":{
      "type":"structure",
      "members":{
        "retryAfterSeconds":{
          "shape":"String",
          "location":"header",
          "locationName":"Retry-After"
        },
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":429},
      "exception":true
    },
    "ListOfApiKey":{
      "type":"list",
      "member":{"shape":"ApiKey"}
    },
    "ListOfAuthorizer":{
      "type":"list",
      "member":{"shape":"Authorizer"}
    },
    "ListOfBasePathMapping":{
      "type":"list",
      "member":{"shape":"BasePathMapping"}
    },
    "ListOfClientCertificate":{
      "type":"list",
      "member":{"shape":"ClientCertificate"}
    },
    "ListOfDeployment":{
      "type":"list",
      "member":{"shape":"Deployment"}
    },
    "ListOfDomainName":{
      "type":"list",
      "member":{"shape":"DomainName"}
    },
    "ListOfModel":{
      "type":"list",
      "member":{"shape":"Model"}
    },
    "ListOfPatchOperation":{
      "type":"list",
      "member":{"shape":"PatchOperation"},
      "documentation":"A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list."
    },
    "ListOfResource":{
      "type":"list",
      "member":{"shape":"Resource"}
    },
    "ListOfRestApi":{
      "type":"list",
      "member":{"shape":"RestApi"}
    },
    "ListOfStage":{
      "type":"list",
      "member":{"shape":"Stage"}
    },
    "ListOfStageKeys":{
      "type":"list",
      "member":{"shape":"StageKey"}
    },
    "ListOfString":{
      "type":"list",
      "member":{"shape":"String"}
    },
    "Long":{"type":"long"},
    "MapOfHeaderValues":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"String"}
    },
    "MapOfIntegrationResponse":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"IntegrationResponse"}
    },
    "MapOfMethod":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"Method"}
    },
    "MapOfMethodResponse":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"MethodResponse"}
    },
    "MapOfMethodSettings":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"MethodSetting"}
    },
    "MapOfMethodSnapshot":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"MethodSnapshot"}
    },
    "MapOfStringToBoolean":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"NullableBoolean"}
    },
    "MapOfStringToList":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"ListOfString"}
    },
    "MapOfStringToString":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"String"}
    },
    "Method":{
      "type":"structure",
      "members":{
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP method.</p>"
        },
        "authorizationType":{
          "shape":"String",
          "documentation":"<p>The method's authorization type.</p>"
        },
        "authorizerId":{
          "shape":"String",
          "documentation":"<p>Specifies the identifier of an <a>Authorizer</a> to use on this Method. The authorizationType must be CUSTOM.</p>"
        },
        "apiKeyRequired":{
          "shape":"NullableBoolean",
          "documentation":"<p>Specifies whether the method requires a valid <a>ApiKey</a>.</p>"
        },
        "requestParameters":{
          "shape":"MapOfStringToBoolean",
          "documentation":"<p>Represents request parameters that can be accepted by Amazon API Gateway. Request parameters are represented as a key/value map, with a source as the key and a Boolean flag as the value. The Boolean flag is used to specify whether the parameter is required. A source must match the pattern <code>method.request.{location}.{name}</code>, where <code>location</code> is either querystring, path, or header. <code>name</code> is a valid, unique parameter name. Sources specified here are available to the integration for mapping to integration request parameters or templates.</p>"
        },
        "requestModels":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the <a>Model</a> resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a <a>Model</a> name as the value.</p>"
        },
        "methodResponses":{
          "shape":"MapOfMethodResponse",
          "documentation":"<p>Represents available responses that can be sent to the caller. Method responses are represented as a key/value map, with an HTTP status code as the key and a <a>MethodResponse</a> as the value. The status codes are available for the <a>Integration</a> responses to map to.</p>"
        },
        "methodIntegration":{
          "shape":"Integration",
          "documentation":"<p>The method's integration.</p>"
        }
      },
      "documentation":"<p>Represents a method.</p>"
    },
    "MethodResponse":{
      "type":"structure",
      "members":{
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>The method response's status code.</p>"
        },
        "responseParameters":{
          "shape":"MapOfStringToBoolean",
          "documentation":"<p>Represents response parameters that can be sent back to the caller by Amazon API Gateway. Response parameters are represented as a key/value map, with a destination as the key and a boolean flag as the value, which is used to specify whether the parameter is required. A destination must match the pattern <code>method.response.header.{name}</code>, where <code>name</code> is a valid, unique header name. Destinations specified here are available to the integration for mapping from integration response parameters.</p>"
        },
        "responseModels":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the <a>Model</a> resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a <a>Model</a> name as the value.</p>"
        }
      },
      "documentation":"<p>Represents a method response. Amazon API Gateway sends back the status code to the caller as the HTTP status code. Parameters and models can be used to transform the response from the method's integration.</p>"
    },
    "MethodSetting":{
      "type":"structure",
      "members":{
        "metricsEnabled":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether Amazon CloudWatch metrics are enabled for this method. The PATCH path for this setting is <code>/{method_setting_key}/metrics/enabled</code>, and the value is a Boolean.</p>"
        },
        "loggingLevel":{
          "shape":"String",
          "documentation":"<p>Specifies the logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. The PATCH path for this setting is <code>/{method_setting_key}/logging/loglevel</code>, and the available levels are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>.</p>"
        },
        "dataTraceEnabled":{
          "shape":"Boolean",
          "documentation":"<p>Specifies the whether data trace logging is enabled for this method, which effects the log entries pushed to Amazon CloudWatch Logs. The PATCH path for this setting is <code>/{method_setting_key}/logging/dataTrace</code>, and the value is a Boolean.</p>"
        },
        "throttlingBurstLimit":{
          "shape":"Integer",
          "documentation":"<p>Specifies the throttling burst limit. The PATCH path for this setting is <code>/{method_setting_key}/throttling/burstLimit</code>, and the value is an integer.</p>"
        },
        "throttlingRateLimit":{
          "shape":"Double",
          "documentation":"<p>Specifies the throttling rate limit. The PATCH path for this setting is <code>/{method_setting_key}/throttling/rateLimit</code>, and the value is a double.</p>"
        },
        "cachingEnabled":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. The PATCH path for this setting is <code>/{method_setting_key}/caching/enabled</code>, and the value is a Boolean.</p>"
        },
        "cacheTtlInSeconds":{
          "shape":"Integer",
          "documentation":"<p>Specifies the time to live (TTL) in seconds, for cached responses. The higher a the TTL, the longer the response will be cached. The PATCH path for this setting is <code>/{method_setting_key}/caching/ttlInSeconds</code>, and the value is an integer.</p>"
        },
        "cacheDataEncrypted":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether the cached responses are encrypted. The PATCH path for this setting is <code>/{method_setting_key}/caching/dataEncrypted</code>, and the value is a Boolean.</p>"
        },
        "requireAuthorizationForCacheControl":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether authorization is required for a cache invalidation request. The PATCH path for this setting is <code>/{method_setting_key}/caching/requireAuthorizationForCacheControl</code>, and the value is a Boolean.</p>"
        },
        "unauthorizedCacheControlHeaderStrategy":{
          "shape":"UnauthorizedCacheControlHeaderStrategy",
          "documentation":"<p>Specifies the strategy on how to handle the unauthorized requests for cache invalidation. The PATCH path for this setting is <code>/{method_setting_key}/caching/unauthorizedCacheControlHeaderStrategy</code>, and the available values are <code>FAIL_WITH_403</code>, <code>SUCCEED_WITH_RESPONSE_HEADER</code>, <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code>.</p>"
        }
      },
      "documentation":"<p>Specifies the method setting properties.</p>"
    },
    "MethodSnapshot":{
      "type":"structure",
      "members":{
        "authorizationType":{
          "shape":"String",
          "documentation":"<p>Specifies the type of authorization used for the method.</p>"
        },
        "apiKeyRequired":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether the method requires a valid <a>ApiKey</a>.</p>"
        }
      },
      "documentation":"<p>Represents a summary of a <a>Method</a> resource, given a particular date and time.</p>"
    },
    "Model":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The identifier for the model resource.</p>"
        },
        "name":{
          "shape":"String",
          "documentation":"<p>The name of the model.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The description of the model.</p>"
        },
        "schema":{
          "shape":"String",
          "documentation":"<p>The schema for the model. For <code>application/json</code> models, this should be <a href=\"http://json-schema.org/documentation.html\" target=\"_blank\">JSON-schema draft v4</a> model.</p>"
        },
        "contentType":{
          "shape":"String",
          "documentation":"<p>The content-type for the model.</p>"
        }
      },
      "documentation":"<p>Represents the structure of a request or response payload for a method.</p>"
    },
    "Models":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfModel",
          "documentation":"<p>Gets the current <a>Model</a> resource in the collection.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection of <a>Model</a> resources.</p>"
    },
    "NotFoundException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":404},
      "exception":true
    },
    "NullableBoolean":{"type":"boolean"},
    "NullableInteger":{"type":"integer"},
    "PatchOperation":{
      "type":"structure",
      "members":{
        "op":{
          "shape":"op",
          "documentation":"<p>A patch operation whose value indicates the operation to perform. Its value MUST be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors. </p>"
        },
        "path":{
          "shape":"String",
          "documentation":"<p>Operation objects MUST have exactly one \"path\" member. That member's value is a string containing a `JSON-Pointer` value that references a location within the target document (the \"target location\") where the operation is performed.</p>"
        },
        "value":{
          "shape":"String",
          "documentation":"<p>The actual value content. </p>"
        },
        "from":{
          "shape":"String",
          "documentation":"<p>The \"move\" and \"copy\" operation object MUST contain a \"from\" member, which is a string containing a <code>JSON Pointer</code> value that references the location in the target document to move the value from.</p>"
        }
      },
      "documentation":"A single patch operation to apply to the specified resource. Please refer to http://tools.ietf.org/html/rfc6902#section-4 for an explanation of how each operation is used."
    },
    "PathToMapOfMethodSnapshot":{
      "type":"map",
      "key":{"shape":"String"},
      "value":{"shape":"MapOfMethodSnapshot"}
    },
    "PutIntegrationRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "type"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration request's resource ID.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "type":{
          "shape":"IntegrationType",
          "documentation":"<p>Specifies a put integration input's type.</p>"
        },
        "integrationHttpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration HTTP method. When the integration type is HTTP or AWS, this field is required.</p>",
          "locationName":"httpMethod"
        },
        "uri":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration input's Uniform Resource Identifier (URI). When the integration type is HTTP or AWS, this field is required.</p>"
        },
        "credentials":{
          "shape":"String",
          "documentation":"<p>Specifies whether credentials are required for a put integration.</p>"
        },
        "requestParameters":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Represents request parameters that are sent with the backend request. Request parameters are represented as a key/value map, with a destination as the key and a source as the value. A source must match an existing method request parameter, or a static value. Static values must be enclosed with single quotes, and be pre-encoded based on their destination in the request. The destination must match the pattern <code>integration.request.{location}.{name}</code>, where <code>location</code> is either querystring, path, or header. <code>name</code> must be a valid, unique parameter name.</p>"
        },
        "requestTemplates":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the templates used to transform the method request body. Request templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>"
        },
        "cacheNamespace":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration input's cache namespace.</p>"
        },
        "cacheKeyParameters":{
          "shape":"ListOfString",
          "documentation":"<p>Specifies a put integration input's cache key parameters.</p>"
        }
      },
      "documentation":"<p>Represents a put integration request.</p>"
    },
    "PutIntegrationResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration response request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration response request's resource identifier.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies a put integration response request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>Specifies the status code that is used to map the integration response to an existing <a>MethodResponse</a>.</p>",
          "location":"uri",
          "locationName":"status_code"
        },
        "selectionPattern":{
          "shape":"String",
          "documentation":"<p>Specifies the selection pattern of a put integration response.</p>"
        },
        "responseParameters":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Represents response parameters that can be read from the backend response. Response parameters are represented as a key/value map, with a destination as the key and a source as the value. A destination must match an existing response parameter in the <a>Method</a>. The source can be a header from the backend response, or a static value. Static values are specified using enclosing single quotes, and backend response headers can be read using the pattern <code>integration.response.header.{name}</code>.</p>"
        },
        "responseTemplates":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies a put integration response's templates.</p>"
        }
      },
      "documentation":"<p>Represents a put integration response request.</p>"
    },
    "PutMethodRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "authorizationType"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the new <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the new <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies the put method request's HTTP method type.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "authorizationType":{
          "shape":"String",
          "documentation":"<p>Specifies the type of authorization used for the method.</p>"
        },
        "authorizerId":{
          "shape":"String",
          "documentation":"<p>Specifies the identifier of an <a>Authorizer</a> to use on this Method, if the type is CUSTOM.</p>"
        },
        "apiKeyRequired":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether the method required a valid <a>ApiKey</a>.</p>"
        },
        "requestParameters":{
          "shape":"MapOfStringToBoolean",
          "documentation":"<p>Represents requests parameters that are sent with the backend request. Request parameters are represented as a key/value map, with a destination as the key and a source as the value. A source must match an existing method request parameter, or a static value. Static values must be enclosed with single quotes, and be pre-encoded based on their destination in the request. The destination must match the pattern <code>integration.request.{location}.{name}</code>, where <code>location</code> is either querystring, path, or header. <code>name</code> must be a valid, unique parameter name.</p>"
        },
        "requestModels":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the <a>Model</a> resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a <a>Model</a> name as the value.</p>"
        }
      },
      "documentation":"<p>Request to add a method to an existing <a>Resource</a> resource.</p>"
    },
    "PutMethodResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP verb that identifies the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>The method response's status code.</p>",
          "location":"uri",
          "locationName":"status_code"
        },
        "responseParameters":{
          "shape":"MapOfStringToBoolean",
          "documentation":"<p>Represents response parameters that can be sent back to the caller by Amazon API Gateway. Response parameters are represented as a key/value map, with a destination as the key and a Boolean flag as the value. The Boolean flag is used to specify whether the parameter is required. A destination must match the pattern <code>method.response.header.{name}</code>, where <code>name</code> is a valid, unique header name. Destinations specified here are available to the integration for mapping from integration response parameters.</p>"
        },
        "responseModels":{
          "shape":"MapOfStringToString",
          "documentation":"<p>Specifies the <a>Model</a> resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a <a>Model</a> name as the value.</p>"
        }
      },
      "documentation":"<p>Request to add a <a>MethodResponse</a> to an existing <a>Method</a> resource.</p>"
    },
    "Resource":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The resource's identifier.</p>"
        },
        "parentId":{
          "shape":"String",
          "documentation":"<p>The parent resource's identifier.</p>"
        },
        "pathPart":{
          "shape":"String",
          "documentation":"<p>The last path segment for this resource.</p>"
        },
        "path":{
          "shape":"String",
          "documentation":"<p>The full path for this resource.</p>"
        },
        "resourceMethods":{
          "shape":"MapOfMethod",
          "documentation":"<p>Map of methods for this resource, which is included only if requested using the <b>embed</b> option.</p>"
        }
      },
      "documentation":"<p>Represents a resource.</p>"
    },
    "Resources":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfResource",
          "documentation":"<p>Gets the current <a>Resource</a> resource in the collection.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Represents a collection of <a>Resource</a> resources.</p>"
    },
    "RestApi":{
      "type":"structure",
      "members":{
        "id":{
          "shape":"String",
          "documentation":"<p>The API's identifier. This identifier is unique across all of your APIs in Amazon API Gateway.</p>"
        },
        "name":{
          "shape":"String",
          "documentation":"<p>The API's name.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The API's description.</p>"
        },
        "createdDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date when the API was created, in <a href=\"http://www.iso.org/iso/home/standards/iso8601.htm\" target=\"_blank\">ISO 8601 format</a>.</p>"
        }
      },
      "documentation":"<p>Represents a REST API.</p>"
    },
    "RestApis":{
      "type":"structure",
      "members":{
        "position":{"shape":"String"},
        "items":{
          "shape":"ListOfRestApi",
          "documentation":"<p>An array of links to the current page of <a>RestApi</a> resources.</p>",
          "locationName":"item"
        }
      },
      "documentation":"<p>Contains references to your APIs and links that guide you in ways to interact with your collection. A collection offers a paginated view of your APIs.</p>"
    },
    "SdkResponse":{
      "type":"structure",
      "members":{
        "contentType":{
          "shape":"String",
          "location":"header",
          "locationName":"Content-Type"
        },
        "contentDisposition":{
          "shape":"String",
          "location":"header",
          "locationName":"Content-Disposition"
        },
        "body":{"shape":"Blob"}
      },
      "payload":"body"
    },
    "ServiceUnavailableException":{
      "type":"structure",
      "members":{
        "retryAfterSeconds":{
          "shape":"String",
          "location":"header",
          "locationName":"Retry-After"
        },
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":503},
      "exception":true,
      "fault":true
    },
    "Stage":{
      "type":"structure",
      "members":{
        "deploymentId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Deployment</a> that the stage points to.</p>"
        },
        "clientCertificateId":{"shape":"String"},
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to Amazon API Gateway.</p>"
        },
        "description":{
          "shape":"String",
          "documentation":"<p>The stage's description.</p>"
        },
        "cacheClusterEnabled":{
          "shape":"Boolean",
          "documentation":"<p>Specifies whether a cache cluster is enabled for the stage.</p>"
        },
        "cacheClusterSize":{
          "shape":"CacheClusterSize",
          "documentation":"<p>The size of the cache cluster for the stage, if enabled.</p>"
        },
        "cacheClusterStatus":{
          "shape":"CacheClusterStatus",
          "documentation":"<p>The status of the cache cluster for the stage, if enabled.</p>"
        },
        "methodSettings":{
          "shape":"MapOfMethodSettings",
          "documentation":"<p>A map that defines the method settings for a <a>Stage</a> resource. Keys are defined as <code>{resource_path}/{http_method}</code> for an individual method override, or <code>\\*/\\*</code> for the settings applied to all methods in the stage.</p>"
        },
        "variables":{
          "shape":"MapOfStringToString",
          "documentation":"<p>A map that defines the stage variables for a <a>Stage</a> resource. Variable names can have alphanumeric characters, and the values must match <code>[A-Za-z0-9-._~:/?#&amp;=,]+</code>.</p>"
        },
        "createdDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date and time that the stage was created, in <a href=\"http://www.iso.org/iso/home/standards/iso8601.htm\" target=\"_blank\">ISO 8601 format</a>.</p>"
        },
        "lastUpdatedDate":{
          "shape":"Timestamp",
          "documentation":"<p>The date and time that information about the stage was last updated, in <a href=\"http://www.iso.org/iso/home/standards/iso8601.htm\" target=\"_blank\">ISO 8601 format</a>.</p>"
        }
      },
      "documentation":"<p>Represents a unique identifier for a version of a deployed <a>RestApi</a> that is callable by users.</p>"
    },
    "StageKey":{
      "type":"structure",
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>A list of <a>Stage</a> resources that are associated with the <a>ApiKey</a> resource.</p>"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The stage name in the <a>RestApi</a> that the stage key references.</p>"
        }
      },
      "documentation":"<p>A reference to a unique stage identified in the format <code>{restApiId}/{stage}</code>.</p>"
    },
    "Stages":{
      "type":"structure",
      "members":{
        "item":{
          "shape":"ListOfStage",
          "documentation":"<p>An individual <a>Stage</a> resource.</p>"
        }
      },
      "documentation":"<p>A list of <a>Stage</a> resource that are associated with the <a>ApiKey</a> resource.</p>"
    },
    "StatusCode":{
      "type":"string",
      "documentation":"<p>The status code.</p>",
      "pattern":"[1-5]\\d\\d"
    },
    "String":{"type":"string"},
    "Template":{
      "type":"structure",
      "members":{
        "value":{
          "shape":"String",
          "documentation":"<p>The Apache <a href=\"http://velocity.apache.org/engine/devel/vtl-reference-guide.html\" target=\"_blank\">Velocity Template Language (VTL)</a> template content used for the template resource.</p>"
        }
      },
      "documentation":"<p>Represents a mapping template used to transform a payload.</p>"
    },
    "TestInvokeAuthorizerRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "authorizerId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "authorizerId":{
          "shape":"String",
          "location":"uri",
          "locationName":"authorizer_id"
        },
        "headers":{"shape":"MapOfHeaderValues"},
        "pathWithQueryString":{"shape":"String"},
        "body":{"shape":"String"},
        "stageVariables":{"shape":"MapOfStringToString"},
        "additionalContext":{"shape":"MapOfStringToString"}
      }
    },
    "TestInvokeAuthorizerResponse":{
      "type":"structure",
      "members":{
        "clientStatus":{
          "shape":"Integer",
          "documentation":"<p>The HTTP status code that the client would have received. Value is 0 if the authorizer succeeded.</p>"
        },
        "log":{
          "shape":"String",
          "documentation":"<p>The Amazon API Gateway execution log for the test authorizer request.</p>"
        },
        "latency":{
          "shape":"Long",
          "documentation":"<p>The execution latency of the test authorizer request</p>"
        },
        "principalId":{
          "shape":"String",
          "documentation":"<p>The principal identity returned by the <a>Authorizer</a></p>"
        },
        "policy":{
          "shape":"String",
          "documentation":"<p>The policy JSON document returned by the <a>Authorizer</a></p>"
        },
        "authorization":{"shape":"MapOfStringToList"}
      },
      "documentation":"<p>Represents the response of the test invoke request in for a custom <a>Authorizer</a></p>"
    },
    "TestInvokeMethodRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "location":"uri",
          "locationName":"http_method"
        },
        "pathWithQueryString":{"shape":"String"},
        "body":{"shape":"String"},
        "headers":{"shape":"MapOfHeaderValues"},
        "clientCertificateId":{"shape":"String"},
        "stageVariables":{"shape":"MapOfStringToString"}
      }
    },
    "TestInvokeMethodResponse":{
      "type":"structure",
      "members":{
        "status":{
          "shape":"Integer",
          "documentation":"<p>The HTTP status code.</p>"
        },
        "body":{
          "shape":"String",
          "documentation":"<p>The body of HTTP response.</p>"
        },
        "headers":{
          "shape":"MapOfHeaderValues",
          "documentation":"<p>The headers of HTTP response.</p>"
        },
        "log":{
          "shape":"String",
          "documentation":"<p>The Amazon API Gateway execution log for the test invoke request.</p>"
        },
        "latency":{
          "shape":"Long",
          "documentation":"<p>The execution latency of the test invoke request.</p>"
        }
      },
      "documentation":"<p>Represents the response of the test invoke request in HTTP method.</p>"
    },
    "ThrottleSettings":{
      "type":"structure",
      "members":{
        "burstLimit":{
          "shape":"Integer",
          "documentation":"<p>Returns the burstLimit when <b>ThrottleSettings</b> is called.</p>"
        },
        "rateLimit":{
          "shape":"Double",
          "documentation":"<p>Returns the rateLimit when <b>ThrottleSettings</b> is called.</p>"
        }
      },
      "documentation":"<p>Returns the throttle settings.</p>"
    },
    "Timestamp":{"type":"timestamp"},
    "TooManyRequestsException":{
      "type":"structure",
      "members":{
        "retryAfterSeconds":{
          "shape":"String",
          "location":"header",
          "locationName":"Retry-After"
        },
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":429},
      "exception":true
    },
    "UnauthorizedCacheControlHeaderStrategy":{
      "type":"string",
      "enum":[
        "FAIL_WITH_403",
        "SUCCEED_WITH_RESPONSE_HEADER",
        "SUCCEED_WITHOUT_RESPONSE_HEADER"
      ]
    },
    "UnauthorizedException":{
      "type":"structure",
      "members":{
        "message":{"shape":"String"}
      },
      "error":{"httpStatusCode":401},
      "exception":true
    },
    "UpdateAccountRequest":{
      "type":"structure",
      "members":{
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to change information about the current <a>Account</a> resource.</p>"
    },
    "UpdateApiKeyRequest":{
      "type":"structure",
      "required":["apiKey"],
      "members":{
        "apiKey":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>ApiKey</a> resource to be updated.</p>",
          "location":"uri",
          "locationName":"api_Key"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>A request to change information about an <a>ApiKey</a> resource.</p>"
    },
    "UpdateAuthorizerRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "authorizerId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Authorizer</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "authorizerId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Authorizer</a> resource.</p>",
          "location":"uri",
          "locationName":"authorizer_id"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Request to update an existing <a>Authorizer</a> resource.</p>"
    },
    "UpdateBasePathMappingRequest":{
      "type":"structure",
      "required":[
        "domainName",
        "basePath"
      ],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The domain name of the <a>BasePathMapping</a> resource to change.</p>",
          "location":"uri",
          "locationName":"domain_name"
        },
        "basePath":{
          "shape":"String",
          "documentation":"<p>The base path of the <a>BasePathMapping</a> resource to change.</p>",
          "location":"uri",
          "locationName":"base_path"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>A request to change information about the <a>BasePathMapping</a> resource.</p>"
    },
    "UpdateClientCertificateRequest":{
      "type":"structure",
      "required":["clientCertificateId"],
      "members":{
        "clientCertificateId":{
          "shape":"String",
          "location":"uri",
          "locationName":"clientcertificate_id"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      }
    },
    "UpdateDeploymentRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "deploymentId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The replacement identifier of the <a>RestApi</a> resource for the <a>Deployment</a> resource to change information about.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "deploymentId":{
          "shape":"String",
          "documentation":"<p>The replacment identifier for the <a>Deployment</a> resource to change information about.</p>",
          "location":"uri",
          "locationName":"deployment_id"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to change information about a <a>Deployment</a> resource.</p>"
    },
    "UpdateDomainNameRequest":{
      "type":"structure",
      "required":["domainName"],
      "members":{
        "domainName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>DomainName</a> resource to be changed.</p>",
          "location":"uri",
          "locationName":"domain_name"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>A request to change information about the <a>DomainName</a> resource.</p>"
    },
    "UpdateIntegrationRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Represents an update integration request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Represents an update integration request's resource identifier.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Represents an update integration request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Represents an update integration request.</p>"
    },
    "UpdateIntegrationResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>Specifies an update integration response request's API identifier.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>Specifies an update integration response request's resource identifier.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>Specifies an update integration response request's HTTP method.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>Specifies an update integration response request's status code.</p>",
          "location":"uri",
          "locationName":"status_code"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Represents an update integration response request.</p>"
    },
    "UpdateMethodRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP verb that identifies the <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Request to update an existing <a>Method</a> resource.</p>"
    },
    "UpdateMethodResponseRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId",
        "httpMethod",
        "statusCode"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The <a>Resource</a> identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "httpMethod":{
          "shape":"String",
          "documentation":"<p>The HTTP verb identifier for the parent <a>Method</a> resource.</p>",
          "location":"uri",
          "locationName":"http_method"
        },
        "statusCode":{
          "shape":"StatusCode",
          "documentation":"<p>The status code identifier for the <a>MethodResponse</a> resource.</p>",
          "location":"uri",
          "locationName":"status_code"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>A request to update an existing <a>MethodResponse</a> resource.</p>"
    },
    "UpdateModelRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "modelName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier under which the model exists.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "modelName":{
          "shape":"String",
          "documentation":"<p>The name of the model to update.</p>",
          "location":"uri",
          "locationName":"model_name"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Request to update an existing model in an existing <a>RestApi</a> resource.</p>"
    },
    "UpdateResourceRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "resourceId"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The <a>RestApi</a> identifier for the <a>Resource</a> resource.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "resourceId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>Resource</a> resource.</p>",
          "location":"uri",
          "locationName":"resource_id"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Request to change information about a <a>Resource</a> resource.</p>"
    },
    "UpdateRestApiRequest":{
      "type":"structure",
      "required":["restApiId"],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The ID of the <a>RestApi</a> you want to update.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Request to update an existing <a>RestApi</a> resource in your collection.</p>"
    },
    "UpdateStageRequest":{
      "type":"structure",
      "required":[
        "restApiId",
        "stageName"
      ],
      "members":{
        "restApiId":{
          "shape":"String",
          "documentation":"<p>The identifier of the <a>RestApi</a> resource for the <a>Stage</a> resource to change information about.</p>",
          "location":"uri",
          "locationName":"restapi_id"
        },
        "stageName":{
          "shape":"String",
          "documentation":"<p>The name of the <a>Stage</a> resource to change information about.</p>",
          "location":"uri",
          "locationName":"stage_name"
        },
        "patchOperations":{
          "shape":"ListOfPatchOperation",
          "documentation":"<p>A list of operations describing the updates to apply to the specified resource. The patches are applied in the order specified in the list.</p>"
        }
      },
      "documentation":"<p>Requests Amazon API Gateway to change information about a <a>Stage</a> resource.</p>"
    },
    "op":{
      "type":"string",
      "enum":[
        "add",
        "remove",
        "replace",
        "move",
        "copy",
        "test"
      ]
    }
  },
  "documentation":"<fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure and scalable mobile and web application backends. Amazon API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>"
}
                                                                                                                                   usr/local/lib/python2.7/dist-packages/botocore/data/autoscaling/                                    0042755 0000000 0000062 00000000000 13077704402 023264  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/autoscaling/2011-01-01/                         0042755 0000000 0000062 00000000000 13077704402 024303  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/autoscaling/2011-01-01/paginators-1.json        0100644 0000000 0000062 00000002724 13077704371 027510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "pagination": {
    "DescribeAutoScalingGroups": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "AutoScalingGroups"
    },
    "DescribeAutoScalingInstances": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "AutoScalingInstances"
    },
    "DescribeLaunchConfigurations": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "LaunchConfigurations"
    },
    "DescribeNotificationConfigurations": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "NotificationConfigurations"
    },
    "DescribePolicies": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "ScalingPolicies"
    },
    "DescribeScalingActivities": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "Activities"
    },
    "DescribeScheduledActions": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "ScheduledUpdateGroupActions"
    },
    "DescribeTags": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "limit_key": "MaxRecords",
      "result_key": "Tags"
    }
  }
}
                                            usr/local/lib/python2.7/dist-packages/botocore/data/autoscaling/2011-01-01/service-2.json           0100644 0000000 0000062 00000446142 13077704371 027010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2011-01-01",
    "endpointPrefix":"autoscaling",
    "protocol":"query",
    "serviceFullName":"Auto Scaling",
    "signatureVersion":"v4",
    "xmlNamespace":"http://autoscaling.amazonaws.com/doc/2011-01-01/"
  },
  "operations":{
    "AttachInstances":{
      "name":"AttachInstances",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"AttachInstancesQuery"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Attaches one or more EC2 instances to the specified Auto Scaling group.</p> <p>When you attach instances, Auto Scaling increases the desired capacity of the group by the number of instances being attached. If the number of instances being attached plus the desired capacity of the group exceeds the maximum size of the group, the operation fails.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/attach-instance-asg.html\">Attach EC2 Instances to Your Auto Scaling Group</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "AttachLoadBalancers":{
      "name":"AttachLoadBalancers",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"AttachLoadBalancersType"},
      "output":{
        "shape":"AttachLoadBalancersResultType",
        "resultWrapper":"AttachLoadBalancersResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Attaches one or more load balancers to the specified Auto Scaling group.</p> <p>To describe the load balancers for an Auto Scaling group, use <a>DescribeLoadBalancers</a>. To detach the load balancer from the Auto Scaling group, use <a>DetachLoadBalancers</a>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/attach-load-balancer-asg.html\">Attach a Load Balancer to Your Auto Scaling Group</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "CompleteLifecycleAction":{
      "name":"CompleteLifecycleAction",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CompleteLifecycleActionType"},
      "output":{
        "shape":"CompleteLifecycleActionAnswer",
        "resultWrapper":"CompleteLifecycleActionResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Completes the lifecycle action for the specified token or instance with the specified result.</p> <p>This step is a part of the procedure for adding a lifecycle hook to an Auto Scaling group:</p> <ol> <li>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to invoke your Lambda function when Auto Scaling launches or terminates instances.</li> <li>(Optional) Create a notification target and an IAM role. The target can be either an Amazon SQS queue or an Amazon SNS topic. The role allows Auto Scaling to publish lifecycle notifications to the target.</li> <li>Create the lifecycle hook. Specify whether the hook is used when the instances launch or terminate.</li> <li>If you need more time, record the lifecycle action heartbeat to keep the instance in a pending state.</li> <li><b>If you finish before the timeout period ends, complete the lifecycle action.</b></li> </ol> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "CreateAutoScalingGroup":{
      "name":"CreateAutoScalingGroup",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateAutoScalingGroupType"},
      "errors":[
        {"shape":"AlreadyExistsFault"},
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Creates an Auto Scaling group with the specified name and attributes.</p> <p>If you exceed your maximum limit of Auto Scaling groups, which by default is 20 per region, the call fails. For information about viewing and updating this limit, see <a>DescribeAccountLimits</a>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroup.html\">Auto Scaling Groups</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "CreateLaunchConfiguration":{
      "name":"CreateLaunchConfiguration",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateLaunchConfigurationType"},
      "errors":[
        {"shape":"AlreadyExistsFault"},
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Creates a launch configuration.</p> <p>If you exceed your maximum limit of launch configurations, which by default is 100 per region, the call fails. For information about viewing and updating this limit, see <a>DescribeAccountLimits</a>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/LaunchConfiguration.html\">Launch Configurations</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "CreateOrUpdateTags":{
      "name":"CreateOrUpdateTags",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateOrUpdateTagsType"},
      "errors":[
        {"shape":"LimitExceededFault"},
        {"shape":"AlreadyExistsFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Creates or updates tags for the specified Auto Scaling group.</p> <p>When you specify a tag with a key that already exists, the operation overwrites the previous tag definition, and you do not get an error message.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/ASTagging.html\">Tagging Auto Scaling Groups and Instances</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "DeleteAutoScalingGroup":{
      "name":"DeleteAutoScalingGroup",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteAutoScalingGroupType"},
      "errors":[
        {"shape":"ScalingActivityInProgressFault"},
        {"shape":"ResourceInUseFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified Auto Scaling group.</p> <p>If the group has instances or scaling activities in progress, you must specify the option to force the deletion in order for it to succeed.</p> <p>If the group has policies, deleting the group deletes the policies, the underlying alarm actions, and any alarm that no longer has an associated action.</p> <p>To remove instances from the Auto Scaling group before deleting it, call <a>DetachInstances</a> with the list of instances and the option to decrement the desired capacity so that Auto Scaling does not launch replacement instances.</p> <p>To terminate all instances before deleting the Auto Scaling group, call <a>UpdateAutoScalingGroup</a> and set the minimum size and desired capacity of the Auto Scaling group to zero.</p>"
    },
    "DeleteLaunchConfiguration":{
      "name":"DeleteLaunchConfiguration",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"LaunchConfigurationNameType"},
      "errors":[
        {"shape":"ResourceInUseFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified launch configuration.</p> <p>The launch configuration must not be attached to an Auto Scaling group. When this call completes, the launch configuration is no longer available for use.</p>"
    },
    "DeleteLifecycleHook":{
      "name":"DeleteLifecycleHook",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteLifecycleHookType"},
      "output":{
        "shape":"DeleteLifecycleHookAnswer",
        "resultWrapper":"DeleteLifecycleHookResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified lifecycle hook.</p> <p>If there are any outstanding lifecycle actions, they are completed first (<code>ABANDON</code> for launching instances, <code>CONTINUE</code> for terminating instances).</p>"
    },
    "DeleteNotificationConfiguration":{
      "name":"DeleteNotificationConfiguration",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteNotificationConfigurationType"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified notification.</p>"
    },
    "DeletePolicy":{
      "name":"DeletePolicy",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeletePolicyType"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified Auto Scaling policy.</p> <p>Deleting a policy deletes the underlying alarm action, but does not delete the alarm, even if it no longer has an associated action.</p>"
    },
    "DeleteScheduledAction":{
      "name":"DeleteScheduledAction",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteScheduledActionType"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified scheduled action.</p>"
    },
    "DeleteTags":{
      "name":"DeleteTags",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteTagsType"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Deletes the specified tags.</p>"
    },
    "DescribeAccountLimits":{
      "name":"DescribeAccountLimits",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"DescribeAccountLimitsAnswer",
        "resultWrapper":"DescribeAccountLimitsResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the current Auto Scaling resource limits for your AWS account.</p> <p>For information about requesting an increase in these limits, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html\">AWS Service Limits</a> in the <i>Amazon Web Services General Reference</i>.</p>"
    },
    "DescribeAdjustmentTypes":{
      "name":"DescribeAdjustmentTypes",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"DescribeAdjustmentTypesAnswer",
        "resultWrapper":"DescribeAdjustmentTypesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the policy adjustment types for use with <a>PutScalingPolicy</a>.</p>"
    },
    "DescribeAutoScalingGroups":{
      "name":"DescribeAutoScalingGroups",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"AutoScalingGroupNamesType"},
      "output":{
        "shape":"AutoScalingGroupsType",
        "resultWrapper":"DescribeAutoScalingGroupsResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes one or more Auto Scaling groups. If a list of names is not provided, the call describes all Auto Scaling groups.</p>"
    },
    "DescribeAutoScalingInstances":{
      "name":"DescribeAutoScalingInstances",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeAutoScalingInstancesType"},
      "output":{
        "shape":"AutoScalingInstancesType",
        "resultWrapper":"DescribeAutoScalingInstancesResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes one or more Auto Scaling instances. If a list is not provided, the call describes all instances.</p>"
    },
    "DescribeAutoScalingNotificationTypes":{
      "name":"DescribeAutoScalingNotificationTypes",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"DescribeAutoScalingNotificationTypesAnswer",
        "resultWrapper":"DescribeAutoScalingNotificationTypesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the notification types that are supported by Auto Scaling.</p>"
    },
    "DescribeLaunchConfigurations":{
      "name":"DescribeLaunchConfigurations",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"LaunchConfigurationNamesType"},
      "output":{
        "shape":"LaunchConfigurationsType",
        "resultWrapper":"DescribeLaunchConfigurationsResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes one or more launch configurations. If you omit the list of names, then the call describes all launch configurations.</p>"
    },
    "DescribeLifecycleHookTypes":{
      "name":"DescribeLifecycleHookTypes",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"DescribeLifecycleHookTypesAnswer",
        "resultWrapper":"DescribeLifecycleHookTypesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the available types of lifecycle hooks.</p>"
    },
    "DescribeLifecycleHooks":{
      "name":"DescribeLifecycleHooks",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeLifecycleHooksType"},
      "output":{
        "shape":"DescribeLifecycleHooksAnswer",
        "resultWrapper":"DescribeLifecycleHooksResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the lifecycle hooks for the specified Auto Scaling group.</p>"
    },
    "DescribeLoadBalancers":{
      "name":"DescribeLoadBalancers",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeLoadBalancersRequest"},
      "output":{
        "shape":"DescribeLoadBalancersResponse",
        "resultWrapper":"DescribeLoadBalancersResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the load balancers for the specified Auto Scaling group.</p>"
    },
    "DescribeMetricCollectionTypes":{
      "name":"DescribeMetricCollectionTypes",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"DescribeMetricCollectionTypesAnswer",
        "resultWrapper":"DescribeMetricCollectionTypesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the available CloudWatch metrics for Auto Scaling.</p> <p>Note that the <code>GroupStandbyInstances</code> metric is not returned by default. You must explicitly request this metric when calling <a>EnableMetricsCollection</a>.</p>"
    },
    "DescribeNotificationConfigurations":{
      "name":"DescribeNotificationConfigurations",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeNotificationConfigurationsType"},
      "output":{
        "shape":"DescribeNotificationConfigurationsAnswer",
        "resultWrapper":"DescribeNotificationConfigurationsResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the notification actions associated with the specified Auto Scaling group.</p>"
    },
    "DescribePolicies":{
      "name":"DescribePolicies",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribePoliciesType"},
      "output":{
        "shape":"PoliciesType",
        "resultWrapper":"DescribePoliciesResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the policies for the specified Auto Scaling group.</p>"
    },
    "DescribeScalingActivities":{
      "name":"DescribeScalingActivities",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeScalingActivitiesType"},
      "output":{
        "shape":"ActivitiesType",
        "resultWrapper":"DescribeScalingActivitiesResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes one or more scaling activities for the specified Auto Scaling group. If you omit the <code>ActivityIds</code>, the call returns all activities from the past six weeks. Activities are sorted by the start time. Activities still in progress appear first on the list.</p>"
    },
    "DescribeScalingProcessTypes":{
      "name":"DescribeScalingProcessTypes",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"ProcessesType",
        "resultWrapper":"DescribeScalingProcessTypesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the scaling process types for use with <a>ResumeProcesses</a> and <a>SuspendProcesses</a>.</p>"
    },
    "DescribeScheduledActions":{
      "name":"DescribeScheduledActions",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeScheduledActionsType"},
      "output":{
        "shape":"ScheduledActionsType",
        "resultWrapper":"DescribeScheduledActionsResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the actions scheduled for your Auto Scaling group that haven't run. To describe the actions that have already run, use <a>DescribeScalingActivities</a>.</p>"
    },
    "DescribeTags":{
      "name":"DescribeTags",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeTagsType"},
      "output":{
        "shape":"TagsType",
        "resultWrapper":"DescribeTagsResult"
      },
      "errors":[
        {"shape":"InvalidNextToken"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the specified tags.</p> <p>You can use filters to limit the results. For example, you can query for the tags for a specific Auto Scaling group. You can specify multiple values for a filter. A tag must match at least one of the specified values for it to be included in the results.</p> <p>You can also specify multiple filters. The result includes information for a particular tag only if it matches all the filters. If there's no match, no special message is returned.</p>"
    },
    "DescribeTerminationPolicyTypes":{
      "name":"DescribeTerminationPolicyTypes",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "output":{
        "shape":"DescribeTerminationPolicyTypesAnswer",
        "resultWrapper":"DescribeTerminationPolicyTypesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Describes the termination policies supported by Auto Scaling.</p>"
    },
    "DetachInstances":{
      "name":"DetachInstances",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DetachInstancesQuery"},
      "output":{
        "shape":"DetachInstancesAnswer",
        "resultWrapper":"DetachInstancesResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Removes one or more instances from the specified Auto Scaling group.</p> <p>After the instances are detached, you can manage them independently from the rest of the Auto Scaling group.</p> <p>If you do not specify the option to decrement the desired capacity, Auto Scaling launches instances to replace the ones that are detached.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/detach-instance-asg.html\">Detach EC2 Instances from Your Auto Scaling Group</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "DetachLoadBalancers":{
      "name":"DetachLoadBalancers",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DetachLoadBalancersType"},
      "output":{
        "shape":"DetachLoadBalancersResultType",
        "resultWrapper":"DetachLoadBalancersResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Removes one or more load balancers from the specified Auto Scaling group.</p> <p>When you detach a load balancer, it enters the <code>Removing</code> state while deregistering the instances in the group. When all instances are deregistered, then you can no longer describe the load balancer using <a>DescribeLoadBalancers</a>. Note that the instances remain running.</p>"
    },
    "DisableMetricsCollection":{
      "name":"DisableMetricsCollection",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DisableMetricsCollectionQuery"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Disables monitoring of the specified metrics for the specified Auto Scaling group.</p>"
    },
    "EnableMetricsCollection":{
      "name":"EnableMetricsCollection",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"EnableMetricsCollectionQuery"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Enables monitoring of the specified metrics for the specified Auto Scaling group.</p> <p>You can only enable metrics collection if <code>InstanceMonitoring</code> in the launch configuration for the group is set to <code>True</code>.</p>"
    },
    "EnterStandby":{
      "name":"EnterStandby",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"EnterStandbyQuery"},
      "output":{
        "shape":"EnterStandbyAnswer",
        "resultWrapper":"EnterStandbyResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Moves the specified instances into <code>Standby</code> mode.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "ExecutePolicy":{
      "name":"ExecutePolicy",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ExecutePolicyType"},
      "errors":[
        {"shape":"ScalingActivityInProgressFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Executes the specified policy.</p>"
    },
    "ExitStandby":{
      "name":"ExitStandby",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ExitStandbyQuery"},
      "output":{
        "shape":"ExitStandbyAnswer",
        "resultWrapper":"ExitStandbyResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Moves the specified instances out of <code>Standby</code> mode.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "PutLifecycleHook":{
      "name":"PutLifecycleHook",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"PutLifecycleHookType"},
      "output":{
        "shape":"PutLifecycleHookAnswer",
        "resultWrapper":"PutLifecycleHookResult"
      },
      "errors":[
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Creates or updates a lifecycle hook for the specified Auto Scaling Group.</p> <p>A lifecycle hook tells Auto Scaling that you want to perform an action on an instance that is not actively in service; for example, either when the instance launches or before the instance terminates.</p> <p>This step is a part of the procedure for adding a lifecycle hook to an Auto Scaling group:</p> <ol> <li>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to invoke your Lambda function when Auto Scaling launches or terminates instances.</li> <li>(Optional) Create a notification target and an IAM role. The target can be either an Amazon SQS queue or an Amazon SNS topic. The role allows Auto Scaling to publish lifecycle notifications to the target.</li> <li><b>Create the lifecycle hook. Specify whether the hook is used when the instances launch or terminate.</b></li> <li>If you need more time, record the lifecycle action heartbeat to keep the instance in a pending state.</li> <li>If you finish before the timeout period ends, complete the lifecycle action.</li> </ol> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p> <p>If you exceed your maximum limit of lifecycle hooks, which by default is 50 per region, the call fails. For information about updating this limit, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html\">AWS Service Limits</a> in the <i>Amazon Web Services General Reference</i>.</p>"
    },
    "PutNotificationConfiguration":{
      "name":"PutNotificationConfiguration",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"PutNotificationConfigurationType"},
      "errors":[
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p> Configures an Auto Scaling group to send notifications when specified events take place. Subscribers to this topic can have messages for events delivered to an endpoint such as a web server or email address. </p> <p>For more information see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/ASGettingNotifications.html\">Getting Notifications When Your Auto Scaling Group Changes</a> in the <i>Auto Scaling Developer Guide</i>.</p> <p>This configuration overwrites an existing configuration.</p>"
    },
    "PutScalingPolicy":{
      "name":"PutScalingPolicy",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"PutScalingPolicyType"},
      "output":{
        "shape":"PolicyARNType",
        "resultWrapper":"PutScalingPolicyResult"
      },
      "errors":[
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Creates or updates a policy for an Auto Scaling group. To update an existing policy, use the existing policy name and set the parameters you want to change. Any existing parameter not changed in an update to an existing policy is not changed in this update request.</p> <p>If you exceed your maximum limit of step adjustments, which by default is 20 per region, the call fails. For information about updating this limit, see <a href=\"http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html\">AWS Service Limits</a> in the <i>Amazon Web Services General Reference</i>.</p>"
    },
    "PutScheduledUpdateGroupAction":{
      "name":"PutScheduledUpdateGroupAction",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"PutScheduledUpdateGroupActionType"},
      "errors":[
        {"shape":"AlreadyExistsFault"},
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p> Creates or updates a scheduled scaling action for an Auto Scaling group. When updating a scheduled scaling action, if you leave a parameter unspecified, the corresponding value remains unchanged in the affected Auto Scaling group. </p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/schedule_time.html\">Scheduled Scaling</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "RecordLifecycleActionHeartbeat":{
      "name":"RecordLifecycleActionHeartbeat",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"RecordLifecycleActionHeartbeatType"},
      "output":{
        "shape":"RecordLifecycleActionHeartbeatAnswer",
        "resultWrapper":"RecordLifecycleActionHeartbeatResult"
      },
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Records a heartbeat for the lifecycle action associated with the specified token or instance. This extends the timeout by the length of time defined using <a>PutLifecycleHook</a>.</p> <p>This step is a part of the procedure for adding a lifecycle hook to an Auto Scaling group:</p> <ol> <li>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to invoke your Lambda function when Auto Scaling launches or terminates instances.</li> <li>(Optional) Create a notification target and an IAM role. The target can be either an Amazon SQS queue or an Amazon SNS topic. The role allows Auto Scaling to publish lifecycle notifications to the target.</li> <li>Create the lifecycle hook. Specify whether the hook is used when the instances launch or terminate.</li> <li><b>If you need more time, record the lifecycle action heartbeat to keep the instance in a pending state.</b></li> <li>If you finish before the timeout period ends, complete the lifecycle action.</li> </ol> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "ResumeProcesses":{
      "name":"ResumeProcesses",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ScalingProcessQuery"},
      "errors":[
        {"shape":"ResourceInUseFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Resumes the specified suspended Auto Scaling processes, or all suspended process, for the specified Auto Scaling group.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/US_SuspendResume.html\">Suspending and Resuming Auto Scaling Processes</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "SetDesiredCapacity":{
      "name":"SetDesiredCapacity",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"SetDesiredCapacityType"},
      "errors":[
        {"shape":"ScalingActivityInProgressFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Sets the size of the specified Auto Scaling group.</p> <p>For more information about desired capacity, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/WhatIsAutoScaling.html\">What Is Auto Scaling?</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "SetInstanceHealth":{
      "name":"SetInstanceHealth",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"SetInstanceHealthQuery"},
      "errors":[
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Sets the health status of the specified instance.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/healthcheck.html\">Health Checks</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "SetInstanceProtection":{
      "name":"SetInstanceProtection",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"SetInstanceProtectionQuery"},
      "output":{
        "shape":"SetInstanceProtectionAnswer",
        "resultWrapper":"SetInstanceProtectionResult"
      },
      "errors":[
        {"shape":"LimitExceededFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Updates the instance protection settings of the specified instances.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingBehavior.InstanceTermination.html#instance-protection\">Instance Protection</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "SuspendProcesses":{
      "name":"SuspendProcesses",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ScalingProcessQuery"},
      "errors":[
        {"shape":"ResourceInUseFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Suspends the specified Auto Scaling processes, or all processes, for the specified Auto Scaling group.</p> <p>Note that if you suspend either the <code>Launch</code> or <code>Terminate</code> process types, it can prevent other process types from functioning properly.</p> <p>To resume processes that have been suspended, use <a>ResumeProcesses</a>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/US_SuspendResume.html\">Suspending and Resuming Auto Scaling Processes</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "TerminateInstanceInAutoScalingGroup":{
      "name":"TerminateInstanceInAutoScalingGroup",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"TerminateInstanceInAutoScalingGroupType"},
      "output":{
        "shape":"ActivityType",
        "resultWrapper":"TerminateInstanceInAutoScalingGroupResult"
      },
      "errors":[
        {"shape":"ScalingActivityInProgressFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Terminates the specified instance and optionally adjusts the desired group size.</p> <p>This call simply makes a termination request. The instance is not terminated immediately.</p>"
    },
    "UpdateAutoScalingGroup":{
      "name":"UpdateAutoScalingGroup",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateAutoScalingGroupType"},
      "errors":[
        {"shape":"ScalingActivityInProgressFault"},
        {"shape":"ResourceContentionFault"}
      ],
      "documentation":"<p>Updates the configuration for the specified Auto Scaling group.</p> <p>To update an Auto Scaling group with a launch configuration with <code>InstanceMonitoring</code> set to <code>False</code>, you must first disable the collection of group metrics. Otherwise, you will get an error. If you have previously enabled the collection of group metrics, you can disable it using <a>DisableMetricsCollection</a>.</p> <p>The new settings are registered upon the completion of this call. Any launch configuration settings take effect on any triggers after this call returns. Scaling activities that are currently in progress aren't affected.</p> <p>Note the following:</p> <ul> <li> <p>If you specify a new value for <code>MinSize</code> without specifying a value for <code>DesiredCapacity</code>, and the new <code>MinSize</code> is larger than the current size of the group, we implicitly call <a>SetDesiredCapacity</a> to set the size of the group to the new value of <code>MinSize</code>.</p> </li> <li> <p>If you specify a new value for <code>MaxSize</code> without specifying a value for <code>DesiredCapacity</code>, and the new <code>MaxSize</code> is smaller than the current size of the group, we implicitly call <a>SetDesiredCapacity</a> to set the size of the group to the new value of <code>MaxSize</code>.</p> </li> <li> <p>All other optional parameters are left unchanged if not specified.</p> </li> </ul>"
    }
  },
  "shapes":{
    "Activities":{
      "type":"list",
      "member":{"shape":"Activity"}
    },
    "ActivitiesType":{
      "type":"structure",
      "required":["Activities"],
      "members":{
        "Activities":{
          "shape":"Activities",
          "documentation":"<p>The scaling activities.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "Activity":{
      "type":"structure",
      "required":[
        "ActivityId",
        "AutoScalingGroupName",
        "Cause",
        "StartTime",
        "StatusCode"
      ],
      "members":{
        "ActivityId":{
          "shape":"XmlString",
          "documentation":"<p>The ID of the activity.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "Description":{
          "shape":"XmlString",
          "documentation":"<p>A friendly, more verbose description of the activity.</p>"
        },
        "Cause":{
          "shape":"XmlStringMaxLen1023",
          "documentation":"<p>The reason the activity began.</p>"
        },
        "StartTime":{
          "shape":"TimestampType",
          "documentation":"<p>The start time of the activity.</p>"
        },
        "EndTime":{
          "shape":"TimestampType",
          "documentation":"<p>The end time of the activity.</p>"
        },
        "StatusCode":{
          "shape":"ScalingActivityStatusCode",
          "documentation":"<p>The current status of the activity.</p>"
        },
        "StatusMessage":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>A friendly, more verbose description of the activity status.</p>"
        },
        "Progress":{
          "shape":"Progress",
          "documentation":"<p>A value between 0 and 100 that indicates the progress of the activity.</p>"
        },
        "Details":{
          "shape":"XmlString",
          "documentation":"<p>The details about the activity.</p>"
        }
      },
      "documentation":"<p>Describes scaling activity, which is a long-running process that represents a change to your Auto Scaling group, such as changing its size or replacing an instance.</p>"
    },
    "ActivityIds":{
      "type":"list",
      "member":{"shape":"XmlString"}
    },
    "ActivityType":{
      "type":"structure",
      "members":{
        "Activity":{
          "shape":"Activity",
          "documentation":"<p>A scaling activity.</p>"
        }
      }
    },
    "AdjustmentType":{
      "type":"structure",
      "members":{
        "AdjustmentType":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The policy adjustment type. The valid values are <code>ChangeInCapacity</code>, <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>"
        }
      },
      "documentation":"<p>Describes a policy adjustment type.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-scale-based-on-demand.html\">Dynamic Scaling</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "AdjustmentTypes":{
      "type":"list",
      "member":{"shape":"AdjustmentType"}
    },
    "Alarm":{
      "type":"structure",
      "members":{
        "AlarmName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the alarm.</p>"
        },
        "AlarmARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the alarm.</p>"
        }
      },
      "documentation":"<p>Describes an alarm.</p>"
    },
    "Alarms":{
      "type":"list",
      "member":{"shape":"Alarm"}
    },
    "AlreadyExistsFault":{
      "type":"structure",
      "members":{
        "message":{"shape":"XmlStringMaxLen255"}
      },
      "documentation":"<p>You already have an Auto Scaling group or launch configuration with this name.</p>",
      "error":{
        "code":"AlreadyExists",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "AsciiStringMaxLen255":{
      "type":"string",
      "max":255,
      "min":1,
      "pattern":"[A-Za-z0-9\\-_\\/]+"
    },
    "AssociatePublicIpAddress":{"type":"boolean"},
    "AttachInstancesQuery":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "InstanceIds":{
          "shape":"InstanceIds",
          "documentation":"<p>One or more instance IDs.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        }
      }
    },
    "AttachLoadBalancersResultType":{
      "type":"structure",
      "members":{
      }
    },
    "AttachLoadBalancersType":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "LoadBalancerNames":{
          "shape":"LoadBalancerNames",
          "documentation":"<p>One or more load balancer names.</p>"
        }
      }
    },
    "AutoScalingGroup":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "MinSize",
        "MaxSize",
        "DesiredCapacity",
        "DefaultCooldown",
        "AvailabilityZones",
        "HealthCheckType",
        "CreatedTime"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the group.</p>"
        },
        "AutoScalingGroupARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the group.</p>"
        },
        "LaunchConfigurationName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the associated launch configuration.</p>"
        },
        "MinSize":{
          "shape":"AutoScalingGroupMinSize",
          "documentation":"<p>The minimum size of the group.</p>"
        },
        "MaxSize":{
          "shape":"AutoScalingGroupMaxSize",
          "documentation":"<p>The maximum size of the group.</p>"
        },
        "DesiredCapacity":{
          "shape":"AutoScalingGroupDesiredCapacity",
          "documentation":"<p>The desired size of the group.</p>"
        },
        "DefaultCooldown":{
          "shape":"Cooldown",
          "documentation":"<p>The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.</p>"
        },
        "AvailabilityZones":{
          "shape":"AvailabilityZones",
          "documentation":"<p>One or more Availability Zones for the group.</p>"
        },
        "LoadBalancerNames":{
          "shape":"LoadBalancerNames",
          "documentation":"<p>One or more load balancers associated with the group.</p>"
        },
        "HealthCheckType":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The service to use for the health checks. The valid values are <code>EC2</code> and <code>ELB</code>.</p>"
        },
        "HealthCheckGracePeriod":{
          "shape":"HealthCheckGracePeriod",
          "documentation":"<p>The amount of time, in seconds, that Auto Scaling waits before checking the health status of an EC2 instance that has come into service.</p>"
        },
        "Instances":{
          "shape":"Instances",
          "documentation":"<p>The EC2 instances associated with the group.</p>"
        },
        "CreatedTime":{
          "shape":"TimestampType",
          "documentation":"<p>The date and time the group was created.</p>"
        },
        "SuspendedProcesses":{
          "shape":"SuspendedProcesses",
          "documentation":"<p>The suspended processes associated with the group.</p>"
        },
        "PlacementGroup":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the placement group into which you'll launch your instances, if any. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html\">Placement Groups</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "VPCZoneIdentifier":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>One or more subnet IDs, if applicable, separated by commas.</p> <p>If you specify <code>VPCZoneIdentifier</code> and <code>AvailabilityZones</code>, ensure that the Availability Zones of the subnets match the values for <code>AvailabilityZones</code>.</p>"
        },
        "EnabledMetrics":{
          "shape":"EnabledMetrics",
          "documentation":"<p>The metrics enabled for the group.</p>"
        },
        "Status":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The current state of the group when <a>DeleteAutoScalingGroup</a> is in progress.</p>"
        },
        "Tags":{
          "shape":"TagDescriptionList",
          "documentation":"<p>The tags for the group.</p>"
        },
        "TerminationPolicies":{
          "shape":"TerminationPolicies",
          "documentation":"<p>The termination policies for the group.</p>"
        },
        "NewInstancesProtectedFromScaleIn":{
          "shape":"InstanceProtected",
          "documentation":"<p>Indicates whether newly launched instances are protected from termination by Auto Scaling when scaling in.</p>"
        }
      },
      "documentation":"<p>Describes an Auto Scaling group.</p>"
    },
    "AutoScalingGroupDesiredCapacity":{"type":"integer"},
    "AutoScalingGroupMaxSize":{"type":"integer"},
    "AutoScalingGroupMinSize":{"type":"integer"},
    "AutoScalingGroupNames":{
      "type":"list",
      "member":{"shape":"ResourceName"}
    },
    "AutoScalingGroupNamesType":{
      "type":"structure",
      "members":{
        "AutoScalingGroupNames":{
          "shape":"AutoScalingGroupNames",
          "documentation":"<p>The group names.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        }
      }
    },
    "AutoScalingGroups":{
      "type":"list",
      "member":{"shape":"AutoScalingGroup"}
    },
    "AutoScalingGroupsType":{
      "type":"structure",
      "required":["AutoScalingGroups"],
      "members":{
        "AutoScalingGroups":{
          "shape":"AutoScalingGroups",
          "documentation":"<p>The groups.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "AutoScalingInstanceDetails":{
      "type":"structure",
      "required":[
        "InstanceId",
        "AutoScalingGroupName",
        "AvailabilityZone",
        "LifecycleState",
        "HealthStatus",
        "LaunchConfigurationName",
        "ProtectedFromScaleIn"
      ],
      "members":{
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the Auto Scaling group associated with the instance.</p>"
        },
        "AvailabilityZone":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The Availability Zone for the instance.</p>"
        },
        "LifecycleState":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The lifecycle state for the instance. For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "HealthStatus":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The health status of this instance. \"Healthy\" means that the instance is healthy and should remain in service. \"Unhealthy\" means that the instance is unhealthy and Auto Scaling should terminate and replace it.</p>"
        },
        "LaunchConfigurationName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The launch configuration associated with the instance.</p>"
        },
        "ProtectedFromScaleIn":{
          "shape":"InstanceProtected",
          "documentation":"<p>Indicates whether the instance is protected from termination by Auto Scaling when scaling in.</p>"
        }
      },
      "documentation":"<p>Describes an EC2 instance associated with an Auto Scaling group.</p>"
    },
    "AutoScalingInstances":{
      "type":"list",
      "member":{"shape":"AutoScalingInstanceDetails"}
    },
    "AutoScalingInstancesType":{
      "type":"structure",
      "members":{
        "AutoScalingInstances":{
          "shape":"AutoScalingInstances",
          "documentation":"<p>The instances.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "AutoScalingNotificationTypes":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen255"}
    },
    "AvailabilityZones":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen255"},
      "min":1
    },
    "BlockDeviceEbsDeleteOnTermination":{"type":"boolean"},
    "BlockDeviceEbsEncrypted":{"type":"boolean"},
    "BlockDeviceEbsIops":{
      "type":"integer",
      "max":20000,
      "min":100
    },
    "BlockDeviceEbsVolumeSize":{
      "type":"integer",
      "max":16384,
      "min":1
    },
    "BlockDeviceEbsVolumeType":{
      "type":"string",
      "max":255,
      "min":1
    },
    "BlockDeviceMapping":{
      "type":"structure",
      "required":["DeviceName"],
      "members":{
        "VirtualName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>"
        },
        "DeviceName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The device name exposed to the EC2 instance (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>"
        },
        "Ebs":{
          "shape":"Ebs",
          "documentation":"<p>The information about the Amazon EBS volume.</p>"
        },
        "NoDevice":{
          "shape":"NoDevice",
          "documentation":"<p>Suppresses a device mapping.</p> <p>If this parameter is true for the root device, the instance might fail the EC2 health check. Auto Scaling launches a replacement instance if the instance fails the health check.</p>"
        }
      },
      "documentation":"<p>Describes a block device mapping.</p>"
    },
    "BlockDeviceMappings":{
      "type":"list",
      "member":{"shape":"BlockDeviceMapping"}
    },
    "ClassicLinkVPCSecurityGroups":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen255"}
    },
    "CompleteLifecycleActionAnswer":{
      "type":"structure",
      "members":{
      }
    },
    "CompleteLifecycleActionType":{
      "type":"structure",
      "required":[
        "LifecycleHookName",
        "AutoScalingGroupName",
        "LifecycleActionResult"
      ],
      "members":{
        "LifecycleHookName":{
          "shape":"AsciiStringMaxLen255",
          "documentation":"<p>The name of the lifecycle hook.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group for the lifecycle hook.</p>"
        },
        "LifecycleActionToken":{
          "shape":"LifecycleActionToken",
          "documentation":"<p>A universally unique identifier (UUID) that identifies a specific lifecycle action associated with an instance. Auto Scaling sends this token to the notification target you specified when you created the lifecycle hook.</p>"
        },
        "LifecycleActionResult":{
          "shape":"LifecycleActionResult",
          "documentation":"<p>The action for the group to take. This parameter can be either <code>CONTINUE</code> or <code>ABANDON</code>.</p>"
        },
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance.</p>"
        }
      }
    },
    "Cooldown":{"type":"integer"},
    "CreateAutoScalingGroupType":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "MinSize",
        "MaxSize"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the group. This name must be unique within the scope of your AWS account.</p>"
        },
        "LaunchConfigurationName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the launch configuration. Alternatively, specify an EC2 instance instead of a launch configuration.</p>"
        },
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance used to create a launch configuration for the group. Alternatively, specify a launch configuration instead of an EC2 instance.</p> <p>When you specify an ID of an instance, Auto Scaling creates a new launch configuration and associates it with the group. This launch configuration derives its attributes from the specified instance, with the exception of the block device mapping.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/create-asg-from-instance.html\">Create an Auto Scaling Group Using an EC2 Instance</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "MinSize":{
          "shape":"AutoScalingGroupMinSize",
          "documentation":"<p>The minimum size of the group.</p>"
        },
        "MaxSize":{
          "shape":"AutoScalingGroupMaxSize",
          "documentation":"<p>The maximum size of the group.</p>"
        },
        "DesiredCapacity":{
          "shape":"AutoScalingGroupDesiredCapacity",
          "documentation":"<p>The number of EC2 instances that should be running in the group. This number must be greater than or equal to the minimum size of the group and less than or equal to the maximum size of the group.</p>"
        },
        "DefaultCooldown":{
          "shape":"Cooldown",
          "documentation":"<p>The amount of time, in seconds, after a scaling activity completes before another scaling activity can start. The default is 300.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/Cooldown.html\">Auto Scaling Cooldowns</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "AvailabilityZones":{
          "shape":"AvailabilityZones",
          "documentation":"<p>One or more Availability Zones for the group. This parameter is optional if you specify one or more subnets.</p>"
        },
        "LoadBalancerNames":{
          "shape":"LoadBalancerNames",
          "documentation":"<p>One or more load balancers.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/US_SetUpASLBApp.html\">Using a Load Balancer With an Auto Scaling Group</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "HealthCheckType":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The service to use for the health checks. The valid values are <code>EC2</code> and <code>ELB</code>.</p> <p>By default, health checks use Amazon EC2 instance status checks to determine the health of an instance. For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/healthcheck.html\">Health Checks</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "HealthCheckGracePeriod":{
          "shape":"HealthCheckGracePeriod",
          "documentation":"<p>The amount of time, in seconds, that Auto Scaling waits before checking the health status of an EC2 instance that has come into service. During this time, any health check failures for the instance are ignored. The default is 300.</p> <p>This parameter is required if you are adding an <code>ELB</code> health check.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/healthcheck.html\">Health Checks</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "PlacementGroup":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the placement group into which you'll launch your instances, if any. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html\">Placement Groups</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "VPCZoneIdentifier":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>A comma-separated list of subnet identifiers for your virtual private cloud (VPC).</p> <p>If you specify subnets and Availability Zones with this call, ensure that the subnets' Availability Zones match the Availability Zones specified.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/asg-in-vpc.html\">Launching Auto Scaling Instances in a VPC</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "TerminationPolicies":{
          "shape":"TerminationPolicies",
          "documentation":"<p>One or more termination policies used to select the instance to terminate. These policies are executed in the order that they are listed.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingBehavior.InstanceTermination.html\">Controlling Which Instances Auto Scaling Terminates During Scale In</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "NewInstancesProtectedFromScaleIn":{
          "shape":"InstanceProtected",
          "documentation":"<p>Indicates whether newly launched instances are protected from termination by Auto Scaling when scaling in.</p>"
        },
        "Tags":{
          "shape":"Tags",
          "documentation":"<p>One or more tags.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/ASTagging.html\">Tagging Auto Scaling Groups and Instances</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        }
      }
    },
    "CreateLaunchConfigurationType":{
      "type":"structure",
      "required":["LaunchConfigurationName"],
      "members":{
        "LaunchConfigurationName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the launch configuration. This name must be unique within the scope of your AWS account.</p>"
        },
        "ImageId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of the Amazon Machine Image (AMI) to use to launch your EC2 instances. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html\">Finding an AMI</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "KeyName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the key pair. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html\">Amazon EC2 Key Pairs</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "SecurityGroups":{
          "shape":"SecurityGroups",
          "documentation":"<p>One or more security groups with which to associate the instances.</p> <p>If your instances are launched in EC2-Classic, you can either specify security group names or the security group IDs. For more information about security groups for EC2-Classic, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html\">Amazon EC2 Security Groups</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>If your instances are launched into a VPC, specify security group IDs. For more information, see <a href=\"http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html\">Security Groups for Your VPC</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>"
        },
        "ClassicLinkVPCId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of a ClassicLink-enabled VPC to link your EC2-Classic instances to. This parameter is supported only if you are launching EC2-Classic instances. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html\">ClassicLink</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "ClassicLinkVPCSecurityGroups":{
          "shape":"ClassicLinkVPCSecurityGroups",
          "documentation":"<p>The IDs of one or more security groups for the specified ClassicLink-enabled VPC. This parameter is required if you specify a ClassicLink-enabled VPC, and is not supported otherwise. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html\">ClassicLink</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "UserData":{
          "shape":"XmlStringUserData",
          "documentation":"<p>The user data to make available to the launched EC2 instances. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html\">Instance Metadata and User Data</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance to use to create the launch configuration.</p> <p>The new launch configuration derives attributes from the instance, with the exception of the block device mapping.</p> <p>To create a launch configuration with a block device mapping or override any other instance attributes, specify them as part of the same request.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/create-lc-with-instanceID.html\">Create a Launch Configuration Using an EC2 Instance</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "InstanceType":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p> The instance type of the EC2 instance. For information about available instance types, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#AvailableInstanceTypes\"> Available Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide.</i> </p>"
        },
        "KernelId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p> The ID of the kernel associated with the AMI. </p>"
        },
        "RamdiskId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p> The ID of the RAM disk associated with the AMI. </p>"
        },
        "BlockDeviceMappings":{
          "shape":"BlockDeviceMappings",
          "documentation":"<p>One or more mappings that specify how block devices are exposed to the instance. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html\">Block Device Mapping</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "InstanceMonitoring":{
          "shape":"InstanceMonitoring",
          "documentation":"<p>Enables detailed monitoring if it is disabled. Detailed monitoring is enabled by default.</p> <p>When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and your account is charged a fee. When you disable detailed monitoring, by specifying <code>False</code>, CloudWatch generates metrics every 5 minutes. For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-instance-monitoring.html\">Monitoring Your Auto Scaling Instances and Groups</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "SpotPrice":{
          "shape":"SpotPrice",
          "documentation":"<p>The maximum hourly price to be paid for any Spot Instance launched to fulfill the request. Spot Instances are launched when the price you specify exceeds the current Spot market price. For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/US-SpotInstances.html\">Launching Spot Instances in Your Auto Scaling Group</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "IamInstanceProfile":{
          "shape":"XmlStringMaxLen1600",
          "documentation":"<p>The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instance.</p> <p>EC2 instances launched with an IAM role will automatically have AWS security credentials available. You can use IAM roles with Auto Scaling to automatically enable applications running on your EC2 instances to securely access other AWS resources. For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/us-iam-role.html\">Launch Auto Scaling Instances with an IAM Role</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "EbsOptimized":{
          "shape":"EbsOptimized",
          "documentation":"<p>Indicates whether the instance is optimized for Amazon EBS I/O. By default, the instance is not optimized for EBS I/O. The optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization is not available with all instance types. Additional usage charges apply. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html\">Amazon EBS-Optimized Instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "AssociatePublicIpAddress":{
          "shape":"AssociatePublicIpAddress",
          "documentation":"<p>Used for groups that launch instances into a virtual private cloud (VPC). Specifies whether to assign a public IP address to each instance. For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/asg-in-vpc.html\">Launching Auto Scaling Instances in a VPC</a> in the <i>Auto Scaling Developer Guide</i>.</p> <p>If you specify this parameter, be sure to specify at least one subnet when you create your group.</p> <p>Default: If the instance is launched into a default subnet, the default is <code>true</code>. If the instance is launched into a nondefault subnet, the default is <code>false</code>. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html\">Supported Platforms</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "PlacementTenancy":{
          "shape":"XmlStringMaxLen64",
          "documentation":"<p>The tenancy of the instance. An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware and can only be launched into a VPC.</p> <p>You must set the value of this parameter to <code>dedicated</code> if want to launch Dedicated Instances into a shared tenancy VPC (VPC with instance placement tenancy attribute set to <code>default</code>).</p> <p>If you specify this parameter, be sure to specify at least one subnet when you create your group.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/asg-in-vpc.html\">Launching Auto Scaling Instances in a VPC</a> in the <i>Auto Scaling Developer Guide</i>.</p> <p>Valid values: <code>default</code> | <code>dedicated</code></p>"
        }
      }
    },
    "CreateOrUpdateTagsType":{
      "type":"structure",
      "required":["Tags"],
      "members":{
        "Tags":{
          "shape":"Tags",
          "documentation":"<p>One or more tags.</p>"
        }
      }
    },
    "DeleteAutoScalingGroupType":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group to delete.</p>"
        },
        "ForceDelete":{
          "shape":"ForceDelete",
          "documentation":"<p>Specifies that the group will be deleted along with all instances associated with the group, without waiting for all instances to be terminated. This parameter also deletes any lifecycle actions associated with the group.</p>"
        }
      }
    },
    "DeleteLifecycleHookAnswer":{
      "type":"structure",
      "members":{
      }
    },
    "DeleteLifecycleHookType":{
      "type":"structure",
      "required":[
        "LifecycleHookName",
        "AutoScalingGroupName"
      ],
      "members":{
        "LifecycleHookName":{
          "shape":"AsciiStringMaxLen255",
          "documentation":"<p>The name of the lifecycle hook.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group for the lifecycle hook.</p>"
        }
      }
    },
    "DeleteNotificationConfigurationType":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "TopicARN"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "TopicARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic.</p>"
        }
      }
    },
    "DeletePolicyType":{
      "type":"structure",
      "required":["PolicyName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "PolicyName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or Amazon Resource Name (ARN) of the policy.</p>"
        }
      },
      "documentation":"<p/>"
    },
    "DeleteScheduledActionType":{
      "type":"structure",
      "required":["ScheduledActionName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "ScheduledActionName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the action to delete.</p>"
        }
      }
    },
    "DeleteTagsType":{
      "type":"structure",
      "required":["Tags"],
      "members":{
        "Tags":{
          "shape":"Tags",
          "documentation":"<p>One or more tags.</p>"
        }
      }
    },
    "DescribeAccountLimitsAnswer":{
      "type":"structure",
      "members":{
        "MaxNumberOfAutoScalingGroups":{
          "shape":"MaxNumberOfAutoScalingGroups",
          "documentation":"<p>The maximum number of groups allowed for your AWS account. The default limit is 20 per region.</p>"
        },
        "MaxNumberOfLaunchConfigurations":{
          "shape":"MaxNumberOfLaunchConfigurations",
          "documentation":"<p>The maximum number of launch configurations allowed for your AWS account. The default limit is 100 per region.</p>"
        },
        "NumberOfAutoScalingGroups":{
          "shape":"NumberOfAutoScalingGroups",
          "documentation":"<p>The current number of groups for your AWS account.</p>"
        },
        "NumberOfLaunchConfigurations":{
          "shape":"NumberOfLaunchConfigurations",
          "documentation":"<p>The current number of launch configurations for your AWS account.</p>"
        }
      }
    },
    "DescribeAdjustmentTypesAnswer":{
      "type":"structure",
      "members":{
        "AdjustmentTypes":{
          "shape":"AdjustmentTypes",
          "documentation":"<p>The policy adjustment types.</p>"
        }
      }
    },
    "DescribeAutoScalingInstancesType":{
      "type":"structure",
      "members":{
        "InstanceIds":{
          "shape":"InstanceIds",
          "documentation":"<p>The instances to describe; up to 50 instance IDs. If you omit this parameter, all Auto Scaling instances are described. If you specify an ID that does not exist, it is ignored with no error.</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        }
      }
    },
    "DescribeAutoScalingNotificationTypesAnswer":{
      "type":"structure",
      "members":{
        "AutoScalingNotificationTypes":{
          "shape":"AutoScalingNotificationTypes",
          "documentation":"<p>One or more of the following notification types:</p> <ul> <li><p><code>autoscaling:EC2_INSTANCE_LAUNCH</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_LAUNCH_ERROR</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_TERMINATE</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_TERMINATE_ERROR</code></p></li> <li><p><code>autoscaling:TEST_NOTIFICATION</code></p></li> </ul>"
        }
      }
    },
    "DescribeLifecycleHookTypesAnswer":{
      "type":"structure",
      "members":{
        "LifecycleHookTypes":{
          "shape":"AutoScalingNotificationTypes",
          "documentation":"<p>One or more of the following notification types:</p> <ul> <li><p><code>autoscaling:EC2_INSTANCE_LAUNCHING</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_TERMINATING</code></p></li> </ul>"
        }
      }
    },
    "DescribeLifecycleHooksAnswer":{
      "type":"structure",
      "members":{
        "LifecycleHooks":{
          "shape":"LifecycleHooks",
          "documentation":"<p>The lifecycle hooks for the specified group.</p>"
        }
      }
    },
    "DescribeLifecycleHooksType":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "LifecycleHookNames":{
          "shape":"LifecycleHookNames",
          "documentation":"<p>The names of one or more lifecycle hooks.</p>"
        }
      }
    },
    "DescribeLoadBalancersRequest":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        }
      }
    },
    "DescribeLoadBalancersResponse":{
      "type":"structure",
      "members":{
        "LoadBalancers":{
          "shape":"LoadBalancerStates",
          "documentation":"<p>The load balancers.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "DescribeMetricCollectionTypesAnswer":{
      "type":"structure",
      "members":{
        "Metrics":{
          "shape":"MetricCollectionTypes",
          "documentation":"<p>One or more metrics.</p>"
        },
        "Granularities":{
          "shape":"MetricGranularityTypes",
          "documentation":"<p>The granularities for the metrics.</p>"
        }
      }
    },
    "DescribeNotificationConfigurationsAnswer":{
      "type":"structure",
      "required":["NotificationConfigurations"],
      "members":{
        "NotificationConfigurations":{
          "shape":"NotificationConfigurations",
          "documentation":"<p>The notification configurations.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "DescribeNotificationConfigurationsType":{
      "type":"structure",
      "members":{
        "AutoScalingGroupNames":{
          "shape":"AutoScalingGroupNames",
          "documentation":"<p>The name of the group.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        }
      }
    },
    "DescribePoliciesType":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "PolicyNames":{
          "shape":"PolicyNames",
          "documentation":"<p>One or more policy names or policy ARNs to be described. If you omit this list, all policy names are described. If an group name is provided, the results are limited to that group. This list is limited to 50 items. If you specify an unknown policy name, it is ignored with no error.</p>"
        },
        "PolicyTypes":{
          "shape":"PolicyTypes",
          "documentation":"<p>One or more policy types. Valid values are <code>SimpleScaling</code> and <code>StepScaling</code>.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to be returned with each call.</p>"
        }
      }
    },
    "DescribeScalingActivitiesType":{
      "type":"structure",
      "members":{
        "ActivityIds":{
          "shape":"ActivityIds",
          "documentation":"<p>The activity IDs of the desired scaling activities. If this list is omitted, all activities are described. If you specify an Auto Scaling group, the results are limited to that group. The list of requested activities cannot contain more than 50 items. If unknown activities are requested, they are ignored with no error.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        }
      }
    },
    "DescribeScheduledActionsType":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "ScheduledActionNames":{
          "shape":"ScheduledActionNames",
          "documentation":"<p>Describes one or more scheduled actions. If you omit this list, the call describes all scheduled actions. If you specify an unknown scheduled action it is ignored with no error.</p> <p>You can describe up to a maximum of 50 instances with a single call. If there are more items to return, the call returns a token. To get the next set of items, repeat the call with the returned token.</p>"
        },
        "StartTime":{
          "shape":"TimestampType",
          "documentation":"<p>The earliest scheduled start time to return. If scheduled action names are provided, this parameter is ignored.</p>"
        },
        "EndTime":{
          "shape":"TimestampType",
          "documentation":"<p>The latest scheduled start time to return. If scheduled action names are provided, this parameter is ignored.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        }
      }
    },
    "DescribeTagsType":{
      "type":"structure",
      "members":{
        "Filters":{
          "shape":"Filters",
          "documentation":"<p>A filter used to scope the tags to return.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call.</p>"
        }
      }
    },
    "DescribeTerminationPolicyTypesAnswer":{
      "type":"structure",
      "members":{
        "TerminationPolicyTypes":{
          "shape":"TerminationPolicies",
          "documentation":"<p>The termination policies supported by Auto Scaling (<code>OldestInstance</code>, <code>OldestLaunchConfiguration</code>, <code>NewestInstance</code>, <code>ClosestToNextInstanceHour</code>, and <code>Default</code>).</p>"
        }
      }
    },
    "DetachInstancesAnswer":{
      "type":"structure",
      "members":{
        "Activities":{
          "shape":"Activities",
          "documentation":"<p>The activities related to detaching the instances from the Auto Scaling group.</p>"
        }
      }
    },
    "DetachInstancesQuery":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "ShouldDecrementDesiredCapacity"
      ],
      "members":{
        "InstanceIds":{
          "shape":"InstanceIds",
          "documentation":"<p>One or more instance IDs.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "ShouldDecrementDesiredCapacity":{
          "shape":"ShouldDecrementDesiredCapacity",
          "documentation":"<p>If <code>True</code>, the Auto Scaling group decrements the desired capacity value by the number of instances detached.</p>"
        }
      }
    },
    "DetachLoadBalancersResultType":{
      "type":"structure",
      "members":{
      }
    },
    "DetachLoadBalancersType":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "LoadBalancerNames":{
          "shape":"LoadBalancerNames",
          "documentation":"<p>One or more load balancer names.</p>"
        }
      }
    },
    "DisableMetricsCollectionQuery":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or Amazon Resource Name (ARN) of the group.</p>"
        },
        "Metrics":{
          "shape":"Metrics",
          "documentation":"<p>One or more of the following metrics. If you omit this parameter, all metrics are disabled.</p> <ul> <li><p><code>GroupMinSize</code></p></li> <li><p><code>GroupMaxSize</code></p></li> <li><p><code>GroupDesiredCapacity</code></p></li> <li><p><code>GroupInServiceInstances</code></p></li> <li><p><code>GroupPendingInstances</code></p></li> <li><p><code>GroupStandbyInstances</code></p></li> <li><p><code>GroupTerminatingInstances</code></p></li> <li><p><code>GroupTotalInstances</code></p></li> </ul>"
        }
      }
    },
    "Ebs":{
      "type":"structure",
      "members":{
        "SnapshotId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of the snapshot.</p>"
        },
        "VolumeSize":{
          "shape":"BlockDeviceEbsVolumeSize",
          "documentation":"<p>The volume size, in GiB. For <code>standard</code> volumes, specify a value from 1 to 1,024. For <code>io1</code> volumes, specify a value from 4 to 16,384. For <code>gp2</code> volumes, specify a value from 1 to 16,384. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you create a volume from a snapshot and you don't specify a volume size, the default is the snapshot size.</p>"
        },
        "VolumeType":{
          "shape":"BlockDeviceEbsVolumeType",
          "documentation":"<p>The volume type. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html\">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Valid values: <code>standard</code> | <code>io1</code> | <code>gp2</code></p> <p>Default: <code>standard</code></p>"
        },
        "DeleteOnTermination":{
          "shape":"BlockDeviceEbsDeleteOnTermination",
          "documentation":"<p>Indicates whether the volume is deleted on instance termination.</p> <p>Default: <code>true</code></p>"
        },
        "Iops":{
          "shape":"BlockDeviceEbsIops",
          "documentation":"<p>The number of I/O operations per second (IOPS) to provision for the volume.</p> <p>Constraint: Required when the volume type is <code>io1</code>.</p>"
        },
        "Encrypted":{
          "shape":"BlockDeviceEbsEncrypted",
          "documentation":"<p>Indicates whether the volume should be encrypted. Encrypted EBS volumes must be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or an unencrypted volume from an encrypted snapshot. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html\">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        }
      },
      "documentation":"<p>Describes an Amazon EBS volume.</p>"
    },
    "EbsOptimized":{"type":"boolean"},
    "EnableMetricsCollectionQuery":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "Granularity"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or ARN of the Auto Scaling group.</p>"
        },
        "Metrics":{
          "shape":"Metrics",
          "documentation":"<p>One or more of the following metrics. If you omit this parameter, all metrics are enabled.</p> <ul> <li><p><code>GroupMinSize</code></p></li> <li><p><code>GroupMaxSize</code></p></li> <li><p><code>GroupDesiredCapacity</code></p></li> <li><p><code>GroupInServiceInstances</code></p></li> <li><p><code>GroupPendingInstances</code></p></li> <li><p><code>GroupStandbyInstances</code></p></li> <li><p><code>GroupTerminatingInstances</code></p></li> <li><p><code>GroupTotalInstances</code></p></li> </ul> <p>Note that the <code>GroupStandbyInstances</code> metric is not enabled by default. You must explicitly request this metric.</p>"
        },
        "Granularity":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The granularity to associate with the metrics to collect. The only valid value is <code>1Minute</code>.</p>"
        }
      }
    },
    "EnabledMetric":{
      "type":"structure",
      "members":{
        "Metric":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>One of the following metrics:</p> <ul> <li><p><code>GroupMinSize</code></p></li> <li><p><code>GroupMaxSize</code></p></li> <li><p><code>GroupDesiredCapacity</code></p></li> <li><p><code>GroupInServiceInstances</code></p></li> <li><p><code>GroupPendingInstances</code></p></li> <li><p><code>GroupStandbyInstances</code></p></li> <li><p><code>GroupTerminatingInstances</code></p></li> <li><p><code>GroupTotalInstances</code></p></li> </ul>"
        },
        "Granularity":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The granularity of the metric. The only valid value is <code>1Minute</code>.</p>"
        }
      },
      "documentation":"<p>Describes an enabled metric.</p>"
    },
    "EnabledMetrics":{
      "type":"list",
      "member":{"shape":"EnabledMetric"}
    },
    "EnterStandbyAnswer":{
      "type":"structure",
      "members":{
        "Activities":{
          "shape":"Activities",
          "documentation":"<p>The activities related to moving instances into <code>Standby</code> mode.</p>"
        }
      }
    },
    "EnterStandbyQuery":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "ShouldDecrementDesiredCapacity"
      ],
      "members":{
        "InstanceIds":{
          "shape":"InstanceIds",
          "documentation":"<p>One or more instances to move into <code>Standby</code> mode. You must specify at least one instance ID.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "ShouldDecrementDesiredCapacity":{
          "shape":"ShouldDecrementDesiredCapacity",
          "documentation":"<p>Specifies whether the instances moved to <code>Standby</code> mode count as part of the Auto Scaling group's desired capacity. If set, the desired capacity for the Auto Scaling group decrements by the number of instances moved to <code>Standby</code> mode.</p>"
        }
      }
    },
    "EstimatedInstanceWarmup":{"type":"integer"},
    "ExecutePolicyType":{
      "type":"structure",
      "required":["PolicyName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or Amazon Resource Name (ARN) of the Auto Scaling group.</p>"
        },
        "PolicyName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or ARN of the policy.</p>"
        },
        "HonorCooldown":{
          "shape":"HonorCooldown",
          "documentation":"<p>If this parameter is true, Auto Scaling waits for the cooldown period to complete before executing the policy. Otherwise, Auto Scaling executes the policy without waiting for the cooldown period to complete.</p> <p>This parameter is not supported if the policy type is <code>StepScaling</code>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/Cooldown.html\">Auto Scaling Cooldowns</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "MetricValue":{
          "shape":"MetricScale",
          "documentation":"<p>The metric value to compare to <code>BreachThreshold</code>. This enables you to execute a policy of type <code>StepScaling</code> and determine which step adjustment to use. For example, if the breach threshold is 50 and you want to use a step adjustment with a lower bound of 0 and an upper bound of 10, you can set the metric value to 59.</p> <p>If you specify a metric value that doesn't correspond to a step adjustment for the policy, the call returns an error.</p> <p>This parameter is required if the policy type is <code>StepScaling</code> and not supported otherwise.</p>"
        },
        "BreachThreshold":{
          "shape":"MetricScale",
          "documentation":"<p>The breach threshold for the alarm.</p> <p>This parameter is required if the policy type is <code>StepScaling</code> and not supported otherwise.</p>"
        }
      }
    },
    "ExitStandbyAnswer":{
      "type":"structure",
      "members":{
        "Activities":{
          "shape":"Activities",
          "documentation":"<p>The activities related to moving instances out of <code>Standby</code> mode.</p>"
        }
      }
    },
    "ExitStandbyQuery":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "InstanceIds":{
          "shape":"InstanceIds",
          "documentation":"<p>One or more instance IDs. You must specify at least one instance ID.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        }
      }
    },
    "Filter":{
      "type":"structure",
      "members":{
        "Name":{
          "shape":"XmlString",
          "documentation":"<p>The name of the filter. The valid values are: <code>\"auto-scaling-group\"</code>, <code>\"key\"</code>, <code>\"value\"</code>, and <code>\"propagate-at-launch\"</code>.</p>"
        },
        "Values":{
          "shape":"Values",
          "documentation":"<p>The value of the filter.</p>"
        }
      },
      "documentation":"<p>Describes a filter.</p>"
    },
    "Filters":{
      "type":"list",
      "member":{"shape":"Filter"}
    },
    "ForceDelete":{"type":"boolean"},
    "GlobalTimeout":{"type":"integer"},
    "HealthCheckGracePeriod":{"type":"integer"},
    "HeartbeatTimeout":{"type":"integer"},
    "HonorCooldown":{"type":"boolean"},
    "Instance":{
      "type":"structure",
      "required":[
        "InstanceId",
        "AvailabilityZone",
        "LifecycleState",
        "HealthStatus",
        "LaunchConfigurationName",
        "ProtectedFromScaleIn"
      ],
      "members":{
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance.</p>"
        },
        "AvailabilityZone":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The Availability Zone in which the instance is running.</p>"
        },
        "LifecycleState":{
          "shape":"LifecycleState",
          "documentation":"<p>A description of the current lifecycle state. Note that the <code>Quarantined</code> state is not used.</p>"
        },
        "HealthStatus":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The health status of the instance. \"Healthy\" means that the instance is healthy and should remain in service. \"Unhealthy\" means that the instance is unhealthy and Auto Scaling should terminate and replace it.</p>"
        },
        "LaunchConfigurationName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The launch configuration associated with the instance.</p>"
        },
        "ProtectedFromScaleIn":{
          "shape":"InstanceProtected",
          "documentation":"<p>Indicates whether the instance is protected from termination by Auto Scaling when scaling in.</p>"
        }
      },
      "documentation":"<p>Describes an EC2 instance.</p>"
    },
    "InstanceIds":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen19"}
    },
    "InstanceMonitoring":{
      "type":"structure",
      "members":{
        "Enabled":{
          "shape":"MonitoringEnabled",
          "documentation":"<p>If <code>True</code>, instance monitoring is enabled.</p>"
        }
      },
      "documentation":"<p>Describes whether instance monitoring is enabled.</p>"
    },
    "InstanceProtected":{"type":"boolean"},
    "Instances":{
      "type":"list",
      "member":{"shape":"Instance"}
    },
    "InvalidNextToken":{
      "type":"structure",
      "members":{
        "message":{"shape":"XmlStringMaxLen255"}
      },
      "documentation":"<p>The <code>NextToken</code> value is not valid.</p>",
      "error":{
        "code":"InvalidNextToken",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "LaunchConfiguration":{
      "type":"structure",
      "required":[
        "LaunchConfigurationName",
        "ImageId",
        "InstanceType",
        "CreatedTime"
      ],
      "members":{
        "LaunchConfigurationName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the launch configuration.</p>"
        },
        "LaunchConfigurationARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the launch configuration.</p>"
        },
        "ImageId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of the Amazon Machine Image (AMI).</p>"
        },
        "KeyName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the key pair.</p>"
        },
        "SecurityGroups":{
          "shape":"SecurityGroups",
          "documentation":"<p>The security groups to associate with the instances.</p>"
        },
        "ClassicLinkVPCId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of a ClassicLink-enabled VPC to link your EC2-Classic instances to. This parameter can only be used if you are launching EC2-Classic instances. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html\">ClassicLink</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "ClassicLinkVPCSecurityGroups":{
          "shape":"ClassicLinkVPCSecurityGroups",
          "documentation":"<p>The IDs of one or more security groups for the VPC specified in <code>ClassicLinkVPCId</code>. This parameter is required if you specify a ClassicLink-enabled VPC, and cannot be used otherwise. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html\">ClassicLink</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "UserData":{
          "shape":"XmlStringUserData",
          "documentation":"<p>The user data available to the instances.</p>"
        },
        "InstanceType":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The instance type for the instances.</p>"
        },
        "KernelId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of the kernel associated with the AMI.</p>"
        },
        "RamdiskId":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of the RAM disk associated with the AMI.</p>"
        },
        "BlockDeviceMappings":{
          "shape":"BlockDeviceMappings",
          "documentation":"<p>A block device mapping, which specifies the block devices for the instance.</p>"
        },
        "InstanceMonitoring":{
          "shape":"InstanceMonitoring",
          "documentation":"<p>Controls whether instances in this group are launched with detailed monitoring.</p>"
        },
        "SpotPrice":{
          "shape":"SpotPrice",
          "documentation":"<p>The price to bid when launching Spot Instances.</p>"
        },
        "IamInstanceProfile":{
          "shape":"XmlStringMaxLen1600",
          "documentation":"<p>The name or Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instance.</p>"
        },
        "CreatedTime":{
          "shape":"TimestampType",
          "documentation":"<p>The creation date and time for the launch configuration.</p>"
        },
        "EbsOptimized":{
          "shape":"EbsOptimized",
          "documentation":"<p>Controls whether the instance is optimized for EBS I/O (<code>true</code>) or not (<code>false</code>).</p>"
        },
        "AssociatePublicIpAddress":{
          "shape":"AssociatePublicIpAddress",
          "documentation":"<p>[EC2-VPC] Indicates whether to assign a public IP address to each instance.</p>"
        },
        "PlacementTenancy":{
          "shape":"XmlStringMaxLen64",
          "documentation":"<p>The tenancy of the instance, either <code>default</code> or <code>dedicated</code>. An instance with <code>dedicated</code> tenancy runs in an isolated, single-tenant hardware and can only be launched into a VPC.</p>"
        }
      },
      "documentation":"<p>Describes a launch configuration.</p>"
    },
    "LaunchConfigurationNameType":{
      "type":"structure",
      "required":["LaunchConfigurationName"],
      "members":{
        "LaunchConfigurationName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the launch configuration.</p>"
        }
      }
    },
    "LaunchConfigurationNames":{
      "type":"list",
      "member":{"shape":"ResourceName"}
    },
    "LaunchConfigurationNamesType":{
      "type":"structure",
      "members":{
        "LaunchConfigurationNames":{
          "shape":"LaunchConfigurationNames",
          "documentation":"<p>The launch configuration names.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token for the next set of items to return. (You received this token from a previous call.)</p>"
        },
        "MaxRecords":{
          "shape":"MaxRecords",
          "documentation":"<p>The maximum number of items to return with this call. The default is 100.</p>"
        }
      }
    },
    "LaunchConfigurations":{
      "type":"list",
      "member":{"shape":"LaunchConfiguration"}
    },
    "LaunchConfigurationsType":{
      "type":"structure",
      "required":["LaunchConfigurations"],
      "members":{
        "LaunchConfigurations":{
          "shape":"LaunchConfigurations",
          "documentation":"<p>The launch configurations.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "LifecycleActionResult":{"type":"string"},
    "LifecycleActionToken":{
      "type":"string",
      "max":36,
      "min":36
    },
    "LifecycleHook":{
      "type":"structure",
      "members":{
        "LifecycleHookName":{
          "shape":"AsciiStringMaxLen255",
          "documentation":"<p>The name of the lifecycle hook.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group for the lifecycle hook.</p>"
        },
        "LifecycleTransition":{
          "shape":"LifecycleTransition",
          "documentation":"<p>The state of the EC2 instance to which you want to attach the lifecycle hook. For a list of lifecycle hook types, see <a>DescribeLifecycleHookTypes</a>.</p>"
        },
        "NotificationTargetARN":{
          "shape":"ResourceName",
          "documentation":"<p>The ARN of the notification target that Auto Scaling uses to notify you when an instance is in the transition state for the lifecycle hook. This ARN target can be either an SQS queue or an SNS topic. The notification message sent to the target includes the following:</p> <ul> <li>Lifecycle action token</li> <li>User account ID</li> <li>Name of the Auto Scaling group</li> <li>Lifecycle hook name</li> <li>EC2 instance ID</li> <li>Lifecycle transition</li> <li>Notification metadata</li> </ul>"
        },
        "RoleARN":{
          "shape":"ResourceName",
          "documentation":"<p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target.</p>"
        },
        "NotificationMetadata":{
          "shape":"XmlStringMaxLen1023",
          "documentation":"<p>Additional information that you want to include any time Auto Scaling sends a message to the notification target.</p>"
        },
        "HeartbeatTimeout":{
          "shape":"HeartbeatTimeout",
          "documentation":"<p>The maximum time, in seconds, that can elapse before the lifecycle hook times out. The default is 3600 seconds (1 hour). When the lifecycle hook times out, Auto Scaling performs the default action. You can prevent the lifecycle hook from timing out by calling <a>RecordLifecycleActionHeartbeat</a>.</p>"
        },
        "GlobalTimeout":{
          "shape":"GlobalTimeout",
          "documentation":"<p>The maximum time, in seconds, that an instance can remain in a <code>Pending:Wait</code> or <code>Terminating:Wait</code> state. The default is 172800 seconds (48 hours).</p>"
        },
        "DefaultResult":{
          "shape":"LifecycleActionResult",
          "documentation":"<p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses or if an unexpected failure occurs. The valid values are <code>CONTINUE</code> and <code>ABANDON</code>. The default value is <code>CONTINUE</code>.</p>"
        }
      },
      "documentation":"<p>Describes a lifecycle hook, which tells Auto Scaling that you want to perform an action when an instance launches or terminates. When you have a lifecycle hook in place, the Auto Scaling group will either:</p> <ul> <li>Pause the instance after it launches, but before it is put into service</li> <li>Pause the instance as it terminates, but before it is fully terminated</li> </ul> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html\">Auto Scaling Lifecycle</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "LifecycleHookNames":{
      "type":"list",
      "member":{"shape":"AsciiStringMaxLen255"}
    },
    "LifecycleHooks":{
      "type":"list",
      "member":{"shape":"LifecycleHook"}
    },
    "LifecycleState":{
      "type":"string",
      "enum":[
        "Pending",
        "Pending:Wait",
        "Pending:Proceed",
        "Quarantined",
        "InService",
        "Terminating",
        "Terminating:Wait",
        "Terminating:Proceed",
        "Terminated",
        "Detaching",
        "Detached",
        "EnteringStandby",
        "Standby"
      ]
    },
    "LifecycleTransition":{"type":"string"},
    "LimitExceededFault":{
      "type":"structure",
      "members":{
        "message":{"shape":"XmlStringMaxLen255"}
      },
      "documentation":"<p>You have already reached a limit for your Auto Scaling resources (for example, groups, launch configurations, or lifecycle hooks). For more information, see <a>DescribeAccountLimits</a>.</p>",
      "error":{
        "code":"LimitExceeded",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "LoadBalancerNames":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen255"}
    },
    "LoadBalancerState":{
      "type":"structure",
      "members":{
        "LoadBalancerName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the load balancer.</p>"
        },
        "State":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>One of the following load balancer states:</p> <ul> <li><p><code>Adding</code> - The instances in the group are being registered with the load balancer.</p></li> <li><p><code>Added</code> - All instances in the group are registered with the load balancer.</p></li> <li><p><code>InService</code> - At least one instance in the group passed an ELB health check.</p></li> <li><p><code>Removing</code> - The instances are being deregistered from the load balancer. If connection draining is enabled, Elastic Load Balancing waits for in-flight requests to complete before deregistering the instances.</p></li> </ul>"
        }
      },
      "documentation":"<p>Describes the state of a load balancer.</p>"
    },
    "LoadBalancerStates":{
      "type":"list",
      "member":{"shape":"LoadBalancerState"}
    },
    "MaxNumberOfAutoScalingGroups":{"type":"integer"},
    "MaxNumberOfLaunchConfigurations":{"type":"integer"},
    "MaxRecords":{"type":"integer"},
    "MetricCollectionType":{
      "type":"structure",
      "members":{
        "Metric":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>One of the following metrics:</p> <ul> <li><p><code>GroupMinSize</code></p></li> <li><p><code>GroupMaxSize</code></p></li> <li><p><code>GroupDesiredCapacity</code></p></li> <li><p><code>GroupInServiceInstances</code></p></li> <li><p><code>GroupPendingInstances</code></p></li> <li><p><code>GroupStandbyInstances</code></p></li> <li><p><code>GroupTerminatingInstances</code></p></li> <li><p><code>GroupTotalInstances</code></p></li> </ul>"
        }
      },
      "documentation":"<p>Describes a metric.</p>"
    },
    "MetricCollectionTypes":{
      "type":"list",
      "member":{"shape":"MetricCollectionType"}
    },
    "MetricGranularityType":{
      "type":"structure",
      "members":{
        "Granularity":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The granularity. The only valid value is <code>1Minute</code>.</p>"
        }
      },
      "documentation":"<p>Describes a granularity of a metric.</p>"
    },
    "MetricGranularityTypes":{
      "type":"list",
      "member":{"shape":"MetricGranularityType"}
    },
    "MetricScale":{"type":"double"},
    "Metrics":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen255"}
    },
    "MinAdjustmentMagnitude":{"type":"integer"},
    "MinAdjustmentStep":{
      "type":"integer",
      "deprecated":true
    },
    "MonitoringEnabled":{"type":"boolean"},
    "NoDevice":{"type":"boolean"},
    "NotificationConfiguration":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "TopicARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic.</p>"
        },
        "NotificationType":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>One of the following event notification types:</p> <ul> <li><p><code>autoscaling:EC2_INSTANCE_LAUNCH</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_LAUNCH_ERROR</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_TERMINATE</code></p></li> <li><p><code>autoscaling:EC2_INSTANCE_TERMINATE_ERROR</code></p></li> <li><p><code>autoscaling:TEST_NOTIFICATION</code></p></li> </ul>"
        }
      },
      "documentation":"<p>Describes a notification.</p>"
    },
    "NotificationConfigurations":{
      "type":"list",
      "member":{"shape":"NotificationConfiguration"}
    },
    "NotificationTargetResourceName":{
      "type":"string",
      "max":1600,
      "min":0,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "NumberOfAutoScalingGroups":{"type":"integer"},
    "NumberOfLaunchConfigurations":{"type":"integer"},
    "PoliciesType":{
      "type":"structure",
      "members":{
        "ScalingPolicies":{
          "shape":"ScalingPolicies",
          "documentation":"<p>The scaling policies.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "PolicyARNType":{
      "type":"structure",
      "members":{
        "PolicyARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the policy.</p>"
        }
      }
    },
    "PolicyIncrement":{"type":"integer"},
    "PolicyNames":{
      "type":"list",
      "member":{"shape":"ResourceName"}
    },
    "PolicyTypes":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen64"}
    },
    "ProcessNames":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen255"}
    },
    "ProcessType":{
      "type":"structure",
      "required":["ProcessName"],
      "members":{
        "ProcessName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>One of the following processes:</p> <ul> <li><p><code>Launch</code></p></li> <li><p><code>Terminate</code></p></li> <li><p><code>AddToLoadBalancer</code></p></li> <li><p><code>AlarmNotification</code></p></li> <li><p><code>AZRebalance</code></p></li> <li><p><code>HealthCheck</code></p></li> <li><p><code>ReplaceUnhealthy</code></p></li> <li><p><code>ScheduledActions</code></p></li> </ul>"
        }
      },
      "documentation":"<p>Describes a process type.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/US_SuspendResume.html#process-types\">Auto Scaling Processes</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
    },
    "Processes":{
      "type":"list",
      "member":{"shape":"ProcessType"}
    },
    "ProcessesType":{
      "type":"structure",
      "members":{
        "Processes":{
          "shape":"Processes",
          "documentation":"<p>The names of the process types.</p>"
        }
      }
    },
    "Progress":{"type":"integer"},
    "PropagateAtLaunch":{"type":"boolean"},
    "ProtectedFromScaleIn":{"type":"boolean"},
    "PutLifecycleHookAnswer":{
      "type":"structure",
      "members":{
      }
    },
    "PutLifecycleHookType":{
      "type":"structure",
      "required":[
        "LifecycleHookName",
        "AutoScalingGroupName"
      ],
      "members":{
        "LifecycleHookName":{
          "shape":"AsciiStringMaxLen255",
          "documentation":"<p>The name of the lifecycle hook.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group to which you want to assign the lifecycle hook.</p>"
        },
        "LifecycleTransition":{
          "shape":"LifecycleTransition",
          "documentation":"<p>The instance state to which you want to attach the lifecycle hook. For a list of lifecycle hook types, see <a>DescribeLifecycleHookTypes</a>.</p> <p>This parameter is required for new lifecycle hooks, but optional when updating existing hooks.</p>"
        },
        "RoleARN":{
          "shape":"ResourceName",
          "documentation":"<p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target.</p> <p>This parameter is required for new lifecycle hooks, but optional when updating existing hooks.</p>"
        },
        "NotificationTargetARN":{
          "shape":"NotificationTargetResourceName",
          "documentation":"<p>The ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an SQS queue or an SNS topic. If you specify an empty string, this overrides the current ARN.</p> <p>The notification messages sent to the target include the following information:</p> <ul> <li><b>AutoScalingGroupName</b>. The name of the Auto Scaling group.</li> <li><b>AccountId</b>. The AWS account ID.</li> <li><b>LifecycleTransition</b>. The lifecycle hook type.</li> <li><b>LifecycleActionToken</b>. The lifecycle action token.</li> <li><b>EC2InstanceId</b>. The EC2 instance ID.</li> <li><b>LifecycleHookName</b>. The name of the lifecycle hook.</li> <li><b>NotificationMetadata</b>. User-defined information.</li> </ul> <p>This operation uses the JSON format when sending notifications to an Amazon SQS queue, and an email key/value pair format when sending notifications to an Amazon SNS topic.</p> <p>When you specify a notification target, Auto Scaling sends it a test message. Test messages contains the following additional key/value pair: <code>\"Event\": \"autoscaling:TEST_NOTIFICATION\"</code>.</p>"
        },
        "NotificationMetadata":{
          "shape":"XmlStringMaxLen1023",
          "documentation":"<p>Contains additional information that you want to include any time Auto Scaling sends a message to the notification target.</p>"
        },
        "HeartbeatTimeout":{
          "shape":"HeartbeatTimeout",
          "documentation":"<p>The amount of time, in seconds, that can elapse before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the default action. You can prevent the lifecycle hook from timing out by calling <a>RecordLifecycleActionHeartbeat</a>. The default is 3600 seconds (1 hour).</p>"
        },
        "DefaultResult":{
          "shape":"LifecycleActionResult",
          "documentation":"<p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses or if an unexpected failure occurs. This parameter can be either <code>CONTINUE</code> or <code>ABANDON</code>. The default value is <code>ABANDON</code>.</p>"
        }
      }
    },
    "PutNotificationConfigurationType":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "TopicARN",
        "NotificationTypes"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "TopicARN":{
          "shape":"ResourceName",
          "documentation":"<p> The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic. </p>"
        },
        "NotificationTypes":{
          "shape":"AutoScalingNotificationTypes",
          "documentation":"<p>The type of event that will cause the notification to be sent. For details about notification types supported by Auto Scaling, see <a>DescribeAutoScalingNotificationTypes</a>.</p>"
        }
      }
    },
    "PutScalingPolicyType":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "PolicyName",
        "AdjustmentType"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or ARN of the group.</p>"
        },
        "PolicyName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the policy.</p>"
        },
        "PolicyType":{
          "shape":"XmlStringMaxLen64",
          "documentation":"<p>The policy type. Valid values are <code>SimpleScaling</code> and <code>StepScaling</code>. If the policy type is null, the value is treated as <code>SimpleScaling</code>.</p>"
        },
        "AdjustmentType":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The adjustment type. Valid values are <code>ChangeInCapacity</code>, <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-scale-based-on-demand.html\">Dynamic Scaling</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "MinAdjustmentStep":{
          "shape":"MinAdjustmentStep",
          "documentation":"<p>Available for backward compatibility. Use <code>MinAdjustmentMagnitude</code> instead.</p>"
        },
        "MinAdjustmentMagnitude":{
          "shape":"MinAdjustmentMagnitude",
          "documentation":"<p>The minimum number of instances to scale. If the value of <code>AdjustmentType</code> is <code>PercentChangeInCapacity</code>, the scaling policy changes the <code>DesiredCapacity</code> of the Auto Scaling group by at least this many instances. Otherwise, the error is <code>ValidationError</code>.</p>"
        },
        "ScalingAdjustment":{
          "shape":"PolicyIncrement",
          "documentation":"<p>The amount by which to scale, based on the specified adjustment type. A positive value adds to the current capacity while a negative number removes from the current capacity.</p> <p>This parameter is required if the policy type is <code>SimpleScaling</code> and not supported otherwise.</p>"
        },
        "Cooldown":{
          "shape":"Cooldown",
          "documentation":"<p>The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.</p> <p>This parameter is not supported unless the policy type is <code>SimpleScaling</code>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/Cooldown.html\">Auto Scaling Cooldowns</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "MetricAggregationType":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The aggregation type for the CloudWatch metrics. Valid values are <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code>. If the aggregation type is null, the value is treated as <code>Average</code>.</p> <p>This parameter is not supported if the policy type is <code>SimpleScaling</code>.</p>"
        },
        "StepAdjustments":{
          "shape":"StepAdjustments",
          "documentation":"<p>A set of adjustments that enable you to scale based on the size of the alarm breach.</p> <p>This parameter is required if the policy type is <code>StepScaling</code> and not supported otherwise.</p>"
        },
        "EstimatedInstanceWarmup":{
          "shape":"EstimatedInstanceWarmup",
          "documentation":"<p>The estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics. The default is to use the value specified for the default cooldown period for the group.</p> <p>This parameter is not supported if the policy type is <code>SimpleScaling</code>.</p>"
        }
      }
    },
    "PutScheduledUpdateGroupActionType":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "ScheduledActionName"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or Amazon Resource Name (ARN) of the Auto Scaling group.</p>"
        },
        "ScheduledActionName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of this scaling action.</p>"
        },
        "Time":{
          "shape":"TimestampType",
          "documentation":"<p>This parameter is deprecated.</p>"
        },
        "StartTime":{
          "shape":"TimestampType",
          "documentation":"<p>The time for this action to start, in \"YYYY-MM-DDThh:mm:ssZ\" format in UTC/GMT only (for example, <code>2014-06-01T00:00:00Z</code>).</p> <p>If you try to schedule your action in the past, Auto Scaling returns an error message. </p> <p>When <code>StartTime</code> and <code>EndTime</code> are specified with <code>Recurrence</code>, they form the boundaries of when the recurring action starts and stops.</p>"
        },
        "EndTime":{
          "shape":"TimestampType",
          "documentation":"<p>The time for this action to end.</p>"
        },
        "Recurrence":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The time when recurring future actions will start. Start time is specified by the user following the Unix cron syntax format. For more information, see <a href=\"http://en.wikipedia.org/wiki/Cron\">Cron</a> in Wikipedia.</p> <p>When <code>StartTime</code> and <code>EndTime</code> are specified with <code>Recurrence</code>, they form the boundaries of when the recurring action will start and stop.</p>"
        },
        "MinSize":{
          "shape":"AutoScalingGroupMinSize",
          "documentation":"<p> The minimum size for the Auto Scaling group. </p>"
        },
        "MaxSize":{
          "shape":"AutoScalingGroupMaxSize",
          "documentation":"<p> The maximum size for the Auto Scaling group. </p>"
        },
        "DesiredCapacity":{
          "shape":"AutoScalingGroupDesiredCapacity",
          "documentation":"<p> The number of EC2 instances that should be running in the group. </p>"
        }
      }
    },
    "RecordLifecycleActionHeartbeatAnswer":{
      "type":"structure",
      "members":{
      }
    },
    "RecordLifecycleActionHeartbeatType":{
      "type":"structure",
      "required":[
        "LifecycleHookName",
        "AutoScalingGroupName"
      ],
      "members":{
        "LifecycleHookName":{
          "shape":"AsciiStringMaxLen255",
          "documentation":"<p>The name of the lifecycle hook.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group for the hook.</p>"
        },
        "LifecycleActionToken":{
          "shape":"LifecycleActionToken",
          "documentation":"<p>A token that uniquely identifies a specific lifecycle action associated with an instance. Auto Scaling sends this token to the notification target you specified when you created the lifecycle hook.</p>"
        },
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance.</p>"
        }
      }
    },
    "ResourceContentionFault":{
      "type":"structure",
      "members":{
        "message":{"shape":"XmlStringMaxLen255"}
      },
      "documentation":"<p>You already have a pending update to an Auto Scaling resource (for example, a group, instance, or load balancer).</p>",
      "error":{
        "code":"ResourceContention",
        "httpStatusCode":500,
        "senderFault":true
      },
      "exception":true
    },
    "ResourceInUseFault":{
      "type":"structure",
      "members":{
        "message":{"shape":"XmlStringMaxLen255"}
      },
      "documentation":"<p>The Auto Scaling group or launch configuration can't be deleted because it is in use.</p>",
      "error":{
        "code":"ResourceInUse",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "ResourceName":{
      "type":"string",
      "max":1600,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "ScalingActivityInProgressFault":{
      "type":"structure",
      "members":{
        "message":{"shape":"XmlStringMaxLen255"}
      },
      "documentation":"<p>The Auto Scaling group can't be deleted because there are scaling activities in progress.</p>",
      "error":{
        "code":"ScalingActivityInProgress",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "ScalingActivityStatusCode":{
      "type":"string",
      "enum":[
        "PendingSpotBidPlacement",
        "WaitingForSpotInstanceRequestId",
        "WaitingForSpotInstanceId",
        "WaitingForInstanceId",
        "PreInService",
        "InProgress",
        "WaitingForELBConnectionDraining",
        "MidLifecycleAction",
        "WaitingForInstanceWarmup",
        "Successful",
        "Failed",
        "Cancelled"
      ]
    },
    "ScalingPolicies":{
      "type":"list",
      "member":{"shape":"ScalingPolicy"}
    },
    "ScalingPolicy":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the Auto Scaling group associated with this scaling policy.</p>"
        },
        "PolicyName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the scaling policy.</p>"
        },
        "PolicyARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the policy.</p>"
        },
        "PolicyType":{
          "shape":"XmlStringMaxLen64",
          "documentation":"<p>The policy type. Valid values are <code>SimpleScaling</code> and <code>StepScaling</code>.</p>"
        },
        "AdjustmentType":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The adjustment type, which specifies how <code>ScalingAdjustment</code> is interpreted. Valid values are <code>ChangeInCapacity</code>, <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>"
        },
        "MinAdjustmentStep":{
          "shape":"MinAdjustmentStep",
          "documentation":"<p>Available for backward compatibility. Use <code>MinAdjustmentMagnitude</code> instead.</p>"
        },
        "MinAdjustmentMagnitude":{
          "shape":"MinAdjustmentMagnitude",
          "documentation":"<p>The minimum number of instances to scale. If the value of <code>AdjustmentType</code> is <code>PercentChangeInCapacity</code>, the scaling policy changes the <code>DesiredCapacity</code> of the Auto Scaling group by at least this many instances. Otherwise, the error is <code>ValidationError</code>.</p>"
        },
        "ScalingAdjustment":{
          "shape":"PolicyIncrement",
          "documentation":"<p>The amount by which to scale, based on the specified adjustment type. A positive value adds to the current capacity while a negative number removes from the current capacity.</p>"
        },
        "Cooldown":{
          "shape":"Cooldown",
          "documentation":"<p>The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.</p>"
        },
        "StepAdjustments":{
          "shape":"StepAdjustments",
          "documentation":"<p>A set of adjustments that enable you to scale based on the size of the alarm breach.</p>"
        },
        "MetricAggregationType":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The aggregation type for the CloudWatch metrics. Valid values are <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code>.</p>"
        },
        "EstimatedInstanceWarmup":{
          "shape":"EstimatedInstanceWarmup",
          "documentation":"<p>The estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics.</p>"
        },
        "Alarms":{
          "shape":"Alarms",
          "documentation":"<p>The CloudWatch alarms related to the policy.</p>"
        }
      },
      "documentation":"<p>Describes a scaling policy.</p>"
    },
    "ScalingProcessQuery":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name or Amazon Resource Name (ARN) of the Auto Scaling group.</p>"
        },
        "ScalingProcesses":{
          "shape":"ProcessNames",
          "documentation":"<p>One or more of the following processes:</p> <ul> <li><p><code>Launch</code></p></li> <li><p><code>Terminate</code></p></li> <li><p><code>HealthCheck</code></p></li> <li><p><code>ReplaceUnhealthy</code></p></li> <li><p><code>AZRebalance</code></p></li> <li><p><code>AlarmNotification</code></p></li> <li><p><code>ScheduledActions</code></p></li> <li><p><code>AddToLoadBalancer</code></p></li> </ul>"
        }
      }
    },
    "ScheduledActionNames":{
      "type":"list",
      "member":{"shape":"ResourceName"}
    },
    "ScheduledActionsType":{
      "type":"structure",
      "members":{
        "ScheduledUpdateGroupActions":{
          "shape":"ScheduledUpdateGroupActions",
          "documentation":"<p>The scheduled actions.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "ScheduledUpdateGroupAction":{
      "type":"structure",
      "members":{
        "AutoScalingGroupName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the group.</p>"
        },
        "ScheduledActionName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the scheduled action.</p>"
        },
        "ScheduledActionARN":{
          "shape":"ResourceName",
          "documentation":"<p>The Amazon Resource Name (ARN) of the scheduled action.</p>"
        },
        "Time":{
          "shape":"TimestampType",
          "documentation":"<p>This parameter is deprecated.</p>"
        },
        "StartTime":{
          "shape":"TimestampType",
          "documentation":"<p>The date and time that the action is scheduled to begin. This date and time can be up to one month in the future.</p> <p>When <code>StartTime</code> and <code>EndTime</code> are specified with <code>Recurrence</code>, they form the boundaries of when the recurring action will start and stop.</p>"
        },
        "EndTime":{
          "shape":"TimestampType",
          "documentation":"<p>The date and time that the action is scheduled to end. This date and time can be up to one month in the future.</p>"
        },
        "Recurrence":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The recurring schedule for the action.</p>"
        },
        "MinSize":{
          "shape":"AutoScalingGroupMinSize",
          "documentation":"<p>The minimum size of the group.</p>"
        },
        "MaxSize":{
          "shape":"AutoScalingGroupMaxSize",
          "documentation":"<p>The maximum size of the group.</p>"
        },
        "DesiredCapacity":{
          "shape":"AutoScalingGroupDesiredCapacity",
          "documentation":"<p>The number of instances you prefer to maintain in the group.</p>"
        }
      },
      "documentation":"<p>Describes a scheduled update to an Auto Scaling group.</p>"
    },
    "ScheduledUpdateGroupActions":{
      "type":"list",
      "member":{"shape":"ScheduledUpdateGroupAction"}
    },
    "SecurityGroups":{
      "type":"list",
      "member":{"shape":"XmlString"}
    },
    "SetDesiredCapacityType":{
      "type":"structure",
      "required":[
        "AutoScalingGroupName",
        "DesiredCapacity"
      ],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "DesiredCapacity":{
          "shape":"AutoScalingGroupDesiredCapacity",
          "documentation":"<p>The number of EC2 instances that should be running in the Auto Scaling group.</p>"
        },
        "HonorCooldown":{
          "shape":"HonorCooldown",
          "documentation":"<p>By default, <code>SetDesiredCapacity</code> overrides any cooldown period associated with the Auto Scaling group. Specify <code>True</code> to make Auto Scaling to wait for the cool-down period associated with the Auto Scaling group to complete before initiating a scaling activity to set your Auto Scaling group to its new capacity.</p>"
        }
      }
    },
    "SetInstanceHealthQuery":{
      "type":"structure",
      "required":[
        "InstanceId",
        "HealthStatus"
      ],
      "members":{
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance.</p>"
        },
        "HealthStatus":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p> The health status of the instance. Set to <code>Healthy</code> if you want the instance to remain in service. Set to <code>Unhealthy</code> if you want the instance to be out of service. Auto Scaling will terminate and replace the unhealthy instance. </p>"
        },
        "ShouldRespectGracePeriod":{
          "shape":"ShouldRespectGracePeriod",
          "documentation":"<p>If the Auto Scaling group of the specified instance has a <code>HealthCheckGracePeriod</code> specified for the group, by default, this call will respect the grace period. Set this to <code>False</code>, if you do not want the call to respect the grace period associated with the group.</p> <p>For more information, see the description of the health check grace period for <a>CreateAutoScalingGroup</a>.</p>"
        }
      }
    },
    "SetInstanceProtectionAnswer":{
      "type":"structure",
      "members":{
      }
    },
    "SetInstanceProtectionQuery":{
      "type":"structure",
      "required":[
        "InstanceIds",
        "AutoScalingGroupName",
        "ProtectedFromScaleIn"
      ],
      "members":{
        "InstanceIds":{
          "shape":"InstanceIds",
          "documentation":"<p>One or more instance IDs.</p>"
        },
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the group.</p>"
        },
        "ProtectedFromScaleIn":{
          "shape":"ProtectedFromScaleIn",
          "documentation":"<p>Indicates whether the instance is protected from termination by Auto Scaling when scaling in.</p>"
        }
      }
    },
    "ShouldDecrementDesiredCapacity":{"type":"boolean"},
    "ShouldRespectGracePeriod":{"type":"boolean"},
    "SpotPrice":{
      "type":"string",
      "max":255,
      "min":1
    },
    "StepAdjustment":{
      "type":"structure",
      "required":["ScalingAdjustment"],
      "members":{
        "MetricIntervalLowerBound":{
          "shape":"MetricScale",
          "documentation":"<p>The lower bound for the difference between the alarm threshold and the CloudWatch metric. If the metric value is above the breach threshold, the lower bound is inclusive (the metric must be greater than or equal to the threshold plus the lower bound). Otherwise, it is exclusive (the metric must be greater than the threshold plus the lower bound). A null value indicates negative infinity.</p>"
        },
        "MetricIntervalUpperBound":{
          "shape":"MetricScale",
          "documentation":"<p>The upper bound for the difference between the alarm threshold and the CloudWatch metric. If the metric value is above the breach threshold, the upper bound is exclusive (the metric must be less than the threshold plus the upper bound). Otherwise, it is inclusive (the metric must be less than or equal to the threshold plus the upper bound). A null value indicates positive infinity.</p> <p>The upper bound must be greater than the lower bound.</p>"
        },
        "ScalingAdjustment":{
          "shape":"PolicyIncrement",
          "documentation":"<p>The amount by which to scale, based on the specified adjustment type. A positive value adds to the current capacity while a negative number removes from the current capacity.</p>"
        }
      },
      "documentation":"<p>Describes an adjustment based on the difference between the value of the aggregated CloudWatch metric and the breach threshold that you've defined for the alarm.</p> <p>For the following examples, suppose that you have an alarm with a breach threshold of 50:</p> <ul> <li> <p>If you want the adjustment to be triggered when the metric is greater than or equal to 50 and less than 60, specify a lower bound of 0 and an upper bound of 10.</p> </li> <li> <p>If you want the adjustment to be triggered when the metric is greater than 40 and less than or equal to 50, specify a lower bound of -10 and an upper bound of 0.</p> </li> </ul> <p>There are a few rules for the step adjustments for your step policy:</p> <ul> <li> <p>The ranges of your step adjustments can't overlap or have a gap.</p> </li> <li> <p>At most one step adjustment can have a null lower bound. If one step adjustment has a negative lower bound, then there must be a step adjustment with a null lower bound.</p> </li> <li> <p>At most one step adjustment can have a null upper bound. If one step adjustment has a positive upper bound, then there must be a step adjustment with a null upper bound.</p> </li> <li> <p>The upper and lower bound can't be null in the same step adjustment.</p> </li> </ul>"
    },
    "StepAdjustments":{
      "type":"list",
      "member":{"shape":"StepAdjustment"}
    },
    "SuspendedProcess":{
      "type":"structure",
      "members":{
        "ProcessName":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the suspended process.</p>"
        },
        "SuspensionReason":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The reason that the process was suspended.</p>"
        }
      },
      "documentation":"<p>Describes an Auto Scaling process that has been suspended. For more information, see <a>ProcessType</a>.</p>"
    },
    "SuspendedProcesses":{
      "type":"list",
      "member":{"shape":"SuspendedProcess"}
    },
    "Tag":{
      "type":"structure",
      "required":["Key"],
      "members":{
        "ResourceId":{
          "shape":"XmlString",
          "documentation":"<p>The name of the group.</p>"
        },
        "ResourceType":{
          "shape":"XmlString",
          "documentation":"<p>The type of resource. The only supported value is <code>auto-scaling-group</code>.</p>"
        },
        "Key":{
          "shape":"TagKey",
          "documentation":"<p>The tag key.</p>"
        },
        "Value":{
          "shape":"TagValue",
          "documentation":"<p>The tag value.</p>"
        },
        "PropagateAtLaunch":{
          "shape":"PropagateAtLaunch",
          "documentation":"<p>Determines whether the tag is added to new instances as they are launched in the group.</p>"
        }
      },
      "documentation":"<p>Describes a tag for an Auto Scaling group.</p>"
    },
    "TagDescription":{
      "type":"structure",
      "members":{
        "ResourceId":{
          "shape":"XmlString",
          "documentation":"<p>The name of the group.</p>"
        },
        "ResourceType":{
          "shape":"XmlString",
          "documentation":"<p>The type of resource. The only supported value is <code>auto-scaling-group</code>.</p>"
        },
        "Key":{
          "shape":"TagKey",
          "documentation":"<p>The tag key.</p>"
        },
        "Value":{
          "shape":"TagValue",
          "documentation":"<p>The tag value.</p>"
        },
        "PropagateAtLaunch":{
          "shape":"PropagateAtLaunch",
          "documentation":"<p>Determines whether the tag is added to new instances as they are launched in the group.</p>"
        }
      },
      "documentation":"<p>Describes a tag for an Auto Scaling group.</p>"
    },
    "TagDescriptionList":{
      "type":"list",
      "member":{"shape":"TagDescription"}
    },
    "TagKey":{
      "type":"string",
      "max":128,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "TagValue":{
      "type":"string",
      "max":256,
      "min":0,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "Tags":{
      "type":"list",
      "member":{"shape":"Tag"}
    },
    "TagsType":{
      "type":"structure",
      "members":{
        "Tags":{
          "shape":"TagDescriptionList",
          "documentation":"<p>One or more tags.</p>"
        },
        "NextToken":{
          "shape":"XmlString",
          "documentation":"<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"
        }
      }
    },
    "TerminateInstanceInAutoScalingGroupType":{
      "type":"structure",
      "required":[
        "InstanceId",
        "ShouldDecrementDesiredCapacity"
      ],
      "members":{
        "InstanceId":{
          "shape":"XmlStringMaxLen19",
          "documentation":"<p>The ID of the instance.</p>"
        },
        "ShouldDecrementDesiredCapacity":{
          "shape":"ShouldDecrementDesiredCapacity",
          "documentation":"<p>If <code>true</code>, terminating the instance also decrements the size of the Auto Scaling group.</p>"
        }
      }
    },
    "TerminationPolicies":{
      "type":"list",
      "member":{"shape":"XmlStringMaxLen1600"}
    },
    "TimestampType":{"type":"timestamp"},
    "UpdateAutoScalingGroupType":{
      "type":"structure",
      "required":["AutoScalingGroupName"],
      "members":{
        "AutoScalingGroupName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the Auto Scaling group.</p>"
        },
        "LaunchConfigurationName":{
          "shape":"ResourceName",
          "documentation":"<p>The name of the launch configuration.</p>"
        },
        "MinSize":{
          "shape":"AutoScalingGroupMinSize",
          "documentation":"<p>The minimum size of the Auto Scaling group.</p>"
        },
        "MaxSize":{
          "shape":"AutoScalingGroupMaxSize",
          "documentation":"<p>The maximum size of the Auto Scaling group.</p>"
        },
        "DesiredCapacity":{
          "shape":"AutoScalingGroupDesiredCapacity",
          "documentation":"<p>The number of EC2 instances that should be running in the Auto Scaling group. This number must be greater than or equal to the minimum size of the group and less than or equal to the maximum size of the group.</p>"
        },
        "DefaultCooldown":{
          "shape":"Cooldown",
          "documentation":"<p>The amount of time, in seconds, after a scaling activity completes before another scaling activity can start. The default is 300.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/Cooldown.html\">Auto Scaling Cooldowns</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "AvailabilityZones":{
          "shape":"AvailabilityZones",
          "documentation":"<p>One or more Availability Zones for the group.</p>"
        },
        "HealthCheckType":{
          "shape":"XmlStringMaxLen32",
          "documentation":"<p>The service to use for the health checks. The valid values are <code>EC2</code> and <code>ELB</code>.</p>"
        },
        "HealthCheckGracePeriod":{
          "shape":"HealthCheckGracePeriod",
          "documentation":"<p>The amount of time, in seconds, that Auto Scaling waits before checking the health status of an EC2 instance that has come into service. The default is 300.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/healthcheck.html\">Health Checks</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "PlacementGroup":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The name of the placement group into which you'll launch your instances, if any. For more information, see <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html\">Placement Groups</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"
        },
        "VPCZoneIdentifier":{
          "shape":"XmlStringMaxLen255",
          "documentation":"<p>The ID of the subnet, if you are launching into a VPC. You can specify several subnets in a comma-separated list.</p> <p>When you specify <code>VPCZoneIdentifier</code> with <code>AvailabilityZones</code>, ensure that the subnets' Availability Zones match the values you specify for <code>AvailabilityZones</code>.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/asg-in-vpc.html\">Launching Auto Scaling Instances in a VPC</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "TerminationPolicies":{
          "shape":"TerminationPolicies",
          "documentation":"<p>A standalone termination policy or a list of termination policies used to select the instance to terminate. The policies are executed in the order that they are listed.</p> <p>For more information, see <a href=\"http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingBehavior.InstanceTermination.html\">Controlling Which Instances Auto Scaling Terminates During Scale In</a> in the <i>Auto Scaling Developer Guide</i>.</p>"
        },
        "NewInstancesProtectedFromScaleIn":{
          "shape":"InstanceProtected",
          "documentation":"<p>Indicates whether newly launched instances are protected from termination by Auto Scaling when scaling in.</p>"
        }
      }
    },
    "Values":{
      "type":"list",
      "member":{"shape":"XmlString"}
    },
    "XmlString":{
      "type":"string",
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringMaxLen1023":{
      "type":"string",
      "max":1023,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringMaxLen1600":{
      "type":"string",
      "max":1600,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringMaxLen19":{
      "type":"string",
      "max":19,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringMaxLen255":{
      "type":"string",
      "max":255,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringMaxLen32":{
      "type":"string",
      "max":32,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringMaxLen64":{
      "type":"string",
      "max":64,
      "min":1,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    },
    "XmlStringUserData":{
      "type":"string",
      "max":21847,
      "pattern":"[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
    }
  },
  "documentation":"<fullname>Auto Scaling</fullname> <p>Auto Scaling is designed to automatically launch or terminate EC2 instances based on user-defined policies, schedules, and health checks. Use this service in conjunction with the Amazon CloudWatch and Elastic Load Balancing services.</p>"
}
                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/lib/python2.7/dist-packages/botocore/data/cloudformation/                                 0042755 0000000 0000062 00000000000 13077704402 024000  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/cloudformation/2010-05-15/                      0042755 0000000 0000062 00000000000 13077704402 025027  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/cloudformation/2010-05-15/paginators-1.json     0100644 0000000 0000062 00000001077 13077704371 030234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "pagination": {
    "DescribeStackEvents": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "result_key": "StackEvents"
    },
    "DescribeStacks": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "result_key": "Stacks"
    },
    "ListStackResources": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "result_key": "StackResourceSummaries"
    },
    "ListStacks": {
      "input_token": "NextToken",
      "output_token": "NextToken",
      "result_key": "StackSummaries"
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/python2.7/dist-packages/botocore/data/cloudformation/2010-05-15/service-2.json        0100644 0000000 0000062 00000225361 13077704371 027532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2010-05-15",
    "endpointPrefix":"cloudformation",
    "protocol":"query",
    "serviceFullName":"AWS CloudFormation",
    "signatureVersion":"v4",
    "xmlNamespace":"http://cloudformation.amazonaws.com/doc/2010-05-15/"
  },
  "operations":{
    "CancelUpdateStack":{
      "name":"CancelUpdateStack",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CancelUpdateStackInput"},
      "documentation":"<p>Cancels an update on the specified stack. If the call completes successfully, the stack rolls back the update and reverts to the previous stack configuration.</p> <note>You can cancel only stacks that are in the UPDATE_IN_PROGRESS state.</note>"
    },
    "ContinueUpdateRollback":{
      "name":"ContinueUpdateRollback",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ContinueUpdateRollbackInput"},
      "output":{
        "shape":"ContinueUpdateRollbackOutput",
        "resultWrapper":"ContinueUpdateRollbackResult"
      },
      "documentation":"<p>For a specified stack that is in the <code>UPDATE_ROLLBACK_FAILED</code> state, continues rolling it back to the <code>UPDATE_ROLLBACK_COMPLETE</code> state. Depending on the cause of the failure, you can manually <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/troubleshooting.html#troubleshooting-errors-update-rollback-failed\"> fix the error</a> and continue the rollback. By continuing the rollback, you can return your stack to a working state (the <code>UPDATE_ROLLBACK_COMPLETE</code> state), and then try to update the stack again.</p> <p>A stack goes into the <code>UPDATE_ROLLBACK_FAILED</code> state when AWS CloudFormation cannot roll back all changes after a failed stack update. For example, you might have a stack that is rolling back to an old database instance that was deleted outside of AWS CloudFormation. Because AWS CloudFormation doesn't know the database was deleted, it assumes that the database instance still exists and attempts to roll back to it, causing the update rollback to fail.</p>"
    },
    "CreateStack":{
      "name":"CreateStack",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"CreateStackInput"},
      "output":{
        "shape":"CreateStackOutput",
        "resultWrapper":"CreateStackResult"
      },
      "errors":[
        {"shape":"LimitExceededException"},
        {"shape":"AlreadyExistsException"},
        {"shape":"InsufficientCapabilitiesException"}
      ],
      "documentation":"<p>Creates a stack as specified in the template. After the call completes successfully, the stack creation starts. You can check the status of the stack via the <a>DescribeStacks</a> API.</p>"
    },
    "DeleteStack":{
      "name":"DeleteStack",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DeleteStackInput"},
      "documentation":"<p>Deletes a specified stack. Once the call completes successfully, stack deletion starts. Deleted stacks do not show up in the <a>DescribeStacks</a> API if the deletion has been completed successfully.</p>"
    },
    "DescribeAccountLimits":{
      "name":"DescribeAccountLimits",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeAccountLimitsInput"},
      "output":{
        "shape":"DescribeAccountLimitsOutput",
        "resultWrapper":"DescribeAccountLimitsResult"
      },
      "documentation":"<p>Retrieves your account's AWS CloudFormation limits, such as the maximum number of stacks that you can create in your account.</p>"
    },
    "DescribeStackEvents":{
      "name":"DescribeStackEvents",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeStackEventsInput"},
      "output":{
        "shape":"DescribeStackEventsOutput",
        "resultWrapper":"DescribeStackEventsResult"
      },
      "documentation":"<p>Returns all stack related events for a specified stack. For more information about a stack's event history, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/concept-stack.html\">Stacks</a> in the AWS CloudFormation User Guide.</p> <note>You can list events for stacks that have failed to create or have been deleted by specifying the unique stack identifier (stack ID).</note>"
    },
    "DescribeStackResource":{
      "name":"DescribeStackResource",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeStackResourceInput"},
      "output":{
        "shape":"DescribeStackResourceOutput",
        "resultWrapper":"DescribeStackResourceResult"
      },
      "documentation":"<p>Returns a description of the specified resource in the specified stack.</p> <p>For deleted stacks, DescribeStackResource returns resource information for up to 90 days after the stack has been deleted.</p>"
    },
    "DescribeStackResources":{
      "name":"DescribeStackResources",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeStackResourcesInput"},
      "output":{
        "shape":"DescribeStackResourcesOutput",
        "resultWrapper":"DescribeStackResourcesResult"
      },
      "documentation":"<p>Returns AWS resource descriptions for running and deleted stacks. If <code>StackName</code> is specified, all the associated resources that are part of the stack are returned. If <code>PhysicalResourceId</code> is specified, the associated resources of the stack that the resource belongs to are returned.</p> <note>Only the first 100 resources will be returned. If your stack has more resources than this, you should use <code>ListStackResources</code> instead.</note> <p>For deleted stacks, <code>DescribeStackResources</code> returns resource information for up to 90 days after the stack has been deleted.</p> <p>You must specify either <code>StackName</code> or <code>PhysicalResourceId</code>, but not both. In addition, you can specify <code>LogicalResourceId</code> to filter the returned result. For more information about resources, the <code>LogicalResourceId</code> and <code>PhysicalResourceId</code>, go to the <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/\">AWS CloudFormation User Guide</a>.</p> <note>A <code>ValidationError</code> is returned if you specify both <code>StackName</code> and <code>PhysicalResourceId</code> in the same request.</note>"
    },
    "DescribeStacks":{
      "name":"DescribeStacks",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"DescribeStacksInput"},
      "output":{
        "shape":"DescribeStacksOutput",
        "resultWrapper":"DescribeStacksResult"
      },
      "documentation":"<p>Returns the description for the specified stack; if no stack name was specified, then it returns the description for all the stacks created.</p>"
    },
    "EstimateTemplateCost":{
      "name":"EstimateTemplateCost",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"EstimateTemplateCostInput"},
      "output":{
        "shape":"EstimateTemplateCostOutput",
        "resultWrapper":"EstimateTemplateCostResult"
      },
      "documentation":"<p>Returns the estimated monthly cost of a template. The return value is an AWS Simple Monthly Calculator URL with a query string that describes the resources required to run the template.</p>"
    },
    "GetStackPolicy":{
      "name":"GetStackPolicy",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetStackPolicyInput"},
      "output":{
        "shape":"GetStackPolicyOutput",
        "resultWrapper":"GetStackPolicyResult"
      },
      "documentation":"<p>Returns the stack policy for a specified stack. If a stack doesn't have a policy, a null value is returned.</p>"
    },
    "GetTemplate":{
      "name":"GetTemplate",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetTemplateInput"},
      "output":{
        "shape":"GetTemplateOutput",
        "resultWrapper":"GetTemplateResult"
      },
      "documentation":"<p>Returns the template body for a specified stack. You can get the template for running or deleted stacks.</p> <p>For deleted stacks, GetTemplate returns the template for up to 90 days after the stack has been deleted.</p> <note> If the template does not exist, a <code>ValidationError</code> is returned. </note>"
    },
    "GetTemplateSummary":{
      "name":"GetTemplateSummary",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"GetTemplateSummaryInput"},
      "output":{
        "shape":"GetTemplateSummaryOutput",
        "resultWrapper":"GetTemplateSummaryResult"
      },
      "documentation":"<p>Returns information about a new or existing template. The <code>GetTemplateSummary</code> action is useful for viewing parameter information, such as default parameter values and parameter types, before you create or update a stack.</p> <p>You can use the <code>GetTemplateSummary</code> action when you submit a template, or you can get template information for a running or deleted stack.</p> <p>For deleted stacks, <code>GetTemplateSummary</code> returns the template information for up to 90 days after the stack has been deleted. If the template does not exist, a <code>ValidationError</code> is returned.</p>"
    },
    "ListStackResources":{
      "name":"ListStackResources",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListStackResourcesInput"},
      "output":{
        "shape":"ListStackResourcesOutput",
        "resultWrapper":"ListStackResourcesResult"
      },
      "documentation":"<p>Returns descriptions of all resources of the specified stack.</p> <p>For deleted stacks, ListStackResources returns resource information for up to 90 days after the stack has been deleted.</p>"
    },
    "ListStacks":{
      "name":"ListStacks",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ListStacksInput"},
      "output":{
        "shape":"ListStacksOutput",
        "resultWrapper":"ListStacksResult"
      },
      "documentation":"<p>Returns the summary information for stacks whose status matches the specified StackStatusFilter. Summary information for stacks that have been deleted is kept for 90 days after the stack is deleted. If no StackStatusFilter is specified, summary information for all stacks is returned (including existing stacks and stacks that have been deleted).</p>"
    },
    "SetStackPolicy":{
      "name":"SetStackPolicy",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"SetStackPolicyInput"},
      "documentation":"<p>Sets a stack policy for a specified stack.</p>"
    },
    "SignalResource":{
      "name":"SignalResource",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"SignalResourceInput"},
      "documentation":"<p>Sends a signal to the specified resource with a success or failure status. You can use the SignalResource API in conjunction with a creation policy or update policy. AWS CloudFormation doesn't proceed with a stack creation or update until resources receive the required number of signals or the timeout period is exceeded. The SignalResource API is useful in cases where you want to send signals from anywhere other than an Amazon EC2 instance.</p>"
    },
    "UpdateStack":{
      "name":"UpdateStack",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"UpdateStackInput"},
      "output":{
        "shape":"UpdateStackOutput",
        "resultWrapper":"UpdateStackResult"
      },
      "errors":[
        {"shape":"InsufficientCapabilitiesException"}
      ],
      "documentation":"<p>Updates a stack as specified in the template. After the call completes successfully, the stack update starts. You can check the status of the stack via the <a>DescribeStacks</a> action.</p> <p>To get a copy of the template for an existing stack, you can use the <a>GetTemplate</a> action.</p> <p>For more information about creating an update template, updating a stack, and monitoring the progress of the update, see <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html\">Updating a Stack</a>.</p>"
    },
    "ValidateTemplate":{
      "name":"ValidateTemplate",
      "http":{
        "method":"POST",
        "requestUri":"/"
      },
      "input":{"shape":"ValidateTemplateInput"},
      "output":{
        "shape":"ValidateTemplateOutput",
        "resultWrapper":"ValidateTemplateResult"
      },
      "documentation":"<p>Validates a specified template.</p>"
    }
  },
  "shapes":{
    "AccountLimit":{
      "type":"structure",
      "members":{
        "Name":{
          "shape":"LimitName",
          "documentation":"<p>The name of the account limit. Currently, the only account limit is <code>StackLimit</code>.</p>"
        },
        "Value":{
          "shape":"LimitValue",
          "documentation":"<p>The value that is associated with the account limit name.</p>"
        }
      },
      "documentation":"<p>The AccountLimit data type.</p>"
    },
    "AccountLimitList":{
      "type":"list",
      "member":{"shape":"AccountLimit"}
    },
    "AllowedValue":{"type":"string"},
    "AllowedValues":{
      "type":"list",
      "member":{"shape":"AllowedValue"}
    },
    "AlreadyExistsException":{
      "type":"structure",
      "members":{
      },
      "documentation":"<p>Resource with the name requested already exists.</p>",
      "error":{
        "code":"AlreadyExistsException",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "CancelUpdateStackInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack.</p>"
        }
      },
      "documentation":"<p>The input for the <a>CancelUpdateStack</a> action.</p>"
    },
    "Capabilities":{
      "type":"list",
      "member":{"shape":"Capability"}
    },
    "CapabilitiesReason":{"type":"string"},
    "Capability":{
      "type":"string",
      "enum":["CAPABILITY_IAM"]
    },
    "ContinueUpdateRollbackInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackNameOrId",
          "documentation":"<p>The name or the unique ID of the stack that you want to continue rolling back.</p>"
        }
      },
      "documentation":"<p>The input for the <a>ContinueUpdateRollback</a> action.</p>"
    },
    "ContinueUpdateRollbackOutput":{
      "type":"structure",
      "members":{
      },
      "documentation":"<p>The output for a <a>ContinueUpdateRollback</a> action.</p>"
    },
    "CreateStackInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name that is associated with the stack. The name must be unique in the region in which you are creating the stack.</p> <note>A stack name can contain only alphanumeric characters (case sensitive) and hyphens. It must start with an alphabetic character and cannot be longer than 128 characters.</note>"
        },
        "TemplateBody":{
          "shape":"TemplateBody",
          "documentation":"<p>Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must specify either the <code>TemplateBody</code> or the <code>TemplateURL</code> parameter, but not both.</p>"
        },
        "TemplateURL":{
          "shape":"TemplateURL",
          "documentation":"<p>Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket. For more information, go to the <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must specify either the <code>TemplateBody</code> or the <code>TemplateURL</code> parameter, but not both.</p>"
        },
        "Parameters":{
          "shape":"Parameters",
          "documentation":"<p>A list of <code>Parameter</code> structures that specify input parameters for the stack. For more information, see the <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html\">Parameter</a> data type.</p>"
        },
        "DisableRollback":{
          "shape":"DisableRollback",
          "documentation":"<p>Set to <code>true</code> to disable rollback of the stack if stack creation failed. You can specify either <code>DisableRollback</code> or <code>OnFailure</code>, but not both.</p> <p>Default: <code>false</code> </p>"
        },
        "TimeoutInMinutes":{
          "shape":"TimeoutMinutes",
          "documentation":"<p>The amount of time that can pass before the stack status becomes CREATE_FAILED; if <code>DisableRollback</code> is not set or is set to <code>false</code>, the stack will be rolled back.</p>"
        },
        "NotificationARNs":{
          "shape":"NotificationARNs",
          "documentation":"<p>The Simple Notification Service (SNS) topic ARNs to publish stack related events. You can find your SNS topic ARNs using the <a href=\"http://console.aws.amazon.com/sns\">SNS console</a> or your Command Line Interface (CLI).</p>"
        },
        "Capabilities":{
          "shape":"Capabilities",
          "documentation":"<p>A list of capabilities that you must specify before AWS CloudFormation can create or update certain stacks. Some stack templates might include resources that can affect permissions in your AWS account. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter.</p> <p>Currently, the only valid value is <code>CAPABILITY_IAM</code>, which is required for the following resources: <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html\"> AWS::IAM::AccessKey</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html\"> AWS::IAM::Group</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html\"> AWS::IAM::InstanceProfile</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html\"> AWS::IAM::Policy</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html\"> AWS::IAM::Role</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html\"> AWS::IAM::User</a>, and <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html\"> AWS::IAM::UserToGroupAddition</a>. If your stack template contains these resources, we recommend that you review any permissions associated with them. If you don't specify this parameter, this action returns an <code>InsufficientCapabilities</code> error.</p>"
        },
        "ResourceTypes":{
          "shape":"ResourceTypes",
          "documentation":"<p>The template resource types that you have permissions to work with for this create stack action, such as <code>AWS::EC2::Instance</code>, <code>AWS::EC2::*</code>, or <code>Custom::MyCustomInstance</code>. Use the following syntax to describe template resource types: <code>AWS::*</code> (for all AWS resource), <code>Custom::*</code> (for all custom resources), <code>Custom::<i>logical_ID</i></code> (for a specific custom resource), <code>AWS::<i>service_name</i>::*</code> (for all resources of a particular AWS service), and <code>AWS::<i>service_name</i>::<i>resource_logical_ID</i></code> (for a specific AWS resource).</p> <p>If the list of resource types doesn't include a resource that you're creating, the stack creation fails. By default, AWS CloudFormation grants permissions to all resource types. AWS Identity and Access Management (IAM) uses this parameter for AWS CloudFormation-specific condition keys in IAM policies. For more information, see <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html\">Controlling Access with AWS Identity and Access Management</a>.</p>"
        },
        "OnFailure":{
          "shape":"OnFailure",
          "documentation":"<p>Determines what action will be taken if stack creation fails. This must be one of: DO_NOTHING, ROLLBACK, or DELETE. You can specify either <code>OnFailure</code> or <code>DisableRollback</code>, but not both.</p> <p>Default: <code>ROLLBACK</code></p>"
        },
        "StackPolicyBody":{
          "shape":"StackPolicyBody",
          "documentation":"<p>Structure containing the stack policy body. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html\"> Prevent Updates to Stack Resources</a> in the AWS CloudFormation User Guide. You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not both.</p>"
        },
        "StackPolicyURL":{
          "shape":"StackPolicyURL",
          "documentation":"<p>Location of a file containing the stack policy. The URL must point to a policy (max size: 16KB) located in an S3 bucket in the same region as the stack. You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not both.</p>"
        },
        "Tags":{
          "shape":"Tags",
          "documentation":"<p>Key-value pairs to associate with this stack. AWS CloudFormation also propagates these tags to the resources created in the stack. A maximum number of 10 tags can be specified.</p>"
        }
      },
      "documentation":"<p>The input for <a>CreateStack</a> action.</p>"
    },
    "CreateStackOutput":{
      "type":"structure",
      "members":{
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>Unique identifier of the stack.</p>"
        }
      },
      "documentation":"<p>The output for a <a>CreateStack</a> action.</p>"
    },
    "CreationTime":{"type":"timestamp"},
    "DeleteStackInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack.</p>"
        },
        "RetainResources":{
          "shape":"RetainResources",
          "documentation":"<p>For stacks in the <code>DELETE_FAILED</code> state, a list of resource logical IDs that are associated with the resources you want to retain. During deletion, AWS CloudFormation deletes the stack but does not delete the retained resources.</p> <p>Retaining resources is useful when you cannot delete a resource, such as a non-empty S3 bucket, but you want to delete the stack.</p>"
        }
      },
      "documentation":"<p>The input for <a>DeleteStack</a> action.</p>"
    },
    "DeletionTime":{"type":"timestamp"},
    "DescribeAccountLimitsInput":{
      "type":"structure",
      "members":{
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>A string that identifies the next page of limits that you want to retrieve.</p>"
        }
      },
      "documentation":"<p>The input for the <a>DescribeAccountLimits</a> action.</p>"
    },
    "DescribeAccountLimitsOutput":{
      "type":"structure",
      "members":{
        "AccountLimits":{
          "shape":"AccountLimitList",
          "documentation":"<p>An account limit structure that contain a list of AWS CloudFormation account limits and their values.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>If the output exceeds 1 MB in size, a string that identifies the next page of limits. If no additional page exists, this value is null.</p>"
        }
      },
      "documentation":"<p>The output for the <a>DescribeAccountLimits</a> action.</p>"
    },
    "DescribeStackEventsInput":{
      "type":"structure",
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack, which are not always interchangeable:</p> <ul> <li>Running stacks: You can specify either the stack's name or its unique stack ID.</li> <li>Deleted stacks: You must specify the unique stack ID.</li> </ul> <p>Default: There is no default value.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>A string that identifies the next page of events that you want to retrieve.</p>"
        }
      },
      "documentation":"<p>The input for <a>DescribeStackEvents</a> action.</p>"
    },
    "DescribeStackEventsOutput":{
      "type":"structure",
      "members":{
        "StackEvents":{
          "shape":"StackEvents",
          "documentation":"<p>A list of <code>StackEvents</code> structures.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>If the output exceeds 1 MB in size, a string that identifies the next page of events. If no additional page exists, this value is null.</p>"
        }
      },
      "documentation":"<p>The output for a <a>DescribeStackEvents</a> action.</p>"
    },
    "DescribeStackResourceInput":{
      "type":"structure",
      "required":[
        "StackName",
        "LogicalResourceId"
      ],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack, which are not always interchangeable:</p> <ul> <li>Running stacks: You can specify either the stack's name or its unique stack ID.</li> <li>Deleted stacks: You must specify the unique stack ID.</li> </ul> <p>Default: There is no default value.</p>"
        },
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical name of the resource as specified in the template.</p> <p>Default: There is no default value.</p>"
        }
      },
      "documentation":"<p>The input for <a>DescribeStackResource</a> action.</p>"
    },
    "DescribeStackResourceOutput":{
      "type":"structure",
      "members":{
        "StackResourceDetail":{
          "shape":"StackResourceDetail",
          "documentation":"<p>A <code>StackResourceDetail</code> structure containing the description of the specified resource in the specified stack.</p>"
        }
      },
      "documentation":"<p>The output for a <a>DescribeStackResource</a> action.</p>"
    },
    "DescribeStackResourcesInput":{
      "type":"structure",
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack, which are not always interchangeable:</p> <ul> <li>Running stacks: You can specify either the stack's name or its unique stack ID.</li> <li>Deleted stacks: You must specify the unique stack ID.</li> </ul> <p>Default: There is no default value.</p> <p>Required: Conditional. If you do not specify <code>StackName</code>, you must specify <code>PhysicalResourceId</code>.</p>"
        },
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical name of the resource as specified in the template.</p> <p>Default: There is no default value.</p>"
        },
        "PhysicalResourceId":{
          "shape":"PhysicalResourceId",
          "documentation":"<p>The name or unique identifier that corresponds to a physical instance ID of a resource supported by AWS CloudFormation.</p> <p>For example, for an Amazon Elastic Compute Cloud (EC2) instance, <code>PhysicalResourceId</code> corresponds to the <code>InstanceId</code>. You can pass the EC2 <code>InstanceId</code> to <code>DescribeStackResources</code> to find which stack the instance belongs to and what other resources are part of the stack.</p> <p>Required: Conditional. If you do not specify <code>PhysicalResourceId</code>, you must specify <code>StackName</code>.</p> <p>Default: There is no default value.</p>"
        }
      },
      "documentation":"<p>The input for <a>DescribeStackResources</a> action.</p>"
    },
    "DescribeStackResourcesOutput":{
      "type":"structure",
      "members":{
        "StackResources":{
          "shape":"StackResources",
          "documentation":"<p>A list of <code>StackResource</code> structures.</p>"
        }
      },
      "documentation":"<p>The output for a <a>DescribeStackResources</a> action.</p>"
    },
    "DescribeStacksInput":{
      "type":"structure",
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack, which are not always interchangeable:</p> <ul> <li>Running stacks: You can specify either the stack's name or its unique stack ID.</li> <li>Deleted stacks: You must specify the unique stack ID.</li> </ul> <p>Default: There is no default value.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>A string that identifies the next page of stacks that you want to retrieve.</p>"
        }
      },
      "documentation":"<p>The input for <a>DescribeStacks</a> action.</p>"
    },
    "DescribeStacksOutput":{
      "type":"structure",
      "members":{
        "Stacks":{
          "shape":"Stacks",
          "documentation":"<p>A list of stack structures.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>If the output exceeds 1 MB in size, a string that identifies the next page of stacks. If no additional page exists, this value is null.</p>"
        }
      },
      "documentation":"<p>The output for a <a>DescribeStacks</a> action.</p>"
    },
    "Description":{"type":"string"},
    "DisableRollback":{"type":"boolean"},
    "EstimateTemplateCostInput":{
      "type":"structure",
      "members":{
        "TemplateBody":{
          "shape":"TemplateBody",
          "documentation":"<p>Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.)</p> <p>Conditional: You must pass <code>TemplateBody</code> or <code>TemplateURL</code>. If both are passed, only <code>TemplateBody</code> is used.</p>"
        },
        "TemplateURL":{
          "shape":"TemplateURL",
          "documentation":"<p>Location of file containing the template body. The URL must point to a template that is located in an Amazon S3 bucket. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must pass <code>TemplateURL</code> or <code>TemplateBody</code>. If both are passed, only <code>TemplateBody</code> is used.</p>"
        },
        "Parameters":{
          "shape":"Parameters",
          "documentation":"<p>A list of <code>Parameter</code> structures that specify input parameters.</p>"
        }
      }
    },
    "EstimateTemplateCostOutput":{
      "type":"structure",
      "members":{
        "Url":{
          "shape":"Url",
          "documentation":"<p>An AWS Simple Monthly Calculator URL with a query string that describes the resources required to run the template.</p>"
        }
      },
      "documentation":"<p>The output for a <a>EstimateTemplateCost</a> action.</p>"
    },
    "EventId":{"type":"string"},
    "GetStackPolicyInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or unique stack ID that is associated with the stack whose policy you want to get.</p>"
        }
      },
      "documentation":"<p>The input for the <a>GetStackPolicy</a> action.</p>"
    },
    "GetStackPolicyOutput":{
      "type":"structure",
      "members":{
        "StackPolicyBody":{
          "shape":"StackPolicyBody",
          "documentation":"<p>Structure containing the stack policy body. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html\"> Prevent Updates to Stack Resources</a> in the AWS CloudFormation User Guide.)</p>"
        }
      },
      "documentation":"<p>The output for the <a>GetStackPolicy</a> action.</p>"
    },
    "GetTemplateInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack, which are not always interchangeable:</p> <ul> <li>Running stacks: You can specify either the stack's name or its unique stack ID.</li> <li>Deleted stacks: You must specify the unique stack ID.</li> </ul> <p>Default: There is no default value.</p>"
        }
      },
      "documentation":"<p>The input for a <a>GetTemplate</a> action.</p>"
    },
    "GetTemplateOutput":{
      "type":"structure",
      "members":{
        "TemplateBody":{
          "shape":"TemplateBody",
          "documentation":"<p>Structure containing the template body. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.)</p>"
        }
      },
      "documentation":"<p>The output for <a>GetTemplate</a> action.</p>"
    },
    "GetTemplateSummaryInput":{
      "type":"structure",
      "members":{
        "TemplateBody":{
          "shape":"TemplateBody",
          "documentation":"<p>Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. For more information about templates, see <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must specify only one of the following parameters: <code>StackName</code>, <code>TemplateBody</code>, or <code>TemplateURL</code>.</p>"
        },
        "TemplateURL":{
          "shape":"TemplateURL",
          "documentation":"<p>Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket. For more information about templates, see <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must specify only one of the following parameters: <code>StackName</code>, <code>TemplateBody</code>, or <code>TemplateURL</code>.</p>"
        },
        "StackName":{
          "shape":"StackNameOrId",
          "documentation":"<p>The name or the stack ID that is associated with the stack, which are not always interchangeable. For running stacks, you can specify either the stack's name or its unique stack ID. For deleted stack, you must specify the unique stack ID.</p> <p>Conditional: You must specify only one of the following parameters: <code>StackName</code>, <code>TemplateBody</code>, or <code>TemplateURL</code>.</p>"
        }
      },
      "documentation":"<p>The input for the <a>GetTemplateSummary</a> action.</p>"
    },
    "GetTemplateSummaryOutput":{
      "type":"structure",
      "members":{
        "Parameters":{
          "shape":"ParameterDeclarations",
          "documentation":"<p>A list of parameter declarations that describe various properties for each parameter.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>The value that is defined in the <code>Description</code> property of the template.</p>"
        },
        "Capabilities":{
          "shape":"Capabilities",
          "documentation":"<p>The capabilities found within the template. Currently, AWS CloudFormation supports only the CAPABILITY_IAM capability. If your template contains IAM resources, you must specify the CAPABILITY_IAM value for this parameter when you use the <a>CreateStack</a> or <a>UpdateStack</a> actions with your template; otherwise, those actions return an InsufficientCapabilities error.</p>"
        },
        "CapabilitiesReason":{
          "shape":"CapabilitiesReason",
          "documentation":"<p>The list of resources that generated the values in the <code>Capabilities</code> response element.</p>"
        },
        "ResourceTypes":{
          "shape":"ResourceTypes",
          "documentation":"<p>A list of all the template resource types that are defined in the template, such as <code>AWS::EC2::Instance</code>, <code>AWS::Dynamo::Table</code>, and <code>Custom::MyCustomInstance</code>.</p>"
        },
        "Version":{
          "shape":"Version",
          "documentation":"<p>The AWS template format version, which identifies the capabilities of the template.</p>"
        },
        "Metadata":{
          "shape":"Metadata",
          "documentation":"<p>The value that is defined for the <code>Metadata</code> property of the template.</p>"
        }
      },
      "documentation":"<p>The output for the <a>GetTemplateSummary</a> action.</p>"
    },
    "InsufficientCapabilitiesException":{
      "type":"structure",
      "members":{
      },
      "documentation":"<p>The template contains resources with capabilities that were not specified in the Capabilities parameter.</p>",
      "error":{
        "code":"InsufficientCapabilitiesException",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "LastUpdatedTime":{"type":"timestamp"},
    "LimitExceededException":{
      "type":"structure",
      "members":{
      },
      "documentation":"<p>Quota for the resource has already been reached.</p>",
      "error":{
        "code":"LimitExceededException",
        "httpStatusCode":400,
        "senderFault":true
      },
      "exception":true
    },
    "LimitName":{"type":"string"},
    "LimitValue":{"type":"integer"},
    "ListStackResourcesInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or the unique stack ID that is associated with the stack, which are not always interchangeable:</p> <ul> <li>Running stacks: You can specify either the stack's name or its unique stack ID.</li> <li>Deleted stacks: You must specify the unique stack ID.</li> </ul> <p>Default: There is no default value.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>A string that identifies the next page of stack resources that you want to retrieve.</p>"
        }
      },
      "documentation":"<p>The input for the <a>ListStackResource</a> action.</p>"
    },
    "ListStackResourcesOutput":{
      "type":"structure",
      "members":{
        "StackResourceSummaries":{
          "shape":"StackResourceSummaries",
          "documentation":"<p>A list of <code>StackResourceSummary</code> structures.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>If the output exceeds 1 MB in size, a string that identifies the next page of stack resources. If no additional page exists, this value is null.</p>"
        }
      },
      "documentation":"<p>The output for a <a>ListStackResources</a> action.</p>"
    },
    "ListStacksInput":{
      "type":"structure",
      "members":{
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>A string that identifies the next page of stacks that you want to retrieve.</p>"
        },
        "StackStatusFilter":{
          "shape":"StackStatusFilter",
          "documentation":"<p>Stack status to use as a filter. Specify one or more stack status codes to list only stacks with the specified status codes. For a complete list of stack status codes, see the <code>StackStatus</code> parameter of the <a>Stack</a> data type.</p>"
        }
      },
      "documentation":"<p>The input for <a>ListStacks</a> action.</p>"
    },
    "ListStacksOutput":{
      "type":"structure",
      "members":{
        "StackSummaries":{
          "shape":"StackSummaries",
          "documentation":"<p>A list of <code>StackSummary</code> structures containing information about the specified stacks.</p>"
        },
        "NextToken":{
          "shape":"NextToken",
          "documentation":"<p>If the output exceeds 1 MB in size, a string that identifies the next page of stacks. If no additional page exists, this value is null.</p>"
        }
      },
      "documentation":"<p>The output for <a>ListStacks</a> action.</p>"
    },
    "LogicalResourceId":{"type":"string"},
    "Metadata":{"type":"string"},
    "NextToken":{
      "type":"string",
      "max":1024,
      "min":1
    },
    "NoEcho":{"type":"boolean"},
    "NotificationARN":{"type":"string"},
    "NotificationARNs":{
      "type":"list",
      "member":{"shape":"NotificationARN"},
      "max":5
    },
    "OnFailure":{
      "type":"string",
      "enum":[
        "DO_NOTHING",
        "ROLLBACK",
        "DELETE"
      ]
    },
    "Output":{
      "type":"structure",
      "members":{
        "OutputKey":{
          "shape":"OutputKey",
          "documentation":"<p>The key associated with the output.</p>"
        },
        "OutputValue":{
          "shape":"OutputValue",
          "documentation":"<p>The value associated with the output.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>User defined description associated with the output.</p>"
        }
      },
      "documentation":"<p>The Output data type.</p>"
    },
    "OutputKey":{"type":"string"},
    "OutputValue":{"type":"string"},
    "Outputs":{
      "type":"list",
      "member":{"shape":"Output"}
    },
    "Parameter":{
      "type":"structure",
      "members":{
        "ParameterKey":{
          "shape":"ParameterKey",
          "documentation":"<p>The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.</p>"
        },
        "ParameterValue":{
          "shape":"ParameterValue",
          "documentation":"<p>The value associated with the parameter.</p>"
        },
        "UsePreviousValue":{
          "shape":"UsePreviousValue",
          "documentation":"<p>During a stack update, use the existing parameter value that the stack is using for a given parameter key. If you specify <code>true</code>, do not specify a parameter value.</p>"
        }
      },
      "documentation":"<p>The Parameter data type.</p>"
    },
    "ParameterConstraints":{
      "type":"structure",
      "members":{
        "AllowedValues":{
          "shape":"AllowedValues",
          "documentation":"<p>A list of values that are permitted for a parameter.</p>"
        }
      },
      "documentation":"<p>A set of criteria that AWS CloudFormation uses to validate parameter values. Although other constraints might be defined in the stack template, AWS CloudFormation returns only the <code>AllowedValues</code> property.</p>"
    },
    "ParameterDeclaration":{
      "type":"structure",
      "members":{
        "ParameterKey":{
          "shape":"ParameterKey",
          "documentation":"<p>The name that is associated with the parameter.</p>"
        },
        "DefaultValue":{
          "shape":"ParameterValue",
          "documentation":"<p>The default value of the parameter.</p>"
        },
        "ParameterType":{
          "shape":"ParameterType",
          "documentation":"<p>The type of parameter.</p>"
        },
        "NoEcho":{
          "shape":"NoEcho",
          "documentation":"<p>Flag that indicates whether the parameter value is shown as plain text in logs and in the AWS Management Console.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>The description that is associate with the parameter.</p>"
        },
        "ParameterConstraints":{
          "shape":"ParameterConstraints",
          "documentation":"<p>The criteria that AWS CloudFormation uses to validate parameter values.</p>"
        }
      },
      "documentation":"<p>The ParameterDeclaration data type.</p>"
    },
    "ParameterDeclarations":{
      "type":"list",
      "member":{"shape":"ParameterDeclaration"}
    },
    "ParameterKey":{"type":"string"},
    "ParameterType":{"type":"string"},
    "ParameterValue":{"type":"string"},
    "Parameters":{
      "type":"list",
      "member":{"shape":"Parameter"}
    },
    "PhysicalResourceId":{"type":"string"},
    "ResourceProperties":{"type":"string"},
    "ResourceSignalStatus":{
      "type":"string",
      "enum":[
        "SUCCESS",
        "FAILURE"
      ]
    },
    "ResourceSignalUniqueId":{
      "type":"string",
      "max":64,
      "min":1
    },
    "ResourceStatus":{
      "type":"string",
      "enum":[
        "CREATE_IN_PROGRESS",
        "CREATE_FAILED",
        "CREATE_COMPLETE",
        "DELETE_IN_PROGRESS",
        "DELETE_FAILED",
        "DELETE_COMPLETE",
        "DELETE_SKIPPED",
        "UPDATE_IN_PROGRESS",
        "UPDATE_FAILED",
        "UPDATE_COMPLETE"
      ]
    },
    "ResourceStatusReason":{"type":"string"},
    "ResourceType":{"type":"string"},
    "ResourceTypes":{
      "type":"list",
      "member":{"shape":"ResourceType"}
    },
    "RetainResources":{
      "type":"list",
      "member":{"shape":"LogicalResourceId"}
    },
    "SetStackPolicyInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or unique stack ID that you want to associate a policy with.</p>"
        },
        "StackPolicyBody":{
          "shape":"StackPolicyBody",
          "documentation":"<p>Structure containing the stack policy body. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html\"> Prevent Updates to Stack Resources</a> in the AWS CloudFormation User Guide. You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not both.</p>"
        },
        "StackPolicyURL":{
          "shape":"StackPolicyURL",
          "documentation":"<p>Location of a file containing the stack policy. The URL must point to a policy (max size: 16KB) located in an S3 bucket in the same region as the stack. You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not both.</p>"
        }
      },
      "documentation":"<p>The input for the <a>SetStackPolicy</a> action.</p>"
    },
    "SignalResourceInput":{
      "type":"structure",
      "required":[
        "StackName",
        "LogicalResourceId",
        "UniqueId",
        "Status"
      ],
      "members":{
        "StackName":{
          "shape":"StackNameOrId",
          "documentation":"<p>The stack name or unique stack ID that includes the resource that you want to signal.</p>"
        },
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical ID of the resource that you want to signal. The logical ID is the name of the resource that given in the template.</p>"
        },
        "UniqueId":{
          "shape":"ResourceSignalUniqueId",
          "documentation":"<p>A unique ID of the signal. When you signal Amazon EC2 instances or Auto Scaling groups, specify the instance ID that you are signaling as the unique ID. If you send multiple signals to a single resource (such as signaling a wait condition), each signal requires a different unique ID.</p>"
        },
        "Status":{
          "shape":"ResourceSignalStatus",
          "documentation":"<p>The status of the signal, which is either success or failure. A failure signal causes AWS CloudFormation to immediately fail the stack creation or update.</p>"
        }
      },
      "documentation":"<p>The input for the <a>SignalResource</a> action.</p>"
    },
    "Stack":{
      "type":"structure",
      "required":[
        "StackName",
        "CreationTime",
        "StackStatus"
      ],
      "members":{
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>Unique identifier of the stack.</p>"
        },
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name associated with the stack.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>A user-defined description associated with the stack.</p>"
        },
        "Parameters":{
          "shape":"Parameters",
          "documentation":"<p>A list of <code>Parameter</code> structures.</p>"
        },
        "CreationTime":{
          "shape":"CreationTime",
          "documentation":"<p>The time at which the stack was created.</p>"
        },
        "LastUpdatedTime":{
          "shape":"LastUpdatedTime",
          "documentation":"<p>The time the stack was last updated. This field will only be returned if the stack has been updated at least once.</p>"
        },
        "StackStatus":{
          "shape":"StackStatus",
          "documentation":"<p>Current status of the stack.</p>"
        },
        "StackStatusReason":{
          "shape":"StackStatusReason",
          "documentation":"<p>Success/failure message associated with the stack status.</p>"
        },
        "DisableRollback":{
          "shape":"DisableRollback",
          "documentation":"<p>Boolean to enable or disable rollback on stack creation failures:</p> <p> <ul> <li><code>true</code>: disable rollback</li> <li><code>false</code>: enable rollback</li> </ul> </p>"
        },
        "NotificationARNs":{
          "shape":"NotificationARNs",
          "documentation":"<p>SNS topic ARNs to which stack related events are published.</p>"
        },
        "TimeoutInMinutes":{
          "shape":"TimeoutMinutes",
          "documentation":"<p>The amount of time within which stack creation should complete.</p>"
        },
        "Capabilities":{
          "shape":"Capabilities",
          "documentation":"<p>The capabilities allowed in the stack.</p>"
        },
        "Outputs":{
          "shape":"Outputs",
          "documentation":"<p>A list of output structures.</p>"
        },
        "Tags":{
          "shape":"Tags",
          "documentation":"<p>A list of <code>Tag</code>s that specify cost allocation information for the stack.</p>"
        }
      },
      "documentation":"<p>The Stack data type.</p>"
    },
    "StackEvent":{
      "type":"structure",
      "required":[
        "StackId",
        "EventId",
        "StackName",
        "Timestamp"
      ],
      "members":{
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>The unique ID name of the instance of the stack.</p>"
        },
        "EventId":{
          "shape":"EventId",
          "documentation":"<p>The unique ID of this event.</p>"
        },
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name associated with a stack.</p>"
        },
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical name of the resource specified in the template.</p>"
        },
        "PhysicalResourceId":{
          "shape":"PhysicalResourceId",
          "documentation":"<p>The name or unique identifier associated with the physical instance of the resource.</p>"
        },
        "ResourceType":{
          "shape":"ResourceType",
          "documentation":"<p>Type of resource. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html\"> AWS Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>"
        },
        "Timestamp":{
          "shape":"Timestamp",
          "documentation":"<p>Time the status was updated.</p>"
        },
        "ResourceStatus":{
          "shape":"ResourceStatus",
          "documentation":"<p>Current status of the resource.</p>"
        },
        "ResourceStatusReason":{
          "shape":"ResourceStatusReason",
          "documentation":"<p>Success/failure message associated with the resource.</p>"
        },
        "ResourceProperties":{
          "shape":"ResourceProperties",
          "documentation":"<p>BLOB of the properties used to create the resource.</p>"
        }
      },
      "documentation":"<p>The StackEvent data type.</p>"
    },
    "StackEvents":{
      "type":"list",
      "member":{"shape":"StackEvent"}
    },
    "StackId":{"type":"string"},
    "StackName":{"type":"string"},
    "StackNameOrId":{
      "type":"string",
      "min":1,
      "pattern":"([a-zA-Z][-a-zA-Z0-9]*)|(arn:\\b(aws|aws-us-gov|aws-cn)\\b:[-a-zA-Z0-9:/._+]*)"
    },
    "StackPolicyBody":{
      "type":"string",
      "max":16384,
      "min":1
    },
    "StackPolicyDuringUpdateBody":{
      "type":"string",
      "max":16384,
      "min":1
    },
    "StackPolicyDuringUpdateURL":{
      "type":"string",
      "max":1350,
      "min":1
    },
    "StackPolicyURL":{
      "type":"string",
      "max":1350,
      "min":1
    },
    "StackResource":{
      "type":"structure",
      "required":[
        "LogicalResourceId",
        "ResourceType",
        "Timestamp",
        "ResourceStatus"
      ],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name associated with the stack.</p>"
        },
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>Unique identifier of the stack.</p>"
        },
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical name of the resource specified in the template.</p>"
        },
        "PhysicalResourceId":{
          "shape":"PhysicalResourceId",
          "documentation":"<p>The name or unique identifier that corresponds to a physical instance ID of a resource supported by AWS CloudFormation.</p>"
        },
        "ResourceType":{
          "shape":"ResourceType",
          "documentation":"<p>Type of resource. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html\"> AWS Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>"
        },
        "Timestamp":{
          "shape":"Timestamp",
          "documentation":"<p>Time the status was updated.</p>"
        },
        "ResourceStatus":{
          "shape":"ResourceStatus",
          "documentation":"<p>Current status of the resource.</p>"
        },
        "ResourceStatusReason":{
          "shape":"ResourceStatusReason",
          "documentation":"<p>Success/failure message associated with the resource.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>User defined description associated with the resource.</p>"
        }
      },
      "documentation":"<p>The StackResource data type.</p>"
    },
    "StackResourceDetail":{
      "type":"structure",
      "required":[
        "LogicalResourceId",
        "ResourceType",
        "LastUpdatedTimestamp",
        "ResourceStatus"
      ],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name associated with the stack.</p>"
        },
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>Unique identifier of the stack.</p>"
        },
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical name of the resource specified in the template.</p>"
        },
        "PhysicalResourceId":{
          "shape":"PhysicalResourceId",
          "documentation":"<p>The name or unique identifier that corresponds to a physical instance ID of a resource supported by AWS CloudFormation.</p>"
        },
        "ResourceType":{
          "shape":"ResourceType",
          "documentation":"<p>Type of resource. ((For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html\"> AWS Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>"
        },
        "LastUpdatedTimestamp":{
          "shape":"Timestamp",
          "documentation":"<p>Time the status was updated.</p>"
        },
        "ResourceStatus":{
          "shape":"ResourceStatus",
          "documentation":"<p>Current status of the resource.</p>"
        },
        "ResourceStatusReason":{
          "shape":"ResourceStatusReason",
          "documentation":"<p>Success/failure message associated with the resource.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>User defined description associated with the resource.</p>"
        },
        "Metadata":{
          "shape":"Metadata",
          "documentation":"<p>The JSON format content of the <code>Metadata</code> attribute declared for the resource. For more information, see <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html\">Metadata Attribute</a> in the AWS CloudFormation User Guide.</p>"
        }
      },
      "documentation":"<p>Contains detailed information about the specified stack resource.</p>"
    },
    "StackResourceSummaries":{
      "type":"list",
      "member":{"shape":"StackResourceSummary"}
    },
    "StackResourceSummary":{
      "type":"structure",
      "required":[
        "LogicalResourceId",
        "ResourceType",
        "LastUpdatedTimestamp",
        "ResourceStatus"
      ],
      "members":{
        "LogicalResourceId":{
          "shape":"LogicalResourceId",
          "documentation":"<p>The logical name of the resource specified in the template.</p>"
        },
        "PhysicalResourceId":{
          "shape":"PhysicalResourceId",
          "documentation":"<p>The name or unique identifier that corresponds to a physical instance ID of the resource.</p>"
        },
        "ResourceType":{
          "shape":"ResourceType",
          "documentation":"<p>Type of resource. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html\"> AWS Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>"
        },
        "LastUpdatedTimestamp":{
          "shape":"Timestamp",
          "documentation":"<p>Time the status was updated.</p>"
        },
        "ResourceStatus":{
          "shape":"ResourceStatus",
          "documentation":"<p>Current status of the resource.</p>"
        },
        "ResourceStatusReason":{
          "shape":"ResourceStatusReason",
          "documentation":"<p>Success/failure message associated with the resource.</p>"
        }
      },
      "documentation":"<p>Contains high-level information about the specified stack resource.</p>"
    },
    "StackResources":{
      "type":"list",
      "member":{"shape":"StackResource"}
    },
    "StackStatus":{
      "type":"string",
      "enum":[
        "CREATE_IN_PROGRESS",
        "CREATE_FAILED",
        "CREATE_COMPLETE",
        "ROLLBACK_IN_PROGRESS",
        "ROLLBACK_FAILED",
        "ROLLBACK_COMPLETE",
        "DELETE_IN_PROGRESS",
        "DELETE_FAILED",
        "DELETE_COMPLETE",
        "UPDATE_IN_PROGRESS",
        "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS",
        "UPDATE_COMPLETE",
        "UPDATE_ROLLBACK_IN_PROGRESS",
        "UPDATE_ROLLBACK_FAILED",
        "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS",
        "UPDATE_ROLLBACK_COMPLETE"
      ]
    },
    "StackStatusFilter":{
      "type":"list",
      "member":{"shape":"StackStatus"}
    },
    "StackStatusReason":{"type":"string"},
    "StackSummaries":{
      "type":"list",
      "member":{"shape":"StackSummary"}
    },
    "StackSummary":{
      "type":"structure",
      "required":[
        "StackName",
        "CreationTime",
        "StackStatus"
      ],
      "members":{
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>Unique stack identifier.</p>"
        },
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name associated with the stack.</p>"
        },
        "TemplateDescription":{
          "shape":"TemplateDescription",
          "documentation":"<p>The template description of the template used to create the stack.</p>"
        },
        "CreationTime":{
          "shape":"CreationTime",
          "documentation":"<p>The time the stack was created.</p>"
        },
        "LastUpdatedTime":{
          "shape":"LastUpdatedTime",
          "documentation":"<p>The time the stack was last updated. This field will only be returned if the stack has been updated at least once.</p>"
        },
        "DeletionTime":{
          "shape":"DeletionTime",
          "documentation":"<p>The time the stack was deleted.</p>"
        },
        "StackStatus":{
          "shape":"StackStatus",
          "documentation":"<p>The current status of the stack.</p>"
        },
        "StackStatusReason":{
          "shape":"StackStatusReason",
          "documentation":"<p>Success/Failure message associated with the stack status.</p>"
        }
      },
      "documentation":"<p>The StackSummary Data Type</p>"
    },
    "Stacks":{
      "type":"list",
      "member":{"shape":"Stack"}
    },
    "Tag":{
      "type":"structure",
      "members":{
        "Key":{
          "shape":"TagKey",
          "documentation":"<p><i>Required</i>. A string used to identify this tag. You can specify a maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the reserved prefix: <code>aws:</code>.</p>"
        },
        "Value":{
          "shape":"TagValue",
          "documentation":"<p><i>Required</i>. A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value.</p>"
        }
      },
      "documentation":"<p>The Tag type is used by <code>CreateStack</code> in the <code>Tags</code> parameter. It allows you to specify a key-value pair that can be used to store information related to cost allocation for an AWS CloudFormation stack.</p>"
    },
    "TagKey":{"type":"string"},
    "TagValue":{"type":"string"},
    "Tags":{
      "type":"list",
      "member":{"shape":"Tag"}
    },
    "TemplateBody":{
      "type":"string",
      "min":1
    },
    "TemplateDescription":{"type":"string"},
    "TemplateParameter":{
      "type":"structure",
      "members":{
        "ParameterKey":{
          "shape":"ParameterKey",
          "documentation":"<p>The name associated with the parameter.</p>"
        },
        "DefaultValue":{
          "shape":"ParameterValue",
          "documentation":"<p>The default value associated with the parameter.</p>"
        },
        "NoEcho":{
          "shape":"NoEcho",
          "documentation":"<p>Flag indicating whether the parameter should be displayed as plain text in logs and UIs.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>User defined description associated with the parameter.</p>"
        }
      },
      "documentation":"<p>The TemplateParameter data type.</p>"
    },
    "TemplateParameters":{
      "type":"list",
      "member":{"shape":"TemplateParameter"}
    },
    "TemplateURL":{
      "type":"string",
      "max":1024,
      "min":1
    },
    "TimeoutMinutes":{
      "type":"integer",
      "min":1
    },
    "Timestamp":{"type":"timestamp"},
    "UpdateStackInput":{
      "type":"structure",
      "required":["StackName"],
      "members":{
        "StackName":{
          "shape":"StackName",
          "documentation":"<p>The name or unique stack ID of the stack to update.</p>"
        },
        "TemplateBody":{
          "shape":"TemplateBody",
          "documentation":"<p>Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. (For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.)</p> <p>Conditional: You must specify either the <code>TemplateBody</code> or the <code>TemplateURL</code> parameter, but not both.</p>"
        },
        "TemplateURL":{
          "shape":"TemplateURL",
          "documentation":"<p>Location of file containing the template body. The URL must point to a template that is located in an Amazon S3 bucket. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must specify either the <code>TemplateBody</code> or the <code>TemplateURL</code> parameter, but not both.</p>"
        },
        "UsePreviousTemplate":{
          "shape":"UsePreviousTemplate",
          "documentation":"<p>Reuse the existing template that is associated with the stack that you are updating.</p>"
        },
        "StackPolicyDuringUpdateBody":{
          "shape":"StackPolicyDuringUpdateBody",
          "documentation":"<p>Structure containing the temporary overriding stack policy body. You can specify either the <code>StackPolicyDuringUpdateBody</code> or the <code>StackPolicyDuringUpdateURL</code> parameter, but not both.</p> <p>If you want to update protected resources, specify a temporary overriding stack policy during this update. If you do not specify a stack policy, the current policy that is associated with the stack will be used.</p>"
        },
        "StackPolicyDuringUpdateURL":{
          "shape":"StackPolicyDuringUpdateURL",
          "documentation":"<p>Location of a file containing the temporary overriding stack policy. The URL must point to a policy (max size: 16KB) located in an S3 bucket in the same region as the stack. You can specify either the <code>StackPolicyDuringUpdateBody</code> or the <code>StackPolicyDuringUpdateURL</code> parameter, but not both.</p> <p>If you want to update protected resources, specify a temporary overriding stack policy during this update. If you do not specify a stack policy, the current policy that is associated with the stack will be used.</p>"
        },
        "Parameters":{
          "shape":"Parameters",
          "documentation":"<p>A list of <code>Parameter</code> structures that specify input parameters for the stack. For more information, see the <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html\">Parameter</a> data type.</p>"
        },
        "Capabilities":{
          "shape":"Capabilities",
          "documentation":"<p>A list of capabilities that you must specify before AWS CloudFormation can create or update certain stacks. Some stack templates might include resources that can affect permissions in your AWS account. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter. Currently, the only valid value is <code>CAPABILITY_IAM</code>, which is required for the following resources: <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-accesskey.html\"> AWS::IAM::AccessKey</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html\"> AWS::IAM::Group</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html\"> AWS::IAM::InstanceProfile</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-policy.html\"> AWS::IAM::Policy</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html\"> AWS::IAM::Role</a>, <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-user.html\"> AWS::IAM::User</a>, and <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-addusertogroup.html\"> AWS::IAM::UserToGroupAddition</a>. If your stack template contains these resources, we recommend that you review any permissions associated with them. If you don't specify this parameter, this action returns an InsufficientCapabilities error.</p>"
        },
        "ResourceTypes":{
          "shape":"ResourceTypes",
          "documentation":"<p>The template resource types that you have permissions to work with for this update stack action, such as <code>AWS::EC2::Instance</code>, <code>AWS::EC2::*</code>, or <code>Custom::MyCustomInstance</code>.</p> <p>If the list of resource types doesn't include a resource that you're updating, the stack update fails. By default, AWS CloudFormation grants permissions to all resource types. AWS Identity and Access Management (IAM) uses this parameter for AWS CloudFormation-specific condition keys in IAM policies. For more information, see <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html\">Controlling Access with AWS Identity and Access Management</a>.</p>"
        },
        "StackPolicyBody":{
          "shape":"StackPolicyBody",
          "documentation":"<p>Structure containing a new stack policy body. You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not both.</p> <p>You might update the stack policy, for example, in order to protect a new resource that you created during a stack update. If you do not specify a stack policy, the current policy that is associated with the stack is unchanged.</p>"
        },
        "StackPolicyURL":{
          "shape":"StackPolicyURL",
          "documentation":"<p>Location of a file containing the updated stack policy. The URL must point to a policy (max size: 16KB) located in an S3 bucket in the same region as the stack. You can specify either the <code>StackPolicyBody</code> or the <code>StackPolicyURL</code> parameter, but not both.</p> <p>You might update the stack policy, for example, in order to protect a new resource that you created during a stack update. If you do not specify a stack policy, the current policy that is associated with the stack is unchanged.</p>"
        },
        "NotificationARNs":{
          "shape":"NotificationARNs",
          "documentation":"<p>Amazon Simple Notification Service topic Amazon Resource Names (ARNs) that AWS CloudFormation associates with the stack. Specify an empty list to remove all notification topics.</p>"
        },
        "Tags":{
          "shape":"Tags",
          "documentation":"<p>Key-value pairs to associate with this stack. AWS CloudFormation also propagates these tags to supported resources in the stack. You can specify a maximum number of 10 tags.</p> <p>If you don't specify this parameter, AWS CloudFormation doesn't modify the stack's tags. If you specify an empty value, AWS CloudFormation removes all associated tags.</p>"
        }
      },
      "documentation":"<p>The input for <a>UpdateStack</a> action.</p>"
    },
    "UpdateStackOutput":{
      "type":"structure",
      "members":{
        "StackId":{
          "shape":"StackId",
          "documentation":"<p>Unique identifier of the stack.</p>"
        }
      },
      "documentation":"<p>The output for a <a>UpdateStack</a> action.</p>"
    },
    "Url":{"type":"string"},
    "UsePreviousTemplate":{"type":"boolean"},
    "UsePreviousValue":{"type":"boolean"},
    "ValidateTemplateInput":{
      "type":"structure",
      "members":{
        "TemplateBody":{
          "shape":"TemplateBody",
          "documentation":"<p>Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must pass <code>TemplateURL</code> or <code>TemplateBody</code>. If both are passed, only <code>TemplateBody</code> is used.</p>"
        },
        "TemplateURL":{
          "shape":"TemplateURL",
          "documentation":"<p>Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket. For more information, go to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html\">Template Anatomy</a> in the AWS CloudFormation User Guide.</p> <p>Conditional: You must pass <code>TemplateURL</code> or <code>TemplateBody</code>. If both are passed, only <code>TemplateBody</code> is used.</p>"
        }
      },
      "documentation":"<p>The input for <a>ValidateTemplate</a> action.</p>"
    },
    "ValidateTemplateOutput":{
      "type":"structure",
      "members":{
        "Parameters":{
          "shape":"TemplateParameters",
          "documentation":"<p>A list of <code>TemplateParameter</code> structures.</p>"
        },
        "Description":{
          "shape":"Description",
          "documentation":"<p>The description found within the template.</p>"
        },
        "Capabilities":{
          "shape":"Capabilities",
          "documentation":"<p>The capabilities found within the template. Currently, AWS CloudFormation supports only the CAPABILITY_IAM capability. If your template contains IAM resources, you must specify the CAPABILITY_IAM value for this parameter when you use the <a>CreateStack</a> or <a>UpdateStack</a> actions with your template; otherwise, those actions return an InsufficientCapabilities error.</p>"
        },
        "CapabilitiesReason":{
          "shape":"CapabilitiesReason",
          "documentation":"<p>The list of resources that generated the values in the <code>Capabilities</code> response element.</p>"
        }
      },
      "documentation":"<p>The output for <a>ValidateTemplate</a> action.</p>"
    },
    "Version":{"type":"string"}
  },
  "documentation":"<fullname>AWS CloudFormation</fullname> <p>AWS CloudFormation enables you to create and manage AWS infrastructure deployments predictably and repeatedly. AWS CloudFormation helps you leverage AWS products such as Amazon EC2, EBS, Amazon SNS, ELB, and Auto Scaling to build highly-reliable, highly scalable, cost effective applications without worrying about creating and configuring the underlying AWS infrastructure.</p> <p>With AWS CloudFormation, you declare all of your resources and dependencies in a template file. The template defines a collection of resources as a single unit called a stack. AWS CloudFormation creates and deletes all member resources of the stack together and manages all dependencies between the resources for you.</p> <p>For more information about this product, go to the <a href=\"http://aws.amazon.com/cloudformation/\">CloudFormation Product Page</a>.</p> <p>Amazon CloudFormation makes use of other AWS products. If you need additional technical information about a specific AWS product, you can find the product's technical documentation at <a href=\"http://docs.aws.amazon.com/documentation/\">http://docs.aws.amazon.com/documentation/</a>.</p>"
}
                                                                                                                                                                                                                                                                               usr/local/lib/python2.7/dist-packages/botocore/data/cloudformation/2010-05-15/waiters-2.json        0100644 0000000 0000062 00000014466 13077704371 027552  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version": 2,
  "waiters": {
    "StackExists": {
      "delay": 5,
      "operation": "DescribeStacks",
      "maxAttempts": 20,
      "acceptors": [
        {
          "matcher": "status",
          "expected": 200,
          "state": "success"
        },
        {
          "matcher": "error",
          "expected": "ValidationError",
          "state": "retry"
        }
      ]
    },
    "StackCreateComplete": {
      "delay": 30,
      "operation": "DescribeStacks",
      "maxAttempts": 120,
      "description": "Wait until stack status is CREATE_COMPLETE.",
      "acceptors": [
        {
          "argument": "Stacks[].StackStatus",
          "expected": "CREATE_COMPLETE",
          "matcher": "pathAll",
          "state": "success"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "CREATE_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "DELETE_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "DELETE_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "DELETE_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "ROLLBACK_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "ROLLBACK_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "ROLLBACK_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "expected": "ValidationError",
          "matcher": "error",
          "state": "failure"
        }
      ]
    },
    "StackDeleteComplete": {
      "delay": 30,
      "operation": "DescribeStacks",
      "maxAttempts": 120,
      "description": "Wait until stack status is DELETE_COMPLETE.",
      "acceptors": [
        {
          "argument": "Stacks[].StackStatus",
          "expected": "DELETE_COMPLETE",
          "matcher": "pathAll",
          "state": "success"
        },
        {
          "expected": "ValidationError",
          "matcher": "error",
          "state": "success"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "DELETE_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "CREATE_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "CREATE_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "CREATE_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "ROLLBACK_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "ROLLBACK_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "ROLLBACK_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        }
      ]
    },
    "StackUpdateComplete": {
      "delay": 30,
      "maxAttempts": 120,
      "operation": "DescribeStacks",
      "description": "Wait until stack status is UPDATE_COMPLETE.",
      "acceptors": [
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_COMPLETE",
          "matcher": "pathAll",
          "state": "success"
        },
        {
          "expected": "UPDATE_FAILED",
          "matcher": "pathAny",
          "state": "failure",
          "argument": "Stacks[].StackStatus"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_COMPLETE",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_FAILED",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "argument": "Stacks[].StackStatus",
          "expected": "UPDATE_ROLLBACK_IN_PROGRESS",
          "matcher": "pathAny",
          "state": "failure"
        },
        {
          "expected": "ValidationError",
          "matcher": "error",
          "state": "failure"
        }
      ]
    }
  }
}
                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/                                     0042755 0000000 0000062 00000000000 13077704402 023132  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-05-31/                          0042755 0000000 0000062 00000000000 13077704402 024163  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-05-31/paginators-1.json         0100644 0000000 0000062 00000002146 13077704371 027366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "pagination": {
    "ListCloudFrontOriginAccessIdentities": {
      "input_token": "Marker",
      "output_token": "CloudFrontOriginAccessIdentityList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "CloudFrontOriginAccessIdentityList.IsTruncated",
      "result_key": "CloudFrontOriginAccessIdentityList.Items"
    },
    "ListDistributions": {
      "input_token": "Marker",
      "output_token": "DistributionList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "DistributionList.IsTruncated",
      "result_key": "DistributionList.Items"
    },
    "ListInvalidations": {
      "input_token": "Marker",
      "output_token": "InvalidationList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "InvalidationList.IsTruncated",
      "result_key": "InvalidationList.Items"
    },
    "ListStreamingDistributions": {
      "input_token": "Marker",
      "output_token": "StreamingDistributionList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "StreamingDistributionList.IsTruncated",
      "result_key": "StreamingDistributionList.Items"
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-05-31/service-2.json            0100644 0000000 0000062 00000432116 13077704371 026664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "metadata":{
    "apiVersion":"2014-05-31",
    "endpointPrefix":"cloudfront",
    "globalEndpoint":"cloudfront.amazonaws.com",
    "serviceAbbreviation":"CloudFront",
    "serviceFullName":"Amazon CloudFront",
    "signatureVersion":"v4",
    "protocol":"rest-xml"
  },
  "operations":{
    "CreateCloudFrontOriginAccessIdentity":{
      "name":"CreateCloudFrontOriginAccessIdentity2014_05_31",
      "http":{
        "method":"POST",
        "requestUri":"/2014-05-31/origin-access-identity/cloudfront",
        "responseCode":201
      },
      "input":{
        "shape":"CreateCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to create a new origin access identity."
      },
      "output":{
        "shape":"CreateCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CloudFrontOriginAccessIdentityAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true,
          "documentation":"If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyCloudFrontOriginAccessIdentities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of origin access identities allowed."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new origin access identity."
    },
    "CreateDistribution":{
      "name":"CreateDistribution2014_05_31",
      "http":{
        "method":"POST",
        "requestUri":"/2014-05-31/distribution",
        "responseCode":201
      },
      "input":{
        "shape":"CreateDistributionRequest",
        "documentation":"The request to create a new distribution."
      },
      "output":{
        "shape":"CreateDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"DistributionAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true,
          "documentation":"The caller reference you attempted to create the distribution with is associated with another distribution."
        },
        {
          "shape":"InvalidOrigin",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InvalidViewerCertificate",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more CNAMEs than are allowed per distribution."
        },
        {
          "shape":"TooManyDistributions",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of distributions allowed."
        },
        {
          "shape":"InvalidDefaultRootObject",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The default root object file name is too big or contains an invalid character."
        },
        {
          "shape":"InvalidRelativePath",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
        },
        {
          "shape":"InvalidErrorCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidResponseCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidRequiredProtocol",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
        },
        {
          "shape":"NoSuchOrigin",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"No origin exists with the specified Origin Id."
        },
        {
          "shape":"TooManyOrigins",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore origins for the distribution."
        },
        {
          "shape":"TooManyCacheBehaviors",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore cache behaviors for the distribution."
        },
        {
          "shape":"TooManyCookieNamesInWhiteList",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
        },
        {
          "shape":"InvalidForwardCookies",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
        },
        {
          "shape":"TooManyHeadersInForwardedValues",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidHeadersForS3Origin",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        },
        {
          "shape":"TooManyCertificates",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore custom ssl certificates."
        },
        {
          "shape":"InvalidLocationCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidGeoRestrictionParameter",
          "error":{"httpStatusCode":400},
          "exception":true
        }
      ],
      "documentation":"Create a new distribution."
    },
    "CreateInvalidation":{
      "name":"CreateInvalidation2014_05_31",
      "http":{
        "method":"POST",
        "requestUri":"/2014-05-31/distribution/{DistributionId}/invalidation",
        "responseCode":201
      },
      "input":{
        "shape":"CreateInvalidationRequest",
        "documentation":"The request to create an invalidation."
      },
      "output":{
        "shape":"CreateInvalidationResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"BatchTooLarge",
          "error":{"httpStatusCode":413},
          "exception":true
        },
        {
          "shape":"TooManyInvalidationsInProgress",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new invalidation."
    },
    "CreateStreamingDistribution":{
      "name":"CreateStreamingDistribution2014_05_31",
      "http":{
        "method":"POST",
        "requestUri":"/2014-05-31/streaming-distribution",
        "responseCode":201
      },
      "input":{
        "shape":"CreateStreamingDistributionRequest",
        "documentation":"The request to create a new streaming distribution."
      },
      "output":{
        "shape":"CreateStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"StreamingDistributionAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidOrigin",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyStreamingDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"TooManyStreamingDistributions",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of streaming distributions allowed."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new streaming distribution."
    },
    "DeleteCloudFrontOriginAccessIdentity":{
      "name":"DeleteCloudFrontOriginAccessIdentity2014_05_31",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-05-31/origin-access-identity/cloudfront/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to delete a origin access identity."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"CloudFrontOriginAccessIdentityInUse",
          "error":{"httpStatusCode":409},
          "exception":true
        }
      ],
      "documentation":"Delete an origin access identity."
    },
    "DeleteDistribution":{
      "name":"DeleteDistribution2014_05_31",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-05-31/distribution/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteDistributionRequest",
        "documentation":"The request to delete a distribution."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"DistributionNotDisabled",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        }
      ],
      "documentation":"Delete a distribution."
    },
    "DeleteStreamingDistribution":{
      "name":"DeleteStreamingDistribution2014_05_31",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-05-31/streaming-distribution/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteStreamingDistributionRequest",
        "documentation":"The request to delete a streaming distribution."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"StreamingDistributionNotDisabled",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        }
      ],
      "documentation":"Delete a streaming distribution."
    },
    "GetCloudFrontOriginAccessIdentity":{
      "name":"GetCloudFrontOriginAccessIdentity2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/origin-access-identity/cloudfront/{Id}"
      },
      "input":{
        "shape":"GetCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to get an origin access identity's information."
      },
      "output":{
        "shape":"GetCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about an origin access identity."
    },
    "GetCloudFrontOriginAccessIdentityConfig":{
      "name":"GetCloudFrontOriginAccessIdentityConfig2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/origin-access-identity/cloudfront/{Id}/config"
      },
      "input":{
        "shape":"GetCloudFrontOriginAccessIdentityConfigRequest",
        "documentation":"The request to get an origin access identity's configuration."
      },
      "output":{
        "shape":"GetCloudFrontOriginAccessIdentityConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about an origin access identity."
    },
    "GetDistribution":{
      "name":"GetDistribution2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/distribution/{Id}"
      },
      "input":{
        "shape":"GetDistributionRequest",
        "documentation":"The request to get a distribution's information."
      },
      "output":{
        "shape":"GetDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about a distribution."
    },
    "GetDistributionConfig":{
      "name":"GetDistributionConfig2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/distribution/{Id}/config"
      },
      "input":{
        "shape":"GetDistributionConfigRequest",
        "documentation":"The request to get a distribution configuration."
      },
      "output":{
        "shape":"GetDistributionConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about a distribution."
    },
    "GetInvalidation":{
      "name":"GetInvalidation2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/distribution/{DistributionId}/invalidation/{Id}"
      },
      "input":{
        "shape":"GetInvalidationRequest",
        "documentation":"The request to get an invalidation's information."
      },
      "output":{
        "shape":"GetInvalidationResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchInvalidation",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified invalidation does not exist."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about an invalidation."
    },
    "GetStreamingDistribution":{
      "name":"GetStreamingDistribution2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/streaming-distribution/{Id}"
      },
      "input":{
        "shape":"GetStreamingDistributionRequest",
        "documentation":"The request to get a streaming distribution's information."
      },
      "output":{
        "shape":"GetStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about a streaming distribution."
    },
    "GetStreamingDistributionConfig":{
      "name":"GetStreamingDistributionConfig2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/streaming-distribution/{Id}/config"
      },
      "input":{
        "shape":"GetStreamingDistributionConfigRequest",
        "documentation":"To request to get a streaming distribution configuration."
      },
      "output":{
        "shape":"GetStreamingDistributionConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about a streaming distribution."
    },
    "ListCloudFrontOriginAccessIdentities":{
      "name":"ListCloudFrontOriginAccessIdentities2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/origin-access-identity/cloudfront"
      },
      "input":{
        "shape":"ListCloudFrontOriginAccessIdentitiesRequest",
        "documentation":"The request to list origin access identities."
      },
      "output":{
        "shape":"ListCloudFrontOriginAccessIdentitiesResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List origin access identities."
    },
    "ListDistributions":{
      "name":"ListDistributions2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/distribution"
      },
      "input":{
        "shape":"ListDistributionsRequest",
        "documentation":"The request to list your distributions."
      },
      "output":{
        "shape":"ListDistributionsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List distributions."
    },
    "ListInvalidations":{
      "name":"ListInvalidations2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/distribution/{DistributionId}/invalidation"
      },
      "input":{
        "shape":"ListInvalidationsRequest",
        "documentation":"The request to list invalidations."
      },
      "output":{
        "shape":"ListInvalidationsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"List invalidation batches."
    },
    "ListStreamingDistributions":{
      "name":"ListStreamingDistributions2014_05_31",
      "http":{
        "method":"GET",
        "requestUri":"/2014-05-31/streaming-distribution"
      },
      "input":{
        "shape":"ListStreamingDistributionsRequest",
        "documentation":"The request to list your streaming distributions."
      },
      "output":{
        "shape":"ListStreamingDistributionsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List streaming distributions."
    },
    "UpdateCloudFrontOriginAccessIdentity":{
      "name":"UpdateCloudFrontOriginAccessIdentity2014_05_31",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-05-31/origin-access-identity/cloudfront/{Id}/config"
      },
      "input":{
        "shape":"UpdateCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to update an origin access identity."
      },
      "output":{
        "shape":"UpdateCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Update an origin access identity."
    },
    "UpdateDistribution":{
      "name":"UpdateDistribution2014_05_31",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-05-31/distribution/{Id}/config"
      },
      "input":{
        "shape":"UpdateDistributionRequest",
        "documentation":"The request to update a distribution."
      },
      "output":{
        "shape":"UpdateDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"TooManyDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more CNAMEs than are allowed per distribution."
        },
        {
          "shape":"InvalidDefaultRootObject",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The default root object file name is too big or contains an invalid character."
        },
        {
          "shape":"InvalidRelativePath",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
        },
        {
          "shape":"InvalidErrorCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidResponseCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InvalidViewerCertificate",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidRequiredProtocol",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
        },
        {
          "shape":"NoSuchOrigin",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"No origin exists with the specified Origin Id."
        },
        {
          "shape":"TooManyOrigins",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore origins for the distribution."
        },
        {
          "shape":"TooManyCacheBehaviors",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore cache behaviors for the distribution."
        },
        {
          "shape":"TooManyCookieNamesInWhiteList",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
        },
        {
          "shape":"InvalidForwardCookies",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
        },
        {
          "shape":"TooManyHeadersInForwardedValues",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidHeadersForS3Origin",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        },
        {
          "shape":"TooManyCertificates",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore custom ssl certificates."
        },
        {
          "shape":"InvalidLocationCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidGeoRestrictionParameter",
          "error":{"httpStatusCode":400},
          "exception":true
        }
      ],
      "documentation":"Update a distribution."
    },
    "UpdateStreamingDistribution":{
      "name":"UpdateStreamingDistribution2014_05_31",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-05-31/streaming-distribution/{Id}/config"
      },
      "input":{
        "shape":"UpdateStreamingDistributionRequest",
        "documentation":"The request to update a streaming distribution."
      },
      "output":{
        "shape":"UpdateStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"TooManyStreamingDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Update a streaming distribution."
    }
  },
  "shapes":{
    "AccessDenied":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":403},
      "exception":true,
      "documentation":"Access denied."
    },
    "ActiveTrustedSigners":{
      "type":"structure",
      "required":[
        "Enabled",
        "Quantity"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Each active trusted signer."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of unique trusted signers included in all cache behaviors. For example, if three cache behaviors all list the same three AWS accounts, the value of Quantity for ActiveTrustedSigners will be 3."
        },
        "Items":{
          "shape":"SignerList",
          "documentation":"A complex type that contains one Signer complex type for each unique trusted signer that is specified in the TrustedSigners complex type, including trusted signers in the default cache behavior and in all of the other cache behaviors."
        }
      },
      "documentation":"A complex type that lists the AWS accounts, if any, that you included in the TrustedSigners complex type for the default cache behavior or for any of the other cache behaviors for this distribution. These are accounts that you want to allow to create signed URLs for private content."
    },
    "AliasList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"CNAME"
      }
    },
    "Aliases":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of CNAMEs, if any, for this distribution."
        },
        "Items":{
          "shape":"AliasList",
          "documentation":"Optional: A complex type that contains CNAME elements, if any, for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
    },
    "AllowedMethods":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests) and 7 (for DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT requests)."
        },
        "Items":{
          "shape":"AllowedMethodsList",
          "documentation":"A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin."
        }
      },
      "documentation":"A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are two options: - CloudFront forwards only GET and HEAD requests. - CloudFront forwards DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT requests. If you choose the second option, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you may not want users to have permission to delete objects from your origin."
    },
    "AllowedMethodsList":{
      "type":"list",
      "member":{
        "shape":"Method",
        "locationName":"Method"
      }
    },
    "AwsAccountNumberList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"AwsAccountNumber"
      }
    },
    "BatchTooLarge":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":413},
      "exception":true
    },
    "CNAMEAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "CacheBehavior":{
      "type":"structure",
      "required":[
        "PathPattern",
        "TargetOriginId",
        "ForwardedValues",
        "TrustedSigners",
        "ViewerProtocolPolicy",
        "MinTTL"
      ],
      "members":{
        "PathPattern":{
          "shape":"string",
          "documentation":"The pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to. When CloudFront receives an end-user request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior."
        },
        "TargetOriginId":{
          "shape":"string",
          "documentation":"The value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."
        },
        "ForwardedValues":{
          "shape":"ForwardedValues",
          "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "ViewerProtocolPolicy":{
          "shape":"ViewerProtocolPolicy",
          "documentation":"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. If you want CloudFront to allow end users to use any available protocol, specify allow-all. If you want CloudFront to require HTTPS, specify https. If you want CloudFront to respond to an HTTP request with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https. The viewer then resubmits the request using the HTTPS URL."
        },
        "MinTTL":{
          "shape":"long",
          "documentation":"The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.You can specify a value from 0 to 3,153,600,000 seconds (100 years)."
        },
        "AllowedMethods":{"shape":"AllowedMethods"},
        "SmoothStreaming":{
          "shape":"boolean",
          "documentation":"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false."
        }
      },
      "documentation":"A complex type that describes how CloudFront processes requests. You can create up to 10 cache behaviors.You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to distribute objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin will never be used. If you don't want to specify any cache behaviors, include only an empty CacheBehaviors element. Don't include an empty CacheBehavior element, or CloudFront returns a MalformedXML error. To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution."
    },
    "CacheBehaviorList":{
      "type":"list",
      "member":{
        "shape":"CacheBehavior",
        "locationName":"CacheBehavior"
      }
    },
    "CacheBehaviors":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of cache behaviors for this distribution."
        },
        "Items":{
          "shape":"CacheBehaviorList",
          "documentation":"Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains zero or more CacheBehavior elements."
    },
    "CloudFrontOriginAccessIdentity":{
      "type":"structure",
      "required":[
        "Id",
        "S3CanonicalUserId"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The ID for the origin access identity. For example: E74FTE3AJFJ256A."
        },
        "S3CanonicalUserId":{
          "shape":"string",
          "documentation":"The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3."
        },
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The current configuration information for the identity."
        }
      },
      "documentation":"CloudFront origin access identity."
    },
    "CloudFrontOriginAccessIdentityAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true,
      "documentation":"If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
    },
    "CloudFrontOriginAccessIdentityConfig":{
      "type":"structure",
      "required":[
        "CallerReference",
        "Comment"
      ],
      "members":{
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique number that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value you already sent in a previous request to create an identity, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
        },
        "Comment":{
          "shape":"string",
          "documentation":"Any comments you want to include about the origin access identity."
        }
      },
      "documentation":"Origin access identity configuration."
    },
    "CloudFrontOriginAccessIdentityInUse":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "CloudFrontOriginAccessIdentityList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of CloudFront origin access identities that were created by the current AWS account."
        },
        "Items":{
          "shape":"CloudFrontOriginAccessIdentitySummaryList",
          "documentation":"A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current AWS account."
        }
      },
      "documentation":"The CloudFrontOriginAccessIdentityList type."
    },
    "CloudFrontOriginAccessIdentitySummary":{
      "type":"structure",
      "required":[
        "Id",
        "S3CanonicalUserId",
        "Comment"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The ID for the origin access identity. For example: E74FTE3AJFJ256A."
        },
        "S3CanonicalUserId":{
          "shape":"string",
          "documentation":"The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3."
        },
        "Comment":{
          "shape":"string",
          "documentation":"The comment for this origin access identity, as originally specified when created."
        }
      },
      "documentation":"Summary of the information about a CloudFront origin access identity."
    },
    "CloudFrontOriginAccessIdentitySummaryList":{
      "type":"list",
      "member":{
        "shape":"CloudFrontOriginAccessIdentitySummary",
        "locationName":"CloudFrontOriginAccessIdentitySummary"
      }
    },
    "CookieNameList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Name"
      }
    },
    "CookieNames":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of whitelisted cookies for this cache behavior."
        },
        "Items":{
          "shape":"CookieNameList",
          "documentation":"Optional: A complex type that contains whitelisted cookies for this cache behavior. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that specifies the whitelisted cookies, if any, that you want CloudFront to forward to your origin that is associated with this cache behavior."
    },
    "CookiePreference":{
      "type":"structure",
      "required":["Forward"],
      "members":{
        "Forward":{
          "shape":"ItemSelection",
          "documentation":"Use this element to specify whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If you choose All, CloudFront forwards all cookies regardless of how many your application uses."
        },
        "WhitelistedNames":{
          "shape":"CookieNames",
          "documentation":"A complex type that specifies the whitelisted cookies, if any, that you want CloudFront to forward to your origin that is associated with this cache behavior."
        }
      },
      "documentation":"A complex type that specifies the cookie preferences associated with this cache behavior."
    },
    "CreateCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "required":["CloudFrontOriginAccessIdentityConfig"],
      "members":{
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The origin access identity's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"CloudFrontOriginAccessIdentityConfig"
        }
      },
      "documentation":"The request to create a new origin access identity.",
      "payload":"CloudFrontOriginAccessIdentityConfig"
    },
    "CreateCloudFrontOriginAccessIdentityResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentity":{
          "shape":"CloudFrontOriginAccessIdentity",
          "documentation":"The origin access identity's information."
        },
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the new origin access identity just created. For example: https://cloudfront.amazonaws.com/2010-11-01/origin-access-identity/cloudfront/E74FTE3AJFJ256A."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the origin access identity created."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentity"
    },
    "CreateDistributionRequest":{
      "type":"structure",
      "required":["DistributionConfig"],
      "members":{
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"DistributionConfig"
        }
      },
      "documentation":"The request to create a new distribution.",
      "payload":"DistributionConfig"
    },
    "CreateDistributionResult":{
      "type":"structure",
      "members":{
        "Distribution":{
          "shape":"Distribution",
          "documentation":"The distribution's information."
        },
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the new distribution resource just created. For example: https://cloudfront.amazonaws.com/2010-11-01/distribution/EDFDVBD632BHDS5."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the distribution created."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Distribution"
    },
    "CreateInvalidationRequest":{
      "type":"structure",
      "required":[
        "DistributionId",
        "InvalidationBatch"
      ],
      "members":{
        "DistributionId":{
          "shape":"string",
          "location":"uri",
          "locationName":"DistributionId",
          "documentation":"The distribution's id."
        },
        "InvalidationBatch":{
          "shape":"InvalidationBatch",
          "documentation":"The batch information for the invalidation.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"InvalidationBatch"
        }
      },
      "documentation":"The request to create an invalidation.",
      "payload":"InvalidationBatch"
    },
    "CreateInvalidationResult":{
      "type":"structure",
      "members":{
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID."
        },
        "Invalidation":{
          "shape":"Invalidation",
          "documentation":"The invalidation's information."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Invalidation"
    },
    "CreateStreamingDistributionRequest":{
      "type":"structure",
      "required":["StreamingDistributionConfig"],
      "members":{
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The streaming distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"StreamingDistributionConfig"
        }
      },
      "documentation":"The request to create a new streaming distribution.",
      "payload":"StreamingDistributionConfig"
    },
    "CreateStreamingDistributionResult":{
      "type":"structure",
      "members":{
        "StreamingDistribution":{
          "shape":"StreamingDistribution",
          "documentation":"The streaming distribution's information."
        },
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the new streaming distribution resource just created. For example: https://cloudfront.amazonaws.com/2010-11-01/streaming-distribution/EGTXBD79H29TRA8."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the streaming distribution created."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistribution"
    },
    "CustomErrorResponse":{
      "type":"structure",
      "required":["ErrorCode"],
      "members":{
        "ErrorCode":{
          "shape":"integer",
          "documentation":"The 4xx or 5xx HTTP status code that you want to customize. For a list of HTTP status codes that you can customize, see CloudFront documentation."
        },
        "ResponsePagePath":{
          "shape":"string",
          "documentation":"The path of the custom error page (for example, /custom_404.html). The path is relative to the distribution and must begin with a slash (/). If the path includes any non-ASCII characters or unsafe characters as defined in RFC 1783 (http://www.ietf.org/rfc/rfc1738.txt), URL encode those characters. Do not URL encode any other characters in the path, or CloudFront will not return the custom error page to the viewer."
        },
        "ResponseCode":{
          "shape":"string",
          "documentation":"The HTTP status code that you want CloudFront to return with the custom error page to the viewer. For a list of HTTP status codes that you can replace, see CloudFront Documentation."
        },
        "ErrorCachingMinTTL":{
          "shape":"long",
          "documentation":"The minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. You can specify a value from 0 to 31,536,000."
        }
      },
      "documentation":"A complex type that describes how you'd prefer CloudFront to respond to requests that result in either a 4xx or 5xx response. You can control whether a custom error page should be displayed, what the desired response code should be for this error page and how long should the error response be cached by CloudFront. If you don't want to specify any custom error responses, include only an empty CustomErrorResponses element. To delete all custom error responses in an existing distribution, update the distribution configuration and include only an empty CustomErrorResponses element. To add, change, or remove one or more custom error responses, update the distribution configuration and specify all of the custom error responses that you want to include in the updated distribution."
    },
    "CustomErrorResponseList":{
      "type":"list",
      "member":{
        "shape":"CustomErrorResponse",
        "locationName":"CustomErrorResponse"
      }
    },
    "CustomErrorResponses":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of custom error responses for this distribution."
        },
        "Items":{
          "shape":"CustomErrorResponseList",
          "documentation":"Optional: A complex type that contains custom error responses for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains zero or more CustomErrorResponse elements."
    },
    "CustomOriginConfig":{
      "type":"structure",
      "required":[
        "HTTPPort",
        "HTTPSPort",
        "OriginProtocolPolicy"
      ],
      "members":{
        "HTTPPort":{
          "shape":"integer",
          "documentation":"The HTTP port the custom origin listens on."
        },
        "HTTPSPort":{
          "shape":"integer",
          "documentation":"The HTTPS port the custom origin listens on."
        },
        "OriginProtocolPolicy":{
          "shape":"OriginProtocolPolicy",
          "documentation":"The origin protocol policy to apply to your origin."
        }
      },
      "documentation":"A customer origin."
    },
    "DefaultCacheBehavior":{
      "type":"structure",
      "required":[
        "TargetOriginId",
        "ForwardedValues",
        "TrustedSigners",
        "ViewerProtocolPolicy",
        "MinTTL"
      ],
      "members":{
        "TargetOriginId":{
          "shape":"string",
          "documentation":"The value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."
        },
        "ForwardedValues":{
          "shape":"ForwardedValues",
          "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "ViewerProtocolPolicy":{
          "shape":"ViewerProtocolPolicy",
          "documentation":"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. If you want CloudFront to allow end users to use any available protocol, specify allow-all. If you want CloudFront to require HTTPS, specify https. If you want CloudFront to respond to an HTTP request with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https. The viewer then resubmits the request using the HTTPS URL."
        },
        "MinTTL":{
          "shape":"long",
          "documentation":"The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.You can specify a value from 0 to 3,153,600,000 seconds (100 years)."
        },
        "AllowedMethods":{"shape":"AllowedMethods"},
        "SmoothStreaming":{
          "shape":"boolean",
          "documentation":"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false."
        }
      },
      "documentation":"A complex type that describes the default cache behavior if you do not specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements.You must create exactly one default cache behavior."
    },
    "DeleteCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The origin access identity's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to delete a origin access identity.",
      "required":["Id"]
    },
    "DeleteDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when you disabled the distribution. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to delete a distribution.",
      "required":["Id"]
    },
    "DeleteStreamingDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to delete a streaming distribution.",
      "required":["Id"]
    },
    "Distribution":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "LastModifiedTime",
        "InProgressInvalidationBatches",
        "DomainName",
        "ActiveTrustedSigners",
        "DistributionConfig"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the distribution. For example: EDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"This response element indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "InProgressInvalidationBatches":{
          "shape":"integer",
          "documentation":"The number of invalidation batches currently in progress."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the distribution. For example: d604721fxaaqy9.cloudfront.net."
        },
        "ActiveTrustedSigners":{
          "shape":"ActiveTrustedSigners",
          "documentation":"CloudFront automatically adds this element to the response only if you've set up the distribution to serve private content with signed URLs. The element lists the key pair IDs that CloudFront is aware of for each trusted signer. The Signer child element lists the AWS account number of the trusted signer (or an empty Self element if the signer is you). The Signer element also includes the IDs of any active key pairs associated with the trusted signer's AWS account. If no KeyPairId element appears for a Signer, that signer can't create working signed URLs."
        },
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The current configuration information for the distribution."
        }
      },
      "documentation":"A distribution."
    },
    "DistributionAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true,
      "documentation":"The caller reference you attempted to create the distribution with is associated with another distribution."
    },
    "DistributionConfig":{
      "type":"structure",
      "required":[
        "CallerReference",
        "Aliases",
        "DefaultRootObject",
        "Origins",
        "DefaultCacheBehavior",
        "CacheBehaviors",
        "Comment",
        "Logging",
        "PriceClass",
        "Enabled"
      ],
      "members":{
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique number that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the DistributionConfig object), a new distribution is created. If the CallerReference is a value you already sent in a previous request to create a distribution, and the content of the DistributionConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create a distribution but the content of the DistributionConfig is different from the original request, CloudFront returns a DistributionAlreadyExists error."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
        },
        "DefaultRootObject":{
          "shape":"string",
          "documentation":"The object that you want CloudFront to return (for example, index.html) when an end user requests the root URL for your distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/index.html). Specifying a default root object avoids exposing the contents of your distribution. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object."
        },
        "Origins":{
          "shape":"Origins",
          "documentation":"A complex type that contains information about origins for this distribution."
        },
        "DefaultCacheBehavior":{
          "shape":"DefaultCacheBehavior",
          "documentation":"A complex type that describes the default cache behavior if you do not specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements.You must create exactly one default cache behavior."
        },
        "CacheBehaviors":{
          "shape":"CacheBehaviors",
          "documentation":"A complex type that contains zero or more CacheBehavior elements."
        },
        "CustomErrorResponses":{
          "shape":"CustomErrorResponses",
          "documentation":"A complex type that contains zero or more CustomErrorResponse elements."
        },
        "Comment":{
          "shape":"string",
          "documentation":"Any comments you want to include about the distribution."
        },
        "Logging":{
          "shape":"LoggingConfig",
          "documentation":"A complex type that controls whether access logs are written for the distribution."
        },
        "PriceClass":{
          "shape":"PriceClass",
          "documentation":"A complex type that contains information about price class for this distribution."
        },
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the distribution is enabled to accept end user requests for content."
        },
        "ViewerCertificate":{"shape":"ViewerCertificate"},
        "Restrictions":{"shape":"Restrictions"}
      },
      "documentation":"A distribution Configuration."
    },
    "DistributionList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of distributions that were created by the current AWS account."
        },
        "Items":{
          "shape":"DistributionSummaryList",
          "documentation":"A complex type that contains one DistributionSummary element for each distribution that was created by the current AWS account."
        }
      },
      "documentation":"A distribution list."
    },
    "DistributionNotDisabled":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "DistributionSummary":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "LastModifiedTime",
        "DomainName",
        "Aliases",
        "Origins",
        "DefaultCacheBehavior",
        "CacheBehaviors",
        "CustomErrorResponses",
        "Comment",
        "PriceClass",
        "Enabled",
        "ViewerCertificate",
        "Restrictions"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the distribution. For example: EDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"This response element indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the distribution. For example: d604721fxaaqy9.cloudfront.net."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
        },
        "Origins":{
          "shape":"Origins",
          "documentation":"A complex type that contains information about origins for this distribution."
        },
        "DefaultCacheBehavior":{
          "shape":"DefaultCacheBehavior",
          "documentation":"A complex type that describes the default cache behavior if you do not specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements.You must create exactly one default cache behavior."
        },
        "CacheBehaviors":{
          "shape":"CacheBehaviors",
          "documentation":"A complex type that contains zero or more CacheBehavior elements."
        },
        "CustomErrorResponses":{
          "shape":"CustomErrorResponses",
          "documentation":"A complex type that contains zero or more CustomErrorResponses elements."
        },
        "Comment":{
          "shape":"string",
          "documentation":"The comment originally specified when this distribution was created."
        },
        "PriceClass":{"shape":"PriceClass"},
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the distribution is enabled to accept end user requests for content."
        },
        "ViewerCertificate":{"shape":"ViewerCertificate"},
        "Restrictions":{"shape":"Restrictions"}
      },
      "documentation":"A summary of the information for an Amazon CloudFront distribution."
    },
    "DistributionSummaryList":{
      "type":"list",
      "member":{
        "shape":"DistributionSummary",
        "locationName":"DistributionSummary"
      }
    },
    "ForwardedValues":{
      "type":"structure",
      "required":[
        "QueryString",
        "Cookies"
      ],
      "members":{
        "QueryString":{
          "shape":"boolean",
          "documentation":"Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior. If so, specify true; if not, specify false."
        },
        "Cookies":{
          "shape":"CookiePreference",
          "documentation":"A complex type that specifies how CloudFront handles cookies."
        },
        "Headers":{
          "shape":"Headers",
          "documentation":"A complex type that specifies the Headers, if any, that you want CloudFront to vary upon for this cache behavior."
        }
      },
      "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
    },
    "GeoRestriction":{
      "type":"structure",
      "required":[
        "RestrictionType",
        "Quantity"
      ],
      "members":{
        "RestrictionType":{
          "shape":"GeoRestrictionType",
          "documentation":"The method that you want to use to restrict distribution of your content by country: - none: No geo restriction is enabled, meaning access to content is not restricted by client geo location. - blacklist: The Location elements specify the countries in which you do not want CloudFront to distribute your content. - whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items."
        },
        "Items":{
          "shape":"LocationList",
          "documentation":"A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list in the CloudFront console, which includes both country names and codes."
        }
      },
      "documentation":"A complex type that controls the countries in which your content is distributed. For more information about geo restriction, go to Customizing Error Responses in the Amazon CloudFront Developer Guide. CloudFront determines the location of your users using MaxMind GeoIP databases. For information about the accuracy of these databases, see How accurate are your GeoIP databases? on the MaxMind website."
    },
    "GeoRestrictionType":{
      "type":"string",
      "enum":[
        "blacklist",
        "whitelist",
        "none"
      ]
    },
    "GetCloudFrontOriginAccessIdentityConfigRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The identity's id."
        }
      },
      "documentation":"The request to get an origin access identity's configuration.",
      "required":["Id"]
    },
    "GetCloudFrontOriginAccessIdentityConfigResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The origin access identity's configuration information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentityConfig"
    },
    "GetCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The identity's id."
        }
      },
      "documentation":"The request to get an origin access identity's information.",
      "required":["Id"]
    },
    "GetCloudFrontOriginAccessIdentityResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentity":{
          "shape":"CloudFrontOriginAccessIdentity",
          "documentation":"The origin access identity's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentity"
    },
    "GetDistributionConfigRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution's id."
        }
      },
      "documentation":"The request to get a distribution configuration.",
      "required":["Id"]
    },
    "GetDistributionConfigResult":{
      "type":"structure",
      "members":{
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The distribution's configuration information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"DistributionConfig"
    },
    "GetDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution's id."
        }
      },
      "documentation":"The request to get a distribution's information.",
      "required":["Id"]
    },
    "GetDistributionResult":{
      "type":"structure",
      "members":{
        "Distribution":{
          "shape":"Distribution",
          "documentation":"The distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the distribution's information. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Distribution"
    },
    "GetInvalidationRequest":{
      "type":"structure",
      "required":[
        "DistributionId",
        "Id"
      ],
      "members":{
        "DistributionId":{
          "shape":"string",
          "location":"uri",
          "locationName":"DistributionId",
          "documentation":"The distribution's id."
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The invalidation's id."
        }
      },
      "documentation":"The request to get an invalidation's information."
    },
    "GetInvalidationResult":{
      "type":"structure",
      "members":{
        "Invalidation":{
          "shape":"Invalidation",
          "documentation":"The invalidation's information."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Invalidation"
    },
    "GetStreamingDistributionConfigRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The streaming distribution's id."
        }
      },
      "documentation":"To request to get a streaming distribution configuration.",
      "required":["Id"]
    },
    "GetStreamingDistributionConfigResult":{
      "type":"structure",
      "members":{
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The streaming distribution's configuration information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistributionConfig"
    },
    "GetStreamingDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The streaming distribution's id."
        }
      },
      "documentation":"The request to get a streaming distribution's information.",
      "required":["Id"]
    },
    "GetStreamingDistributionResult":{
      "type":"structure",
      "members":{
        "StreamingDistribution":{
          "shape":"StreamingDistribution",
          "documentation":"The streaming distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistribution"
    },
    "HeaderList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Name"
      }
    },
    "Headers":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of different headers that you want CloudFront to forward to the origin and to vary on for this cache behavior. The maximum number of headers that you can specify by name is 10. If you want CloudFront to forward all headers to the origin and vary on all of them, specify 1 for Quantity and * for Name. If you don't want CloudFront to forward any additional headers to the origin or to vary on any headers, specify 0 for Quantity and omit Items."
        },
        "Items":{
          "shape":"HeaderList",
          "documentation":"Optional: A complex type that contains a Name element for each header that you want CloudFront to forward to the origin and to vary on for this cache behavior. If Quantity is 0, omit Items."
        }
      },
      "documentation":"A complex type that specifies the headers that you want CloudFront to forward to the origin for this cache behavior. For the headers that you specify, CloudFront also caches separate versions of a given object based on the header values in viewer requests; this is known as varying on headers. For example, suppose viewer requests for logo.jpg contain a custom Product header that has a value of either Acme or Apex, and you configure CloudFront to vary on the Product header. CloudFront forwards the Product header to the origin and caches the response from the origin once for each header value."
    },
    "IllegalUpdate":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Origin and CallerReference cannot be updated."
    },
    "InconsistentQuantities":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The value of Quantity and the size of Items do not match."
    },
    "InvalidArgument":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The argument is invalid."
    },
    "InvalidDefaultRootObject":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The default root object file name is too big or contains an invalid character."
    },
    "InvalidErrorCode":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidForwardCookies":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
    },
    "InvalidGeoRestrictionParameter":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidHeadersForS3Origin":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidIfMatchVersion":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The If-Match version is missing or not valid for the distribution."
    },
    "InvalidLocationCode":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidOrigin":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
    },
    "InvalidOriginAccessIdentity":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The origin access identity is not valid or doesn't exist."
    },
    "InvalidRelativePath":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
    },
    "InvalidRequiredProtocol":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
    },
    "InvalidResponseCode":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidViewerCertificate":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "Invalidation":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "CreateTime",
        "InvalidationBatch"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the invalidation request. For example: IDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"The status of the invalidation request. When the invalidation batch is finished, the status is Completed."
        },
        "CreateTime":{
          "shape":"timestamp",
          "documentation":"The date and time the invalidation request was first made."
        },
        "InvalidationBatch":{
          "shape":"InvalidationBatch",
          "documentation":"The current invalidation information for the batch request."
        }
      },
      "documentation":"An invalidation."
    },
    "InvalidationBatch":{
      "type":"structure",
      "required":[
        "Paths",
        "CallerReference"
      ],
      "members":{
        "Paths":{
          "shape":"Paths",
          "documentation":"The path of the object to invalidate. The path is relative to the distribution and must begin with a slash (/). You must enclose each invalidation object with the Path element tags. If the path includes non-ASCII characters or unsafe characters as defined in RFC 1783 (http://www.ietf.org/rfc/rfc1738.txt), URL encode those characters. Do not URL encode any other characters in the path, or CloudFront will not invalidate the old version of the updated object."
        },
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique name that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the Path object), a new distribution is created. If the CallerReference is a value you already sent in a previous request to create an invalidation batch, and the content of each Path element is identical to the original request, the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create a distribution but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error."
        }
      },
      "documentation":"An invalidation batch."
    },
    "InvalidationList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your invalidation batches where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of invalidation batches that were created by the current AWS account."
        },
        "Items":{
          "shape":"InvalidationSummaryList",
          "documentation":"A complex type that contains one InvalidationSummary element for each invalidation batch that was created by the current AWS account."
        }
      },
      "documentation":"An invalidation list."
    },
    "InvalidationSummary":{
      "type":"structure",
      "required":[
        "Id",
        "CreateTime",
        "Status"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The unique ID for an invalidation request."
        },
        "CreateTime":{"shape":"timestamp"},
        "Status":{
          "shape":"string",
          "documentation":"The status of an invalidation request."
        }
      },
      "documentation":"Summary of an invalidation request."
    },
    "InvalidationSummaryList":{
      "type":"list",
      "member":{
        "shape":"InvalidationSummary",
        "locationName":"InvalidationSummary"
      }
    },
    "ItemSelection":{
      "type":"string",
      "enum":[
        "none",
        "whitelist",
        "all"
      ]
    },
    "KeyPairIdList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"KeyPairId"
      }
    },
    "KeyPairIds":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of active CloudFront key pairs for AwsAccountNumber."
        },
        "Items":{
          "shape":"KeyPairIdList",
          "documentation":"A complex type that lists the active CloudFront key pairs, if any, that are associated with AwsAccountNumber."
        }
      },
      "documentation":"A complex type that lists the active CloudFront key pairs, if any, that are associated with AwsAccountNumber."
    },
    "ListCloudFrontOriginAccessIdentitiesRequest":{
      "type":"structure",
      "members":{
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page)."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of origin access identities you want in the response body."
        }
      },
      "documentation":"The request to list origin access identities."
    },
    "ListCloudFrontOriginAccessIdentitiesResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentityList":{
          "shape":"CloudFrontOriginAccessIdentityList",
          "documentation":"The CloudFrontOriginAccessIdentityList type."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentityList"
    },
    "ListDistributionsRequest":{
      "type":"structure",
      "members":{
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page)."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of distributions you want in the response body."
        }
      },
      "documentation":"The request to list your distributions."
    },
    "ListDistributionsResult":{
      "type":"structure",
      "members":{
        "DistributionList":{
          "shape":"DistributionList",
          "documentation":"The DistributionList type."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"DistributionList"
    },
    "ListInvalidationsRequest":{
      "type":"structure",
      "required":["DistributionId"],
      "members":{
        "DistributionId":{
          "shape":"string",
          "location":"uri",
          "locationName":"DistributionId",
          "documentation":"The distribution's id."
        },
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of invalidation batches you want in the response body."
        }
      },
      "documentation":"The request to list invalidations."
    },
    "ListInvalidationsResult":{
      "type":"structure",
      "members":{
        "InvalidationList":{
          "shape":"InvalidationList",
          "documentation":"Information about invalidation batches."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"InvalidationList"
    },
    "ListStreamingDistributionsRequest":{
      "type":"structure",
      "members":{
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this when paginating results to indicate where to begin in your list of streaming distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page)."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of streaming distributions you want in the response body."
        }
      },
      "documentation":"The request to list your streaming distributions."
    },
    "ListStreamingDistributionsResult":{
      "type":"structure",
      "members":{
        "StreamingDistributionList":{
          "shape":"StreamingDistributionList",
          "documentation":"The StreamingDistributionList type."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistributionList"
    },
    "LocationList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Location"
      }
    },
    "LoggingConfig":{
      "type":"structure",
      "required":[
        "Enabled",
        "IncludeCookies",
        "Bucket",
        "Prefix"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you do not want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix and IncludeCookies, the values are automatically deleted."
        },
        "IncludeCookies":{
          "shape":"boolean",
          "documentation":"Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you do not want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies."
        },
        "Bucket":{
          "shape":"string",
          "documentation":"The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com."
        },
        "Prefix":{
          "shape":"string",
          "documentation":"An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you do not want to specify a prefix, you still must include an empty Prefix element in the Logging element."
        }
      },
      "documentation":"A complex type that controls whether access logs are written for the distribution."
    },
    "Method":{
      "type":"string",
      "enum":[
        "GET",
        "HEAD",
        "POST",
        "PUT",
        "PATCH",
        "OPTIONS",
        "DELETE"
      ]
    },
    "MissingBody":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
    },
    "NoSuchCloudFrontOriginAccessIdentity":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified origin access identity does not exist."
    },
    "NoSuchDistribution":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified distribution does not exist."
    },
    "NoSuchInvalidation":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified invalidation does not exist."
    },
    "NoSuchOrigin":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"No origin exists with the specified Origin Id."
    },
    "NoSuchStreamingDistribution":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified streaming distribution does not exist."
    },
    "Origin":{
      "type":"structure",
      "required":[
        "Id",
        "DomainName"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"A unique identifier for the origin. The value of Id must be unique within the distribution. You use the value of Id when you create a cache behavior. The Id identifies the origin that CloudFront routes a request to when the request matches the path pattern for that cache behavior."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"Amazon S3 origins: The DNS name of the Amazon S3 bucket from which you want CloudFront to get objects for this origin, for example, myawsbucket.s3.amazonaws.com. Custom origins: The DNS domain name for the HTTP server from which you want CloudFront to get objects for this origin, for example, www.example.com."
        },
        "S3OriginConfig":{
          "shape":"S3OriginConfig",
          "documentation":"A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin, use the CustomOriginConfig element instead."
        },
        "CustomOriginConfig":{
          "shape":"CustomOriginConfig",
          "documentation":"A complex type that contains information about a custom origin. If the origin is an Amazon S3 bucket, use the S3OriginConfig element instead."
        }
      },
      "documentation":"A complex type that describes the Amazon S3 bucket or the HTTP server (for example, a web server) from which CloudFront gets your files.You must create at least one origin."
    },
    "OriginList":{
      "type":"list",
      "member":{
        "shape":"Origin",
        "locationName":"Origin"
      },
      "min":1
    },
    "OriginProtocolPolicy":{
      "type":"string",
      "enum":[
        "http-only",
        "match-viewer"
      ]
    },
    "Origins":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of origins for this distribution."
        },
        "Items":{
          "shape":"OriginList",
          "documentation":"A complex type that contains origins for this distribution."
        }
      },
      "documentation":"A complex type that contains information about origins for this distribution."
    },
    "PathList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Path"
      }
    },
    "Paths":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of objects that you want to invalidate."
        },
        "Items":{
          "shape":"PathList",
          "documentation":"A complex type that contains a list of the objects that you want to invalidate."
        }
      },
      "documentation":"A complex type that contains information about the objects that you want to invalidate."
    },
    "PreconditionFailed":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":412},
      "exception":true,
      "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
    },
    "PriceClass":{
      "type":"string",
      "enum":[
        "PriceClass_100",
        "PriceClass_200",
        "PriceClass_All"
      ]
    },
    "Restrictions":{
      "type":"structure",
      "required":["GeoRestriction"],
      "members":{
        "GeoRestriction":{"shape":"GeoRestriction"}
      },
      "documentation":"A complex type that identifies ways in which you want to restrict distribution of your content."
    },
    "S3Origin":{
      "type":"structure",
      "required":[
        "DomainName",
        "OriginAccessIdentity"
      ],
      "members":{
        "DomainName":{
          "shape":"string",
          "documentation":"The DNS name of the S3 origin."
        },
        "OriginAccessIdentity":{
          "shape":"string",
          "documentation":"Your S3 origin's origin access identity."
        }
      },
      "documentation":"A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution."
    },
    "S3OriginConfig":{
      "type":"structure",
      "required":["OriginAccessIdentity"],
      "members":{
        "OriginAccessIdentity":{
          "shape":"string",
          "documentation":"The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. Use the format origin-access-identity/cloudfront/Id where Id is the value that CloudFront returned in the Id element when you created the origin access identity."
        }
      },
      "documentation":"A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin, use the CustomOriginConfig element instead."
    },
    "SSLSupportMethod":{
      "type":"string",
      "enum":[
        "sni-only",
        "vip"
      ]
    },
    "Signer":{
      "type":"structure",
      "members":{
        "AwsAccountNumber":{
          "shape":"string",
          "documentation":"Specifies an AWS account that can create signed URLs. Values: self, which indicates that the AWS account that was used to create the distribution can created signed URLs, or an AWS account number. Omit the dashes in the account number."
        },
        "KeyPairIds":{
          "shape":"KeyPairIds",
          "documentation":"A complex type that lists the active CloudFront key pairs, if any, that are associated with AwsAccountNumber."
        }
      },
      "documentation":"A complex type that lists the AWS accounts that were included in the TrustedSigners complex type, as well as their active CloudFront key pair IDs, if any."
    },
    "SignerList":{
      "type":"list",
      "member":{
        "shape":"Signer",
        "locationName":"Signer"
      }
    },
    "StreamingDistribution":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "DomainName",
        "ActiveTrustedSigners",
        "StreamingDistributionConfig"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the streaming distribution. For example: EGTXBD79H29TRA8."
        },
        "Status":{
          "shape":"string",
          "documentation":"The current status of the streaming distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the streaming distribution. For example: s5c39gqb8ow64r.cloudfront.net."
        },
        "ActiveTrustedSigners":{
          "shape":"ActiveTrustedSigners",
          "documentation":"CloudFront automatically adds this element to the response only if you've set up the distribution to serve private content with signed URLs. The element lists the key pair IDs that CloudFront is aware of for each trusted signer. The Signer child element lists the AWS account number of the trusted signer (or an empty Self element if the signer is you). The Signer element also includes the IDs of any active key pairs associated with the trusted signer's AWS account. If no KeyPairId element appears for a Signer, that signer can't create working signed URLs."
        },
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The current configuration information for the streaming distribution."
        }
      },
      "documentation":"A streaming distribution."
    },
    "StreamingDistributionAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "StreamingDistributionConfig":{
      "type":"structure",
      "required":[
        "CallerReference",
        "S3Origin",
        "Aliases",
        "Comment",
        "Logging",
        "TrustedSigners",
        "PriceClass",
        "Enabled"
      ],
      "members":{
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique number that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the StreamingDistributionConfig object), a new streaming distribution is created. If the CallerReference is a value you already sent in a previous request to create a streaming distribution, and the content of the StreamingDistributionConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create a streaming distribution but the content of the StreamingDistributionConfig is different from the original request, CloudFront returns a DistributionAlreadyExists error."
        },
        "S3Origin":{
          "shape":"S3Origin",
          "documentation":"A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution."
        },
        "Comment":{
          "shape":"string",
          "documentation":"Any comments you want to include about the streaming distribution."
        },
        "Logging":{
          "shape":"StreamingLoggingConfig",
          "documentation":"A complex type that controls whether access logs are written for the streaming distribution."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "PriceClass":{
          "shape":"PriceClass",
          "documentation":"A complex type that contains information about price class for this streaming distribution."
        },
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the streaming distribution is enabled to accept end user requests for content."
        }
      },
      "documentation":"The configuration for the streaming distribution."
    },
    "StreamingDistributionList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your streaming distributions where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of streaming distributions that were created by the current AWS account."
        },
        "Items":{
          "shape":"StreamingDistributionSummaryList",
          "documentation":"A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current AWS account."
        }
      },
      "documentation":"A streaming distribution list."
    },
    "StreamingDistributionNotDisabled":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "StreamingDistributionSummary":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "LastModifiedTime",
        "DomainName",
        "S3Origin",
        "Aliases",
        "TrustedSigners",
        "Comment",
        "PriceClass",
        "Enabled"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the distribution. For example: EDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the distribution. For example: d604721fxaaqy9.cloudfront.net."
        },
        "S3Origin":{
          "shape":"S3Origin",
          "documentation":"A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "Comment":{
          "shape":"string",
          "documentation":"The comment originally specified when this distribution was created."
        },
        "PriceClass":{"shape":"PriceClass"},
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the distribution is enabled to accept end user requests for content."
        }
      },
      "documentation":"A summary of the information for an Amazon CloudFront streaming distribution."
    },
    "StreamingDistributionSummaryList":{
      "type":"list",
      "member":{
        "shape":"StreamingDistributionSummary",
        "locationName":"StreamingDistributionSummary"
      }
    },
    "StreamingLoggingConfig":{
      "type":"structure",
      "required":[
        "Enabled",
        "Bucket",
        "Prefix"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you do not want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted."
        },
        "Bucket":{
          "shape":"string",
          "documentation":"The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com."
        },
        "Prefix":{
          "shape":"string",
          "documentation":"An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you do not want to specify a prefix, you still must include an empty Prefix element in the Logging element."
        }
      },
      "documentation":"A complex type that controls whether access logs are written for this streaming distribution."
    },
    "TooManyCacheBehaviors":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot create anymore cache behaviors for the distribution."
    },
    "TooManyCertificates":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot create anymore custom ssl certificates."
    },
    "TooManyCloudFrontOriginAccessIdentities":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Processing your request would cause you to exceed the maximum number of origin access identities allowed."
    },
    "TooManyCookieNamesInWhiteList":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
    },
    "TooManyDistributionCNAMEs":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains more CNAMEs than are allowed per distribution."
    },
    "TooManyDistributions":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Processing your request would cause you to exceed the maximum number of distributions allowed."
    },
    "TooManyHeadersInForwardedValues":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "TooManyInvalidationsInProgress":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects."
    },
    "TooManyOrigins":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot create anymore origins for the distribution."
    },
    "TooManyStreamingDistributionCNAMEs":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "TooManyStreamingDistributions":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Processing your request would cause you to exceed the maximum number of streaming distributions allowed."
    },
    "TooManyTrustedSigners":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains more trusted signers than are allowed per distribution."
    },
    "TrustedSignerDoesNotExist":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"One or more of your trusted signers do not exist."
    },
    "TrustedSigners":{
      "type":"structure",
      "required":[
        "Enabled",
        "Quantity"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Specifies whether you want to require end users to use signed URLs to access the files specified by PathPattern and TargetOriginId."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of trusted signers for this cache behavior."
        },
        "Items":{
          "shape":"AwsAccountNumberList",
          "documentation":"Optional: A complex type that contains trusted signers for this cache behavior. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
    },
    "UpdateCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "required":[
        "CloudFrontOriginAccessIdentityConfig",
        "Id"
      ],
      "members":{
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The identity's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"CloudFrontOriginAccessIdentityConfig"
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The identity's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to update an origin access identity.",
      "payload":"CloudFrontOriginAccessIdentityConfig"
    },
    "UpdateCloudFrontOriginAccessIdentityResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentity":{
          "shape":"CloudFrontOriginAccessIdentity",
          "documentation":"The origin access identity's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentity"
    },
    "UpdateDistributionRequest":{
      "type":"structure",
      "required":[
        "DistributionConfig",
        "Id"
      ],
      "members":{
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"DistributionConfig"
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to update a distribution.",
      "payload":"DistributionConfig"
    },
    "UpdateDistributionResult":{
      "type":"structure",
      "members":{
        "Distribution":{
          "shape":"Distribution",
          "documentation":"The distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Distribution"
    },
    "UpdateStreamingDistributionRequest":{
      "type":"structure",
      "required":[
        "StreamingDistributionConfig",
        "Id"
      ],
      "members":{
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The streaming distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-05-31/"},
          "locationName":"StreamingDistributionConfig"
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The streaming distribution's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to update a streaming distribution.",
      "payload":"StreamingDistributionConfig"
    },
    "UpdateStreamingDistributionResult":{
      "type":"structure",
      "members":{
        "StreamingDistribution":{
          "shape":"StreamingDistribution",
          "documentation":"The streaming distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistribution"
    },
    "ViewerCertificate":{
      "type":"structure",
      "members":{
        "IAMCertificateId":{
          "shape":"string",
          "documentation":"If you want viewers to use HTTPS to request your objects and you're using an alternate domain name in your object URLs (for example, https://example.com/logo.jpg), specify the IAM certificate identifier of the custom viewer certificate for this distribution. Specify either this value or CloudFrontDefaultCertificate."
        },
        "CloudFrontDefaultCertificate":{
          "shape":"boolean",
          "documentation":"If you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name of your distribution in your object URLs (for example, https://d111111abcdef8.cloudfront.net/logo.jpg), set to true. Omit this value if you are setting an IAMCertificateId."
        },
        "SSLSupportMethod":{
          "shape":"SSLSupportMethod",
          "documentation":"If you specify a value for IAMCertificateId, you must also specify how you want CloudFront to serve HTTPS requests. Valid values are vip and sni-only. If you specify vip, CloudFront uses dedicated IP addresses for your content and can respond to HTTPS requests from any viewer. However, you must request permission to use this feature, and you incur additional monthly charges. If you specify sni-only, CloudFront can only respond to HTTPS requests from viewers that support Server Name Indication (SNI). All modern browsers support SNI, but some browsers still in use don't support SNI. Do not specify a value for SSLSupportMethod if you specified true for CloudFrontDefaultCertificate."
        }
      },
      "documentation":"A complex type that contains information about viewer certificates for this distribution."
    },
    "ViewerProtocolPolicy":{
      "type":"string",
      "enum":[
        "allow-all",
        "https-only",
        "redirect-to-https"
      ]
    },
    "boolean":{"type":"boolean"},
    "integer":{"type":"integer"},
    "long":{"type":"long"},
    "string":{"type":"string"},
    "timestamp":{"type":"timestamp"}
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-05-31/waiters-2.json            0100644 0000000 0000062 00000002240 13077704371 026671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version": 2,
  "waiters": {
    "DistributionDeployed": {
      "delay": 60,
      "operation": "GetDistribution",
      "maxAttempts": 25,
      "description": "Wait until a distribution is deployed.",
      "acceptors": [
        {
          "expected": "Deployed",
          "matcher": "path",
          "state": "success",
          "argument": "Distribution.Status"
        }
      ]
    },
    "InvalidationCompleted": {
      "delay": 20,
      "operation": "GetInvalidation",
      "maxAttempts": 60,
      "description": "Wait until an invalidation has completed.",
      "acceptors": [
        {
          "expected": "Completed",
          "matcher": "path",
          "state": "success",
          "argument": "Invalidation.Status"
        }
      ]
    },
    "StreamingDistributionDeployed": {
      "delay": 60,
      "operation": "GetStreamingDistribution",
      "maxAttempts": 25,
      "description": "Wait until a streaming distribution is deployed.",
      "acceptors": [
        {
          "expected": "Deployed",
          "matcher": "path",
          "state": "success",
          "argument": "StreamingDistribution.Status"
        }
      ]
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-10-21/                          0042755 0000000 0000062 00000000000 13077704402 024156  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-10-21/paginators-1.json         0100644 0000000 0000062 00000002146 13077704371 027361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "pagination": {
    "ListCloudFrontOriginAccessIdentities": {
      "input_token": "Marker",
      "output_token": "CloudFrontOriginAccessIdentityList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "CloudFrontOriginAccessIdentityList.IsTruncated",
      "result_key": "CloudFrontOriginAccessIdentityList.Items"
    },
    "ListDistributions": {
      "input_token": "Marker",
      "output_token": "DistributionList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "DistributionList.IsTruncated",
      "result_key": "DistributionList.Items"
    },
    "ListInvalidations": {
      "input_token": "Marker",
      "output_token": "InvalidationList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "InvalidationList.IsTruncated",
      "result_key": "InvalidationList.Items"
    },
    "ListStreamingDistributions": {
      "input_token": "Marker",
      "output_token": "StreamingDistributionList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "StreamingDistributionList.IsTruncated",
      "result_key": "StreamingDistributionList.Items"
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-10-21/service-2.json            0100644 0000000 0000062 00000437771 13077704371 026673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "metadata":{
    "apiVersion":"2014-10-21",
    "endpointPrefix":"cloudfront",
    "globalEndpoint":"cloudfront.amazonaws.com",
    "serviceAbbreviation":"CloudFront",
    "serviceFullName":"Amazon CloudFront",
    "signatureVersion":"v4",
    "protocol":"rest-xml"
  },
  "operations":{
    "CreateCloudFrontOriginAccessIdentity":{
      "name":"CreateCloudFrontOriginAccessIdentity2014_10_21",
      "http":{
        "method":"POST",
        "requestUri":"/2014-10-21/origin-access-identity/cloudfront",
        "responseCode":201
      },
      "input":{
        "shape":"CreateCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to create a new origin access identity."
      },
      "output":{
        "shape":"CreateCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CloudFrontOriginAccessIdentityAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true,
          "documentation":"If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyCloudFrontOriginAccessIdentities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of origin access identities allowed."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new origin access identity."
    },
    "CreateDistribution":{
      "name":"CreateDistribution2014_10_21",
      "http":{
        "method":"POST",
        "requestUri":"/2014-10-21/distribution",
        "responseCode":201
      },
      "input":{
        "shape":"CreateDistributionRequest",
        "documentation":"The request to create a new distribution."
      },
      "output":{
        "shape":"CreateDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"DistributionAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true,
          "documentation":"The caller reference you attempted to create the distribution with is associated with another distribution."
        },
        {
          "shape":"InvalidOrigin",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InvalidViewerCertificate",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more CNAMEs than are allowed per distribution."
        },
        {
          "shape":"TooManyDistributions",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of distributions allowed."
        },
        {
          "shape":"InvalidDefaultRootObject",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The default root object file name is too big or contains an invalid character."
        },
        {
          "shape":"InvalidRelativePath",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
        },
        {
          "shape":"InvalidErrorCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidResponseCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidRequiredProtocol",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
        },
        {
          "shape":"NoSuchOrigin",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"No origin exists with the specified Origin Id."
        },
        {
          "shape":"TooManyOrigins",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore origins for the distribution."
        },
        {
          "shape":"TooManyCacheBehaviors",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore cache behaviors for the distribution."
        },
        {
          "shape":"TooManyCookieNamesInWhiteList",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
        },
        {
          "shape":"InvalidForwardCookies",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
        },
        {
          "shape":"TooManyHeadersInForwardedValues",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidHeadersForS3Origin",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        },
        {
          "shape":"TooManyCertificates",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore custom ssl certificates."
        },
        {
          "shape":"InvalidLocationCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidGeoRestrictionParameter",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidProtocolSettings",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that Support Server Name Indication (SNI)."
        }
      ],
      "documentation":"Create a new distribution."
    },
    "CreateInvalidation":{
      "name":"CreateInvalidation2014_10_21",
      "http":{
        "method":"POST",
        "requestUri":"/2014-10-21/distribution/{DistributionId}/invalidation",
        "responseCode":201
      },
      "input":{
        "shape":"CreateInvalidationRequest",
        "documentation":"The request to create an invalidation."
      },
      "output":{
        "shape":"CreateInvalidationResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"BatchTooLarge",
          "error":{"httpStatusCode":413},
          "exception":true
        },
        {
          "shape":"TooManyInvalidationsInProgress",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new invalidation."
    },
    "CreateStreamingDistribution":{
      "name":"CreateStreamingDistribution2014_10_21",
      "http":{
        "method":"POST",
        "requestUri":"/2014-10-21/streaming-distribution",
        "responseCode":201
      },
      "input":{
        "shape":"CreateStreamingDistributionRequest",
        "documentation":"The request to create a new streaming distribution."
      },
      "output":{
        "shape":"CreateStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"StreamingDistributionAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidOrigin",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyStreamingDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"TooManyStreamingDistributions",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of streaming distributions allowed."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new streaming distribution."
    },
    "DeleteCloudFrontOriginAccessIdentity":{
      "name":"DeleteCloudFrontOriginAccessIdentity2014_10_21",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-10-21/origin-access-identity/cloudfront/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to delete a origin access identity."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"CloudFrontOriginAccessIdentityInUse",
          "error":{"httpStatusCode":409},
          "exception":true
        }
      ],
      "documentation":"Delete an origin access identity."
    },
    "DeleteDistribution":{
      "name":"DeleteDistribution2014_10_21",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-10-21/distribution/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteDistributionRequest",
        "documentation":"The request to delete a distribution."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"DistributionNotDisabled",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        }
      ],
      "documentation":"Delete a distribution."
    },
    "DeleteStreamingDistribution":{
      "name":"DeleteStreamingDistribution2014_10_21",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-10-21/streaming-distribution/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteStreamingDistributionRequest",
        "documentation":"The request to delete a streaming distribution."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"StreamingDistributionNotDisabled",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        }
      ],
      "documentation":"Delete a streaming distribution."
    },
    "GetCloudFrontOriginAccessIdentity":{
      "name":"GetCloudFrontOriginAccessIdentity2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/origin-access-identity/cloudfront/{Id}"
      },
      "input":{
        "shape":"GetCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to get an origin access identity's information."
      },
      "output":{
        "shape":"GetCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about an origin access identity."
    },
    "GetCloudFrontOriginAccessIdentityConfig":{
      "name":"GetCloudFrontOriginAccessIdentityConfig2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/origin-access-identity/cloudfront/{Id}/config"
      },
      "input":{
        "shape":"GetCloudFrontOriginAccessIdentityConfigRequest",
        "documentation":"The request to get an origin access identity's configuration."
      },
      "output":{
        "shape":"GetCloudFrontOriginAccessIdentityConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about an origin access identity."
    },
    "GetDistribution":{
      "name":"GetDistribution2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/distribution/{Id}"
      },
      "input":{
        "shape":"GetDistributionRequest",
        "documentation":"The request to get a distribution's information."
      },
      "output":{
        "shape":"GetDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about a distribution."
    },
    "GetDistributionConfig":{
      "name":"GetDistributionConfig2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/distribution/{Id}/config"
      },
      "input":{
        "shape":"GetDistributionConfigRequest",
        "documentation":"The request to get a distribution configuration."
      },
      "output":{
        "shape":"GetDistributionConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about a distribution."
    },
    "GetInvalidation":{
      "name":"GetInvalidation2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/distribution/{DistributionId}/invalidation/{Id}"
      },
      "input":{
        "shape":"GetInvalidationRequest",
        "documentation":"The request to get an invalidation's information."
      },
      "output":{
        "shape":"GetInvalidationResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchInvalidation",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified invalidation does not exist."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about an invalidation."
    },
    "GetStreamingDistribution":{
      "name":"GetStreamingDistribution2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/streaming-distribution/{Id}"
      },
      "input":{
        "shape":"GetStreamingDistributionRequest",
        "documentation":"The request to get a streaming distribution's information."
      },
      "output":{
        "shape":"GetStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about a streaming distribution."
    },
    "GetStreamingDistributionConfig":{
      "name":"GetStreamingDistributionConfig2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/streaming-distribution/{Id}/config"
      },
      "input":{
        "shape":"GetStreamingDistributionConfigRequest",
        "documentation":"To request to get a streaming distribution configuration."
      },
      "output":{
        "shape":"GetStreamingDistributionConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about a streaming distribution."
    },
    "ListCloudFrontOriginAccessIdentities":{
      "name":"ListCloudFrontOriginAccessIdentities2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/origin-access-identity/cloudfront"
      },
      "input":{
        "shape":"ListCloudFrontOriginAccessIdentitiesRequest",
        "documentation":"The request to list origin access identities."
      },
      "output":{
        "shape":"ListCloudFrontOriginAccessIdentitiesResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List origin access identities."
    },
    "ListDistributions":{
      "name":"ListDistributions2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/distribution"
      },
      "input":{
        "shape":"ListDistributionsRequest",
        "documentation":"The request to list your distributions."
      },
      "output":{
        "shape":"ListDistributionsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List distributions."
    },
    "ListInvalidations":{
      "name":"ListInvalidations2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/distribution/{DistributionId}/invalidation"
      },
      "input":{
        "shape":"ListInvalidationsRequest",
        "documentation":"The request to list invalidations."
      },
      "output":{
        "shape":"ListInvalidationsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"List invalidation batches."
    },
    "ListStreamingDistributions":{
      "name":"ListStreamingDistributions2014_10_21",
      "http":{
        "method":"GET",
        "requestUri":"/2014-10-21/streaming-distribution"
      },
      "input":{
        "shape":"ListStreamingDistributionsRequest",
        "documentation":"The request to list your streaming distributions."
      },
      "output":{
        "shape":"ListStreamingDistributionsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List streaming distributions."
    },
    "UpdateCloudFrontOriginAccessIdentity":{
      "name":"UpdateCloudFrontOriginAccessIdentity2014_10_21",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-10-21/origin-access-identity/cloudfront/{Id}/config"
      },
      "input":{
        "shape":"UpdateCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to update an origin access identity."
      },
      "output":{
        "shape":"UpdateCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Update an origin access identity."
    },
    "UpdateDistribution":{
      "name":"UpdateDistribution2014_10_21",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-10-21/distribution/{Id}/config"
      },
      "input":{
        "shape":"UpdateDistributionRequest",
        "documentation":"The request to update a distribution."
      },
      "output":{
        "shape":"UpdateDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"TooManyDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more CNAMEs than are allowed per distribution."
        },
        {
          "shape":"InvalidDefaultRootObject",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The default root object file name is too big or contains an invalid character."
        },
        {
          "shape":"InvalidRelativePath",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
        },
        {
          "shape":"InvalidErrorCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidResponseCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InvalidViewerCertificate",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidRequiredProtocol",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
        },
        {
          "shape":"NoSuchOrigin",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"No origin exists with the specified Origin Id."
        },
        {
          "shape":"TooManyOrigins",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore origins for the distribution."
        },
        {
          "shape":"TooManyCacheBehaviors",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore cache behaviors for the distribution."
        },
        {
          "shape":"TooManyCookieNamesInWhiteList",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
        },
        {
          "shape":"InvalidForwardCookies",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
        },
        {
          "shape":"TooManyHeadersInForwardedValues",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidHeadersForS3Origin",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        },
        {
          "shape":"TooManyCertificates",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore custom ssl certificates."
        },
        {
          "shape":"InvalidLocationCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidGeoRestrictionParameter",
          "error":{"httpStatusCode":400},
          "exception":true
        }
      ],
      "documentation":"Update a distribution."
    },
    "UpdateStreamingDistribution":{
      "name":"UpdateStreamingDistribution2014_10_21",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-10-21/streaming-distribution/{Id}/config"
      },
      "input":{
        "shape":"UpdateStreamingDistributionRequest",
        "documentation":"The request to update a streaming distribution."
      },
      "output":{
        "shape":"UpdateStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"TooManyStreamingDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Update a streaming distribution."
    }
  },
  "shapes":{
    "AccessDenied":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":403},
      "exception":true,
      "documentation":"Access denied."
    },
    "ActiveTrustedSigners":{
      "type":"structure",
      "required":[
        "Enabled",
        "Quantity"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Each active trusted signer."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of unique trusted signers included in all cache behaviors. For example, if three cache behaviors all list the same three AWS accounts, the value of Quantity for ActiveTrustedSigners will be 3."
        },
        "Items":{
          "shape":"SignerList",
          "documentation":"A complex type that contains one Signer complex type for each unique trusted signer that is specified in the TrustedSigners complex type, including trusted signers in the default cache behavior and in all of the other cache behaviors."
        }
      },
      "documentation":"A complex type that lists the AWS accounts, if any, that you included in the TrustedSigners complex type for the default cache behavior or for any of the other cache behaviors for this distribution. These are accounts that you want to allow to create signed URLs for private content."
    },
    "AliasList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"CNAME"
      }
    },
    "Aliases":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of CNAMEs, if any, for this distribution."
        },
        "Items":{
          "shape":"AliasList",
          "documentation":"Optional: A complex type that contains CNAME elements, if any, for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
    },
    "AllowedMethods":{
      "type":"structure",
      "required":[
        "Quantity",
        "Items"
      ],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests)."
        },
        "Items":{
          "shape":"MethodsList",
          "documentation":"A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin."
        },
        "CachedMethods":{"shape":"CachedMethods"}
      },
      "documentation":"A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices: - CloudFront forwards only GET and HEAD requests. - CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you may not want users to have permission to delete objects from your origin."
    },
    "AwsAccountNumberList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"AwsAccountNumber"
      }
    },
    "BatchTooLarge":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":413},
      "exception":true
    },
    "CNAMEAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "CacheBehavior":{
      "type":"structure",
      "required":[
        "PathPattern",
        "TargetOriginId",
        "ForwardedValues",
        "TrustedSigners",
        "ViewerProtocolPolicy",
        "MinTTL"
      ],
      "members":{
        "PathPattern":{
          "shape":"string",
          "documentation":"The pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to. When CloudFront receives an end-user request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior."
        },
        "TargetOriginId":{
          "shape":"string",
          "documentation":"The value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."
        },
        "ForwardedValues":{
          "shape":"ForwardedValues",
          "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "ViewerProtocolPolicy":{
          "shape":"ViewerProtocolPolicy",
          "documentation":"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. If you want CloudFront to allow end users to use any available protocol, specify allow-all. If you want CloudFront to require HTTPS, specify https. If you want CloudFront to respond to an HTTP request with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https. The viewer then resubmits the request using the HTTPS URL."
        },
        "MinTTL":{
          "shape":"long",
          "documentation":"The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.You can specify a value from 0 to 3,153,600,000 seconds (100 years)."
        },
        "AllowedMethods":{"shape":"AllowedMethods"},
        "SmoothStreaming":{
          "shape":"boolean",
          "documentation":"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false."
        }
      },
      "documentation":"A complex type that describes how CloudFront processes requests. You can create up to 10 cache behaviors.You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to distribute objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin will never be used. If you don't want to specify any cache behaviors, include only an empty CacheBehaviors element. Don't include an empty CacheBehavior element, or CloudFront returns a MalformedXML error. To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution."
    },
    "CacheBehaviorList":{
      "type":"list",
      "member":{
        "shape":"CacheBehavior",
        "locationName":"CacheBehavior"
      }
    },
    "CacheBehaviors":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of cache behaviors for this distribution."
        },
        "Items":{
          "shape":"CacheBehaviorList",
          "documentation":"Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains zero or more CacheBehavior elements."
    },
    "CachedMethods":{
      "type":"structure",
      "required":[
        "Quantity",
        "Items"
      ],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of HTTP methods for which you want CloudFront to cache responses. Valid values are 2 (for caching responses to GET and HEAD requests) and 3 (for caching responses to GET, HEAD, and OPTIONS requests)."
        },
        "Items":{
          "shape":"MethodsList",
          "documentation":"A complex type that contains the HTTP methods that you want CloudFront to cache responses to."
        }
      },
      "documentation":"A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices: - CloudFront caches responses to GET and HEAD requests. - CloudFront caches responses to GET, HEAD, and OPTIONS requests. If you pick the second choice for your S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers and Origin headers for the responses to be cached correctly."
    },
    "CloudFrontOriginAccessIdentity":{
      "type":"structure",
      "required":[
        "Id",
        "S3CanonicalUserId"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The ID for the origin access identity. For example: E74FTE3AJFJ256A."
        },
        "S3CanonicalUserId":{
          "shape":"string",
          "documentation":"The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3."
        },
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The current configuration information for the identity."
        }
      },
      "documentation":"CloudFront origin access identity."
    },
    "CloudFrontOriginAccessIdentityAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true,
      "documentation":"If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
    },
    "CloudFrontOriginAccessIdentityConfig":{
      "type":"structure",
      "required":[
        "CallerReference",
        "Comment"
      ],
      "members":{
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique number that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value you already sent in a previous request to create an identity, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
        },
        "Comment":{
          "shape":"string",
          "documentation":"Any comments you want to include about the origin access identity."
        }
      },
      "documentation":"Origin access identity configuration."
    },
    "CloudFrontOriginAccessIdentityInUse":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "CloudFrontOriginAccessIdentityList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of CloudFront origin access identities that were created by the current AWS account."
        },
        "Items":{
          "shape":"CloudFrontOriginAccessIdentitySummaryList",
          "documentation":"A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current AWS account."
        }
      },
      "documentation":"The CloudFrontOriginAccessIdentityList type."
    },
    "CloudFrontOriginAccessIdentitySummary":{
      "type":"structure",
      "required":[
        "Id",
        "S3CanonicalUserId",
        "Comment"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The ID for the origin access identity. For example: E74FTE3AJFJ256A."
        },
        "S3CanonicalUserId":{
          "shape":"string",
          "documentation":"The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3."
        },
        "Comment":{
          "shape":"string",
          "documentation":"The comment for this origin access identity, as originally specified when created."
        }
      },
      "documentation":"Summary of the information about a CloudFront origin access identity."
    },
    "CloudFrontOriginAccessIdentitySummaryList":{
      "type":"list",
      "member":{
        "shape":"CloudFrontOriginAccessIdentitySummary",
        "locationName":"CloudFrontOriginAccessIdentitySummary"
      }
    },
    "CookieNameList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Name"
      }
    },
    "CookieNames":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of whitelisted cookies for this cache behavior."
        },
        "Items":{
          "shape":"CookieNameList",
          "documentation":"Optional: A complex type that contains whitelisted cookies for this cache behavior. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that specifies the whitelisted cookies, if any, that you want CloudFront to forward to your origin that is associated with this cache behavior."
    },
    "CookiePreference":{
      "type":"structure",
      "required":["Forward"],
      "members":{
        "Forward":{
          "shape":"ItemSelection",
          "documentation":"Use this element to specify whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If you choose All, CloudFront forwards all cookies regardless of how many your application uses."
        },
        "WhitelistedNames":{
          "shape":"CookieNames",
          "documentation":"A complex type that specifies the whitelisted cookies, if any, that you want CloudFront to forward to your origin that is associated with this cache behavior."
        }
      },
      "documentation":"A complex type that specifies the cookie preferences associated with this cache behavior."
    },
    "CreateCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "required":["CloudFrontOriginAccessIdentityConfig"],
      "members":{
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The origin access identity's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"CloudFrontOriginAccessIdentityConfig"
        }
      },
      "documentation":"The request to create a new origin access identity.",
      "payload":"CloudFrontOriginAccessIdentityConfig"
    },
    "CreateCloudFrontOriginAccessIdentityResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentity":{
          "shape":"CloudFrontOriginAccessIdentity",
          "documentation":"The origin access identity's information."
        },
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the new origin access identity just created. For example: https://cloudfront.amazonaws.com/2010-11-01/origin-access-identity/cloudfront/E74FTE3AJFJ256A."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the origin access identity created."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentity"
    },
    "CreateDistributionRequest":{
      "type":"structure",
      "required":["DistributionConfig"],
      "members":{
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"DistributionConfig"
        }
      },
      "documentation":"The request to create a new distribution.",
      "payload":"DistributionConfig"
    },
    "CreateDistributionResult":{
      "type":"structure",
      "members":{
        "Distribution":{
          "shape":"Distribution",
          "documentation":"The distribution's information."
        },
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the new distribution resource just created. For example: https://cloudfront.amazonaws.com/2010-11-01/distribution/EDFDVBD632BHDS5."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the distribution created."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Distribution"
    },
    "CreateInvalidationRequest":{
      "type":"structure",
      "required":[
        "DistributionId",
        "InvalidationBatch"
      ],
      "members":{
        "DistributionId":{
          "shape":"string",
          "location":"uri",
          "locationName":"DistributionId",
          "documentation":"The distribution's id."
        },
        "InvalidationBatch":{
          "shape":"InvalidationBatch",
          "documentation":"The batch information for the invalidation.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"InvalidationBatch"
        }
      },
      "documentation":"The request to create an invalidation.",
      "payload":"InvalidationBatch"
    },
    "CreateInvalidationResult":{
      "type":"structure",
      "members":{
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID."
        },
        "Invalidation":{
          "shape":"Invalidation",
          "documentation":"The invalidation's information."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Invalidation"
    },
    "CreateStreamingDistributionRequest":{
      "type":"structure",
      "required":["StreamingDistributionConfig"],
      "members":{
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The streaming distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"StreamingDistributionConfig"
        }
      },
      "documentation":"The request to create a new streaming distribution.",
      "payload":"StreamingDistributionConfig"
    },
    "CreateStreamingDistributionResult":{
      "type":"structure",
      "members":{
        "StreamingDistribution":{
          "shape":"StreamingDistribution",
          "documentation":"The streaming distribution's information."
        },
        "Location":{
          "shape":"string",
          "location":"header",
          "locationName":"Location",
          "documentation":"The fully qualified URI of the new streaming distribution resource just created. For example: https://cloudfront.amazonaws.com/2010-11-01/streaming-distribution/EGTXBD79H29TRA8."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the streaming distribution created."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistribution"
    },
    "CustomErrorResponse":{
      "type":"structure",
      "required":["ErrorCode"],
      "members":{
        "ErrorCode":{
          "shape":"integer",
          "documentation":"The 4xx or 5xx HTTP status code that you want to customize. For a list of HTTP status codes that you can customize, see CloudFront documentation."
        },
        "ResponsePagePath":{
          "shape":"string",
          "documentation":"The path of the custom error page (for example, /custom_404.html). The path is relative to the distribution and must begin with a slash (/). If the path includes any non-ASCII characters or unsafe characters as defined in RFC 1783 (http://www.ietf.org/rfc/rfc1738.txt), URL encode those characters. Do not URL encode any other characters in the path, or CloudFront will not return the custom error page to the viewer."
        },
        "ResponseCode":{
          "shape":"string",
          "documentation":"The HTTP status code that you want CloudFront to return with the custom error page to the viewer. For a list of HTTP status codes that you can replace, see CloudFront Documentation."
        },
        "ErrorCachingMinTTL":{
          "shape":"long",
          "documentation":"The minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. You can specify a value from 0 to 31,536,000."
        }
      },
      "documentation":"A complex type that describes how you'd prefer CloudFront to respond to requests that result in either a 4xx or 5xx response. You can control whether a custom error page should be displayed, what the desired response code should be for this error page and how long should the error response be cached by CloudFront. If you don't want to specify any custom error responses, include only an empty CustomErrorResponses element. To delete all custom error responses in an existing distribution, update the distribution configuration and include only an empty CustomErrorResponses element. To add, change, or remove one or more custom error responses, update the distribution configuration and specify all of the custom error responses that you want to include in the updated distribution."
    },
    "CustomErrorResponseList":{
      "type":"list",
      "member":{
        "shape":"CustomErrorResponse",
        "locationName":"CustomErrorResponse"
      }
    },
    "CustomErrorResponses":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of custom error responses for this distribution."
        },
        "Items":{
          "shape":"CustomErrorResponseList",
          "documentation":"Optional: A complex type that contains custom error responses for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains zero or more CustomErrorResponse elements."
    },
    "CustomOriginConfig":{
      "type":"structure",
      "required":[
        "HTTPPort",
        "HTTPSPort",
        "OriginProtocolPolicy"
      ],
      "members":{
        "HTTPPort":{
          "shape":"integer",
          "documentation":"The HTTP port the custom origin listens on."
        },
        "HTTPSPort":{
          "shape":"integer",
          "documentation":"The HTTPS port the custom origin listens on."
        },
        "OriginProtocolPolicy":{
          "shape":"OriginProtocolPolicy",
          "documentation":"The origin protocol policy to apply to your origin."
        }
      },
      "documentation":"A customer origin."
    },
    "DefaultCacheBehavior":{
      "type":"structure",
      "required":[
        "TargetOriginId",
        "ForwardedValues",
        "TrustedSigners",
        "ViewerProtocolPolicy",
        "MinTTL"
      ],
      "members":{
        "TargetOriginId":{
          "shape":"string",
          "documentation":"The value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."
        },
        "ForwardedValues":{
          "shape":"ForwardedValues",
          "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "ViewerProtocolPolicy":{
          "shape":"ViewerProtocolPolicy",
          "documentation":"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. If you want CloudFront to allow end users to use any available protocol, specify allow-all. If you want CloudFront to require HTTPS, specify https. If you want CloudFront to respond to an HTTP request with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https. The viewer then resubmits the request using the HTTPS URL."
        },
        "MinTTL":{
          "shape":"long",
          "documentation":"The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated.You can specify a value from 0 to 3,153,600,000 seconds (100 years)."
        },
        "AllowedMethods":{"shape":"AllowedMethods"},
        "SmoothStreaming":{
          "shape":"boolean",
          "documentation":"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false."
        }
      },
      "documentation":"A complex type that describes the default cache behavior if you do not specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements.You must create exactly one default cache behavior."
    },
    "DeleteCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The origin access identity's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to delete a origin access identity.",
      "required":["Id"]
    },
    "DeleteDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when you disabled the distribution. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to delete a distribution.",
      "required":["Id"]
    },
    "DeleteStreamingDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to delete a streaming distribution.",
      "required":["Id"]
    },
    "Distribution":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "LastModifiedTime",
        "InProgressInvalidationBatches",
        "DomainName",
        "ActiveTrustedSigners",
        "DistributionConfig"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the distribution. For example: EDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"This response element indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "InProgressInvalidationBatches":{
          "shape":"integer",
          "documentation":"The number of invalidation batches currently in progress."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the distribution. For example: d604721fxaaqy9.cloudfront.net."
        },
        "ActiveTrustedSigners":{
          "shape":"ActiveTrustedSigners",
          "documentation":"CloudFront automatically adds this element to the response only if you've set up the distribution to serve private content with signed URLs. The element lists the key pair IDs that CloudFront is aware of for each trusted signer. The Signer child element lists the AWS account number of the trusted signer (or an empty Self element if the signer is you). The Signer element also includes the IDs of any active key pairs associated with the trusted signer's AWS account. If no KeyPairId element appears for a Signer, that signer can't create working signed URLs."
        },
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The current configuration information for the distribution."
        }
      },
      "documentation":"A distribution."
    },
    "DistributionAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true,
      "documentation":"The caller reference you attempted to create the distribution with is associated with another distribution."
    },
    "DistributionConfig":{
      "type":"structure",
      "required":[
        "CallerReference",
        "Aliases",
        "DefaultRootObject",
        "Origins",
        "DefaultCacheBehavior",
        "CacheBehaviors",
        "Comment",
        "Logging",
        "PriceClass",
        "Enabled"
      ],
      "members":{
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique number that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the DistributionConfig object), a new distribution is created. If the CallerReference is a value you already sent in a previous request to create a distribution, and the content of the DistributionConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create a distribution but the content of the DistributionConfig is different from the original request, CloudFront returns a DistributionAlreadyExists error."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
        },
        "DefaultRootObject":{
          "shape":"string",
          "documentation":"The object that you want CloudFront to return (for example, index.html) when an end user requests the root URL for your distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/index.html). Specifying a default root object avoids exposing the contents of your distribution. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object."
        },
        "Origins":{
          "shape":"Origins",
          "documentation":"A complex type that contains information about origins for this distribution."
        },
        "DefaultCacheBehavior":{
          "shape":"DefaultCacheBehavior",
          "documentation":"A complex type that describes the default cache behavior if you do not specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements.You must create exactly one default cache behavior."
        },
        "CacheBehaviors":{
          "shape":"CacheBehaviors",
          "documentation":"A complex type that contains zero or more CacheBehavior elements."
        },
        "CustomErrorResponses":{
          "shape":"CustomErrorResponses",
          "documentation":"A complex type that contains zero or more CustomErrorResponse elements."
        },
        "Comment":{
          "shape":"string",
          "documentation":"Any comments you want to include about the distribution."
        },
        "Logging":{
          "shape":"LoggingConfig",
          "documentation":"A complex type that controls whether access logs are written for the distribution."
        },
        "PriceClass":{
          "shape":"PriceClass",
          "documentation":"A complex type that contains information about price class for this distribution."
        },
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the distribution is enabled to accept end user requests for content."
        },
        "ViewerCertificate":{"shape":"ViewerCertificate"},
        "Restrictions":{"shape":"Restrictions"}
      },
      "documentation":"A distribution Configuration."
    },
    "DistributionList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of distributions that were created by the current AWS account."
        },
        "Items":{
          "shape":"DistributionSummaryList",
          "documentation":"A complex type that contains one DistributionSummary element for each distribution that was created by the current AWS account."
        }
      },
      "documentation":"A distribution list."
    },
    "DistributionNotDisabled":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "DistributionSummary":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "LastModifiedTime",
        "DomainName",
        "Aliases",
        "Origins",
        "DefaultCacheBehavior",
        "CacheBehaviors",
        "CustomErrorResponses",
        "Comment",
        "PriceClass",
        "Enabled",
        "ViewerCertificate",
        "Restrictions"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the distribution. For example: EDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"This response element indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the distribution. For example: d604721fxaaqy9.cloudfront.net."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
        },
        "Origins":{
          "shape":"Origins",
          "documentation":"A complex type that contains information about origins for this distribution."
        },
        "DefaultCacheBehavior":{
          "shape":"DefaultCacheBehavior",
          "documentation":"A complex type that describes the default cache behavior if you do not specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements.You must create exactly one default cache behavior."
        },
        "CacheBehaviors":{
          "shape":"CacheBehaviors",
          "documentation":"A complex type that contains zero or more CacheBehavior elements."
        },
        "CustomErrorResponses":{
          "shape":"CustomErrorResponses",
          "documentation":"A complex type that contains zero or more CustomErrorResponses elements."
        },
        "Comment":{
          "shape":"string",
          "documentation":"The comment originally specified when this distribution was created."
        },
        "PriceClass":{"shape":"PriceClass"},
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the distribution is enabled to accept end user requests for content."
        },
        "ViewerCertificate":{"shape":"ViewerCertificate"},
        "Restrictions":{"shape":"Restrictions"}
      },
      "documentation":"A summary of the information for an Amazon CloudFront distribution."
    },
    "DistributionSummaryList":{
      "type":"list",
      "member":{
        "shape":"DistributionSummary",
        "locationName":"DistributionSummary"
      }
    },
    "ForwardedValues":{
      "type":"structure",
      "required":[
        "QueryString",
        "Cookies"
      ],
      "members":{
        "QueryString":{
          "shape":"boolean",
          "documentation":"Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior. If so, specify true; if not, specify false."
        },
        "Cookies":{
          "shape":"CookiePreference",
          "documentation":"A complex type that specifies how CloudFront handles cookies."
        },
        "Headers":{
          "shape":"Headers",
          "documentation":"A complex type that specifies the Headers, if any, that you want CloudFront to vary upon for this cache behavior."
        }
      },
      "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
    },
    "GeoRestriction":{
      "type":"structure",
      "required":[
        "RestrictionType",
        "Quantity"
      ],
      "members":{
        "RestrictionType":{
          "shape":"GeoRestrictionType",
          "documentation":"The method that you want to use to restrict distribution of your content by country: - none: No geo restriction is enabled, meaning access to content is not restricted by client geo location. - blacklist: The Location elements specify the countries in which you do not want CloudFront to distribute your content. - whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items."
        },
        "Items":{
          "shape":"LocationList",
          "documentation":"A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list in the CloudFront console, which includes both country names and codes."
        }
      },
      "documentation":"A complex type that controls the countries in which your content is distributed. For more information about geo restriction, go to Customizing Error Responses in the Amazon CloudFront Developer Guide. CloudFront determines the location of your users using MaxMind GeoIP databases. For information about the accuracy of these databases, see How accurate are your GeoIP databases? on the MaxMind website."
    },
    "GeoRestrictionType":{
      "type":"string",
      "enum":[
        "blacklist",
        "whitelist",
        "none"
      ]
    },
    "GetCloudFrontOriginAccessIdentityConfigRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The identity's id."
        }
      },
      "documentation":"The request to get an origin access identity's configuration.",
      "required":["Id"]
    },
    "GetCloudFrontOriginAccessIdentityConfigResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The origin access identity's configuration information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentityConfig"
    },
    "GetCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The identity's id."
        }
      },
      "documentation":"The request to get an origin access identity's information.",
      "required":["Id"]
    },
    "GetCloudFrontOriginAccessIdentityResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentity":{
          "shape":"CloudFrontOriginAccessIdentity",
          "documentation":"The origin access identity's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentity"
    },
    "GetDistributionConfigRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution's id."
        }
      },
      "documentation":"The request to get a distribution configuration.",
      "required":["Id"]
    },
    "GetDistributionConfigResult":{
      "type":"structure",
      "members":{
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The distribution's configuration information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"DistributionConfig"
    },
    "GetDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution's id."
        }
      },
      "documentation":"The request to get a distribution's information.",
      "required":["Id"]
    },
    "GetDistributionResult":{
      "type":"structure",
      "members":{
        "Distribution":{
          "shape":"Distribution",
          "documentation":"The distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the distribution's information. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Distribution"
    },
    "GetInvalidationRequest":{
      "type":"structure",
      "required":[
        "DistributionId",
        "Id"
      ],
      "members":{
        "DistributionId":{
          "shape":"string",
          "location":"uri",
          "locationName":"DistributionId",
          "documentation":"The distribution's id."
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The invalidation's id."
        }
      },
      "documentation":"The request to get an invalidation's information."
    },
    "GetInvalidationResult":{
      "type":"structure",
      "members":{
        "Invalidation":{
          "shape":"Invalidation",
          "documentation":"The invalidation's information."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Invalidation"
    },
    "GetStreamingDistributionConfigRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The streaming distribution's id."
        }
      },
      "documentation":"To request to get a streaming distribution configuration.",
      "required":["Id"]
    },
    "GetStreamingDistributionConfigResult":{
      "type":"structure",
      "members":{
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The streaming distribution's configuration information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistributionConfig"
    },
    "GetStreamingDistributionRequest":{
      "type":"structure",
      "members":{
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The streaming distribution's id."
        }
      },
      "documentation":"The request to get a streaming distribution's information.",
      "required":["Id"]
    },
    "GetStreamingDistributionResult":{
      "type":"structure",
      "members":{
        "StreamingDistribution":{
          "shape":"StreamingDistribution",
          "documentation":"The streaming distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistribution"
    },
    "HeaderList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Name"
      }
    },
    "Headers":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of different headers that you want CloudFront to forward to the origin and to vary on for this cache behavior. The maximum number of headers that you can specify by name is 10. If you want CloudFront to forward all headers to the origin and vary on all of them, specify 1 for Quantity and * for Name. If you don't want CloudFront to forward any additional headers to the origin or to vary on any headers, specify 0 for Quantity and omit Items."
        },
        "Items":{
          "shape":"HeaderList",
          "documentation":"Optional: A complex type that contains a Name element for each header that you want CloudFront to forward to the origin and to vary on for this cache behavior. If Quantity is 0, omit Items."
        }
      },
      "documentation":"A complex type that specifies the headers that you want CloudFront to forward to the origin for this cache behavior. For the headers that you specify, CloudFront also caches separate versions of a given object based on the header values in viewer requests; this is known as varying on headers. For example, suppose viewer requests for logo.jpg contain a custom Product header that has a value of either Acme or Apex, and you configure CloudFront to vary on the Product header. CloudFront forwards the Product header to the origin and caches the response from the origin once for each header value."
    },
    "IllegalUpdate":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Origin and CallerReference cannot be updated."
    },
    "InconsistentQuantities":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The value of Quantity and the size of Items do not match."
    },
    "InvalidArgument":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The argument is invalid."
    },
    "InvalidDefaultRootObject":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The default root object file name is too big or contains an invalid character."
    },
    "InvalidErrorCode":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidForwardCookies":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
    },
    "InvalidGeoRestrictionParameter":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidHeadersForS3Origin":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidIfMatchVersion":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The If-Match version is missing or not valid for the distribution."
    },
    "InvalidLocationCode":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidOrigin":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
    },
    "InvalidOriginAccessIdentity":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The origin access identity is not valid or doesn't exist."
    },
    "InvalidProtocolSettings":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that Support Server Name Indication (SNI)."
    },
    "InvalidRelativePath":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
    },
    "InvalidRequiredProtocol":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
    },
    "InvalidResponseCode":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "InvalidViewerCertificate":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "Invalidation":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "CreateTime",
        "InvalidationBatch"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the invalidation request. For example: IDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"The status of the invalidation request. When the invalidation batch is finished, the status is Completed."
        },
        "CreateTime":{
          "shape":"timestamp",
          "documentation":"The date and time the invalidation request was first made."
        },
        "InvalidationBatch":{
          "shape":"InvalidationBatch",
          "documentation":"The current invalidation information for the batch request."
        }
      },
      "documentation":"An invalidation."
    },
    "InvalidationBatch":{
      "type":"structure",
      "required":[
        "Paths",
        "CallerReference"
      ],
      "members":{
        "Paths":{
          "shape":"Paths",
          "documentation":"The path of the object to invalidate. The path is relative to the distribution and must begin with a slash (/). You must enclose each invalidation object with the Path element tags. If the path includes non-ASCII characters or unsafe characters as defined in RFC 1783 (http://www.ietf.org/rfc/rfc1738.txt), URL encode those characters. Do not URL encode any other characters in the path, or CloudFront will not invalidate the old version of the updated object."
        },
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique name that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the Path object), a new distribution is created. If the CallerReference is a value you already sent in a previous request to create an invalidation batch, and the content of each Path element is identical to the original request, the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create a distribution but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error."
        }
      },
      "documentation":"An invalidation batch."
    },
    "InvalidationList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your invalidation batches where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of invalidation batches that were created by the current AWS account."
        },
        "Items":{
          "shape":"InvalidationSummaryList",
          "documentation":"A complex type that contains one InvalidationSummary element for each invalidation batch that was created by the current AWS account."
        }
      },
      "documentation":"An invalidation list."
    },
    "InvalidationSummary":{
      "type":"structure",
      "required":[
        "Id",
        "CreateTime",
        "Status"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The unique ID for an invalidation request."
        },
        "CreateTime":{"shape":"timestamp"},
        "Status":{
          "shape":"string",
          "documentation":"The status of an invalidation request."
        }
      },
      "documentation":"Summary of an invalidation request."
    },
    "InvalidationSummaryList":{
      "type":"list",
      "member":{
        "shape":"InvalidationSummary",
        "locationName":"InvalidationSummary"
      }
    },
    "ItemSelection":{
      "type":"string",
      "enum":[
        "none",
        "whitelist",
        "all"
      ]
    },
    "KeyPairIdList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"KeyPairId"
      }
    },
    "KeyPairIds":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of active CloudFront key pairs for AwsAccountNumber."
        },
        "Items":{
          "shape":"KeyPairIdList",
          "documentation":"A complex type that lists the active CloudFront key pairs, if any, that are associated with AwsAccountNumber."
        }
      },
      "documentation":"A complex type that lists the active CloudFront key pairs, if any, that are associated with AwsAccountNumber."
    },
    "ListCloudFrontOriginAccessIdentitiesRequest":{
      "type":"structure",
      "members":{
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page)."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of origin access identities you want in the response body."
        }
      },
      "documentation":"The request to list origin access identities."
    },
    "ListCloudFrontOriginAccessIdentitiesResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentityList":{
          "shape":"CloudFrontOriginAccessIdentityList",
          "documentation":"The CloudFrontOriginAccessIdentityList type."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentityList"
    },
    "ListDistributionsRequest":{
      "type":"structure",
      "members":{
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page)."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of distributions you want in the response body."
        }
      },
      "documentation":"The request to list your distributions."
    },
    "ListDistributionsResult":{
      "type":"structure",
      "members":{
        "DistributionList":{
          "shape":"DistributionList",
          "documentation":"The DistributionList type."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"DistributionList"
    },
    "ListInvalidationsRequest":{
      "type":"structure",
      "required":["DistributionId"],
      "members":{
        "DistributionId":{
          "shape":"string",
          "location":"uri",
          "locationName":"DistributionId",
          "documentation":"The distribution's id."
        },
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of invalidation batches you want in the response body."
        }
      },
      "documentation":"The request to list invalidations."
    },
    "ListInvalidationsResult":{
      "type":"structure",
      "members":{
        "InvalidationList":{
          "shape":"InvalidationList",
          "documentation":"Information about invalidation batches."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"InvalidationList"
    },
    "ListStreamingDistributionsRequest":{
      "type":"structure",
      "members":{
        "Marker":{
          "shape":"string",
          "location":"querystring",
          "locationName":"Marker",
          "documentation":"Use this when paginating results to indicate where to begin in your list of streaming distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page)."
        },
        "MaxItems":{
          "shape":"string",
          "location":"querystring",
          "locationName":"MaxItems",
          "documentation":"The maximum number of streaming distributions you want in the response body."
        }
      },
      "documentation":"The request to list your streaming distributions."
    },
    "ListStreamingDistributionsResult":{
      "type":"structure",
      "members":{
        "StreamingDistributionList":{
          "shape":"StreamingDistributionList",
          "documentation":"The StreamingDistributionList type."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistributionList"
    },
    "LocationList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Location"
      }
    },
    "LoggingConfig":{
      "type":"structure",
      "required":[
        "Enabled",
        "IncludeCookies",
        "Bucket",
        "Prefix"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you do not want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix and IncludeCookies, the values are automatically deleted."
        },
        "IncludeCookies":{
          "shape":"boolean",
          "documentation":"Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you do not want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies."
        },
        "Bucket":{
          "shape":"string",
          "documentation":"The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com."
        },
        "Prefix":{
          "shape":"string",
          "documentation":"An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you do not want to specify a prefix, you still must include an empty Prefix element in the Logging element."
        }
      },
      "documentation":"A complex type that controls whether access logs are written for the distribution."
    },
    "Method":{
      "type":"string",
      "enum":[
        "GET",
        "HEAD",
        "POST",
        "PUT",
        "PATCH",
        "OPTIONS",
        "DELETE"
      ]
    },
    "MethodsList":{
      "type":"list",
      "member":{
        "shape":"Method",
        "locationName":"Method"
      }
    },
    "MinimumProtocolVersion":{
      "type":"string",
      "enum":[
        "SSLv3",
        "TLSv1"
      ]
    },
    "MissingBody":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
    },
    "NoSuchCloudFrontOriginAccessIdentity":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified origin access identity does not exist."
    },
    "NoSuchDistribution":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified distribution does not exist."
    },
    "NoSuchInvalidation":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified invalidation does not exist."
    },
    "NoSuchOrigin":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"No origin exists with the specified Origin Id."
    },
    "NoSuchStreamingDistribution":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":404},
      "exception":true,
      "documentation":"The specified streaming distribution does not exist."
    },
    "Origin":{
      "type":"structure",
      "required":[
        "Id",
        "DomainName"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"A unique identifier for the origin. The value of Id must be unique within the distribution. You use the value of Id when you create a cache behavior. The Id identifies the origin that CloudFront routes a request to when the request matches the path pattern for that cache behavior."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"Amazon S3 origins: The DNS name of the Amazon S3 bucket from which you want CloudFront to get objects for this origin, for example, myawsbucket.s3.amazonaws.com. Custom origins: The DNS domain name for the HTTP server from which you want CloudFront to get objects for this origin, for example, www.example.com."
        },
        "S3OriginConfig":{
          "shape":"S3OriginConfig",
          "documentation":"A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin, use the CustomOriginConfig element instead."
        },
        "CustomOriginConfig":{
          "shape":"CustomOriginConfig",
          "documentation":"A complex type that contains information about a custom origin. If the origin is an Amazon S3 bucket, use the S3OriginConfig element instead."
        }
      },
      "documentation":"A complex type that describes the Amazon S3 bucket or the HTTP server (for example, a web server) from which CloudFront gets your files.You must create at least one origin."
    },
    "OriginList":{
      "type":"list",
      "member":{
        "shape":"Origin",
        "locationName":"Origin"
      },
      "min":1
    },
    "OriginProtocolPolicy":{
      "type":"string",
      "enum":[
        "http-only",
        "match-viewer"
      ]
    },
    "Origins":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of origins for this distribution."
        },
        "Items":{
          "shape":"OriginList",
          "documentation":"A complex type that contains origins for this distribution."
        }
      },
      "documentation":"A complex type that contains information about origins for this distribution."
    },
    "PathList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"Path"
      }
    },
    "Paths":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of objects that you want to invalidate."
        },
        "Items":{
          "shape":"PathList",
          "documentation":"A complex type that contains a list of the objects that you want to invalidate."
        }
      },
      "documentation":"A complex type that contains information about the objects that you want to invalidate."
    },
    "PreconditionFailed":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":412},
      "exception":true,
      "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
    },
    "PriceClass":{
      "type":"string",
      "enum":[
        "PriceClass_100",
        "PriceClass_200",
        "PriceClass_All"
      ]
    },
    "Restrictions":{
      "type":"structure",
      "required":["GeoRestriction"],
      "members":{
        "GeoRestriction":{"shape":"GeoRestriction"}
      },
      "documentation":"A complex type that identifies ways in which you want to restrict distribution of your content."
    },
    "S3Origin":{
      "type":"structure",
      "required":[
        "DomainName",
        "OriginAccessIdentity"
      ],
      "members":{
        "DomainName":{
          "shape":"string",
          "documentation":"The DNS name of the S3 origin."
        },
        "OriginAccessIdentity":{
          "shape":"string",
          "documentation":"Your S3 origin's origin access identity."
        }
      },
      "documentation":"A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution."
    },
    "S3OriginConfig":{
      "type":"structure",
      "required":["OriginAccessIdentity"],
      "members":{
        "OriginAccessIdentity":{
          "shape":"string",
          "documentation":"The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. Use the format origin-access-identity/cloudfront/Id where Id is the value that CloudFront returned in the Id element when you created the origin access identity."
        }
      },
      "documentation":"A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin, use the CustomOriginConfig element instead."
    },
    "SSLSupportMethod":{
      "type":"string",
      "enum":[
        "sni-only",
        "vip"
      ]
    },
    "Signer":{
      "type":"structure",
      "members":{
        "AwsAccountNumber":{
          "shape":"string",
          "documentation":"Specifies an AWS account that can create signed URLs. Values: self, which indicates that the AWS account that was used to create the distribution can created signed URLs, or an AWS account number. Omit the dashes in the account number."
        },
        "KeyPairIds":{
          "shape":"KeyPairIds",
          "documentation":"A complex type that lists the active CloudFront key pairs, if any, that are associated with AwsAccountNumber."
        }
      },
      "documentation":"A complex type that lists the AWS accounts that were included in the TrustedSigners complex type, as well as their active CloudFront key pair IDs, if any."
    },
    "SignerList":{
      "type":"list",
      "member":{
        "shape":"Signer",
        "locationName":"Signer"
      }
    },
    "StreamingDistribution":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "DomainName",
        "ActiveTrustedSigners",
        "StreamingDistributionConfig"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the streaming distribution. For example: EGTXBD79H29TRA8."
        },
        "Status":{
          "shape":"string",
          "documentation":"The current status of the streaming distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the streaming distribution. For example: s5c39gqb8ow64r.cloudfront.net."
        },
        "ActiveTrustedSigners":{
          "shape":"ActiveTrustedSigners",
          "documentation":"CloudFront automatically adds this element to the response only if you've set up the distribution to serve private content with signed URLs. The element lists the key pair IDs that CloudFront is aware of for each trusted signer. The Signer child element lists the AWS account number of the trusted signer (or an empty Self element if the signer is you). The Signer element also includes the IDs of any active key pairs associated with the trusted signer's AWS account. If no KeyPairId element appears for a Signer, that signer can't create working signed URLs."
        },
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The current configuration information for the streaming distribution."
        }
      },
      "documentation":"A streaming distribution."
    },
    "StreamingDistributionAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "StreamingDistributionConfig":{
      "type":"structure",
      "required":[
        "CallerReference",
        "S3Origin",
        "Aliases",
        "Comment",
        "Logging",
        "TrustedSigners",
        "PriceClass",
        "Enabled"
      ],
      "members":{
        "CallerReference":{
          "shape":"string",
          "documentation":"A unique number that ensures the request can't be replayed. If the CallerReference is new (no matter the content of the StreamingDistributionConfig object), a new streaming distribution is created. If the CallerReference is a value you already sent in a previous request to create a streaming distribution, and the content of the StreamingDistributionConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create a streaming distribution but the content of the StreamingDistributionConfig is different from the original request, CloudFront returns a DistributionAlreadyExists error."
        },
        "S3Origin":{
          "shape":"S3Origin",
          "documentation":"A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution."
        },
        "Comment":{
          "shape":"string",
          "documentation":"Any comments you want to include about the streaming distribution."
        },
        "Logging":{
          "shape":"StreamingLoggingConfig",
          "documentation":"A complex type that controls whether access logs are written for the streaming distribution."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "PriceClass":{
          "shape":"PriceClass",
          "documentation":"A complex type that contains information about price class for this streaming distribution."
        },
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the streaming distribution is enabled to accept end user requests for content."
        }
      },
      "documentation":"The configuration for the streaming distribution."
    },
    "StreamingDistributionList":{
      "type":"structure",
      "required":[
        "Marker",
        "MaxItems",
        "IsTruncated",
        "Quantity"
      ],
      "members":{
        "Marker":{
          "shape":"string",
          "documentation":"The value you provided for the Marker request parameter."
        },
        "NextMarker":{
          "shape":"string",
          "documentation":"If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your streaming distributions where they left off."
        },
        "MaxItems":{
          "shape":"integer",
          "documentation":"The value you provided for the MaxItems request parameter."
        },
        "IsTruncated":{
          "shape":"boolean",
          "documentation":"A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of streaming distributions that were created by the current AWS account."
        },
        "Items":{
          "shape":"StreamingDistributionSummaryList",
          "documentation":"A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current AWS account."
        }
      },
      "documentation":"A streaming distribution list."
    },
    "StreamingDistributionNotDisabled":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "StreamingDistributionSummary":{
      "type":"structure",
      "required":[
        "Id",
        "Status",
        "LastModifiedTime",
        "DomainName",
        "S3Origin",
        "Aliases",
        "TrustedSigners",
        "Comment",
        "PriceClass",
        "Enabled"
      ],
      "members":{
        "Id":{
          "shape":"string",
          "documentation":"The identifier for the distribution. For example: EDFDVBD632BHDS5."
        },
        "Status":{
          "shape":"string",
          "documentation":"Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system."
        },
        "LastModifiedTime":{
          "shape":"timestamp",
          "documentation":"The date and time the distribution was last modified."
        },
        "DomainName":{
          "shape":"string",
          "documentation":"The domain name corresponding to the distribution. For example: d604721fxaaqy9.cloudfront.net."
        },
        "S3Origin":{
          "shape":"S3Origin",
          "documentation":"A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution."
        },
        "Aliases":{
          "shape":"Aliases",
          "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "Comment":{
          "shape":"string",
          "documentation":"The comment originally specified when this distribution was created."
        },
        "PriceClass":{"shape":"PriceClass"},
        "Enabled":{
          "shape":"boolean",
          "documentation":"Whether the distribution is enabled to accept end user requests for content."
        }
      },
      "documentation":"A summary of the information for an Amazon CloudFront streaming distribution."
    },
    "StreamingDistributionSummaryList":{
      "type":"list",
      "member":{
        "shape":"StreamingDistributionSummary",
        "locationName":"StreamingDistributionSummary"
      }
    },
    "StreamingLoggingConfig":{
      "type":"structure",
      "required":[
        "Enabled",
        "Bucket",
        "Prefix"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you do not want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted."
        },
        "Bucket":{
          "shape":"string",
          "documentation":"The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com."
        },
        "Prefix":{
          "shape":"string",
          "documentation":"An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you do not want to specify a prefix, you still must include an empty Prefix element in the Logging element."
        }
      },
      "documentation":"A complex type that controls whether access logs are written for this streaming distribution."
    },
    "TooManyCacheBehaviors":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot create anymore cache behaviors for the distribution."
    },
    "TooManyCertificates":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot create anymore custom ssl certificates."
    },
    "TooManyCloudFrontOriginAccessIdentities":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Processing your request would cause you to exceed the maximum number of origin access identities allowed."
    },
    "TooManyCookieNamesInWhiteList":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
    },
    "TooManyDistributionCNAMEs":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains more CNAMEs than are allowed per distribution."
    },
    "TooManyDistributions":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Processing your request would cause you to exceed the maximum number of distributions allowed."
    },
    "TooManyHeadersInForwardedValues":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "TooManyInvalidationsInProgress":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects."
    },
    "TooManyOrigins":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"You cannot create anymore origins for the distribution."
    },
    "TooManyStreamingDistributionCNAMEs":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true
    },
    "TooManyStreamingDistributions":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Processing your request would cause you to exceed the maximum number of streaming distributions allowed."
    },
    "TooManyTrustedSigners":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"Your request contains more trusted signers than are allowed per distribution."
    },
    "TrustedSignerDoesNotExist":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":400},
      "exception":true,
      "documentation":"One or more of your trusted signers do not exist."
    },
    "TrustedSigners":{
      "type":"structure",
      "required":[
        "Enabled",
        "Quantity"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Specifies whether you want to require end users to use signed URLs to access the files specified by PathPattern and TargetOriginId."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of trusted signers for this cache behavior."
        },
        "Items":{
          "shape":"AwsAccountNumberList",
          "documentation":"Optional: A complex type that contains trusted signers for this cache behavior. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
    },
    "UpdateCloudFrontOriginAccessIdentityRequest":{
      "type":"structure",
      "required":[
        "CloudFrontOriginAccessIdentityConfig",
        "Id"
      ],
      "members":{
        "CloudFrontOriginAccessIdentityConfig":{
          "shape":"CloudFrontOriginAccessIdentityConfig",
          "documentation":"The identity's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"CloudFrontOriginAccessIdentityConfig"
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The identity's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to update an origin access identity.",
      "payload":"CloudFrontOriginAccessIdentityConfig"
    },
    "UpdateCloudFrontOriginAccessIdentityResult":{
      "type":"structure",
      "members":{
        "CloudFrontOriginAccessIdentity":{
          "shape":"CloudFrontOriginAccessIdentity",
          "documentation":"The origin access identity's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"CloudFrontOriginAccessIdentity"
    },
    "UpdateDistributionRequest":{
      "type":"structure",
      "required":[
        "DistributionConfig",
        "Id"
      ],
      "members":{
        "DistributionConfig":{
          "shape":"DistributionConfig",
          "documentation":"The distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"DistributionConfig"
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The distribution's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to update a distribution.",
      "payload":"DistributionConfig"
    },
    "UpdateDistributionResult":{
      "type":"structure",
      "members":{
        "Distribution":{
          "shape":"Distribution",
          "documentation":"The distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"Distribution"
    },
    "UpdateStreamingDistributionRequest":{
      "type":"structure",
      "required":[
        "StreamingDistributionConfig",
        "Id"
      ],
      "members":{
        "StreamingDistributionConfig":{
          "shape":"StreamingDistributionConfig",
          "documentation":"The streaming distribution's configuration information.",
          "xmlNamespace":{"uri":"http://cloudfront.amazonaws.com/doc/2014-10-21/"},
          "locationName":"StreamingDistributionConfig"
        },
        "Id":{
          "shape":"string",
          "location":"uri",
          "locationName":"Id",
          "documentation":"The streaming distribution's id."
        },
        "IfMatch":{
          "shape":"string",
          "location":"header",
          "locationName":"If-Match",
          "documentation":"The value of the ETag header you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The request to update a streaming distribution.",
      "payload":"StreamingDistributionConfig"
    },
    "UpdateStreamingDistributionResult":{
      "type":"structure",
      "members":{
        "StreamingDistribution":{
          "shape":"StreamingDistribution",
          "documentation":"The streaming distribution's information."
        },
        "ETag":{
          "shape":"string",
          "location":"header",
          "locationName":"ETag",
          "documentation":"The current version of the configuration. For example: E2QWRUHAPOMQZL."
        }
      },
      "documentation":"The returned result of the corresponding request.",
      "payload":"StreamingDistribution"
    },
    "ViewerCertificate":{
      "type":"structure",
      "members":{
        "IAMCertificateId":{
          "shape":"string",
          "documentation":"If you want viewers to use HTTPS to request your objects and you're using an alternate domain name in your object URLs (for example, https://example.com/logo.jpg), specify the IAM certificate identifier of the custom viewer certificate for this distribution. Specify either this value or CloudFrontDefaultCertificate."
        },
        "CloudFrontDefaultCertificate":{
          "shape":"boolean",
          "documentation":"If you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name of your distribution in your object URLs (for example, https://d111111abcdef8.cloudfront.net/logo.jpg), set to true. Omit this value if you are setting an IAMCertificateId."
        },
        "SSLSupportMethod":{
          "shape":"SSLSupportMethod",
          "documentation":"If you specify a value for IAMCertificateId, you must also specify how you want CloudFront to serve HTTPS requests. Valid values are vip and sni-only. If you specify vip, CloudFront uses dedicated IP addresses for your content and can respond to HTTPS requests from any viewer. However, you must request permission to use this feature, and you incur additional monthly charges. If you specify sni-only, CloudFront can only respond to HTTPS requests from viewers that support Server Name Indication (SNI). All modern browsers support SNI, but some browsers still in use don't support SNI. Do not specify a value for SSLSupportMethod if you specified true for CloudFrontDefaultCertificate."
        },
        "MinimumProtocolVersion":{
          "shape":"MinimumProtocolVersion",
          "documentation":"Specify the minimum version of the SSL protocol that you want CloudFront to use, SSLv3 or TLSv1, for HTTPS connections. CloudFront will serve your objects only to browsers or devices that support at least the SSL version that you specify. The TLSv1 protocol is more secure, so we recommend that you specify SSLv3 only if your users are using browsers or devices that don't support TLSv1. If you're using a custom certificate (if you specify a value for IAMCertificateId) and if you're using dedicated IP (if you specify vip for SSLSupportMethod), you can choose SSLv3 or TLSv1 as the MinimumProtocolVersion. If you're using a custom certificate (if you specify a value for IAMCertificateId) and if you're using SNI (if you specify sni-only for SSLSupportMethod), you must specify TLSv1 for MinimumProtocolVersion."
        }
      },
      "documentation":"A complex type that contains information about viewer certificates for this distribution."
    },
    "ViewerProtocolPolicy":{
      "type":"string",
      "enum":[
        "allow-all",
        "https-only",
        "redirect-to-https"
      ]
    },
    "boolean":{"type":"boolean"},
    "integer":{"type":"integer"},
    "long":{"type":"long"},
    "string":{"type":"string"},
    "timestamp":{"type":"timestamp"}
  }
}
       usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-10-21/waiters-2.json            0100644 0000000 0000062 00000002240 13077704371 026664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version": 2,
  "waiters": {
    "DistributionDeployed": {
      "delay": 60,
      "operation": "GetDistribution",
      "maxAttempts": 25,
      "description": "Wait until a distribution is deployed.",
      "acceptors": [
        {
          "expected": "Deployed",
          "matcher": "path",
          "state": "success",
          "argument": "Distribution.Status"
        }
      ]
    },
    "InvalidationCompleted": {
      "delay": 20,
      "operation": "GetInvalidation",
      "maxAttempts": 60,
      "description": "Wait until an invalidation has completed.",
      "acceptors": [
        {
          "expected": "Completed",
          "matcher": "path",
          "state": "success",
          "argument": "Invalidation.Status"
        }
      ]
    },
    "StreamingDistributionDeployed": {
      "delay": 60,
      "operation": "GetStreamingDistribution",
      "maxAttempts": 25,
      "description": "Wait until a streaming distribution is deployed.",
      "acceptors": [
        {
          "expected": "Deployed",
          "matcher": "path",
          "state": "success",
          "argument": "StreamingDistribution.Status"
        }
      ]
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-11-06/                          0042755 0000000 0000062 00000000000 13077704402 024162  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-11-06/paginators-1.json         0100644 0000000 0000062 00000002146 13077704371 027365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "pagination": {
    "ListCloudFrontOriginAccessIdentities": {
      "input_token": "Marker",
      "output_token": "CloudFrontOriginAccessIdentityList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "CloudFrontOriginAccessIdentityList.IsTruncated",
      "result_key": "CloudFrontOriginAccessIdentityList.Items"
    },
    "ListDistributions": {
      "input_token": "Marker",
      "output_token": "DistributionList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "DistributionList.IsTruncated",
      "result_key": "DistributionList.Items"
    },
    "ListInvalidations": {
      "input_token": "Marker",
      "output_token": "InvalidationList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "InvalidationList.IsTruncated",
      "result_key": "InvalidationList.Items"
    },
    "ListStreamingDistributions": {
      "input_token": "Marker",
      "output_token": "StreamingDistributionList.NextMarker",
      "limit_key": "MaxItems",
      "more_results": "StreamingDistributionList.IsTruncated",
      "result_key": "StreamingDistributionList.Items"
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/lib/python2.7/dist-packages/botocore/data/cloudfront/2014-11-06/service-2.json            0100644 0000000 0000062 00000440326 13077704371 026665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        {
  "version":"2.0",
  "metadata":{
    "apiVersion":"2014-11-06",
    "endpointPrefix":"cloudfront",
    "globalEndpoint":"cloudfront.amazonaws.com",
    "serviceAbbreviation":"CloudFront",
    "serviceFullName":"Amazon CloudFront",
    "signatureVersion":"v4",
    "protocol":"rest-xml"
  },
  "operations":{
    "CreateCloudFrontOriginAccessIdentity":{
      "name":"CreateCloudFrontOriginAccessIdentity2014_11_06",
      "http":{
        "method":"POST",
        "requestUri":"/2014-11-06/origin-access-identity/cloudfront",
        "responseCode":201
      },
      "input":{
        "shape":"CreateCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to create a new origin access identity."
      },
      "output":{
        "shape":"CreateCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CloudFrontOriginAccessIdentityAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true,
          "documentation":"If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyCloudFrontOriginAccessIdentities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of origin access identities allowed."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new origin access identity."
    },
    "CreateDistribution":{
      "name":"CreateDistribution2014_11_06",
      "http":{
        "method":"POST",
        "requestUri":"/2014-11-06/distribution",
        "responseCode":201
      },
      "input":{
        "shape":"CreateDistributionRequest",
        "documentation":"The request to create a new distribution."
      },
      "output":{
        "shape":"CreateDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"DistributionAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true,
          "documentation":"The caller reference you attempted to create the distribution with is associated with another distribution."
        },
        {
          "shape":"InvalidOrigin",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InvalidViewerCertificate",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more CNAMEs than are allowed per distribution."
        },
        {
          "shape":"TooManyDistributions",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of distributions allowed."
        },
        {
          "shape":"InvalidDefaultRootObject",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The default root object file name is too big or contains an invalid character."
        },
        {
          "shape":"InvalidRelativePath",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
        },
        {
          "shape":"InvalidErrorCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidResponseCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidRequiredProtocol",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
        },
        {
          "shape":"NoSuchOrigin",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"No origin exists with the specified Origin Id."
        },
        {
          "shape":"TooManyOrigins",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore origins for the distribution."
        },
        {
          "shape":"TooManyCacheBehaviors",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore cache behaviors for the distribution."
        },
        {
          "shape":"TooManyCookieNamesInWhiteList",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
        },
        {
          "shape":"InvalidForwardCookies",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
        },
        {
          "shape":"TooManyHeadersInForwardedValues",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidHeadersForS3Origin",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        },
        {
          "shape":"TooManyCertificates",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore custom ssl certificates."
        },
        {
          "shape":"InvalidLocationCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidGeoRestrictionParameter",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidProtocolSettings",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that Support Server Name Indication (SNI)."
        }
      ],
      "documentation":"Create a new distribution."
    },
    "CreateInvalidation":{
      "name":"CreateInvalidation2014_11_06",
      "http":{
        "method":"POST",
        "requestUri":"/2014-11-06/distribution/{DistributionId}/invalidation",
        "responseCode":201
      },
      "input":{
        "shape":"CreateInvalidationRequest",
        "documentation":"The request to create an invalidation."
      },
      "output":{
        "shape":"CreateInvalidationResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"BatchTooLarge",
          "error":{"httpStatusCode":413},
          "exception":true
        },
        {
          "shape":"TooManyInvalidationsInProgress",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new invalidation."
    },
    "CreateStreamingDistribution":{
      "name":"CreateStreamingDistribution2014_11_06",
      "http":{
        "method":"POST",
        "requestUri":"/2014-11-06/streaming-distribution",
        "responseCode":201
      },
      "input":{
        "shape":"CreateStreamingDistributionRequest",
        "documentation":"The request to create a new streaming distribution."
      },
      "output":{
        "shape":"CreateStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"StreamingDistributionAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidOrigin",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"TooManyStreamingDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"TooManyStreamingDistributions",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Processing your request would cause you to exceed the maximum number of streaming distributions allowed."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Create a new streaming distribution."
    },
    "DeleteCloudFrontOriginAccessIdentity":{
      "name":"DeleteCloudFrontOriginAccessIdentity2014_11_06",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-11-06/origin-access-identity/cloudfront/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to delete a origin access identity."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"CloudFrontOriginAccessIdentityInUse",
          "error":{"httpStatusCode":409},
          "exception":true
        }
      ],
      "documentation":"Delete an origin access identity."
    },
    "DeleteDistribution":{
      "name":"DeleteDistribution2014_11_06",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-11-06/distribution/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteDistributionRequest",
        "documentation":"The request to delete a distribution."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"DistributionNotDisabled",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        }
      ],
      "documentation":"Delete a distribution."
    },
    "DeleteStreamingDistribution":{
      "name":"DeleteStreamingDistribution2014_11_06",
      "http":{
        "method":"DELETE",
        "requestUri":"/2014-11-06/streaming-distribution/{Id}",
        "responseCode":204
      },
      "input":{
        "shape":"DeleteStreamingDistributionRequest",
        "documentation":"The request to delete a streaming distribution."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"StreamingDistributionNotDisabled",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        }
      ],
      "documentation":"Delete a streaming distribution."
    },
    "GetCloudFrontOriginAccessIdentity":{
      "name":"GetCloudFrontOriginAccessIdentity2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/origin-access-identity/cloudfront/{Id}"
      },
      "input":{
        "shape":"GetCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to get an origin access identity's information."
      },
      "output":{
        "shape":"GetCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about an origin access identity."
    },
    "GetCloudFrontOriginAccessIdentityConfig":{
      "name":"GetCloudFrontOriginAccessIdentityConfig2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/origin-access-identity/cloudfront/{Id}/config"
      },
      "input":{
        "shape":"GetCloudFrontOriginAccessIdentityConfigRequest",
        "documentation":"The request to get an origin access identity's configuration."
      },
      "output":{
        "shape":"GetCloudFrontOriginAccessIdentityConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about an origin access identity."
    },
    "GetDistribution":{
      "name":"GetDistribution2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/distribution/{Id}"
      },
      "input":{
        "shape":"GetDistributionRequest",
        "documentation":"The request to get a distribution's information."
      },
      "output":{
        "shape":"GetDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about a distribution."
    },
    "GetDistributionConfig":{
      "name":"GetDistributionConfig2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/distribution/{Id}/config"
      },
      "input":{
        "shape":"GetDistributionConfigRequest",
        "documentation":"The request to get a distribution configuration."
      },
      "output":{
        "shape":"GetDistributionConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about a distribution."
    },
    "GetInvalidation":{
      "name":"GetInvalidation2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/distribution/{DistributionId}/invalidation/{Id}"
      },
      "input":{
        "shape":"GetInvalidationRequest",
        "documentation":"The request to get an invalidation's information."
      },
      "output":{
        "shape":"GetInvalidationResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchInvalidation",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified invalidation does not exist."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about an invalidation."
    },
    "GetStreamingDistribution":{
      "name":"GetStreamingDistribution2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/streaming-distribution/{Id}"
      },
      "input":{
        "shape":"GetStreamingDistributionRequest",
        "documentation":"The request to get a streaming distribution's information."
      },
      "output":{
        "shape":"GetStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the information about a streaming distribution."
    },
    "GetStreamingDistributionConfig":{
      "name":"GetStreamingDistributionConfig2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/streaming-distribution/{Id}/config"
      },
      "input":{
        "shape":"GetStreamingDistributionConfigRequest",
        "documentation":"To request to get a streaming distribution configuration."
      },
      "output":{
        "shape":"GetStreamingDistributionConfigResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"Get the configuration information about a streaming distribution."
    },
    "ListCloudFrontOriginAccessIdentities":{
      "name":"ListCloudFrontOriginAccessIdentities2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/origin-access-identity/cloudfront"
      },
      "input":{
        "shape":"ListCloudFrontOriginAccessIdentitiesRequest",
        "documentation":"The request to list origin access identities."
      },
      "output":{
        "shape":"ListCloudFrontOriginAccessIdentitiesResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List origin access identities."
    },
    "ListDistributions":{
      "name":"ListDistributions2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/distribution"
      },
      "input":{
        "shape":"ListDistributionsRequest",
        "documentation":"The request to list your distributions."
      },
      "output":{
        "shape":"ListDistributionsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List distributions."
    },
    "ListInvalidations":{
      "name":"ListInvalidations2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/distribution/{DistributionId}/invalidation"
      },
      "input":{
        "shape":"ListInvalidationsRequest",
        "documentation":"The request to list invalidations."
      },
      "output":{
        "shape":"ListInvalidationsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        }
      ],
      "documentation":"List invalidation batches."
    },
    "ListStreamingDistributions":{
      "name":"ListStreamingDistributions2014_11_06",
      "http":{
        "method":"GET",
        "requestUri":"/2014-11-06/streaming-distribution"
      },
      "input":{
        "shape":"ListStreamingDistributionsRequest",
        "documentation":"The request to list your streaming distributions."
      },
      "output":{
        "shape":"ListStreamingDistributionsResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        }
      ],
      "documentation":"List streaming distributions."
    },
    "UpdateCloudFrontOriginAccessIdentity":{
      "name":"UpdateCloudFrontOriginAccessIdentity2014_11_06",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-11-06/origin-access-identity/cloudfront/{Id}/config"
      },
      "input":{
        "shape":"UpdateCloudFrontOriginAccessIdentityRequest",
        "documentation":"The request to update an origin access identity."
      },
      "output":{
        "shape":"UpdateCloudFrontOriginAccessIdentityResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchCloudFrontOriginAccessIdentity",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified origin access identity does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Update an origin access identity."
    },
    "UpdateDistribution":{
      "name":"UpdateDistribution2014_11_06",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-11-06/distribution/{Id}/config"
      },
      "input":{
        "shape":"UpdateDistributionRequest",
        "documentation":"The request to update a distribution."
      },
      "output":{
        "shape":"UpdateDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"TooManyDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more CNAMEs than are allowed per distribution."
        },
        {
          "shape":"InvalidDefaultRootObject",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The default root object file name is too big or contains an invalid character."
        },
        {
          "shape":"InvalidRelativePath",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The relative path is too big, is not URL-encoded, or does not begin with a slash (/)."
        },
        {
          "shape":"InvalidErrorCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidResponseCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InvalidViewerCertificate",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidRequiredProtocol",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration."
        },
        {
          "shape":"NoSuchOrigin",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"No origin exists with the specified Origin Id."
        },
        {
          "shape":"TooManyOrigins",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore origins for the distribution."
        },
        {
          "shape":"TooManyCacheBehaviors",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore cache behaviors for the distribution."
        },
        {
          "shape":"TooManyCookieNamesInWhiteList",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more cookie names in the whitelist than are allowed per cache behavior."
        },
        {
          "shape":"InvalidForwardCookies",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected."
        },
        {
          "shape":"TooManyHeadersInForwardedValues",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidHeadersForS3Origin",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        },
        {
          "shape":"TooManyCertificates",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"You cannot create anymore custom ssl certificates."
        },
        {
          "shape":"InvalidLocationCode",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidGeoRestrictionParameter",
          "error":{"httpStatusCode":400},
          "exception":true
        }
      ],
      "documentation":"Update a distribution."
    },
    "UpdateStreamingDistribution":{
      "name":"UpdateStreamingDistribution2014_11_06",
      "http":{
        "method":"PUT",
        "requestUri":"/2014-11-06/streaming-distribution/{Id}/config"
      },
      "input":{
        "shape":"UpdateStreamingDistributionRequest",
        "documentation":"The request to update a streaming distribution."
      },
      "output":{
        "shape":"UpdateStreamingDistributionResult",
        "documentation":"The returned result of the corresponding request."
      },
      "errors":[
        {
          "shape":"AccessDenied",
          "error":{"httpStatusCode":403},
          "exception":true,
          "documentation":"Access denied."
        },
        {
          "shape":"CNAMEAlreadyExists",
          "error":{"httpStatusCode":409},
          "exception":true
        },
        {
          "shape":"IllegalUpdate",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Origin and CallerReference cannot be updated."
        },
        {
          "shape":"InvalidIfMatchVersion",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The If-Match version is missing or not valid for the distribution."
        },
        {
          "shape":"MissingBody",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"This operation requires a body. Ensure that the body is present and the Content-Type header is set."
        },
        {
          "shape":"NoSuchStreamingDistribution",
          "error":{"httpStatusCode":404},
          "exception":true,
          "documentation":"The specified streaming distribution does not exist."
        },
        {
          "shape":"PreconditionFailed",
          "error":{"httpStatusCode":412},
          "exception":true,
          "documentation":"The precondition given in one or more of the request-header fields evaluated to false."
        },
        {
          "shape":"TooManyStreamingDistributionCNAMEs",
          "error":{"httpStatusCode":400},
          "exception":true
        },
        {
          "shape":"InvalidArgument",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The argument is invalid."
        },
        {
          "shape":"InvalidOriginAccessIdentity",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The origin access identity is not valid or doesn't exist."
        },
        {
          "shape":"TooManyTrustedSigners",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"Your request contains more trusted signers than are allowed per distribution."
        },
        {
          "shape":"TrustedSignerDoesNotExist",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"One or more of your trusted signers do not exist."
        },
        {
          "shape":"InconsistentQuantities",
          "error":{"httpStatusCode":400},
          "exception":true,
          "documentation":"The value of Quantity and the size of Items do not match."
        }
      ],
      "documentation":"Update a streaming distribution."
    }
  },
  "shapes":{
    "AccessDenied":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":403},
      "exception":true,
      "documentation":"Access denied."
    },
    "ActiveTrustedSigners":{
      "type":"structure",
      "required":[
        "Enabled",
        "Quantity"
      ],
      "members":{
        "Enabled":{
          "shape":"boolean",
          "documentation":"Each active trusted signer."
        },
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of unique trusted signers included in all cache behaviors. For example, if three cache behaviors all list the same three AWS accounts, the value of Quantity for ActiveTrustedSigners will be 3."
        },
        "Items":{
          "shape":"SignerList",
          "documentation":"A complex type that contains one Signer complex type for each unique trusted signer that is specified in the TrustedSigners complex type, including trusted signers in the default cache behavior and in all of the other cache behaviors."
        }
      },
      "documentation":"A complex type that lists the AWS accounts, if any, that you included in the TrustedSigners complex type for the default cache behavior or for any of the other cache behaviors for this distribution. These are accounts that you want to allow to create signed URLs for private content."
    },
    "AliasList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"CNAME"
      }
    },
    "Aliases":{
      "type":"structure",
      "required":["Quantity"],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of CNAMEs, if any, for this distribution."
        },
        "Items":{
          "shape":"AliasList",
          "documentation":"Optional: A complex type that contains CNAME elements, if any, for this distribution. If Quantity is 0, you can omit Items."
        }
      },
      "documentation":"A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution."
    },
    "AllowedMethods":{
      "type":"structure",
      "required":[
        "Quantity",
        "Items"
      ],
      "members":{
        "Quantity":{
          "shape":"integer",
          "documentation":"The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests)."
        },
        "Items":{
          "shape":"MethodsList",
          "documentation":"A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin."
        },
        "CachedMethods":{"shape":"CachedMethods"}
      },
      "documentation":"A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices: - CloudFront forwards only GET and HEAD requests. - CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you may not want users to have permission to delete objects from your origin."
    },
    "AwsAccountNumberList":{
      "type":"list",
      "member":{
        "shape":"string",
        "locationName":"AwsAccountNumber"
      }
    },
    "BatchTooLarge":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":413},
      "exception":true
    },
    "CNAMEAlreadyExists":{
      "type":"structure",
      "members":{
        "Message":{"shape":"string"}
      },
      "error":{"httpStatusCode":409},
      "exception":true
    },
    "CacheBehavior":{
      "type":"structure",
      "required":[
        "PathPattern",
        "TargetOriginId",
        "ForwardedValues",
        "TrustedSigners",
        "ViewerProtocolPolicy",
        "MinTTL"
      ],
      "members":{
        "PathPattern":{
          "shape":"string",
          "documentation":"The pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to. When CloudFront receives an end-user request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior."
        },
        "TargetOriginId":{
          "shape":"string",
          "documentation":"The value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."
        },
        "ForwardedValues":{
          "shape":"ForwardedValues",
          "documentation":"A complex type that specifies how CloudFront handles query strings, cookies and headers."
        },
        "TrustedSigners":{
          "shape":"TrustedSigners",
          "documentation":"A complex type that specifies the AWS accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items. For more information, go to Using a Signed URL to Serve Private Content in the Amazon CloudFront Developer Guide. If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution."
        },
        "ViewerProtocolPolicy":{
          "shape":"ViewerProtocolPolicy",
          "documentation":"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPat