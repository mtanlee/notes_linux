umber, meaning it is
        topologically sorted.

        'heads' and 'common' are both lists of node IDs.  If heads is
        not supplied, uses all of the revlog's heads.  If common is not
        supplied, uses nullid."""
        if common is None:
            common = [nullid]
        if heads is None:
            heads = self.heads()

        common = [self.rev(n) for n in common]
        heads = [self.rev(n) for n in heads]

        # we want the ancestors, but inclusive
        class lazyset(object):
            def __init__(self, lazyvalues):
                self.addedvalues = set()
                self.lazyvalues = lazyvalues

            def __contains__(self, value):
                return value in self.addedvalues or value in self.lazyvalues

            def __iter__(self):
                added = self.addedvalues
                for r in added:
                    yield r
                for r in self.lazyvalues:
                    if not r in added:
                        yield r

            def add(self, value):
                self.addedvalues.add(value)

            def update(self, values):
                self.addedvalues.update(values)

        has = lazyset(self.ancestors(common))
        has.add(nullrev)
        has.update(common)

        # take all ancestors from heads that aren't in has
        missing = set()
        visit = util.deque(r for r in heads if r not in has)
        while visit:
            r = visit.popleft()
            if r in missing:
                continue
            else:
                missing.add(r)
                for p in self.parentrevs(r):
                    if p not in has:
                        visit.append(p)
        missing = list(missing)
        missing.sort()
        return has, [self.node(r) for r in missing]

    def findmissingrevs(self, common=None, heads=None):
        """Return the revision numbers of the ancestors of heads that
        are not ancestors of common.

        More specifically, return a list of revision numbers corresponding to
        nodes N such that every N satisfies the following constraints:

          1. N is an ancestor of some node in 'heads'
          2. N is not an ancestor of any node in 'common'

        The list is sorted by revision number, meaning it is
        topologically sorted.

        'heads' and 'common' are both lists of revision numbers.  If heads is
        not supplied, uses all of the revlog's heads.  If common is not
        supplied, uses nullid."""
        if common is None:
            common = [nullrev]
        if heads is None:
            heads = self.headrevs()

        return ancestor.missingancestors(heads, common, self.parentrevs)

    def findmissing(self, common=None, heads=None):
        """Return the ancestors of heads that are not ancestors of common.

        More specifically, return a list of nodes N such that every N
        satisfies the following constraints:

          1. N is an ancestor of some node in 'heads'
          2. N is not an ancestor of any node in 'common'

        The list is sorted by revision number, meaning it is
        topologically sorted.

        'heads' and 'common' are both lists of node IDs.  If heads is
        not supplied, uses all of the revlog's heads.  If common is not
        supplied, uses nullid."""
        if common is None:
            common = [nullid]
        if heads is None:
            heads = self.heads()

        common = [self.rev(n) for n in common]
        heads = [self.rev(n) for n in heads]

        return [self.node(r) for r in
                ancestor.missingancestors(heads, common, self.parentrevs)]

    def nodesbetween(self, roots=None, heads=None):
        """Return a topological path from 'roots' to 'heads'.

        Return a tuple (nodes, outroots, outheads) where 'nodes' is a
        topologically sorted list of all nodes N that satisfy both of
        these constraints:

          1. N is a descendant of some node in 'roots'
          2. N is an ancestor of some node in 'heads'

        Every node is considered to be both a descendant and an ancestor
        of itself, so every reachable node in 'roots' and 'heads' will be
        included in 'nodes'.

        'outroots' is the list of reachable nodes in 'roots', i.e., the
        subset of 'roots' that is returned in 'nodes'.  Likewise,
        'outheads' is the subset of 'heads' that is also in 'nodes'.

        'roots' and 'heads' are both lists of node IDs.  If 'roots' is
        unspecified, uses nullid as the only root.  If 'heads' is
        unspecified, uses list of all of the revlog's heads."""
        nonodes = ([], [], [])
        if roots is not None:
            roots = list(roots)
            if not roots:
                return nonodes
            lowestrev = min([self.rev(n) for n in roots])
        else:
            roots = [nullid] # Everybody's a descendant of nullid
            lowestrev = nullrev
        if (lowestrev == nullrev) and (heads is None):
            # We want _all_ the nodes!
            return ([self.node(r) for r in self], [nullid], list(self.heads()))
        if heads is None:
            # All nodes are ancestors, so the latest ancestor is the last
            # node.
            highestrev = len(self) - 1
            # Set ancestors to None to signal that every node is an ancestor.
            ancestors = None
            # Set heads to an empty dictionary for later discovery of heads
            heads = {}
        else:
            heads = list(heads)
            if not heads:
                return nonodes
            ancestors = set()
            # Turn heads into a dictionary so we can remove 'fake' heads.
            # Also, later we will be using it to filter out the heads we can't
            # find from roots.
            heads = dict.fromkeys(heads, False)
            # Start at the top and keep marking parents until we're done.
            nodestotag = set(heads)
            # Remember where the top was so we can use it as a limit later.
            highestrev = max([self.rev(n) for n in nodestotag])
            while nodestotag:
                # grab a node to tag
                n = nodestotag.pop()
                # Never tag nullid
                if n == nullid:
                    continue
                # A node's revision number represents its place in a
                # topologically sorted list of nodes.
                r = self.rev(n)
                if r >= lowestrev:
                    if n not in ancestors:
                        # If we are possibly a descendant of one of the roots
                        # and we haven't already been marked as an ancestor
                        ancestors.add(n) # Mark as ancestor
                        # Add non-nullid parents to list of nodes to tag.
                        nodestotag.update([p for p in self.parents(n) if
                                           p != nullid])
                    elif n in heads: # We've seen it before, is it a fake head?
                        # So it is, real heads should not be the ancestors of
                        # any other heads.
                        heads.pop(n)
            if not ancestors:
                return nonodes
            # Now that we have our set of ancestors, we want to remove any
            # roots that are not ancestors.

            # If one of the roots was nullid, everything is included anyway.
            if lowestrev > nullrev:
                # But, since we weren't, let's recompute the lowest rev to not
                # include roots that aren't ancestors.

                # Filter out roots that aren't ancestors of heads
                roots = [n for n in roots if n in ancestors]
                # Recompute the lowest revision
                if roots:
                    lowestrev = min([self.rev(n) for n in roots])
                else:
                    # No more roots?  Return empty list
                    return nonodes
            else:
                # We are descending from nullid, and don't need to care about
                # any other roots.
                lowestrev = nullrev
                roots = [nullid]
        # Transform our roots list into a set.
        descendants = set(roots)
        # Also, keep the original roots so we can filter out roots that aren't
        # 'real' roots (i.e. are descended from other roots).
        roots = descendants.copy()
        # Our topologically sorted list of output nodes.
        orderedout = []
        # Don't start at nullid since we don't want nullid in our output list,
        # and if nullid shows up in descendants, empty parents will look like
        # they're descendants.
        for r in self.revs(start=max(lowestrev, 0), stop=highestrev + 1):
            n = self.node(r)
            isdescendant = False
            if lowestrev == nullrev:  # Everybody is a descendant of nullid
                isdescendant = True
            elif n in descendants:
                # n is already a descendant
                isdescendant = True
                # This check only needs to be done here because all the roots
                # will start being marked is descendants before the loop.
                if n in roots:
                    # If n was a root, check if it's a 'real' root.
                    p = tuple(self.parents(n))
                    # If any of its parents are descendants, it's not a root.
                    if (p[0] in descendants) or (p[1] in descendants):
                        roots.remove(n)
            else:
                p = tuple(self.parents(n))
                # A node is a descendant if either of its parents are
                # descendants.  (We seeded the dependents list with the roots
                # up there, remember?)
                if (p[0] in descendants) or (p[1] in descendants):
                    descendants.add(n)
                    isdescendant = True
            if isdescendant and ((ancestors is None) or (n in ancestors)):
                # Only include nodes that are both descendants and ancestors.
                orderedout.append(n)
                if (ancestors is not None) and (n in heads):
                    # We're trying to figure out which heads are reachable
                    # from roots.
                    # Mark this head as having been reached
                    heads[n] = True
                elif ancestors is None:
                    # Otherwise, we're trying to discover the heads.
                    # Assume this is a head because if it isn't, the next step
                    # will eventually remove it.
                    heads[n] = True
                    # But, obviously its parents aren't.
                    for p in self.parents(n):
                        heads.pop(p, None)
        heads = [n for n, flag in heads.iteritems() if flag]
        roots = list(roots)
        assert orderedout
        assert roots
        assert heads
        return (orderedout, roots, heads)

    def headrevs(self):
        try:
            return self.index.headrevs()
        except AttributeError:
            return self._headrevs()

    def _headrevs(self):
        count = len(self)
        if not count:
            return [nullrev]
        # we won't iter over filtered rev so nobody is a head at start
        ishead = [0] * (count + 1)
        index = self.index
        for r in self:
            ishead[r] = 1  # I may be an head
            e = index[r]
            ishead[e[5]] = ishead[e[6]] = 0  # my parent are not
        return [r for r, val in enumerate(ishead) if val]

    def heads(self, start=None, stop=None):
        """return the list of all nodes that have no children

        if start is specified, only heads that are descendants of
        start will be returned
        if stop is specified, it will consider all the revs from stop
        as if they had no children
        """
        if start is None and stop is None:
            if not len(self):
                return [nullid]
            return [self.node(r) for r in self.headrevs()]

        if start is None:
            start = nullid
        if stop is None:
            stop = []
        stoprevs = set([self.rev(n) for n in stop])
        startrev = self.rev(start)
        reachable = set((startrev,))
        heads = set((startrev,))

        parentrevs = self.parentrevs
        for r in self.revs(start=startrev + 1):
            for p in parentrevs(r):
                if p in reachable:
                    if r not in stoprevs:
                        reachable.add(r)
                    heads.add(r)
                if p in heads and p not in stoprevs:
                    heads.remove(p)

        return [self.node(r) for r in heads]

    def children(self, node):
        """find the children of a given node"""
        c = []
        p = self.rev(node)
        for r in self.revs(start=p + 1):
            prevs = [pr for pr in self.parentrevs(r) if pr != nullrev]
            if prevs:
                for pr in prevs:
                    if pr == p:
                        c.append(self.node(r))
            elif p == nullrev:
                c.append(self.node(r))
        return c

    def descendant(self, start, end):
        if start == nullrev:
            return True
        for i in self.descendants([start]):
            if i == end:
                return True
            elif i > end:
                break
        return False

    def commonancestorsheads(self, a, b):
        """calculate all the heads of the common ancestors of nodes a and b"""
        a, b = self.rev(a), self.rev(b)
        try:
            ancs = self.index.commonancestorsheads(a, b)
        except (AttributeError, OverflowError): # C implementation failed
            ancs = ancestor.commonancestorsheads(self.parentrevs, a, b)
        return map(self.node, ancs)

    def ancestor(self, a, b):
        """calculate the least common ancestor of nodes a and b"""

        a, b = self.rev(a), self.rev(b)
        try:
            ancs = self.index.ancestors(a, b)
        except (AttributeError, OverflowError):
            ancs = ancestor.ancestors(self.parentrevs, a, b)
        if ancs:
            # choose a consistent winner when there's a tie
            return min(map(self.node, ancs))
        return nullid

    def _match(self, id):
        if isinstance(id, int):
            # rev
            return self.node(id)
        if len(id) == 20:
            # possibly a binary node
            # odds of a binary node being all hex in ASCII are 1 in 10**25
            try:
                node = id
                self.rev(node) # quick search the index
                return node
            except LookupError:
                pass # may be partial hex id
        try:
            # str(rev)
            rev = int(id)
            if str(rev) != id:
                raise ValueError
            if rev < 0:
                rev = len(self) + rev
            if rev < 0 or rev >= len(self):
                raise ValueError
            return self.node(rev)
        except (ValueError, OverflowError):
            pass
        if len(id) == 40:
            try:
                # a full hex nodeid?
                node = bin(id)
                self.rev(node)
                return node
            except (TypeError, LookupError):
                pass

    def _partialmatch(self, id):
        try:
            n = self.index.partialmatch(id)
            if n and self.hasnode(n):
                return n
            return None
        except RevlogError:
            # parsers.c radix tree lookup gave multiple matches
            # fall through to slow path that filters hidden revisions
            pass
        except (AttributeError, ValueError):
            # we are pure python, or key was too short to search radix tree
            pass

        if id in self._pcache:
            return self._pcache[id]

        if len(id) < 40:
            try:
                # hex(node)[:...]
                l = len(id) // 2  # grab an even number of digits
                prefix = bin(id[:l * 2])
                nl = [e[7] for e in self.index if e[7].startswith(prefix)]
                nl = [n for n in nl if hex(n).startswith(id) and
                      self.hasnode(n)]
                if len(nl) > 0:
                    if len(nl) == 1:
                        self._pcache[id] = nl[0]
                        return nl[0]
                    raise LookupError(id, self.indexfile,
                                      _('ambiguous identifier'))
                return None
            except TypeError:
                pass

    def lookup(self, id):
        """locate a node based on:
            - revision number or str(revision number)
            - nodeid or subset of hex nodeid
        """
        n = self._match(id)
        if n is not None:
            return n
        n = self._partialmatch(id)
        if n:
            return n

        raise LookupError(id, self.indexfile, _('no match found'))

    def cmp(self, node, text):
        """compare text with a given file revision

        returns True if text is different than what is stored.
        """
        p1, p2 = self.parents(node)
        return hash(text, p1, p2) != node

    def _addchunk(self, offset, data):
        o, d = self._chunkcache
        # try to add to existing cache
        if o + len(d) == offset and len(d) + len(data) < _chunksize:
            self._chunkcache = o, d + data
        else:
            self._chunkcache = offset, data

    def _loadchunk(self, offset, length):
        if self._inline:
            df = self.opener(self.indexfile)
        else:
            df = self.opener(self.datafile)

        # Cache data both forward and backward around the requested
        # data, in a fixed size window. This helps speed up operations
        # involving reading the revlog backwards.
        cachesize = self._chunkcachesize
        realoffset = offset & ~(cachesize - 1)
        reallength = (((offset + length + cachesize) & ~(cachesize - 1))
                      - realoffset)
        df.seek(realoffset)
        d = df.read(reallength)
        df.close()
        self._addchunk(realoffset, d)
        if offset != realoffset or reallength != length:
            return util.buffer(d, offset - realoffset, length)
        return d

    def _getchunk(self, offset, length):
        o, d = self._chunkcache
        l = len(d)

        # is it in the cache?
        cachestart = offset - o
        cacheend = cachestart + length
        if cachestart >= 0 and cacheend <= l:
            if cachestart == 0 and cacheend == l:
                return d # avoid a copy
            return util.buffer(d, cachestart, cacheend - cachestart)

        return self._loadchunk(offset, length)

    def _chunkraw(self, startrev, endrev):
        start = self.start(startrev)
        end = self.end(endrev)
        if self._inline:
            start += (startrev + 1) * self._io.size
            end += (endrev + 1) * self._io.size
        length = end - start
        return self._getchunk(start, length)

    def _chunk(self, rev):
        return decompress(self._chunkraw(rev, rev))

    def _chunks(self, revs):
        '''faster version of [self._chunk(rev) for rev in revs]

        Assumes that revs is in ascending order.'''
        if not revs:
            return []
        start = self.start
        length = self.length
        inline = self._inline
        iosize = self._io.size
        buffer = util.buffer

        l = []
        ladd = l.append

        # preload the cache
        try:
            while True:
                # ensure that the cache doesn't change out from under us
                _cache = self._chunkcache
                self._chunkraw(revs[0], revs[-1])
                if _cache == self._chunkcache:
                    break
            offset, data = _cache
        except OverflowError:
            # issue4215 - we can't cache a run of chunks greater than
            # 2G on Windows
            return [self._chunk(rev) for rev in revs]

        for rev in revs:
            chunkstart = start(rev)
            if inline:
                chunkstart += (rev + 1) * iosize
            chunklength = length(rev)
            ladd(decompress(buffer(data, chunkstart - offset, chunklength)))

        return l

    def _chunkclear(self):
        self._chunkcache = (0, '')

    def deltaparent(self, rev):
        """return deltaparent of the given revision"""
        base = self.index[rev][3]
        if base == rev:
            return nullrev
        elif self._generaldelta:
            return base
        else:
            return rev - 1

    def revdiff(self, rev1, rev2):
        """return or calculate a delta between two revisions"""
        if rev1 != nullrev and self.deltaparent(rev2) == rev1:
            return str(self._chunk(rev2))

        return mdiff.textdiff(self.revision(rev1),
                              self.revision(rev2))

    def revision(self, nodeorrev):
        """return an uncompressed revision of a given node or revision
        number.
        """
        if isinstance(nodeorrev, int):
            rev = nodeorrev
            node = self.node(rev)
        else:
            node = nodeorrev
            rev = None

        _cache = self._cache # grab local copy of cache to avoid thread race
        cachedrev = None
        if node == nullid:
            return ""
        if _cache:
            if _cache[0] == node:
                return _cache[2]
            cachedrev = _cache[1]

        # look up what we need to read
        text = None
        if rev is None:
            rev = self.rev(node)

        # check rev flags
        if self.flags(rev) & ~REVIDX_KNOWN_FLAGS:
            raise RevlogError(_('incompatible revision flag %x') %
                              (self.flags(rev) & ~REVIDX_KNOWN_FLAGS))

        # build delta chain
        chain = []
        index = self.index # for performance
        generaldelta = self._generaldelta
        iterrev = rev
        e = index[iterrev]
        while iterrev != e[3] and iterrev != cachedrev:
            chain.append(iterrev)
            if generaldelta:
                iterrev = e[3]
            else:
                iterrev -= 1
            e = index[iterrev]

        if iterrev == cachedrev:
            # cache hit
            text = _cache[2]
        else:
            chain.append(iterrev)
        chain.reverse()

        # drop cache to save memory
        self._cache = None

        bins = self._chunks(chain)
        if text is None:
            text = str(bins[0])
            bins = bins[1:]

        text = mdiff.patches(text, bins)

        text = self._checkhash(text, node, rev)

        self._cache = (node, rev, text)
        return text

    def _checkhash(self, text, node, rev):
        p1, p2 = self.parents(node)
        self.checkhash(text, p1, p2, node, rev)
        return text

    def checkhash(self, text, p1, p2, node, rev=None):
        if node != hash(text, p1, p2):
            revornode = rev
            if revornode is None:
                revornode = templatefilters.short(hex(node))
            raise RevlogError(_("integrity check failed on %s:%s")
                % (self.indexfile, revornode))

    def checkinlinesize(self, tr, fp=None):
        if not self._inline or (self.start(-2) + self.length(-2)) < _maxinline:
            return

        trinfo = tr.find(self.indexfile)
        if trinfo is None:
            raise RevlogError(_("%s not found in the transaction")
                              % self.indexfile)

        trindex = trinfo[2]
        dataoff = self.start(trindex)

        tr.add(self.datafile, dataoff)

        if fp:
            fp.flush()
            fp.close()

        df = self.opener(self.datafile, 'w')
        try:
            for r in self:
                df.write(self._chunkraw(r, r))
        finally:
            df.close()

        fp = self.opener(self.indexfile, 'w', atomictemp=True)
        self.version &= ~(REVLOGNGINLINEDATA)
        self._inline = False
        for i in self:
            e = self._io.packentry(self.index[i], self.node, self.version, i)
            fp.write(e)

        # if we don't call close, the temp file will never replace the
        # real index
        fp.close()

        tr.replace(self.indexfile, trindex * self._io.size)
        self._chunkclear()

    def addrevision(self, text, transaction, link, p1, p2, cachedelta=None,
                    node=None):
        """add a revision to the log

        text - the revision data to add
        transaction - the transaction object used for rollback
        link - the linkrev data to add
        p1, p2 - the parent nodeids of the revision
        cachedelta - an optional precomputed delta
        node - nodeid of revision; typically node is not specified, and it is
            computed by default as hash(text, p1, p2), however subclasses might
            use different hashing method (and override checkhash() in such case)
        """
        if link == nullrev:
            raise RevlogError(_("attempted to add linkrev -1 to %s")
                              % self.indexfile)
        node = node or hash(text, p1, p2)
        if node in self.nodemap:
            return node

        dfh = None
        if not self._inline:
            dfh = self.opener(self.datafile, "a")
        ifh = self.opener(self.indexfile, "a+")
        try:
            return self._addrevision(node, text, transaction, link, p1, p2,
                                     cachedelta, ifh, dfh)
        finally:
            if dfh:
                dfh.close()
            ifh.close()

    def compress(self, text):
        """ generate a possibly-compressed representation of text """
        if not text:
            return ("", text)
        l = len(text)
        bin = None
        if l < 44:
            pass
        elif l > 1000000:
            # zlib makes an internal copy, thus doubling memory usage for
            # large files, so lets do this in pieces
            z = zlib.compressobj()
            p = []
            pos = 0
            while pos < l:
                pos2 = pos + 2**20
                p.append(z.compress(text[pos:pos2]))
                pos = pos2
            p.append(z.flush())
            if sum(map(len, p)) < l:
                bin = "".join(p)
        else:
            bin = _compress(text)
        if bin is None or len(bin) > l:
            if text[0] == '\0':
                return ("", text)
            return ('u', text)
        return ("", bin)

    def _addrevision(self, node, text, transaction, link, p1, p2,
                     cachedelta, ifh, dfh):
        """internal function to add revisions to the log

        see addrevision for argument descriptions.
        invariants:
        - text is optional (can be None); if not set, cachedelta must be set.
          if both are set, they must correspond to each other.
        """
        btext = [text]
        def buildtext():
            if btext[0] is not None:
                return btext[0]
            # flush any pending writes here so we can read it in revision
            if dfh:
                dfh.flush()
            ifh.flush()
            basetext = self.revision(self.node(cachedelta[0]))
            btext[0] = mdiff.patch(basetext, cachedelta[1])
            self.checkhash(btext[0], p1, p2, node)
            return btext[0]

        def builddelta(rev):
            # can we use the cached delta?
            if cachedelta and cachedelta[0] == rev:
                delta = cachedelta[1]
            else:
                t = buildtext()
                ptext = self.revision(self.node(rev))
                delta = mdiff.textdiff(ptext, t)
            data = self.compress(delta)
            l = len(data[1]) + len(data[0])
            if basecache[0] == rev:
                chainbase = basecache[1]
            else:
                chainbase = self.chainbase(rev)
            dist = l + offset - self.start(chainbase)
            if self._generaldelta:
                base = rev
            else:
                base = chainbase
            return dist, l, data, base, chainbase

        curr = len(self)
        prev = curr - 1
        base = chainbase = curr
        offset = self.end(prev)
        flags = 0
        d = None
        if self._basecache is None:
            self._basecache = (prev, self.chainbase(prev))
        basecache = self._basecache
        p1r, p2r = self.rev(p1), self.rev(p2)

        # should we try to build a delta?
        if prev != nullrev:
            if self._generaldelta:
                if p1r >= basecache[1]:
                    d = builddelta(p1r)
                elif p2r >= basecache[1]:
                    d = builddelta(p2r)
                else:
                    d = builddelta(prev)
            else:
                d = builddelta(prev)
            dist, l, data, base, chainbase = d

        # full versions are inserted when the needed deltas
        # become comparable to the uncompressed text
        if text is None:
            textlen = mdiff.patchedsize(self.rawsize(cachedelta[0]),
                                        cachedelta[1])
        else:
            textlen = len(text)
        if d is None or dist > textlen * 2:
            text = buildtext()
            data = self.compress(text)
            l = len(data[1]) + len(data[0])
            base = chainbase = curr

        e = (offset_type(offset, flags), l, textlen,
             base, link, p1r, p2r, node)
        self.index.insert(-1, e)
        self.nodemap[node] = curr

        entry = self._io.packentry(e, self.node, self.version, curr)
        self._writeentry(transaction, ifh, dfh, entry, data, link, offset)

        if type(text) == str: # only accept immutable objects
            self._cache = (node, curr, text)
        self._basecache = (curr, chainbase)
        return node

    def _writeentry(self, transaction, ifh, dfh, entry, data, link, offset):
        curr = len(self) - 1
        if not self._inline:
            transaction.add(self.datafile, offset)
            transaction.add(self.indexfile, curr * len(entry))
            if data[0]:
                dfh.write(data[0])
            dfh.write(data[1])
            dfh.flush()
            ifh.write(entry)
        else:
            offset += curr * self._io.size
            transaction.add(self.indexfile, offset, curr)
            ifh.write(entry)
            ifh.write(data[0])
            ifh.write(data[1])
            self.checkinlinesize(transaction, ifh)

    def addgroup(self, bundle, linkmapper, transaction):
        """
        add a delta group

        given a set of deltas, add them to the revision log. the
        first delta is against its parent, which should be in our
        log, the rest are against the previous delta.
        """

        # track the base of the current delta log
        content = []
        node = None

        r = len(self)
        end = 0
        if r:
            end = self.end(r - 1)
        ifh = self.opener(self.indexfile, "a+")
        isize = r * self._io.size
        if self._inline:
            transaction.add(self.indexfile, end + isize, r)
            dfh = None
        else:
            transaction.add(self.indexfile, isize, r)
            transaction.add(self.datafile, end)
            dfh = self.opener(self.datafile, "a")

        try:
            # loop through our set of deltas
            chain = None
            while True:
                chunkdata = bundle.deltachunk(chain)
                if not chunkdata:
                    break
                node = chunkdata['node']
                p1 = chunkdata['p1']
                p2 = chunkdata['p2']
                cs = chunkdata['cs']
                deltabase = chunkdata['deltabase']
                delta = chunkdata['delta']

                content.append(node)

                link = linkmapper(cs)
                if node in self.nodemap:
                    # this can happen if two branches make the same change
                    chain = node
                    continue

                for p in (p1, p2):
                    if p not in self.nodemap:
                        raise LookupError(p, self.indexfile,
                                          _('unknown parent'))

                if deltabase not in self.nodemap:
                    raise LookupError(deltabase, self.indexfile,
                                      _('unknown delta base'))

                baserev = self.rev(deltabase)
                chain = self._addrevision(node, None, transaction, link,
                                          p1, p2, (baserev, delta), ifh, dfh)
                if not dfh and not self._inline:
                    # addrevision switched from inline to conventional
                    # reopen the index
                    ifh.close()
                    dfh = self.opener(self.datafile, "a")
                    ifh = self.opener(self.indexfile, "a")
        finally:
            if dfh:
                dfh.close()
            ifh.close()

        return content

    def getstrippoint(self, minlink):
        """find the minimum rev that must be stripped to strip the linkrev

        Returns a tuple containing the minimum rev and a set of all revs that
        have linkrevs that will be broken by this strip.
        """
        brokenrevs = set()
        strippoint = len(self)

        heads = {}
        futurelargelinkrevs = set()
        for head in self.headrevs():
            headlinkrev = self.linkrev(head)
            heads[head] = headlinkrev
            if headlinkrev >= minlink:
                futurelargelinkrevs.add(headlinkrev)

        # This algorithm involves walking down the rev graph, starting at the
        # heads. Since the revs are topologically sorted according to linkrev,
        # once all head linkrevs are below the minlink, we know there are
        # no more revs that could have a linkrev greater than minlink.
        # So we can stop walking.
        while futurelargelinkrevs:
            strippoint -= 1
            linkrev = heads.pop(strippoint)

            if linkrev < minlink:
                brokenrevs.add(strippoint)
            else:
                futurelargelinkrevs.remove(linkrev)

            for p in self.parentrevs(strippoint):
                if p != nullrev:
                    plinkrev = self.linkrev(p)
                    heads[p] = plinkrev
                    if plinkrev >= minlink:
                        futurelargelinkrevs.add(plinkrev)

        return strippoint, brokenrevs

    def strip(self, minlink, transaction):
        """truncate the revlog on the first revision with a linkrev >= minlink

        This function is called when we're stripping revision minlink and
        its descendants from the repository.

        We have to remove all revisions with linkrev >= minlink, because
        the equivalent changelog revisions will be renumbered after the
        strip.

        So we truncate the revlog on the first of these revisions, and
        trust that the caller has saved the revisions that shouldn't be
        removed and that it'll re-add them after this truncation.
        """
        if len(self) == 0:
            return

        rev, _ = self.getstrippoint(minlink)
        if rev == len(self):
            return

        # first truncate the files on disk
        end = self.start(rev)
        if not self._inline:
            transaction.add(self.datafile, end)
            end = rev * self._io.size
        else:
            end += rev * self._io.size

        transaction.add(self.indexfile, end)

        # then reset internal state in memory to forget those revisions
        self._cache = None
        self._chunkclear()
        for x in xrange(rev, len(self)):
            del self.nodemap[self.node(x)]

        del self.index[rev:-1]

    def checksize(self):
        expected = 0
        if len(self):
            expected = max(0, self.end(len(self) - 1))

        try:
            f = self.opener(self.datafile)
            f.seek(0, 2)
            actual = f.tell()
            f.close()
            dd = actual - expected
        except IOError, inst:
            if inst.errno != errno.ENOENT:
                raise
            dd = 0

        try:
            f = self.opener(self.indexfile)
            f.seek(0, 2)
            actual = f.tell()
            f.close()
            s = self._io.size
            i = max(0, actual // s)
            di = actual - (i * s)
            if self._inline:
                databytes = 0
                for r in self:
                    databytes += max(0, self.length(r))
                dd = 0
                di = actual - len(self) * s - databytes
        except IOError, inst:
            if inst.errno != errno.ENOENT:
                raise
            di = 0

        return (dd, di)

    def files(self):
        res = [self.indexfile]
        if not self._inline:
            res.append(self.datafile)
        return res
                                                                                                                                                                                                       usr/lib/python2.7/dist-packages/mercurial/revlog.pyc                                                0100644 0000000 0000000 00000123421 13077704337 021127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sÊ  d  Z  d d l m Z m Z m Z m Z d d l m Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z e j Z e j Z e j Z e j Z e j Z d Z d Z d Z d Z e Z e Z  e  e BZ! e e BZ" d Z# d	 Z$ d
 Z% e j& Z& e j' Z' d „  Z( d „  Z) d „  Z* e e ƒ Z+ d „  Z, d „  Z d Z- d Z. d e/ f d „  ƒ  YZ0 d Z1 d Z2 d Z3 d e/ f d „  ƒ  YZ4 d e/ f d „  ƒ  YZ5 d S(   sŒ   Storage back-end for Mercurial.

This provides efficient delta storage with O(1) retrieve and append
and O(changes) merge between branches.
iÿÿÿÿ(   t   bint   hext   nullidt   nullrev(   t   _Ni    i   i   i   i   i   c         C   s   t  |  d ?ƒ S(   Ni   (   t   int(   t   q(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   getoffset.   s    c         C   s   t  |  d @ƒ S(   Niÿÿ  (   R   (   R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   gettype1   s    c         C   s   t  t  |  ƒ d >| Bƒ S(   Ni   (   t   long(   t   offsett   type(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   offset_type4   s    c         C   sv   | t  k r( t j ƒ  } | j | ƒ n7 | | g } | j ƒ  t | d ƒ } | j | d ƒ | j |  ƒ | j ƒ  S(   sî   generate a hash from the given text and its parent hashes

    This hash combines both the current file contents and its history
    in a manner that makes it easy to distinguish nodes with the same
    content in the revision graph.
    i    i   (   R   t   nullhasht   copyt   updatet   sortt   _shat   digest(   t   textt   p1t   p2t   st   l(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   hash9   s    
c         C   s¤   |  s
 |  S|  d } | d k r$ |  S| d k rv y t  |  ƒ SWqv t j k
 rr } t t d ƒ t | ƒ ƒ ‚ qv Xn  | d k rŠ |  d St t d ƒ | ƒ ‚ d S(	   s    decompress the given input i    t    t   xs   revlog decompress error: %st   ui   s   unknown compression type %rN(   t   _decompresst   zlibt   errort   RevlogErrorR   t   str(   R    t   tt   e(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt
   decompressN   s    
#s   >4l20s20s20si8   t   revlogoldioc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         C   s   t  j t ƒ |  _ d  S(   N(   t   structt   calcsizet   indexformatv0t   size(   t   self(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   __init__j   s    c      	   C   s%  |  j  } g  } i t t 6} d } } t | ƒ } x¾ | | | k rò | | | | !}	 | | 7} t t |	 ƒ }
 t |
 d d ƒ |
 d d |
 d |
 d | j |
 d t ƒ | j |
 d t ƒ |
 d f } | j | ƒ | | |
 d <| d 7} q5 W| j d d d d d d d t f ƒ | | d  f S(	   Ni    i   iÿÿÿÿi   i   i   i   i   (
   R(   R   R   t   lent   _unpackR'   R   t   gett   appendt   None(   R)   t   datat   inlineR   t   indext   nodemapt   nt   offR   t   curR"   t   e2(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt
   parseindexm   s     	

(3%c         C   s{   t  | d ƒ r% t t d ƒ ƒ ‚ n  t | d ƒ | d | d | d | | d ƒ | | d ƒ | d f } t t | Œ S(	   Ni    s   index entry flags need RevlogNGi   i   i   i   i   i   (   R   R   R   R   t   _packR'   (   R)   t   entryt   nodet   versiont   revR7   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   packentryƒ   s
    "'(   t   __name__t
   __module__R*   R8   R>   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR$   i   s   		s   >Qiiiiii20s12xi    s   >It   revlogioc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         C   s   t  j t ƒ |  _ d  S(   N(   R%   R&   t   indexformatngR(   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR*   ™   s    c         C   s1   t  j | | ƒ \ } } | t | d d  ƒ | f S(   NR3   (   t   parserst   parse_index2t   getattrR/   (   R)   R0   R1   R2   t   cache(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR8   œ   s    c         C   s9   t  t | Œ } | d k r5 t  t | ƒ | d } n  | S(   Ni    i   (   R9   RB   t   versionformat(   R)   R:   R;   R<   R=   t   p(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR>   ¡   s    (   R?   R@   R*   R8   R>   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRA   ˜   s   		t   revlogc           B   s]  e  Z d  Z d „  Z d „  Z d „  Z d „  Z d d< d „ Z e	 j
 d „  ƒ Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z e Z d e d „ Z d „  Z d< d< d „ Z d< d< d „ Z d< d< d „ Z d< d< d „ Z  d „  Z! d „  Z" d< d< d „ Z# d „  Z$ d „  Z% d  „  Z& d! „  Z' d" „  Z( d# „  Z) d$ „  Z* d% „  Z+ d& „  Z, d' „  Z- d( „  Z. d) „  Z/ d* „  Z0 d+ „  Z1 d, „  Z2 d- „  Z3 d. „  Z4 d/ „  Z5 d0 „  Z6 d< d1 „ Z7 d< d2 „ Z8 d< d< d3 „ Z9 d4 „  Z: d5 „  Z; d6 „  Z< d7 „  Z= d8 „  Z> d9 „  Z? d: „  Z@ d; „  ZA RS(=   sM  
    the underlying revision storage object

    A revlog consists of two parts, an index and the revision data.

    The index is a file with a fixed record size containing
    information on each revision, including its nodeid (hash), the
    nodeids of its parents, the position and offset of its data within
    the data file, and the revision it's based on. Finally, each entry
    contains a linkrev entry that can serve as a pointer to external
    data.

    The revision data itself is a linear collection of data chunks.
    Each chunk represents a revision and is usually represented as a
    delta against the previous chunk. To bound lookup time, runs of
    deltas are limited to about 2 times the length of the original
    version data. This makes retrieval of a version proportional to
    its size, or O(1) relative to the number of revisions.

    Both pieces of the revlog are written to in an append-only
    fashion, which means we never need to rewrite a file to insert or
    remove data, and can use some simple techniques to avoid the need
    for locking while reading.
    c         C   s€  | |  _  | d  d |  _ | |  _ d |  _ d |  _ d |  _ d |  _ g  |  _ i  |  _	 i t
 t 6|  _ d |  _ t } t | d d ƒ } | d k	 rã d | k r¾ d | k rÄ | t O} qÄ n d } d	 | k rã | d	 |  _ qã n  |  j d k rt t d
 ƒ |  j ƒ ‚ n0 |  j |  j d @r>t t d ƒ |  j ƒ ‚ n  d } t |  _ yd |  j |  j  ƒ } | j ƒ  } | j ƒ  t | ƒ d k r°t j t | d  ƒ d } t |  _ n  Wn+ t k
 rÞ} | j t j k rß‚  qßn X| |  _ | t  @|  _! | t @|  _" | d @} | d @}	 |	 t# k rN| rNt t d ƒ |  j  | d ?f ƒ ‚ nk |	 t$ k r‹| t% @r‹t t d ƒ |  j  | d ?f ƒ ‚ n. |	 t$ k r¹t t d ƒ |  j  |	 f ƒ ‚ n  t& ƒ  |  _' |  j t# k rãt( ƒ  |  _' n  y |  j' j) | |  j! ƒ }
 Wn0 t* t+ f k
 r1t t d ƒ |  j  ƒ ‚ n X|
 \ |  _ } |  _ | d k	 rf| |  _, |  _ n  |  j s||  j- ƒ  n  d S(   s°   
        create a revlog object

        opener is a function that abstracts the file opening operation
        and can be used to implement COW semantics or the like.
        iþÿÿÿs   .di    t    i   t   optionst   revlogv1t   generaldeltat   chunkcachesizes0   revlog chunk cache size %r is not greater than 0i   s.   revlog chunk cache size %r is not a power of 2i   iÿÿ  s*   index %s unknown flags %#04x for format v0i   s)   index %s unknown flags %#04x for revlogngs   index %s unknown format %ds   index %s is corruptedN(   i    RJ   i  ÿÿ(.   t	   indexfilet   datafilet   openerR/   t   _cachet
   _basecachet   _chunkcachet   _chunkcachesizeR2   t   _pcacheR   R   t
   _nodecachet   _nodepost   REVLOG_DEFAULT_VERSIONRE   t   REVLOGGENERALDELTAR   R   t   Truet
   _initemptyt   readt   closeR+   R%   t   unpackRG   t   Falset   IOErrort   errnot   ENOENTR<   t   REVLOGNGINLINEDATAt   _inlinet   _generaldeltat   REVLOGV0t   REVLOGNGt   REVLOGNG_FLAGSRA   t   _ioR$   R8   t
   ValueErrort
   IndexErrorR3   t   _chunkclear(   R)   RQ   RO   t   vt   optst   it   ft   instt   flagst   fmtt   dR3   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR*   À   s€    										

	

	c         C   s   |  j  t |  j ƒ d ƒ S(   Ni   (   R;   R+   R2   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   tip  s    c         C   s   t  |  j ƒ d S(   Ni   (   R+   R2   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   __len__  s    c         C   s   t  t t |  ƒ ƒ ƒ S(   N(   t   itert   xrangeR+   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   __iter__  s    i    c         C   sP   d } | d k	 r4 | | k r' d } n  | | 7} n t |  ƒ } t | | | ƒ S(   s8   iterate over all rev in this revlog (from start to stop)i   iÿÿÿÿN(   R/   R+   Ry   (   R)   t   startt   stopt   step(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   revs  s    	c         C   s   |  j  |  j d ƒ ƒ |  j S(   Ni    (   R=   R;   RW   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR3     s    c         C   s.   y |  j  | ƒ t SWn t k
 r) t SXd  S(   N(   R=   R[   t   KeyErrorR`   (   R)   R;   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   hasnode$  s
    c         C   sB   y |  j  j ƒ  Wn* t k
 r= i t t 6|  _  d  |  _ n Xd  S(   N(   RW   t   clearcachest   AttributeErrorR   R   R/   RX   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR   +  s
    c         C   sù   y |  j  | SWnã t k
 r= t | |  j t d ƒ ƒ ‚ n¸ t k
 rô |  j  } |  j } |  j } | d  k r„ t	 | ƒ d } n  xO t
 | d d ƒ D]; } | | d } | | | <| | k r— | d |  _ | Sq— Wt | |  j t d ƒ ƒ ‚ n Xd  S(   Ns   no nodei   iÿÿÿÿi   i   (   RW   R   t   LookupErrorRO   R   R   R2   RX   R/   R+   Ry   (   R)   R;   R4   Rp   RH   t   rRn   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR=   2  s"    			
c         C   s   |  j  | d S(   Ni   (   R2   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR;   G  s    c         C   s   |  j  | d S(   Ni   (   R2   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   linkrevI  s    c         C   s>   |  j  } | |  j | ƒ } | | d d | | d d f S(   Ni   i   i   (   R2   R=   (   R)   R;   Rp   Ru   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   parentsK  s    	c         C   s   |  j  | d d !S(   Ni   i   (   R2   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt
   parentrevsO  s    c         C   s   t  |  j | d d ?ƒ S(   Ni    i   (   R   R2   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR{   Q  s    c         C   s   |  j  | ƒ |  j | ƒ S(   N(   R{   t   length(   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   endS  s    c         C   s   |  j  | d S(   Ni   (   R2   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRˆ   U  s    c         C   sB   |  j  } | | d } x$ | | k r= | } | | d } q W| S(   Ni   (   R2   (   R)   R=   R2   t   base(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   chainbaseW  s    	c         C   s   |  j  | d d @S(   Ni    iÿÿ  (   R2   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRs   ^  s    c         C   sC   |  j  | d } | d k r! | S|  j |  j | ƒ ƒ } t | ƒ S(   s?   return the length of the uncompressed text for a given revisioni   i    (   R2   t   revisionR;   R+   (   R)   R=   R   R!   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   rawsize`  s
    c         C   s   t  j |  | d | d | ƒS(   s½   Generate the ancestors of 'revs' in reverse topological order.
        Does not generate revs lower than stoprev.

        See the documentation for ancestor.lazyancestors for more details.t   stoprevt	   inclusive(   t   ancestort   lazyancestors(   R)   R~   RŽ   R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   ancestorsj  s    c         c   s«   t  | ƒ } | t k r2 x |  D] } | Vq Wd St | ƒ } xf |  j d | d ƒ D]N } xE |  j | ƒ D]4 } | t k rk | | k rk | j | ƒ | VPqk qk WqU Wd S(   s$  Generate the descendants of 'revs' in revision order.

        Yield a sequence of revision numbers starting with a child of
        some rev in revs, i.e., each revision is *not* considered a
        descendant of itself.  Results are ordered by revision number (a
        topological sort).NR{   i   (   t   minR   t   setR~   R‡   t   add(   R)   R~   t   firstRp   t   seenR   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   descendantss  s    	c   	         sŽ  | d k r t g } n  | d k r3 |  j ƒ  } n  g  | D] } |  j | ƒ ^ q: } g  | D] } |  j | ƒ ^ q\ } d t f d „  ƒ  Y} | |  j | ƒ ƒ ‰  ˆ  j t ƒ ˆ  j | ƒ t	 ƒ  } t
 j ‡  f d †  | Dƒ ƒ } xk | rQ| j ƒ  } | | k rqç qç | j | ƒ x3 |  j | ƒ D]" } | ˆ  k r(| j | ƒ q(q(Wqç Wt | ƒ } | j ƒ  ˆ  g  | D] } |  j | ƒ ^ qrf S(   sØ  Return a tuple of the ancestors of common and the ancestors of heads
        that are not ancestors of common. In revset terminology, we return the
        tuple:

          ::common, (::heads) - (::common)

        The list is sorted by revision number, meaning it is
        topologically sorted.

        'heads' and 'common' are both lists of node IDs.  If heads is
        not supplied, uses all of the revlog's heads.  If common is not
        supplied, uses nullid.t   lazysetc           B   s5   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z RS(   c         S   s   t  ƒ  |  _ | |  _ d  S(   N(   R”   t   addedvaluest
   lazyvalues(   R)   R›   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR*   Ÿ  s    c         S   s   | |  j  k p | |  j k S(   N(   Rš   R›   (   R)   t   value(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   __contains__£  s    c         s   sK   |  j  } x | D] } | Vq Wx% |  j D] } | | k r) | Vq) q) Wd  S(   N(   Rš   R›   (   R)   t   addedR„   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRz   ¦  s    		c         S   s   |  j  j | ƒ d  S(   N(   Rš   R•   (   R)   Rœ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR•   ®  s    c         S   s   |  j  j | ƒ d  S(   N(   Rš   R   (   R)   t   values(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR   ±  s    (   R?   R@   R*   R   Rz   R•   R   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR™   ž  s
   				c         3   s!   |  ] } | ˆ  k r | Vq d  S(   N(    (   t   .0R„   (   t   has(    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pys	   <genexpr>º  s    N(   R/   R   t   headsR=   t   objectR’   R•   R   R   R”   t   utilt   dequet   popleftR‡   R.   t   listR   R;   (	   R)   t   commonR¢   R4   R™   t   missingt   visitR„   RH   (    (   R¡   s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   findcommonmissingˆ  s.    ""		
c         C   sI   | d k r t g } n  | d k r3 |  j ƒ  } n  t j | | |  j ƒ S(   sx  Return the revision numbers of the ancestors of heads that
        are not ancestors of common.

        More specifically, return a list of revision numbers corresponding to
        nodes N such that every N satisfies the following constraints:

          1. N is an ancestor of some node in 'heads'
          2. N is not an ancestor of any node in 'common'

        The list is sorted by revision number, meaning it is
        topologically sorted.

        'heads' and 'common' are both lists of revision numbers.  If heads is
        not supplied, uses all of the revlog's heads.  If common is not
        supplied, uses nullid.N(   R/   R   t   headrevsR   t   missingancestorsR‡   (   R)   R¨   R¢   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   findmissingrevsÈ  s
    c         C   s©   | d k r t g } n  | d k r3 |  j ƒ  } n  g  | D] } |  j | ƒ ^ q: } g  | D] } |  j | ƒ ^ q\ } g  t j | | |  j ƒ D] } |  j | ƒ ^ q S(   s.  Return the ancestors of heads that are not ancestors of common.

        More specifically, return a list of nodes N such that every N
        satisfies the following constraints:

          1. N is an ancestor of some node in 'heads'
          2. N is not an ancestor of any node in 'common'

        The list is sorted by revision number, meaning it is
        topologically sorted.

        'heads' and 'common' are both lists of node IDs.  If heads is
        not supplied, uses all of the revlog's heads.  If common is not
        supplied, uses nullid.N(   R/   R   R¢   R=   R   R­   R‡   R;   (   R)   R¨   R¢   R4   R„   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   findmissingß  s    ""c         C   s­  g  g  g  f } | d k	 r\ t | ƒ } | s1 | St g  | D] } |  j | ƒ ^ q; ƒ } n t g } t } | t k r» | d k r» g  |  D] } |  j | ƒ ^ qŠ t g t |  j ƒ  ƒ f S| d k ræ t |  ƒ d } d } i  } nt | ƒ } | sü | St	 ƒ  } t
 j | t ƒ } t	 | ƒ }	 t g  |	 D] } |  j | ƒ ^ q-ƒ } x³ |	 r |	 j ƒ  } | t k rrqNn  |  j | ƒ } | | k rN| | k rÞ| j | ƒ |	 j g  |  j | ƒ D] }
 |
 t k r¼|
 ^ q¼ƒ qý| | k rý| j | ƒ qýqNqNW| s| S| t k rtg  | D] } | | k r| ^ q} | rmt g  | D] } |  j | ƒ ^ qLƒ } qƒ| Sn t } t g } t	 | ƒ } | j ƒ  } g  } x¡|  j d t | d ƒ d | d ƒ D]z} |  j | ƒ } t } | t k r÷t } n´ | | k r`t } | | k r«t |  j | ƒ ƒ }
 |
 d | k sJ|
 d | k r]| j | ƒ q]q«nK t |  j | ƒ ƒ }
 |
 d | k s•|
 d | k r«| j | ƒ t } n  | rÇ| d k sÉ| | k rÇ| j | ƒ | d k	 rû| | k rût | | <qA| d k rAt | | <x* |  j | ƒ D] }
 | j |
 d ƒ q!WqAqÇqÇWg  | j ƒ  D] \ } } | rR| ^ qR} t | ƒ } | sˆt ‚ | s”t ‚ | s t ‚ | | | f S(   s  Return a topological path from 'roots' to 'heads'.

        Return a tuple (nodes, outroots, outheads) where 'nodes' is a
        topologically sorted list of all nodes N that satisfy both of
        these constraints:

          1. N is a descendant of some node in 'roots'
          2. N is an ancestor of some node in 'heads'

        Every node is considered to be both a descendant and an ancestor
        of itself, so every reachable node in 'roots' and 'heads' will be
        included in 'nodes'.

        'outroots' is the list of reachable nodes in 'roots', i.e., the
        subset of 'roots' that is returned in 'nodes'.  Likewise,
        'outheads' is the subset of 'heads' that is also in 'nodes'.

        'roots' and 'heads' are both lists of node IDs.  If 'roots' is
        unspecified, uses nullid as the only root.  If 'heads' is
        unspecified, uses list of all of the revlog's heads.i   R{   i    R|   N(   R/   R§   R“   R=   R   R   R;   R¢   R+   R”   t   dictt   fromkeysR`   t   maxt   popR•   R   R†   R   R~   R[   t   tuplet   removeR.   t	   iteritemst   AssertionError(   R)   t   rootsR¢   t   nonodesR4   t	   lowestrevR„   t
   highestrevR’   t
   nodestotagRH   R˜   t
   orderedoutt   isdescendantt   flag(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   nodesbetweenù  s”    +	8		(	%+	,	  	
+c         C   s0   y |  j  j ƒ  SWn t k
 r+ |  j ƒ  SXd  S(   N(   R2   R¬   R‚   t	   _headrevs(   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR¬   ”  s    c         C   s›   t  |  ƒ } | s t g Sd g | d } |  j } x< |  D]4 } d | | <| | } d | | d <| | d <q: Wg  t | ƒ D] \ } } | r | ^ q S(   Ni    i   i   i   (   R+   R   R2   t	   enumerate(   R)   t   countt   isheadR2   R„   R"   t   val(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRÁ   š  s    	

c         C   s‘  | d k rQ | d k rQ t |  ƒ s+ t g Sg  |  j ƒ  D] } |  j | ƒ ^ q8 S| d k rf t } n  | d k r{ g  } n  t g  | D] } |  j | ƒ ^ q… ƒ } |  j | ƒ } t | f ƒ } t | f ƒ } |  j }	 x• |  j d | d ƒ D]} } xt |	 | ƒ D]f }
 |
 | k rA| | k r1| j	 | ƒ n  | j	 | ƒ n  |
 | k r|
 | k r| j
 |
 ƒ qqWqð Wg  | D] } |  j | ƒ ^ qxS(   s  return the list of all nodes that have no children

        if start is specified, only heads that are descendants of
        start will be returned
        if stop is specified, it will consider all the revs from stop
        as if they had no children
        R{   i   N(   R/   R+   R   R¬   R;   R”   R=   R‡   R~   R•   Rµ   (   R)   R{   R|   R„   R4   t   stoprevst   startrevt	   reachableR¢   R‡   RH   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR¢   §  s,    &		(	c         C   sÌ   g  } |  j  | ƒ } x° |  j d | d ƒ D]˜ } g  |  j | ƒ D] } | t k rB | ^ qB } | rŸ x[ | D]+ } | | k rm | j |  j | ƒ ƒ qm qm Wq, | t k r, | j |  j | ƒ ƒ q, q, W| S(   s!   find the children of a given nodeR{   i   (   R=   R~   R‡   R   R.   R;   (   R)   R;   t   cRH   R„   t   prt   prevs(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   childrenÉ  s    . c         C   sQ   | t  k r t Sx: |  j | g ƒ D]& } | | k r9 t S| | k r# Pq# q# Wt S(   N(   R   R[   R˜   R`   (   R)   R{   R‰   Rp   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt
   descendant×  s    c         C   sz   |  j  | ƒ |  j  | ƒ } } y |  j j | | ƒ } Wn/ t t f k
 ri t j |  j | | ƒ } n Xt |  j | ƒ S(   s@   calculate all the heads of the common ancestors of nodes a and b(	   R=   R2   t   commonancestorsheadsR‚   t   OverflowErrorR   R‡   t   mapR;   (   R)   t   at   bt   ancs(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRÎ   á  s    c         C   sŠ   |  j  | ƒ |  j  | ƒ } } y |  j j | | ƒ } Wn/ t t f k
 ri t j |  j | | ƒ } n X| r† t t |  j	 | ƒ ƒ St
 S(   s4   calculate the least common ancestor of nodes a and b(   R=   R2   R’   R‚   RÏ   R   R‡   R“   RÐ   R;   R   (   R)   RÑ   RÒ   RÓ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR   ê  s    c         C   sL  t  | t ƒ r |  j | ƒ St | ƒ d k r` y | } |  j | ƒ | SWq` t k
 r\ q` Xn  y~ t | ƒ } t | ƒ | k rŠ t ‚ n  | d k  r© t |  ƒ | } n  | d k  sÇ | t |  ƒ k rÐ t ‚ n  |  j | ƒ SWn t t f k
 r÷ n Xt | ƒ d k rHy! t	 | ƒ } |  j | ƒ | SWqHt
 t f k
 rDqHXn  d  S(   Ni   i    i(   (   t
   isinstanceR   R;   R+   R=   Rƒ   R    Rk   RÏ   R    t	   TypeError(   R)   t   idR;   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   _match÷  s6    		c         C   s›  y3 |  j  j | ƒ } | r. |  j | ƒ r. | Sd  SWn' t k
 rF n t t f k
 r\ n X| |  j k rw |  j | St | ƒ d k  r—y÷ t | ƒ d } t	 | | d  ƒ } g  |  j  D]# } | d j
 | ƒ rº | d ^ qº } g  | D]0 } t | ƒ j
 | ƒ rê |  j | ƒ rê | ^ qê } t | ƒ d k r{t | ƒ d k r]| d |  j | <| d St | |  j t d ƒ ƒ ‚ n  d  SWq—t k
 r“q—Xn  d  S(   Ni(   i   i   i    i   s   ambiguous identifier(   R2   t   partialmatchR€   R/   R   R‚   Rk   RV   R+   R    t
   startswithR   Rƒ   RO   R   RÕ   (   R)   RÖ   R4   R   t   prefixR"   t   nl(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   _partialmatch  s6    3"c         C   sW   |  j  | ƒ } | d k	 r | S|  j | ƒ } | r8 | St | |  j t d ƒ ƒ ‚ d S(   sƒ   locate a node based on:
            - revision number or str(revision number)
            - nodeid or subset of hex nodeid
        s   no match foundN(   R×   R/   RÜ   Rƒ   RO   R   (   R)   RÖ   R4   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   lookup<  s    c         C   s+   |  j  | ƒ \ } } t | | | ƒ | k S(   sp   compare text with a given file revision

        returns True if text is different than what is stored.
        (   R†   R   (   R)   R;   R   R   R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   cmpJ  s    c         C   sj   |  j  \ } } | t | ƒ | k rW t | ƒ t | ƒ t k  rW | | | f |  _  n | | f |  _  d  S(   N(   RT   R+   t
   _chunksize(   R)   R
   R0   t   oRu   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   _addchunkR  s    2c         C   sÌ   |  j  r |  j |  j ƒ } n |  j |  j ƒ } |  j } | | d @} | | | | d @| } | j | ƒ | j | ƒ } | j ƒ  |  j | | ƒ | | k s± | | k rÈ t	 j
 | | | | ƒ S| S(   Ni   (   Re   RQ   RO   RP   RU   t   seekR]   R^   Rá   R¤   t   buffer(   R)   R
   Rˆ   t   dft	   cachesizet
   realoffsett
   reallengthRu   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt
   _loadchunkZ  s    		
c         C   sŠ   |  j  \ } } t | ƒ } | | } | | } | d k rz | | k rz | d k rc | | k rc | St j | | | | ƒ S|  j | | ƒ S(   Ni    (   RT   R+   R¤   Rã   Rè   (   R)   R
   Rˆ   Rà   Ru   R   t
   cachestartt   cacheend(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   _getchunko  s    

c         C   st   |  j  | ƒ } |  j | ƒ } |  j rZ | | d |  j j 7} | | d |  j j 7} n  | | } |  j | | ƒ S(   Ni   (   R{   R‰   Re   Rj   R(   Rë   (   R)   RÇ   t   endrevR{   R‰   Rˆ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   _chunkraw}  s    	
c         C   s   t  |  j | | ƒ ƒ S(   N(   R#   Rí   (   R)   R=   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   _chunk†  s    c         C   s3  | s
 g  S|  j  } |  j } |  j } |  j j } t j } g  } | j } yQ x> t rŒ |  j	 }	 |  j
 | d | d ƒ |	 |  j	 k rO PqO qO W|	 \ }
 } Wn. t k
 rÊ g  | D] } |  j | ƒ ^ q± SXxa | D]Y } | | ƒ } | rÿ | | d | 7} n  | | ƒ } | t | | | |
 | ƒ ƒ ƒ qÒ W| S(   sf   faster version of [self._chunk(rev) for rev in revs]

        Assumes that revs is in ascending order.i    iÿÿÿÿi   (   R{   Rˆ   Re   Rj   R(   R¤   Rã   R.   R[   RT   Rí   RÏ   Rî   R#   (   R)   R~   R{   Rˆ   R1   t   iosizeRã   R   t   laddRR   R
   R0   R=   t
   chunkstartt   chunklength(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   _chunks‰  s2    							!$c         C   s   d |  _  d  S(   Ni    RJ   (   i    RJ   (   RT   (   R)   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRm   ¯  s    c         C   s:   |  j  | d } | | k r! t S|  j r. | S| d Sd S(   s(   return deltaparent of the given revisioni   i   N(   R2   R   Rf   (   R)   R=   RŠ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   deltaparent²  s    	c         C   sV   | t  k r4 |  j | ƒ | k r4 t |  j | ƒ ƒ St j |  j | ƒ |  j | ƒ ƒ S(   s1   return or calculate a delta between two revisions(   R   Rô   R    Rî   t   mdifft   textdiffRŒ   (   R)   t   rev1t   rev2(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   revdiff¼  s    !c         C   s	  t  | t ƒ r' | } |  j | ƒ } n | } d } |  j } d } | t k rR d S| r} | d | k rp | d S| d } n  d } | d k r¡ |  j | ƒ } n  |  j | ƒ t @rÜ t	 t
 d ƒ |  j | ƒ t @ƒ ‚ n  g  } |  j } |  j }	 | }
 | |
 } xT |
 | d k rZ|
 | k rZ| j |
 ƒ |	 rC| d }
 n
 |
 d 8}
 | |
 } qW|
 | k rt| d } n | j |
 ƒ | j ƒ  d |  _ |  j | ƒ } | d k rÌt | d ƒ } | d } n  t j | | ƒ } |  j | | | ƒ } | | | f |  _ | S(   sT   return an uncompressed revision of a given node or revision
        number.
        RJ   i    i   i   s   incompatible revision flag %xi   N(   RÔ   R   R;   R/   RR   R   R=   Rs   t   REVIDX_KNOWN_FLAGSR   R   R2   Rf   R.   t   reverseRó   R    Rõ   t   patchest
   _checkhash(   R)   t	   nodeorrevR=   R;   RR   t	   cachedrevR   t   chainR2   RM   t   iterrevR"   t   bins(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRŒ   Ä  sV    			


	c         C   s2   |  j  | ƒ \ } } |  j | | | | | ƒ | S(   N(   R†   t	   checkhash(   R)   R   R;   R=   R   R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRý     s    c         C   sh   | t  | | | ƒ k rd | } | d  k rB t j t | ƒ ƒ } n  t t d ƒ |  j | f ƒ ‚ n  d  S(   Ns   integrity check failed on %s:%s(   R   R/   t   templatefilterst   shortR   R   R   RO   (   R)   R   R   R   R;   R=   t	   revornode(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR    s    c   
      C   s³  |  j  s, |  j d ƒ |  j d ƒ t k  r0 d  S| j |  j ƒ } | d  k rj t t d ƒ |  j ƒ ‚ n  | d } |  j | ƒ } | j	 |  j
 | ƒ | r³ | j ƒ  | j ƒ  n  |  j |  j
 d ƒ } z. x' |  D] } | j |  j | | ƒ ƒ qÒ WWd  | j ƒ  X|  j |  j d d t ƒ} |  j t M_ t |  _  xC |  D]; } |  j j |  j | |  j |  j | ƒ }	 | j |	 ƒ q?W| j ƒ  | j |  j | |  j j ƒ |  j ƒ  d  S(   Niþÿÿÿs   %s not found in the transactioni   t   wt
   atomictemp(   Re   R{   Rˆ   t
   _maxinlinet   findRO   R/   R   R   R•   RP   t   flushR^   RQ   t   writeRí   R[   R<   Rd   R`   Rj   R>   R2   R;   t   replaceR(   Rm   (
   R)   t   trt   fpt   trinfot   trindext   dataoffRä   R„   Rp   R"   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   checkinlinesize  s4    ,

!	(
c   
   
   C   sÝ   | t  k r( t t d ƒ |  j ƒ ‚ n  | p= t | | | ƒ } | |  j k rS | Sd } |  j sz |  j |  j	 d ƒ } n  |  j |  j d ƒ }	 z) |  j
 | | | | | | | |	 | ƒ	 SWd | rÎ | j ƒ  n  |	 j ƒ  Xd S(   s  add a revision to the log

        text - the revision data to add
        transaction - the transaction object used for rollback
        link - the linkrev data to add
        p1, p2 - the parent nodeids of the revision
        cachedelta - an optional precomputed delta
        node - nodeid of revision; typically node is not specified, and it is
            computed by default as hash(text, p1, p2), however subclasses might
            use different hashing method (and override checkhash() in such case)
        s!   attempted to add linkrev -1 to %sRÑ   s   a+N(   R   R   R   RO   R   R3   R/   Re   RQ   RP   t   _addrevisionR^   (
   R)   R   t   transactiont   linkR   R   t
   cachedeltaR;   t   dfht   ifh(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   addrevision:  s     	c         C   s0  | s d | f St  | ƒ } d	 } | d k  r1 n³ | d k rØ t j ƒ  } g  } d } x= | | k  r” | d
 } | j | j | | | !ƒ ƒ | } qX W| j | j ƒ  ƒ t t t  | ƒ ƒ | k  rä d j	 | ƒ } qä n t
 | ƒ } | d	 k st  | ƒ | k r&| d d k rd | f Sd | f Sd | f S(   s7    generate a possibly-compressed representation of text RJ   i,   i@B i    i   i   R   R   Ni   (   R+   R/   R   t   compressobjR.   t   compressR  t   sumRÐ   t   joint	   _compress(   R)   R   R   R    t   zRH   t   post   pos2(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR  Z  s.    




c
            s¹  | g ‰ ‡ ‡ ‡ ‡ ‡ ‡ ‡	 ‡
 f d †  ‰ ‡  ‡ ‡ ‡ ‡
 f d †  }
 t  ˆ
 ƒ } | d } | } } ˆ
 j | ƒ ‰ d } d } ˆ
 j d k r­ | ˆ
 j | ƒ f ˆ
 _ n  ˆ
 j ‰  ˆ
 j ˆ ƒ ˆ
 j ˆ	 ƒ } } | t k r[ˆ
 j r7| ˆ  d k r	|
 | ƒ } qC| ˆ  d k r(|
 | ƒ } qC|
 | ƒ } n |
 | ƒ } | \ } } } } } n  | d k rt j	 ˆ
 j
 ˆ d ƒ ˆ d ƒ } n t  | ƒ } | d k sµ| | d k røˆ ƒ  } ˆ
 j | ƒ } t  | d ƒ t  | d ƒ } | } } n  t ˆ | ƒ | | | | | | ˆ f } ˆ
 j j d | ƒ | ˆ
 j ˆ <ˆ
 j j | ˆ
 j ˆ
 j | ƒ } ˆ
 j | ˆ ˆ | | | ˆ ƒ t | ƒ t k r¦ˆ | | f ˆ
 _ n  | | f ˆ
 _ ˆ S(   s  internal function to add revisions to the log

        see addrevision for argument descriptions.
        invariants:
        - text is optional (can be None); if not set, cachedelta must be set.
          if both are set, they must correspond to each other.
        c             s   ˆ  d d  k	 r ˆ  d Sˆ r+ ˆ j ƒ  n  ˆ j ƒ  ˆ j ˆ j ˆ d ƒ ƒ }  t j |  ˆ d ƒ ˆ  d <ˆ j ˆ  d ˆ ˆ ˆ ƒ ˆ  d S(   Ni    i   (   R/   R  RŒ   R;   Rõ   t   patchR  (   t   basetext(   t   btextR  R  R  R;   R   R   R)   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   buildtext  s    
c   	         sñ   ˆ r# ˆ d |  k r# ˆ d } n3 ˆ ƒ  } ˆ j  ˆ j |  ƒ ƒ } t j | | ƒ } ˆ j | ƒ } t | d ƒ t | d ƒ } ˆ  d |  k r  ˆ  d } n ˆ j |  ƒ } | ˆ ˆ j | ƒ } ˆ j rØ |  } n | } | | | | | f S(   Ni    i   (	   RŒ   R;   Rõ   Rö   R  R+   R‹   R{   Rf   (	   R=   t   deltaR!   t   ptextR0   R   R‹   t   distRŠ   (   t	   basecacheR&  R  R
   R)   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt
   builddelta  s    			i   i    i   iÿÿÿÿN(   R+   R‰   R/   RS   R‹   R=   R   Rf   Rõ   t   patchedsizeR   R  R   R2   t   insertR3   Rj   R>   R;   R<   t   _writeentryR   R    RR   (   R)   R;   R   R  R  R   R   R  R  R  R+  t   currt   prevRŠ   R‹   Rs   Ru   t   p1rt   p2rR)  R   R0   t   textlenR"   R:   (    (   R*  R%  R&  R  R  R  R;   R
   R   R   R)   s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR  w  sR    		$

			!c   	      C   sÿ   t  |  ƒ d } |  j s’ | j |  j | ƒ | j |  j | t  | ƒ ƒ | d rg | j | d ƒ n  | j | d ƒ | j ƒ  | j | ƒ ni | | |  j j 7} | j |  j | | ƒ | j | ƒ | j | d ƒ | j | d ƒ |  j	 | | ƒ d  S(   Ni   i    (
   R+   Re   R•   RP   RO   R  R  Rj   R(   R  (	   R)   R  R  R  R:   R0   R  R
   R/  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyR.  Ô  s    	

c      
   C   sƒ  g  } d } t |  ƒ } d } | r: |  j | d ƒ } n  |  j |  j d ƒ } | |  j j }	 |  j r‹ | j |  j | |	 | ƒ d }
 n> | j |  j |	 | ƒ | j |  j	 | ƒ |  j |  j	 d ƒ }
 z•d } xˆt
 r\| j | ƒ } | sô Pn  | d } | d } | d } | d } | d	 } | d
 } | j | ƒ | | ƒ } | |  j k rd| } qÕ n  xA | | f D]3 } | |  j k rqt | |  j t d ƒ ƒ ‚ qqqqW| |  j k rÕt | |  j t d ƒ ƒ ‚ n  |  j | ƒ } |  j | d | | | | | | f | |
 ƒ	 } |
 rÕ |  j rÕ | j ƒ  |  j |  j	 d ƒ }
 |  j |  j d ƒ } qÕ qÕ WWd |
 rt|
 j ƒ  n  | j ƒ  X| S(   sÝ   
        add a delta group

        given a set of deltas, add them to the revision log. the
        first delta is against its parent, which should be in our
        log, the rest are against the previous delta.
        i    i   s   a+RÑ   R;   R   R   t   cst	   deltabaseR'  s   unknown parents   unknown delta baseN(   R/   R+   R‰   RQ   RO   Rj   R(   Re   R•   RP   R[   t
   deltachunkR.   R3   Rƒ   R   R=   R  R^   (   R)   t   bundlet
   linkmapperR  t   contentR;   R„   R‰   R  t   isizeR  R   t	   chunkdataR   R   R4  R5  R'  R  RH   t   baserev(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   addgroupæ  sb    
			






 c         C   s'  t  ƒ  } t |  ƒ } i  } t  ƒ  } xI |  j ƒ  D]; } |  j | ƒ } | | | <| | k r1 | j | ƒ q1 q1 Wxª | r| d 8} | j | ƒ } | | k  r® | j | ƒ n | j | ƒ x[ |  j | ƒ D]J }	 |	 t k rË |  j |	 ƒ }
 |
 | |	 <|
 | k r| j |
 ƒ qqË qË Wqs W| | f S(   sÐ   find the minimum rev that must be stripped to strip the linkrev

        Returns a tuple containing the minimum rev and a set of all revs that
        have linkrevs that will be broken by this strip.
        i   (	   R”   R+   R¬   R…   R•   R³   Rµ   R‡   R   (   R)   t   minlinkt
   brokenrevst
   strippointR¢   t   futurelargelinkrevst   headt   headlinkrevR…   RH   t   plinkrev(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   getstrippoint0  s,    		
	

c         C   sý   t  |  ƒ d k r d S|  j | ƒ \ } } | t  |  ƒ k rA d S|  j | ƒ } |  j s | j |  j | ƒ | |  j j } n | | |  j j 7} | j |  j | ƒ d |  _
 |  j ƒ  x0 t | t  |  ƒ ƒ D] } |  j |  j | ƒ =qÏ W|  j | d 5d S(   s7  truncate the revlog on the first revision with a linkrev >= minlink

        This function is called when we're stripping revision minlink and
        its descendants from the repository.

        We have to remove all revisions with linkrev >= minlink, because
        the equivalent changelog revisions will be renumbered after the
        strip.

        So we truncate the revlog on the first of these revisions, and
        trust that the caller has saved the revisions that shouldn't be
        removed and that it'll re-add them after this truncation.
        i    Niÿÿÿÿ(   R+   RE  R{   Re   R•   RP   Rj   R(   RO   R/   RR   Rm   Ry   R3   R;   R2   (   R)   R>  R  R=   R   R‰   R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   stripX  s     		
c         C   sµ  d } t  |  ƒ r7 t d |  j t  |  ƒ d ƒ ƒ } n  yF |  j |  j ƒ } | j d d ƒ | j ƒ  } | j ƒ  | | } Wn1 t k
 r° } | j	 t	 j
 k r§ ‚  n  d } n XyÆ |  j |  j ƒ } | j d d ƒ | j ƒ  } | j ƒ  |  j j } t d | | ƒ } | | | } |  j rvd }	 x* |  D]" }
 |	 t d |  j |
 ƒ ƒ 7}	 q/Wd } | t  |  ƒ | |	 } n  Wn1 t k
 rª} | j	 t	 j
 k r¡‚  n  d } n X| | f S(   Ni    i   i   (   R+   R²   R‰   RQ   RP   Râ   t   tellR^   Ra   Rb   Rc   RO   Rj   R(   Re   Rˆ   (   R)   t   expectedRq   t   actualt   ddRr   R   Rp   t   dit	   databytesR„   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt	   checksize  s@    %


	 
c         C   s,   |  j  g } |  j s( | j |  j ƒ n  | S(   N(   RO   Re   R.   RP   (   R)   t   res(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   files¤  s    	N(B   R?   R@   t   __doc__R*   Rv   Rw   Rz   R/   R~   R¤   t   propertycacheR3   R€   R   R=   R;   R…   R†   R‡   R{   R‰   Rˆ   R‹   Rs   R   R(   R`   R’   R˜   R«   R®   R¯   RÀ   R¬   RÁ   R¢   RÌ   RÍ   RÎ   R   R×   RÜ   RÝ   RÞ   Rá   Rè   Rë   Rí   Rî   Ró   Rm   Rô   Rù   RŒ   Rý   R  R  R  R  R  R.  R=  RE  RF  RM  RO  (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyRI   §   sz   	N																		@›		"		
				"	#									&		
		B	'		]		J	(	'	%i   i   (6   RP  R;   R    R   R   R   t   i18nR   R   Rõ   RC   R   R¤   R  R%   R   Rb   t   packR9   R_   R,   R  R  R#   R   t   sha1R   Rg   Rh   Rd   RZ   t   REVLOG_DEFAULT_FLAGSt   REVLOG_DEFAULT_FORMATRY   Ri   Rú   R	  Rß   R   Rƒ   R   R   R   R   R   R'   t   v0shaoffsetR£   R$   RB   t   ngshaoffsetRG   RA   RI   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revlog.pyt   <module>   sH   "H$					

							+                                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/mercurial/revset.py                                                 0100644 0000000 0000000 00000260233 12413056314 020765  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # revset.py - revision set queries for mercurial
#
# Copyright 2010 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

import re
import parser, util, error, discovery, hbisect, phases
import node
import heapq
import match as matchmod
import ancestor as ancestormod
from i18n import _
import encoding
import obsolete as obsmod
import pathutil
import repoview

def _revancestors(repo, revs, followfirst):
    """Like revlog.ancestors(), but supports followfirst."""
    cut = followfirst and 1 or None
    cl = repo.changelog

    def iterate():
        revqueue, revsnode = None, None
        h = []

        revs.descending()
        revqueue = util.deque(revs)
        if revqueue:
            revsnode = revqueue.popleft()
            heapq.heappush(h, -revsnode)

        seen = set([node.nullrev])
        while h:
            current = -heapq.heappop(h)
            if current not in seen:
                if revsnode and current == revsnode:
                    if revqueue:
                        revsnode = revqueue.popleft()
                        heapq.heappush(h, -revsnode)
                seen.add(current)
                yield current
                for parent in cl.parentrevs(current)[:cut]:
                    if parent != node.nullrev:
                        heapq.heappush(h, -parent)

    return _descgeneratorset(iterate())

def _revdescendants(repo, revs, followfirst):
    """Like revlog.descendants() but supports followfirst."""
    cut = followfirst and 1 or None

    def iterate():
        cl = repo.changelog
        first = min(revs)
        nullrev = node.nullrev
        if first == nullrev:
            # Are there nodes with a null first parent and a non-null
            # second one? Maybe. Do we care? Probably not.
            for i in cl:
                yield i
        else:
            seen = set(revs)
            for i in cl.revs(first + 1):
                for x in cl.parentrevs(i)[:cut]:
                    if x != nullrev and x in seen:
                        seen.add(i)
                        yield i
                        break

    return _ascgeneratorset(iterate())

def _revsbetween(repo, roots, heads):
    """Return all paths between roots and heads, inclusive of both endpoint
    sets."""
    if not roots:
        return baseset([])
    parentrevs = repo.changelog.parentrevs
    visit = baseset(heads)
    reachable = set()
    seen = {}
    minroot = min(roots)
    roots = set(roots)
    # open-code the post-order traversal due to the tiny size of
    # sys.getrecursionlimit()
    while visit:
        rev = visit.pop()
        if rev in roots:
            reachable.add(rev)
        parents = parentrevs(rev)
        seen[rev] = parents
        for parent in parents:
            if parent >= minroot and parent not in seen:
                visit.append(parent)
    if not reachable:
        return baseset([])
    for rev in sorted(seen):
        for parent in seen[rev]:
            if parent in reachable:
                reachable.add(rev)
    return baseset(sorted(reachable))

elements = {
    "(": (20, ("group", 1, ")"), ("func", 1, ")")),
    "~": (18, None, ("ancestor", 18)),
    "^": (18, None, ("parent", 18), ("parentpost", 18)),
    "-": (5, ("negate", 19), ("minus", 5)),
    "::": (17, ("dagrangepre", 17), ("dagrange", 17),
           ("dagrangepost", 17)),
    "..": (17, ("dagrangepre", 17), ("dagrange", 17),
           ("dagrangepost", 17)),
    ":": (15, ("rangepre", 15), ("range", 15), ("rangepost", 15)),
    "not": (10, ("not", 10)),
    "!": (10, ("not", 10)),
    "and": (5, None, ("and", 5)),
    "&": (5, None, ("and", 5)),
    "or": (4, None, ("or", 4)),
    "|": (4, None, ("or", 4)),
    "+": (4, None, ("or", 4)),
    ",": (2, None, ("list", 2)),
    ")": (0, None, None),
    "symbol": (0, ("symbol",), None),
    "string": (0, ("string",), None),
    "end": (0, None, None),
}

keywords = set(['and', 'or', 'not'])

def tokenize(program, lookup=None):
    '''
    Parse a revset statement into a stream of tokens

    Check that @ is a valid unquoted token character (issue3686):
    >>> list(tokenize("@::"))
    [('symbol', '@', 0), ('::', None, 1), ('end', None, 3)]

    '''

    pos, l = 0, len(program)
    while pos < l:
        c = program[pos]
        if c.isspace(): # skip inter-token whitespace
            pass
        elif c == ':' and program[pos:pos + 2] == '::': # look ahead carefully
            yield ('::', None, pos)
            pos += 1 # skip ahead
        elif c == '.' and program[pos:pos + 2] == '..': # look ahead carefully
            yield ('..', None, pos)
            pos += 1 # skip ahead
        elif c in "():,-|&+!~^": # handle simple operators
            yield (c, None, pos)
        elif (c in '"\'' or c == 'r' and
              program[pos:pos + 2] in ("r'", 'r"')): # handle quoted strings
            if c == 'r':
                pos += 1
                c = program[pos]
                decode = lambda x: x
            else:
                decode = lambda x: x.decode('string-escape')
            pos += 1
            s = pos
            while pos < l: # find closing quote
                d = program[pos]
                if d == '\\': # skip over escaped characters
                    pos += 2
                    continue
                if d == c:
                    yield ('string', decode(program[s:pos]), s)
                    break
                pos += 1
            else:
                raise error.ParseError(_("unterminated string"), s)
        # gather up a symbol/keyword
        elif c.isalnum() or c in '._@' or ord(c) > 127:
            s = pos
            pos += 1
            while pos < l: # find end of symbol
                d = program[pos]
                if not (d.isalnum() or d in "-._/@" or ord(d) > 127):
                    break
                if d == '.' and program[pos - 1] == '.': # special case for ..
                    pos -= 1
                    break
                pos += 1
            sym = program[s:pos]
            if sym in keywords: # operator keywords
                yield (sym, None, s)
            elif '-' in sym:
                # some jerk gave us foo-bar-baz, try to check if it's a symbol
                if lookup and lookup(sym):
                    # looks like a real symbol
                    yield ('symbol', sym, s)
                else:
                    # looks like an expression
                    parts = sym.split('-')
                    for p in parts[:-1]:
                        if p: # possible consecutive -
                            yield ('symbol', p, s)
                        s += len(p)
                        yield ('-', None, pos)
                        s += 1
                    if parts[-1]: # possible trailing -
                        yield ('symbol', parts[-1], s)
            else:
                yield ('symbol', sym, s)
            pos -= 1
        else:
            raise error.ParseError(_("syntax error"), pos)
        pos += 1
    yield ('end', None, pos)

# helpers

def getstring(x, err):
    if x and (x[0] == 'string' or x[0] == 'symbol'):
        return x[1]
    raise error.ParseError(err)

def getlist(x):
    if not x:
        return []
    if x[0] == 'list':
        return getlist(x[1]) + [x[2]]
    return [x]

def getargs(x, min, max, err):
    l = getlist(x)
    if len(l) < min or (max >= 0 and len(l) > max):
        raise error.ParseError(err)
    return l

def getset(repo, subset, x):
    if not x:
        raise error.ParseError(_("missing argument"))
    s = methods[x[0]](repo, subset, *x[1:])
    if util.safehasattr(s, 'set'):
        return s
    return baseset(s)

def _getrevsource(repo, r):
    extra = repo[r].extra()
    for label in ('source', 'transplant_source', 'rebase_source'):
        if label in extra:
            try:
                return repo[extra[label]].rev()
            except error.RepoLookupError:
                pass
    return None

# operator methods

def stringset(repo, subset, x):
    x = repo[x].rev()
    if x == -1 and len(subset) == len(repo):
        return baseset([-1])
    if len(subset) == len(repo) or x in subset:
        return baseset([x])
    return baseset([])

def symbolset(repo, subset, x):
    if x in symbols:
        raise error.ParseError(_("can't use %s here") % x)
    return stringset(repo, subset, x)

def rangeset(repo, subset, x, y):
    cl = baseset(repo.changelog)
    m = getset(repo, cl, x)
    n = getset(repo, cl, y)

    if not m or not n:
        return baseset([])
    m, n = m[0], n[-1]

    if m < n:
        r = spanset(repo, m, n + 1)
    else:
        r = spanset(repo, m, n - 1)
    return r & subset

def dagrange(repo, subset, x, y):
    r = spanset(repo)
    xs = _revsbetween(repo, getset(repo, r, x), getset(repo, r, y))
    s = subset.set()
    return xs.filter(s.__contains__)

def andset(repo, subset, x, y):
    return getset(repo, getset(repo, subset, x), y)

def orset(repo, subset, x, y):
    xl = getset(repo, subset, x)
    yl = getset(repo, subset - xl, y)
    return xl + yl

def notset(repo, subset, x):
    return subset - getset(repo, subset, x)

def listset(repo, subset, a, b):
    raise error.ParseError(_("can't use a list in this context"))

def func(repo, subset, a, b):
    if a[0] == 'symbol' and a[1] in symbols:
        return symbols[a[1]](repo, subset, b)
    raise error.ParseError(_("not a function: %s") % a[1])

# functions

def adds(repo, subset, x):
    """``adds(pattern)``
    Changesets that add a file matching pattern.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file or a
    directory.
    """
    # i18n: "adds" is a keyword
    pat = getstring(x, _("adds requires a pattern"))
    return checkstatus(repo, subset, pat, 1)

def ancestor(repo, subset, x):
    """``ancestor(*changeset)``
    A greatest common ancestor of the changesets.

    Accepts 0 or more changesets.
    Will return empty list when passed no args.
    Greatest common ancestor of a single changeset is that changeset.
    """
    # i18n: "ancestor" is a keyword
    l = getlist(x)
    rl = spanset(repo)
    anc = None

    # (getset(repo, rl, i) for i in l) generates a list of lists
    for revs in (getset(repo, rl, i) for i in l):
        for r in revs:
            if anc is None:
                anc = repo[r]
            else:
                anc = anc.ancestor(repo[r])

    if anc is not None and anc.rev() in subset:
        return baseset([anc.rev()])
    return baseset([])

def _ancestors(repo, subset, x, followfirst=False):
    args = getset(repo, spanset(repo), x)
    if not args:
        return baseset([])
    s = _revancestors(repo, args, followfirst)
    return subset.filter(s.__contains__)

def ancestors(repo, subset, x):
    """``ancestors(set)``
    Changesets that are ancestors of a changeset in set.
    """
    return _ancestors(repo, subset, x)

def _firstancestors(repo, subset, x):
    # ``_firstancestors(set)``
    # Like ``ancestors(set)`` but follows only the first parents.
    return _ancestors(repo, subset, x, followfirst=True)

def ancestorspec(repo, subset, x, n):
    """``set~n``
    Changesets that are the Nth ancestor (first parents only) of a changeset
    in set.
    """
    try:
        n = int(n[1])
    except (TypeError, ValueError):
        raise error.ParseError(_("~ expects a number"))
    ps = set()
    cl = repo.changelog
    for r in getset(repo, baseset(cl), x):
        for i in range(n):
            r = cl.parentrevs(r)[0]
        ps.add(r)
    return subset.filter(ps.__contains__)

def author(repo, subset, x):
    """``author(string)``
    Alias for ``user(string)``.
    """
    # i18n: "author" is a keyword
    n = encoding.lower(getstring(x, _("author requires a string")))
    kind, pattern, matcher = _substringmatcher(n)
    return subset.filter(lambda x: matcher(encoding.lower(repo[x].user())))

def only(repo, subset, x):
    """``only(set, [set])``
    Changesets that are ancestors of the first set that are not ancestors
    of any other head in the repo. If a second set is specified, the result
    is ancestors of the first set that are not ancestors of the second set
    (i.e. ::<set1> - ::<set2>).
    """
    cl = repo.changelog
    # i18n: "only" is a keyword
    args = getargs(x, 1, 2, _('only takes one or two arguments'))
    include = getset(repo, spanset(repo), args[0]).set()
    if len(args) == 1:
        if len(include) == 0:
            return baseset([])

        descendants = set(_revdescendants(repo, include, False))
        exclude = [rev for rev in cl.headrevs()
            if not rev in descendants and not rev in include]
    else:
        exclude = getset(repo, spanset(repo), args[1])

    results = set(ancestormod.missingancestors(include, exclude, cl.parentrevs))
    return lazyset(subset, results.__contains__)

def bisect(repo, subset, x):
    """``bisect(string)``
    Changesets marked in the specified bisect status:

    - ``good``, ``bad``, ``skip``: csets explicitly marked as good/bad/skip
    - ``goods``, ``bads``      : csets topologically good/bad
    - ``range``              : csets taking part in the bisection
    - ``pruned``             : csets that are goods, bads or skipped
    - ``untested``           : csets whose fate is yet unknown
    - ``ignored``            : csets ignored due to DAG topology
    - ``current``            : the cset currently being bisected
    """
    # i18n: "bisect" is a keyword
    status = getstring(x, _("bisect requires a string")).lower()
    state = set(hbisect.get(repo, status))
    return subset.filter(state.__contains__)

# Backward-compatibility
# - no help entry so that we do not advertise it any more
def bisected(repo, subset, x):
    return bisect(repo, subset, x)

def bookmark(repo, subset, x):
    """``bookmark([name])``
    The named bookmark or all bookmarks.

    If `name` starts with `re:`, the remainder of the name is treated as
    a regular expression. To match a bookmark that actually starts with `re:`,
    use the prefix `literal:`.
    """
    # i18n: "bookmark" is a keyword
    args = getargs(x, 0, 1, _('bookmark takes one or no arguments'))
    if args:
        bm = getstring(args[0],
                       # i18n: "bookmark" is a keyword
                       _('the argument to bookmark must be a string'))
        kind, pattern, matcher = _stringmatcher(bm)
        if kind == 'literal':
            bmrev = repo._bookmarks.get(pattern, None)
            if not bmrev:
                raise util.Abort(_("bookmark '%s' does not exist") % bm)
            bmrev = repo[bmrev].rev()
            return subset.filter(lambda r: r == bmrev)
        else:
            matchrevs = set()
            for name, bmrev in repo._bookmarks.iteritems():
                if matcher(name):
                    matchrevs.add(bmrev)
            if not matchrevs:
                raise util.Abort(_("no bookmarks exist that match '%s'")
                                 % pattern)
            bmrevs = set()
            for bmrev in matchrevs:
                bmrevs.add(repo[bmrev].rev())
            return subset & bmrevs

    bms = set([repo[r].rev()
               for r in repo._bookmarks.values()])
    return subset.filter(bms.__contains__)

def branch(repo, subset, x):
    """``branch(string or set)``
    All changesets belonging to the given branch or the branches of the given
    changesets.

    If `string` starts with `re:`, the remainder of the name is treated as
    a regular expression. To match a branch that actually starts with `re:`,
    use the prefix `literal:`.
    """
    try:
        b = getstring(x, '')
    except error.ParseError:
        # not a string, but another revspec, e.g. tip()
        pass
    else:
        kind, pattern, matcher = _stringmatcher(b)
        if kind == 'literal':
            # note: falls through to the revspec case if no branch with
            # this name exists
            if pattern in repo.branchmap():
                return subset.filter(lambda r: matcher(repo[r].branch()))
        else:
            return subset.filter(lambda r: matcher(repo[r].branch()))

    s = getset(repo, spanset(repo), x)
    b = set()
    for r in s:
        b.add(repo[r].branch())
    s = s.set()
    return subset.filter(lambda r: r in s or repo[r].branch() in b)

def bumped(repo, subset, x):
    """``bumped()``
    Mutable changesets marked as successors of public changesets.

    Only non-public and non-obsolete changesets can be `bumped`.
    """
    # i18n: "bumped" is a keyword
    getargs(x, 0, 0, _("bumped takes no arguments"))
    bumped = obsmod.getrevs(repo, 'bumped')
    return subset & bumped

def bundle(repo, subset, x):
    """``bundle()``
    Changesets in the bundle.

    Bundle must be specified by the -R option."""

    try:
        bundlerevs = repo.changelog.bundlerevs
    except AttributeError:
        raise util.Abort(_("no bundle provided - specify with -R"))
    return subset & bundlerevs

def checkstatus(repo, subset, pat, field):
    hasset = matchmod.patkind(pat) == 'set'

    def matches(x):
        m = None
        fname = None
        c = repo[x]
        if not m or hasset:
            m = matchmod.match(repo.root, repo.getcwd(), [pat], ctx=c)
            if not m.anypats() and len(m.files()) == 1:
                fname = m.files()[0]
        if fname is not None:
            if fname not in c.files():
                return False
        else:
            for f in c.files():
                if m(f):
                    break
            else:
                return False
        files = repo.status(c.p1().node(), c.node())[field]
        if fname is not None:
            if fname in files:
                return True
        else:
            for f in files:
                if m(f):
                    return True

    return subset.filter(matches)

def _children(repo, narrow, parentset):
    cs = set()
    if not parentset:
        return baseset(cs)
    pr = repo.changelog.parentrevs
    minrev = min(parentset)
    for r in narrow:
        if r <= minrev:
            continue
        for p in pr(r):
            if p in parentset:
                cs.add(r)
    return baseset(cs)

def children(repo, subset, x):
    """``children(set)``
    Child changesets of changesets in set.
    """
    s = getset(repo, baseset(repo), x).set()
    cs = _children(repo, subset, s)
    return subset & cs

def closed(repo, subset, x):
    """``closed()``
    Changeset is closed.
    """
    # i18n: "closed" is a keyword
    getargs(x, 0, 0, _("closed takes no arguments"))
    return subset.filter(lambda r: repo[r].closesbranch())

def contains(repo, subset, x):
    """``contains(pattern)``
    The revision's manifest contains a file matching pattern (but might not
    modify it). See :hg:`help patterns` for information about file patterns.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file exactly
    for efficiency.
    """
    # i18n: "contains" is a keyword
    pat = getstring(x, _("contains requires a pattern"))

    def matches(x):
        if not matchmod.patkind(pat):
            pats = pathutil.canonpath(repo.root, repo.getcwd(), pat)
            if pats in repo[x]:
                return True
        else:
            c = repo[x]
            m = matchmod.match(repo.root, repo.getcwd(), [pat], ctx=c)
            for f in c.manifest():
                if m(f):
                    return True
        return False

    return subset.filter(matches)

def converted(repo, subset, x):
    """``converted([id])``
    Changesets converted from the given identifier in the old repository if
    present, or all converted changesets if no identifier is specified.
    """

    # There is exactly no chance of resolving the revision, so do a simple
    # string compare and hope for the best

    rev = None
    # i18n: "converted" is a keyword
    l = getargs(x, 0, 1, _('converted takes one or no arguments'))
    if l:
        # i18n: "converted" is a keyword
        rev = getstring(l[0], _('converted requires a revision'))

    def _matchvalue(r):
        source = repo[r].extra().get('convert_revision', None)
        return source is not None and (rev is None or source.startswith(rev))

    return subset.filter(lambda r: _matchvalue(r))

def date(repo, subset, x):
    """``date(interval)``
    Changesets within the interval, see :hg:`help dates`.
    """
    # i18n: "date" is a keyword
    ds = getstring(x, _("date requires a string"))
    dm = util.matchdate(ds)
    return subset.filter(lambda x: dm(repo[x].date()[0]))

def desc(repo, subset, x):
    """``desc(string)``
    Search commit message for string. The match is case-insensitive.
    """
    # i18n: "desc" is a keyword
    ds = encoding.lower(getstring(x, _("desc requires a string")))

    def matches(x):
        c = repo[x]
        return ds in encoding.lower(c.description())

    return subset.filter(matches)

def _descendants(repo, subset, x, followfirst=False):
    args = getset(repo, spanset(repo), x)
    if not args:
        return baseset([])
    s = _revdescendants(repo, args, followfirst)

    # Both sets need to be ascending in order to lazily return the union
    # in the correct order.
    args.ascending()

    subsetset = subset.set()
    result = (orderedlazyset(s, subsetset.__contains__, ascending=True) +
              orderedlazyset(args, subsetset.__contains__, ascending=True))

    # Wrap result in a lazyset since it's an _addset, which doesn't implement
    # all the necessary functions to be consumed by callers.
    return orderedlazyset(result, lambda r: True, ascending=True)

def descendants(repo, subset, x):
    """``descendants(set)``
    Changesets which are descendants of changesets in set.
    """
    return _descendants(repo, subset, x)

def _firstdescendants(repo, subset, x):
    # ``_firstdescendants(set)``
    # Like ``descendants(set)`` but follows only the first parents.
    return _descendants(repo, subset, x, followfirst=True)

def destination(repo, subset, x):
    """``destination([set])``
    Changesets that were created by a graft, transplant or rebase operation,
    with the given revisions specified as the source.  Omitting the optional set
    is the same as passing all().
    """
    if x is not None:
        args = getset(repo, spanset(repo), x).set()
    else:
        args = getall(repo, spanset(repo), x).set()

    dests = set()

    # subset contains all of the possible destinations that can be returned, so
    # iterate over them and see if their source(s) were provided in the args.
    # Even if the immediate src of r is not in the args, src's source (or
    # further back) may be.  Scanning back further than the immediate src allows
    # transitive transplants and rebases to yield the same results as transitive
    # grafts.
    for r in subset:
        src = _getrevsource(repo, r)
        lineage = None

        while src is not None:
            if lineage is None:
                lineage = list()

            lineage.append(r)

            # The visited lineage is a match if the current source is in the arg
            # set.  Since every candidate dest is visited by way of iterating
            # subset, any dests further back in the lineage will be tested by a
            # different iteration over subset.  Likewise, if the src was already
            # selected, the current lineage can be selected without going back
            # further.
            if src in args or src in dests:
                dests.update(lineage)
                break

            r = src
            src = _getrevsource(repo, r)

    return subset.filter(dests.__contains__)

def divergent(repo, subset, x):
    """``divergent()``
    Final successors of changesets with an alternative set of final successors.
    """
    # i18n: "divergent" is a keyword
    getargs(x, 0, 0, _("divergent takes no arguments"))
    divergent = obsmod.getrevs(repo, 'divergent')
    return subset.filter(divergent.__contains__)

def draft(repo, subset, x):
    """``draft()``
    Changeset in draft phase."""
    # i18n: "draft" is a keyword
    getargs(x, 0, 0, _("draft takes no arguments"))
    pc = repo._phasecache
    return subset.filter(lambda r: pc.phase(repo, r) == phases.draft)

def extinct(repo, subset, x):
    """``extinct()``
    Obsolete changesets with obsolete descendants only.
    """
    # i18n: "extinct" is a keyword
    getargs(x, 0, 0, _("extinct takes no arguments"))
    extincts = obsmod.getrevs(repo, 'extinct')
    return subset & extincts

def extra(repo, subset, x):
    """``extra(label, [value])``
    Changesets with the given label in the extra metadata, with the given
    optional value.

    If `value` starts with `re:`, the remainder of the value is treated as
    a regular expression. To match a value that actually starts with `re:`,
    use the prefix `literal:`.
    """

    # i18n: "extra" is a keyword
    l = getargs(x, 1, 2, _('extra takes at least 1 and at most 2 arguments'))
    # i18n: "extra" is a keyword
    label = getstring(l[0], _('first argument to extra must be a string'))
    value = None

    if len(l) > 1:
        # i18n: "extra" is a keyword
        value = getstring(l[1], _('second argument to extra must be a string'))
        kind, value, matcher = _stringmatcher(value)

    def _matchvalue(r):
        extra = repo[r].extra()
        return label in extra and (value is None or matcher(extra[label]))

    return subset.filter(lambda r: _matchvalue(r))

def filelog(repo, subset, x):
    """``filelog(pattern)``
    Changesets connected to the specified filelog.

    For performance reasons, visits only revisions mentioned in the file-level
    filelog, rather than filtering through all changesets (much faster, but
    doesn't include deletes or duplicate changes). For a slower, more accurate
    result, use ``file()``.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file exactly
    for efficiency.
    """

    # i18n: "filelog" is a keyword
    pat = getstring(x, _("filelog requires a pattern"))
    s = set()

    if not matchmod.patkind(pat):
        f = pathutil.canonpath(repo.root, repo.getcwd(), pat)
        fl = repo.file(f)
        for fr in fl:
            s.add(fl.linkrev(fr))
    else:
        m = matchmod.match(repo.root, repo.getcwd(), [pat], ctx=repo[None])
        for f in repo[None]:
            if m(f):
                fl = repo.file(f)
                for fr in fl:
                    s.add(fl.linkrev(fr))

    return subset.filter(s.__contains__)

def first(repo, subset, x):
    """``first(set, [n])``
    An alias for limit().
    """
    return limit(repo, subset, x)

def _follow(repo, subset, x, name, followfirst=False):
    l = getargs(x, 0, 1, _("%s takes no arguments or a filename") % name)
    c = repo['.']
    if l:
        x = getstring(l[0], _("%s expected a filename") % name)
        if x in c:
            cx = c[x]
            s = set(ctx.rev() for ctx in cx.ancestors(followfirst=followfirst))
            # include the revision responsible for the most recent version
            s.add(cx.linkrev())
        else:
            return baseset([])
    else:
        s = _revancestors(repo, baseset([c.rev()]), followfirst)

    return subset.filter(s.__contains__)

def follow(repo, subset, x):
    """``follow([file])``
    An alias for ``::.`` (ancestors of the working copy's first parent).
    If a filename is specified, the history of the given file is followed,
    including copies.
    """
    return _follow(repo, subset, x, 'follow')

def _followfirst(repo, subset, x):
    # ``followfirst([file])``
    # Like ``follow([file])`` but follows only the first parent of
    # every revision or file revision.
    return _follow(repo, subset, x, '_followfirst', followfirst=True)

def getall(repo, subset, x):
    """``all()``
    All changesets, the same as ``0:tip``.
    """
    # i18n: "all" is a keyword
    getargs(x, 0, 0, _("all takes no arguments"))
    return subset

def grep(repo, subset, x):
    """``grep(regex)``
    Like ``keyword(string)`` but accepts a regex. Use ``grep(r'...')``
    to ensure special escape characters are handled correctly. Unlike
    ``keyword(string)``, the match is case-sensitive.
    """
    try:
        # i18n: "grep" is a keyword
        gr = re.compile(getstring(x, _("grep requires a string")))
    except re.error, e:
        raise error.ParseError(_('invalid match pattern: %s') % e)

    def matches(x):
        c = repo[x]
        for e in c.files() + [c.user(), c.description()]:
            if gr.search(e):
                return True
        return False

    return subset.filter(matches)

def _matchfiles(repo, subset, x):
    # _matchfiles takes a revset list of prefixed arguments:
    #
    #   [p:foo, i:bar, x:baz]
    #
    # builds a match object from them and filters subset. Allowed
    # prefixes are 'p:' for regular patterns, 'i:' for include
    # patterns and 'x:' for exclude patterns. Use 'r:' prefix to pass
    # a revision identifier, or the empty string to reference the
    # working directory, from which the match object is
    # initialized. Use 'd:' to set the default matching mode, default
    # to 'glob'. At most one 'r:' and 'd:' argument can be passed.

    # i18n: "_matchfiles" is a keyword
    l = getargs(x, 1, -1, _("_matchfiles requires at least one argument"))
    pats, inc, exc = [], [], []
    hasset = False
    rev, default = None, None
    for arg in l:
        # i18n: "_matchfiles" is a keyword
        s = getstring(arg, _("_matchfiles requires string arguments"))
        prefix, value = s[:2], s[2:]
        if prefix == 'p:':
            pats.append(value)
        elif prefix == 'i:':
            inc.append(value)
        elif prefix == 'x:':
            exc.append(value)
        elif prefix == 'r:':
            if rev is not None:
                # i18n: "_matchfiles" is a keyword
                raise error.ParseError(_('_matchfiles expected at most one '
                                         'revision'))
            rev = value
        elif prefix == 'd:':
            if default is not None:
                # i18n: "_matchfiles" is a keyword
                raise error.ParseError(_('_matchfiles expected at most one '
                                         'default mode'))
            default = value
        else:
            # i18n: "_matchfiles" is a keyword
            raise error.ParseError(_('invalid _matchfiles prefix: %s') % prefix)
        if not hasset and matchmod.patkind(value) == 'set':
            hasset = True
    if not default:
        default = 'glob'

    def matches(x):
        m = None
        c = repo[x]
        if not m or (hasset and rev is None):
            ctx = c
            if rev is not None:
                ctx = repo[rev or None]
            m = matchmod.match(repo.root, repo.getcwd(), pats, include=inc,
                               exclude=exc, ctx=ctx, default=default)
        for f in c.files():
            if m(f):
                return True
        return False

    return subset.filter(matches)

def hasfile(repo, subset, x):
    """``file(pattern)``
    Changesets affecting files matched by pattern.

    For a faster but less accurate result, consider using ``filelog()``
    instead.

    This predicate uses ``glob:`` as the default kind of pattern.
    """
    # i18n: "file" is a keyword
    pat = getstring(x, _("file requires a pattern"))
    return _matchfiles(repo, subset, ('string', 'p:' + pat))

def head(repo, subset, x):
    """``head()``
    Changeset is a named branch head.
    """
    # i18n: "head" is a keyword
    getargs(x, 0, 0, _("head takes no arguments"))
    hs = set()
    for b, ls in repo.branchmap().iteritems():
        hs.update(repo[h].rev() for h in ls)
    return baseset(hs).filter(subset.__contains__)

def heads(repo, subset, x):
    """``heads(set)``
    Members of set with no children in set.
    """
    s = getset(repo, subset, x)
    ps = parents(repo, subset, x)
    return s - ps

def hidden(repo, subset, x):
    """``hidden()``
    Hidden changesets.
    """
    # i18n: "hidden" is a keyword
    getargs(x, 0, 0, _("hidden takes no arguments"))
    hiddenrevs = repoview.filterrevs(repo, 'visible')
    return subset & hiddenrevs

def keyword(repo, subset, x):
    """``keyword(string)``
    Search commit message, user name, and names of changed files for
    string. The match is case-insensitive.
    """
    # i18n: "keyword" is a keyword
    kw = encoding.lower(getstring(x, _("keyword requires a string")))

    def matches(r):
        c = repo[r]
        return util.any(kw in encoding.lower(t) for t in c.files() + [c.user(),
            c.description()])

    return subset.filter(matches)

def limit(repo, subset, x):
    """``limit(set, [n])``
    First n members of set, defaulting to 1.
    """
    # i18n: "limit" is a keyword
    l = getargs(x, 1, 2, _("limit requires one or two arguments"))
    try:
        lim = 1
        if len(l) == 2:
            # i18n: "limit" is a keyword
            lim = int(getstring(l[1], _("limit requires a number")))
    except (TypeError, ValueError):
        # i18n: "limit" is a keyword
        raise error.ParseError(_("limit expects a number"))
    ss = subset.set()
    os = getset(repo, spanset(repo), l[0])
    bs = baseset([])
    it = iter(os)
    for x in xrange(lim):
        try:
            y = it.next()
            if y in ss:
                bs.append(y)
        except (StopIteration):
            break
    return bs

def last(repo, subset, x):
    """``last(set, [n])``
    Last n members of set, defaulting to 1.
    """
    # i18n: "last" is a keyword
    l = getargs(x, 1, 2, _("last requires one or two arguments"))
    try:
        lim = 1
        if len(l) == 2:
            # i18n: "last" is a keyword
            lim = int(getstring(l[1], _("last requires a number")))
    except (TypeError, ValueError):
        # i18n: "last" is a keyword
        raise error.ParseError(_("last expects a number"))
    ss = subset.set()
    os = getset(repo, spanset(repo), l[0])
    os.reverse()
    bs = baseset([])
    it = iter(os)
    for x in xrange(lim):
        try:
            y = it.next()
            if y in ss:
                bs.append(y)
        except (StopIteration):
            break
    return bs

def maxrev(repo, subset, x):
    """``max(set)``
    Changeset with highest revision number in set.
    """
    os = getset(repo, spanset(repo), x)
    if os:
        m = os.max()
        if m in subset:
            return baseset([m])
    return baseset([])

def merge(repo, subset, x):
    """``merge()``
    Changeset is a merge changeset.
    """
    # i18n: "merge" is a keyword
    getargs(x, 0, 0, _("merge takes no arguments"))
    cl = repo.changelog
    return subset.filter(lambda r: cl.parentrevs(r)[1] != -1)

def branchpoint(repo, subset, x):
    """``branchpoint()``
    Changesets with more than one child.
    """
    # i18n: "branchpoint" is a keyword
    getargs(x, 0, 0, _("branchpoint takes no arguments"))
    cl = repo.changelog
    if not subset:
        return baseset([])
    baserev = min(subset)
    parentscount = [0]*(len(repo) - baserev)
    for r in cl.revs(start=baserev + 1):
        for p in cl.parentrevs(r):
            if p >= baserev:
                parentscount[p - baserev] += 1
    return subset.filter(lambda r: parentscount[r - baserev] > 1)

def minrev(repo, subset, x):
    """``min(set)``
    Changeset with lowest revision number in set.
    """
    os = getset(repo, spanset(repo), x)
    if os:
        m = os.min()
        if m in subset:
            return baseset([m])
    return baseset([])

def modifies(repo, subset, x):
    """``modifies(pattern)``
    Changesets modifying files matched by pattern.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file or a
    directory.
    """
    # i18n: "modifies" is a keyword
    pat = getstring(x, _("modifies requires a pattern"))
    return checkstatus(repo, subset, pat, 0)

def node_(repo, subset, x):
    """``id(string)``
    Revision non-ambiguously specified by the given hex string prefix.
    """
    # i18n: "id" is a keyword
    l = getargs(x, 1, 1, _("id requires one argument"))
    # i18n: "id" is a keyword
    n = getstring(l[0], _("id requires a string"))
    if len(n) == 40:
        rn = repo[n].rev()
    else:
        rn = None
        pm = repo.changelog._partialmatch(n)
        if pm is not None:
            rn = repo.changelog.rev(pm)

    return subset.filter(lambda r: r == rn)

def obsolete(repo, subset, x):
    """``obsolete()``
    Mutable changeset with a newer version."""
    # i18n: "obsolete" is a keyword
    getargs(x, 0, 0, _("obsolete takes no arguments"))
    obsoletes = obsmod.getrevs(repo, 'obsolete')
    return subset & obsoletes

def origin(repo, subset, x):
    """``origin([set])``
    Changesets that were specified as a source for the grafts, transplants or
    rebases that created the given revisions.  Omitting the optional set is the
    same as passing all().  If a changeset created by these operations is itself
    specified as a source for one of these operations, only the source changeset
    for the first operation is selected.
    """
    if x is not None:
        args = getset(repo, spanset(repo), x).set()
    else:
        args = getall(repo, spanset(repo), x).set()

    def _firstsrc(rev):
        src = _getrevsource(repo, rev)
        if src is None:
            return None

        while True:
            prev = _getrevsource(repo, src)

            if prev is None:
                return src
            src = prev

    o = set([_firstsrc(r) for r in args])
    return subset.filter(o.__contains__)

def outgoing(repo, subset, x):
    """``outgoing([path])``
    Changesets not found in the specified destination repository, or the
    default push location.
    """
    import hg # avoid start-up nasties
    # i18n: "outgoing" is a keyword
    l = getargs(x, 0, 1, _("outgoing takes one or no arguments"))
    # i18n: "outgoing" is a keyword
    dest = l and getstring(l[0], _("outgoing requires a repository path")) or ''
    dest = repo.ui.expandpath(dest or 'default-push', dest or 'default')
    dest, branches = hg.parseurl(dest)
    revs, checkout = hg.addbranchrevs(repo, repo, branches, [])
    if revs:
        revs = [repo.lookup(rev) for rev in revs]
    other = hg.peer(repo, {}, dest)
    repo.ui.pushbuffer()
    outgoing = discovery.findcommonoutgoing(repo, other, onlyheads=revs)
    repo.ui.popbuffer()
    cl = repo.changelog
    o = set([cl.rev(r) for r in outgoing.missing])
    return subset.filter(o.__contains__)

def p1(repo, subset, x):
    """``p1([set])``
    First parent of changesets in set, or the working directory.
    """
    if x is None:
        p = repo[x].p1().rev()
        return subset.filter(lambda r: r == p)

    ps = set()
    cl = repo.changelog
    for r in getset(repo, spanset(repo), x):
        ps.add(cl.parentrevs(r)[0])
    return subset & ps

def p2(repo, subset, x):
    """``p2([set])``
    Second parent of changesets in set, or the working directory.
    """
    if x is None:
        ps = repo[x].parents()
        try:
            p = ps[1].rev()
            return subset.filter(lambda r: r == p)
        except IndexError:
            return baseset([])

    ps = set()
    cl = repo.changelog
    for r in getset(repo, spanset(repo), x):
        ps.add(cl.parentrevs(r)[1])
    return subset & ps

def parents(repo, subset, x):
    """``parents([set])``
    The set of all parents for all changesets in set, or the working directory.
    """
    if x is None:
        ps = tuple(p.rev() for p in repo[x].parents())
        return subset & ps

    ps = set()
    cl = repo.changelog
    for r in getset(repo, spanset(repo), x):
        ps.update(cl.parentrevs(r))
    return subset & ps

def parentspec(repo, subset, x, n):
    """``set^0``
    The set.
    ``set^1`` (or ``set^``), ``set^2``
    First or second parent, respectively, of all changesets in set.
    """
    try:
        n = int(n[1])
        if n not in (0, 1, 2):
            raise ValueError
    except (TypeError, ValueError):
        raise error.ParseError(_("^ expects a number 0, 1, or 2"))
    ps = set()
    cl = repo.changelog
    for r in getset(repo, baseset(cl), x):
        if n == 0:
            ps.add(r)
        elif n == 1:
            ps.add(cl.parentrevs(r)[0])
        elif n == 2:
            parents = cl.parentrevs(r)
            if len(parents) > 1:
                ps.add(parents[1])
    return subset & ps

def present(repo, subset, x):
    """``present(set)``
    An empty set, if any revision in set isn't found; otherwise,
    all revisions in set.

    If any of specified revisions is not present in the local repository,
    the query is normally aborted. But this predicate allows the query
    to continue even in such cases.
    """
    try:
        return getset(repo, subset, x)
    except error.RepoLookupError:
        return baseset([])

def public(repo, subset, x):
    """``public()``
    Changeset in public phase."""
    # i18n: "public" is a keyword
    getargs(x, 0, 0, _("public takes no arguments"))
    pc = repo._phasecache
    return subset.filter(lambda r: pc.phase(repo, r) == phases.public)

def remote(repo, subset, x):
    """``remote([id [,path]])``
    Local revision that corresponds to the given identifier in a
    remote repository, if present. Here, the '.' identifier is a
    synonym for the current local branch.
    """

    import hg # avoid start-up nasties
    # i18n: "remote" is a keyword
    l = getargs(x, 0, 2, _("remote takes one, two or no arguments"))

    q = '.'
    if len(l) > 0:
    # i18n: "remote" is a keyword
        q = getstring(l[0], _("remote requires a string id"))
    if q == '.':
        q = repo['.'].branch()

    dest = ''
    if len(l) > 1:
        # i18n: "remote" is a keyword
        dest = getstring(l[1], _("remote requires a repository path"))
    dest = repo.ui.expandpath(dest or 'default')
    dest, branches = hg.parseurl(dest)
    revs, checkout = hg.addbranchrevs(repo, repo, branches, [])
    if revs:
        revs = [repo.lookup(rev) for rev in revs]
    other = hg.peer(repo, {}, dest)
    n = other.lookup(q)
    if n in repo:
        r = repo[n].rev()
        if r in subset:
            return baseset([r])
    return baseset([])

def removes(repo, subset, x):
    """``removes(pattern)``
    Changesets which remove files matching pattern.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file or a
    directory.
    """
    # i18n: "removes" is a keyword
    pat = getstring(x, _("removes requires a pattern"))
    return checkstatus(repo, subset, pat, 2)

def rev(repo, subset, x):
    """``rev(number)``
    Revision with the given numeric identifier.
    """
    # i18n: "rev" is a keyword
    l = getargs(x, 1, 1, _("rev requires one argument"))
    try:
        # i18n: "rev" is a keyword
        l = int(getstring(l[0], _("rev requires a number")))
    except (TypeError, ValueError):
        # i18n: "rev" is a keyword
        raise error.ParseError(_("rev expects a number"))
    return subset.filter(lambda r: r == l)

def matching(repo, subset, x):
    """``matching(revision [, field])``
    Changesets in which a given set of fields match the set of fields in the
    selected revision or set.

    To match more than one field pass the list of fields to match separated
    by spaces (e.g. ``author description``).

    Valid fields are most regular revision fields and some special fields.

    Regular revision fields are ``description``, ``author``, ``branch``,
    ``date``, ``files``, ``phase``, ``parents``, ``substate``, ``user``
    and ``diff``.
    Note that ``author`` and ``user`` are synonyms. ``diff`` refers to the
    contents of the revision. Two revisions matching their ``diff`` will
    also match their ``files``.

    Special fields are ``summary`` and ``metadata``:
    ``summary`` matches the first line of the description.
    ``metadata`` is equivalent to matching ``description user date``
    (i.e. it matches the main metadata fields).

    ``metadata`` is the default field which is used when no fields are
    specified. You can match more than one field at a time.
    """
    # i18n: "matching" is a keyword
    l = getargs(x, 1, 2, _("matching takes 1 or 2 arguments"))

    revs = getset(repo, baseset(repo.changelog), l[0])

    fieldlist = ['metadata']
    if len(l) > 1:
            fieldlist = getstring(l[1],
                # i18n: "matching" is a keyword
                _("matching requires a string "
                "as its second argument")).split()

    # Make sure that there are no repeated fields,
    # expand the 'special' 'metadata' field type
    # and check the 'files' whenever we check the 'diff'
    fields = []
    for field in fieldlist:
        if field == 'metadata':
            fields += ['user', 'description', 'date']
        elif field == 'diff':
            # a revision matching the diff must also match the files
            # since matching the diff is very costly, make sure to
            # also match the files first
            fields += ['files', 'diff']
        else:
            if field == 'author':
                field = 'user'
            fields.append(field)
    fields = set(fields)
    if 'summary' in fields and 'description' in fields:
        # If a revision matches its description it also matches its summary
        fields.discard('summary')

    # We may want to match more than one field
    # Not all fields take the same amount of time to be matched
    # Sort the selected fields in order of increasing matching cost
    fieldorder = ['phase', 'parents', 'user', 'date', 'branch', 'summary',
        'files', 'description', 'substate', 'diff']
    def fieldkeyfunc(f):
        try:
            return fieldorder.index(f)
        except ValueError:
            # assume an unknown field is very costly
            return len(fieldorder)
    fields = list(fields)
    fields.sort(key=fieldkeyfunc)

    # Each field will be matched with its own "getfield" function
    # which will be added to the getfieldfuncs array of functions
    getfieldfuncs = []
    _funcs = {
        'user': lambda r: repo[r].user(),
        'branch': lambda r: repo[r].branch(),
        'date': lambda r: repo[r].date(),
        'description': lambda r: repo[r].description(),
        'files': lambda r: repo[r].files(),
        'parents': lambda r: repo[r].parents(),
        'phase': lambda r: repo[r].phase(),
        'substate': lambda r: repo[r].substate,
        'summary': lambda r: repo[r].description().splitlines()[0],
        'diff': lambda r: list(repo[r].diff(git=True),)
    }
    for info in fields:
        getfield = _funcs.get(info, None)
        if getfield is None:
            raise error.ParseError(
                # i18n: "matching" is a keyword
                _("unexpected field name passed to matching: %s") % info)
        getfieldfuncs.append(getfield)
    # convert the getfield array of functions into a "getinfo" function
    # which returns an array of field values (or a single value if there
    # is only one field to match)
    getinfo = lambda r: [f(r) for f in getfieldfuncs]

    def matches(x):
        for rev in revs:
            target = getinfo(rev)
            match = True
            for n, f in enumerate(getfieldfuncs):
                if target[n] != f(x):
                    match = False
            if match:
                return True
        return False

    return subset.filter(matches)

def reverse(repo, subset, x):
    """``reverse(set)``
    Reverse order of set.
    """
    l = getset(repo, subset, x)
    l.reverse()
    return l

def roots(repo, subset, x):
    """``roots(set)``
    Changesets in set with no parent changeset in set.
    """
    s = getset(repo, spanset(repo), x).set()
    subset = baseset([r for r in s if r in subset.set()])
    cs = _children(repo, subset, s)
    return subset - cs

def secret(repo, subset, x):
    """``secret()``
    Changeset in secret phase."""
    # i18n: "secret" is a keyword
    getargs(x, 0, 0, _("secret takes no arguments"))
    pc = repo._phasecache
    return subset.filter(lambda x: pc.phase(repo, x) == phases.secret)

def sort(repo, subset, x):
    """``sort(set[, [-]key...])``
    Sort set by keys. The default sort order is ascending, specify a key
    as ``-key`` to sort in descending order.

    The keys can be:

    - ``rev`` for the revision number,
    - ``branch`` for the branch name,
    - ``desc`` for the commit message (description),
    - ``user`` for user name (``author`` can be used as an alias),
    - ``date`` for the commit date
    """
    # i18n: "sort" is a keyword
    l = getargs(x, 1, 2, _("sort requires one or two arguments"))
    keys = "rev"
    if len(l) == 2:
        # i18n: "sort" is a keyword
        keys = getstring(l[1], _("sort spec must be a string"))

    s = l[0]
    keys = keys.split()
    l = []
    def invert(s):
        return "".join(chr(255 - ord(c)) for c in s)
    revs = getset(repo, subset, s)
    if keys == ["rev"]:
        revs.sort()
        return revs
    elif keys == ["-rev"]:
        revs.sort(reverse=True)
        return revs
    for r in revs:
        c = repo[r]
        e = []
        for k in keys:
            if k == 'rev':
                e.append(r)
            elif k == '-rev':
                e.append(-r)
            elif k == 'branch':
                e.append(c.branch())
            elif k == '-branch':
                e.append(invert(c.branch()))
            elif k == 'desc':
                e.append(c.description())
            elif k == '-desc':
                e.append(invert(c.description()))
            elif k in 'user author':
                e.append(c.user())
            elif k in '-user -author':
                e.append(invert(c.user()))
            elif k == 'date':
                e.append(c.date()[0])
            elif k == '-date':
                e.append(-c.date()[0])
            else:
                raise error.ParseError(_("unknown sort key %r") % k)
        e.append(r)
        l.append(e)
    l.sort()
    return baseset([e[-1] for e in l])

def _stringmatcher(pattern):
    """
    accepts a string, possibly starting with 're:' or 'literal:' prefix.
    returns the matcher name, pattern, and matcher function.
    missing or unknown prefixes are treated as literal matches.

    helper for tests:
    >>> def test(pattern, *tests):
    ...     kind, pattern, matcher = _stringmatcher(pattern)
    ...     return (kind, pattern, [bool(matcher(t)) for t in tests])

    exact matching (no prefix):
    >>> test('abcdefg', 'abc', 'def', 'abcdefg')
    ('literal', 'abcdefg', [False, False, True])

    regex matching ('re:' prefix)
    >>> test('re:a.+b', 'nomatch', 'fooadef', 'fooadefbar')
    ('re', 'a.+b', [False, False, True])

    force exact matches ('literal:' prefix)
    >>> test('literal:re:foobar', 'foobar', 're:foobar')
    ('literal', 're:foobar', [False, True])

    unknown prefixes are ignored and treated as literals
    >>> test('foo:bar', 'foo', 'bar', 'foo:bar')
    ('literal', 'foo:bar', [False, False, True])
    """
    if pattern.startswith('re:'):
        pattern = pattern[3:]
        try:
            regex = re.compile(pattern)
        except re.error, e:
            raise error.ParseError(_('invalid regular expression: %s')
                                   % e)
        return 're', pattern, regex.search
    elif pattern.startswith('literal:'):
        pattern = pattern[8:]
    return 'literal', pattern, pattern.__eq__

def _substringmatcher(pattern):
    kind, pattern, matcher = _stringmatcher(pattern)
    if kind == 'literal':
        matcher = lambda s: pattern in s
    return kind, pattern, matcher

def tag(repo, subset, x):
    """``tag([name])``
    The specified tag by name, or all tagged revisions if no name is given.

    If `name` starts with `re:`, the remainder of the name is treated as
    a regular expression. To match a tag that actually starts with `re:`,
    use the prefix `literal:`.
    """
    # i18n: "tag" is a keyword
    args = getargs(x, 0, 1, _("tag takes one or no arguments"))
    cl = repo.changelog
    if args:
        pattern = getstring(args[0],
                            # i18n: "tag" is a keyword
                            _('the argument to tag must be a string'))
        kind, pattern, matcher = _stringmatcher(pattern)
        if kind == 'literal':
            # avoid resolving all tags
            tn = repo._tagscache.tags.get(pattern, None)
            if tn is None:
                raise util.Abort(_("tag '%s' does not exist") % pattern)
            s = set([repo[tn].rev()])
        else:
            s = set([cl.rev(n) for t, n in repo.tagslist() if matcher(t)])
    else:
        s = set([cl.rev(n) for t, n in repo.tagslist() if t != 'tip'])
    return subset & s

def tagged(repo, subset, x):
    return tag(repo, subset, x)

def unstable(repo, subset, x):
    """``unstable()``
    Non-obsolete changesets with obsolete ancestors.
    """
    # i18n: "unstable" is a keyword
    getargs(x, 0, 0, _("unstable takes no arguments"))
    unstables = obsmod.getrevs(repo, 'unstable')
    return subset & unstables


def user(repo, subset, x):
    """``user(string)``
    User name contains string. The match is case-insensitive.

    If `string` starts with `re:`, the remainder of the string is treated as
    a regular expression. To match a user that actually contains `re:`, use
    the prefix `literal:`.
    """
    return author(repo, subset, x)

# for internal use
def _list(repo, subset, x):
    s = getstring(x, "internal error")
    if not s:
        return baseset([])
    ls = [repo[r].rev() for r in s.split('\0')]
    s = subset.set()
    return baseset([r for r in ls if r in s])

# for internal use
def _intlist(repo, subset, x):
    s = getstring(x, "internal error")
    if not s:
        return baseset([])
    ls = [int(r) for r in s.split('\0')]
    s = subset.set()
    return baseset([r for r in ls if r in s])

# for internal use
def _hexlist(repo, subset, x):
    s = getstring(x, "internal error")
    if not s:
        return baseset([])
    cl = repo.changelog
    ls = [cl.rev(node.bin(r)) for r in s.split('\0')]
    s = subset.set()
    return baseset([r for r in ls if r in s])

symbols = {
    "adds": adds,
    "all": getall,
    "ancestor": ancestor,
    "ancestors": ancestors,
    "_firstancestors": _firstancestors,
    "author": author,
    "only": only,
    "bisect": bisect,
    "bisected": bisected,
    "bookmark": bookmark,
    "branch": branch,
    "branchpoint": branchpoint,
    "bumped": bumped,
    "bundle": bundle,
    "children": children,
    "closed": closed,
    "contains": contains,
    "converted": converted,
    "date": date,
    "desc": desc,
    "descendants": descendants,
    "_firstdescendants": _firstdescendants,
    "destination": destination,
    "divergent": divergent,
    "draft": draft,
    "extinct": extinct,
    "extra": extra,
    "file": hasfile,
    "filelog": filelog,
    "first": first,
    "follow": follow,
    "_followfirst": _followfirst,
    "grep": grep,
    "head": head,
    "heads": heads,
    "hidden": hidden,
    "id": node_,
    "keyword": keyword,
    "last": last,
    "limit": limit,
    "_matchfiles": _matchfiles,
    "max": maxrev,
    "merge": merge,
    "min": minrev,
    "modifies": modifies,
    "obsolete": obsolete,
    "origin": origin,
    "outgoing": outgoing,
    "p1": p1,
    "p2": p2,
    "parents": parents,
    "present": present,
    "public": public,
    "remote": remote,
    "removes": removes,
    "rev": rev,
    "reverse": reverse,
    "roots": roots,
    "sort": sort,
    "secret": secret,
    "matching": matching,
    "tag": tag,
    "tagged": tagged,
    "user": user,
    "unstable": unstable,
    "_list": _list,
    "_intlist": _intlist,
    "_hexlist": _hexlist,
}

# symbols which can't be used for a DoS attack for any given input
# (e.g. those which accept regexes as plain strings shouldn't be included)
# functions that just return a lot of changesets (like all) don't count here
safesymbols = set([
    "adds",
    "all",
    "ancestor",
    "ancestors",
    "_firstancestors",
    "author",
    "bisect",
    "bisected",
    "bookmark",
    "branch",
    "branchpoint",
    "bumped",
    "bundle",
    "children",
    "closed",
    "converted",
    "date",
    "desc",
    "descendants",
    "_firstdescendants",
    "destination",
    "divergent",
    "draft",
    "extinct",
    "extra",
    "file",
    "filelog",
    "first",
    "follow",
    "_followfirst",
    "head",
    "heads",
    "hidden",
    "id",
    "keyword",
    "last",
    "limit",
    "_matchfiles",
    "max",
    "merge",
    "min",
    "modifies",
    "obsolete",
    "origin",
    "outgoing",
    "p1",
    "p2",
    "parents",
    "present",
    "public",
    "remote",
    "removes",
    "rev",
    "reverse",
    "roots",
    "sort",
    "secret",
    "matching",
    "tag",
    "tagged",
    "user",
    "unstable",
    "_list",
    "_intlist",
    "_hexlist",
])

methods = {
    "range": rangeset,
    "dagrange": dagrange,
    "string": stringset,
    "symbol": symbolset,
    "and": andset,
    "or": orset,
    "not": notset,
    "list": listset,
    "func": func,
    "ancestor": ancestorspec,
    "parent": parentspec,
    "parentpost": p1,
}

def optimize(x, small):
    if x is None:
        return 0, x

    smallbonus = 1
    if small:
        smallbonus = .5

    op = x[0]
    if op == 'minus':
        return optimize(('and', x[1], ('not', x[2])), small)
    elif op == 'dagrangepre':
        return optimize(('func', ('symbol', 'ancestors'), x[1]), small)
    elif op == 'dagrangepost':
        return optimize(('func', ('symbol', 'descendants'), x[1]), small)
    elif op == 'rangepre':
        return optimize(('range', ('string', '0'), x[1]), small)
    elif op == 'rangepost':
        return optimize(('range', x[1], ('string', 'tip')), small)
    elif op == 'negate':
        return optimize(('string',
                         '-' + getstring(x[1], _("can't negate that"))), small)
    elif op in 'string symbol negate':
        return smallbonus, x # single revisions are small
    elif op == 'and':
        wa, ta = optimize(x[1], True)
        wb, tb = optimize(x[2], True)

        # (::x and not ::y)/(not ::y and ::x) have a fast path
        def isonly(revs, bases):
            return (
                revs[0] == 'func'
                and getstring(revs[1], _('not a symbol')) == 'ancestors'
                and bases[0] == 'not'
                and bases[1][0] == 'func'
                and getstring(bases[1][1], _('not a symbol')) == 'ancestors')

        w = min(wa, wb)
        if isonly(ta, tb):
            return w, ('func', ('symbol', 'only'), ('list', ta[2], tb[1][2]))
        if isonly(tb, ta):
            return w, ('func', ('symbol', 'only'), ('list', tb[2], ta[1][2]))

        if wa > wb:
            return w, (op, tb, ta)
        return w, (op, ta, tb)
    elif op == 'or':
        wa, ta = optimize(x[1], False)
        wb, tb = optimize(x[2], False)
        if wb < wa:
            wb, wa = wa, wb
        return max(wa, wb), (op, ta, tb)
    elif op == 'not':
        o = optimize(x[1], not small)
        return o[0], (op, o[1])
    elif op == 'parentpost':
        o = optimize(x[1], small)
        return o[0], (op, o[1])
    elif op == 'group':
        return optimize(x[1], small)
    elif op in 'dagrange range list parent ancestorspec':
        if op == 'parent':
            # x^:y means (x^) : y, not x ^ (:y)
            post = ('parentpost', x[1])
            if x[2][0] == 'dagrangepre':
                return optimize(('dagrange', post, x[2][1]), small)
            elif x[2][0] == 'rangepre':
                return optimize(('range', post, x[2][1]), small)

        wa, ta = optimize(x[1], small)
        wb, tb = optimize(x[2], small)
        return wa + wb, (op, ta, tb)
    elif op == 'func':
        f = getstring(x[1], _("not a symbol"))
        wa, ta = optimize(x[2], small)
        if f in ("author branch closed date desc file grep keyword "
                 "outgoing user"):
            w = 10 # slow
        elif f in "modifies adds removes":
            w = 30 # slower
        elif f == "contains":
            w = 100 # very slow
        elif f == "ancestor":
            w = 1 * smallbonus
        elif f in "reverse limit first":
            w = 0
        elif f in "sort":
            w = 10 # assume most sorts look at changelog
        else:
            w = 1
        return w + wa, (op, x[1], ta)
    return 1, x

_aliasarg = ('func', ('symbol', '_aliasarg'))
def _getaliasarg(tree):
    """If tree matches ('func', ('symbol', '_aliasarg'), ('string', X))
    return X, None otherwise.
    """
    if (len(tree) == 3 and tree[:2] == _aliasarg
        and tree[2][0] == 'string'):
        return tree[2][1]
    return None

def _checkaliasarg(tree, known=None):
    """Check tree contains no _aliasarg construct or only ones which
    value is in known. Used to avoid alias placeholders injection.
    """
    if isinstance(tree, tuple):
        arg = _getaliasarg(tree)
        if arg is not None and (not known or arg not in known):
            raise error.ParseError(_("not a function: %s") % '_aliasarg')
        for t in tree:
            _checkaliasarg(t, known)

class revsetalias(object):
    funcre = re.compile('^([^(]+)\(([^)]+)\)$')
    args = None

    def __init__(self, name, value):
        '''Aliases like:

        h = heads(default)
        b($1) = ancestors($1) - ancestors(default)
        '''
        m = self.funcre.search(name)
        if m:
            self.name = m.group(1)
            self.tree = ('func', ('symbol', m.group(1)))
            self.args = [x.strip() for x in m.group(2).split(',')]
            for arg in self.args:
                # _aliasarg() is an unknown symbol only used separate
                # alias argument placeholders from regular strings.
                value = value.replace(arg, '_aliasarg(%r)' % (arg,))
        else:
            self.name = name
            self.tree = ('symbol', name)

        self.replacement, pos = parse(value)
        if pos != len(value):
            raise error.ParseError(_('invalid token'), pos)
        # Check for placeholder injection
        _checkaliasarg(self.replacement, self.args)

def _getalias(aliases, tree):
    """If tree looks like an unexpanded alias, return it. Return None
    otherwise.
    """
    if isinstance(tree, tuple) and tree:
        if tree[0] == 'symbol' and len(tree) == 2:
            name = tree[1]
            alias = aliases.get(name)
            if alias and alias.args is None and alias.tree == tree:
                return alias
        if tree[0] == 'func' and len(tree) > 1:
            if tree[1][0] == 'symbol' and len(tree[1]) == 2:
                name = tree[1][1]
                alias = aliases.get(name)
                if alias and alias.args is not None and alias.tree == tree[:2]:
                    return alias
    return None

def _expandargs(tree, args):
    """Replace _aliasarg instances with the substitution value of the
    same name in args, recursively.
    """
    if not tree or not isinstance(tree, tuple):
        return tree
    arg = _getaliasarg(tree)
    if arg is not None:
        return args[arg]
    return tuple(_expandargs(t, args) for t in tree)

def _expandaliases(aliases, tree, expanding, cache):
    """Expand aliases in tree, recursively.

    'aliases' is a dictionary mapping user defined aliases to
    revsetalias objects.
    """
    if not isinstance(tree, tuple):
        # Do not expand raw strings
        return tree
    alias = _getalias(aliases, tree)
    if alias is not None:
        if alias in expanding:
            raise error.ParseError(_('infinite expansion of revset alias "%s" '
                                     'detected') % alias.name)
        expanding.append(alias)
        if alias.name not in cache:
            cache[alias.name] = _expandaliases(aliases, alias.replacement,
                                               expanding, cache)
        result = cache[alias.name]
        expanding.pop()
        if alias.args is not None:
            l = getlist(tree[2])
            if len(l) != len(alias.args):
                raise error.ParseError(
                    _('invalid number of arguments: %s') % len(l))
            l = [_expandaliases(aliases, a, [], cache) for a in l]
            result = _expandargs(result, dict(zip(alias.args, l)))
    else:
        result = tuple(_expandaliases(aliases, t, expanding, cache)
                       for t in tree)
    return result

def findaliases(ui, tree):
    _checkaliasarg(tree)
    aliases = {}
    for k, v in ui.configitems('revsetalias'):
        alias = revsetalias(k, v)
        aliases[alias.name] = alias
    return _expandaliases(aliases, tree, [], {})

def parse(spec, lookup=None):
    p = parser.parser(tokenize, elements)
    return p.parse(spec, lookup=lookup)

def match(ui, spec, repo=None):
    if not spec:
        raise error.ParseError(_("empty query"))
    lookup = None
    if repo:
        lookup = repo.__contains__
    tree, pos = parse(spec, lookup)
    if (pos != len(spec)):
        raise error.ParseError(_("invalid token"), pos)
    if ui:
        tree = findaliases(ui, tree)
    weight, tree = optimize(tree, True)
    def mfunc(repo, subset):
        if util.safehasattr(subset, 'set'):
            return getset(repo, subset, tree)
        return getset(repo, baseset(subset), tree)
    return mfunc

def formatspec(expr, *args):
    '''
    This is a convenience function for using revsets internally, and
    escapes arguments appropriately. Aliases are intentionally ignored
    so that intended expression behavior isn't accidentally subverted.

    Supported arguments:

    %r = revset expression, parenthesized
    %d = int(arg), no quoting
    %s = string(arg), escaped and single-quoted
    %b = arg.branch(), escaped and single-quoted
    %n = hex(arg), single-quoted
    %% = a literal '%'

    Prefixing the type with 'l' specifies a parenthesized list of that type.

    >>> formatspec('%r:: and %lr', '10 or 11', ("this()", "that()"))
    '(10 or 11):: and ((this()) or (that()))'
    >>> formatspec('%d:: and not %d::', 10, 20)
    '10:: and not 20::'
    >>> formatspec('%ld or %ld', [], [1])
    "_list('') or 1"
    >>> formatspec('keyword(%s)', 'foo\\xe9')
    "keyword('foo\\\\xe9')"
    >>> b = lambda: 'default'
    >>> b.branch = b
    >>> formatspec('branch(%b)', b)
    "branch('default')"
    >>> formatspec('root(%ls)', ['a', 'b', 'c', 'd'])
    "root(_list('a\\x00b\\x00c\\x00d'))"
    '''

    def quote(s):
        return repr(str(s))

    def argtype(c, arg):
        if c == 'd':
            return str(int(arg))
        elif c == 's':
            return quote(arg)
        elif c == 'r':
            parse(arg) # make sure syntax errors are confined
            return '(%s)' % arg
        elif c == 'n':
            return quote(node.hex(arg))
        elif c == 'b':
            return quote(arg.branch())

    def listexp(s, t):
        l = len(s)
        if l == 0:
            return "_list('')"
        elif l == 1:
            return argtype(t, s[0])
        elif t == 'd':
            return "_intlist('%s')" % "\0".join(str(int(a)) for a in s)
        elif t == 's':
            return "_list('%s')" % "\0".join(s)
        elif t == 'n':
            return "_hexlist('%s')" % "\0".join(node.hex(a) for a in s)
        elif t == 'b':
            return "_list('%s')" % "\0".join(a.branch() for a in s)

        m = l // 2
        return '(%s or %s)' % (listexp(s[:m], t), listexp(s[m:], t))

    ret = ''
    pos = 0
    arg = 0
    while pos < len(expr):
        c = expr[pos]
        if c == '%':
            pos += 1
            d = expr[pos]
            if d == '%':
                ret += d
            elif d in 'dsnbr':
                ret += argtype(d, args[arg])
                arg += 1
            elif d == 'l':
                # a list of some type
                pos += 1
                d = expr[pos]
                ret += listexp(list(args[arg]), d)
                arg += 1
            else:
                raise util.Abort('unexpected revspec format character %s' % d)
        else:
            ret += c
        pos += 1

    return ret

def prettyformat(tree):
    def _prettyformat(tree, level, lines):
        if not isinstance(tree, tuple) or tree[0] in ('string', 'symbol'):
            lines.append((level, str(tree)))
        else:
            lines.append((level, '(%s' % tree[0]))
            for s in tree[1:]:
                _prettyformat(s, level + 1, lines)
            lines[-1:] = [(lines[-1][0], lines[-1][1] + ')')]

    lines = []
    _prettyformat(tree, 0, lines)
    output = '\n'.join(('  '*l + s) for l, s in lines)
    return output

def depth(tree):
    if isinstance(tree, tuple):
        return max(map(depth, tree)) + 1
    else:
        return 0

def funcsused(tree):
    if not isinstance(tree, tuple) or tree[0] in ('string', 'symbol'):
        return set()
    else:
        funcs = set()
        for s in tree[1:]:
            funcs |= funcsused(s)
        if tree[0] == 'func':
            funcs.add(tree[1][1])
        return funcs

class baseset(list):
    """Basic data structure that represents a revset and contains the basic
    operation that it should be able to perform.

    Every method in this class should be implemented by any smartset class.
    """
    def __init__(self, data=()):
        super(baseset, self).__init__(data)
        self._set = None

    def ascending(self):
        """Sorts the set in ascending order (in place).

        This is part of the mandatory API for smartset."""
        self.sort()

    def descending(self):
        """Sorts the set in descending order (in place).

        This is part of the mandatory API for smartset."""
        self.sort(reverse=True)

    def min(self):
        return min(self)

    def max(self):
        return max(self)

    def set(self):
        """Returns a set or a smartset containing all the elements.

        The returned structure should be the fastest option for membership
        testing.

        This is part of the mandatory API for smartset."""
        if not self._set:
            self._set = set(self)
        return self._set

    @util.propertycache
    def __contains__(self):
        return self.set().__contains__

    def __sub__(self, other):
        """Returns a new object with the substraction of the two collections.

        This is part of the mandatory API for smartset."""
        # If we are operating on 2 baseset, do the computation now since all
        # data is available. The alternative is to involve a lazyset, which
        # may be slow.
        if isinstance(other, baseset):
            other = other.set()
            return baseset([x for x in self if x not in other])

        return self.filter(lambda x: x not in other)

    def __and__(self, other):
        """Returns a new object with the intersection of the two collections.

        This is part of the mandatory API for smartset."""
        if isinstance(other, baseset):
            other = other.set()
        return baseset([y for y in self if y in other])

    def __add__(self, other):
        """Returns a new object with the union of the two collections.

        This is part of the mandatory API for smartset."""
        s = self.set()
        l = [r for r in other if r not in s]
        return baseset(list(self) + l)

    def isascending(self):
        """Returns True if the collection is ascending order, False if not.

        This is part of the mandatory API for smartset."""
        return False

    def isdescending(self):
        """Returns True if the collection is descending order, False if not.

        This is part of the mandatory API for smartset."""
        return False

    def filter(self, condition):
        """Returns this smartset filtered by condition as a new smartset.

        `condition` is a callable which takes a revision number and returns a
        boolean.

        This is part of the mandatory API for smartset."""
        return lazyset(self, condition)

class _orderedsetmixin(object):
    """Mixin class with utility methods for smartsets

    This should be extended by smartsets which have the isascending(),
    isdescending() and reverse() methods"""

    def _first(self):
        """return the first revision in the set"""
        for r in self:
            return r
        raise ValueError('arg is an empty sequence')

    def _last(self):
        """return the last revision in the set"""
        self.reverse()
        m = self._first()
        self.reverse()
        return m

    def min(self):
        """return the smallest element in the set"""
        if self.isascending():
            return self._first()
        return self._last()

    def max(self):
        """return the largest element in the set"""
        if self.isascending():
            return self._last()
        return self._first()

class lazyset(object):
    """Duck type for baseset class which iterates lazily over the revisions in
    the subset and contains a function which tests for membership in the
    revset
    """
    def __init__(self, subset, condition=lambda x: True):
        """
        condition: a function that decide whether a revision in the subset
                   belongs to the revset or not.
        """
        self._subset = subset
        self._condition = condition
        self._cache = {}

    def ascending(self):
        self._subset.sort()

    def descending(self):
        self._subset.sort(reverse=True)

    def min(self):
        return min(self)

    def max(self):
        return max(self)

    def __contains__(self, x):
        c = self._cache
        if x not in c:
            c[x] = x in self._subset and self._condition(x)
        return c[x]

    def __iter__(self):
        cond = self._condition
        for x in self._subset:
            if cond(x):
                yield x

    def __and__(self, x):
        return lazyset(self, x.__contains__)

    def __sub__(self, x):
        return lazyset(self, lambda r: r not in x)

    def __add__(self, x):
        return _addset(self, x)

    def __nonzero__(self):
        for r in self:
            return True
        return False

    def __len__(self):
        # Basic implementation to be changed in future patches.
        l = baseset([r for r in self])
        return len(l)

    def __getitem__(self, x):
        # Basic implementation to be changed in future patches.
        l = baseset([r for r in self])
        return l[x]

    def sort(self, reverse=False):
        if not util.safehasattr(self._subset, 'sort'):
            self._subset = baseset(self._subset)
        self._subset.sort(reverse=reverse)

    def reverse(self):
        self._subset.reverse()

    def set(self):
        return set([r for r in self])

    def isascending(self):
        return False

    def isdescending(self):
        return False

    def filter(self, l):
        return lazyset(self, l)

class orderedlazyset(_orderedsetmixin, lazyset):
    """Subclass of lazyset which subset can be ordered either ascending or
    descendingly
    """
    def __init__(self, subset, condition, ascending=True):
        super(orderedlazyset, self).__init__(subset, condition)
        self._ascending = ascending

    def filter(self, l):
        return orderedlazyset(self, l, ascending=self._ascending)

    def ascending(self):
        if not self._ascending:
            self.reverse()

    def descending(self):
        if self._ascending:
            self.reverse()

    def __and__(self, x):
        return orderedlazyset(self, x.__contains__,
                ascending=self._ascending)

    def __sub__(self, x):
        return orderedlazyset(self, lambda r: r not in x,
                ascending=self._ascending)

    def __add__(self, x):
        kwargs = {}
        if self.isascending() and x.isascending():
            kwargs['ascending'] = True
        if self.isdescending() and x.isdescending():
            kwargs['ascending'] = False
        return _addset(self, x, **kwargs)

    def sort(self, reverse=False):
        if reverse:
            if self._ascending:
                self._subset.sort(reverse=reverse)
        else:
            if not self._ascending:
                self._subset.sort(reverse=reverse)
        self._ascending = not reverse

    def isascending(self):
        return self._ascending

    def isdescending(self):
        return not self._ascending

    def reverse(self):
        self._subset.reverse()
        self._ascending = not self._ascending

class _addset(_orderedsetmixin):
    """Represent the addition of two sets

    Wrapper structure for lazily adding two structures without losing much
    performance on the __contains__ method

    If the ascending attribute is set, that means the two structures are
    ordered in either an ascending or descending way. Therefore, we can add
    them maintaining the order by iterating over both at the same time

    This class does not duck-type baseset and it's only supposed to be used
    internally
    """
    def __init__(self, revs1, revs2, ascending=None):
        self._r1 = revs1
        self._r2 = revs2
        self._iter = None
        self._ascending = ascending
        self._genlist = None

    def __len__(self):
        return len(self._list)

    @util.propertycache
    def _list(self):
        if not self._genlist:
            self._genlist = baseset(self._iterator())
        return self._genlist

    def filter(self, condition):
        if self._ascending is not None:
            return orderedlazyset(self, condition, ascending=self._ascending)
        return lazyset(self, condition)

    def ascending(self):
        if self._ascending is None:
            self.sort()
            self._ascending = True
        else:
            if not self._ascending:
                self.reverse()

    def descending(self):
        if self._ascending is None:
            self.sort(reverse=True)
            self._ascending = False
        else:
            if self._ascending:
                self.reverse()

    def __and__(self, other):
        filterfunc = other.__contains__
        if self._ascending is not None:
            return orderedlazyset(self, filterfunc, ascending=self._ascending)
        return lazyset(self, filterfunc)

    def __sub__(self, other):
        filterfunc = lambda r: r not in other
        if self._ascending is not None:
            return orderedlazyset(self, filterfunc, ascending=self._ascending)
        return lazyset(self, filterfunc)

    def __add__(self, other):
        """When both collections are ascending or descending, preserve the order
        """
        kwargs = {}
        if self._ascending is not None:
            if self.isascending() and other.isascending():
                kwargs['ascending'] = True
            if self.isdescending() and other.isdescending():
                kwargs['ascending'] = False
        return _addset(self, other, **kwargs)

    def _iterator(self):
        """Iterate over both collections without repeating elements

        If the ascending attribute is not set, iterate over the first one and
        then over the second one checking for membership on the first one so we
        dont yield any duplicates.

        If the ascending attribute is set, iterate over both collections at the
        same time, yielding only one value at a time in the given order.
        """
        if not self._iter:
            def gen():
                if self._ascending is None:
                    for r in self._r1:
                        yield r
                    s = self._r1.set()
                    for r in self._r2:
                        if r not in s:
                            yield r
                else:
                    iter1 = iter(self._r1)
                    iter2 = iter(self._r2)

                    val1 = None
                    val2 = None

                    choice = max
                    if self._ascending:
                        choice = min
                    try:
                        # Consume both iterators in an ordered way until one is
                        # empty
                        while True:
                            if val1 is None:
                                val1 = iter1.next()
                            if val2 is None:
                                val2 = iter2.next()
                            next = choice(val1, val2)
                            yield next
                            if val1 == next:
                                val1 = None
                            if val2 == next:
                                val2 = None
                    except StopIteration:
                        # Flush any remaining values and consume the other one
                        it = iter2
                        if val1 is not None:
                            yield val1
                            it = iter1
                        elif val2 is not None:
                            # might have been equality and both are empty
                            yield val2
                        for val in it:
                            yield val

            self._iter = _generatorset(gen())

        return self._iter

    def __iter__(self):
        if self._genlist:
            return iter(self._genlist)
        return iter(self._iterator())

    def __contains__(self, x):
        return x in self._r1 or x in self._r2

    def set(self):
        return self

    def sort(self, reverse=False):
        """Sort the added set

        For this we use the cached list with all the generated values and if we
        know they are ascending or descending we can sort them in a smart way.
        """
        if self._ascending is None:
            self._list.sort(reverse=reverse)
            self._ascending = not reverse
        else:
            if bool(self._ascending) == bool(reverse):
                self.reverse()

    def isascending(self):
        return self._ascending is not None and self._ascending

    def isdescending(self):
        return self._ascending is not None and not self._ascending

    def reverse(self):
        self._list.reverse()
        if self._ascending is not None:
            self._ascending = not self._ascending

class _generatorset(object):
    """Wrap a generator for lazy iteration

    Wrapper structure for generators that provides lazy membership and can
    be iterated more than once.
    When asked for membership it generates values until either it finds the
    requested one or has gone through all the elements in the generator

    This class does not duck-type baseset and it's only supposed to be used
    internally
    """
    def __init__(self, gen):
        """
        gen: a generator producing the values for the generatorset.
        """
        self._gen = gen
        self._cache = {}
        self._genlist = baseset([])
        self._finished = False

    def __contains__(self, x):
        if x in self._cache:
            return self._cache[x]

        # Use new values only, as existing values would be cached.
        for l in self._consumegen():
            if l == x:
                return True

        self._cache[x] = False
        return False

    def __iter__(self):
        if self._finished:
            for x in self._genlist:
                yield x
            return

        i = 0
        genlist = self._genlist
        consume = self._consumegen()
        while True:
            if i < len(genlist):
                yield genlist[i]
            else:
                yield consume.next()
            i += 1

    def _consumegen(self):
        for item in self._gen:
            self._cache[item] = True
            self._genlist.append(item)
            yield item
        self._finished = True

    def set(self):
        return self

    def sort(self, reverse=False):
        if not self._finished:
            for i in self:
                continue
        self._genlist.sort(reverse=reverse)

class _ascgeneratorset(_generatorset):
    """Wrap a generator of ascending elements for lazy iteration

    Same structure as _generatorset but stops iterating after it goes past
    the value when asked for membership and the element is not contained

    This class does not duck-type baseset and it's only supposed to be used
    internally
    """
    def __contains__(self, x):
        if x in self._cache:
            return self._cache[x]

        # Use new values only, as existing values would be cached.
        for l in self._consumegen():
            if l == x:
                return True
            if l > x:
                break

        self._cache[x] = False
        return False

class _descgeneratorset(_generatorset):
    """Wrap a generator of descending elements for lazy iteration

    Same structure as _generatorset but stops iterating after it goes past
    the value when asked for membership and the element is not contained

    This class does not duck-type baseset and it's only supposed to be used
    internally
    """
    def __contains__(self, x):
        if x in self._cache:
            return self._cache[x]

        # Use new values only, as existing values would be cached.
        for l in self._consumegen():
            if l == x:
                return True
            if l < x:
                break

        self._cache[x] = False
        return False

class spanset(_orderedsetmixin):
    """Duck type for baseset class which represents a range of revisions and
    can work lazily and without having all the range in memory

    Note that spanset(x, y) behave almost like xrange(x, y) except for two
    notable points:
    - when x < y it will be automatically descending,
    - revision filtered with this repoview will be skipped.

    """
    def __init__(self, repo, start=0, end=None):
        """
        start: first revision included the set
               (default to 0)
        end:   first revision excluded (last+1)
               (default to len(repo)

        Spanset will be descending if `end` < `start`.
        """
        self._start = start
        if end is not None:
            self._end = end
        else:
            self._end = len(repo)
        self._hiddenrevs = repo.changelog.filteredrevs

    def ascending(self):
        if self._start > self._end:
            self.reverse()

    def descending(self):
        if self._start < self._end:
            self.reverse()

    def __iter__(self):
        if self._start <= self._end:
            iterrange = xrange(self._start, self._end)
        else:
            iterrange = xrange(self._start, self._end, -1)

        if self._hiddenrevs:
            s = self._hiddenrevs
            for r in iterrange:
                if r not in s:
                    yield r
        else:
            for r in iterrange:
                yield r

    def __contains__(self, rev):
        return (((self._end < rev <= self._start)
                  or (self._start <= rev < self._end))
                and not (self._hiddenrevs and rev in self._hiddenrevs))

    def __nonzero__(self):
        for r in self:
            return True
        return False

    def __and__(self, x):
        if isinstance(x, baseset):
            x = x.set()
        if self._start <= self._end:
            return orderedlazyset(self, x.__contains__)
        else:
            return orderedlazyset(self, x.__contains__, ascending=False)

    def __sub__(self, x):
        if isinstance(x, baseset):
            x = x.set()
        if self._start <= self._end:
            return orderedlazyset(self, lambda r: r not in x)
        else:
            return orderedlazyset(self, lambda r: r not in x, ascending=False)

    def __add__(self, x):
        kwargs = {}
        if self.isascending() and x.isascending():
            kwargs['ascending'] = True
        if self.isdescending() and x.isdescending():
            kwargs['ascending'] = False
        return _addset(self, x, **kwargs)

    def __len__(self):
        if not self._hiddenrevs:
            return abs(self._end - self._start)
        else:
            count = 0
            start = self._start
            end = self._end
            for rev in self._hiddenrevs:
                if (end < rev <= start) or (start <= rev < end):
                    count += 1
            return abs(self._end - self._start) - count

    def __getitem__(self, x):
        # Basic implementation to be changed in future patches.
        l = baseset([r for r in self])
        return l[x]

    def sort(self, reverse=False):
        if bool(reverse) != (self._start > self._end):
            self.reverse()

    def reverse(self):
        # Just switch the _start and _end parameters
        if self._start <= self._end:
            self._start, self._end = self._end - 1, self._start - 1
        else:
            self._start, self._end = self._end + 1, self._start + 1

    def set(self):
        return self

    def isascending(self):
        return self._start < self._end

    def isdescending(self):
        return self._start > self._end

    def filter(self, l):
        if self._start <= self._end:
            return orderedlazyset(self, l)
        else:
            return orderedlazyset(self, l, ascending=False)

# tell hggettext to extract docstrings from these functions:
i18nfunctions = symbols.values()
                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/dist-packages/mercurial/revset.pyc                                                0100644 0000000 0000000 00000316400 13077704337 021142  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc        B   @   sê	  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z
 d  d l Z d  d l m Z d  d l Z d  d l Z d  d l Z d  d l Z d „  Z d „  Z d „  Z i d dó dô f d 6d d dõ f d 6d d dö d÷ f d 6d dø dù f d 6d dú dû dü f d 6d dý dþ dÿ f d 6d d ddf d! 6d" df d# 6d" df d$ 6d d df d% 6d d df d& 6d' d df d( 6d' d df d) 6d' d d	f d* 6d+ d d
f d- 6dd	 6d. dd f d/ 6d. dd f d0 6dd1 6Z e d% d( d# g ƒ Z d d2 „ Z d3 „  Z d4 „  Z d5 „  Z d6 „  Z d7 „  Z  d8 „  Z! d9 „  Z" d: „  Z# d; „  Z$ d< „  Z% d= „  Z& d> „  Z' d? „  Z( d@ „  Z) dA „  Z* dB „  Z e+ dC „ Z, dD „  Z- dE „  Z. dF „  Z/ dG „  Z0 dH „  Z1 dI „  Z2 dJ „  Z3 dK „  Z4 dL „  Z5 dM „  Z6 dN „  Z7 dO „  Z8 dP „  Z9 dQ „  Z: dR „  Z; dS „  Z< dT „  Z= dU „  Z> dV „  Z? e+ dW „ Z@ dX „  ZA dY „  ZB dZ „  ZC d[ „  ZD d\ „  ZE d] „  ZF d^ „  ZG d_ „  ZH d` „  ZI e+ da „ ZJ db „  ZK dc „  ZL dd „  ZM de „  ZN df „  ZO dg „  ZP dh „  ZQ di „  ZR dj „  ZS dk „  ZT dl „  ZU dm „  ZV dn „  ZW do „  ZX dp „  ZY dq „  ZZ dr „  Z[ ds „  Z\ dt „  Z du „  Z] dv „  Z^ dw „  Z_ dx „  Z` dy „  Za dz „  Zb d{ „  Zc d| „  Zd d} „  Ze d~ „  Zf d „  Zg d€ „  Zh d „  Zi d‚ „  Zj dƒ „  Zk d„ „  Zl d… „  Zm d† „  Zn d‡ „  Zo dˆ „  Zp d‰ „  Zq dŠ „  Zr d‹ „  Zs dŒ „  Zt d „  Zu iD e* dŽ 6eM d 6e d 6e- d 6e. d‘ 6e0 d’ 6e1 d“ 6e2 d” 6e3 d• 6e4 d– 6e5 d— 6eY d˜ 6e6 d™ 6e7 dš 6e: d› 6e; dœ 6e< d 6e= dž 6e> dŸ 6e? d  6eA d¡ 6eB d¢ 6eC d£ 6eD d¤ 6eE d¥ 6eF d¦ 6eG d§ 6eP d¨ 6eH d© 6eI dª 6eK d« 6eL d¬ 6eN d­ 6eQ d® 6eR d¯ 6eS d° 6e\ d± 6eT d² 6eV d³ 6eU d´ 6eO dµ 6eW d¶ 6eX d· 6eZ d¸ 6e[ d¹ 6e dº 6e] d» 6e^ d¼ 6e_ d½ 6e` d¾ 6ea d¿ 6ec dÀ 6ed dÁ 6ee dÂ 6ef dÃ 6eg dÄ 6ei dÅ 6ej dÆ 6el dÇ 6ek dÈ 6eh dÉ 6eo dÊ 6ep dË 6er dÌ 6eq dÍ 6es dÎ 6et dÏ 6eu dÐ 6Zv e dŽ d d d d‘ d’ d” d• d– d— d˜ d™ dš d› dœ dž dŸ d  d¡ d¢ d£ d¤ d¥ d¦ d§ d¨ d© dª d« d¬ d® d¯ d° d± d² d³ d´ dµ d¶ d· d¸ d¹ dº d» d¼ d½ d¾ d¿ dÀ dÁ dÂ dÃ dÄ dÅ dÆ dÇ dÈ dÉ dÊ dË dÌ dÍ dÎ dÏ dÐ gA ƒ Zw i e# d 6e$ d 6e! d0 6e" d/ 6e% d% 6e& d( 6e' d# 6e( d, 6e) d
 6e/ d 6eb d 6e_ d 6Zx dÑ „  Zy d
 df Zz dÓ „  Z{ d dÔ „ Z| dÕ e} f dÖ „  ƒ  YZ~ d× „  Z dØ „  Z€ dÙ „  Z dÚ „  Z‚ d dÛ „ Zƒ d dÜ „ Z	 dÝ „  Z„ dÞ „  Z… dß „  Z† dà „  Z‡ dá eˆ f dâ „  ƒ  YZ‰ dã e} f dä „  ƒ  YZŠ då e} f dæ „  ƒ  YZ‹ dç eŠ e‹ f dè „  ƒ  YZŒ dé eŠ f dê „  ƒ  YZ dë e} f dì „  ƒ  YZŽ dí eŽ f dî „  ƒ  YZ dï eŽ f dð „  ƒ  YZ dñ eŠ f dò „  ƒ  YZ‘ ev j’ ƒ  Z“ d S(  iÿÿÿÿN(   t   _c            s=   | r d p d ‰ |  j ‰  ‡  ‡ ‡ f d †  } t | ƒ  ƒ S(   s2   Like revlog.ancestors(), but supports followfirst.i   c          3   s!  d \ }  } g  } ˆ j ƒ  t j ˆ ƒ }  |  rQ |  j ƒ  } t j | | ƒ n  t t j	 g ƒ } x· | rt j
 | ƒ } | | k rf | rÃ | | k rÃ |  rÃ |  j ƒ  } t j | | ƒ qÃ n  | j | ƒ | VxA ˆ  j | ƒ ˆ  D]) } | t j	 k ré t j | | ƒ qé qé Wqf qf Wd  S(   N(   NN(   t   Nonet
   descendingt   utilt   dequet   popleftt   heapqt   heappusht   sett   nodet   nullrevt   heappopt   addt
   parentrevs(   t   revqueuet   revsnodet   ht   seent   currentt   parent(   t   clt   cutt   revs(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   iterate   s(    
	N(   R   t	   changelogt   _descgeneratorset(   t   repoR   t   followfirstR   (    (   R   R   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _revancestors   s    	c            s4   | r d p d ‰  ‡  ‡ ‡ f d †  } t | ƒ  ƒ S(   s3   Like revlog.descendants() but supports followfirst.i   c          3   s½   ˆ j  }  t ˆ ƒ } t j } | | k rC xŒ |  D] } | Vq1 Wnv t ˆ ƒ } xg |  j | d ƒ D]R } xI |  j | ƒ ˆ   D]4 } | | k r} | | k r} | j | ƒ | VPq} q} Wqc Wd  S(   Ni   (   R   t   minR	   R
   R   R   R   R   (   R   t   firstR
   t   iR   t   x(   R   R   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   7   s    		N(   R   t   _ascgeneratorset(   R   R   R   R   (    (   R   R   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _revdescendants3   s    c         C   s;  | s t  g  ƒ S|  j j } t  | ƒ } t ƒ  } i  } t | ƒ } t | ƒ } x | rÒ | j ƒ  } | | k r€ | j | ƒ n  | | ƒ }	 |	 | | <x6 |	 D]. }
 |
 | k r |
 | k r | j |
 ƒ q q WqR W| sã t  g  ƒ SxE t | ƒ D]7 } x. | | D]" }
 |
 | k r| j | ƒ qqWqð Wt  t | ƒ ƒ S(   sN   Return all paths between roots and heads, inclusive of both endpoint
    sets.(	   t   basesetR   R   R   R   t   popR   t   appendt   sorted(   R   t   rootst   headsR   t   visitt	   reachableR   t   minroott   revt   parentsR   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _revsbetweenK   s0    
		

i   t   groupi   t   )t   funct   (i   t   ancestort   ~R   t
   parentpostt   ^i   t   negatei   t   minust   -i   t   dagrangepret   dagranget   dagrangeposts   ::s   ..i   t   rangepret   ranget	   rangepostt   :i
   t   nott   !t   andt   &i   t   ort   |t   +i   t   listt   ,i    t   symbolt   stringt   endc         c   s¿  d t  |  ƒ } } x—| | k  r¬|  | } | j ƒ  r; nd| d k ry |  | | d !d k ry d d | f V| d 7} n&| d k r· |  | | d !d k r· d d | f V| d 7} nè| d k rÔ | d | f VnË| d	 k s| d
 k rÑ|  | | d !d k rÑ| d
 k r/| d 7} |  | } d „  } n	 d „  } | d 7} | } xT| | k  rµ|  | } | d k r}| d 7} qKn  | | k r¨d | |  | | !ƒ | f VPn  | d 7} qKWt j t d ƒ | ƒ ‚ nÎ| j ƒ  sû| d k sût | ƒ d k r‡| } | d 7} x€ | | k  r|  | } | j ƒ  pK| d k pKt | ƒ d k sRPn  | d k r€|  | d d k r€| d 8} Pn  | d 7} qW|  | | !} | t k r¸| d | f VnÂ d | k rl| rç| | ƒ rçd | | f Vqz| j	 d ƒ }	 xQ |	 d  D]E }
 |
 rd |
 | f Vn  | t  |
 ƒ 7} d d | f V| d 7} qW|	 d rzd |	 d | f Vqzn d | | f V| d 8} n t j t d ƒ | ƒ ‚ | d 7} q Wd d | f Vd S(   sØ   
    Parse a revset statement into a stream of tokens

    Check that @ is a valid unquoted token character (issue3686):
    >>> list(tokenize("@::"))
    [('symbol', '@', 0), ('::', None, 1), ('end', None, 3)]

    i    R@   i   s   ::i   t   .s   ..s   ():,-|&+!~^s   "'t   rs   r's   r"c         S   s   |  S(   N(    (   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   <lambda>Ÿ   s    c         S   s   |  j  d ƒ S(   Ns   string-escape(   t   decode(   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ¡   s    s   \RK   s   unterminated strings   ._@i   s   -._/@R9   RJ   iÿÿÿÿs   syntax errorRL   N(   s   r's   r"(
   t   lent   isspaceR   t   errort
   ParseErrorR    t   isalnumt   ordt   keywordst   split(   t   programt   lookupt   post   lt   cRP   t   st   dt   symt   partst   p(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   tokenizeƒ   s~    

##

	


*

* 

c         C   sA   |  r. |  d d k s& |  d d k r. |  d St  j | ƒ ‚ d  S(   Ni    RK   RJ   i   (   RS   RT   (   R    t   err(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   getstringØ   s    &c         C   s:   |  s
 g  S|  d d k r3 t  |  d ƒ |  d g S|  g S(   Ni    RH   i   i   (   t   getlist(   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRf   Ý   s
    c         C   sR   t  |  ƒ } t | ƒ | k  s< | d k rN t | ƒ | k rN t j | ƒ ‚ n  | S(   Ni    (   Rf   RQ   RS   RT   (   R    R   t   maxRd   R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   getargsä   s    0c         C   s\   | s t  j t d ƒ ƒ ‚ n  t | d |  | | d Œ } t j | d ƒ rR | St | ƒ S(   Ns   missing argumenti    i   R   (   RS   RT   R    t   methodsR   t   safehasattrR#   (   R   t   subsetR    R^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   getsetê   s    c         C   sa   |  | j  ƒ  } xJ d D]B } | | k r y |  | | j ƒ  SWqY t j k
 rU qY Xq q Wd  S(   Nt   sourcet   transplant_sourcet   rebase_source(   s   sourceRn   Ro   (   t   extraR,   RS   t   RepoLookupErrorR   (   R   RN   Rp   t   label(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _getrevsourceò   s    c         C   s|   |  | j  ƒ  } | d k rA t | ƒ t |  ƒ k rA t d g ƒ St | ƒ t |  ƒ k se | | k rr t | g ƒ St g  ƒ S(   Niÿÿÿÿ(   R,   RQ   R#   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   stringsetþ   s    $$c         C   s8   | t  k r( t j t d ƒ | ƒ ‚ n  t |  | | ƒ S(   Ns   can't use %s here(   t   symbolsRS   RT   R    Rt   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   symbolset  s    c         C   s£   t  |  j ƒ } t |  | | ƒ } t |  | | ƒ } | sA | rK t  g  ƒ S| d | d } } | | k  r… t |  | | d ƒ } n t |  | | d ƒ } | | @S(   Ni    iÿÿÿÿi   (   R#   R   Rl   t   spanset(   R   Rk   R    t   yR   t   mt   nRN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   rangeset  s    
c         C   sR   t  |  ƒ } t |  t |  | | ƒ t |  | | ƒ ƒ } | j ƒ  } | j | j ƒ S(   N(   Rw   R.   Rl   R   t   filtert   __contains__(   R   Rk   R    Rx   RN   t   xsR^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR;     s    *c         C   s   t  |  t  |  | | ƒ | ƒ S(   N(   Rl   (   R   Rk   R    Rx   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   andset   s    c         C   s0   t  |  | | ƒ } t  |  | | | ƒ } | | S(   N(   Rl   (   R   Rk   R    Rx   t   xlt   yl(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   orset#  s    c         C   s   | t  |  | | ƒ S(   N(   Rl   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   notset(  s    c         C   s   t  j t d ƒ ƒ ‚ d  S(   Ns    can't use a list in this context(   RS   RT   R    (   R   Rk   t   at   b(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   listset+  s    c         C   sY   | d d k r8 | d t  k r8 t  | d |  | | ƒ St j t d ƒ | d ƒ ‚ d  S(   Ni    RJ   i   s   not a function: %s(   Ru   RS   RT   R    (   R   Rk   R„   R…   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR1   .  s     c         C   s(   t  | t d ƒ ƒ } t |  | | d ƒ S(   sâ   ``adds(pattern)``
    Changesets that add a file matching pattern.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file or a
    directory.
    s   adds requires a patterni   (   Re   R    t   checkstatus(   R   Rk   R    t   pat(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   adds5  s    	c            sº   t  | ƒ } t ˆ  ƒ ‰ d } x^ ‡  ‡ f d †  | Dƒ D]C } x: | D]2 } | d k rd ˆ  | } qE | j ˆ  | ƒ } qE Wq8 W| d k	 r° | j ƒ  | k r° t | j ƒ  g ƒ St g  ƒ S(   sè   ``ancestor(*changeset)``
    A greatest common ancestor of the changesets.

    Accepts 0 or more changesets.
    Will return empty list when passed no args.
    Greatest common ancestor of a single changeset is that changeset.
    c         3   s!   |  ] } t  ˆ  ˆ | ƒ Vq d  S(   N(   Rl   (   t   .0R   (   R   t   rl(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>O  s    N(   Rf   Rw   R   R3   R,   R#   (   R   Rk   R    R\   t   ancR   RN   (    (   R   R‹   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR3   A  s    	 c         C   sJ   t  |  t |  ƒ | ƒ } | s( t g  ƒ St |  | | ƒ } | j | j ƒ S(   N(   Rl   Rw   R#   R   R|   R}   (   R   Rk   R    R   t   argsR^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt
   _ancestorsZ  s
    
c         C   s   t  |  | | ƒ S(   sP   ``ancestors(set)``
    Changesets that are ancestors of a changeset in set.
    (   RŽ   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   ancestorsa  s    c         C   s   t  |  | | d t ƒS(   NR   (   RŽ   t   True(   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _firstancestorsg  s    c         C   s¿   y t  | d ƒ } Wn, t t f k
 rB t j t d ƒ ƒ ‚ n Xt ƒ  } |  j } xW t |  t	 | ƒ | ƒ D]= } x' t
 | ƒ D] } | j | ƒ d } q W| j | ƒ qn W| j | j ƒ S(   sg   ``set~n``
    Changesets that are the Nth ancestor (first parents only) of a changeset
    in set.
    i   s   ~ expects a numberi    (   t   intt	   TypeErrort
   ValueErrorRS   RT   R    R   R   Rl   R#   R>   R   R   R|   R}   (   R   Rk   R    Rz   t   psR   RN   R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   ancestorspecl  s    		c            sL   t  j t | t d ƒ ƒ ƒ } t | ƒ \ } } ‰  | j ‡  ‡ f d †  ƒ S(   s7   ``author(string)``
    Alias for ``user(string)``.
    s   author requires a stringc            s   ˆ  t  j ˆ |  j ƒ  ƒ ƒ S(   N(   t   encodingt   lowert   user(   R    (   t   matcherR   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   „  s    (   R—   R˜   Re   R    t   _substringmatcherR|   (   R   Rk   R    Rz   t   kindt   pattern(    (   Rš   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   author}  s    c   
      C   s  |  j  } t | d d t d ƒ ƒ } t |  t |  ƒ | d ƒ j ƒ  } t | ƒ d k rÆ t | ƒ d k rt t g  ƒ St t |  | t	 ƒ ƒ } g  | j
 ƒ  D]$ } | | k r™ | | k r™ | ^ q™ } n t |  t |  ƒ | d ƒ } t t j | | | j ƒ ƒ }	 t | |	 j ƒ S(   s  ``only(set, [set])``
    Changesets that are ancestors of the first set that are not ancestors
    of any other head in the repo. If a second set is specified, the result
    is ancestors of the first set that are not ancestors of the second set
    (i.e. ::<set1> - ::<set2>).
    i   i   s   only takes one or two argumentsi    (   R   Rh   R    Rl   Rw   R   RQ   R#   R"   t   Falset   headrevst   ancestormodt   missingancestorsR   t   lazysetR}   (
   R   Rk   R    R   R   t   includet   descendantsR,   t   excludet   results(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   only†  s    	"
'c         C   sC   t  | t d ƒ ƒ j ƒ  } t t j |  | ƒ ƒ } | j | j ƒ S(   s   ``bisect(string)``
    Changesets marked in the specified bisect status:

    - ``good``, ``bad``, ``skip``: csets explicitly marked as good/bad/skip
    - ``goods``, ``bads``      : csets topologically good/bad
    - ``range``              : csets taking part in the bisection
    - ``pruned``             : csets that are goods, bads or skipped
    - ``untested``           : csets whose fate is yet unknown
    - ``ignored``            : csets ignored due to DAG topology
    - ``current``            : the cset currently being bisected
    s   bisect requires a string(   Re   R    R˜   R   t   hbisectt   getR|   R}   (   R   Rk   R    t   statust   state(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   bisectž  s    c         C   s   t  |  | | ƒ S(   N(   R­   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   bisected±  s    c            s  t  | d d t d ƒ ƒ } | r[t | d t d ƒ ƒ } t | ƒ \ } } } | d k r¸ |  j j | d	 ƒ ‰  ˆ  s’ t j t d ƒ | ƒ ‚ n  |  ˆ  j	 ƒ  ‰  | j
 ‡  f d †  ƒ St ƒ  } x9 |  j j ƒ  D]( \ }	 ‰  | |	 ƒ rÑ | j ˆ  ƒ qÑ qÑ W| st j t d ƒ | ƒ ‚ n  t ƒ  }
 x% | D] ‰  |
 j |  ˆ  j	 ƒ  ƒ q/W| |
 @Sn  t g  |  j j ƒ  D] } |  | j	 ƒ  ^ qnƒ } | j
 | j ƒ S(
   sú   ``bookmark([name])``
    The named bookmark or all bookmarks.

    If `name` starts with `re:`, the remainder of the name is treated as
    a regular expression. To match a bookmark that actually starts with `re:`,
    use the prefix `literal:`.
    i    i   s"   bookmark takes one or no argumentss)   the argument to bookmark must be a stringt   literals   bookmark '%s' does not existc            s
   |  ˆ  k S(   N(    (   RN   (   t   bmrev(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   È  s    s"   no bookmarks exist that match '%s'N(   Rh   R    Re   t   _stringmatchert
   _bookmarksRª   R   R   t   AbortR,   R|   R   t	   iteritemsR   t   valuesR}   (   R   Rk   R    R   t   bmRœ   R   Rš   t	   matchrevst   namet   bmrevsRN   t   bms(    (   R°   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   bookmark´  s2    	
		,c            s  y t  | d ƒ ‰  Wn t j k
 r) ni Xt ˆ  ƒ \ } } ‰ | d k ry | ˆ j ƒ  k r’ | j ‡ ‡ f d †  ƒ Sn | j ‡ ‡ f d †  ƒ St ˆ t ˆ ƒ | ƒ ‰ t ƒ  ‰  x% ˆ D] } ˆ  j	 ˆ | j
 ƒ  ƒ qº Wˆ j ƒ  ‰ | j ‡  ‡ ‡ f d †  ƒ S(   s4  ``branch(string or set)``
    All changesets belonging to the given branch or the branches of the given
    changesets.

    If `string` starts with `re:`, the remainder of the name is treated as
    a regular expression. To match a branch that actually starts with `re:`,
    use the prefix `literal:`.
    t    R¯   c            s   ˆ  ˆ |  j  ƒ  ƒ S(   N(   t   branch(   RN   (   Rš   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   î  s    c            s   ˆ  ˆ |  j  ƒ  ƒ S(   N(   R½   (   RN   (   Rš   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ð  s    c            s    |  ˆ k p ˆ |  j  ƒ  ˆ  k S(   N(   R½   (   RN   (   R…   R   R^   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ÷  s    (   Re   RS   RT   R±   t	   branchmapR|   Rl   Rw   R   R   R½   (   R   Rk   R    Rœ   R   RN   (    (   R…   Rš   R   R^   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR½   Ú  s    		c         C   s3   t  | d d t d ƒ ƒ t j |  d ƒ } | | @S(   s•   ``bumped()``
    Mutable changesets marked as successors of public changesets.

    Only non-public and non-obsolete changesets can be `bumped`.
    i    s   bumped takes no argumentst   bumped(   Rh   R    t   obsmodt   getrevs(   R   Rk   R    R¿   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¿   ù  s    c         C   sA   y |  j  j } Wn& t k
 r8 t j t d ƒ ƒ ‚ n X| | @S(   sZ   ``bundle()``
    Changesets in the bundle.

    Bundle must be specified by the -R option.s$   no bundle provided - specify with -R(   R   t
   bundlerevst   AttributeErrorR   R³   R    (   R   Rk   R    RÂ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   bundle  s
    c            s:   t  j ˆ ƒ d k ‰ ‡  ‡ ‡ ‡ f d †  } | j | ƒ S(   NR   c            sA  d  } d  } ˆ |  } | s# ˆ r… t j ˆ j ˆ j ƒ  ˆ g d | ƒ} | j ƒ  r… t | j ƒ  ƒ d k r… | j ƒ  d } q… n  | d  k	 rª | | j ƒ  k rÕ t Sn+ x( | j ƒ  D] } | | ƒ r· Pq· q· Wt Sˆ j	 | j
 ƒ  j ƒ  | j ƒ  ƒ ˆ  } | d  k	 r| | k r=t Sn! x | D] } | | ƒ r#t Sq#Wd  S(   Nt   ctxi   i    (   R   t   matchmodt   matcht   roott   getcwdt   anypatsRQ   t   filesRŸ   R«   t   p1R	   R   (   R    Ry   t   fnameR]   t   fRË   (   t   fieldt   hassetRˆ   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   matches  s*    
'%((   RÆ   t   patkindR|   (   R   Rk   Rˆ   RÏ   RÑ   (    (   RÏ   RÐ   Rˆ   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR‡     s    c         C   s‘   t  ƒ  } | s t | ƒ S|  j j } t | ƒ } xS | D]K } | | k rP q8 n  x0 | | ƒ D]" } | | k r] | j | ƒ q] q] Wq8 Wt | ƒ S(   N(   R   R#   R   R   R   R   (   R   t   narrowt	   parentsett   cst   prt   minrevRN   Rb   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   _children/  s    	
c         C   s8   t  |  t |  ƒ | ƒ j ƒ  } t |  | | ƒ } | | @S(   sA   ``children(set)``
    Child changesets of changesets in set.
    (   Rl   R#   R   RØ   (   R   Rk   R    R^   RÕ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   children=  s    c            s/   t  | d d t d ƒ ƒ | j ‡  f d †  ƒ S(   s*   ``closed()``
    Changeset is closed.
    i    s   closed takes no argumentsc            s   ˆ  |  j  ƒ  S(   N(   t   closesbranch(   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   K  s    (   Rh   R    R|   (   R   Rk   R    (    (   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   closedE  s    c            s4   t  | t d ƒ ƒ ‰  ‡  ‡ f d †  } | j | ƒ S(   sV  ``contains(pattern)``
    The revision's manifest contains a file matching pattern (but might not
    modify it). See :hg:`help patterns` for information about file patterns.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file exactly
    for efficiency.
    s   contains requires a patternc            s    t  j ˆ  ƒ sD t j ˆ j ˆ j ƒ  ˆ  ƒ } | ˆ |  k rœ t SnX ˆ |  } t  j ˆ j ˆ j ƒ  ˆ  g d | ƒ} x$ | j ƒ  D] } | | ƒ r‚ t Sq‚ Wt	 S(   NRÅ   (
   RÆ   RÒ   t   pathutilt	   canonpathRÈ   RÉ   R   RÇ   t   manifestRŸ   (   R    t   patsR]   Ry   RÎ   (   Rˆ   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ   Y  s    
'(   Re   R    R|   (   R   Rk   R    RÑ   (    (   Rˆ   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   containsM  s    
c            sk   d ‰ t | d d t d ƒ ƒ } | rC t | d t d ƒ ƒ ‰ n  ‡ ‡ f d †  ‰  | j ‡  f d †  ƒ S(   s¬   ``converted([id])``
    Changesets converted from the given identifier in the old repository if
    present, or all converted changesets if no identifier is specified.
    i    i   s#   converted takes one or no argumentss   converted requires a revisionc            sA   ˆ  |  j  ƒ  j d d  ƒ } | d  k	 o@ ˆ d  k p@ | j ˆ ƒ S(   Nt   convert_revision(   Rp   Rª   R   t
   startswith(   RN   Rm   (   R   R,   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _matchvaluex  s    c            s
   ˆ  |  ƒ S(   N(    (   RN   (   Rã   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   |  s    N(   R   Rh   R    Re   R|   (   R   Rk   R    R\   (    (   Rã   R   R,   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   convertedh  s    	c            s=   t  | t d ƒ ƒ } t j | ƒ ‰  | j ‡  ‡ f d †  ƒ S(   sQ   ``date(interval)``
    Changesets within the interval, see :hg:`help dates`.
    s   date requires a stringc            s   ˆ  ˆ |  j  ƒ  d ƒ S(   Ni    (   t   date(   R    (   t   dmR   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   …  s    (   Re   R    R   t	   matchdateR|   (   R   Rk   R    t   ds(    (   Ræ   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRå   ~  s    c            s=   t  j t | t d ƒ ƒ ƒ ‰  ‡  ‡ f d †  } | j | ƒ S(   sZ   ``desc(string)``
    Search commit message for string. The match is case-insensitive.
    s   desc requires a stringc            s#   ˆ |  } ˆ  t  j | j ƒ  ƒ k S(   N(   R—   R˜   t   description(   R    R]   (   Rè   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ   Ž  s    
(   R—   R˜   Re   R    R|   (   R   Rk   R    RÑ   (    (   Rè   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   desc‡  s    c         C   s”   t  |  t |  ƒ | ƒ } | s( t g  ƒ St |  | | ƒ } | j ƒ  | j ƒ  } t | | j d t ƒt | | j d t ƒ} t | d „  d t ƒS(   Nt	   ascendingc         S   s   t  S(   N(   R   (   RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ¤  s    (	   Rl   Rw   R#   R"   Rë   R   t   orderedlazysetR}   R   (   R   Rk   R    R   R   R^   t	   subsetsett   result(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _descendants”  s    

c         C   s   t  |  | | ƒ S(   sT   ``descendants(set)``
    Changesets which are descendants of changesets in set.
    (   Rï   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¥   ¦  s    c         C   s   t  |  | | d t ƒS(   NR   (   Rï   R   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _firstdescendants¬  s    c         C   s   | d k	 r- t |  t |  ƒ | ƒ j ƒ  } n t |  t |  ƒ | ƒ j ƒ  } t ƒ  } x™ | D]‘ } t |  | ƒ } d } xs | d k	 rë | d k r t ƒ  } n  | j | ƒ | | k sÂ | | k rÓ | j | ƒ Pn  | } t |  | ƒ } qy Wq[ W| j	 | j
 ƒ S(   sÛ   ``destination([set])``
    Changesets that were created by a graft, transplant or rebase operation,
    with the given revisions specified as the source.  Omitting the optional set
    is the same as passing all().
    N(   R   Rl   Rw   R   t   getallRs   RH   R%   t   updateR|   R}   (   R   Rk   R    R   t   destsRN   t   srct   lineage(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   destination±  s"    !	c         C   s;   t  | d d t d ƒ ƒ t j |  d ƒ } | j | j ƒ S(   sd   ``divergent()``
    Final successors of changesets with an alternative set of final successors.
    i    s   divergent takes no argumentst	   divergent(   Rh   R    RÀ   RÁ   R|   R}   (   R   Rk   R    R÷   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR÷   Ý  s    c            s;   t  | d d t d ƒ ƒ ˆ j ‰  | j ‡  ‡ f d †  ƒ S(   s)   ``draft()``
    Changeset in draft phase.i    s   draft takes no argumentsc            s   ˆ  j  ˆ |  ƒ t j k S(   N(   t   phaset   phasest   draft(   RN   (   t   pcR   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ì  s    (   Rh   R    t   _phasecacheR|   (   R   Rk   R    (    (   Rû   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRú   æ  s    	c         C   s3   t  | d d t d ƒ ƒ t j |  d ƒ } | | @S(   sJ   ``extinct()``
    Obsolete changesets with obsolete descendants only.
    i    s   extinct takes no argumentst   extinct(   Rh   R    RÀ   RÁ   (   R   Rk   R    t   extincts(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRý   î  s    c            s«   t  | d d t d ƒ ƒ } t | d t d ƒ ƒ ‰ d	 ‰ t | ƒ d k r} t | d t d ƒ ƒ ‰ t ˆ ƒ \ } ‰ ‰ n  ‡ ‡ ‡ ‡ f d †  ‰  | j ‡  f d †  ƒ S(
   s3  ``extra(label, [value])``
    Changesets with the given label in the extra metadata, with the given
    optional value.

    If `value` starts with `re:`, the remainder of the value is treated as
    a regular expression. To match a value that actually starts with `re:`,
    use the prefix `literal:`.
    i   i   s.   extra takes at least 1 and at most 2 argumentsi    s(   first argument to extra must be a strings)   second argument to extra must be a stringc            s6   ˆ |  j  ƒ  } ˆ  | k o5 ˆ d  k p5 ˆ | ˆ  ƒ S(   N(   Rp   R   (   RN   Rp   (   Rr   Rš   R   t   value(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRã     s    c            s
   ˆ  |  ƒ S(   N(    (   RN   (   Rã   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO     s    N(   Rh   R    Re   R   RQ   R±   R|   (   R   Rk   R    R\   Rœ   (    (   Rã   Rr   Rš   R   Rÿ   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRp   ÷  s    c   	      C   s  t  | t d ƒ ƒ } t ƒ  } t j | ƒ s„ t j |  j |  j ƒ  | ƒ } |  j	 | ƒ } x¬ | D] } | j
 | j | ƒ ƒ qa Wn… t j |  j |  j ƒ  | g d |  d ƒ} xW |  d D]K } | | ƒ rº |  j	 | ƒ } x' | D] } | j
 | j | ƒ ƒ qâ Wqº qº W| j | j ƒ S(   sö  ``filelog(pattern)``
    Changesets connected to the specified filelog.

    For performance reasons, visits only revisions mentioned in the file-level
    filelog, rather than filtering through all changesets (much faster, but
    doesn't include deletes or duplicate changes). For a slower, more accurate
    result, use ``file()``.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file exactly
    for efficiency.
    s   filelog requires a patternRÅ   N(   Re   R    R   RÆ   RÒ   RÜ   RÝ   RÈ   RÉ   t   fileR   t   linkrevRÇ   R   R|   R}   (	   R   Rk   R    Rˆ   R^   RÎ   t   flt   frRy   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   filelog  s    	+!c         C   s   t  |  | | ƒ S(   s2   ``first(set, [n])``
    An alias for limit().
    (   t   limit(   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   3  s    c   	      C   sØ   t  | d d t d ƒ | ƒ } |  d } | r§ t | d t d ƒ | ƒ } | | k rš | | } t d „  | j d | ƒ Dƒ ƒ } | j | j ƒ  ƒ qÈ t g  ƒ Sn! t |  t | j	 ƒ  g ƒ | ƒ } | j
 | j ƒ S(   Ni    i   s#   %s takes no arguments or a filenameRM   s   %s expected a filenamec         s   s   |  ] } | j  ƒ  Vq d  S(   N(   R,   (   RŠ   RÅ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>@  s    R   (   Rh   R    Re   R   R   R   R  R#   R   R,   R|   R}   (	   R   Rk   R    R¸   R   R\   R]   t   cxR^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _follow9  s    

"!c         C   s   t  |  | | d ƒ S(   sÁ   ``follow([file])``
    An alias for ``::.`` (ancestors of the working copy's first parent).
    If a filename is specified, the history of the given file is followed,
    including copies.
    t   follow(   R  (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR  J  s    c         C   s   t  |  | | d d t ƒS(   Nt   _followfirstR   (   R  R   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR	  R  s    c         C   s   t  | d d t d ƒ ƒ | S(   s9   ``all()``
    All changesets, the same as ``0:tip``.
    i    s   all takes no arguments(   Rh   R    (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRñ   X  s    c            ss   y" t  j t | t d ƒ ƒ ƒ ‰  Wn/ t  j k
 rS } t j t d ƒ | ƒ ‚ n X‡  ‡ f d †  } | j | ƒ S(   s×   ``grep(regex)``
    Like ``keyword(string)`` but accepts a regex. Use ``grep(r'...')``
    to ensure special escape characters are handled correctly. Unlike
    ``keyword(string)``, the match is case-sensitive.
    s   grep requires a strings   invalid match pattern: %sc            sN   ˆ |  } x= | j  ƒ  | j ƒ  | j ƒ  g D] } ˆ  j | ƒ r- t Sq- Wt S(   N(   RË   R™   Ré   t   searchR   RŸ   (   R    R]   t   e(   t   grR   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ   l  s
    
)(   t   ret   compileRe   R    RS   RT   R|   (   R   Rk   R    R  RÑ   (    (   R  R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   grep`  s    "c   	         s½  t  | d d t d ƒ ƒ } g  g  g  ‰ ‰ ‰ t ‰ d \ ‰ ‰  x<| D]4} t | t d ƒ ƒ } | d  | d } } | d k r” ˆ j | ƒ nÃ | d k r° ˆ j | ƒ n§ | d k rÌ ˆ j | ƒ n‹ | d	 k rˆ d  k	 rü t j t d
 ƒ ƒ ‚ n  | ‰ nR | d k r>ˆ  d  k	 r5t j t d ƒ ƒ ‚ n  | ‰  n t j t d ƒ | ƒ ‚ ˆ rH t j	 | ƒ d k rH t
 ‰ qH qH Wˆ  sd ‰  n  ‡  ‡ ‡ ‡ ‡ ‡ ‡ f d †  } | j | ƒ S(   Ni   iÿÿÿÿs*   _matchfiles requires at least one arguments%   _matchfiles requires string argumentsi   s   p:s   i:s   x:s   r:s)   _matchfiles expected at most one revisions   d:s-   _matchfiles expected at most one default modes   invalid _matchfiles prefix: %sR   t   globc            s²   d  } ˆ |  } | s) ˆ r‡ ˆ d  k r‡ | } ˆ d  k	 rN ˆ ˆ pG d  } n  t j ˆ j ˆ j ƒ  ˆ d ˆ d ˆ d | d ˆ  ƒ} n  x$ | j ƒ  D] } | | ƒ r” t Sq” Wt S(   NR¤   R¦   RÅ   t   default(   R   RÆ   RÇ   RÈ   RÉ   RË   R   RŸ   (   R    Ry   R]   RÅ   RÎ   (   R  t   excRÐ   t   incRß   R   R,   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ   ¥  s    
!(   NN(   Rh   R    RŸ   R   Re   R%   RS   RT   RÆ   RÒ   R   R|   (	   R   Rk   R    R\   t   argR^   t   prefixRÿ   RÑ   (    (   R  R  RÐ   R  Rß   R   R,   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _matchfilesu  s8    			!c         C   s/   t  | t d ƒ ƒ } t |  | d d | f ƒ S(   sâ   ``file(pattern)``
    Changesets affecting files matched by pattern.

    For a faster but less accurate result, consider using ``filelog()``
    instead.

    This predicate uses ``glob:`` as the default kind of pattern.
    s   file requires a patternRK   s   p:(   Re   R    R  (   R   Rk   R    Rˆ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   hasfileµ  s    
c            sx   t  | d d t d ƒ ƒ t ƒ  } x= ˆ  j ƒ  j ƒ  D]) \ } } | j ‡  f d †  | Dƒ ƒ q5 Wt | ƒ j | j ƒ S(   s5   ``head()``
    Changeset is a named branch head.
    i    s   head takes no argumentsc         3   s   |  ] } ˆ  | j  ƒ  Vq d  S(   N(   R,   (   RŠ   R   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>Ê  s    (	   Rh   R    R   R¾   R´   Rò   R#   R|   R}   (   R   Rk   R    t   hsR…   t   ls(    (   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   headÂ  s
    	!c         C   s,   t  |  | | ƒ } t |  | | ƒ } | | S(   s?   ``heads(set)``
    Members of set with no children in set.
    (   Rl   R-   (   R   Rk   R    R^   R•   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR(   Í  s    c         C   s3   t  | d d t d ƒ ƒ t j |  d ƒ } | | @S(   s(   ``hidden()``
    Hidden changesets.
    i    s   hidden takes no argumentst   visible(   Rh   R    t   repoviewt
   filterrevs(   R   Rk   R    t
   hiddenrevs(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   hiddenÕ  s    c            s=   t  j t | t d ƒ ƒ ƒ ‰  ‡  ‡ f d †  } | j | ƒ S(   sˆ   ``keyword(string)``
    Search commit message, user name, and names of changed files for
    string. The match is case-insensitive.
    s   keyword requires a stringc            sC   ˆ |  } t  j ‡  f d †  | j ƒ  | j ƒ  | j ƒ  g Dƒ ƒ S(   Nc         3   s$   |  ] } ˆ  t  j | ƒ k Vq d  S(   N(   R—   R˜   (   RŠ   t   t(   t   kw(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>è  s    (   R   t   anyRË   R™   Ré   (   RN   R]   (   R!  R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ   æ  s    
$(   R—   R˜   Re   R    R|   (   R   Rk   R    RÑ   (    (   R!  R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   keywordÞ  s    c   
      C   s$  t  | d d t d ƒ ƒ } y> d } t | ƒ d k rX t t | d t d ƒ ƒ ƒ } n  Wn, t t f k
 r‡ t j t d ƒ ƒ ‚ n X| j	 ƒ  } t
 |  t |  ƒ | d ƒ } t g  ƒ } t | ƒ } xU t | ƒ D]G } y, | j ƒ  }	 |	 | k r| j |	 ƒ n  WqÕ t k
 rPqÕ XqÕ W| S(   sE   ``limit(set, [n])``
    First n members of set, defaulting to 1.
    i   i   s#   limit requires one or two argumentss   limit requires a numbers   limit expects a numberi    (   Rh   R    RQ   R’   Re   R“   R”   RS   RT   R   Rl   Rw   R#   t   itert   xranget   nextR%   t   StopIteration(
   R   Rk   R    R\   t   limt   sst   ost   bst   itRx   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR  í  s&    &	c   
      C   s.  t  | d d t d ƒ ƒ } y> d } t | ƒ d k rX t t | d t d ƒ ƒ ƒ } n  Wn, t t f k
 r‡ t j t d ƒ ƒ ‚ n X| j	 ƒ  } t
 |  t |  ƒ | d ƒ } | j ƒ  t g  ƒ } t | ƒ } xU t | ƒ D]G } y, | j ƒ  }	 |	 | k r| j |	 ƒ n  Wqß t k
 r%Pqß Xqß W| S(   sC   ``last(set, [n])``
    Last n members of set, defaulting to 1.
    i   i   s"   last requires one or two argumentss   last requires a numbers   last expects a numberi    (   Rh   R    RQ   R’   Re   R“   R”   RS   RT   R   Rl   Rw   t   reverseR#   R$  R%  R&  R%   R'  (
   R   Rk   R    R\   R(  R)  R*  R+  R,  Rx   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   last  s(    &
	c         C   sP   t  |  t |  ƒ | ƒ } | rF | j ƒ  } | | k rF t | g ƒ Sn  t g  ƒ S(   sD   ``max(set)``
    Changeset with highest revision number in set.
    (   Rl   Rw   Rg   R#   (   R   Rk   R    R*  Ry   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   maxrev$  s    c            s8   t  | d d t d ƒ ƒ |  j ‰  | j ‡  f d †  ƒ S(   s4   ``merge()``
    Changeset is a merge changeset.
    i    s   merge takes no argumentsc            s   ˆ  j  |  ƒ d d k S(   Ni   iÿÿÿÿ(   R   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   6  s    (   Rh   R    R   R|   (   R   Rk   R    (    (   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   merge/  s    	c            sÌ   t  | d d t d ƒ ƒ |  j } | s2 t g  ƒ St | ƒ ‰  d g t |  ƒ ˆ  ‰ x[ | j d ˆ  d ƒ D]C } x: | j | ƒ D]) } | ˆ  k r‚ ˆ | ˆ  c d 7<q‚ q‚ Wql W| j ‡  ‡ f d †  ƒ S(   s?   ``branchpoint()``
    Changesets with more than one child.
    i    s   branchpoint takes no argumentst   starti   c            s   ˆ |  ˆ  d k S(   Ni   (    (   RN   (   t   baserevt   parentscount(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   G  s    (	   Rh   R    R   R#   R   RQ   R   R   R|   (   R   Rk   R    R   RN   Rb   (    (   R2  R3  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   branchpoint8  s    	
c         C   sP   t  |  t |  ƒ | ƒ } | rF | j ƒ  } | | k rF t | g ƒ Sn  t g  ƒ S(   sC   ``min(set)``
    Changeset with lowest revision number in set.
    (   Rl   Rw   R   R#   (   R   Rk   R    R*  Ry   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR×   I  s    c         C   s(   t  | t d ƒ ƒ } t |  | | d ƒ S(   sè   ``modifies(pattern)``
    Changesets modifying files matched by pattern.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file or a
    directory.
    s   modifies requires a patterni    (   Re   R    R‡   (   R   Rk   R    Rˆ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   modifiesT  s    	c            s¨   t  | d d t d ƒ ƒ } t | d t d ƒ ƒ } t | ƒ d k rY |  | j ƒ  ‰  n9 d ‰  |  j j | ƒ } | d k	 r’ |  j j | ƒ ‰  n  | j ‡  f d †  ƒ S(   sZ   ``id(string)``
    Revision non-ambiguously specified by the given hex string prefix.
    i   s   id requires one argumenti    s   id requires a stringi(   c            s
   |  ˆ  k S(   N(    (   RN   (   t   rn(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   p  s    N(	   Rh   R    Re   RQ   R,   R   R   t   _partialmatchR|   (   R   Rk   R    R\   Rz   t   pm(    (   R6  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   node_`  s    c         C   s3   t  | d d t d ƒ ƒ t j |  d ƒ } | | @S(   s:   ``obsolete()``
    Mutable changeset with a newer version.i    s   obsolete takes no argumentst   obsolete(   Rh   R    RÀ   RÁ   (   R   Rk   R    t	   obsoletes(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR:  r  s    c            s   | d k	 r- t ˆ  t ˆ  ƒ | ƒ j ƒ  } n t ˆ  t ˆ  ƒ | ƒ j ƒ  } ‡  f d †  } t g  | D] } | | ƒ ^ qd ƒ } | j | j ƒ S(   s  ``origin([set])``
    Changesets that were specified as a source for the grafts, transplants or
    rebases that created the given revisions.  Omitting the optional set is the
    same as passing all().  If a changeset created by these operations is itself
    specified as a source for one of these operations, only the source changeset
    for the first operation is selected.
    c            sU   t  ˆ  |  ƒ } | d  k r d  Sx/ t rP t  ˆ  | ƒ } | d  k rG | S| } q" Wd  S(   N(   Rs   R   R   (   R,   Rô   t   prev(   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   _firstsrc‡  s    	N(   R   Rl   Rw   R   Rñ   R|   R}   (   R   Rk   R    R   R=  RN   t   o(    (   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   originz  s    !%c         C   sV  d d l  } t | d d t d ƒ ƒ } | rF t | d t d ƒ ƒ pI d } |  j j | p^ d | pg d	 ƒ } | j | ƒ \ } } | j |  |  | g  ƒ \ } } | rË g  | D] }	 |  j |	 ƒ ^ q­ } n  | j	 |  i  | ƒ }
 |  j j
 ƒ  t j |  |
 d
 | ƒ} |  j j ƒ  |  j } t g  | j D] } | j | ƒ ^ q(ƒ } | j | j ƒ S(   s}   ``outgoing([path])``
    Changesets not found in the specified destination repository, or the
    default push location.
    iÿÿÿÿNi    i   s"   outgoing takes one or no argumentss#   outgoing requires a repository pathR¼   s   default-pushR  t	   onlyheads(   t   hgRh   R    Re   t   uit
   expandpatht   parseurlt   addbranchrevsRZ   t   peert
   pushbuffert	   discoveryt   findcommonoutgoingt	   popbufferR   R   t   missingR,   R|   R}   (   R   Rk   R    RA  R\   t   destt   branchesR   t   checkoutR,   t   othert   outgoingR   RN   R>  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRP  –  s    %!%	+c            s   | d k r8 |  | j ƒ  j ƒ  ‰  | j ‡  f d †  ƒ St ƒ  } |  j } x: t |  t |  ƒ | ƒ D]  } | j | j	 | ƒ d ƒ qc W| | @S(   sS   ``p1([set])``
    First parent of changesets in set, or the working directory.
    c            s
   |  ˆ  k S(   N(    (   RN   (   Rb   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ³  s    i    N(
   R   RÌ   R,   R|   R   R   Rl   Rw   R   R   (   R   Rk   R    R•   R   RN   (    (   Rb   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÌ   ­  s    		c            s»   | d k rd |  | j ƒ  } y* | d j ƒ  ‰  | j ‡  f d †  ƒ SWqd t k
 r` t g  ƒ SXn  t ƒ  } |  j } x: t |  t	 |  ƒ | ƒ D]  } | j
 | j | ƒ d ƒ q W| | @S(   sT   ``p2([set])``
    Second parent of changesets in set, or the working directory.
    i   c            s
   |  ˆ  k S(   N(    (   RN   (   Rb   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   Ã  s    N(   R   R-   R,   R|   t
   IndexErrorR#   R   R   Rl   Rw   R   R   (   R   Rk   R    R•   R   RN   (    (   Rb   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   p2»  s    		c         C   s‡   | d k r4 t d „  |  | j ƒ  Dƒ ƒ } | | @St ƒ  } |  j } x6 t |  t |  ƒ | ƒ D] } | j | j | ƒ ƒ q_ W| | @S(   sg   ``parents([set])``
    The set of all parents for all changesets in set, or the working directory.
    c         s   s   |  ] } | j  ƒ  Vq d  S(   N(   R,   (   RŠ   Rb   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>Ò  s    N(	   R   t   tupleR-   R   R   Rl   Rw   Rò   R   (   R   Rk   R    R•   R   RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR-   Í  s     		c         C   s  y) t  | d ƒ } | d k r( t ‚ n  Wn, t t f k
 rW t j t d ƒ ƒ ‚ n Xt ƒ  } |  j } x© t |  t	 | ƒ | ƒ D] } | d k r¥ | j
 | ƒ qƒ | d k rÎ | j
 | j | ƒ d ƒ qƒ | d k rƒ | j | ƒ } t | ƒ d k r| j
 | d ƒ qqƒ qƒ W| | @S(   s†   ``set^0``
    The set.
    ``set^1`` (or ``set^``), ``set^2``
    First or second parent, respectively, of all changesets in set.
    i   i    i   s   ^ expects a number 0, 1, or 2(   i    i   i   (   R’   R”   R“   RS   RT   R    R   R   Rl   R#   R   R   RQ   (   R   Rk   R    Rz   R•   R   RN   R-   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt
   parentspecÛ  s$    		c         C   s6   y t  |  | | ƒ SWn t j k
 r1 t g  ƒ SXd S(   s&  ``present(set)``
    An empty set, if any revision in set isn't found; otherwise,
    all revisions in set.

    If any of specified revisions is not present in the local repository,
    the query is normally aborted. But this predicate allows the query
    to continue even in such cases.
    N(   Rl   RS   Rq   R#   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   presentô  s    	c            s;   t  | d d t d ƒ ƒ ˆ j ‰  | j ‡  ‡ f d †  ƒ S(   s+   ``public()``
    Changeset in public phase.i    s   public takes no argumentsc            s   ˆ  j  ˆ |  ƒ t j k S(   N(   Rø   Rù   t   public(   RN   (   Rû   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO     s    (   Rh   R    Rü   R|   (   R   Rk   R    (    (   Rû   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRV    s    	c         C   sŠ  d d l  } t | d d t d ƒ ƒ } d } t | ƒ d k r[ t | d t d ƒ ƒ } n  | d k rz |  d j ƒ  } n  d } t | ƒ d	 k r® t | d	 t d
 ƒ ƒ } n  |  j j | pÀ d ƒ } | j | ƒ \ } } | j	 |  |  | g  ƒ \ } }	 | r$g  | D] }
 |  j
 |
 ƒ ^ q} n  | j |  i  | ƒ } | j
 | ƒ } | |  k r€|  | j ƒ  } | | k r€t | g ƒ Sn  t g  ƒ S(   sÉ   ``remote([id [,path]])``
    Local revision that corresponds to the given identifier in a
    remote repository, if present. Here, the '.' identifier is a
    synonym for the current local branch.
    iÿÿÿÿNi    i   s%   remote takes one, two or no argumentsRM   s   remote requires a string idR¼   i   s!   remote requires a repository pathR  (   RA  Rh   R    RQ   Re   R½   RB  RC  RD  RE  RZ   RF  R,   R#   (   R   Rk   R    RA  R\   t   qRL  RM  R   RN  R,   RO  Rz   RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   remote
  s,    %c         C   s(   t  | t d ƒ ƒ } t |  | | d ƒ S(   sè   ``removes(pattern)``
    Changesets which remove files matching pattern.

    The pattern without explicit kind like ``glob:`` is expected to be
    relative to the current directory and match against a file or a
    directory.
    s   removes requires a patterni   (   Re   R    R‡   (   R   Rk   R    Rˆ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   removes-  s    	c            sƒ   t  | d d t d ƒ ƒ ‰  y# t t ˆ  d t d ƒ ƒ ƒ ‰  Wn, t t f k
 rl t j t d ƒ ƒ ‚ n X| j ‡  f d †  ƒ S(   sD   ``rev(number)``
    Revision with the given numeric identifier.
    i   s   rev requires one argumenti    s   rev requires a numbers   rev expects a numberc            s
   |  ˆ  k S(   N(    (   RN   (   R\   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   E  s    (	   Rh   R    R’   Re   R“   R”   RS   RT   R|   (   R   Rk   R    (    (   R\   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR,   9  s    #c      
      s©  t  | d d t d ƒ ƒ } t ˆ t ˆ j ƒ | d ƒ ‰ d g } t | ƒ d k rw t | d t d ƒ ƒ j ƒ  } n  g  } xq | D]i } | d k r¬ | d d d	 g 7} q„ | d
 k rË | d d
 g 7} q„ | d k rà d } n  | j | ƒ q„ Wt	 | ƒ } d | k r%d | k r%| j
 d ƒ n  d d d d	 d d d d d d
 g
 ‰  ‡  f d †  } t | ƒ } | j d | ƒ g  ‰ i
 ‡ f d †  d 6‡ f d †  d 6‡ f d †  d	 6‡ f d †  d 6‡ f d †  d 6‡ f d †  d 6‡ f d †  d 6‡ f d †  d 6‡ f d †  d 6‡ f d †  d
 6} xU | D]M }	 | j |	 d! ƒ }
 |
 d! k rgt j t d ƒ |	 ƒ ‚ n  ˆ j |
 ƒ q'W‡ f d †  ‰ ‡ ‡ ‡ f d  †  } | j | ƒ S("   s  ``matching(revision [, field])``
    Changesets in which a given set of fields match the set of fields in the
    selected revision or set.

    To match more than one field pass the list of fields to match separated
    by spaces (e.g. ``author description``).

    Valid fields are most regular revision fields and some special fields.

    Regular revision fields are ``description``, ``author``, ``branch``,
    ``date``, ``files``, ``phase``, ``parents``, ``substate``, ``user``
    and ``diff``.
    Note that ``author`` and ``user`` are synonyms. ``diff`` refers to the
    contents of the revision. Two revisions matching their ``diff`` will
    also match their ``files``.

    Special fields are ``summary`` and ``metadata``:
    ``summary`` matches the first line of the description.
    ``metadata`` is equivalent to matching ``description user date``
    (i.e. it matches the main metadata fields).

    ``metadata`` is the default field which is used when no fields are
    specified. You can match more than one field at a time.
    i   i   s   matching takes 1 or 2 argumentsi    t   metadatas1   matching requires a string as its second argumentR™   Ré   Rå   t   diffRË   Rž   t   summaryRø   R-   R½   t   substatec            s0   y ˆ  j  |  ƒ SWn t k
 r+ t ˆ  ƒ SXd  S(   N(   t   indexR”   RQ   (   RÎ   (   t
   fieldorder(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   fieldkeyfunc†  s    t   keyc            s   ˆ  |  j  ƒ  S(   N(   R™   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   “  s    c            s   ˆ  |  j  ƒ  S(   N(   R½   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ”  s    c            s   ˆ  |  j  ƒ  S(   N(   Rå   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   •  s    c            s   ˆ  |  j  ƒ  S(   N(   Ré   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   –  s    c            s   ˆ  |  j  ƒ  S(   N(   RË   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   —  s    c            s   ˆ  |  j  ƒ  S(   N(   R-   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ˜  s    c            s   ˆ  |  j  ƒ  S(   N(   Rø   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ™  s    c            s   ˆ  |  j  S(   N(   R]  (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   š  s    c            s   ˆ  |  j  ƒ  j ƒ  d S(   Ni    (   Ré   t
   splitlines(   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ›  s    c            s   t  ˆ  |  j d t ƒ ƒ S(   Nt   git(   RH   R[  R   (   RN   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   œ  s    s,   unexpected field name passed to matching: %sc            s   g  ˆ  D] } | |  ƒ ^ q S(   N(    (   RN   RÎ   (   t   getfieldfuncs(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ¨  s    c            sm   xf ˆ D]^ } ˆ | ƒ } t  } x9 t ˆ  ƒ D]+ \ } } | | | |  ƒ k r, t } q, q, W| r t  Sq Wt S(   N(   R   t	   enumerateRŸ   (   R    R,   t   targetRÇ   Rz   RÎ   (   Rd  t   getinfoR   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ   ª  s    N(   Rh   R    Rl   R#   R   RQ   Re   RX   R%   R   t   discardRH   t   sortRª   R   RS   RT   R|   (   R   Rk   R    R\   t	   fieldlistt   fieldsRÏ   R`  t   _funcst   infot   getfieldRÑ   (    (   R_  Rd  Rg  R   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   matchingG  sX    	
	c         C   s    t  |  | | ƒ } | j ƒ  | S(   s/   ``reverse(set)``
    Reverse order of set.
    (   Rl   R-  (   R   Rk   R    R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR-  ·  s    
c         C   si   t  |  t |  ƒ | ƒ j ƒ  } t g  | D] } | | j ƒ  k r( | ^ q( ƒ } t |  | | ƒ } | | S(   sJ   ``roots(set)``
    Changesets in set with no parent changeset in set.
    (   Rl   Rw   R   R#   RØ   (   R   Rk   R    R^   RN   RÕ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR'   ¿  s    1c            s;   t  | d d t d ƒ ƒ ˆ j ‰  | j ‡  ‡ f d †  ƒ S(   s+   ``secret()``
    Changeset in secret phase.i    s   secret takes no argumentsc            s   ˆ  j  ˆ |  ƒ t j k S(   N(   Rø   Rù   t   secret(   R    (   Rû   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   Î  s    (   Rh   R    Rü   R|   (   R   Rk   R    (    (   Rû   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRp  È  s    	c         C   sº  t  | d d t d ƒ ƒ } d } t | ƒ d k rO t | d t d ƒ ƒ } n  | d } | j ƒ  } g  } d „  } t |  | | ƒ } | d g k r£ | j ƒ  | S| d g k rÆ | j d	 t ƒ | SxÆ| D]¾} |  | }	 g  }
 x‹| D]ƒ} | d k r|
 j | ƒ qê | d k r)|
 j | ƒ qê | d
 k rK|
 j |	 j	 ƒ  ƒ qê | d k rs|
 j | |	 j	 ƒ  ƒ ƒ qê | d k r•|
 j |	 j
 ƒ  ƒ qê | d k r½|
 j | |	 j
 ƒ  ƒ ƒ qê | d k rß|
 j |	 j ƒ  ƒ qê | d k r|
 j | |	 j ƒ  ƒ ƒ qê | d k r-|
 j |	 j ƒ  d ƒ qê | d k rT|
 j |	 j ƒ  d ƒ qê t j t d ƒ | ƒ ‚ qê W|
 j | ƒ | j |
 ƒ qÍ W| j ƒ  t g  | D] }
 |
 d ^ q£ƒ S(   s”  ``sort(set[, [-]key...])``
    Sort set by keys. The default sort order is ascending, specify a key
    as ``-key`` to sort in descending order.

    The keys can be:

    - ``rev`` for the revision number,
    - ``branch`` for the branch name,
    - ``desc`` for the commit message (description),
    - ``user`` for user name (``author`` can be used as an alias),
    - ``date`` for the commit date
    i   i   s"   sort requires one or two argumentsR,   s   sort spec must be a stringi    c         S   s   d j  d „  |  Dƒ ƒ S(   NR¼   c         s   s%   |  ] } t  d  t | ƒ ƒ Vq d S(   iÿ   N(   t   chrRV   (   RŠ   R]   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>è  s    (   t   join(   R^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   invertç  s    s   -revR-  R½   s   -branchRê   s   -descs   user authors   -user -authorRå   s   -dates   unknown sort key %riÿÿÿÿ(   Rh   R    RQ   Re   RX   Rl   Ri  R   R%   R½   Ré   R™   Rå   RS   RT   R#   (   R   Rk   R    R\   t   keysR^   Rs  R   RN   R]   R  t   k(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRi  Ð  sX    
	


c         C   sš   |  j  d ƒ rn |  d }  y t j |  ƒ } Wn/ t j k
 r] } t j t d ƒ | ƒ ‚ n Xd |  | j f S|  j  d ƒ rŠ |  d }  n  d |  |  j f S(   sÁ  
    accepts a string, possibly starting with 're:' or 'literal:' prefix.
    returns the matcher name, pattern, and matcher function.
    missing or unknown prefixes are treated as literal matches.

    helper for tests:
    >>> def test(pattern, *tests):
    ...     kind, pattern, matcher = _stringmatcher(pattern)
    ...     return (kind, pattern, [bool(matcher(t)) for t in tests])

    exact matching (no prefix):
    >>> test('abcdefg', 'abc', 'def', 'abcdefg')
    ('literal', 'abcdefg', [False, False, True])

    regex matching ('re:' prefix)
    >>> test('re:a.+b', 'nomatch', 'fooadef', 'fooadefbar')
    ('re', 'a.+b', [False, False, True])

    force exact matches ('literal:' prefix)
    >>> test('literal:re:foobar', 'foobar', 're:foobar')
    ('literal', 're:foobar', [False, True])

    unknown prefixes are ignored and treated as literals
    >>> test('foo:bar', 'foo', 'bar', 'foo:bar')
    ('literal', 'foo:bar', [False, False, True])
    s   re:i   s   invalid regular expression: %sR  s   literal:i   R¯   (   Râ   R  R  RS   RT   R    R
  t   __eq__(   R   t   regexR  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR±     s    
c            s@   t  ˆ  ƒ \ } ‰  } | d k r3 ‡  f d †  } n  | ˆ  | f S(   NR¯   c            s
   ˆ  |  k S(   N(    (   R^   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   9  s    (   R±   (   R   Rœ   Rš   (    (   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR›   6  s    c         C   sK  t  | d d t d ƒ ƒ } |  j } | rt | d t d ƒ ƒ } t | ƒ \ } } } | d k rÀ |  j j j | d ƒ } | d k r¤ t	 j
 t d ƒ | ƒ ‚ n  t |  | j ƒ  g ƒ }	 qCt g  |  j ƒ  D]' \ }
 } | |
 ƒ rÐ | j | ƒ ^ qÐ ƒ }	 n@ t g  |  j ƒ  D]' \ }
 } |
 d k r| j | ƒ ^ qƒ }	 | |	 @S(	   s  ``tag([name])``
    The specified tag by name, or all tagged revisions if no name is given.

    If `name` starts with `re:`, the remainder of the name is treated as
    a regular expression. To match a tag that actually starts with `re:`,
    use the prefix `literal:`.
    i    i   s   tag takes one or no argumentss$   the argument to tag must be a stringR¯   s   tag '%s' does not existt   tipN(   Rh   R    R   Re   R±   t
   _tagscachet   tagsRª   R   R   R³   R   R,   t   tagslist(   R   Rk   R    R   R   R   Rœ   Rš   t   tnR^   R   Rz   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   tag<  s    		
C@c         C   s   t  |  | | ƒ S(   N(   R}  (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   taggedX  s    c         C   s3   t  | d d t d ƒ ƒ t j |  d ƒ } | | @S(   sH   ``unstable()``
    Non-obsolete changesets with obsolete ancestors.
    i    s   unstable takes no argumentst   unstable(   Rh   R    RÀ   RÁ   (   R   Rk   R    t	   unstables(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR  [  s    c         C   s   t  |  | | ƒ S(   s  ``user(string)``
    User name contains string. The match is case-insensitive.

    If `string` starts with `re:`, the remainder of the string is treated as
    a regular expression. To match a user that actually contains `re:`, use
    the prefix `literal:`.
    (   Rž   (   R   Rk   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR™   e  s    c         C   s€   t  | d ƒ } | s t g  ƒ Sg  | j d ƒ D] } |  | j ƒ  ^ q/ } | j ƒ  } t g  | D] } | | k ra | ^ qa ƒ S(   Ns   internal errort    (   Re   R#   RX   R,   R   (   R   Rk   R    R^   RN   R  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _listp  s    
,c         C   s|   t  | d ƒ } | s t g  ƒ Sg  | j d ƒ D] } t | ƒ ^ q/ } | j ƒ  } t g  | D] } | | k r] | ^ q] ƒ S(   Ns   internal errorR  (   Re   R#   RX   R’   R   (   R   Rk   R    R^   RN   R  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _intlisty  s    
(c         C   s‘   t  | d ƒ } | s t g  ƒ S|  j } g  | j d ƒ D] } | j t j | ƒ ƒ ^ q8 } | j ƒ  } t g  | D] } | | k rr | ^ qr ƒ S(   Ns   internal errorR  (   Re   R#   R   RX   R,   R	   t   binR   (   R   Rk   R    R^   R   RN   R  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _hexlist‚  s    
	4R‰   t   allR   R‘   Rž   R¨   R­   R®   R»   R½   R4  R¿   RÄ   RÙ   RÛ   Rà   Rä   Rå   Rê   R¥   Rð   Rö   R÷   Rú   Rý   Rp   R   R  R   R  R	  R  R  R(   R  t   idR#  R.  R  R  Rg   R0  R   R5  R:  R?  RP  RÌ   RR  R-   RU  RV  RX  RY  R,   R-  R'   Ri  Rp  Ro  R}  R~  R™   R  R‚  Rƒ  R…  c         C   s  |  d  k r d |  f Sd } | r+ d } n  |  d } | d k re t d |  d d |  d f f | ƒ S| d k r‹ t d	 d+ |  d f | ƒ S| d k r± t d	 d, |  d f | ƒ S| d k r× t d d- |  d f | ƒ S| d k rý t d |  d d. f | ƒ S| d k r3t d d t |  d t d ƒ ƒ f | ƒ S| d k rI| |  f S| d k r?t |  d t ƒ \ } } t |  d t ƒ \ } } d „  } t | | ƒ }	 | | | ƒ rÖ|	 d	 d/ d | d | d d f f f S| | | ƒ r|	 d	 d0 d | d | d d f f f S| | k r,|	 | | | f f S|	 | | | f f S| d k rµt |  d t ƒ \ } } t |  d t ƒ \ } } | | k  r™| | } } n  t | | ƒ | | | f f S| d k rít |  d | ƒ }
 |
 d | |
 d f f S| d k r$t |  d | ƒ }
 |
 d | |
 d f f S| d k rAt |  d | ƒ S| d k r| d k rÐd |  d f } |  d d d k r›t d  | |  d d f | ƒ S|  d d d k rÐt d | |  d d f | ƒ Sn  t |  d | ƒ \ } } t |  d | ƒ \ } } | | | | | f f S| d	 k rút |  d t d! ƒ ƒ } t |  d | ƒ \ } } | d" k rld# }	 ns | d$ k rd% }	 n^ | d& k r–d' }	 nI | d( k r¯d | }	 n0 | d) k rÄd }	 n | d* k rÙd# }	 n d }	 |	 | | |  d | f f Sd |  f S(1   Ni    i   g      à?R8   RC   RA   i   R:   R1   RJ   R   R<   R¥   R=   R>   RK   t   0R?   Rx  R7   R9   s   can't negate thats   string symbol negatec         S   st   |  d d k os t  |  d t d ƒ ƒ d k os | d d k os | d d d k os t  | d d t d ƒ ƒ d k S(   Ni    R1   i   s   not a symbolR   RA   (   Re   R    (   R   t   bases(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   isonlyE  s
    R¨   RH   RE   R5   R/   s'   dagrange range list parent ancestorspecR   R;   s   not a symbols>   author branch closed date desc file grep keyword outgoing useri
   s   modifies adds removesi   Rà   id   R3   s   reverse limit firstRi  (   s   symbols	   ancestors(   s   symbols   descendants(   s   stringRˆ  (   s   strings   tip(   s   symbols   only(   s   symbols   only(   R   t   optimizeRe   R    R   R   RŸ   Rg   (   R    t   smallt
   smallbonust   opt   wat   tat   wbt   tbRŠ  t   wR>  t   postRÎ   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR‹  (  s–    
	
$$
	((!					t	   _aliasargc         C   sF   t  |  ƒ d k rB |  d  t k rB |  d d d k rB |  d d Sd S(   sc   If tree matches ('func', ('symbol', '_aliasarg'), ('string', X))
    return X, None otherwise.
    i   i   i    RK   i   N(   RQ   R•  R   (   t   tree(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _getaliasarg†  s    "c         C   s{   t  |  t ƒ rw t |  ƒ } | d k	 rV | s: | | k rV t j t d ƒ d ƒ ‚ n  x |  D] } t | | ƒ q] Wn  d S(   s…   Check tree contains no _aliasarg construct or only ones which
    value is in known. Used to avoid alias placeholders injection.
    s   not a function: %sR•  N(   t
   isinstanceRS  R—  R   RS   RT   R    t   _checkaliasarg(   R–  t   knownR  R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR™    s    t   revsetaliasc           B   s&   e  Z e j d  ƒ Z d Z d „  Z RS(   s   ^([^(]+)\(([^)]+)\)$c         C   s  |  j  j | ƒ } | r¬ | j d ƒ |  _ d d | j d ƒ f f |  _ g  | j d ƒ j d ƒ D] } | j ƒ  ^ qa |  _ xE |  j D] } | j | d | f ƒ } q† Wn | |  _ d | f |  _ t	 | ƒ \ |  _
 } | t | ƒ k rt j t d ƒ | ƒ ‚ n  t |  j
 |  j ƒ d S(	   se   Aliases like:

        h = heads(default)
        b($1) = ancestors($1) - ancestors(default)
        i   R1   RJ   i   RI   s   _aliasarg(%r)s   invalid tokenN(   t   funcreR
  R/   R¸   R–  RX   t   stripR   t   replacet   parset   replacementRQ   RS   RT   R    R™  (   t   selfR¸   Rÿ   Ry   R    R  R[   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __init__ž  s    4 	N(   t   __name__t
   __module__R  R  Rœ  R   R   R¢  (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR›  š  s   c         C   s  t  | t ƒ r| r| d d k r{ t | ƒ d k r{ | d } |  j | ƒ } | r{ | j d k r{ | j | k r{ | Sn  | d d k rt | ƒ d k r| d d d k rt | d ƒ d k r| d d } |  j | ƒ } | r| j d k	 r| j | d  k r| Sqqn  d S(   sR   If tree looks like an unexpanded alias, return it. Return None
    otherwise.
    i    RJ   i   i   R1   N(   R˜  RS  RQ   Rª   R   R   R–  (   t   aliasesR–  R¸   t   alias(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt	   _getalias·  s    "
$"*(c            sU   |  s t  |  t ƒ r |  St |  ƒ } | d k	 r; ˆ  | St ‡  f d †  |  Dƒ ƒ S(   sg   Replace _aliasarg instances with the substitution value of the
    same name in args, recursively.
    c         3   s   |  ] } t  | ˆ  ƒ Vq d  S(   N(   t   _expandargs(   RŠ   R   (   R   (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>Ò  s    N(   R˜  RS  R—  R   (   R–  R   R  (    (   R   s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¨  É  s    c            s  t  | t ƒ s | St ˆ  | ƒ } | d k	 rY| ˆ k rY t j t d ƒ | j ƒ ‚ n  ˆ j | ƒ | j ˆ k r— t	 ˆ  | j
 ˆ ˆ ƒ ˆ | j <n  ˆ | j } ˆ j ƒ  | j d k	 r{t | d ƒ } t | ƒ t | j ƒ k r
t j t d ƒ t | ƒ ƒ ‚ n  g  | D] } t	 ˆ  | g  ˆ ƒ ^ q} t | t t | j | ƒ ƒ ƒ } q{n" t ‡  ‡ ‡ f d †  | Dƒ ƒ } | S(   s   Expand aliases in tree, recursively.

    'aliases' is a dictionary mapping user defined aliases to
    revsetalias objects.
    s0   infinite expansion of revset alias "%s" detectedi   s   invalid number of arguments: %sc         3   s$   |  ] } t  ˆ  | ˆ ˆ ƒ Vq d  S(   N(   t   _expandaliases(   RŠ   R   (   R¥  t   cachet	   expanding(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>ð  s   N(   R˜  RS  R§  R   RS   RT   R    R¸   R%   R©  R   R$   R   Rf   RQ   R¨  t   dictt   zip(   R¥  R–  R«  Rª  R¦  Rî   R\   R„   (    (   R¥  Rª  R«  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR©  Ô  s.    
('c         C   s_   t  | ƒ i  } x9 |  j d ƒ D]( \ } } t | | ƒ } | | | j <q  Wt | | g  i  ƒ S(   NR›  (   R™  t   configitemsR›  R¸   R©  (   RB  R–  R¥  Ru  t   vR¦  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   findaliasesô  s    
c         C   s%   t  j  t t ƒ } | j |  d | ƒS(   NRZ   (   t   parserRc   t   elementsRŸ  (   t   specRZ   Rb   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRŸ  ü  s    c            s¸   | s t  j t d ƒ ƒ ‚ n  d  } | r6 | j } n  t | | ƒ \ ‰  } | t | ƒ k rx t  j t d ƒ | ƒ ‚ n  |  r t |  ˆ  ƒ ‰  n  t ˆ  t	 ƒ \ } ‰  ‡  f d †  } | S(   Ns   empty querys   invalid tokenc            s8   t  j | d ƒ r" t |  | ˆ  ƒ St |  t | ƒ ˆ  ƒ S(   NR   (   R   Rj   Rl   R#   (   R   Rk   (   R–  (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   mfunc  s    (
   RS   RT   R    R   R}   RŸ  RQ   R°  R‹  R   (   RB  R³  R   RZ   R[   t   weightR´  (    (   R–  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÇ      s    c            s@  d „  ‰ ‡ f d †  ‰  ‡  ‡ f d †  ‰ d } d } d } xý | t  |  ƒ k  r;|  | } | d k r$| d 7} |  | } | d k r” | | 7} q.| d k rÄ | ˆ  | | | ƒ 7} | d 7} q.| d	 k r| d 7} |  | } | ˆ t | | ƒ | ƒ 7} | d 7} q.t j d
 | ƒ ‚ n
 | | 7} | d 7} q? W| S(   s/  
    This is a convenience function for using revsets internally, and
    escapes arguments appropriately. Aliases are intentionally ignored
    so that intended expression behavior isn't accidentally subverted.

    Supported arguments:

    %r = revset expression, parenthesized
    %d = int(arg), no quoting
    %s = string(arg), escaped and single-quoted
    %b = arg.branch(), escaped and single-quoted
    %n = hex(arg), single-quoted
    %% = a literal '%'

    Prefixing the type with 'l' specifies a parenthesized list of that type.

    >>> formatspec('%r:: and %lr', '10 or 11', ("this()", "that()"))
    '(10 or 11):: and ((this()) or (that()))'
    >>> formatspec('%d:: and not %d::', 10, 20)
    '10:: and not 20::'
    >>> formatspec('%ld or %ld', [], [1])
    "_list('') or 1"
    >>> formatspec('keyword(%s)', 'foo\xe9')
    "keyword('foo\\xe9')"
    >>> b = lambda: 'default'
    >>> b.branch = b
    >>> formatspec('branch(%b)', b)
    "branch('default')"
    >>> formatspec('root(%ls)', ['a', 'b', 'c', 'd'])
    "root(_list('a\x00b\x00c\x00d'))"
    c         S   s   t  t |  ƒ ƒ S(   N(   t   reprt   str(   R^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   quote3  s    c            s   |  d k r t  t | ƒ ƒ S|  d k r2 ˆ  | ƒ S|  d k rP t | ƒ d | S|  d k ro ˆ  t j | ƒ ƒ S|  d k r‹ ˆ  | j ƒ  ƒ Sd  S(   NR_   R^   RN   s   (%s)Rz   R…   (   R·  R’   RŸ  R	   t   hexR½   (   R]   R  (   R¸  (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   argtype6  s    

c            sý   t  |  ƒ } | d k r d S| d k r9 ˆ  | |  d ƒ S| d k r` d d j d „  |  Dƒ ƒ S| d k r} d	 d j |  ƒ S| d
 k r¤ d d j d „  |  Dƒ ƒ S| d k rË d	 d j d „  |  Dƒ ƒ S| d } d ˆ |  |  | ƒ ˆ |  | | ƒ f S(   Ni    s	   _list('')i   R_   s   _intlist('%s')R  c         s   s!   |  ] } t  t | ƒ ƒ Vq d  S(   N(   R·  R’   (   RŠ   R„   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>J  s    R^   s   _list('%s')Rz   s   _hexlist('%s')c         s   s   |  ] } t  j | ƒ Vq d  S(   N(   R	   R¹  (   RŠ   R„   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>N  s    R…   c         s   s   |  ] } | j  ƒ  Vq d  S(   N(   R½   (   RŠ   R„   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>P  s    i   s
   (%s or %s)(   RQ   Rr  (   R^   R   R\   Ry   (   Rº  t   listexp(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR»  C  s    
R¼   i    t   %i   t   dsnbrR\   s&   unexpected revspec format character %s(   RQ   RH   R   R³   (   t   exprR   t   retR[   R  R]   R_   (    (   Rº  R»  R¸  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt
   formatspec  s2    !	





c            sB   ‡  f d †  ‰  g  } ˆ  |  d | ƒ d j  d „  | Dƒ ƒ } | S(   Nc            s«   t  |  t ƒ s  |  d d k r< | j | t |  ƒ f ƒ nk | j | d |  d f ƒ x& |  d D] } ˆ  | | d | ƒ qb W| d d | d d d f g | d )d  S(	   Ni    RK   RJ   s   (%si   iÿÿÿÿR0   (   s   strings   symbol(   R˜  RS  R%   R·  (   R–  t   levelt   linesR^   (   t   _prettyformat(    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÃ  q  s     i    s   
c         s   s#   |  ] \ } } d  | | Vq d S(   s     N(    (   RŠ   R\   R^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pys	   <genexpr>|  s    (   Rr  (   R–  RÂ  t   output(    (   RÃ  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   prettyformatp  s
    	c         C   s.   t  |  t ƒ r& t t t |  ƒ ƒ d Sd Sd  S(   Ni   i    (   R˜  RS  Rg   t   mapt   depth(   R–  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÇ    s    c         C   s…   t  |  t ƒ s  |  d d k r' t ƒ  St ƒ  } x" |  d D] } | t | ƒ O} q; W|  d d k r} | j |  d d ƒ n  | Sd  S(   Ni    RK   RJ   i   R1   (   s   strings   symbol(   R˜  RS  R   t	   funcsusedR   (   R–  t   funcsR^   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÈ  …  s     	R#   c           B   s   e  Z d  Z d d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z e	 j
 d „  ƒ Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z RS(   sÇ   Basic data structure that represents a revset and contains the basic
    operation that it should be able to perform.

    Every method in this class should be implemented by any smartset class.
    c         C   s#   t  t |  ƒ j | ƒ d  |  _ d  S(   N(   t   superR#   R¢  R   t   _set(   R¡  t   data(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¢  –  s    c         C   s   |  j  ƒ  d S(   se   Sorts the set in ascending order (in place).

        This is part of the mandatory API for smartset.N(   Ri  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRë   š  s    c         C   s   |  j  d t ƒ d S(   sf   Sorts the set in descending order (in place).

        This is part of the mandatory API for smartset.R-  N(   Ri  R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR      s    c         C   s
   t  |  ƒ S(   N(   R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   ¦  s    c         C   s
   t  |  ƒ S(   N(   Rg   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRg   ©  s    c         C   s"   |  j  s t |  ƒ |  _  n  |  j  S(   sÎ   Returns a set or a smartset containing all the elements.

        The returned structure should be the fastest option for membership
        testing.

        This is part of the mandatory API for smartset.(   RË  R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   ¬  s    	c         C   s   |  j  ƒ  j S(   N(   R   R}   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   ·  s    c            sZ   t  ˆ  t ƒ rD ˆ  j ƒ  ‰  t g  |  D] } | ˆ  k r% | ^ q% ƒ S|  j ‡  f d †  ƒ S(   s{   Returns a new object with the substraction of the two collections.

        This is part of the mandatory API for smartset.c            s
   |  ˆ  k S(   N(    (   R    (   RO  (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   Æ  s    (   R˜  R#   R   R|   (   R¡  RO  R    (    (   RO  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __sub__»  s    )c         C   sG   t  | t ƒ r | j ƒ  } n  t g  |  D] } | | k r( | ^ q( ƒ S(   s{   Returns a new object with the intersection of the two collections.

        This is part of the mandatory API for smartset.(   R˜  R#   R   (   R¡  RO  Rx   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __and__È  s    c         C   sE   |  j  ƒ  } g  | D] } | | k r | ^ q } t t |  ƒ | ƒ S(   st   Returns a new object with the union of the two collections.

        This is part of the mandatory API for smartset.(   R   R#   RH   (   R¡  RO  R^   RN   R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __add__Ð  s    %c         C   s   t  S(   sy   Returns True if the collection is ascending order, False if not.

        This is part of the mandatory API for smartset.(   RŸ   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   isascendingØ  s    c         C   s   t  S(   sz   Returns True if the collection is descending order, False if not.

        This is part of the mandatory API for smartset.(   RŸ   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   isdescendingÞ  s    c         C   s   t  |  | ƒ S(   s×   Returns this smartset filtered by condition as a new smartset.

        `condition` is a callable which takes a revision number and returns a
        boolean.

        This is part of the mandatory API for smartset.(   R£   (   R¡  t	   condition(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR|   ä  s    (    (   R£  R¤  t   __doc__R¢  Rë   R   R   Rg   R   R   t   propertycacheR}   RÍ  RÎ  RÏ  RÐ  RÑ  R|   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR#     s   										t   _orderedsetmixinc           B   s2   e  Z d  Z d „  Z d „  Z d „  Z d „  Z RS(   sŸ   Mixin class with utility methods for smartsets

    This should be extended by smartsets which have the isascending(),
    isdescending() and reverse() methodsc         C   s"   x |  D] } | SWt  d ƒ ‚ d S(   s$   return the first revision in the sets   arg is an empty sequenceN(   R”   (   R¡  RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _firstó  s    c         C   s$   |  j  ƒ  |  j ƒ  } |  j  ƒ  | S(   s#   return the last revision in the set(   R-  RÖ  (   R¡  Ry   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   _lastù  s    

c         C   s    |  j  ƒ  r |  j ƒ  S|  j ƒ  S(   s&   return the smallest element in the set(   RÐ  RÖ  R×  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR    	  s    
c         C   s    |  j  ƒ  r |  j ƒ  S|  j ƒ  S(   s%   return the largest element in the set(   RÐ  R×  RÖ  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRg   	  s    
(   R£  R¤  RÓ  RÖ  R×  R   Rg   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÕ  í  s
   			R£   c           B   sÂ   e  Z d  Z d „  d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d	 „  Z
 d
 „  Z d „  Z d „  Z d „  Z d „  Z e d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   s    Duck type for baseset class which iterates lazily over the revisions in
    the subset and contains a function which tests for membership in the
    revset
    c         C   s   t  S(   N(   R   (   R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   	  s    c         C   s   | |  _  | |  _ i  |  _ d S(   s…   
        condition: a function that decide whether a revision in the subset
                   belongs to the revset or not.
        N(   t   _subsett
   _conditiont   _cache(   R¡  Rk   RÒ  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¢  	  s    		c         C   s   |  j  j ƒ  d  S(   N(   RØ  Ri  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRë   	  s    c         C   s   |  j  j d t ƒ d  S(   NR-  (   RØ  Ri  R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   	  s    c         C   s
   t  |  ƒ S(   N(   R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR    	  s    c         C   s
   t  |  ƒ S(   N(   Rg   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRg   #	  s    c         C   sB   |  j  } | | k r: | |  j k o0 |  j | ƒ | | <n  | | S(   N(   RÚ  RØ  RÙ  (   R¡  R    R]   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   &	  s    	%c         c   s5   |  j  } x% |  j D] } | | ƒ r | Vq q Wd  S(   N(   RÙ  RØ  (   R¡  t   condR    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __iter__,	  s    	c         C   s   t  |  | j ƒ S(   N(   R£   R}   (   R¡  R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÎ  2	  s    c            s   t  |  ‡  f d †  ƒ S(   Nc            s
   |  ˆ  k S(   N(    (   RN   (   R    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   6	  s    (   R£   (   R¡  R    (    (   R    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÍ  5	  s    c         C   s   t  |  | ƒ S(   N(   t   _addset(   R¡  R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÏ  8	  s    c         C   s   x |  D] } t  SWt S(   N(   R   RŸ   (   R¡  RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __nonzero__;	  s    c         C   s)   t  g  |  D] } | ^ q
 ƒ } t | ƒ S(   N(   R#   RQ   (   R¡  RN   R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __len__@	  s    c         C   s'   t  g  |  D] } | ^ q
 ƒ } | | S(   N(   R#   (   R¡  R    RN   R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   __getitem__E	  s    c         C   sA   t  j |  j d ƒ s* t |  j ƒ |  _ n  |  j j d | ƒ d  S(   NRi  R-  (   R   Rj   RØ  R#   Ri  (   R¡  R-  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRi  J	  s    c         C   s   |  j  j ƒ  d  S(   N(   RØ  R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR-  O	  s    c         C   s   t  g  |  D] } | ^ q
 ƒ S(   N(   R   (   R¡  RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   R	  s    c         C   s   t  S(   N(   RŸ   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÐ  U	  s    c         C   s   t  S(   N(   RŸ   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ  X	  s    c         C   s   t  |  | ƒ S(   N(   R£   (   R¡  R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR|   [	  s    (   R£  R¤  RÓ  R¢  Rë   R   R   Rg   R}   RÜ  RÎ  RÍ  RÏ  RÞ  Rß  Rà  RŸ   Ri  R-  R   RÐ  RÑ  R|   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR£   	  s(   																	Rì   c           B   sw   e  Z d  Z e d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 e d „ Z d	 „  Z d
 „  Z d „  Z RS(   sY   Subclass of lazyset which subset can be ordered either ascending or
    descendingly
    c         C   s&   t  t |  ƒ j | | ƒ | |  _ d  S(   N(   RÊ  Rì   R¢  t
   _ascending(   R¡  Rk   RÒ  Rë   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¢  b	  s    c         C   s   t  |  | d |  j ƒS(   NRë   (   Rì   Rá  (   R¡  R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR|   f	  s    c         C   s   |  j  s |  j ƒ  n  d  S(   N(   Rá  R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRë   i	  s    	c         C   s   |  j  r |  j ƒ  n  d  S(   N(   Rá  R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   m	  s    	c         C   s   t  |  | j d |  j ƒS(   NRë   (   Rì   R}   Rá  (   R¡  R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÎ  q	  s    c            s   t  |  ‡  f d †  d |  j ƒS(   Nc            s
   |  ˆ  k S(   N(    (   RN   (   R    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   v	  s    Rë   (   Rì   Rá  (   R¡  R    (    (   R    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÍ  u	  s    c         C   s`   i  } |  j  ƒ  r+ | j  ƒ  r+ t | d <n  |  j ƒ  rP | j ƒ  rP t | d <n  t |  | |  S(   NRë   (   RÐ  R   RÑ  RŸ   RÝ  (   R¡  R    t   kwargs(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÏ  y	  s    c         C   sU   | r( |  j  rG |  j j d | ƒ qG n |  j  sG |  j j d | ƒ n  | |  _  d  S(   NR-  (   Rá  RØ  Ri  (   R¡  R-  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRi  	  s    		c         C   s   |  j  S(   N(   Rá  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÐ  Š	  s    c         C   s   |  j  S(   N(   Rá  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ  	  s    c         C   s   |  j  j ƒ  |  j |  _ d  S(   N(   RØ  R-  Rá  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR-  	  s    (   R£  R¤  RÓ  R   R¢  R|   Rë   R   RÎ  RÍ  RÏ  RŸ   Ri  RÐ  RÑ  R-  (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRì   ^	  s   									RÝ  c           B   s¶   e  Z d  Z d d „ Z d „  Z e j d „  ƒ Z d „  Z	 d „  Z
 d „  Z d „  Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z e d „ Z d „  Z d „  Z d „  Z RS(   s×  Represent the addition of two sets

    Wrapper structure for lazily adding two structures without losing much
    performance on the __contains__ method

    If the ascending attribute is set, that means the two structures are
    ordered in either an ascending or descending way. Therefore, we can add
    them maintaining the order by iterating over both at the same time

    This class does not duck-type baseset and it's only supposed to be used
    internally
    c         C   s1   | |  _  | |  _ d  |  _ | |  _ d  |  _ d  S(   N(   t   _r1t   _r2R   t   _iterRá  t   _genlist(   R¡  t   revs1t   revs2Rë   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¢  ¡	  s
    				c         C   s   t  |  j ƒ S(   N(   RQ   R‚  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRß  ¨	  s    c         C   s(   |  j  s! t |  j ƒ  ƒ |  _  n  |  j  S(   N(   Ræ  R#   t	   _iterator(   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR‚  «	  s    	c         C   s2   |  j  d  k	 r% t |  | d |  j  ƒSt |  | ƒ S(   NRë   (   Rá  R   Rì   R£   (   R¡  RÒ  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR|   ±	  s    c         C   s?   |  j  d  k r% |  j ƒ  t |  _  n |  j  s; |  j ƒ  n  d  S(   N(   Rá  R   Ri  R   R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRë   ¶	  s
    
	c         C   sE   |  j  d  k r+ |  j d t ƒ t |  _  n |  j  rA |  j ƒ  n  d  S(   NR-  (   Rá  R   Ri  R   RŸ   R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   ¾	  s
    	c         C   s;   | j  } |  j d  k	 r. t |  | d |  j ƒSt |  | ƒ S(   NRë   (   R}   Rá  R   Rì   R£   (   R¡  RO  t
   filterfunc(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÎ  Æ	  s    	c            sA   ‡  f d †  } |  j  d  k	 r4 t |  | d |  j  ƒSt |  | ƒ S(   Nc            s
   |  ˆ  k S(   N(    (   RN   (   RO  (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   Í	  s    Rë   (   Rá  R   Rì   R£   (   R¡  RO  Rê  (    (   RO  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÍ  Ì	  s    c         C   sr   i  } |  j  d k	 rb |  j ƒ  r: | j ƒ  r: t | d <n  |  j ƒ  rb | j ƒ  rb t | d <qb n  t |  | |  S(   sN   When both collections are ascending or descending, preserve the order
        Rë   N(   Rá  R   RÐ  R   RÑ  RŸ   RÝ  (   R¡  RO  Râ  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÏ  Ò	  s    c            s4   ˆ  j  s- ‡  f d †  } t | ƒ  ƒ ˆ  _  n  ˆ  j  S(   s  Iterate over both collections without repeating elements

        If the ascending attribute is not set, iterate over the first one and
        then over the second one checking for membership on the first one so we
        dont yield any duplicates.

        If the ascending attribute is set, iterate over both collections at the
        same time, yielding only one value at a time in the given order.
        c    
      3   s‹  ˆ  j  d  k rb x ˆ  j D] }  |  Vq Wˆ  j j ƒ  } xMˆ  j D] }  |  | k rA |  VqA qA Wn%t ˆ  j ƒ } t ˆ  j ƒ } d  } d  } t } ˆ  j  r¤ t } n  y… x~ t r'| d  k rË | j	 ƒ  } n  | d  k ræ | j	 ƒ  } n  | | | ƒ } | V| | k rd  } n  | | k rª d  } qª qª WWn[ t
 k
 r†| } | d  k	 rY| V| } n | d  k	 rm| Vn  x | D] }	 |	 VqtWn Xd  S(   N(   Rá  R   Rã  R   Rä  R$  Rg   R   R   R&  R'  (
   RN   R^   t   iter1t   iter2t   val1t   val2t   choiceR&  R,  t   val(   R¡  (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   genè	  sF    						(   Rå  t   _generatorset(   R¡  Rñ  (    (   R¡  s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRé  Ý	  s    
	,c         C   s&   |  j  r t |  j  ƒ St |  j ƒ  ƒ S(   N(   Ræ  R$  Ré  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÜ  
  s    	c         C   s   | |  j  k p | |  j k S(   N(   Rã  Rä  (   R¡  R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   
  s    c         C   s   |  S(   N(    (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR    
  s    c         C   s[   |  j  d k r/ |  j j d | ƒ | |  _  n( t |  j  ƒ t | ƒ k rW |  j ƒ  n  d S(   s»   Sort the added set

        For this we use the cached list with all the generated values and if we
        know they are ascending or descending we can sort them in a smart way.
        R-  N(   Rá  R   R‚  Ri  t   boolR-  (   R¡  R-  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRi  #
  s
    c         C   s   |  j  d  k	 o |  j  S(   N(   Rá  R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÐ  0
  s    c         C   s   |  j  d  k	 o |  j  S(   N(   Rá  R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ  3
  s    c         C   s0   |  j  j ƒ  |  j d  k	 r, |  j |  _ n  d  S(   N(   R‚  R-  Rá  R   (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR-  6
  s    N(   R£  R¤  RÓ  R   R¢  Rß  R   RÔ  R‚  R|   Rë   R   RÎ  RÍ  RÏ  Ré  RÜ  R}   R   RŸ   Ri  RÐ  RÑ  R-  (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÝ  ”	  s$   								;					Rò  c           B   sG   e  Z d  Z d „  Z d „  Z d „  Z d „  Z d „  Z e d „ Z	 RS(   s„  Wrap a generator for lazy iteration

    Wrapper structure for generators that provides lazy membership and can
    be iterated more than once.
    When asked for membership it generates values until either it finds the
    requested one or has gone through all the elements in the generator

    This class does not duck-type baseset and it's only supposed to be used
    internally
    c         C   s.   | |  _  i  |  _ t g  ƒ |  _ t |  _ d S(   sM   
        gen: a generator producing the values for the generatorset.
        N(   t   _genRÚ  R#   Ræ  RŸ   t	   _finished(   R¡  Rñ  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¢  F
  s    		c         C   sR   | |  j  k r |  j  | Sx$ |  j ƒ  D] } | | k r' t Sq' Wt |  j  | <t S(   N(   RÚ  t   _consumegenR   RŸ   (   R¡  R    R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   O
  s    c         c   s…   |  j  r& x |  j D] } | Vq Wd  Sd } |  j } |  j ƒ  } x= t r€ | t | ƒ k  rh | | Vn | j ƒ  V| d 7} qD Wd  S(   Ni    i   (   Rõ  Ræ  Rö  R   RQ   R&  (   R¡  R    R   t   genlistt   consume(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÜ  [
  s    				c         c   sC   x3 |  j  D]( } t |  j | <|  j j | ƒ | Vq
 Wt |  _ d  S(   N(   Rô  R   RÚ  Ræ  R%   Rõ  (   R¡  t   item(    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRö  k
  s
    	c         C   s   |  S(   N(    (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   r
  s    c         C   s7   |  j  s  x |  D]	 } q q Wn  |  j j d | ƒ d  S(   NR-  (   Rõ  Ræ  Ri  (   R¡  R-  R   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRi  u
  s    	
(
   R£  R¤  RÓ  R¢  R}   RÜ  Rö  R   RŸ   Ri  (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRò  ;
  s   
						R!   c           B   s   e  Z d  Z d „  Z RS(   s/  Wrap a generator of ascending elements for lazy iteration

    Same structure as _generatorset but stops iterating after it goes past
    the value when asked for membership and the element is not contained

    This class does not duck-type baseset and it's only supposed to be used
    internally
    c         C   sb   | |  j  k r |  j  | Sx4 |  j ƒ  D]& } | | k r= t S| | k r' Pq' q' Wt |  j  | <t S(   N(   RÚ  Rö  R   RŸ   (   R¡  R    R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   „
  s    (   R£  R¤  RÓ  R}   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR!   {
  s   R   c           B   s   e  Z d  Z d „  Z RS(   s0  Wrap a generator of descending elements for lazy iteration

    Same structure as _generatorset but stops iterating after it goes past
    the value when asked for membership and the element is not contained

    This class does not duck-type baseset and it's only supposed to be used
    internally
    c         C   sb   | |  j  k r |  j  | Sx4 |  j ƒ  D]& } | | k r= t S| | k  r' Pq' q' Wt |  j  | <t S(   N(   RÚ  Rö  R   RŸ   (   R¡  R    R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   ›
  s    (   R£  R¤  RÓ  R}   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   ’
  s   Rw   c           B   s°   e  Z d  Z d d d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z d „  Z e d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   s\  Duck type for baseset class which represents a range of revisions and
    can work lazily and without having all the range in memory

    Note that spanset(x, y) behave almost like xrange(x, y) except for two
    notable points:
    - when x < y it will be automatically descending,
    - revision filtered with this repoview will be skipped.

    i    c         C   sC   | |  _  | d k	 r! | |  _ n t | ƒ |  _ | j j |  _ d S(   sã   
        start: first revision included the set
               (default to 0)
        end:   first revision excluded (last+1)
               (default to len(repo)

        Spanset will be descending if `end` < `start`.
        N(   t   _startR   t   _endRQ   R   t   filteredrevst   _hiddenrevs(   R¡  R   R1  RL   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR¢  ³
  s
    		c         C   s#   |  j  |  j k r |  j ƒ  n  d  S(   N(   Rú  Rû  R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRë   Ã
  s    c         C   s#   |  j  |  j k  r |  j ƒ  n  d  S(   N(   Rú  Rû  R-  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR   Ç
  s    c         c   s–   |  j  |  j k r* t |  j  |  j ƒ } n t |  j  |  j d ƒ } |  j r| |  j } x; | D] } | | k r[ | Vq[ q[ Wn x | D] } | Vqƒ Wd  S(   Niÿÿÿÿ(   Rú  Rû  R%  Rý  (   R¡  t	   iterrangeR^   RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÜ  Ë
  s    		c         C   s[   |  j  | k  o |  j k n sD |  j | k o? |  j  k  n oZ |  j oY | |  j k S(   N(   Rû  Rú  Rý  (   R¡  R,   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR}   Ú
  s    ""c         C   s   x |  D] } t  SWt S(   N(   R   RŸ   (   R¡  RN   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÞ  ß
  s    c         C   sZ   t  | t ƒ r | j ƒ  } n  |  j |  j k r@ t |  | j ƒ St |  | j d t ƒSd  S(   NRë   (   R˜  R#   R   Rú  Rû  Rì   R}   RŸ   (   R¡  R    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÎ  ä
  s
    c            sf   t  ˆ  t ƒ r ˆ  j ƒ  ‰  n  |  j |  j k rF t |  ‡  f d †  ƒ St |  ‡  f d †  d t ƒSd  S(   Nc            s
   |  ˆ  k S(   N(    (   RN   (   R    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ð
  s    c            s
   |  ˆ  k S(   N(    (   RN   (   R    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRO   ò
  s    Rë   (   R˜  R#   R   Rú  Rû  Rì   RŸ   (   R¡  R    (    (   R    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÍ  ì
  s
    c         C   s`   i  } |  j  ƒ  r+ | j  ƒ  r+ t | d <n  |  j ƒ  rP | j ƒ  rP t | d <n  t |  | |  S(   NRë   (   RÐ  R   RÑ  RŸ   RÝ  (   R¡  R    Râ  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÏ  ô
  s    c         C   sª   |  j  s t |  j |  j ƒ Sd } |  j } |  j } xV |  j  D]K } | | k  o\ | k n s} | | k ox | k  n r? | d 7} q? q? Wt |  j |  j ƒ | Sd  S(   Ni    i   (   Rý  t   absRû  Rú  (   R¡  t   countR1  RL   R,   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRß  ü
  s    			8c         C   s'   t  g  |  D] } | ^ q
 ƒ } | | S(   N(   R#   (   R¡  R    RN   R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRà    s    c         C   s/   t  | ƒ |  j |  j k k r+ |  j ƒ  n  d  S(   N(   Ró  Rú  Rû  R-  (   R¡  R-  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRi    s    c         C   s[   |  j  |  j k r6 |  j d |  j  d |  _  |  _ n! |  j d |  j  d |  _  |  _ d  S(   Ni   (   Rú  Rû  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR-    s    $c         C   s   |  S(   N(    (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR     s    c         C   s   |  j  |  j k  S(   N(   Rú  Rû  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÐ    s    c         C   s   |  j  |  j k S(   N(   Rú  Rû  (   R¡  (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRÑ    s    c         C   s6   |  j  |  j k r t |  | ƒ St |  | d t ƒSd  S(   NRë   (   Rú  Rû  Rì   RŸ   (   R¡  R\   (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyR|   !  s    N(   R£  R¤  RÓ  R   R¢  Rë   R   RÜ  R}   RÞ  RÎ  RÍ  RÏ  Rß  Rà  RŸ   Ri  R-  R   RÐ  RÑ  R|   (    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyRw   ©
  s$   															(   s   groupi   R0   (   s   funci   R0   (   s   ancestori   (   s   parenti   (   s
   parentposti   (   s   negatei   (   s   minusi   (   s   dagrangeprei   (   s   dagrangei   (   s   dagrangeposti   (   s   dagrangeprei   (   s   dagrangei   (   s   dagrangeposti   (   s   rangeprei   (   s   rangei   (   s	   rangeposti   (   s   noti
   (   s   noti
   (   s   andi   (   s   andi   (   s   ori   (   s   ori   (   s   ori   (   s   listi   (   i    NN(   s   symbol(   s   string(   i    NN(   s   symbols	   _aliasarg(”   R  R±  R   RS   RH  R©   Rù   R	   R   RÇ   RÆ   R3   R¡   t   i18nR    R—   R:  RÀ   RÜ   R  R   R"   R.   R   R²  R   RW   Rc   Re   Rf   Rh   Rl   Rs   Rt   Rv   R{   R;   R   R‚   Rƒ   R†   R1   R‰   RŸ   RŽ   R   R‘   R–   Rž   R¨   R­   R®   R»   R½   R¿   RÄ   R‡   RØ   RÙ   RÛ   Rà   Rä   Rå   Rê   Rï   R¥   Rð   Rö   R÷   Rú   Rý   Rp   R  R   R  R  R	  Rñ   R  R  R  R  R(   R  R#  R  R.  R/  R0  R4  R×   R5  R9  R?  RP  RÌ   RR  R-   RT  RU  RV  RX  RY  R,   Ro  R-  R'   Rp  Ri  R±   R›   R}  R~  R  R™   R‚  Rƒ  R…  Ru   t   safesymbolsRi   R‹  R•  R—  R™  t   objectR›  R§  R¨  R©  R°  RŸ  RÀ  RÅ  RÇ  RÈ  RH   R#   RÕ  R£   Rì   RÝ  Rò  R!   R   Rw   Rµ   t   i18nfunctions(    (    (    s4   /usr/lib/python2.7/dist-packages/mercurial/revset.pyt   <module>   sZ  H				
	

U																									&															,							!						@																									#			p					?	'				
							

	]					 		^			]R6§@                                                                                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/scmposix.py                                               0100644 0000000 0000000 00000001555 12413056314 021322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import sys, os
import osutil

def _rcfiles(path):
    rcs = [os.path.join(path, 'hgrc')]
    rcdir = os.path.join(path, 'hgrc.d')
    try:
        rcs.extend([os.path.join(rcdir, f)
                    for f, kind in osutil.listdir(rcdir)
                    if f.endswith(".rc")])
    except OSError:
        pass
    return rcs

def systemrcpath():
    path = []
    if sys.platform == 'plan9':
        root = 'lib/mercurial'
    else:
        root = 'etc/mercurial'
    # old mod_python does not set sys.argv
    if len(getattr(sys, 'argv', [])) > 0:
        p = os.path.dirname(os.path.dirname(sys.argv[0]))
        path.extend(_rcfiles(os.path.join(p, root)))
    path.extend(_rcfiles('/' + root))
    return path

def userrcpath():
    if sys.platform == 'plan9':
        return [os.environ['home'] + '/lib/hgrc']
    else:
        return [os.path.expanduser('~/.hgrc')]
                                                                                                                                                   usr/lib/python2.7/dist-packages/mercurial/scmposix.pyc                                              0100644 0000000 0000000 00000002665 13077704337 021504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sC   d  d l  Z  d  d l Z d  d l Z d „  Z d „  Z d „  Z d S(   iÿÿÿÿNc         C   s–   t  j j |  d ƒ g } t  j j |  d ƒ } yQ | j g  t j | ƒ D]0 \ } } | j d ƒ rF t  j j | | ƒ ^ qF ƒ Wn t k
 r‘ n X| S(   Nt   hgrcs   hgrc.ds   .rc(   t   ost   patht   joint   extendt   osutilt   listdirt   endswitht   OSError(   R   t   rcst   rcdirt   ft   kind(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/scmposix.pyt   _rcfiles   s    	/c          C   s§   g  }  t  j d k r d } n d } t t t  d g  ƒ ƒ d k rŒ t j j t j j t  j d ƒ ƒ } |  j t	 t j j
 | | ƒ ƒ ƒ n  |  j t	 d | ƒ ƒ |  S(   Nt   plan9s   lib/mercurials   etc/mercurialt   argvi    t   /(   t   syst   platformt   lent   getattrR   R   t   dirnameR   R   R   R   (   R   t   roott   p(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/scmposix.pyt   systemrcpath   s    	%%c           C   s8   t  j d k r! t j d d g St j j d ƒ g Sd  S(   NR   t   homes	   /lib/hgrcs   ~/.hgrc(   R   R   R   t   environR   t
   expanduser(    (    (    s6   /usr/lib/python2.7/dist-packages/mercurial/scmposix.pyt
   userrcpath   s    (   R   R   R   R   R   R   (    (    (    s6   /usr/lib/python2.7/dist-packages/mercurial/scmposix.pyt   <module>   s   		                                                                           usr/lib/python2.7/dist-packages/mercurial/scmutil.py                                                0100644 0000000 0000000 00000075736 12413056314 021151  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # scmutil.py - Mercurial core utility functions
#
#  Copyright Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
from mercurial.node import nullrev
import util, error, osutil, revset, similar, encoding, phases, parsers
import pathutil
import match as matchmod
import os, errno, re, glob, tempfile

if os.name == 'nt':
    import scmwindows as scmplatform
else:
    import scmposix as scmplatform

systemrcpath = scmplatform.systemrcpath
userrcpath = scmplatform.userrcpath

def itersubrepos(ctx1, ctx2):
    """find subrepos in ctx1 or ctx2"""
    # Create a (subpath, ctx) mapping where we prefer subpaths from
    # ctx1. The subpaths from ctx2 are important when the .hgsub file
    # has been modified (in ctx2) but not yet committed (in ctx1).
    subpaths = dict.fromkeys(ctx2.substate, ctx2)
    subpaths.update(dict.fromkeys(ctx1.substate, ctx1))
    for subpath, ctx in sorted(subpaths.iteritems()):
        yield subpath, ctx.sub(subpath)

def nochangesfound(ui, repo, excluded=None):
    '''Report no changes for push/pull, excluded is None or a list of
    nodes excluded from the push/pull.
    '''
    secretlist = []
    if excluded:
        for n in excluded:
            if n not in repo:
                # discovery should not have included the filtered revision,
                # we have to explicitly exclude it until discovery is cleanup.
                continue
            ctx = repo[n]
            if ctx.phase() >= phases.secret and not ctx.extinct():
                secretlist.append(n)

    if secretlist:
        ui.status(_("no changes found (ignored %d secret changesets)\n")
                  % len(secretlist))
    else:
        ui.status(_("no changes found\n"))

def checknewlabel(repo, lbl, kind):
    # Do not use the "kind" parameter in ui output.
    # It makes strings difficult to translate.
    if lbl in ['tip', '.', 'null']:
        raise util.Abort(_("the name '%s' is reserved") % lbl)
    for c in (':', '\0', '\n', '\r'):
        if c in lbl:
            raise util.Abort(_("%r cannot be used in a name") % c)
    try:
        int(lbl)
        raise util.Abort(_("cannot use an integer as a name"))
    except ValueError:
        pass

def checkfilename(f):
    '''Check that the filename f is an acceptable filename for a tracked file'''
    if '\r' in f or '\n' in f:
        raise util.Abort(_("'\\n' and '\\r' disallowed in filenames: %r") % f)

def checkportable(ui, f):
    '''Check if filename f is portable and warn or abort depending on config'''
    checkfilename(f)
    abort, warn = checkportabilityalert(ui)
    if abort or warn:
        msg = util.checkwinfilename(f)
        if msg:
            msg = "%s: %r" % (msg, f)
            if abort:
                raise util.Abort(msg)
            ui.warn(_("warning: %s\n") % msg)

def checkportabilityalert(ui):
    '''check if the user's config requests nothing, a warning, or abort for
    non-portable filenames'''
    val = ui.config('ui', 'portablefilenames', 'warn')
    lval = val.lower()
    bval = util.parsebool(val)
    abort = os.name == 'nt' or lval == 'abort'
    warn = bval or lval == 'warn'
    if bval is None and not (warn or abort or lval == 'ignore'):
        raise error.ConfigError(
            _("ui.portablefilenames value is invalid ('%s')") % val)
    return abort, warn

class casecollisionauditor(object):
    def __init__(self, ui, abort, dirstate):
        self._ui = ui
        self._abort = abort
        allfiles = '\0'.join(dirstate._map)
        self._loweredfiles = set(encoding.lower(allfiles).split('\0'))
        self._dirstate = dirstate
        # The purpose of _newfiles is so that we don't complain about
        # case collisions if someone were to call this object with the
        # same filename twice.
        self._newfiles = set()

    def __call__(self, f):
        if f in self._newfiles:
            return
        fl = encoding.lower(f)
        if fl in self._loweredfiles and f not in self._dirstate:
            msg = _('possible case-folding collision for %s') % f
            if self._abort:
                raise util.Abort(msg)
            self._ui.warn(_("warning: %s\n") % msg)
        self._loweredfiles.add(fl)
        self._newfiles.add(f)

class abstractvfs(object):
    """Abstract base class; cannot be instantiated"""

    def __init__(self, *args, **kwargs):
        '''Prevent instantiation; don't call this from subclasses.'''
        raise NotImplementedError('attempted instantiating ' + str(type(self)))

    def tryread(self, path):
        '''gracefully return an empty string for missing files'''
        try:
            return self.read(path)
        except IOError, inst:
            if inst.errno != errno.ENOENT:
                raise
        return ""

    def open(self, path, mode="r", text=False, atomictemp=False):
        self.open = self.__call__
        return self.__call__(path, mode, text, atomictemp)

    def read(self, path):
        fp = self(path, 'rb')
        try:
            return fp.read()
        finally:
            fp.close()

    def write(self, path, data):
        fp = self(path, 'wb')
        try:
            return fp.write(data)
        finally:
            fp.close()

    def append(self, path, data):
        fp = self(path, 'ab')
        try:
            return fp.write(data)
        finally:
            fp.close()

    def chmod(self, path, mode):
        return os.chmod(self.join(path), mode)

    def exists(self, path=None):
        return os.path.exists(self.join(path))

    def fstat(self, fp):
        return util.fstat(fp)

    def isdir(self, path=None):
        return os.path.isdir(self.join(path))

    def isfile(self, path=None):
        return os.path.isfile(self.join(path))

    def islink(self, path=None):
        return os.path.islink(self.join(path))

    def lexists(self, path=None):
        return os.path.lexists(self.join(path))

    def lstat(self, path=None):
        return os.lstat(self.join(path))

    def listdir(self, path=None):
        return os.listdir(self.join(path))

    def makedir(self, path=None, notindexed=True):
        return util.makedir(self.join(path), notindexed)

    def makedirs(self, path=None, mode=None):
        return util.makedirs(self.join(path), mode)

    def makelock(self, info, path):
        return util.makelock(info, self.join(path))

    def mkdir(self, path=None):
        return os.mkdir(self.join(path))

    def mkstemp(self, suffix='', prefix='tmp', dir=None, text=False):
        fd, name = tempfile.mkstemp(suffix=suffix, prefix=prefix,
                                    dir=self.join(dir), text=text)
        dname, fname = util.split(name)
        if dir:
            return fd, os.path.join(dir, fname)
        else:
            return fd, fname

    def readdir(self, path=None, stat=None, skip=None):
        return osutil.listdir(self.join(path), stat, skip)

    def readlock(self, path):
        return util.readlock(self.join(path))

    def rename(self, src, dst):
        return util.rename(self.join(src), self.join(dst))

    def readlink(self, path):
        return os.readlink(self.join(path))

    def setflags(self, path, l, x):
        return util.setflags(self.join(path), l, x)

    def stat(self, path=None):
        return os.stat(self.join(path))

    def unlink(self, path=None):
        return util.unlink(self.join(path))

    def unlinkpath(self, path=None, ignoremissing=False):
        return util.unlinkpath(self.join(path), ignoremissing)

    def utime(self, path=None, t=None):
        return os.utime(self.join(path), t)

class vfs(abstractvfs):
    '''Operate files relative to a base directory

    This class is used to hide the details of COW semantics and
    remote file access from higher level code.
    '''
    def __init__(self, base, audit=True, expandpath=False, realpath=False):
        if expandpath:
            base = util.expandpath(base)
        if realpath:
            base = os.path.realpath(base)
        self.base = base
        self._setmustaudit(audit)
        self.createmode = None
        self._trustnlink = None

    def _getmustaudit(self):
        return self._audit

    def _setmustaudit(self, onoff):
        self._audit = onoff
        if onoff:
            self.audit = pathutil.pathauditor(self.base)
        else:
            self.audit = util.always

    mustaudit = property(_getmustaudit, _setmustaudit)

    @util.propertycache
    def _cansymlink(self):
        return util.checklink(self.base)

    @util.propertycache
    def _chmod(self):
        return util.checkexec(self.base)

    def _fixfilemode(self, name):
        if self.createmode is None or not self._chmod:
            return
        os.chmod(name, self.createmode & 0666)

    def __call__(self, path, mode="r", text=False, atomictemp=False):
        if self._audit:
            r = util.checkosfilename(path)
            if r:
                raise util.Abort("%s: %r" % (r, path))
        self.audit(path)
        f = self.join(path)

        if not text and "b" not in mode:
            mode += "b" # for that other OS

        nlink = -1
        if mode not in ('r', 'rb'):
            dirname, basename = util.split(f)
            # If basename is empty, then the path is malformed because it points
            # to a directory. Let the posixfile() call below raise IOError.
            if basename:
                if atomictemp:
                    util.ensuredirs(dirname, self.createmode)
                    return util.atomictempfile(f, mode, self.createmode)
                try:
                    if 'w' in mode:
                        util.unlink(f)
                        nlink = 0
                    else:
                        # nlinks() may behave differently for files on Windows
                        # shares if the file is open.
                        fd = util.posixfile(f)
                        nlink = util.nlinks(f)
                        if nlink < 1:
                            nlink = 2 # force mktempcopy (issue1922)
                        fd.close()
                except (OSError, IOError), e:
                    if e.errno != errno.ENOENT:
                        raise
                    nlink = 0
                    util.ensuredirs(dirname, self.createmode)
                if nlink > 0:
                    if self._trustnlink is None:
                        self._trustnlink = nlink > 1 or util.checknlink(f)
                    if nlink > 1 or not self._trustnlink:
                        util.rename(util.mktempcopy(f), f)
        fp = util.posixfile(f, mode)
        if nlink == 0:
            self._fixfilemode(f)
        return fp

    def symlink(self, src, dst):
        self.audit(dst)
        linkname = self.join(dst)
        try:
            os.unlink(linkname)
        except OSError:
            pass

        util.ensuredirs(os.path.dirname(linkname), self.createmode)

        if self._cansymlink:
            try:
                os.symlink(src, linkname)
            except OSError, err:
                raise OSError(err.errno, _('could not symlink to %r: %s') %
                              (src, err.strerror), linkname)
        else:
            self.write(dst, src)

    def join(self, path):
        if path:
            return os.path.join(self.base, path)
        else:
            return self.base

opener = vfs

class auditvfs(object):
    def __init__(self, vfs):
        self.vfs = vfs

    def _getmustaudit(self):
        return self.vfs.mustaudit

    def _setmustaudit(self, onoff):
        self.vfs.mustaudit = onoff

    mustaudit = property(_getmustaudit, _setmustaudit)

class filtervfs(abstractvfs, auditvfs):
    '''Wrapper vfs for filtering filenames with a function.'''

    def __init__(self, vfs, filter):
        auditvfs.__init__(self, vfs)
        self._filter = filter

    def __call__(self, path, *args, **kwargs):
        return self.vfs(self._filter(path), *args, **kwargs)

    def join(self, path):
        if path:
            return self.vfs.join(self._filter(path))
        else:
            return self.vfs.join(path)

filteropener = filtervfs

class readonlyvfs(abstractvfs, auditvfs):
    '''Wrapper vfs preventing any writing.'''

    def __init__(self, vfs):
        auditvfs.__init__(self, vfs)

    def __call__(self, path, mode='r', *args, **kw):
        if mode not in ('r', 'rb'):
            raise util.Abort('this vfs is read only')
        return self.vfs(path, mode, *args, **kw)


def walkrepos(path, followsym=False, seen_dirs=None, recurse=False):
    '''yield every hg repository under path, always recursively.
    The recurse flag will only control recursion into repo working dirs'''
    def errhandler(err):
        if err.filename == path:
            raise err
    samestat = getattr(os.path, 'samestat', None)
    if followsym and samestat is not None:
        def adddir(dirlst, dirname):
            match = False
            dirstat = os.stat(dirname)
            for lstdirstat in dirlst:
                if samestat(dirstat, lstdirstat):
                    match = True
                    break
            if not match:
                dirlst.append(dirstat)
            return not match
    else:
        followsym = False

    if (seen_dirs is None) and followsym:
        seen_dirs = []
        adddir(seen_dirs, path)
    for root, dirs, files in os.walk(path, topdown=True, onerror=errhandler):
        dirs.sort()
        if '.hg' in dirs:
            yield root # found a repository
            qroot = os.path.join(root, '.hg', 'patches')
            if os.path.isdir(os.path.join(qroot, '.hg')):
                yield qroot # we have a patch queue repo here
            if recurse:
                # avoid recursing inside the .hg directory
                dirs.remove('.hg')
            else:
                dirs[:] = [] # don't descend further
        elif followsym:
            newdirs = []
            for d in dirs:
                fname = os.path.join(root, d)
                if adddir(seen_dirs, fname):
                    if os.path.islink(fname):
                        for hgname in walkrepos(fname, True, seen_dirs):
                            yield hgname
                    else:
                        newdirs.append(d)
            dirs[:] = newdirs

def osrcpath():
    '''return default os-specific hgrc search path'''
    path = systemrcpath()
    path.extend(userrcpath())
    path = [os.path.normpath(f) for f in path]
    return path

_rcpath = None

def rcpath():
    '''return hgrc search path. if env var HGRCPATH is set, use it.
    for each item in path, if directory, use files ending in .rc,
    else use item.
    make HGRCPATH empty to only look in .hg/hgrc of current repo.
    if no HGRCPATH, use default os-specific path.'''
    global _rcpath
    if _rcpath is None:
        if 'HGRCPATH' in os.environ:
            _rcpath = []
            for p in os.environ['HGRCPATH'].split(os.pathsep):
                if not p:
                    continue
                p = util.expandpath(p)
                if os.path.isdir(p):
                    for f, kind in osutil.listdir(p):
                        if f.endswith('.rc'):
                            _rcpath.append(os.path.join(p, f))
                else:
                    _rcpath.append(p)
        else:
            _rcpath = osrcpath()
    return _rcpath

def revsingle(repo, revspec, default='.'):
    if not revspec and revspec != 0:
        return repo[default]

    l = revrange(repo, [revspec])
    if len(l) < 1:
        raise util.Abort(_('empty revision set'))
    return repo[l[-1]]

def revpair(repo, revs):
    if not revs:
        return repo.dirstate.p1(), None

    l = revrange(repo, revs)

    if not l:
        first = second = None
    elif l.isascending():
        first = l.min()
        second = l.max()
    elif l.isdescending():
        first = l.max()
        second = l.min()
    else:
        l = list(l)
        first = l[0]
        second = l[-1]

    if first is None:
        raise util.Abort(_('empty revision range'))

    if first == second and len(revs) == 1 and _revrangesep not in revs[0]:
        return repo.lookup(first), None

    return repo.lookup(first), repo.lookup(second)

_revrangesep = ':'

def revrange(repo, revs):
    """Yield revision as strings from a list of revision specifications."""

    def revfix(repo, val, defval):
        if not val and val != 0 and defval is not None:
            return defval
        return repo[val].rev()

    seen, l = set(), revset.baseset([])
    for spec in revs:
        if l and not seen:
            seen = set(l)
        # attempt to parse old-style ranges first to deal with
        # things like old-tag which contain query metacharacters
        try:
            if isinstance(spec, int):
                seen.add(spec)
                l = l + revset.baseset([spec])
                continue

            if _revrangesep in spec:
                start, end = spec.split(_revrangesep, 1)
                start = revfix(repo, start, 0)
                end = revfix(repo, end, len(repo) - 1)
                if end == nullrev and start < 0:
                    start = nullrev
                rangeiter = repo.changelog.revs(start, end)
                if not seen and not l:
                    # by far the most common case: revs = ["-1:0"]
                    l = revset.baseset(rangeiter)
                    # defer syncing seen until next iteration
                    continue
                newrevs = set(rangeiter)
                if seen:
                    newrevs.difference_update(seen)
                    seen.update(newrevs)
                else:
                    seen = newrevs
                l = l + revset.baseset(sorted(newrevs, reverse=start > end))
                continue
            elif spec and spec in repo: # single unquoted rev
                rev = revfix(repo, spec, None)
                if rev in seen:
                    continue
                seen.add(rev)
                l = l + revset.baseset([rev])
                continue
        except error.RepoLookupError:
            pass

        # fall through to new-style queries if old-style fails
        m = revset.match(repo.ui, spec, repo)
        if seen or l:
            dl = [r for r in m(repo, revset.spanset(repo)) if r not in seen]
            l = l + revset.baseset(dl)
            seen.update(dl)
        else:
            l = m(repo, revset.spanset(repo))

    return l

def expandpats(pats):
    '''Expand bare globs when running on windows.
    On posix we assume it already has already been done by sh.'''
    if not util.expandglobs:
        return list(pats)
    ret = []
    for kindpat in pats:
        kind, pat = matchmod._patsplit(kindpat, None)
        if kind is None:
            try:
                globbed = glob.glob(pat)
            except re.error:
                globbed = [pat]
            if globbed:
                ret.extend(globbed)
                continue
        ret.append(kindpat)
    return ret

def matchandpats(ctx, pats=[], opts={}, globbed=False, default='relpath'):
    '''Return a matcher and the patterns that were used.
    The matcher will warn about bad matches.'''
    if pats == ("",):
        pats = []
    if not globbed and default == 'relpath':
        pats = expandpats(pats or [])

    m = ctx.match(pats, opts.get('include'), opts.get('exclude'),
                         default)
    def badfn(f, msg):
        ctx._repo.ui.warn("%s: %s\n" % (m.rel(f), msg))
    m.bad = badfn
    return m, pats

def match(ctx, pats=[], opts={}, globbed=False, default='relpath'):
    '''Return a matcher that will warn about bad matches.'''
    return matchandpats(ctx, pats, opts, globbed, default)[0]

def matchall(repo):
    '''Return a matcher that will efficiently match everything.'''
    return matchmod.always(repo.root, repo.getcwd())

def matchfiles(repo, files):
    '''Return a matcher that will efficiently match exactly these files.'''
    return matchmod.exact(repo.root, repo.getcwd(), files)

def addremove(repo, pats=[], opts={}, dry_run=None, similarity=None):
    if dry_run is None:
        dry_run = opts.get('dry_run')
    if similarity is None:
        similarity = float(opts.get('similarity') or 0)
    # we'd use status here, except handling of symlinks and ignore is tricky
    m = match(repo[None], pats, opts)
    rejected = []
    m.bad = lambda x, y: rejected.append(x)

    added, unknown, deleted, removed = _interestingfiles(repo, m)

    unknownset = set(unknown)
    toprint = unknownset.copy()
    toprint.update(deleted)
    for abs in sorted(toprint):
        if repo.ui.verbose or not m.exact(abs):
            rel = m.rel(abs)
            if abs in unknownset:
                status = _('adding %s\n') % ((pats and rel) or abs)
            else:
                status = _('removing %s\n') % ((pats and rel) or abs)
            repo.ui.status(status)

    renames = _findrenames(repo, m, added + unknown, removed + deleted,
                           similarity)

    if not dry_run:
        _markchanges(repo, unknown, deleted, renames)

    for f in rejected:
        if f in m.files():
            return 1
    return 0

def marktouched(repo, files, similarity=0.0):
    '''Assert that files have somehow been operated upon. files are relative to
    the repo root.'''
    m = matchfiles(repo, files)
    rejected = []
    m.bad = lambda x, y: rejected.append(x)

    added, unknown, deleted, removed = _interestingfiles(repo, m)

    if repo.ui.verbose:
        unknownset = set(unknown)
        toprint = unknownset.copy()
        toprint.update(deleted)
        for abs in sorted(toprint):
            if abs in unknownset:
                status = _('adding %s\n') % abs
            else:
                status = _('removing %s\n') % abs
            repo.ui.status(status)

    renames = _findrenames(repo, m, added + unknown, removed + deleted,
                           similarity)

    _markchanges(repo, unknown, deleted, renames)

    for f in rejected:
        if f in m.files():
            return 1
    return 0

def _interestingfiles(repo, matcher):
    '''Walk dirstate with matcher, looking for files that addremove would care
    about.

    This is different from dirstate.status because it doesn't care about
    whether files are modified or clean.'''
    added, unknown, deleted, removed = [], [], [], []
    audit_path = pathutil.pathauditor(repo.root)

    ctx = repo[None]
    dirstate = repo.dirstate
    walkresults = dirstate.walk(matcher, sorted(ctx.substate), True, False,
                                full=False)
    for abs, st in walkresults.iteritems():
        dstate = dirstate[abs]
        if dstate == '?' and audit_path.check(abs):
            unknown.append(abs)
        elif dstate != 'r' and not st:
            deleted.append(abs)
        # for finding renames
        elif dstate == 'r':
            removed.append(abs)
        elif dstate == 'a':
            added.append(abs)

    return added, unknown, deleted, removed

def _findrenames(repo, matcher, added, removed, similarity):
    '''Find renames from removed files to added ones.'''
    renames = {}
    if similarity > 0:
        for old, new, score in similar.findrenames(repo, added, removed,
                                                   similarity):
            if (repo.ui.verbose or not matcher.exact(old)
                or not matcher.exact(new)):
                repo.ui.status(_('recording removal of %s as rename to %s '
                                 '(%d%% similar)\n') %
                               (matcher.rel(old), matcher.rel(new),
                                score * 100))
            renames[new] = old
    return renames

def _markchanges(repo, unknown, deleted, renames):
    '''Marks the files in unknown as added, the files in deleted as removed,
    and the files in renames as copied.'''
    wctx = repo[None]
    wlock = repo.wlock()
    try:
        wctx.forget(deleted)
        wctx.add(unknown)
        for new, old in renames.iteritems():
            wctx.copy(old, new)
    finally:
        wlock.release()

def dirstatecopy(ui, repo, wctx, src, dst, dryrun=False, cwd=None):
    """Update the dirstate to reflect the intent of copying src to dst. For
    different reasons it might not end with dst being marked as copied from src.
    """
    origsrc = repo.dirstate.copied(src) or src
    if dst == origsrc: # copying back a copy?
        if repo.dirstate[dst] not in 'mn' and not dryrun:
            repo.dirstate.normallookup(dst)
    else:
        if repo.dirstate[origsrc] == 'a' and origsrc == src:
            if not ui.quiet:
                ui.warn(_("%s has not been committed yet, so no copy "
                          "data will be stored for %s.\n")
                        % (repo.pathto(origsrc, cwd), repo.pathto(dst, cwd)))
            if repo.dirstate[dst] in '?r' and not dryrun:
                wctx.add([dst])
        elif not dryrun:
            wctx.copy(origsrc, dst)

def readrequires(opener, supported):
    '''Reads and parses .hg/requires and checks if all entries found
    are in the list of supported features.'''
    requirements = set(opener.read("requires").splitlines())
    missings = []
    for r in requirements:
        if r not in supported:
            if not r or not r[0].isalnum():
                raise error.RequirementError(_(".hg/requires file is corrupt"))
            missings.append(r)
    missings.sort()
    if missings:
        raise error.RequirementError(
            _("repository requires features unknown to this Mercurial: %s")
            % " ".join(missings),
            hint=_("see http://mercurial.selenic.com/wiki/MissingRequirement"
                   " for more information"))
    return requirements

class filecachesubentry(object):
    def __init__(self, path, stat):
        self.path = path
        self.cachestat = None
        self._cacheable = None

        if stat:
            self.cachestat = filecachesubentry.stat(self.path)

            if self.cachestat:
                self._cacheable = self.cachestat.cacheable()
            else:
                # None means we don't know yet
                self._cacheable = None

    def refresh(self):
        if self.cacheable():
            self.cachestat = filecachesubentry.stat(self.path)

    def cacheable(self):
        if self._cacheable is not None:
            return self._cacheable

        # we don't know yet, assume it is for now
        return True

    def changed(self):
        # no point in going further if we can't cache it
        if not self.cacheable():
            return True

        newstat = filecachesubentry.stat(self.path)

        # we may not know if it's cacheable yet, check again now
        if newstat and self._cacheable is None:
            self._cacheable = newstat.cacheable()

            # check again
            if not self._cacheable:
                return True

        if self.cachestat != newstat:
            self.cachestat = newstat
            return True
        else:
            return False

    @staticmethod
    def stat(path):
        try:
            return util.cachestat(path)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise

class filecacheentry(object):
    def __init__(self, paths, stat=True):
        self._entries = []
        for path in paths:
            self._entries.append(filecachesubentry(path, stat))

    def changed(self):
        '''true if any entry has changed'''
        for entry in self._entries:
            if entry.changed():
                return True
        return False

    def refresh(self):
        for entry in self._entries:
            entry.refresh()

class filecache(object):
    '''A property like decorator that tracks files under .hg/ for updates.

    Records stat info when called in _filecache.

    On subsequent calls, compares old stat info with new info, and recreates the
    object when any of the files changes, updating the new stat info in
    _filecache.

    Mercurial either atomic renames or appends for files under .hg,
    so to ensure the cache is reliable we need the filesystem to be able
    to tell us if a file has been replaced. If it can't, we fallback to
    recreating the object on every call (essentially the same behaviour as
    propertycache).

    '''
    def __init__(self, *paths):
        self.paths = paths

    def join(self, obj, fname):
        """Used to compute the runtime path of a cached file.

        Users should subclass filecache and provide their own version of this
        function to call the appropriate join function on 'obj' (an instance
        of the class that its member function was decorated).
        """
        return obj.join(fname)

    def __call__(self, func):
        self.func = func
        self.name = func.__name__
        return self

    def __get__(self, obj, type=None):
        # do we need to check if the file changed?
        if self.name in obj.__dict__:
            assert self.name in obj._filecache, self.name
            return obj.__dict__[self.name]

        entry = obj._filecache.get(self.name)

        if entry:
            if entry.changed():
                entry.obj = self.func(obj)
        else:
            paths = [self.join(obj, path) for path in self.paths]

            # We stat -before- creating the object so our cache doesn't lie if
            # a writer modified between the time we read and stat
            entry = filecacheentry(paths, True)
            entry.obj = self.func(obj)

            obj._filecache[self.name] = entry

        obj.__dict__[self.name] = entry.obj
        return entry.obj

    def __set__(self, obj, value):
        if self.name not in obj._filecache:
            # we add an entry for the missing value because X in __dict__
            # implies X in _filecache
            paths = [self.join(obj, path) for path in self.paths]
            ce = filecacheentry(paths, False)
            obj._filecache[self.name] = ce
        else:
            ce = obj._filecache[self.name]

        ce.obj = value # update cached copy
        obj.__dict__[self.name] = value # update copy returned by obj.x

    def __delete__(self, obj):
        try:
            del obj.__dict__[self.name]
        except KeyError:
            raise AttributeError(self.name)

class dirs(object):
    '''a multiset of directory names from a dirstate or manifest'''

    def __init__(self, map, skip=None):
        self._dirs = {}
        addpath = self.addpath
        if util.safehasattr(map, 'iteritems') and skip is not None:
            for f, s in map.iteritems():
                if s[0] != skip:
                    addpath(f)
        else:
            for f in map:
                addpath(f)

    def addpath(self, path):
        dirs = self._dirs
        for base in finddirs(path):
            if base in dirs:
                dirs[base] += 1
                return
            dirs[base] = 1

    def delpath(self, path):
        dirs = self._dirs
        for base in finddirs(path):
            if dirs[base] > 1:
                dirs[base] -= 1
                return
            del dirs[base]

    def __iter__(self):
        return self._dirs.iterkeys()

    def __contains__(self, d):
        return d in self._dirs

if util.safehasattr(parsers, 'dirs'):
    dirs = parsers.dirs

def finddirs(path):
    pos = path.rfind('/')
    while pos != -1:
        yield path[:pos]
        pos = path.rfind('/', 0, pos)
                                  usr/lib/python2.7/dist-packages/mercurial/scmutil.pyc                                               0100644 0000000 0000000 00000112374 13077704337 021316  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sI  d  d l  m Z d  d l m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z e j d k rò d  d l Z n d  d l Z e j Z e j Z d „  Z d d „ Z d „  Z d „  Z d	 „  Z d
 „  Z  d e! f d „  ƒ  YZ" d e! f d „  ƒ  YZ# d e# f d „  ƒ  YZ$ e$ Z% d e! f d „  ƒ  YZ& d e# e& f d „  ƒ  YZ' e' Z( d e# e& f d „  ƒ  YZ) e* d e* d „ Z+ d „  Z, d a- d „  Z. d d „ Z/ d „  Z0 d Z1 d „  Z2 d „  Z3 g  i  e* d  d! „ Z4 g  i  e* d  d" „ Z d# „  Z5 d$ „  Z6 g  i  d d d% „ Z7 d& d' „ Z8 d( „  Z9 d) „  Z: d* „  Z; e* d d+ „ Z< d, „  Z= d- e! f d. „  ƒ  YZ> d/ e! f d0 „  ƒ  YZ? d1 e! f d2 „  ƒ  YZ@ d3 e! f d4 „  ƒ  YZA e jB e d3 ƒ r<e jA ZA n  d5 „  ZC d S(6   iÿÿÿÿ(   t   _(   t   nullrevNt   ntc         c   sl   t  j | j | ƒ } | j t  j |  j |  ƒ ƒ x4 t | j ƒ  ƒ D]  \ } } | | j | ƒ f VqD Wd S(   s   find subrepos in ctx1 or ctx2N(   t   dictt   fromkeyst   substatet   updatet   sortedt	   iteritemst   sub(   t   ctx1t   ctx2t   subpathst   subpatht   ctx(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   itersubrepos   s    c         C   s«   g  } | rn x_ | D]T } | | k r+ q n  | | } | j  ƒ  t j k r | j ƒ  r | j | ƒ q q Wn  | r” |  j t d ƒ t | ƒ ƒ n |  j t d ƒ ƒ d S(   sj   Report no changes for push/pull, excluded is None or a list of
    nodes excluded from the push/pull.
    s0   no changes found (ignored %d secret changesets)
s   no changes found
N(   t   phaset   phasest   secrett   extinctt   appendt   statusR    t   len(   t   uit   repot   excludedt
   secretlistt   nR   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   nochangesfound!   s    
"c         C   sœ   | d k r( t  j t d ƒ | ƒ ‚ n  x6 d D]. } | | k r/ t  j t d	 ƒ | ƒ ‚ q/ q/ Wy# t | ƒ t  j t d
 ƒ ƒ ‚ Wn t k
 r— n Xd  S(   Nt   tipt   .t   nulls   the name '%s' is reservedt   :t    s   
s   s   %r cannot be used in a names   cannot use an integer as a name(   R   R   R   (   R    s    s   
s   (   t   utilt   AbortR    t   intt
   ValueError(   R   t   lblt   kindt   c(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   checknewlabel6   s     
c         C   s8   d |  k s d |  k r4 t  j t d ƒ |  ƒ ‚ n  d S(   sF   Check that the filename f is an acceptable filename for a tracked files   s   
s)   '\n' and '\r' disallowed in filenames: %rN(   R"   R#   R    (   t   f(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   checkfilenameD   s    c         C   s†   t  | ƒ t |  ƒ \ } } | s( | r‚ t j | ƒ } | r‚ d | | f } | re t j | ƒ ‚ n  |  j t d ƒ | ƒ q‚ n  d S(   sE   Check if filename f is portable and warn or abort depending on configs   %s: %rs   warning: %s
N(   R+   t   checkportabilityalertR"   t   checkwinfilenameR#   t   warnR    (   R   R*   t   abortR.   t   msg(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   checkportableI   s    
c         C   s¨   |  j  d d d ƒ } | j ƒ  } t j | ƒ } t j d k pH | d k } | pZ | d k } | d k rž | p~ | p~ | d k rž t j t	 d ƒ | ƒ ‚ n  | | f S(	   s_   check if the user's config requests nothing, a warning, or abort for
    non-portable filenamesR   t   portablefilenamesR.   R   R/   t   ignores,   ui.portablefilenames value is invalid ('%s')N(
   t   configt   lowerR"   t	   parseboolt   ost   namet   Nonet   errort   ConfigErrorR    (   R   t   valt   lvalt   bvalR/   R.   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR,   U   s    %t   casecollisionauditorc           B   s   e  Z d  „  Z d „  Z RS(   c         C   s^   | |  _  | |  _ d j | j ƒ } t t j | ƒ j d ƒ ƒ |  _ | |  _	 t ƒ  |  _
 d  S(   NR!   (   t   _uit   _abortt   joint   _mapt   sett   encodingR5   t   splitt   _loweredfilest	   _dirstatet	   _newfiles(   t   selfR   R/   t   dirstatet   allfiles(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   __init__c   s    		!	c         C   s¬   | |  j  k r d  St j | ƒ } | |  j k rˆ | |  j k rˆ t d ƒ | } |  j rk t j | ƒ ‚ n  |  j	 j
 t d ƒ | ƒ n  |  j j | ƒ |  j  j | ƒ d  S(   Ns&   possible case-folding collision for %ss   warning: %s
(   RI   RE   R5   RG   RH   R    RA   R"   R#   R@   R.   t   add(   RJ   R*   t   flR0   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   __call__n   s    	(   t   __name__t
   __module__RM   RP   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR?   b   s   	t   abstractvfsc           B   sg  e  Z d  Z d „  Z d „  Z d e e d „ Z d „  Z d „  Z d „  Z	 d „  Z
 d! d	 „ Z d
 „  Z d! d „ Z d! d „ Z d! d „ Z d! d „ Z d! d „ Z d! d „ Z d! e d „ Z d! d! d „ Z d „  Z d! d „ Z d d d! e d „ Z d! d! d! d „ Z d „  Z d „  Z d „  Z d „  Z d! d „ Z d! d „ Z  d! e d „ Z! d! d! d  „ Z" RS("   s+   Abstract base class; cannot be instantiatedc         O   s    t  d t t |  ƒ ƒ ƒ ‚ d S(   s7   Prevent instantiation; don't call this from subclasses.s   attempted instantiating N(   t   NotImplementedErrort   strt   type(   RJ   t   argst   kwargs(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   }   s    c         C   sC   y |  j  | ƒ SWn+ t k
 r> } | j t j k r? ‚  q? n Xd S(   s3   gracefully return an empty string for missing filest    (   t   readt   IOErrort   errnot   ENOENT(   RJ   t   patht   inst(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   tryread   s    
t   rc         C   s"   |  j  |  _ |  j  | | | | ƒ S(   N(   RP   t   open(   RJ   R^   t   modet   textt
   atomictemp(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRb   Š   s    c         C   s/   |  | d ƒ } z | j  ƒ  SWd  | j ƒ  Xd  S(   Nt   rb(   RZ   t   close(   RJ   R^   t   fp(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRZ   Ž   s    c         C   s2   |  | d ƒ } z | j  | ƒ SWd  | j ƒ  Xd  S(   Nt   wb(   t   writeRg   (   RJ   R^   t   dataRh   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRj   •   s    c         C   s2   |  | d ƒ } z | j  | ƒ SWd  | j ƒ  Xd  S(   Nt   ab(   Rj   Rg   (   RJ   R^   Rk   Rh   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR   œ   s    c         C   s   t  j |  j | ƒ | ƒ S(   N(   R7   t   chmodRB   (   RJ   R^   Rc   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRm   £   s    c         C   s   t  j j |  j | ƒ ƒ S(   N(   R7   R^   t   existsRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRn   ¦   s    c         C   s   t  j | ƒ S(   N(   R"   t   fstat(   RJ   Rh   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRo   ©   s    c         C   s   t  j j |  j | ƒ ƒ S(   N(   R7   R^   t   isdirRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRp   ¬   s    c         C   s   t  j j |  j | ƒ ƒ S(   N(   R7   R^   t   isfileRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRq   ¯   s    c         C   s   t  j j |  j | ƒ ƒ S(   N(   R7   R^   t   islinkRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRr   ²   s    c         C   s   t  j j |  j | ƒ ƒ S(   N(   R7   R^   t   lexistsRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRs   µ   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R7   t   lstatRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRt   ¸   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R7   t   listdirRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRu   »   s    c         C   s   t  j |  j | ƒ | ƒ S(   N(   R"   t   makedirRB   (   RJ   R^   t
   notindexed(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRv   ¾   s    c         C   s   t  j |  j | ƒ | ƒ S(   N(   R"   t   makedirsRB   (   RJ   R^   Rc   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRx   Á   s    c         C   s   t  j | |  j | ƒ ƒ S(   N(   R"   t   makelockRB   (   RJ   t   infoR^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRy   Ä   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R7   t   mkdirRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR{   Ç   s    RY   t   tmpc   	   	   C   su   t  j d | d | d |  j | ƒ d | ƒ \ } } t j | ƒ \ } } | rg | t j j | | ƒ f S| | f Sd  S(   Nt   suffixt   prefixt   dirRd   (   t   tempfilet   mkstempRB   R"   RF   R7   R^   (	   RJ   R}   R~   R   Rd   t   fdR8   t   dnamet   fname(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR   Ê   s    c         C   s   t  j |  j | ƒ | | ƒ S(   N(   t   osutilRu   RB   (   RJ   R^   t   statt   skip(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   readdirÓ   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R"   t   readlockRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR‰   Ö   s    c         C   s"   t  j |  j | ƒ |  j | ƒ ƒ S(   N(   R"   t   renameRB   (   RJ   t   srct   dst(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRŠ   Ù   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R7   t   readlinkRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR   Ü   s    c         C   s   t  j |  j | ƒ | | ƒ S(   N(   R"   t   setflagsRB   (   RJ   R^   t   lt   x(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRŽ   ß   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R7   R†   RB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR†   â   s    c         C   s   t  j |  j | ƒ ƒ S(   N(   R"   t   unlinkRB   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR‘   å   s    c         C   s   t  j |  j | ƒ | ƒ S(   N(   R"   t
   unlinkpathRB   (   RJ   R^   t   ignoremissing(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR’   è   s    c         C   s   t  j |  j | ƒ | ƒ S(   N(   R7   t   utimeRB   (   RJ   R^   t   t(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR”   ë   s    N(#   RQ   RR   t   __doc__RM   R`   t   FalseRb   RZ   Rj   R   Rm   R9   Rn   Ro   Rp   Rq   Rr   Rs   Rt   Ru   t   TrueRv   Rx   Ry   R{   R   Rˆ   R‰   RŠ   R   RŽ   R†   R‘   R’   R”   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRS   z   s<   														t   vfsc           B   s’   e  Z d  Z e e e d „ Z d „  Z d „  Z e e e ƒ Z	 e
 j d „  ƒ Z e
 j d „  ƒ Z d „  Z d e e d „ Z d	 „  Z d
 „  Z RS(   sŸ   Operate files relative to a base directory

    This class is used to hide the details of COW semantics and
    remote file access from higher level code.
    c         C   s_   | r t  j | ƒ } n  | r3 t j j | ƒ } n  | |  _ |  j | ƒ d  |  _ d  |  _	 d  S(   N(
   R"   t
   expandpathR7   R^   t   realpatht   baset   _setmustauditR9   t
   createmodet   _trustnlink(   RJ   Rœ   t   auditRš   R›   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   ô   s    		c         C   s   |  j  S(   N(   t   _audit(   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   _getmustauditþ   s    c         C   s7   | |  _  | r' t j |  j ƒ |  _ n t j |  _ d  S(   N(   R¡   t   pathutilt   pathauditorRœ   R    R"   t   always(   RJ   t   onoff(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR     s    	c         C   s   t  j |  j ƒ S(   N(   R"   t	   checklinkRœ   (   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   _cansymlink
  s    c         C   s   t  j |  j ƒ S(   N(   R"   t	   checkexecRœ   (   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   _chmod  s    c         C   s8   |  j  d  k s |  j r d  St j | |  j  d @ƒ d  S(   Ni¶  (   Rž   R9   Rª   R7   Rm   (   RJ   R8   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   _fixfilemode  s    Ra   c         C   s.  |  j  r= t j | ƒ } | r= t j d | | f ƒ ‚ q= n  |  j | ƒ |  j | ƒ } | ry d | k ry | d 7} n  d } | d
 k rüt j | ƒ \ } }	 |	 rü| rÕ t j | |  j ƒ t j	 | | |  j ƒ Syc d | k rú t j
 | ƒ d } n= t j | ƒ }
 t j | ƒ } | d k  r-d	 } n  |
 j ƒ  WnJ t t f k
 r„} | j t j k rh‚  n  d } t j | |  j ƒ n X| d k rù|  j d  k rÁ| d k p¸t j | ƒ |  _ n  | d k s×|  j röt j t j | ƒ | ƒ qöqùqün  t j | | ƒ } | d k r*|  j | ƒ n  | S(   Ns   %s: %rt   biÿÿÿÿRa   Rf   t   wi    i   i   (   Ra   s   rb(   R¡   R"   t   checkosfilenameR#   R    RB   RF   t
   ensuredirsRž   t   atomictempfileR‘   t	   posixfilet   nlinksRg   t   OSErrorR[   R\   R]   RŸ   R9   t
   checknlinkRŠ   t
   mktempcopyR«   (   RJ   R^   Rc   Rd   Re   Ra   R*   t   nlinkt   dirnamet   basenameR‚   t   eRh   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRP     sL    			!%c         C   sÒ   |  j  | ƒ |  j | ƒ } y t j | ƒ Wn t k
 r@ n Xt j t j j | ƒ |  j	 ƒ |  j
 r¾ y t j | | ƒ WqÎ t k
 rº } t | j t d ƒ | | j f | ƒ ‚ qÎ Xn |  j | | ƒ d  S(   Ns   could not symlink to %r: %s(   R    RB   R7   R‘   R³   R"   R¯   R^   R·   Rž   R¨   t   symlinkR\   R    t   strerrorRj   (   RJ   R‹   RŒ   t   linknamet   err(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRº   F  s    	c         C   s'   | r t  j j |  j | ƒ S|  j Sd  S(   N(   R7   R^   RB   Rœ   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRB   Y  s    (   RQ   RR   R–   R˜   R—   RM   R¢   R   t   propertyt	   mustauditR"   t   propertycacheR¨   Rª   R«   RP   Rº   RB   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR™   î   s   
			/	t   auditvfsc           B   s2   e  Z d  „  Z d „  Z d „  Z e e e ƒ Z RS(   c         C   s   | |  _  d  S(   N(   R™   (   RJ   R™   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   b  s    c         C   s
   |  j  j S(   N(   R™   R¿   (   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR¢   e  s    c         C   s   | |  j  _ d  S(   N(   R™   R¿   (   RJ   R¦   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR   h  s    (   RQ   RR   RM   R¢   R   R¾   R¿   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRÁ   a  s   			t	   filtervfsc           B   s)   e  Z d  Z d „  Z d „  Z d „  Z RS(   s4   Wrapper vfs for filtering filenames with a function.c         C   s   t  j |  | ƒ | |  _ d  S(   N(   RÁ   RM   t   _filter(   RJ   R™   t   filter(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   p  s    c         O   s   |  j  |  j | ƒ | | Ž S(   N(   R™   RÃ   (   RJ   R^   RW   RX   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRP   t  s    c         C   s3   | r |  j  j |  j | ƒ ƒ S|  j  j | ƒ Sd  S(   N(   R™   RB   RÃ   (   RJ   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRB   w  s    (   RQ   RR   R–   RM   RP   RB   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRÂ   m  s   		t   readonlyvfsc           B   s#   e  Z d  Z d „  Z d d „ Z RS(   s#   Wrapper vfs preventing any writing.c         C   s   t  j |  | ƒ d  S(   N(   RÁ   RM   (   RJ   R™   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   ‚  s    Ra   c         O   s4   | d k r t  j d ƒ ‚ n  |  j | | | | Ž S(   NRa   Rf   s   this vfs is read only(   Ra   s   rb(   R"   R#   R™   (   RJ   R^   Rc   RW   t   kw(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRP   …  s    (   RQ   RR   R–   RM   RP   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRÅ     s   	c         #   s·  ‡  f d †  } t  t j d d ƒ ‰ | rH ˆ d k	 rH ‡ f d †  } n t } | d k rv | rv g  } | | ˆ  ƒ n  x:t j ˆ  d t d | ƒD]\ } } } | j ƒ  d | k r| Vt j j | d d ƒ }	 t j j	 t j j |	 d ƒ ƒ rý |	 Vn  | r| j
 d ƒ q¯g  | (q’ | r’ g  }
 xy | D]q } t j j | | ƒ } | | | ƒ r0t j j | ƒ r‘x/ t | t | ƒ D] } | VqWq¡|
 j | ƒ q0q0W|
 | (q’ q’ Wd S(	   s   yield every hg repository under path, always recursively.
    The recurse flag will only control recursion into repo working dirsc            s   |  j  ˆ  k r |  ‚ n  d  S(   N(   t   filename(   R½   (   R^   (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt
   errhandlerŽ  s    t   samestatc            sZ   t  } t j | ƒ } x' |  D] } ˆ  | | ƒ r t } Pq q W| sU |  j | ƒ n  | S(   N(   R—   R7   R†   R˜   R   (   t   dirlstR·   t   matcht   dirstatt
   lstdirstat(   RÉ   (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   adddir“  s    t   topdownt   onerrors   .hgt   patchesN(   t   getattrR7   R^   R9   R—   t   walkR˜   t   sortRB   Rp   t   removeRr   t	   walkreposR   (   R^   t	   followsymt	   seen_dirst   recurseRÈ   RÎ   t   roott   dirst   filest   qroott   newdirst   dR„   t   hgname(    (   R^   RÉ   s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRÖ   ‹  s8    +
!
c          C   sB   t  ƒ  }  |  j t ƒ  ƒ g  |  D] } t j j | ƒ ^ q  }  |  S(   s+   return default os-specific hgrc search path(   t   systemrcpatht   extendt
   userrcpathR7   R^   t   normpath(   R^   R*   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   osrcpath»  s    	%c          C   sã   t  d k rß d t j k rÓ g  a  x¸ t j d j t j ƒ D]‘ }  |  sM q; n  t j |  ƒ }  t j j	 |  ƒ r¿ x[ t
 j |  ƒ D]: \ } } | j d ƒ r~ t  j t j j |  | ƒ ƒ q~ q~ Wq; t  j |  ƒ q; Wqß t ƒ  a  n  t  S(   s  return hgrc search path. if env var HGRCPATH is set, use it.
    for each item in path, if directory, use files ending in .rc,
    else use item.
    make HGRCPATH empty to only look in .hg/hgrc of current repo.
    if no HGRCPATH, use default os-specific path.t   HGRCPATHs   .rcN(   t   _rcpathR9   R7   t   environRF   t   pathsepR"   Rš   R^   Rp   R…   Ru   t   endswithR   RB   Rå   (   t   pR*   R'   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   rcpathÄ  s     &R   c         C   sc   | r | d k r |  | St  |  | g ƒ } t | ƒ d k  rW t j t d ƒ ƒ ‚ n  |  | d S(   Ni    i   s   empty revision setiÿÿÿÿ(   t   revrangeR   R"   R#   R    (   R   t   revspect   defaultR   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt	   revsingleÜ  s    c         C   s*  | s |  j  j ƒ  d  f St |  | ƒ } | s; d  } } nn | j ƒ  rb | j ƒ  } | j ƒ  } nG | j ƒ  r‰ | j ƒ  } | j ƒ  } n  t | ƒ } | d } | d } | d  k rÍ t	 j
 t d ƒ ƒ ‚ n  | | k rt | ƒ d k rt | d k r|  j | ƒ d  f S|  j | ƒ |  j | ƒ f S(   Ni    iÿÿÿÿs   empty revision rangei   (   RK   t   p1R9   Rí   t   isascendingt   mint   maxt   isdescendingt   listR"   R#   R    R   t   _revrangesept   lookup(   R   t   revsR   t   firstt   second(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   revpairå  s&    

.R    c         C   s¦  d „  } t  ƒ  t j g  ƒ } } x}| D]u} | rK | rK t  | ƒ } n  y¦t | t ƒ r† | j | ƒ | t j | g ƒ } w) n  t | k r‘| j t d ƒ \ } } | |  | d ƒ } | |  | t |  ƒ d ƒ } | t	 k rù | d k  rù t	 } n  |  j
 j | | ƒ } | r1| r1t j | ƒ } w) n  t  | ƒ }	 | r`|	 j | ƒ | j |	 ƒ n |	 } | t j t |	 d | | k ƒƒ } w) n_ | rð| |  k rð| |  | d ƒ }
 |
 | k rÇw) n  | j |
 ƒ | t j |
 g ƒ } w) n  Wn t j k
 rn Xt j |  j | |  ƒ } | s,| r†g  | |  t j |  ƒ ƒ D] } | | k rE| ^ qE} | t j | ƒ } | j | ƒ q) | |  t j |  ƒ ƒ } q) W| S(   sA   Yield revision as strings from a list of revision specifications.c         S   s1   | r# | d k r# | d  k	 r# | S|  | j ƒ  S(   Ni    (   R9   t   rev(   R   R<   t   defval(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   revfix  s    i   i    t   reverseN(   RD   t   revsett   basesett
   isinstanceR$   RN   R÷   RF   R   R   t	   changelogRù   t   difference_updateR   R   R9   R:   t   RepoLookupErrorRË   R   t   spanset(   R   Rù   Rÿ   t   seenR   t   spect   startt   endt	   rangeitert   newrevsRý   t   mRa   t   dl(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRí     sV    		%
7c         C   s®   t  j s t |  ƒ Sg  } xŽ |  D]† } t j | d ƒ \ } } | d k r™ y t j | ƒ } Wn t j k
 r| | g } n X| r™ | j	 | ƒ q  q™ n  | j
 | ƒ q  W| S(   si   Expand bare globs when running on windows.
    On posix we assume it already has already been done by sh.N(   R"   t   expandglobsRö   t   matchmodt	   _patsplitR9   t   globt   reR:   Râ   R   (   t   patst   rett   kindpatR'   t   patt   globbed(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt
   expandpats?  s    	
	t   relpathc            sŒ   | d k r g  } n  | r= | d k r= t  | p4 g  ƒ } n  ˆ  j | | j d ƒ | j d ƒ | ƒ ‰ ‡  ‡ f d †  } | ˆ _ ˆ | f S(   s^   Return a matcher and the patterns that were used.
    The matcher will warn about bad matches.RY   R  t   includet   excludec            s*   ˆ  j  j j d ˆ j |  ƒ | f ƒ d  S(   Ns   %s: %s
(   t   _repoR   R.   t   rel(   R*   R0   (   R   R  (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   badfn\  s    (   RY   (   R  RË   t   gett   bad(   R   R  t   optsR  Rï   R   (    (   R   R  s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   matchandpatsR  s    	!		c         C   s   t  |  | | | | ƒ d S(   s2   Return a matcher that will warn about bad matches.i    (   R$  (   R   R  R#  R  Rï   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRË   a  s    c         C   s   t  j |  j |  j ƒ  ƒ S(   s8   Return a matcher that will efficiently match everything.(   R  R¥   RÚ   t   getcwd(   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   matchalle  s    c         C   s   t  j |  j |  j ƒ  | ƒ S(   sA   Return a matcher that will efficiently match exactly these files.(   R  t   exactRÚ   R%  (   R   RÜ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt
   matchfilesi  s    c            s¹  | d  k r | j d ƒ } n  | d  k rH t | j d ƒ p? d ƒ } n  t |  d  | | ƒ } g  ‰  ‡  f d †  | _ t |  | ƒ \ } } } }	 t | ƒ }
 |
 j ƒ  } | j | ƒ x™ t	 | ƒ D]‹ } |  j
 j så | j | ƒ rÃ | j | ƒ } | |
 k rt d ƒ | r| p| } n t d ƒ | r4| p7| } |  j
 j | ƒ qÃ qÃ Wt |  | | | |	 | | ƒ } | sŽt |  | | | ƒ n  x$ ˆ  D] } | | j ƒ  k r•d Sq•Wd S(   Nt   dry_runt
   similarityi    c            s   ˆ  j  |  ƒ S(   N(   R   (   R   t   y(   t   rejected(    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   <lambda>u  s    s
   adding %s
s   removing %s
i   (   R9   R!  t   floatRË   R"  t   _interestingfilesRD   t   copyR   R   R   t   verboseR'  R  R    R   t   _findrenamest   _markchangesRÜ   (   R   R  R#  R)  R*  R  t   addedt   unknownt   deletedt   removedt
   unknownsett   toprintt   absR  R   t   renamesR*   (    (   R,  s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt	   addremovem  s4    	g        c            s*  t  |  | ƒ } g  ‰  ‡  f d †  | _ t |  | ƒ \ } } } } |  j j rÌ t | ƒ } | j ƒ  }	 |	 j | ƒ xV t |	 ƒ D]E }
 |
 | k r¥ t	 d ƒ |
 } n t	 d ƒ |
 } |  j j
 | ƒ q€ Wn  t |  | | | | | | ƒ } t |  | | | ƒ x$ ˆ  D] } | | j ƒ  k rd SqWd S(   s[   Assert that files have somehow been operated upon. files are relative to
    the repo root.c            s   ˆ  j  |  ƒ S(   N(   R   (   R   R+  (   R,  (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR-  •  s    s
   adding %s
s   removing %s
i   i    (   R(  R"  R/  R   R1  RD   R0  R   R   R    R   R2  R3  RÜ   (   R   RÜ   R*  R  R4  R5  R6  R7  R8  R9  R:  R   R;  R*   (    (   R,  s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   marktouched  s(    	c         C   s'  g  g  g  g  f \ } } } } t  j |  j ƒ } |  d } |  j } | j | t | j ƒ t t	 d t	 ƒ}	 xª |	 j
 ƒ  D]œ \ }
 } | |
 } | d k r¸ | j |
 ƒ r¸ | j |
 ƒ qw | d k rÛ | rÛ | j |
 ƒ qw | d k r÷ | j |
 ƒ qw | d k rw | j |
 ƒ qw qw W| | | | f S(   sÅ   Walk dirstate with matcher, looking for files that addremove would care
    about.

    This is different from dirstate.status because it doesn't care about
    whether files are modified or clean.t   fullt   ?Ra   t   aN(   R£   R¤   RÚ   R9   RK   RÓ   R   R   R˜   R—   R   t   checkR   (   R   t   matcherR4  R5  R6  R7  t
   audit_pathR   RK   t   walkresultsR:  t   stt   dstate(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR/  ®  s"    
		
c   	      C   s·   i  } | d k r³ xž t  j |  | | | ƒ D] \ } } } |  j j sf | j | ƒ sf | j | ƒ r¢ |  j j t d ƒ | j | ƒ | j | ƒ | d f ƒ n  | | | <q+ Wn  | S(   s.   Find renames from removed files to added ones.i    s7   recording removal of %s as rename to %s (%d%% similar)
id   (   t   similart   findrenamesR   R1  R'  R   R    R  (	   R   RB  R4  R7  R*  R;  t   oldt   newt   score(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR2  É  s    c         C   ss   |  d } |  j ƒ  } zK | j | ƒ | j | ƒ x* | j ƒ  D] \ } } | j | | ƒ q@ WWd | j ƒ  Xd S(   sm   Marks the files in unknown as added, the files in deleted as removed,
    and the files in renames as copied.N(   R9   t   wlockt   forgetRN   R   R0  t   release(   R   R5  R6  R;  t   wctxRL  RJ  RI  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR3  Ø  s    
c         C   s  | j  j | ƒ p | } | | k rT | j  | d k rý | rý | j  j | ƒ qý n© | j  | d k rä | | k rä |  j s´ |  j t d ƒ | j | | ƒ | j | | ƒ f ƒ n  | j  | d k rý | rý | j | g ƒ qý n | sý | j | | ƒ n  d S(   sš   Update the dirstate to reflect the intent of copying src to dst. For
    different reasons it might not end with dst being marked as copied from src.
    t   mnR@  sF   %s has not been committed yet, so no copy data will be stored for %s.
s   ?rN(	   RK   t   copiedt   normallookupt   quietR.   R    t   pathtoRN   R0  (   R   R   RO  R‹   RŒ   t   dryrunt   cwdt   origsrc(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   dirstatecopyå  s    	)c         C   sÃ   t  |  j d ƒ j ƒ  ƒ } g  } xZ | D]R } | | k r( | sR | d j ƒ  rj t j t d ƒ ƒ ‚ n  | j | ƒ q( q( W| j ƒ  | r¿ t j t d ƒ d j	 | ƒ d t d ƒ ƒ‚ n  | S(   sh   Reads and parses .hg/requires and checks if all entries found
    are in the list of supported features.t   requiresi    s   .hg/requires file is corrupts:   repository requires features unknown to this Mercurial: %st    t   hintsM   see http://mercurial.selenic.com/wiki/MissingRequirement for more information(
   RD   RZ   t
   splitlinest   isalnumR:   t   RequirementErrorR    R   RÔ   RB   (   t   openert	   supportedt   requirementst   missingsRa   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   readrequiresø  s    
	t   filecachesubentryc           B   s;   e  Z d  „  Z d „  Z d „  Z d „  Z e d „  ƒ Z RS(   c         C   sd   | |  _  d  |  _ d  |  _ | r` t j |  j  ƒ |  _ |  j rT |  j j ƒ  |  _ q` d  |  _ n  d  S(   N(   R^   R9   t	   cachestatt
   _cacheableRd  R†   t	   cacheable(   RJ   R^   R†   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM     s    				c         C   s(   |  j  ƒ  r$ t j |  j ƒ |  _ n  d  S(   N(   Rg  Rd  R†   R^   Re  (   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   refresh  s    c         C   s   |  j  d  k	 r |  j  St S(   N(   Rf  R9   R˜   (   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRg    s    c         C   sz   |  j  ƒ  s t St j |  j ƒ } | rV |  j d  k rV | j  ƒ  |  _ |  j sV t Sn  |  j | k rr | |  _ t St Sd  S(   N(	   Rg  R˜   Rd  R†   R^   Rf  R9   Re  R—   (   RJ   t   newstat(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   changed%  s    		c         C   sC   y t  j |  ƒ SWn+ t k
 r> } | j t j k r? ‚  q? n Xd  S(   N(   R"   Re  R³   R\   R]   (   R^   R¹   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR†   :  s
    (   RQ   RR   RM   Rh  Rg  Rj  t   staticmethodR†   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRd    s
   				t   filecacheentryc           B   s&   e  Z e d  „ Z d „  Z d „  Z RS(   c         C   s7   g  |  _  x' | D] } |  j  j t | | ƒ ƒ q Wd  S(   N(   t   _entriesR   Rd  (   RJ   t   pathsR†   R^   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   C  s    	c         C   s(   x! |  j  D] } | j ƒ  r
 t Sq
 Wt S(   s   true if any entry has changed(   Rm  Rj  R˜   R—   (   RJ   t   entry(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRj  H  s    c         C   s"   x |  j  D] } | j ƒ  q
 Wd  S(   N(   Rm  Rh  (   RJ   Ro  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRh  O  s    (   RQ   RR   R˜   RM   Rj  Rh  (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRl  B  s   	t	   filecachec           B   sG   e  Z d  Z d „  Z d „  Z d „  Z d d „ Z d „  Z d „  Z	 RS(   sZ  A property like decorator that tracks files under .hg/ for updates.

    Records stat info when called in _filecache.

    On subsequent calls, compares old stat info with new info, and recreates the
    object when any of the files changes, updating the new stat info in
    _filecache.

    Mercurial either atomic renames or appends for files under .hg,
    so to ensure the cache is reliable we need the filesystem to be able
    to tell us if a file has been replaced. If it can't, we fallback to
    recreating the object on every call (essentially the same behaviour as
    propertycache).

    c         G   s   | |  _  d  S(   N(   Rn  (   RJ   Rn  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   c  s    c         C   s   | j  | ƒ S(   s  Used to compute the runtime path of a cached file.

        Users should subclass filecache and provide their own version of this
        function to call the appropriate join function on 'obj' (an instance
        of the class that its member function was decorated).
        (   RB   (   RJ   t   objR„   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRB   f  s    c         C   s   | |  _  | j |  _ |  S(   N(   t   funcRQ   R8   (   RJ   Rr  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRP   o  s    	c         C   só   |  j  | j k rA |  j  | j k s3 t |  j  ƒ ‚ | j |  j  S| j j |  j  ƒ } | r€ | j ƒ  rÙ |  j | ƒ | _ qÙ nY g  |  j D] } |  j	 | | ƒ ^ qŠ } t
 | t ƒ } |  j | ƒ | _ | | j |  j  <| j | j |  j  <| j S(   N(   R8   t   __dict__t
   _filecachet   AssertionErrorR!  Rj  Rr  Rq  Rn  RB   Rl  R˜   (   RJ   Rq  RV   Ro  R^   Rn  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   __get__t  s    !(c         C   s‰   |  j  | j k r\ g  |  j D] } |  j | | ƒ ^ q } t | t ƒ } | | j |  j  <n | j |  j  } | | _ | | j |  j  <d  S(   N(   R8   Rt  Rn  RB   Rl  R—   Rq  Rs  (   RJ   Rq  t   valueR^   Rn  t   ce(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   __set__Œ  s    (	c         C   s8   y | j  |  j =Wn  t k
 r3 t |  j ƒ ‚ n Xd  S(   N(   Rs  R8   t   KeyErrort   AttributeError(   RJ   Rq  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt
   __delete__™  s    N(
   RQ   RR   R–   RM   RB   RP   R9   Rv  Ry  R|  (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRp  S  s   					RÛ   c           B   s>   e  Z d  Z d d „ Z d „  Z d „  Z d „  Z d „  Z RS(   s9   a multiset of directory names from a dirstate or manifestc         C   sŒ   i  |  _  |  j } t j | d ƒ rm | d  k	 rm xU | j ƒ  D]) \ } } | d | k r= | | ƒ q= q= Wn x | D] } | | ƒ qt Wd  S(   NR   i    (   t   _dirst   addpathR"   t   safehasattrR9   R   (   RJ   t   mapR‡   R~  R*   t   s(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRM   ¢  s    		c         C   sN   |  j  } x> t | ƒ D]0 } | | k r< | | c d 7<d  Sd | | <q Wd  S(   Ni   (   R}  t   finddirs(   RJ   R^   RÛ   Rœ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR~  ­  s    	c         C   sO   |  j  } x? t | ƒ D]1 } | | d k r@ | | c d 8<d  S| | =q Wd  S(   Ni   (   R}  R‚  (   RJ   R^   RÛ   Rœ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   delpathµ  s    	c         C   s   |  j  j ƒ  S(   N(   R}  t   iterkeys(   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   __iter__½  s    c         C   s   | |  j  k S(   N(   R}  (   RJ   Rß   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   __contains__À  s    N(	   RQ   RR   R–   R9   RM   R~  Rƒ  R…  R†  (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyRÛ   Ÿ  s   			c         c   sD   |  j  d ƒ } x. | d k r? |  |  V|  j  d d | ƒ } q Wd  S(   Nt   /iÿÿÿÿi    (   t   rfind(   R^   t   pos(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyR‚  Æ  s    	(D   t   i18nR    t   mercurial.nodeR   R"   R:   R…   R  RG  RE   R   t   parsersR£   RË   R  R7   R\   R  R  R€   R8   t
   scmwindowst   scmplatformt   scmposixRá   Rã   R   R9   R   R)   R+   R1   R,   t   objectR?   RS   R™   R_  RÁ   RÂ   t   filteropenerRÅ   R—   RÖ   Rå   Rç   Rì   Rð   Rü   R÷   Rí   R  R$  R&  R(  R<  R=  R/  R2  R3  RX  Rc  Rd  Rl  Rp  RÛ   R  R‚  (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/scmutil.pyt   <module>   sf   `<			
				tq0					=			#				7L$                                                                                                                                                                                                                                                                    usr/lib/python2.7/dist-packages/mercurial/scmwindows.py                                             0100644 0000000 0000000 00000003205 12413056314 021644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
import osutil
import util
import _winreg

def systemrcpath():
    '''return default os-specific hgrc search path'''
    rcpath = []
    filename = util.executablepath()
    # Use mercurial.ini found in directory with hg.exe
    progrc = os.path.join(os.path.dirname(filename), 'mercurial.ini')
    if os.path.isfile(progrc):
        rcpath.append(progrc)
        return rcpath
    # Use hgrc.d found in directory with hg.exe
    progrcd = os.path.join(os.path.dirname(filename), 'hgrc.d')
    if os.path.isdir(progrcd):
        for f, kind in osutil.listdir(progrcd):
            if f.endswith('.rc'):
                rcpath.append(os.path.join(progrcd, f))
        return rcpath
    # else look for a system rcpath in the registry
    value = util.lookupreg('SOFTWARE\\Mercurial', None,
                           _winreg.HKEY_LOCAL_MACHINE)
    if not isinstance(value, str) or not value:
        return rcpath
    value = util.localpath(value)
    for p in value.split(os.pathsep):
        if p.lower().endswith('mercurial.ini'):
            rcpath.append(p)
        elif os.path.isdir(p):
            for f, kind in osutil.listdir(p):
                if f.endswith('.rc'):
                    rcpath.append(os.path.join(p, f))
    return rcpath

def userrcpath():
    '''return os-specific hgrc search path to the user dir'''
    home = os.path.expanduser('~')
    path = [os.path.join(home, 'mercurial.ini'),
            os.path.join(home, '.hgrc')]
    userprofile = os.environ.get('USERPROFILE')
    if userprofile:
        path.append(os.path.join(userprofile, 'mercurial.ini'))
        path.append(os.path.join(userprofile, '.hgrc'))
    return path
                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python2.7/dist-packages/mercurial/scmwindows.pyc                                            0100644 0000000 0000000 00000003441 13077704337 022025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sF   d  d l  Z  d  d l Z d  d l Z d  d l Z d „  Z d „  Z d S(   iÿÿÿÿNc          C   sÆ  g  }  t  j ƒ  } t j j t j j | ƒ d ƒ } t j j | ƒ rV |  j | ƒ |  St j j t j j | ƒ d ƒ } t j j | ƒ rÛ xK t	 j
 | ƒ D]: \ } } | j d ƒ r™ |  j t j j | | ƒ ƒ q™ q™ W|  St  j d d t j ƒ } t | t ƒ s
| r|  St  j | ƒ } x¢ | j t j ƒ D]Ž } | j ƒ  j d ƒ r[|  j | ƒ q0t j j | ƒ r0xN t	 j
 | ƒ D]: \ } } | j d ƒ r}|  j t j j | | ƒ ƒ q}q}Wq0q0W|  S(   s+   return default os-specific hgrc search paths   mercurial.inis   hgrc.ds   .rcs   SOFTWARE\MercurialN(   t   utilt   executablepatht   ost   patht   joint   dirnamet   isfilet   appendt   isdirt   osutilt   listdirt   endswitht	   lookupregt   Nonet   _winregt   HKEY_LOCAL_MACHINEt
   isinstancet   strt	   localpatht   splitt   pathsept   lower(   t   rcpatht   filenamet   progrct   progrcdt   ft   kindt   valuet   p(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/scmwindows.pyt   systemrcpath   s2    !!#*c          C   s“   t  j j d ƒ }  t  j j |  d ƒ t  j j |  d ƒ g } t  j j d ƒ } | r | j t  j j | d ƒ ƒ | j t  j j | d ƒ ƒ n  | S(   s3   return os-specific hgrc search path to the user dirt   ~s   mercurial.inis   .hgrct   USERPROFILE(   R   R   t
   expanduserR   t   environt   getR   (   t   homeR   t   userprofile(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/scmwindows.pyt
   userrcpath%   s    (   R   R	   R    R   R   R&   (    (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/scmwindows.pyt   <module>   s
   	                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/mercurial/setdiscovery.py                                           0100644 0000000 0000000 00000020466 12413056314 022202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # setdiscovery.py - improved discovery of common nodeset for mercurial
#
# Copyright 2010 Benoit Boissinot <bboissin@gmail.com>
# and Peter Arrenbrecht <peter@arrenbrecht.ch>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.
"""
Algorithm works in the following way. You have two repository: local and
remote. They both contains a DAG of changelists.

The goal of the discovery protocol is to find one set of node *common*,
the set of nodes shared by local and remote.

One of the issue with the original protocol was latency, it could
potentially require lots of roundtrips to discover that the local repo was a
subset of remote (which is a very common case, you usually have few changes
compared to upstream, while upstream probably had lots of development).

The new protocol only requires one interface for the remote repo: `known()`,
which given a set of changelists tells you if they are present in the DAG.

The algorithm then works as follow:

 - We will be using three sets, `common`, `missing`, `unknown`. Originally
 all nodes are in `unknown`.
 - Take a sample from `unknown`, call `remote.known(sample)`
   - For each node that remote knows, move it and all its ancestors to `common`
   - For each node that remote doesn't know, move it and all its descendants
   to `missing`
 - Iterate until `unknown` is empty

There are a couple optimizations, first is instead of starting with a random
sample of missing, start by sending all heads, in the case where the local
repo is a subset, you computed the answer in one round trip.

Then you can do something similar to the bisecting strategy used when
finding faulty changesets. Instead of random samples, you can try picking
nodes that will maximize the number of nodes that will be
classified with it (since all ancestors or descendants will be marked as well).
"""

from node import nullid
from i18n import _
import random
import util, dagutil

def _updatesample(dag, nodes, sample, always, quicksamplesize=0):
    # if nodes is empty we scan the entire graph
    if nodes:
        heads = dag.headsetofconnecteds(nodes)
    else:
        heads = dag.heads()
    dist = {}
    visit = util.deque(heads)
    seen = set()
    factor = 1
    while visit:
        curr = visit.popleft()
        if curr in seen:
            continue
        d = dist.setdefault(curr, 1)
        if d > factor:
            factor *= 2
        if d == factor:
            if curr not in always: # need this check for the early exit below
                sample.add(curr)
                if quicksamplesize and (len(sample) >= quicksamplesize):
                    return
        seen.add(curr)
        for p in dag.parents(curr):
            if not nodes or p in nodes:
                dist.setdefault(p, d + 1)
                visit.append(p)

def _setupsample(dag, nodes, size):
    if len(nodes) <= size:
        return set(nodes), None, 0
    always = dag.headsetofconnecteds(nodes)
    desiredlen = size - len(always)
    if desiredlen <= 0:
        # This could be bad if there are very many heads, all unknown to the
        # server. We're counting on long request support here.
        return always, None, desiredlen
    return always, set(), desiredlen

def _takequicksample(dag, nodes, size, initial):
    always, sample, desiredlen = _setupsample(dag, nodes, size)
    if sample is None:
        return always
    if initial:
        fromset = None
    else:
        fromset = nodes
    _updatesample(dag, fromset, sample, always, quicksamplesize=desiredlen)
    sample.update(always)
    return sample

def _takefullsample(dag, nodes, size):
    always, sample, desiredlen = _setupsample(dag, nodes, size)
    if sample is None:
        return always
    # update from heads
    _updatesample(dag, nodes, sample, always)
    # update from roots
    _updatesample(dag.inverse(), nodes, sample, always)
    assert sample
    if len(sample) > desiredlen:
        sample = set(random.sample(sample, desiredlen))
    elif len(sample) < desiredlen:
        more = desiredlen - len(sample)
        sample.update(random.sample(list(nodes - sample - always), more))
    sample.update(always)
    return sample

def findcommonheads(ui, local, remote,
                    initialsamplesize=100,
                    fullsamplesize=200,
                    abortwhenunrelated=True):
    '''Return a tuple (common, anyincoming, remoteheads) used to identify
    missing nodes from or in remote.
    '''
    roundtrips = 0
    cl = local.changelog
    dag = dagutil.revlogdag(cl)

    # early exit if we know all the specified remote heads already
    ui.debug("query 1; heads\n")
    roundtrips += 1
    ownheads = dag.heads()
    sample = ownheads
    if remote.local():
        # stopgap until we have a proper localpeer that supports batch()
        srvheadhashes = remote.heads()
        yesno = remote.known(dag.externalizeall(sample))
    elif remote.capable('batch'):
        batch = remote.batch()
        srvheadhashesref = batch.heads()
        yesnoref = batch.known(dag.externalizeall(sample))
        batch.submit()
        srvheadhashes = srvheadhashesref.value
        yesno = yesnoref.value
    else:
        # compatibility with pre-batch, but post-known remotes during 1.9
        # development
        srvheadhashes = remote.heads()
        sample = []

    if cl.tip() == nullid:
        if srvheadhashes != [nullid]:
            return [nullid], True, srvheadhashes
        return [nullid], False, []

    # start actual discovery (we note this before the next "if" for
    # compatibility reasons)
    ui.status(_("searching for changes\n"))

    srvheads = dag.internalizeall(srvheadhashes, filterunknown=True)
    if len(srvheads) == len(srvheadhashes):
        ui.debug("all remote heads known locally\n")
        return (srvheadhashes, False, srvheadhashes,)

    if sample and util.all(yesno):
        ui.note(_("all local heads known remotely\n"))
        ownheadhashes = dag.externalizeall(ownheads)
        return (ownheadhashes, True, srvheadhashes,)

    # full blown discovery

    # own nodes where I don't know if remote knows them
    undecided = dag.nodeset()
    # own nodes I know we both know
    common = set()
    # own nodes I know remote lacks
    missing = set()

    # treat remote heads (and maybe own heads) as a first implicit sample
    # response
    common.update(dag.ancestorset(srvheads))
    undecided.difference_update(common)

    full = False
    while undecided:

        if sample:
            commoninsample = set(n for i, n in enumerate(sample) if yesno[i])
            common.update(dag.ancestorset(commoninsample, common))

            missinginsample = [n for i, n in enumerate(sample) if not yesno[i]]
            missing.update(dag.descendantset(missinginsample, missing))

            undecided.difference_update(missing)
            undecided.difference_update(common)

        if not undecided:
            break

        if full:
            ui.note(_("sampling from both directions\n"))
            sample = _takefullsample(dag, undecided, size=fullsamplesize)
        elif common:
            # use cheapish initial sample
            ui.debug("taking initial sample\n")
            sample = _takefullsample(dag, undecided, size=fullsamplesize)
        else:
            # use even cheaper initial sample
            ui.debug("taking quick initial sample\n")
            sample = _takequicksample(dag, undecided, size=initialsamplesize,
                                      initial=True)

        roundtrips += 1
        ui.progress(_('searching'), roundtrips, unit=_('queries'))
        ui.debug("query %i; still undecided: %i, sample size is: %i\n"
                 % (roundtrips, len(undecided), len(sample)))
        # indices between sample and externalized version must match
        sample = list(sample)
        yesno = remote.known(dag.externalizeall(sample))
        full = True

    result = dag.headsetofconnecteds(common)
    ui.progress(_('searching'), None)
    ui.debug("%d total queries\n" % roundtrips)

    if not result and srvheadhashes != [nullid]:
        if abortwhenunrelated:
            raise util.Abort(_("repository is unrelated"))
        else:
            ui.warn(_("warning: repository is unrelated\n"))
        return (set([nullid]), True, srvheadhashes,)

    anyincoming = (srvheadhashes != [nullid])
    return dag.externalizeall(result), anyincoming, srvheadhashes
                                                                                                                                                                                                          usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyc                                          0100644 0000000 0000000 00000015425 13077704337 022360  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s‡   d  Z  d d l m Z d d l m Z d d l Z d d l Z d d l Z d d „ Z d „  Z	 d „  Z
 d	 „  Z d
 d e d „ Z d S(   s;  
Algorithm works in the following way. You have two repository: local and
remote. They both contains a DAG of changelists.

The goal of the discovery protocol is to find one set of node *common*,
the set of nodes shared by local and remote.

One of the issue with the original protocol was latency, it could
potentially require lots of roundtrips to discover that the local repo was a
subset of remote (which is a very common case, you usually have few changes
compared to upstream, while upstream probably had lots of development).

The new protocol only requires one interface for the remote repo: `known()`,
which given a set of changelists tells you if they are present in the DAG.

The algorithm then works as follow:

 - We will be using three sets, `common`, `missing`, `unknown`. Originally
 all nodes are in `unknown`.
 - Take a sample from `unknown`, call `remote.known(sample)`
   - For each node that remote knows, move it and all its ancestors to `common`
   - For each node that remote doesn't know, move it and all its descendants
   to `missing`
 - Iterate until `unknown` is empty

There are a couple optimizations, first is instead of starting with a random
sample of missing, start by sending all heads, in the case where the local
repo is a subset, you computed the answer in one round trip.

Then you can do something similar to the bisecting strategy used when
finding faulty changesets. Instead of random samples, you can try picking
nodes that will maximize the number of nodes that will be
classified with it (since all ancestors or descendants will be marked as well).
iÿÿÿÿ(   t   nullid(   t   _Ni    c         C   sG  | r |  j  | ƒ } n |  j ƒ  } i  } t j | ƒ } t ƒ  } d }	 xø | rB| j ƒ  }
 |
 | k ro qK n  | j |
 d ƒ } | |	 k rš |	 d 9}	 n  | |	 k rá |
 | k rá | j |
 ƒ | rÞ t | ƒ | k rÞ d  Sqá n  | j |
 ƒ xN |  j	 |
 ƒ D]= } | s| | k rþ | j | | d ƒ | j
 | ƒ qþ qþ WqK Wd  S(   Ni   i   (   t   headsetofconnectedst   headst   utilt   dequet   sett   popleftt
   setdefaultt   addt   lent   parentst   append(   t   dagt   nodest   samplet   alwayst   quicksamplesizeR   t   distt   visitt   seent   factort   currt   dt   p(    (    s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyt   _updatesample0   s0    		
c         C   sm   t  | ƒ | k r% t | ƒ d  d f S|  j | ƒ } | t  | ƒ } | d k r] | d  | f S| t ƒ  | f S(   Ni    (   R
   R   t   NoneR   (   R   R   t   sizeR   t
   desiredlen(    (    s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyt   _setupsampleL   s    c         C   sj   t  |  | | ƒ \ } } } | d  k r+ | S| r: d  } n | } t |  | | | d | ƒ| j | ƒ | S(   NR   (   R   R   R   t   update(   R   R   R   t   initialR   R   R   t   fromset(    (    s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyt   _takequicksampleW   s    	c         C   sí   t  |  | | ƒ \ } } } | d  k r+ | St |  | | | ƒ t |  j ƒ  | | | ƒ | sc t ‚ t | ƒ | k r t t j | | ƒ ƒ } nL t | ƒ | k  rÜ | t | ƒ } | j	 t j t
 | | | ƒ | ƒ ƒ n  | j	 | ƒ | S(   N(   R   R   R   t   inverset   AssertionErrorR
   R   t   randomR   R   t   list(   R   R   R   R   R   R   t   more(    (    s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyt   _takefullsamplec   s    *id   iÈ   c            s…  d } | j  } t j | ƒ } |  j d ƒ | d 7} | j ƒ  }	 |	 }
 | j ƒ  rz | j ƒ  } | j | j |
 ƒ ƒ ‰  np | j d ƒ rØ | j	 ƒ  } | j ƒ  } | j | j |
 ƒ ƒ } | j
 ƒ  | j } | j ‰  n | j ƒ  } g  }
 | j ƒ  t k r+| t g k rt g t | f St g t g  f S|  j t d ƒ ƒ | j | d t ƒ} t | ƒ t | ƒ k r…|  j d ƒ | t | f S|
 rÉt j ˆ  ƒ rÉ|  j t d ƒ ƒ | j |	 ƒ } | t | f S| j ƒ  } t ƒ  } t ƒ  } | j | j | ƒ ƒ | j | ƒ t } xº| rÌ|
 r¿t ‡  f d	 †  t |
 ƒ Dƒ ƒ } | j | j | | ƒ ƒ g  t |
 ƒ D] \ } } ˆ  | sg| ^ qg} | j | j | | ƒ ƒ | j | ƒ | j | ƒ n  | sÉPn  | rú|  j t d
 ƒ ƒ t | | d | ƒ}
 nS | r%|  j d ƒ t | | d | ƒ}
 n( |  j d ƒ t | | d | d t ƒ}
 | d 7} |  j  t d ƒ | d t d ƒ ƒ|  j d | t | ƒ t |
 ƒ f ƒ t! |
 ƒ }
 | j | j |
 ƒ ƒ ‰  t } qW| j" | ƒ } |  j  t d ƒ d ƒ |  j d | ƒ | r`| t g k r`| r7t j$ t d ƒ ƒ ‚ n |  j% t d ƒ ƒ t t g ƒ t | f S| t g k } | j | ƒ | | f S(   sl   Return a tuple (common, anyincoming, remoteheads) used to identify
    missing nodes from or in remote.
    i    s   query 1; heads
i   t   batchs   searching for changes
t   filterunknowns   all remote heads known locally
s   all local heads known remotely
c         3   s%   |  ] \ } } ˆ  | r | Vq d  S(   N(    (   t   .0t   it   n(   t   yesno(    s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pys	   <genexpr>º   s    s   sampling from both directions
R   s   taking initial sample
s   taking quick initial sample
R   t	   searchingt   unitt   queriess2   query %i; still undecided: %i, sample size is: %i
s   %d total queries
s   repository is unrelateds!   warning: repository is unrelated
N(&   t	   changelogt   dagutilt	   revlogdagt   debugR   t   localt   knownt   externalizeallt   capableR(   t   submitt   valuet   tipR    t   Truet   Falset   statusR   t   internalizeallR
   R   t   allt   notet   nodesetR   R   t   ancestorsett   difference_updatet	   enumeratet   descendantsetR'   R!   t   progressR%   R   R   t   Abortt   warn(   t   uiR5   t   remotet   initialsamplesizet   fullsamplesizet   abortwhenunrelatedt
   roundtripst   clR   t   ownheadsR   t   srvheadhashesR(   t   srvheadhashesreft   yesnoreft   srvheadst   ownheadhashest	   undecidedt   commont   missingt   fullt   commoninsampleR+   R,   t   missinginsamplet   resultt   anyincoming(    (   R-   s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyt   findcommonheadst   s”    	

				"/	
"	
(   t   __doc__t   nodeR    t   i18nR   R$   R   R2   R   R   R!   R'   R<   R_   (    (    (    s:   /usr/lib/python2.7/dist-packages/mercurial/setdiscovery.pyt   <module>)   s   			                                                                                                                                                                                                                                           usr/lib/python2.7/dist-packages/mercurial/similar.py                                                0100644 0000000 0000000 00000007101 12413056314 021106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # similar.py - mechanisms for finding similar files
#
# Copyright 2005-2007 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
import util
import mdiff
import bdiff

def _findexactmatches(repo, added, removed):
    '''find renamed files that have no changes

    Takes a list of new filectxs and a list of removed filectxs, and yields
    (before, after) tuples of exact matches.
    '''
    numfiles = len(added) + len(removed)

    # Get hashes of removed files.
    hashes = {}
    for i, fctx in enumerate(removed):
        repo.ui.progress(_('searching for exact renames'), i, total=numfiles)
        h = util.sha1(fctx.data()).digest()
        hashes[h] = fctx

    # For each added file, see if it corresponds to a removed file.
    for i, fctx in enumerate(added):
        repo.ui.progress(_('searching for exact renames'), i + len(removed),
                total=numfiles)
        h = util.sha1(fctx.data()).digest()
        if h in hashes:
            yield (hashes[h], fctx)

    # Done
    repo.ui.progress(_('searching for exact renames'), None)

def _findsimilarmatches(repo, added, removed, threshold):
    '''find potentially renamed files based on similar file content

    Takes a list of new filectxs and a list of removed filectxs, and yields
    (before, after, score) tuples of partial matches.
    '''
    copies = {}
    for i, r in enumerate(removed):
        repo.ui.progress(_('searching for similar files'), i,
                         total=len(removed))

        # lazily load text
        @util.cachefunc
        def data():
            orig = r.data()
            return orig, mdiff.splitnewlines(orig)

        def score(text):
            orig, lines = data()
            # bdiff.blocks() returns blocks of matching lines
            # count the number of bytes in each
            equal = 0
            matches = bdiff.blocks(text, orig)
            for x1, x2, y1, y2 in matches:
                for line in lines[y1:y2]:
                    equal += len(line)

            lengths = len(text) + len(orig)
            return equal * 2.0 / lengths

        for a in added:
            bestscore = copies.get(a, (None, threshold))[1]
            myscore = score(a.data())
            if myscore >= bestscore:
                copies[a] = (r, myscore)
    repo.ui.progress(_('searching'), None)

    for dest, v in copies.iteritems():
        source, score = v
        yield source, dest, score

def findrenames(repo, added, removed, threshold):
    '''find renamed files -- yields (before, after, score) tuples'''
    parentctx = repo['.']
    workingctx = repo[None]

    # Zero length files will be frequently unrelated to each other, and
    # tracking the deletion/addition of such a file will probably cause more
    # harm than good. We strip them out here to avoid matching them later on.
    addedfiles = set([workingctx[fp] for fp in added
            if workingctx[fp].size() > 0])
    removedfiles = set([parentctx[fp] for fp in removed
            if fp in parentctx and parentctx[fp].size() > 0])

    # Find exact matches.
    for (a, b) in _findexactmatches(repo,
            sorted(addedfiles), sorted(removedfiles)):
        addedfiles.remove(b)
        yield (a.path(), b.path(), 1.0)

    # If the user requested similar files to be matched, search for them also.
    if threshold < 1.0:
        for (a, b, score) in _findsimilarmatches(repo,
                sorted(addedfiles), sorted(removedfiles), threshold):
            yield (a.path(), b.path(), score)

                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/mercurial/similar.pyc                                               0100644 0000000 0000000 00000006500 13077704337 021267  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sS   d  d l  m Z d  d l Z d  d l Z d  d l Z d „  Z d „  Z d „  Z d S(   iÿÿÿÿ(   t   _Nc         c   s  t  | ƒ t  | ƒ } i  } x^ t | ƒ D]P \ } } |  j j t d ƒ | d | ƒt j | j ƒ  ƒ j ƒ  } | | | <q) Wx| t | ƒ D]n \ } } |  j j t d ƒ | t  | ƒ d | ƒt j | j ƒ  ƒ j ƒ  } | | k rŠ | | | f VqŠ qŠ W|  j j t d ƒ d ƒ d S(   s¦   find renamed files that have no changes

    Takes a list of new filectxs and a list of removed filectxs, and yields
    (before, after) tuples of exact matches.
    s   searching for exact renamest   totalN(
   t   lent	   enumeratet   uit   progressR    t   utilt   sha1t   datat   digestt   None(   t   repot   addedt   removedt   numfilest   hashest   it   fctxt   h(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/similar.pyt   _findexactmatches   s    "c         #   s!  i  } xÄ t  | ƒ D]¶ \ } ‰ |  j j t d ƒ | d t | ƒ ƒt j ‡ f d †  ƒ ‰  ‡  f d †  } x[ | D]S } | j | d | f ƒ d } | | j	 ƒ  ƒ }	 |	 | k rr ˆ |	 f | | <qr qr Wq W|  j j t d ƒ d ƒ x4 | j
 ƒ  D]& \ }
 } | \ } } | |
 | f Vqó Wd S(   sÄ   find potentially renamed files based on similar file content

    Takes a list of new filectxs and a list of removed filectxs, and yields
    (before, after, score) tuples of partial matches.
    s   searching for similar filesR   c             s   ˆ  j  ƒ  }  |  t j |  ƒ f S(   N(   R   t   mdifft   splitnewlines(   t   orig(   t   r(    s5   /usr/lib/python2.7/dist-packages/mercurial/similar.pyR   3   s    c            sŽ   ˆ  ƒ  \ } } d } t  j |  | ƒ } xB | D]: \ } } } } x% | | | !D] }	 | t |	 ƒ 7} qN Wq. Wt |  ƒ t | ƒ }
 | d |
 S(   Ni    g       @(   t   bdifft   blocksR   (   t   textR   t   linest   equalt   matchest   x1t   x2t   y1t   y2t   linet   lengths(   R   (    s5   /usr/lib/python2.7/dist-packages/mercurial/similar.pyt   score8   s    i   t	   searchingN(   R   R   R   R    R   R   t	   cachefunct   getR
   R   t	   iteritems(   R   R   R   t	   thresholdt   copiesR   R$   t   at	   bestscoret   myscoret   destt   vt   source(    (   R   R   s5   /usr/lib/python2.7/dist-packages/mercurial/similar.pyt   _findsimilarmatches'   s    c         c   sJ  |  d } |  d } t g  | D]& } | | j ƒ  d k r | | ^ q ƒ } t g  | D]2 } | | k rW | | j ƒ  d k rW | | ^ qW ƒ } xS t |  t | ƒ t | ƒ ƒ D]3 \ }	 }
 | j |
 ƒ |	 j ƒ  |
 j ƒ  d f Vq± W| d k  rFxO t |  t | ƒ t | ƒ | ƒ D]) \ }	 }
 } |	 j ƒ  |
 j ƒ  | f VqWn  d S(   s:   find renamed files -- yields (before, after, score) tuplest   .i    g      ð?N(   R
   t   sett   sizeR   t   sortedt   removet   pathR1   (   R   R   R   R)   t	   parentctxt
   workingctxt   fpt
   addedfilest   removedfilesR+   t   bR$   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/similar.pyt   findrenamesP   s    

)5	"	((   t   i18nR    R   R   R   R   R1   R>   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/similar.pyt   <module>   s   		)                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/simplemerge.py                                            0100644 0000000 0000000 00000035716 12413056314 021774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (C) 2004, 2005 Canonical Ltd
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.

# mbp: "you know that thing where cvs gives you conflict markers?"
# s: "i hate that."

from i18n import _
import scmutil, util, mdiff
import sys, os

class CantReprocessAndShowBase(Exception):
    pass

def intersect(ra, rb):
    """Given two ranges return the range where they intersect or None.

    >>> intersect((0, 10), (0, 6))
    (0, 6)
    >>> intersect((0, 10), (5, 15))
    (5, 10)
    >>> intersect((0, 10), (10, 15))
    >>> intersect((0, 9), (10, 15))
    >>> intersect((0, 9), (7, 15))
    (7, 9)
    """
    assert ra[0] <= ra[1]
    assert rb[0] <= rb[1]

    sa = max(ra[0], rb[0])
    sb = min(ra[1], rb[1])
    if sa < sb:
        return sa, sb
    else:
        return None

def compare_range(a, astart, aend, b, bstart, bend):
    """Compare a[astart:aend] == b[bstart:bend], without slicing.
    """
    if (aend - astart) != (bend - bstart):
        return False
    for ia, ib in zip(xrange(astart, aend), xrange(bstart, bend)):
        if a[ia] != b[ib]:
            return False
    else:
        return True

class Merge3Text(object):
    """3-way merge of texts.

    Given strings BASE, OTHER, THIS, tries to produce a combined text
    incorporating the changes from both BASE->OTHER and BASE->THIS."""
    def __init__(self, basetext, atext, btext, base=None, a=None, b=None):
        self.basetext = basetext
        self.atext = atext
        self.btext = btext
        if base is None:
            base = mdiff.splitnewlines(basetext)
        if a is None:
            a = mdiff.splitnewlines(atext)
        if b is None:
            b = mdiff.splitnewlines(btext)
        self.base = base
        self.a = a
        self.b = b

    def merge_lines(self,
                    name_a=None,
                    name_b=None,
                    name_base=None,
                    start_marker='<<<<<<<',
                    mid_marker='=======',
                    end_marker='>>>>>>>',
                    base_marker=None,
                    reprocess=False):
        """Return merge in cvs-like form.
        """
        self.conflicts = False
        newline = '\n'
        if len(self.a) > 0:
            if self.a[0].endswith('\r\n'):
                newline = '\r\n'
            elif self.a[0].endswith('\r'):
                newline = '\r'
        if base_marker and reprocess:
            raise CantReprocessAndShowBase
        if name_a:
            start_marker = start_marker + ' ' + name_a
        if name_b:
            end_marker = end_marker + ' ' + name_b
        if name_base and base_marker:
            base_marker = base_marker + ' ' + name_base
        merge_regions = self.merge_regions()
        if reprocess is True:
            merge_regions = self.reprocess_merge_regions(merge_regions)
        for t in merge_regions:
            what = t[0]
            if what == 'unchanged':
                for i in range(t[1], t[2]):
                    yield self.base[i]
            elif what == 'a' or what == 'same':
                for i in range(t[1], t[2]):
                    yield self.a[i]
            elif what == 'b':
                for i in range(t[1], t[2]):
                    yield self.b[i]
            elif what == 'conflict':
                self.conflicts = True
                yield start_marker + newline
                for i in range(t[3], t[4]):
                    yield self.a[i]
                if base_marker is not None:
                    yield base_marker + newline
                    for i in range(t[1], t[2]):
                        yield self.base[i]
                yield mid_marker + newline
                for i in range(t[5], t[6]):
                    yield self.b[i]
                yield end_marker + newline
            else:
                raise ValueError(what)

    def merge_annotated(self):
        """Return merge with conflicts, showing origin of lines.

        Most useful for debugging merge.
        """
        for t in self.merge_regions():
            what = t[0]
            if what == 'unchanged':
                for i in range(t[1], t[2]):
                    yield 'u | ' + self.base[i]
            elif what == 'a' or what == 'same':
                for i in range(t[1], t[2]):
                    yield what[0] + ' | ' + self.a[i]
            elif what == 'b':
                for i in range(t[1], t[2]):
                    yield 'b | ' + self.b[i]
            elif what == 'conflict':
                yield '<<<<\n'
                for i in range(t[3], t[4]):
                    yield 'A | ' + self.a[i]
                yield '----\n'
                for i in range(t[5], t[6]):
                    yield 'B | ' + self.b[i]
                yield '>>>>\n'
            else:
                raise ValueError(what)

    def merge_groups(self):
        """Yield sequence of line groups.  Each one is a tuple:

        'unchanged', lines
             Lines unchanged from base

        'a', lines
             Lines taken from a

        'same', lines
             Lines taken from a (and equal to b)

        'b', lines
             Lines taken from b

        'conflict', base_lines, a_lines, b_lines
             Lines from base were changed to either a or b and conflict.
        """
        for t in self.merge_regions():
            what = t[0]
            if what == 'unchanged':
                yield what, self.base[t[1]:t[2]]
            elif what == 'a' or what == 'same':
                yield what, self.a[t[1]:t[2]]
            elif what == 'b':
                yield what, self.b[t[1]:t[2]]
            elif what == 'conflict':
                yield (what,
                       self.base[t[1]:t[2]],
                       self.a[t[3]:t[4]],
                       self.b[t[5]:t[6]])
            else:
                raise ValueError(what)

    def merge_regions(self):
        """Return sequences of matching and conflicting regions.

        This returns tuples, where the first value says what kind we
        have:

        'unchanged', start, end
             Take a region of base[start:end]

        'same', astart, aend
             b and a are different from base but give the same result

        'a', start, end
             Non-clashing insertion from a[start:end]

        Method is as follows:

        The two sequences align only on regions which match the base
        and both descendants.  These are found by doing a two-way diff
        of each one against the base, and then finding the
        intersections between those regions.  These "sync regions"
        are by definition unchanged in both and easily dealt with.

        The regions in between can be in any of three cases:
        conflicted, or changed on only one side.
        """

        # section a[0:ia] has been disposed of, etc
        iz = ia = ib = 0

        for region in self.find_sync_regions():
            zmatch, zend, amatch, aend, bmatch, bend = region
            #print 'match base [%d:%d]' % (zmatch, zend)

            matchlen = zend - zmatch
            assert matchlen >= 0
            assert matchlen == (aend - amatch)
            assert matchlen == (bend - bmatch)

            len_a = amatch - ia
            len_b = bmatch - ib
            len_base = zmatch - iz
            assert len_a >= 0
            assert len_b >= 0
            assert len_base >= 0

            #print 'unmatched a=%d, b=%d' % (len_a, len_b)

            if len_a or len_b:
                # try to avoid actually slicing the lists
                equal_a = compare_range(self.a, ia, amatch,
                                        self.base, iz, zmatch)
                equal_b = compare_range(self.b, ib, bmatch,
                                        self.base, iz, zmatch)
                same = compare_range(self.a, ia, amatch,
                                     self.b, ib, bmatch)

                if same:
                    yield 'same', ia, amatch
                elif equal_a and not equal_b:
                    yield 'b', ib, bmatch
                elif equal_b and not equal_a:
                    yield 'a', ia, amatch
                elif not equal_a and not equal_b:
                    yield 'conflict', iz, zmatch, ia, amatch, ib, bmatch
                else:
                    raise AssertionError("can't handle a=b=base but unmatched")

                ia = amatch
                ib = bmatch
            iz = zmatch

            # if the same part of the base was deleted on both sides
            # that's OK, we can just skip it.


            if matchlen > 0:
                assert ia == amatch
                assert ib == bmatch
                assert iz == zmatch

                yield 'unchanged', zmatch, zend
                iz = zend
                ia = aend
                ib = bend

    def reprocess_merge_regions(self, merge_regions):
        """Where there are conflict regions, remove the agreed lines.

        Lines where both A and B have made the same changes are
        eliminated.
        """
        for region in merge_regions:
            if region[0] != "conflict":
                yield region
                continue
            type, iz, zmatch, ia, amatch, ib, bmatch = region
            a_region = self.a[ia:amatch]
            b_region = self.b[ib:bmatch]
            matches = mdiff.get_matching_blocks(''.join(a_region),
                                                ''.join(b_region))
            next_a = ia
            next_b = ib
            for region_ia, region_ib, region_len in matches[:-1]:
                region_ia += ia
                region_ib += ib
                reg = self.mismatch_region(next_a, region_ia, next_b,
                                           region_ib)
                if reg is not None:
                    yield reg
                yield 'same', region_ia, region_len + region_ia
                next_a = region_ia + region_len
                next_b = region_ib + region_len
            reg = self.mismatch_region(next_a, amatch, next_b, bmatch)
            if reg is not None:
                yield reg

    def mismatch_region(next_a, region_ia,  next_b, region_ib):
        if next_a < region_ia or next_b < region_ib:
            return 'conflict', None, None, next_a, region_ia, next_b, region_ib
    mismatch_region = staticmethod(mismatch_region)

    def find_sync_regions(self):
        """Return a list of sync regions, where both descendants match the base.

        Generates a list of (base1, base2, a1, a2, b1, b2).  There is
        always a zero-length sync region at the end of all the files.
        """

        ia = ib = 0
        amatches = mdiff.get_matching_blocks(self.basetext, self.atext)
        bmatches = mdiff.get_matching_blocks(self.basetext, self.btext)
        len_a = len(amatches)
        len_b = len(bmatches)

        sl = []

        while ia < len_a and ib < len_b:
            abase, amatch, alen = amatches[ia]
            bbase, bmatch, blen = bmatches[ib]

            # there is an unconflicted block at i; how long does it
            # extend?  until whichever one ends earlier.
            i = intersect((abase, abase + alen), (bbase, bbase + blen))
            if i:
                intbase = i[0]
                intend = i[1]
                intlen = intend - intbase

                # found a match of base[i[0], i[1]]; this may be less than
                # the region that matches in either one
                assert intlen <= alen
                assert intlen <= blen
                assert abase <= intbase
                assert bbase <= intbase

                asub = amatch + (intbase - abase)
                bsub = bmatch + (intbase - bbase)
                aend = asub + intlen
                bend = bsub + intlen

                assert self.base[intbase:intend] == self.a[asub:aend], \
                       (self.base[intbase:intend], self.a[asub:aend])

                assert self.base[intbase:intend] == self.b[bsub:bend]

                sl.append((intbase, intend,
                           asub, aend,
                           bsub, bend))

            # advance whichever one ends first in the base text
            if (abase + alen) < (bbase + blen):
                ia += 1
            else:
                ib += 1

        intbase = len(self.base)
        abase = len(self.a)
        bbase = len(self.b)
        sl.append((intbase, intbase, abase, abase, bbase, bbase))

        return sl

    def find_unconflicted(self):
        """Return a list of ranges in base that are not conflicted."""
        am = mdiff.get_matching_blocks(self.basetext, self.atext)
        bm = mdiff.get_matching_blocks(self.basetext, self.btext)

        unc = []

        while am and bm:
            # there is an unconflicted block at i; how long does it
            # extend?  until whichever one ends earlier.
            a1 = am[0][0]
            a2 = a1 + am[0][2]
            b1 = bm[0][0]
            b2 = b1 + bm[0][2]
            i = intersect((a1, a2), (b1, b2))
            if i:
                unc.append(i)

            if a2 < b2:
                del am[0]
            else:
                del bm[0]

        return unc

def simplemerge(ui, local, base, other, **opts):
    def readfile(filename):
        f = open(filename, "rb")
        text = f.read()
        f.close()
        if util.binary(text):
            msg = _("%s looks like a binary file.") % filename
            if not opts.get('quiet'):
                ui.warn(_('warning: %s\n') % msg)
            if not opts.get('text'):
                raise util.Abort(msg)
        return text

    name_a = local
    name_b = other
    labels = opts.get('label', [])
    if len(labels) > 0:
        name_a = labels[0]
    if len(labels) > 1:
        name_b = labels[1]
    if len(labels) > 2:
        raise util.Abort(_("can only specify two labels."))

    try:
        localtext = readfile(local)
        basetext = readfile(base)
        othertext = readfile(other)
    except util.Abort:
        return 1

    local = os.path.realpath(local)
    if not opts.get('print'):
        opener = scmutil.opener(os.path.dirname(local))
        out = opener(os.path.basename(local), "w", atomictemp=True)
    else:
        out = sys.stdout

    reprocess = not opts.get('no_minimal')

    m3 = Merge3Text(basetext, localtext, othertext)
    for line in m3.merge_lines(name_a=name_a, name_b=name_b,
                               reprocess=reprocess):
        out.write(line)

    if not opts.get('print'):
        out.close()

    if m3.conflicts:
        if not opts.get('quiet'):
            ui.warn(_("warning: conflicts during merge.\n"))
        return 1
                                                  usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyc                                           0100644 0000000 0000000 00000030314 13077704337 022140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s—   d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d e f d „  ƒ  YZ d „  Z	 d „  Z
 d e f d „  ƒ  YZ d	 „  Z d S(
   iÿÿÿÿ(   t   _Nt   CantReprocessAndShowBasec           B   s   e  Z RS(    (   t   __name__t
   __module__(    (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyR      s   c         C   s€   |  d |  d k s t  ‚ | d | d k s4 t  ‚ t |  d | d ƒ } t |  d | d ƒ } | | k  rx | | f Sd Sd S(   s  Given two ranges return the range where they intersect or None.

    >>> intersect((0, 10), (0, 6))
    (0, 6)
    >>> intersect((0, 10), (5, 15))
    (5, 10)
    >>> intersect((0, 10), (10, 15))
    >>> intersect((0, 9), (10, 15))
    >>> intersect((0, 9), (7, 15))
    (7, 9)
    i    i   N(   t   AssertionErrort   maxt   mint   None(   t   rat   rbt   sat   sb(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt	   intersect   s    
c         C   sj   | | | | k r t  SxK t t | | ƒ t | | ƒ ƒ D]$ \ } } |  | | | k r: t  Sq: Wt Sd S(   s?   Compare a[astart:aend] == b[bstart:bend], without slicing.
    N(   t   Falset   zipt   xranget   True(   t   at   astartt   aendt   bt   bstartt   bendt   iat   ib(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   compare_range0   s    .t
   Merge3Textc        	   B   sŒ   e  Z d  Z d d d d „ Z d d d d d d d e d „ Z d „  Z d „  Z d „  Z	 d	 „  Z
 d
 „  Z e e ƒ Z d „  Z d „  Z RS(   s    3-way merge of texts.

    Given strings BASE, OTHER, THIS, tries to produce a combined text
    incorporating the changes from both BASE->OTHER and BASE->THIS.c         C   s”   | |  _  | |  _ | |  _ | d  k r9 t j | ƒ } n  | d  k rW t j | ƒ } n  | d  k ru t j | ƒ } n  | |  _ | |  _ | |  _ d  S(   N(	   t   basetextt   atextt   btextR   t   mdifft   splitnewlinest   baseR   R   (   t   selfR   R   R   R    R   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   __init__@   s    					s   <<<<<<<s   =======s   >>>>>>>c	         c   s²  t  |  _ d }	 t |  j ƒ d k re |  j d j d ƒ rC d }	 qe |  j d j d ƒ re d }	 qe n  | rz | rz t ‚ n  | r‘ | d | } n  | r¨ | d | } n  | rÅ | rÅ | d | } n  |  j ƒ  }
 | t k rï |  j |
 ƒ }
 n  x¼|
 D]´} | d } | d k rCx•t	 | d | d ƒ D] } |  j
 | Vq*Wqö | d	 k s[| d
 k rŒxLt	 | d | d ƒ D] } |  j | VqsWqö | d k rÉxt	 | d | d ƒ D] } |  j | Vq°Wqö | d k ržt |  _ | |	 Vx+ t	 | d | d ƒ D] } |  j | VqÿW| d k	 r[| |	 Vx. t	 | d | d ƒ D] } |  j
 | VqBWn  | |	 Vx+ t	 | d | d ƒ D] } |  j | Vq|W| |	 Vqö t | ƒ ‚ qö Wd S(   s'   Return merge in cvs-like form.
        s   
i    s   
s   t    t	   unchangedi   i   R   t   sameR   t   conflicti   i   i   i   N(   R   t	   conflictst   lenR   t   endswithR   t   merge_regionsR   t   reprocess_merge_regionst   rangeR    R   R   t
   ValueError(   R!   t   name_at   name_bt	   name_baset   start_markert
   mid_markert
   end_markert   base_markert	   reprocesst   newlineR*   t   tt   whatt   i(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   merge_linesN   sV    			
				c         c   sŠ  xƒ|  j  ƒ  D]u} | d } | d k r^ xVt | d | d ƒ D] } d |  j | VqA Wq | d k sv | d k r³ x	t | d | d ƒ D] } | d d |  j | VqŽ Wq | d	 k rô xÀ t | d | d ƒ D] } d
 |  j | Vq× Wq | d k rvd Vx/ t | d | d ƒ D] } d |  j | VqWd Vx/ t | d | d ƒ D] } d |  j | VqTWd Vq t | ƒ ‚ q Wd S(   sh   Return merge with conflicts, showing origin of lines.

        Most useful for debugging merge.
        i    R$   i   i   s   u | R   R%   s    | R   s   b | R&   s   <<<<
i   i   s   A | s   ----
i   i   s   B | s   >>>>
N(   R*   R,   R    R   R   R-   (   R!   R7   R8   R9   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   merge_annotated†   s(    
c         c   s  x|  j  ƒ  D]} | d } | d k rI | |  j | d | d !f Vq | d k sa | d k r | |  j | d | d !f Vq | d k r­ | |  j | d | d !f Vq | d k r| |  j | d | d !|  j | d	 | d
 !|  j | d | d !f Vq t | ƒ ‚ q Wd S(   s«  Yield sequence of line groups.  Each one is a tuple:

        'unchanged', lines
             Lines unchanged from base

        'a', lines
             Lines taken from a

        'same', lines
             Lines taken from a (and equal to b)

        'b', lines
             Lines taken from b

        'conflict', base_lines, a_lines, b_lines
             Lines from base were changed to either a or b and conflict.
        i    R$   i   i   R   R%   R   R&   i   i   i   i   N(   R*   R    R   R   R-   (   R!   R7   R8   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   merge_groups¡   s    
   c         c   sP  d } } } x;|  j  ƒ  D]-} | \ } } } } }	 }
 | | } | d k sU t ‚ | | | k sk t ‚ | |
 |	 k s t ‚ | | } |	 | } | | } | d k s± t ‚ | d k sÃ t ‚ | d k sÕ t ‚ | sá | rÝt |  j | | |  j | | ƒ } t |  j | |	 |  j | | ƒ } t |  j | | |  j | |	 ƒ } | r[d | | f Vns | ry| ryd | |	 f VnU | r—| r—d | | f Vn7 | rÂ| rÂd | | | | | |	 f Vn t d ƒ ‚ | } |	 } n  | } | d k r | | k st ‚ | |	 k st ‚ | | k s%t ‚ d | | f V| } | } |
 } q q Wd S(	   sp  Return sequences of matching and conflicting regions.

        This returns tuples, where the first value says what kind we
        have:

        'unchanged', start, end
             Take a region of base[start:end]

        'same', astart, aend
             b and a are different from base but give the same result

        'a', start, end
             Non-clashing insertion from a[start:end]

        Method is as follows:

        The two sequences align only on regions which match the base
        and both descendants.  These are found by doing a two-way diff
        of each one against the base, and then finding the
        intersections between those regions.  These "sync regions"
        are by definition unchanged in both and easily dealt with.

        The regions in between can be in any of three cases:
        conflicted, or changed on only one side.
        i    R%   R   R   R&   s#   can't handle a=b=base but unmatchedR$   N(   t   find_sync_regionsR   R   R   R    R   (   R!   t   izR   R   t   regiont   zmatcht   zendt   amatchR   t   bmatchR   t   matchlent   len_at   len_bt   len_baset   equal_at   equal_bR%   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyR*   Ã   sP    



	c         c   sK  xD| D]<} | d d k r( | Vq n  | \ } } } } } } }	 |  j  | | !}
 |  j | |	 !} t j d j |
 ƒ d j | ƒ ƒ } | } | } x | d  D]u \ } } } | | 7} | | 7} |  j | | | | ƒ } | d k	 rí | Vn  d | | | f V| | } | | } qž W|  j | | | |	 ƒ } | d k	 r | Vq q Wd S(   s˜   Where there are conflict regions, remove the agreed lines.

        Lines where both A and B have made the same changes are
        eliminated.
        i    R&   t    iÿÿÿÿR%   N(   R   R   R   t   get_matching_blockst   joint   mismatch_regionR   (   R!   R*   R?   t   typeR>   R@   R   RB   R   RC   t   a_regiont   b_regiont   matchest   next_at   next_bt	   region_iat	   region_ibt
   region_lent   reg(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyR+     s0    

	
c         C   s5   |  | k  s | | k  r1 d d  d  |  | | | f Sd  S(   NR&   (   R   (   RR   RT   RS   RU   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyRM   8  s    c         C   se  d } } t  j |  j |  j ƒ } t  j |  j |  j ƒ } t | ƒ } t | ƒ } g  } xº| | k  r| | k  r| | \ } }	 }
 | | \ } } } t | | |
 f | | | f ƒ } | ræ| d } | d } | | } | |
 k sò t ‚ | | k st ‚ | | k st ‚ | | k s(t ‚ |	 | | } | | | } | | } | | } |  j | | !|  j	 | | !k sžt |  j | | !|  j	 | | !f ƒ ‚ |  j | | !|  j
 | | !k sÄt ‚ | j | | | | | | f ƒ n  | |
 | | k  r| d 7} q[ | d 7} q[ Wt |  j ƒ } t |  j	 ƒ } t |  j
 ƒ } | j | | | | | | f ƒ | S(   sÛ   Return a list of sync regions, where both descendants match the base.

        Generates a list of (base1, base2, a1, a2, b1, b2).  There is
        always a zero-length sync region at the end of all the files.
        i    i   (   R   RK   R   R   R   R(   R   R   R    R   R   t   append(   R!   R   R   t   amatchest   bmatchesRE   RF   t   slt   abaseRB   t   alent   bbaseRC   t   blenR9   t   intbaset   intendt   intlent   asubt   bsubR   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyR=   =  sH    
#




##&c   	      C   sÛ   t  j |  j |  j ƒ } t  j |  j |  j ƒ } g  } xž | rÖ | rÖ | d d } | | d d } | d d } | | d d } t | | f | | f ƒ } | r¶ | j | ƒ n  | | k  rÌ | d =q9 | d =q9 W| S(   s8   Return a list of ranges in base that are not conflicted.i    i   (   R   RK   R   R   R   R   RX   (	   R!   t   amt   bmt   unct   a1t   a2t   b1t   b2R9   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   find_unconflictedz  s    
N(   R   R   t   __doc__R   R"   R   R:   R;   R<   R*   R+   RM   t   staticmethodR=   Rl   (    (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyR   ;   s$   0		"	V			=c            së  ‡  ‡ f d †  } | } | } ˆ  j  d g  ƒ } t | ƒ d k rO | d } n  t | ƒ d k rn | d } n  t | ƒ d k r˜ t j t d ƒ ƒ ‚ n  y( | | ƒ }	 | | ƒ }
 | | ƒ } Wn t j k
 r× d SXt j j | ƒ } ˆ  j  d ƒ s8t j	 t j j
 | ƒ ƒ } | t j j | ƒ d d	 t ƒ} n	 t j } ˆ  j  d
 ƒ } t |
 |	 | ƒ } x3 | j d | d | d | ƒ D] } | j | ƒ q‚Wˆ  j  d ƒ sµ| j ƒ  n  | j rçˆ  j  d ƒ sãˆ j t d ƒ ƒ n  d Sd  S(   Nc            s•   t  |  d ƒ } | j ƒ  } | j ƒ  t j | ƒ r‘ t d ƒ |  } ˆ  j d ƒ sm ˆ j t d ƒ | ƒ n  ˆ  j d ƒ s‘ t j | ƒ ‚ q‘ n  | S(   NR	   s   %s looks like a binary file.t   quiets   warning: %s
t   text(	   t   opent   readt   closet   utilt   binaryR    t   gett   warnt   Abort(   t   filenamet   fRp   t   msg(   t   optst   ui(    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   readfile”  s    
t   labeli    i   i   s   can only specify two labels.t   printt   wt
   atomictempt
   no_minimalR.   R/   R5   Ro   s!   warning: conflicts during merge.
(   Rv   R(   Rt   Rx   R    t   ost   patht   realpatht   scmutilt   openert   dirnamet   basenameR   t   syst   stdoutR   R:   t   writeRs   R'   Rw   (   R}   t   localR    t   otherR|   R~   R.   R/   t   labelst	   localtextR   t	   othertextRˆ   t   outR5   t   m3t   line(    (   R|   R}   s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   simplemerge“  s@    $		(   t   i18nR    R‡   Rt   R   R‹   R„   t	   ExceptionR   R   R   t   objectR   R–   (    (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/simplemerge.pyt   <module>   s   $		ÿ Y                                                                                                                                                                                                                                                                                                                    usr/lib/python2.7/dist-packages/mercurial/sshpeer.py                                                0100644 0000000 0000000 00000017375 12712351006 021133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # sshpeer.py - ssh repository proxy class for mercurial
#
# Copyright 2005, 2006 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

import re
from i18n import _
import util, error, wireproto

class remotelock(object):
    def __init__(self, repo):
        self.repo = repo
    def release(self):
        self.repo.unlock()
        self.repo = None
    def __del__(self):
        if self.repo:
            self.release()

def _serverquote(s):
    if not s:
        return s
    '''quote a string for the remote shell ... which we assume is sh'''
    if re.match('[a-zA-Z0-9@%_+=:,./-]*$', s):
        return s
    return "'%s'" % s.replace("'", "'\\''")

class sshpeer(wireproto.wirepeer):
    def __init__(self, ui, path, create=False):
        self._url = path
        self.ui = ui
        self.pipeo = self.pipei = self.pipee = None

        u = util.url(path, parsequery=False, parsefragment=False)
        if u.scheme != 'ssh' or not u.host or u.path is None:
            self._abort(error.RepoError(_("couldn't parse location %s") % path))

        self.user = u.user
        if u.passwd is not None:
            self._abort(error.RepoError(_("password in URL not supported")))
        self.host = u.host
        self.port = u.port
        self.path = u.path or "."

        sshcmd = self.ui.config("ui", "ssh", "ssh")
        remotecmd = self.ui.config("ui", "remotecmd", "hg")

        args = util.sshargs(sshcmd,
                            _serverquote(self.host),
                            _serverquote(self.user),
                            _serverquote(self.port))

        if create:
            cmd = '%s %s %s' % (sshcmd, args,
                util.shellquote("%s init %s" %
                    (_serverquote(remotecmd), _serverquote(self.path))))
            ui.debug('running %s\n' % cmd)
            res = util.system(cmd)
            if res != 0:
                self._abort(error.RepoError(_("could not create remote repo")))

        self._validaterepo(sshcmd, args, remotecmd)

    def url(self):
        return self._url

    def _validaterepo(self, sshcmd, args, remotecmd):
        # cleanup up previous run
        self.cleanup()

        cmd = '%s %s %s' % (sshcmd, args,
            util.shellquote("%s -R %s serve --stdio" %
                (_serverquote(remotecmd), _serverquote(self.path))))
        self.ui.debug('running %s\n' % cmd)
        cmd = util.quotecommand(cmd)

        # while self.subprocess isn't used, having it allows the subprocess to
        # to clean up correctly later
        self.pipeo, self.pipei, self.pipee, self.subprocess = util.popen4(cmd)

        # skip any noise generated by remote shell
        self._callstream("hello")
        r = self._callstream("between", pairs=("%s-%s" % ("0"*40, "0"*40)))
        lines = ["", "dummy"]
        max_noise = 500
        while lines[-1] and max_noise:
            l = r.readline()
            self.readerr()
            if lines[-1] == "1\n" and l == "\n":
                break
            if l:
                self.ui.debug("remote: ", l)
            lines.append(l)
            max_noise -= 1
        else:
            self._abort(error.RepoError(_('no suitable response from '
                                          'remote hg')))

        self._caps = set()
        for l in reversed(lines):
            if l.startswith("capabilities:"):
                self._caps.update(l[:-1].split(":")[1].split())
                break

    def _capabilities(self):
        return self._caps

    def readerr(self):
        while True:
            size = util.fstat(self.pipee).st_size
            if size == 0:
                break
            s = self.pipee.read(size)
            if not s:
                break
            for l in s.splitlines():
                self.ui.status(_("remote: "), l, '\n')

    def _abort(self, exception):
        self.cleanup()
        raise exception

    def cleanup(self):
        if self.pipeo is None:
            return
        self.pipeo.close()
        self.pipei.close()
        try:
            # read the error descriptor until EOF
            for l in self.pipee:
                self.ui.status(_("remote: "), l)
        except (IOError, ValueError):
            pass
        self.pipee.close()

    __del__ = cleanup

    def _callstream(self, cmd, **args):
        self.ui.debug("sending %s command\n" % cmd)
        self.pipeo.write("%s\n" % cmd)
        _func, names = wireproto.commands[cmd]
        keys = names.split()
        wireargs = {}
        for k in keys:
            if k == '*':
                wireargs['*'] = args
                break
            else:
                wireargs[k] = args[k]
                del args[k]
        for k, v in sorted(wireargs.iteritems()):
            self.pipeo.write("%s %d\n" % (k, len(v)))
            if isinstance(v, dict):
                for dk, dv in v.iteritems():
                    self.pipeo.write("%s %d\n" % (dk, len(dv)))
                    self.pipeo.write(dv)
            else:
                self.pipeo.write(v)
        self.pipeo.flush()

        return self.pipei

    def _callcompressable(self, cmd, **args):
        return self._callstream(cmd, **args)

    def _call(self, cmd, **args):
        self._callstream(cmd, **args)
        return self._recv()

    def _callpush(self, cmd, fp, **args):
        r = self._call(cmd, **args)
        if r:
            return '', r
        while True:
            d = fp.read(4096)
            if not d:
                break
            self._send(d)
        self._send("", flush=True)
        r = self._recv()
        if r:
            return '', r
        return self._recv(), ''

    def _calltwowaystream(self, cmd, fp, **args):
        r = self._call(cmd, **args)
        if r:
            # XXX needs to be made better
            raise util.Abort('unexpected remote reply: %s' % r)
        while True:
            d = fp.read(4096)
            if not d:
                break
            self._send(d)
        self._send("", flush=True)
        return self.pipei

    def _recv(self):
        l = self.pipei.readline()
        if l == '\n':
            err = []
            while True:
                line = self.pipee.readline()
                if line == '-\n':
                    break
                err.extend([line])
            if len(err) > 0:
                # strip the trailing newline added to the last line server-side
                err[-1] = err[-1][:-1]
            self._abort(error.OutOfBandError(*err))
        self.readerr()
        try:
            l = int(l)
        except ValueError:
            self._abort(error.ResponseError(_("unexpected response:"), l))
        return self.pipei.read(l)

    def _send(self, data, flush=False):
        self.pipeo.write("%d\n" % len(data))
        if data:
            self.pipeo.write(data)
        if flush:
            self.pipeo.flush()
        self.readerr()

    def lock(self):
        self._call("lock")
        return remotelock(self)

    def unlock(self):
        self._call("unlock")

    def addchangegroup(self, cg, source, url, lock=None):
        '''Send a changegroup to the remote server.  Return an integer
        similar to unbundle(). DEPRECATED, since it requires locking the
        remote.'''
        d = self._call("addchangegroup")
        if d:
            self._abort(error.RepoError(_("push refused: %s") % d))
        while True:
            d = cg.read(4096)
            if not d:
                break
            self.pipeo.write(d)
            self.readerr()

        self.pipeo.flush()

        self.readerr()
        r = self._recv()
        if not r:
            return 1
        try:
            return int(r)
        except ValueError:
            self._abort(error.ResponseError(_("unexpected response:"), r))

instance = sshpeer
                                                                                                                                                                                                                                                                   usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyc                                               0100644 0000000 0000000 00000022126 13077704337 021302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ò)Wc           @   s‚   d  d l  Z  d  d l m Z d  d l Z d  d l Z d  d l Z d e f d „  ƒ  YZ d „  Z d e j	 f d „  ƒ  YZ
 e
 Z d S(   iÿÿÿÿN(   t   _t
   remotelockc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         C   s   | |  _  d  S(   N(   t   repo(   t   selfR   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   __init__   s    c         C   s   |  j  j ƒ  d  |  _  d  S(   N(   R   t   unlockt   None(   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   release   s    c         C   s   |  j  r |  j ƒ  n  d  S(   N(   R   R   (   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   __del__   s    	(   t   __name__t
   __module__R   R   R   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR      s   		c         C   s4   |  s
 |  St  j d |  ƒ r  |  Sd |  j d d ƒ S(   Ns   [a-zA-Z0-9@%_+=:,./-]*$s   '%s't   's   '\''(   t   ret   matcht   replace(   t   s(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   _serverquote   s
    t   sshpeerc           B   s°   e  Z e d  „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 e	 Z
 d „  Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z e d „ Z d „  Z d „  Z d d „ Z RS(   c   
      C   sö  | |  _  | |  _ d  |  _ |  _ |  _ t j | d t d t ƒ} | j	 d k sl | j
 sl | j d  k r |  j t j t d ƒ | ƒ ƒ n  | j |  _ | j d  k	 rÉ |  j t j t d ƒ ƒ ƒ n  | j
 |  _
 | j |  _ | j pí d |  _ |  j j d d d ƒ } |  j j d d d	 ƒ } t j | t |  j
 ƒ t |  j ƒ t |  j ƒ ƒ } | rßd
 | | t j d t | ƒ t |  j ƒ f ƒ f } | j d | ƒ t j | ƒ }	 |	 d k rß|  j t j t d ƒ ƒ ƒ qßn  |  j | | | ƒ d  S(   Nt
   parsequeryt   parsefragmentt   sshs   couldn't parse location %ss   password in URL not supportedt   .t   uit	   remotecmdt   hgs   %s %s %ss
   %s init %ss   running %s
i    s   could not create remote repo(   t   _urlR   R   t   pipeot   pipeit   pipeet   utilt   urlt   Falset   schemet   hostt   patht   _abortt   errort	   RepoErrorR    t   usert   passwdt   portt   configt   sshargsR   t
   shellquotet   debugt   systemt   _validaterepo(
   R   R   R"   t   createt   ut   sshcmdR   t   argst   cmdt   res(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR      s6    		(#			#"c         C   s   |  j  S(   N(   R   (   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR   B   s    c   	      C   sÌ  |  j  ƒ  d | | t j d t | ƒ t |  j ƒ f ƒ f } |  j j d | ƒ t j | ƒ } t j | ƒ \ |  _	 |  _
 |  _ |  _ |  j d ƒ |  j d d d d d	 d d	 f ƒ} d
 d g } d } x™ | d rN| rN| j ƒ  } |  j ƒ  | d d k r| d k rPn  | r4|  j j d | ƒ n  | j | ƒ | d 8} qÒ W|  j t j t d ƒ ƒ ƒ t ƒ  |  _ xN t | ƒ D]@ } | j d ƒ r„|  j j | d  j d ƒ d j ƒ  ƒ Pq„q„Wd  S(   Ns   %s %s %ss   %s -R %s serve --stdios   running %s
t   hellot   betweent   pairss   %s-%st   0i(   t    t   dummyiô  iÿÿÿÿs   1
s   
s   remote: i   s#   no suitable response from remote hgs   capabilities:t   :(   t   cleanupR   R+   R   R"   R   R,   t   quotecommandt   popen4R   R   R   t
   subprocesst   _callstreamt   readlinet   readerrt   appendR#   R$   R%   R    t   sett   _capst   reversedt
   startswitht   updatet   split(	   R   R1   R2   R   R3   t   rt   linest	   max_noiset   l(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR.   E   s4    
		#''
'c         C   s   |  j  S(   N(   RE   (   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   _capabilitiesk   s    c         C   s…   x~ t  r€ t j |  j ƒ j } | d k r. Pn  |  j j | ƒ } | sJ Pn  x0 | j ƒ  D]" } |  j j t	 d ƒ | d ƒ qW Wq Wd  S(   Ni    s   remote: s   
(
   t   TrueR   t   fstatR   t   st_sizet   readt
   splitlinesR   t   statusR    (   R   t   sizeR   RM   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyRB   n   s    	c         C   s   |  j  ƒ  | ‚ d  S(   N(   R<   (   R   t	   exception(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR#   y   s    
c         C   s‰   |  j  d  k r d  S|  j  j ƒ  |  j j ƒ  y1 x* |  j D] } |  j j t d ƒ | ƒ q: WWn t t	 f k
 rw n X|  j j ƒ  d  S(   Ns   remote: (
   R   R   t   closeR   R   R   RT   R    t   IOErrort
   ValueError(   R   RM   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR<   }   s    !c         K   sS  |  j  j d | ƒ |  j j d | ƒ t j | \ } } | j ƒ  } i  } x= | D]5 } | d k rt | | d <PqT | | | | <| | =qT Wx¯ t | j ƒ  ƒ D]› \ } } |  j j d | t	 | ƒ f ƒ t
 | t ƒ r+x] | j ƒ  D]< \ }	 }
 |  j j d |	 t	 |
 ƒ f ƒ |  j j |
 ƒ qè Wq  |  j j | ƒ q  W|  j j ƒ  |  j S(   Ns   sending %s command
s   %s
t   *s   %s %d
(   R   R,   R   t   writet	   wireprotot   commandsRI   t   sortedt	   iteritemst   lent
   isinstancet   dictt   flushR   (   R   R3   R2   t   _funct   namest   keyst   wireargst   kt   vt   dkt   dv(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR@   Œ   s(    
  c         K   s   |  j  | |  S(   N(   R@   (   R   R3   R2   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   _callcompressable¥   s    c         K   s   |  j  | |  |  j ƒ  S(   N(   R@   t   _recv(   R   R3   R2   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   _call¨   s    c         K   s”   |  j  | |  } | r" d | f Sx0 t rT | j d ƒ } | sD Pn  |  j | ƒ q% W|  j d d t ƒ|  j ƒ  } | r„ d | f S|  j ƒ  d f S(   NR9   i   Rc   (   Rn   RO   RR   t   _sendRm   (   R   R3   t   fpR2   RJ   t   d(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt	   _callpush¬   s    
	
c         K   s{   |  j  | |  } | r. t j d | ƒ ‚ n  x0 t r` | j d ƒ } | sP Pn  |  j | ƒ q1 W|  j d d t ƒ|  j S(   Ns   unexpected remote reply: %si   R9   Rc   (   Rn   R   t   AbortRO   RR   Ro   R   (   R   R3   Rp   R2   RJ   Rq   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   _calltwowaystream»   s    	c         C   sú   |  j  j ƒ  } | d k r g  } x9 t r\ |  j j ƒ  } | d k rI Pn  | j | g ƒ q$ Wt | ƒ d k r„ | d d  | d <n  |  j t j | Œ  ƒ n  |  j	 ƒ  y t
 | ƒ } Wn0 t k
 ré |  j t j t d ƒ | ƒ ƒ n X|  j  j | ƒ S(   Ns   
s   -
i    iÿÿÿÿs   unexpected response:(   R   RA   RO   R   t   extendR`   R#   R$   t   OutOfBandErrorRB   t   intRY   t   ResponseErrorR    RR   (   R   RM   t   errt   line(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyRm   È   s"    	
#c         C   sW   |  j  j d t | ƒ ƒ | r3 |  j  j | ƒ n  | rI |  j  j ƒ  n  |  j ƒ  d  S(   Ns   %d
(   R   R[   R`   Rc   RB   (   R   t   dataRc   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyRo   Ü   s    c         C   s   |  j  d ƒ t |  ƒ S(   Nt   lock(   Rn   R   (   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR|   ä   s    c         C   s   |  j  d ƒ d  S(   NR   (   Rn   (   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR   è   s    c         C   sê   |  j  d ƒ } | r8 |  j t j t d ƒ | ƒ ƒ n  x= t rw | j d ƒ } | sZ Pn  |  j j | ƒ |  j	 ƒ  q; W|  j j
 ƒ  |  j	 ƒ  |  j ƒ  } | s¥ d Sy t | ƒ SWn0 t k
 rå |  j t j t d ƒ | ƒ ƒ n Xd S(   s”   Send a changegroup to the remote server.  Return an integer
        similar to unbundle(). DEPRECATED, since it requires locking the
        remote.t   addchangegroups   push refused: %si   i   s   unexpected response:N(   Rn   R#   R$   R%   R    RO   RR   R   R[   RB   Rc   Rm   Rw   RY   Rx   (   R   t   cgt   sourceR   R|   Rq   RJ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR}   ë   s$    #	
N(   R	   R
   R   R   R   R.   RN   RB   R#   R<   R   R@   Rl   Rn   Rr   Rt   Rm   Ro   R|   R   R   R}   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyR      s$   #		&												(   R   t   i18nR    R   R$   R\   t   objectR   R   t   wirepeerR   t   instance(    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sshpeer.pyt   <module>   s   $
	æ                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python2.7/dist-packages/mercurial/sshserver.py                                              0100644 0000000 0000000 00000010322 12413056314 021471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # sshserver.py - ssh protocol server support for mercurial
#
# Copyright 2005-2007 Matt Mackall <mpm@selenic.com>
# Copyright 2006 Vadim Gelfer <vadim.gelfer@gmail.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

import util, hook, wireproto, changegroup
import os, sys

class sshserver(wireproto.abstractserverproto):
    def __init__(self, ui, repo):
        self.ui = ui
        self.repo = repo
        self.lock = None
        self.fin = ui.fin
        self.fout = ui.fout

        hook.redirect(True)
        ui.fout = repo.ui.fout = ui.ferr

        # Prevent insertion/deletion of CRs
        util.setbinary(self.fin)
        util.setbinary(self.fout)

    def getargs(self, args):
        data = {}
        keys = args.split()
        for n in xrange(len(keys)):
            argline = self.fin.readline()[:-1]
            arg, l = argline.split()
            if arg not in keys:
                raise util.Abort("unexpected parameter %r" % arg)
            if arg == '*':
                star = {}
                for k in xrange(int(l)):
                    argline = self.fin.readline()[:-1]
                    arg, l = argline.split()
                    val = self.fin.read(int(l))
                    star[arg] = val
                data['*'] = star
            else:
                val = self.fin.read(int(l))
                data[arg] = val
        return [data[k] for k in keys]

    def getarg(self, name):
        return self.getargs(name)[0]

    def getfile(self, fpout):
        self.sendresponse('')
        count = int(self.fin.readline())
        while count:
            fpout.write(self.fin.read(count))
            count = int(self.fin.readline())

    def redirect(self):
        pass

    def groupchunks(self, changegroup):
        while True:
            d = changegroup.read(4096)
            if not d:
                break
            yield d

    def sendresponse(self, v):
        self.fout.write("%d\n" % len(v))
        self.fout.write(v)
        self.fout.flush()

    def sendstream(self, source):
        write = self.fout.write
        for chunk in source.gen:
            write(chunk)
        self.fout.flush()

    def sendpushresponse(self, rsp):
        self.sendresponse('')
        self.sendresponse(str(rsp.res))

    def sendpusherror(self, rsp):
        self.sendresponse(rsp.res)

    def sendooberror(self, rsp):
        self.ui.ferr.write('%s\n-\n' % rsp.message)
        self.ui.ferr.flush()
        self.fout.write('\n')
        self.fout.flush()

    def serve_forever(self):
        try:
            while self.serve_one():
                pass
        finally:
            if self.lock is not None:
                self.lock.release()
        sys.exit(0)

    handlers = {
        str: sendresponse,
        wireproto.streamres: sendstream,
        wireproto.pushres: sendpushresponse,
        wireproto.pusherr: sendpusherror,
        wireproto.ooberror: sendooberror,
    }

    def serve_one(self):
        cmd = self.fin.readline()[:-1]
        if cmd and cmd in wireproto.commands:
            rsp = wireproto.dispatch(self.repo, self, cmd)
            self.handlers[rsp.__class__](self, rsp)
        elif cmd:
            impl = getattr(self, 'do_' + cmd, None)
            if impl:
                r = impl()
                if r is not None:
                    self.sendresponse(r)
            else: self.sendresponse("")
        return cmd != ''

    def do_lock(self):
        '''DEPRECATED - allowing remote client to lock repo is not safe'''

        self.lock = self.repo.lock()
        return ""

    def do_unlock(self):
        '''DEPRECATED'''

        if self.lock:
            self.lock.release()
        self.lock = None
        return ""

    def do_addchangegroup(self):
        '''DEPRECATED'''

        if not self.lock:
            self.sendresponse("not locked")
            return

        self.sendresponse("")
        cg = changegroup.unbundle10(self.fin, "UN")
        r = changegroup.addchangegroup(self.repo, cg, 'serve', self._client())
        self.lock.release()
        return str(r)

    def _client(self):
        client = os.environ.get('SSH_CLIENT', '').split(' ', 1)[0]
        return 'remote:ssh:' + client
                                                                                                                                                                                                                                                                                                              usr/lib/python2.7/dist-packages/mercurial/sshserver.pyc                                             0100644 0000000 0000000 00000013400 13077704337 021650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   se   d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d e j f d „  ƒ  YZ d S(   iÿÿÿÿNt	   sshserverc           B   sÖ   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z i e e 6e	 e j 6e
 e j 6e e j 6e e j 6Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   c         C   sz   | |  _  | |  _ d  |  _ | j |  _ | j |  _ t j t ƒ | j	 | _ | j  _ t
 j |  j ƒ t
 j |  j ƒ d  S(   N(   t   uit   repot   Nonet   lockt   fint   foutt   hookt   redirectt   Truet   ferrt   utilt	   setbinary(   t   selfR   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   __init__   s    			c         C   s6  i  } | j  ƒ  } xt t | ƒ ƒ D]ò } |  j j ƒ  d  } | j  ƒ  \ } } | | k rr t j d | ƒ ‚ n  | d k rõ i  } xa t t | ƒ ƒ D]M }	 |  j j ƒ  d  } | j  ƒ  \ } } |  j j t | ƒ ƒ }
 |
 | | <q— W| | d <q% |  j j t | ƒ ƒ }
 |
 | | <q% Wg  | D] }	 | |	 ^ q"S(   Niÿÿÿÿs   unexpected parameter %rt   *(	   t   splitt   xranget   lenR   t   readlineR   t   Abortt   intt   read(   R   t   argst   datat   keyst   nt   arglinet   argt   lt   start   kt   val(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   getargs   s$    c         C   s   |  j  | ƒ d S(   Ni    (   R!   (   R   t   name(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   getarg0   s    c         C   sa   |  j  d ƒ t |  j j ƒ  ƒ } x8 | r\ | j |  j j | ƒ ƒ t |  j j ƒ  ƒ } q% Wd  S(   Nt    (   t   sendresponseR   R   R   t   writeR   (   R   t   fpoutt   count(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   getfile3   s
    	c         C   s   d  S(   N(    (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyR   :   s    c         c   s/   x( t  r* | j d ƒ } | s" Pn  | Vq Wd  S(   Ni   (   R	   R   (   R   t   changegroupt   d(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   groupchunks=   s
    	c         C   s;   |  j  j d t | ƒ ƒ |  j  j | ƒ |  j  j ƒ  d  S(   Ns   %d
(   R   R&   R   t   flush(   R   t   v(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyR%   D   s    c         C   s;   |  j  j } x | j D] } | | ƒ q W|  j  j ƒ  d  S(   N(   R   R&   t   genR-   (   R   t   sourceR&   t   chunk(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt
   sendstreamI   s    c         C   s'   |  j  d ƒ |  j  t | j ƒ ƒ d  S(   NR$   (   R%   t   strt   res(   R   t   rsp(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   sendpushresponseO   s    c         C   s   |  j  | j ƒ d  S(   N(   R%   R4   (   R   R5   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   sendpusherrorS   s    c         C   sK   |  j  j j d | j ƒ |  j  j j ƒ  |  j j d ƒ |  j j ƒ  d  S(   Ns   %s
-
s   
(   R   R
   R&   t   messageR-   R   (   R   R5   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   sendooberrorV   s    c         C   sK   z x |  j  ƒ  r q WWd  |  j d  k	 r9 |  j j ƒ  n  Xt j d ƒ d  S(   Ni    (   t	   serve_oneR   R   t   releaset   syst   exit(   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   serve_forever\   s    c         C   s¾   |  j  j ƒ  d  } | rZ | t j k rZ t j |  j |  | ƒ } |  j | j |  | ƒ nZ | r´ t |  d | d  ƒ } | r¤ | ƒ  } | d  k	 r± |  j
 | ƒ q± q´ |  j
 d ƒ n  | d k S(   Niÿÿÿÿt   do_R$   (   R   R   t	   wireprotot   commandst   dispatchR   t   handlerst	   __class__t   getattrR   R%   (   R   t   cmdR5   t   implt   r(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyR:   m   s    	c         C   s   |  j  j ƒ  |  _ d S(   s<   DEPRECATED - allowing remote client to lock repo is not safeR$   (   R   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   do_lock{   s    c         C   s&   |  j  r |  j  j ƒ  n  d |  _  d S(   t
   DEPRECATEDR$   N(   R   R;   R   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt	   do_unlock   s    		c         C   st   |  j  s |  j d ƒ d S|  j d ƒ t j |  j d ƒ } t j |  j | d |  j ƒ  ƒ } |  j  j ƒ  t	 | ƒ S(   RJ   s
   not lockedNR$   t   UNt   serve(
   R   R%   R*   t
   unbundle10R   t   addchangegroupR   t   _clientR;   R3   (   R   t   cgRH   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   do_addchangegroup‰   s    	!c         C   s-   t  j j d d ƒ j d d ƒ d } d | S(   Nt
   SSH_CLIENTR$   t    i   i    s   remote:ssh:(   t   ost   environt   getR   (   R   t   client(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyRP   –   s    %(   t   __name__t
   __module__R   R!   R#   R)   R   R,   R%   R2   R6   R7   R9   R>   R3   R@   t	   streamrest   pushrest   pusherrt   ooberrorRC   R:   RI   RK   RR   RP   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyR       s.   													


				(   R   R   R@   R*   RU   R<   t   abstractserverprotoR    (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/sshserver.pyt   <module>	   s   0                                                                                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/sslutil.py                                                0100644 0000000 0000000 00000015733 12413056314 021157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # sslutil.py - SSL handling for mercurial
#
# Copyright 2005, 2006, 2007, 2008 Matt Mackall <mpm@selenic.com>
# Copyright 2006, 2007 Alexis S. L. Carvalho <alexis@cecm.usp.br>
# Copyright 2006 Vadim Gelfer <vadim.gelfer@gmail.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.
import os

from mercurial import util
from mercurial.i18n import _
try:
    # avoid using deprecated/broken FakeSocket in python 2.6
    import ssl
    CERT_REQUIRED = ssl.CERT_REQUIRED
    PROTOCOL_SSLv23 = ssl.PROTOCOL_SSLv23
    PROTOCOL_TLSv1 = ssl.PROTOCOL_TLSv1
    def ssl_wrap_socket(sock, keyfile, certfile, ssl_version=PROTOCOL_TLSv1,
                cert_reqs=ssl.CERT_NONE, ca_certs=None):
        sslsocket = ssl.wrap_socket(sock, keyfile, certfile,
                                    cert_reqs=cert_reqs, ca_certs=ca_certs,
                                    ssl_version=ssl_version)
        # check if wrap_socket failed silently because socket had been closed
        # - see http://bugs.python.org/issue13721
        if not sslsocket.cipher():
            raise util.Abort(_('ssl connection failed'))
        return sslsocket
except ImportError:
    CERT_REQUIRED = 2

    PROTOCOL_SSLv23 = 2
    PROTOCOL_TLSv1 = 3

    import socket, httplib

    def ssl_wrap_socket(sock, keyfile, certfile, ssl_version=PROTOCOL_TLSv1,
                        cert_reqs=CERT_REQUIRED, ca_certs=None):
        if not util.safehasattr(socket, 'ssl'):
            raise util.Abort(_('Python SSL support not found'))
        if ca_certs:
            raise util.Abort(_(
                'certificate checking requires Python 2.6'))

        ssl = socket.ssl(sock, keyfile, certfile)
        return httplib.FakeSocket(sock, ssl)

def _verifycert(cert, hostname):
    '''Verify that cert (in socket.getpeercert() format) matches hostname.
    CRLs is not handled.

    Returns error message if any problems are found and None on success.
    '''
    if not cert:
        return _('no certificate received')
    dnsname = hostname.lower()
    def matchdnsname(certname):
        return (certname == dnsname or
                '.' in dnsname and certname == '*.' + dnsname.split('.', 1)[1])

    san = cert.get('subjectAltName', [])
    if san:
        certnames = [value.lower() for key, value in san if key == 'DNS']
        for name in certnames:
            if matchdnsname(name):
                return None
        if certnames:
            return _('certificate is for %s') % ', '.join(certnames)

    # subject is only checked when subjectAltName is empty
    for s in cert.get('subject', []):
        key, value = s[0]
        if key == 'commonName':
            try:
                # 'subject' entries are unicode
                certname = value.lower().encode('ascii')
            except UnicodeEncodeError:
                return _('IDN in certificate not supported')
            if matchdnsname(certname):
                return None
            return _('certificate is for %s') % certname
    return _('no commonName or subjectAltName found in certificate')


# CERT_REQUIRED means fetch the cert from the server all the time AND
# validate it against the CA store provided in web.cacerts.
#
# We COMPLETELY ignore CERT_REQUIRED on Python <= 2.5, as it's totally
# busted on those versions.

def sslkwargs(ui, host):
    cacerts = ui.config('web', 'cacerts')
    forcetls = ui.configbool('ui', 'tls', default=True)
    if forcetls:
        ssl_version = PROTOCOL_TLSv1
    else:
        ssl_version = PROTOCOL_SSLv23
    hostfingerprint = ui.config('hostfingerprints', host)
    kws = {'ssl_version': ssl_version,
           }
    if cacerts and not hostfingerprint:
        cacerts = util.expandpath(cacerts)
        if not os.path.exists(cacerts):
            raise util.Abort(_('could not find web.cacerts: %s') % cacerts)
        kws.update({'ca_certs': cacerts,
                    'cert_reqs': CERT_REQUIRED,
                    })
    return kws

class validator(object):
    def __init__(self, ui, host):
        self.ui = ui
        self.host = host

    def __call__(self, sock, strict=False):
        host = self.host
        cacerts = self.ui.config('web', 'cacerts')
        hostfingerprint = self.ui.config('hostfingerprints', host)
        if not getattr(sock, 'getpeercert', False): # python 2.5 ?
            if hostfingerprint:
                raise util.Abort(_("host fingerprint for %s can't be "
                                   "verified (Python too old)") % host)
            if strict:
                raise util.Abort(_("certificate for %s can't be verified "
                                   "(Python too old)") % host)
            if self.ui.configbool('ui', 'reportoldssl', True):
                self.ui.warn(_("warning: certificate for %s can't be verified "
                               "(Python too old)\n") % host)
            return

        if not sock.cipher(): # work around http://bugs.python.org/issue13721
            raise util.Abort(_('%s ssl connection error') % host)
        try:
            peercert = sock.getpeercert(True)
            peercert2 = sock.getpeercert()
        except AttributeError:
            raise util.Abort(_('%s ssl connection error') % host)

        if not peercert:
            raise util.Abort(_('%s certificate error: '
                               'no certificate received') % host)
        peerfingerprint = util.sha1(peercert).hexdigest()
        nicefingerprint = ":".join([peerfingerprint[x:x + 2]
            for x in xrange(0, len(peerfingerprint), 2)])
        if hostfingerprint:
            if peerfingerprint.lower() != \
                    hostfingerprint.replace(':', '').lower():
                raise util.Abort(_('certificate for %s has unexpected '
                                   'fingerprint %s') % (host, nicefingerprint),
                                 hint=_('check hostfingerprint configuration'))
            self.ui.debug('%s certificate matched fingerprint %s\n' %
                          (host, nicefingerprint))
        elif cacerts:
            msg = _verifycert(peercert2, host)
            if msg:
                raise util.Abort(_('%s certificate error: %s') % (host, msg),
                                 hint=_('configure hostfingerprint %s or use '
                                        '--insecure to connect insecurely') %
                                      nicefingerprint)
            self.ui.debug('%s certificate successfully verified\n' % host)
        elif strict:
            raise util.Abort(_('%s certificate with fingerprint %s not '
                               'verified') % (host, nicefingerprint),
                             hint=_('check hostfingerprints or web.cacerts '
                                     'config setting'))
        else:
            self.ui.warn(_('warning: %s certificate with fingerprint %s not '
                           'verified (check hostfingerprints or web.cacerts '
                           'config setting)\n') %
                         (host, nicefingerprint))
                                     usr/lib/python2.7/dist-packages/mercurial/sslutil.pyc                                               0100644 0000000 0000000 00000013506 13077704337 021332  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sè   d  d l  Z  d  d l m Z d  d l m Z y@ d  d l Z e j Z e j Z e j Z e e j	 d d „ Z WnM e k
 r» d Z d Z d Z d  d l Z d  d l Z e e d d „ Z n Xd „  Z d	 „  Z d
 e f d „  ƒ  YZ d S(   iÿÿÿÿN(   t   util(   t   _c      
   C   sO   t  j |  | | d | d | d | ƒ} | j ƒ  sK t j t d ƒ ƒ ‚ n  | S(   Nt	   cert_reqst   ca_certst   ssl_versions   ssl connection failed(   t   sslt   wrap_sockett   cipherR    t   AbortR   (   t   sockt   keyfilet   certfileR   R   R   t	   sslsocket(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt   ssl_wrap_socket   s    	i   i   c         C   sm   t  j t d ƒ s* t  j t d ƒ ƒ ‚ n  | rH t  j t d ƒ ƒ ‚ n  t j |  | | ƒ } t j |  | ƒ S(   NR   s   Python SSL support not founds(   certificate checking requires Python 2.6(   R    t   safehasattrt   socketR   R   R   t   httplibt
   FakeSocket(   R	   R
   R   R   R   R   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyR   %   s    	c   
         sJ  |  s t  d ƒ S| j ƒ  ‰  ‡  f d †  } |  j d g  ƒ } | rµ g  | D]$ \ } } | d k rJ | j ƒ  ^ qJ } x | D] } | | ƒ r{ d Sq{ W| rµ t  d ƒ d j | ƒ Sn  xˆ |  j d g  ƒ D]t } | d \ } } | d	 k rÈ y | j ƒ  j d
 ƒ }	 Wn t k
 rt  d ƒ SX| |	 ƒ r.d St  d ƒ |	 SqÈ Wt  d ƒ S(   s«   Verify that cert (in socket.getpeercert() format) matches hostname.
    CRLs is not handled.

    Returns error message if any problems are found and None on success.
    s   no certificate receivedc            s6   |  ˆ  k p5 d ˆ  k o5 |  d ˆ  j  d d ƒ d k S(   Nt   .s   *.i   (   t   split(   t   certname(   t   dnsname(    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt   matchdnsname9   s    t   subjectAltNamet   DNSs   certificate is for %ss   , t   subjecti    t
   commonNamet   asciis    IDN in certificate not supporteds4   no commonName or subjectAltName found in certificateN(   R   t   lowert   gett   Nonet   joint   encodet   UnicodeEncodeError(
   t   certt   hostnameR   t   sant   keyt   valuet	   certnamest   namet   sR   (    (   R   s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt   _verifycert0   s.    
1c         C   sÊ   |  j  d d ƒ } |  j d d d t ƒ} | r9 t } n t } |  j  d | ƒ } i | d 6} | rÆ | rÆ t j | ƒ } t j j	 | ƒ s¨ t j
 t d ƒ | ƒ ‚ n  | j i | d	 6t d
 6ƒ n  | S(   Nt   webt   cacertst   uit   tlst   defaultt   hostfingerprintsR   s   could not find web.cacerts: %sR   R   (   t   configt
   configboolt   Truet   PROTOCOL_TLSv1t   PROTOCOL_SSLv23R    t
   expandpatht   ost   patht   existsR   R   t   updatet   CERT_REQUIRED(   R-   t   hostR,   t   forcetlsR   t   hostfingerprintt   kws(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt	   sslkwargs[   s    	t	   validatorc           B   s   e  Z d  „  Z e d „ Z RS(   c         C   s   | |  _  | |  _ d  S(   N(   R-   R<   (   t   selfR-   R<   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt   __init__o   s    	c         C   sÝ  |  j  } |  j j d d ƒ } |  j j d | ƒ } t | d t ƒ sÂ | rg t j t d ƒ | ƒ ‚ n  | r‰ t j t d ƒ | ƒ ‚ n  |  j j d d t	 ƒ r¾ |  j j
 t d	 ƒ | ƒ n  d  S| j ƒ  sê t j t d
 ƒ | ƒ ‚ n  y | j t	 ƒ } | j ƒ  } Wn* t k
 r5t j t d
 ƒ | ƒ ‚ n X| sXt j t d ƒ | ƒ ‚ n  t j | ƒ j ƒ  } d j g  t d t | ƒ d ƒ D] }	 | |	 |	 d !^ qŒƒ }
 | r!| j ƒ  | j d d ƒ j ƒ  k rt j t d ƒ | |
 f d t d ƒ ƒ‚ n  |  j j d | |
 f ƒ n¸ | r…t | | ƒ } | rnt j t d ƒ | | f d t d ƒ |
 ƒ‚ n  |  j j d | ƒ nT | r¹t j t d ƒ | |
 f d t d ƒ ƒ‚ n  |  j j
 t d ƒ | |
 f ƒ d  S(   NR+   R,   R0   t   getpeercerts:   host fingerprint for %s can't be verified (Python too old)s5   certificate for %s can't be verified (Python too old)R-   t   reportoldssls?   warning: certificate for %s can't be verified (Python too old)
s   %s ssl connection errors-   %s certificate error: no certificate receivedt   :i    i   t    s0   certificate for %s has unexpected fingerprint %st   hints#   check hostfingerprint configurations&   %s certificate matched fingerprint %s
s   %s certificate error: %ssD   configure hostfingerprint %s or use --insecure to connect insecurelys%   %s certificate successfully verified
s/   %s certificate with fingerprint %s not verifieds4   check hostfingerprints or web.cacerts config settingsp   warning: %s certificate with fingerprint %s not verified (check hostfingerprints or web.cacerts config setting)
(   R<   R-   R1   t   getattrt   FalseR    R   R   R2   R3   t   warnR   RD   t   AttributeErrort   sha1t	   hexdigestR   t   xranget   lenR   t   replacet   debugR*   (   RB   R	   t   strictR<   R,   R>   t   peercertt	   peercert2t   peerfingerprintt   xt   nicefingerprintt   msg(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt   __call__s   s`    		6		(   t   __name__t
   __module__RC   RJ   RZ   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyRA   n   s   	(   R7   t	   mercurialR    t   mercurial.i18nR   R   R;   R5   R4   t	   CERT_NONER   R   t   ImportErrorR   R   R*   R@   t   objectRA   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/sslutil.pyt   <module>	   s&   				
	+	                                                                                                                                                                                          usr/lib/python2.7/dist-packages/mercurial/statichttprepo.py                                         0100644 0000000 0000000 00000012372 12413056314 022531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # statichttprepo.py - simple http repository class for mercurial
#
# This provides read-only repo access to repositories exported via static http
#
# Copyright 2005-2007 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
import changelog, byterange, url, error
import localrepo, manifest, util, scmutil, store
import urllib, urllib2, errno, os

class httprangereader(object):
    def __init__(self, url, opener):
        # we assume opener has HTTPRangeHandler
        self.url = url
        self.pos = 0
        self.opener = opener
        self.name = url
    def seek(self, pos):
        self.pos = pos
    def read(self, bytes=None):
        req = urllib2.Request(self.url)
        end = ''
        if bytes:
            end = self.pos + bytes - 1
        if self.pos or end:
            req.add_header('Range', 'bytes=%d-%s' % (self.pos, end))

        try:
            f = self.opener.open(req)
            data = f.read()
            # Python 2.6+ defines a getcode() function, and 2.4 and
            # 2.5 appear to always have an undocumented code attribute
            # set. If we can't read either of those, fall back to 206
            # and hope for the best.
            code = getattr(f, 'getcode', lambda : getattr(f, 'code', 206))()
        except urllib2.HTTPError, inst:
            num = inst.code == 404 and errno.ENOENT or None
            raise IOError(num, inst)
        except urllib2.URLError, inst:
            raise IOError(None, inst.reason[1])

        if code == 200:
            # HTTPRangeHandler does nothing if remote does not support
            # Range headers and returns the full entity. Let's slice it.
            if bytes:
                data = data[self.pos:self.pos + bytes]
            else:
                data = data[self.pos:]
        elif bytes:
            data = data[:bytes]
        self.pos += len(data)
        return data
    def readlines(self):
        return self.read().splitlines(True)
    def __iter__(self):
        return iter(self.readlines())
    def close(self):
        pass

def build_opener(ui, authinfo):
    # urllib cannot handle URLs with embedded user or passwd
    urlopener = url.opener(ui, authinfo)
    urlopener.add_handler(byterange.HTTPRangeHandler())

    class statichttpvfs(scmutil.abstractvfs):
        def __init__(self, base):
            self.base = base

        def __call__(self, path, mode="r", atomictemp=None):
            if mode not in ('r', 'rb'):
                raise IOError('Permission denied')
            f = "/".join((self.base, urllib.quote(path)))
            return httprangereader(f, urlopener)

        def join(self, path):
            if path:
                return os.path.join(self.base, path)
            else:
                return self.base

    return statichttpvfs

class statichttppeer(localrepo.localpeer):
    def local(self):
        return None
    def canpush(self):
        return False

class statichttprepository(localrepo.localrepository):
    supported = localrepo.localrepository._basesupported

    def __init__(self, ui, path):
        self._url = path
        self.ui = ui

        self.root = path
        u = util.url(path.rstrip('/') + "/.hg")
        self.path, authinfo = u.authinfo()

        opener = build_opener(ui, authinfo)
        self.opener = opener(self.path)
        self.vfs = self.opener
        self._phasedefaults = []

        try:
            requirements = scmutil.readrequires(self.opener, self.supported)
        except IOError, inst:
            if inst.errno != errno.ENOENT:
                raise
            requirements = set()

            # check if it is a non-empty old-style repository
            try:
                fp = self.opener("00changelog.i")
                fp.read(1)
                fp.close()
            except IOError, inst:
                if inst.errno != errno.ENOENT:
                    raise
                # we do not care about empty old-style repositories here
                msg = _("'%s' does not appear to be an hg repository") % path
                raise error.RepoError(msg)

        # setup store
        self.store = store.store(requirements, self.path, opener)
        self.spath = self.store.path
        self.sopener = self.store.opener
        self.svfs = self.sopener
        self.sjoin = self.store.join
        self._filecache = {}
        self.requirements = requirements

        self.manifest = manifest.manifest(self.sopener)
        self.changelog = changelog.changelog(self.sopener)
        self._tags = None
        self.nodetagscache = None
        self._branchcaches = {}
        self.encodepats = None
        self.decodepats = None

    def _restrictcapabilities(self, caps):
        caps = super(statichttprepository, self)._restrictcapabilities(caps)
        return caps.difference(["pushkey"])

    def url(self):
        return self._url

    def local(self):
        return False

    def peer(self):
        return statichttppeer(self)

    def lock(self, wait=True):
        raise util.Abort(_('cannot lock static-http repository'))

def instance(ui, path, create):
    if create:
        raise util.Abort(_('cannot create new static-http repository'))
    return statichttprepository(ui, path[7:])
                                                                                                                                                                                                                                                                      usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyc                                        0100644 0000000 0000000 00000016400 13077704337 022704  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s
  d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l Z d  d l Z d  d l Z d  d l Z d e f d „  ƒ  YZ d „  Z d e j f d „  ƒ  YZ d e j f d	 „  ƒ  YZ d
 „  Z d S(   iÿÿÿÿ(   t   _Nt   httprangereaderc           B   sA   e  Z d  „  Z d „  Z d d „ Z d „  Z d „  Z d „  Z RS(   c         C   s(   | |  _  d |  _ | |  _ | |  _ d  S(   Ni    (   t   urlt   post   openert   name(   t   selfR   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   __init__   s    			c         C   s   | |  _  d  S(   N(   R   (   R   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   seek   s    c            sz  t  j |  j ƒ } d } | r2 |  j | d } n  |  j sA | ra | j d d |  j | f ƒ n  y@ |  j j | ƒ ‰  ˆ  j ƒ  } t ˆ  d ‡  f d †  ƒ ƒ  } Wnn t  j	 k
 ræ } | j
 d k rÎ t j pÑ d  } t | | ƒ ‚ n, t  j k
 r} t d  | j d ƒ ‚ n X| d k rN| r>| |  j |  j | !} qa| |  j } n | ra| |  } n  |  j t | ƒ 7_ | S(	   Nt    i   t   Ranges   bytes=%d-%st   getcodec              s   t  ˆ  d d ƒ S(   Nt   codeiÎ   (   t   getattr(    (   t   f(    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   <lambda>'   s    i”  iÈ   (   t   urllib2t   RequestR   R   t
   add_headerR   t   opent   readR   t	   HTTPErrorR   t   errnot   ENOENTt   Nonet   IOErrort   URLErrort   reasont   len(   R   t   bytest   reqt   endt   dataR   t   instt   num(    (   R   s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR      s.     "c         C   s   |  j  ƒ  j t ƒ S(   N(   R   t
   splitlinest   True(   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt	   readlines9   s    c         C   s   t  |  j ƒ  ƒ S(   N(   t   iterR%   (   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   __iter__;   s    c         C   s   d  S(   N(    (   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   close=   s    N(	   t   __name__t
   __module__R   R   R   R   R%   R'   R(   (    (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR      s   		!		c            sH   t  j |  | ƒ ‰  ˆ  j t j ƒ  ƒ d t j f ‡  f d †  ƒ  Y} | S(   Nt   statichttpvfsc              s/   e  Z d  „  Z d d ‡  f d † Z d „  Z RS(   c         S   s   | |  _  d  S(   N(   t   base(   R   R,   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR   F   s    t   rc            sI   | d k r t  d ƒ ‚ n  d j |  j t j | ƒ f ƒ } t | ˆ  ƒ S(   NR-   t   rbs   Permission deniedt   /(   R-   s   rb(   R   t   joinR,   t   urllibt   quoteR   (   R   t   patht   modet
   atomictempR   (   t	   urlopener(    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   __call__I   s    !c         S   s'   | r t  j j |  j | ƒ S|  j Sd  S(   N(   t   osR3   R0   R,   (   R   R3   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR0   O   s    N(   R)   R*   R   R   R7   R0   (    (   R6   (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR+   E   s   	(   R   R   t   add_handlert	   byteranget   HTTPRangeHandlert   scmutilt   abstractvfs(   t   uit   authinfoR+   (    (   R6   s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   build_opener@   s    t   statichttppeerc           B   s   e  Z d  „  Z d „  Z RS(   c         C   s   d  S(   N(   R   (   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   localX   s    c         C   s   t  S(   N(   t   False(   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   canpushZ   s    (   R)   R*   RB   RD   (    (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyRA   W   s   	t   statichttprepositoryc           B   sM   e  Z e j j Z d  „  Z d „  Z d „  Z d „  Z	 d „  Z
 e d „ Z RS(   c   
      C   s  | |  _  | |  _ | |  _ t j | j d ƒ d ƒ } | j ƒ  \ |  _ } t | | ƒ } | |  j ƒ |  _	 |  j	 |  _
 g  |  _ y t j |  j	 |  j ƒ } Wn« t k
 rK} | j t j k rÈ ‚  n  t ƒ  } y* |  j	 d ƒ } | j d ƒ | j ƒ  WqLt k
 rG} | j t j k r%‚  n  t d ƒ | }	 t j |	 ƒ ‚ qLXn Xt j | |  j | ƒ |  _ |  j j |  _ |  j j	 |  _ |  j |  _ |  j j |  _ i  |  _ | |  _ t  j  |  j ƒ |  _  t! j! |  j ƒ |  _! d  |  _# d  |  _$ i  |  _% d  |  _& d  |  _' d  S(   NR/   s   /.hgs   00changelog.ii   s+   '%s' does not appear to be an hg repository((   t   _urlR>   t   roott   utilR   t   rstripR?   R3   R@   R   t   vfst   _phasedefaultsR<   t   readrequirest	   supportedR   R   R   t   setR   R(   R    t   errort	   RepoErrort   storet   spatht   sopenert   svfsR0   t   sjoint
   _filecachet   requirementst   manifestt	   changelogR   t   _tagst   nodetagscachet   _branchcachest
   encodepatst
   decodepats(
   R   R>   R3   t   uR?   R   RW   R!   t   fpt   msg(    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR   `   sL    											c         C   s(   t  t |  ƒ j | ƒ } | j d g ƒ S(   Nt   pushkey(   t   superRE   t   _restrictcapabilitiest
   difference(   R   t   caps(    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyRd   ‘   s    c         C   s   |  j  S(   N(   RF   (   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyR   •   s    c         C   s   t  S(   N(   RC   (   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyRB   ˜   s    c         C   s
   t  |  ƒ S(   N(   RA   (   R   (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   peer›   s    c         C   s   t  j t d ƒ ƒ ‚ d  S(   Ns"   cannot lock static-http repository(   RH   t   AbortR    (   R   t   wait(    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   lockž   s    (   R)   R*   t	   localrepot   localrepositoryt   _basesupportedRM   R   Rd   R   RB   Rg   R$   Rj   (    (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyRE   ]   s   	1				c         C   s/   | r t  j t d ƒ ƒ ‚ n  t |  | d ƒ S(   Ns(   cannot create new static-http repositoryi   (   RH   Rh   R    RE   (   R>   R3   t   create(    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   instance¡   s    (   t   i18nR    RY   R:   R   RO   Rk   RX   RH   R<   RQ   R1   R   R   R8   t   objectR   R@   t	   localpeerRA   Rl   RE   Ro   (    (    (    s<   /usr/lib/python2.7/dist-packages/mercurial/statichttprepo.pyt   <module>
   s   0<01	D                                                                                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/store.py                                                  0100644 0000000 0000000 00000041010 12413056314 020577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # store.py - repository store handling for Mercurial
#
# Copyright 2008 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
import scmutil, util, parsers
import os, stat, errno

_sha = util.sha1

# This avoids a collision between a file named foo and a dir named
# foo.i or foo.d
def _encodedir(path):
    '''
    >>> _encodedir('data/foo.i')
    'data/foo.i'
    >>> _encodedir('data/foo.i/bla.i')
    'data/foo.i.hg/bla.i'
    >>> _encodedir('data/foo.i.hg/bla.i')
    'data/foo.i.hg.hg/bla.i'
    >>> _encodedir('data/foo.i\\ndata/foo.i/bla.i\\ndata/foo.i.hg/bla.i\\n')
    'data/foo.i\\ndata/foo.i.hg/bla.i\\ndata/foo.i.hg.hg/bla.i\\n'
    '''
    return (path
            .replace(".hg/", ".hg.hg/")
            .replace(".i/", ".i.hg/")
            .replace(".d/", ".d.hg/"))

encodedir = getattr(parsers, 'encodedir', _encodedir)

def decodedir(path):
    '''
    >>> decodedir('data/foo.i')
    'data/foo.i'
    >>> decodedir('data/foo.i.hg/bla.i')
    'data/foo.i/bla.i'
    >>> decodedir('data/foo.i.hg.hg/bla.i')
    'data/foo.i.hg/bla.i'
    '''
    if ".hg/" not in path:
        return path
    return (path
            .replace(".d.hg/", ".d/")
            .replace(".i.hg/", ".i/")
            .replace(".hg.hg/", ".hg/"))

def _buildencodefun():
    '''
    >>> enc, dec = _buildencodefun()

    >>> enc('nothing/special.txt')
    'nothing/special.txt'
    >>> dec('nothing/special.txt')
    'nothing/special.txt'

    >>> enc('HELLO')
    '_h_e_l_l_o'
    >>> dec('_h_e_l_l_o')
    'HELLO'

    >>> enc('hello:world?')
    'hello~3aworld~3f'
    >>> dec('hello~3aworld~3f')
    'hello:world?'

    >>> enc('the\x07quick\xADshot')
    'the~07quick~adshot'
    >>> dec('the~07quick~adshot')
    'the\\x07quick\\xadshot'
    '''
    e = '_'
    winreserved = [ord(x) for x in '\\:*?"<>|']
    cmap = dict([(chr(x), chr(x)) for x in xrange(127)])
    for x in (range(32) + range(126, 256) + winreserved):
        cmap[chr(x)] = "~%02x" % x
    for x in range(ord("A"), ord("Z") + 1) + [ord(e)]:
        cmap[chr(x)] = e + chr(x).lower()
    dmap = {}
    for k, v in cmap.iteritems():
        dmap[v] = k
    def decode(s):
        i = 0
        while i < len(s):
            for l in xrange(1, 4):
                try:
                    yield dmap[s[i:i + l]]
                    i += l
                    break
                except KeyError:
                    pass
            else:
                raise KeyError
    return (lambda s: ''.join([cmap[c] for c in s]),
            lambda s: ''.join(list(decode(s))))

_encodefname, _decodefname = _buildencodefun()

def encodefilename(s):
    '''
    >>> encodefilename('foo.i/bar.d/bla.hg/hi:world?/HELLO')
    'foo.i.hg/bar.d.hg/bla.hg.hg/hi~3aworld~3f/_h_e_l_l_o'
    '''
    return _encodefname(encodedir(s))

def decodefilename(s):
    '''
    >>> decodefilename('foo.i.hg/bar.d.hg/bla.hg.hg/hi~3aworld~3f/_h_e_l_l_o')
    'foo.i/bar.d/bla.hg/hi:world?/HELLO'
    '''
    return decodedir(_decodefname(s))

def _buildlowerencodefun():
    '''
    >>> f = _buildlowerencodefun()
    >>> f('nothing/special.txt')
    'nothing/special.txt'
    >>> f('HELLO')
    'hello'
    >>> f('hello:world?')
    'hello~3aworld~3f'
    >>> f('the\x07quick\xADshot')
    'the~07quick~adshot'
    '''
    winreserved = [ord(x) for x in '\\:*?"<>|']
    cmap = dict([(chr(x), chr(x)) for x in xrange(127)])
    for x in (range(32) + range(126, 256) + winreserved):
        cmap[chr(x)] = "~%02x" % x
    for x in range(ord("A"), ord("Z") + 1):
        cmap[chr(x)] = chr(x).lower()
    return lambda s: "".join([cmap[c] for c in s])

lowerencode = getattr(parsers, 'lowerencode', None) or _buildlowerencodefun()

# Windows reserved names: con, prn, aux, nul, com1..com9, lpt1..lpt9
_winres3 = ('aux', 'con', 'prn', 'nul') # length 3
_winres4 = ('com', 'lpt')               # length 4 (with trailing 1..9)
def _auxencode(path, dotencode):
    '''
    Encodes filenames containing names reserved by Windows or which end in
    period or space. Does not touch other single reserved characters c.
    Specifically, c in '\\:*?"<>|' or ord(c) <= 31 are *not* encoded here.
    Additionally encodes space or period at the beginning, if dotencode is
    True. Parameter path is assumed to be all lowercase.
    A segment only needs encoding if a reserved name appears as a
    basename (e.g. "aux", "aux.foo"). A directory or file named "foo.aux"
    doesn't need encoding.

    >>> s = '.foo/aux.txt/txt.aux/con/prn/nul/foo.'
    >>> _auxencode(s.split('/'), True)
    ['~2efoo', 'au~78.txt', 'txt.aux', 'co~6e', 'pr~6e', 'nu~6c', 'foo~2e']
    >>> s = '.com1com2/lpt9.lpt4.lpt1/conprn/com0/lpt0/foo.'
    >>> _auxencode(s.split('/'), False)
    ['.com1com2', 'lp~749.lpt4.lpt1', 'conprn', 'com0', 'lpt0', 'foo~2e']
    >>> _auxencode(['foo. '], True)
    ['foo.~20']
    >>> _auxencode([' .foo'], True)
    ['~20.foo']
    '''
    for i, n in enumerate(path):
        if not n:
            continue
        if dotencode and n[0] in '. ':
            n = "~%02x" % ord(n[0]) + n[1:]
            path[i] = n
        else:
            l = n.find('.')
            if l == -1:
                l = len(n)
            if ((l == 3 and n[:3] in _winres3) or
                (l == 4 and n[3] <= '9' and n[3] >= '1'
                        and n[:3] in _winres4)):
                # encode third letter ('aux' -> 'au~78')
                ec = "~%02x" % ord(n[2])
                n = n[0:2] + ec + n[3:]
                path[i] = n
        if n[-1] in '. ':
            # encode last period or space ('foo...' -> 'foo..~2e')
            path[i] = n[:-1] + "~%02x" % ord(n[-1])
    return path

_maxstorepathlen = 120
_dirprefixlen = 8
_maxshortdirslen = 8 * (_dirprefixlen + 1) - 4

def _hashencode(path, dotencode):
    digest = _sha(path).hexdigest()
    le = lowerencode(path).split('/')[1:]
    parts = _auxencode(le, dotencode)
    basename = parts[-1]
    _root, ext = os.path.splitext(basename)
    sdirs = []
    sdirslen = 0
    for p in parts[:-1]:
        d = p[:_dirprefixlen]
        if d[-1] in '. ':
            # Windows can't access dirs ending in period or space
            d = d[:-1] + '_'
        if sdirslen == 0:
            t = len(d)
        else:
            t = sdirslen + 1 + len(d)
            if t > _maxshortdirslen:
                break
        sdirs.append(d)
        sdirslen = t
    dirs = '/'.join(sdirs)
    if len(dirs) > 0:
        dirs += '/'
    res = 'dh/' + dirs + digest + ext
    spaceleft = _maxstorepathlen - len(res)
    if spaceleft > 0:
        filler = basename[:spaceleft]
        res = 'dh/' + dirs + filler + digest + ext
    return res

def _hybridencode(path, dotencode):
    '''encodes path with a length limit

    Encodes all paths that begin with 'data/', according to the following.

    Default encoding (reversible):

    Encodes all uppercase letters 'X' as '_x'. All reserved or illegal
    characters are encoded as '~xx', where xx is the two digit hex code
    of the character (see encodefilename).
    Relevant path components consisting of Windows reserved filenames are
    masked by encoding the third character ('aux' -> 'au~78', see _auxencode).

    Hashed encoding (not reversible):

    If the default-encoded path is longer than _maxstorepathlen, a
    non-reversible hybrid hashing of the path is done instead.
    This encoding uses up to _dirprefixlen characters of all directory
    levels of the lowerencoded path, but not more levels than can fit into
    _maxshortdirslen.
    Then follows the filler followed by the sha digest of the full path.
    The filler is the beginning of the basename of the lowerencoded path
    (the basename is everything after the last path separator). The filler
    is as long as possible, filling in characters from the basename until
    the encoded path has _maxstorepathlen characters (or all chars of the
    basename have been taken).
    The extension (e.g. '.i' or '.d') is preserved.

    The string 'data/' at the beginning is replaced with 'dh/', if the hashed
    encoding was used.
    '''
    path = encodedir(path)
    ef = _encodefname(path).split('/')
    res = '/'.join(_auxencode(ef, dotencode))
    if len(res) > _maxstorepathlen:
        res = _hashencode(path, dotencode)
    return res

def _pathencode(path):
    de = encodedir(path)
    if len(path) > _maxstorepathlen:
        return _hashencode(de, True)
    ef = _encodefname(de).split('/')
    res = '/'.join(_auxencode(ef, True))
    if len(res) > _maxstorepathlen:
        return _hashencode(de, True)
    return res

_pathencode = getattr(parsers, 'pathencode', _pathencode)

def _plainhybridencode(f):
    return _hybridencode(f, False)

def _calcmode(vfs):
    try:
        # files in .hg/ will be created using this mode
        mode = vfs.stat().st_mode
            # avoid some useless chmods
        if (0777 & ~util.umask) == (0777 & mode):
            mode = None
    except OSError:
        mode = None
    return mode

_data = ('data 00manifest.d 00manifest.i 00changelog.d 00changelog.i'
         ' phaseroots obsstore')

class basicstore(object):
    '''base class for local repository stores'''
    def __init__(self, path, vfstype):
        vfs = vfstype(path)
        self.path = vfs.base
        self.createmode = _calcmode(vfs)
        vfs.createmode = self.createmode
        self.rawvfs = vfs
        self.vfs = scmutil.filtervfs(vfs, encodedir)
        self.opener = self.vfs

    def join(self, f):
        return self.path + '/' + encodedir(f)

    def _walk(self, relpath, recurse):
        '''yields (unencoded, encoded, size)'''
        path = self.path
        if relpath:
            path += '/' + relpath
        striplen = len(self.path) + 1
        l = []
        if self.rawvfs.isdir(path):
            visit = [path]
            readdir = self.rawvfs.readdir
            while visit:
                p = visit.pop()
                for f, kind, st in readdir(p, stat=True):
                    fp = p + '/' + f
                    if kind == stat.S_IFREG and f[-2:] in ('.d', '.i'):
                        n = util.pconvert(fp[striplen:])
                        l.append((decodedir(n), n, st.st_size))
                    elif kind == stat.S_IFDIR and recurse:
                        visit.append(fp)
        l.sort()
        return l

    def datafiles(self):
        return self._walk('data', True)

    def topfiles(self):
        # yield manifest before changelog
        return reversed(self._walk('', False))

    def walk(self):
        '''yields (unencoded, encoded, size)'''
        # yield data files first
        for x in self.datafiles():
            yield x
        for x in self.topfiles():
            yield x

    def copylist(self):
        return ['requires'] + _data.split()

    def write(self, tr):
        pass

    def invalidatecaches(self):
        pass

    def markremoved(self, fn):
        pass

    def __contains__(self, path):
        '''Checks if the store contains path'''
        path = "/".join(("data", path))
        # file?
        if self.vfs.exists(path + ".i"):
            return True
        # dir?
        if not path.endswith("/"):
            path = path + "/"
        return self.vfs.exists(path)

class encodedstore(basicstore):
    def __init__(self, path, vfstype):
        vfs = vfstype(path + '/store')
        self.path = vfs.base
        self.createmode = _calcmode(vfs)
        vfs.createmode = self.createmode
        self.rawvfs = vfs
        self.vfs = scmutil.filtervfs(vfs, encodefilename)
        self.opener = self.vfs

    def datafiles(self):
        for a, b, size in self._walk('data', True):
            try:
                a = decodefilename(a)
            except KeyError:
                a = None
            yield a, b, size

    def join(self, f):
        return self.path + '/' + encodefilename(f)

    def copylist(self):
        return (['requires', '00changelog.i'] +
                ['store/' + f for f in _data.split()])

class fncache(object):
    # the filename used to be partially encoded
    # hence the encodedir/decodedir dance
    def __init__(self, vfs):
        self.vfs = vfs
        self.entries = None
        self._dirty = False

    def _load(self):
        '''fill the entries from the fncache file'''
        self._dirty = False
        try:
            fp = self.vfs('fncache', mode='rb')
        except IOError:
            # skip nonexistent file
            self.entries = set()
            return
        self.entries = set(decodedir(fp.read()).splitlines())
        if '' in self.entries:
            fp.seek(0)
            for n, line in enumerate(fp):
                if not line.rstrip('\n'):
                    t = _('invalid entry in fncache, line %s') % (n + 1)
                    raise util.Abort(t)
        fp.close()

    def write(self, tr):
        if self._dirty:
            tr.addbackup('fncache')
            fp = self.vfs('fncache', mode='wb', atomictemp=True)
            if self.entries:
                fp.write(encodedir('\n'.join(self.entries) + '\n'))
            fp.close()
            self._dirty = False

    def add(self, fn):
        if self.entries is None:
            self._load()
        if fn not in self.entries:
            self._dirty = True
            self.entries.add(fn)

    def remove(self, fn):
        if self.entries is None:
            self._load()
        try:
            self.entries.remove(fn)
            self._dirty = True
        except KeyError:
            pass

    def __contains__(self, fn):
        if self.entries is None:
            self._load()
        return fn in self.entries

    def __iter__(self):
        if self.entries is None:
            self._load()
        return iter(self.entries)

class _fncachevfs(scmutil.abstractvfs, scmutil.auditvfs):
    def __init__(self, vfs, fnc, encode):
        scmutil.auditvfs.__init__(self, vfs)
        self.fncache = fnc
        self.encode = encode

    def __call__(self, path, mode='r', *args, **kw):
        if mode not in ('r', 'rb') and path.startswith('data/'):
            self.fncache.add(path)
        return self.vfs(self.encode(path), mode, *args, **kw)

    def join(self, path):
        if path:
            return self.vfs.join(self.encode(path))
        else:
            return self.vfs.join(path)

class fncachestore(basicstore):
    def __init__(self, path, vfstype, dotencode):
        if dotencode:
            encode = _pathencode
        else:
            encode = _plainhybridencode
        self.encode = encode
        vfs = vfstype(path + '/store')
        self.path = vfs.base
        self.pathsep = self.path + '/'
        self.createmode = _calcmode(vfs)
        vfs.createmode = self.createmode
        self.rawvfs = vfs
        fnc = fncache(vfs)
        self.fncache = fnc
        self.vfs = _fncachevfs(vfs, fnc, encode)
        self.opener = self.vfs

    def join(self, f):
        return self.pathsep + self.encode(f)

    def getsize(self, path):
        return self.rawvfs.stat(path).st_size

    def datafiles(self):
        for f in sorted(self.fncache):
            ef = self.encode(f)
            try:
                yield f, ef, self.getsize(ef)
            except OSError, err:
                if err.errno != errno.ENOENT:
                    raise

    def copylist(self):
        d = ('data dh fncache phaseroots obsstore'
             ' 00manifest.d 00manifest.i 00changelog.d 00changelog.i')
        return (['requires', '00changelog.i'] +
                ['store/' + f for f in d.split()])

    def write(self, tr):
        self.fncache.write(tr)

    def invalidatecaches(self):
        self.fncache.entries = None

    def markremoved(self, fn):
        self.fncache.remove(fn)

    def _exists(self, f):
        ef = self.encode(f)
        try:
            self.getsize(ef)
            return True
        except OSError, err:
            if err.errno != errno.ENOENT:
                raise
            # nonexistent entry
            return False

    def __contains__(self, path):
        '''Checks if the store contains path'''
        path = "/".join(("data", path))
        # check for files (exact match)
        e = path + '.i'
        if e in self.fncache and self._exists(e):
            return True
        # now check for directories (prefix match)
        if not path.endswith('/'):
            path += '/'
        for e in self.fncache:
            if e.startswith(path) and self._exists(e):
                return True
        return False

def store(requirements, path, vfstype):
    if 'store' in requirements:
        if 'fncache' in requirements:
            return fncachestore(path, vfstype, 'dotencode' in requirements)
        return encodedstore(path, vfstype)
    return basicstore(path, vfstype)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/mercurial/store.pyc                                                 0100644 0000000 0000000 00000052113 13077704337 020764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sÏ  d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z e j Z	 d „  Z
 e e d e
 ƒ Z d „  Z d „  Z e ƒ  \ Z Z d „  Z d „  Z d	 „  Z e e d
 d ƒ pÐ e ƒ  Z d( Z d) Z d „  Z d Z d Z d e d d Z d „  Z d „  Z d „  Z e e d e ƒ Z d „  Z d „  Z  d Z! d e" f d „  ƒ  YZ# d e# f d  „  ƒ  YZ$ d! e" f d" „  ƒ  YZ% d# e j& e j' f d$ „  ƒ  YZ( d% e# f d& „  ƒ  YZ) d' „  Z* d S(*   iÿÿÿÿ(   t   _Nc         C   s(   |  j  d d ƒ j  d d ƒ j  d d ƒ S(   sI  
    >>> _encodedir('data/foo.i')
    'data/foo.i'
    >>> _encodedir('data/foo.i/bla.i')
    'data/foo.i.hg/bla.i'
    >>> _encodedir('data/foo.i.hg/bla.i')
    'data/foo.i.hg.hg/bla.i'
    >>> _encodedir('data/foo.i\ndata/foo.i/bla.i\ndata/foo.i.hg/bla.i\n')
    'data/foo.i\ndata/foo.i.hg/bla.i\ndata/foo.i.hg.hg/bla.i\n'
    s   .hg/s   .hg.hg/s   .i/s   .i.hg/s   .d/s   .d.hg/(   t   replace(   t   path(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt
   _encodedir   s    t	   encodedirc         C   s8   d |  k r |  S|  j  d d ƒ j  d d ƒ j  d d ƒ S(   s¼   
    >>> decodedir('data/foo.i')
    'data/foo.i'
    >>> decodedir('data/foo.i.hg/bla.i')
    'data/foo.i/bla.i'
    >>> decodedir('data/foo.i.hg.hg/bla.i')
    'data/foo.i.hg/bla.i'
    s   .hg/s   .d.hg/s   .d/s   .i.hg/s   .i/s   .hg.hg/(   R   (   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt	   decodedir"   s    	c             sG  d }  g  d D] } t  | ƒ ^ q } t g  t d ƒ D] } t | ƒ t | ƒ f ^ q5 ƒ ‰  x9 t d ƒ t d d ƒ | D] } d | ˆ  t | ƒ <qz WxT t t  d ƒ t  d	 ƒ d
 ƒ t  |  ƒ g D]& } |  t | ƒ j ƒ  ˆ  t | ƒ <qÅ Wi  ‰ x$ ˆ  j ƒ  D] \ } } | ˆ | <qW‡ f d †  ‰ ‡  f d †  ‡ f d †  f S(   sÎ  
    >>> enc, dec = _buildencodefun()

    >>> enc('nothing/special.txt')
    'nothing/special.txt'
    >>> dec('nothing/special.txt')
    'nothing/special.txt'

    >>> enc('HELLO')
    '_h_e_l_l_o'
    >>> dec('_h_e_l_l_o')
    'HELLO'

    >>> enc('hello:world?')
    'hello~3aworld~3f'
    >>> dec('hello~3aworld~3f')
    'hello:world?'

    >>> enc('thequick­shot')
    'the~07quick~adshot'
    >>> dec('the~07quick~adshot')
    'the\x07quick\xadshot'
    R    s   \:*?"<>|i   i    i~   i   s   ~%02xt   At   Zi   c         3   sz   d } xm | t  |  ƒ k  ru xT t d d ƒ D]= } y# ˆ  |  | | | !V| | 7} PWq+ t k
 rg q+ Xq+ Wt ‚ q	 Wd  S(   Ni    i   i   (   t   lent   xranget   KeyError(   t   st   it   l(   t   dmap(    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   decodeT   s    
c            s$   d j  g  |  D] } ˆ  | ^ q ƒ S(   Nt    (   t   join(   R   t   c(   t   cmap(    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   <lambda>`   s    c            s   d j  t ˆ  |  ƒ ƒ ƒ S(   NR   (   R   t   list(   R   (   R   (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR   a   s    (   t   ordt   dictR	   t   chrt   ranget   lowert	   iteritems(   t   et   xt   winreservedt   kt   v(    (   R   R   R   s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _buildencodefun2   s    7$3$c         C   s   t  t |  ƒ ƒ S(   s}   
    >>> encodefilename('foo.i/bar.d/bla.hg/hi:world?/HELLO')
    'foo.i.hg/bar.d.hg/bla.hg.hg/hi~3aworld~3f/_h_e_l_l_o'
    (   t   _encodefnameR   (   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   encodefilenamee   s    c         C   s   t  t |  ƒ ƒ S(   s}   
    >>> decodefilename('foo.i.hg/bar.d.hg/bla.hg.hg/hi~3aworld~3f/_h_e_l_l_o')
    'foo.i/bar.d/bla.hg/hi:world?/HELLO'
    (   R   t   _decodefname(   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   decodefilenamel   s    c             så   g  d D] }  t  |  ƒ ^ q } t g  t d ƒ D] }  t |  ƒ t |  ƒ f ^ q/ ƒ ‰  x9 t d ƒ t d d ƒ | D] }  d |  ˆ  t |  ƒ <qt WxC t t  d ƒ t  d ƒ d	 ƒ D]" }  t |  ƒ j ƒ  ˆ  t |  ƒ <q² W‡  f d
 †  S(   sè   
    >>> f = _buildlowerencodefun()
    >>> f('nothing/special.txt')
    'nothing/special.txt'
    >>> f('HELLO')
    'hello'
    >>> f('hello:world?')
    'hello~3aworld~3f'
    >>> f('thequick­shot')
    'the~07quick~adshot'
    s   \:*?"<>|i   i    i~   i   s   ~%02xR   R   i   c            s$   d j  g  |  D] } ˆ  | ^ q ƒ S(   NR   (   R   (   R   R   (   R   (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR   …   s    (   R   R   R	   R   R   R   (   R   R   (    (   R   s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _buildlowerencodefuns   s    7$& t   lowerencodet   auxt   cont   prnt   nult   comt   lptc         C   s[  xTt  |  ƒ D]F\ } } | s% q n  | rd | d d k rd d t | d ƒ | d } | |  | <n¼ | j d ƒ } | d k rŽ t | ƒ } n  | d k rª | d  t k sæ | d k r | d d	 k r | d d
 k r | d  t k r d t | d ƒ } | d d !| | d } | |  | <n  | d d k r | d  d t | d ƒ |  | <q q W|  S(   sÌ  
    Encodes filenames containing names reserved by Windows or which end in
    period or space. Does not touch other single reserved characters c.
    Specifically, c in '\:*?"<>|' or ord(c) <= 31 are *not* encoded here.
    Additionally encodes space or period at the beginning, if dotencode is
    True. Parameter path is assumed to be all lowercase.
    A segment only needs encoding if a reserved name appears as a
    basename (e.g. "aux", "aux.foo"). A directory or file named "foo.aux"
    doesn't need encoding.

    >>> s = '.foo/aux.txt/txt.aux/con/prn/nul/foo.'
    >>> _auxencode(s.split('/'), True)
    ['~2efoo', 'au~78.txt', 'txt.aux', 'co~6e', 'pr~6e', 'nu~6c', 'foo~2e']
    >>> s = '.com1com2/lpt9.lpt4.lpt1/conprn/com0/lpt0/foo.'
    >>> _auxencode(s.split('/'), False)
    ['.com1com2', 'lp~749.lpt4.lpt1', 'conprn', 'com0', 'lpt0', 'foo~2e']
    >>> _auxencode(['foo. '], True)
    ['foo.~20']
    >>> _auxencode([' .foo'], True)
    ['~20.foo']
    i    s   . s   ~%02xi   t   .iÿÿÿÿi   i   t   9t   1i   (   t	   enumerateR   t   findR   t   _winres3t   _winres4(   R   t	   dotencodeR   t   nR   t   ec(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt
   _auxencodeŒ   s$    ,'ix   i   i   i   c         C   s}  t  |  ƒ j ƒ  } t |  ƒ j d ƒ d } t | | ƒ } | d } t j j | ƒ \ } } g  } d }	 x | d  D]ƒ }
 |
 t  } | d d k r¤ | d  d } n  |	 d k r¿ t	 | ƒ } n$ |	 d t	 | ƒ } | t
 k rã Pn  | j | ƒ | }	 qs Wd j | ƒ } t	 | ƒ d k r(| d 7} n  d | | | } t t	 | ƒ } | d k ry| |  } d | | | | } n  | S(   Nt   /i   iÿÿÿÿi    s   . R    s   dh/(   t   _shat	   hexdigestR'   t   splitR8   t   osR   t   splitextt   _dirprefixlenR   t   _maxshortdirslent   appendR   t   _maxstorepathlen(   R   R5   t   digestt   let   partst   basenamet   _roott   extt   sdirst   sdirslent   pt   dt   tt   dirst   rest	   spaceleftt   filler(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _hashencode¼   s6    



c         C   sa   t  |  ƒ }  t |  ƒ j d ƒ } d j t | | ƒ ƒ } t | ƒ t k r] t |  | ƒ } n  | S(   se  encodes path with a length limit

    Encodes all paths that begin with 'data/', according to the following.

    Default encoding (reversible):

    Encodes all uppercase letters 'X' as '_x'. All reserved or illegal
    characters are encoded as '~xx', where xx is the two digit hex code
    of the character (see encodefilename).
    Relevant path components consisting of Windows reserved filenames are
    masked by encoding the third character ('aux' -> 'au~78', see _auxencode).

    Hashed encoding (not reversible):

    If the default-encoded path is longer than _maxstorepathlen, a
    non-reversible hybrid hashing of the path is done instead.
    This encoding uses up to _dirprefixlen characters of all directory
    levels of the lowerencoded path, but not more levels than can fit into
    _maxshortdirslen.
    Then follows the filler followed by the sha digest of the full path.
    The filler is the beginning of the basename of the lowerencoded path
    (the basename is everything after the last path separator). The filler
    is as long as possible, filling in characters from the basename until
    the encoded path has _maxstorepathlen characters (or all chars of the
    basename have been taken).
    The extension (e.g. '.i' or '.d') is preserved.

    The string 'data/' at the beginning is replaced with 'dh/', if the hashed
    encoding was used.
    R9   (   R   R"   R<   R   R8   R   RB   RR   (   R   R5   t   efRO   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _hybridencodeÛ   s    c         C   s{   t  |  ƒ } t |  ƒ t k r+ t | t ƒ St | ƒ j d ƒ } d j t | t ƒ ƒ } t | ƒ t k rw t | t ƒ S| S(   NR9   (	   R   R   RB   RR   t   TrueR"   R<   R   R8   (   R   t   deRS   RO   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _pathencode  s    t
   pathencodec         C   s   t  |  t ƒ S(   N(   RT   t   False(   t   f(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _plainhybridencode  s    c         C   sR   y4 |  j  ƒ  j } d t j @d | @k r3 d  } n  Wn t k
 rM d  } n X| S(   Niÿ  (   t   statt   st_modet   utilt   umaskt   Nonet   OSError(   t   vfst   mode(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt	   _calcmode  s    
sN   data 00manifest.d 00manifest.i 00changelog.d 00changelog.i phaseroots obsstoret
   basicstorec           B   sq   e  Z d  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z d
 „  Z d „  Z RS(   s&   base class for local repository storesc         C   sa   | | ƒ } | j  |  _ t | ƒ |  _ |  j | _ | |  _ t j | t ƒ |  _ |  j |  _	 d  S(   N(
   t   baseR   Rd   t
   createmodet   rawvfst   scmutilt	   filtervfsR   Rb   t   opener(   t   selfR   t   vfstypeRb   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   __init__   s    	c         C   s   |  j  d t | ƒ S(   NR9   (   R   R   (   Rl   RZ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR   )  s    c         C   s7  |  j  } | r  | d | 7} n  t |  j  ƒ d } g  } |  j j | ƒ r)| g } |  j j } xÆ | r%| j ƒ  } xª | | d t ƒD]– \ }	 }
 } | d |	 } |
 t j k rù |	 d d k rù t	 j
 | | ƒ } | j t | ƒ | | j f ƒ qˆ |
 t j k rˆ | rˆ | j | ƒ qˆ qˆ Wqc Wn  | j ƒ  | S(   s!   yields (unencoded, encoded, size)R9   i   R\   iþÿÿÿs   .ds   .i(   s   .ds   .i(   R   R   Rh   t   isdirt   readdirt   popRU   R\   t   S_IFREGR^   t   pconvertRA   R   t   st_sizet   S_IFDIRt   sort(   Rl   t   relpatht   recurseR   t   striplenR   t   visitRp   RK   RZ   t   kindt   stt   fpR6   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _walk,  s&    			""
c         C   s   |  j  d t ƒ S(   Nt   data(   R~   RU   (   Rl   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt	   datafilesB  s    c         C   s   t  |  j d t ƒ ƒ S(   NR   (   t   reversedR~   RY   (   Rl   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   topfilesE  s    c         c   s<   x |  j  ƒ  D] } | Vq Wx |  j ƒ  D] } | Vq) Wd S(   s!   yields (unencoded, encoded, size)N(   R€   R‚   (   Rl   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   walkI  s    	c         C   s   d g t  j ƒ  S(   Nt   requires(   t   _dataR<   (   Rl   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   copylistQ  s    c         C   s   d  S(   N(    (   Rl   t   tr(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   writeT  s    c         C   s   d  S(   N(    (   Rl   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   invalidatecachesW  s    c         C   s   d  S(   N(    (   Rl   t   fn(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   markremovedZ  s    c         C   s[   d j  d | f ƒ } |  j j | d ƒ r/ t S| j d ƒ sK | d } n  |  j j | ƒ S(   s!   Checks if the store contains pathR9   R   s   .i(   R   Rb   t   existsRU   t   endswith(   Rl   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   __contains__]  s    (   t   __name__t
   __module__t   __doc__Rn   R   R~   R€   R‚   Rƒ   R†   Rˆ   R‰   R‹   RŽ   (    (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRe     s   											t   encodedstorec           B   s,   e  Z d  „  Z d „  Z d „  Z d „  Z RS(   c         C   se   | | d ƒ } | j  |  _ t | ƒ |  _ |  j | _ | |  _ t j | t ƒ |  _ |  j |  _	 d  S(   Ns   /store(
   Rf   R   Rd   Rg   Rh   Ri   Rj   R#   Rb   Rk   (   Rl   R   Rm   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRn   i  s    	c         c   sb   x[ |  j  d t ƒ D]G \ } } } y t | ƒ } Wn t k
 rK d  } n X| | | f Vq Wd  S(   NR   (   R~   RU   R%   R
   R`   (   Rl   t   at   bt   size(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR€   r  s    "
c         C   s   |  j  d t | ƒ S(   NR9   (   R   R#   (   Rl   RZ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR   z  s    c         C   s+   d d g g  t  j ƒ  D] } d | ^ q S(   NR„   s   00changelog.is   store/(   R…   R<   (   Rl   RZ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR†   }  s    	(   R   R   Rn   R€   R   R†   (    (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR’   h  s   				t   fncachec           B   sG   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   c         C   s   | |  _  d  |  _ t |  _ d  S(   N(   Rb   R`   t   entriesRY   t   _dirty(   Rl   Rb   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRn   „  s    		c         C   sã   t  |  _ y |  j d d d ƒ} Wn t k
 rB t ƒ  |  _ d SXt t | j ƒ  ƒ j ƒ  ƒ |  _ d |  j k rÕ | j	 d ƒ xR t
 | ƒ D]A \ } } | j d ƒ s t d ƒ | d	 } t j | ƒ ‚ q q Wn  | j ƒ  d S(
   s&   fill the entries from the fncache fileR–   Rc   t   rbNR   i    s   
s!   invalid entry in fncache, line %si   (   RY   R˜   Rb   t   IOErrort   setR—   R   t   readt
   splitlinest   seekR1   t   rstripR    R^   t   Abortt   close(   Rl   R}   R6   t   lineRM   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _load‰  s    	!c         C   sz   |  j  rv | j d ƒ |  j d d d d t ƒ} |  j r` | j t d j |  j ƒ d ƒ ƒ n  | j ƒ  t	 |  _  n  d  S(   NR–   Rc   t   wbt
   atomictemps   
(
   R˜   t	   addbackupRb   RU   R—   Rˆ   R   R   R¡   RY   (   Rl   R‡   R}   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRˆ   ›  s    		&
c         C   sK   |  j  d  k r |  j ƒ  n  | |  j  k rG t |  _ |  j  j | ƒ n  d  S(   N(   R—   R`   R£   RU   R˜   t   add(   Rl   RŠ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR§   ¤  s
    	c         C   sQ   |  j  d  k r |  j ƒ  n  y |  j  j | ƒ t |  _ Wn t k
 rL n Xd  S(   N(   R—   R`   R£   t   removeRU   R˜   R
   (   Rl   RŠ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR¨   «  s    c         C   s)   |  j  d  k r |  j ƒ  n  | |  j  k S(   N(   R—   R`   R£   (   Rl   RŠ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRŽ   ´  s    c         C   s)   |  j  d  k r |  j ƒ  n  t |  j  ƒ S(   N(   R—   R`   R£   t   iter(   Rl   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   __iter__¹  s    (	   R   R   Rn   R£   Rˆ   R§   R¨   RŽ   Rª   (    (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR–     s   								t   _fncachevfsc           B   s&   e  Z d  „  Z d d „ Z d „  Z RS(   c         C   s)   t  j j |  | ƒ | |  _ | |  _ d  S(   N(   Ri   t   auditvfsRn   R–   t   encode(   Rl   Rb   t   fncR­   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRn   ¿  s    	t   rc         O   sM   | d k r. | j  d ƒ r. |  j j | ƒ n  |  j |  j | ƒ | | | Ž S(   NR¯   R™   s   data/(   R¯   s   rb(   t
   startswithR–   R§   Rb   R­   (   Rl   R   Rc   t   argst   kw(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   __call__Ä  s    c         C   s3   | r |  j  j |  j | ƒ ƒ S|  j  j | ƒ Sd  S(   N(   Rb   R   R­   (   Rl   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR   É  s    (   R   R   Rn   R³   R   (    (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR«   ¾  s   	t   fncachestorec           B   sb   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d	 „  Z RS(
   c         C   s¨   | r t  } n t } | |  _ | | d ƒ } | j |  _ |  j d |  _ t | ƒ |  _ |  j | _ | |  _ t	 | ƒ } | |  _	 t
 | | | ƒ |  _ |  j |  _ d  S(   Ns   /storeR9   (   RW   R[   R­   Rf   R   t   pathsepRd   Rg   Rh   R–   R«   Rb   Rk   (   Rl   R   Rm   R5   R­   Rb   R®   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRn   Ð  s    				c         C   s   |  j  |  j | ƒ S(   N(   Rµ   R­   (   Rl   RZ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR   á  s    c         C   s   |  j  j | ƒ j S(   N(   Rh   R\   Rt   (   Rl   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   getsizeä  s    c         c   sv   xo t  |  j ƒ D]^ } |  j | ƒ } y | | |  j | ƒ f VWq t k
 rm } | j t j k rn ‚  qn q Xq Wd  S(   N(   t   sortedR–   R­   R¶   Ra   t   errnot   ENOENT(   Rl   RZ   RS   t   err(    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR€   ç  s    c         C   s1   d } d d g g  | j  ƒ  D] } d | ^ q S(   NsY   data dh fncache phaseroots obsstore 00manifest.d 00manifest.i 00changelog.d 00changelog.iR„   s   00changelog.is   store/(   R<   (   Rl   RL   RZ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR†   ð  s    	c         C   s   |  j  j | ƒ d  S(   N(   R–   Rˆ   (   Rl   R‡   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRˆ   ö  s    c         C   s   d  |  j _ d  S(   N(   R`   R–   R—   (   Rl   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR‰   ù  s    c         C   s   |  j  j | ƒ d  S(   N(   R–   R¨   (   Rl   RŠ   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR‹   ü  s    c         C   sW   |  j  | ƒ } y |  j | ƒ t SWn, t k
 rR } | j t j k rN ‚  n  t SXd  S(   N(   R­   R¶   RU   Ra   R¸   R¹   RY   (   Rl   RZ   RS   Rº   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   _existsÿ  s    c         C   s—   d j  d | f ƒ } | d } | |  j k rA |  j | ƒ rA t S| j d ƒ s] | d 7} n  x3 |  j D]( } | j | ƒ rg |  j | ƒ rg t Sqg Wt S(   s!   Checks if the store contains pathR9   R   s   .i(   R   R–   R»   RU   R   R°   RY   (   Rl   R   R   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyRŽ   
  s    
(   R   R   Rn   R   R¶   R€   R†   Rˆ   R‰   R‹   R»   RŽ   (    (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR´   Ï  s   										c         C   sH   d |  k r; d |  k r. t  | | d |  k ƒ St | | ƒ St | | ƒ S(   Nt   storeR–   R5   (   R´   R’   Re   (   t   requirementsR   Rm   (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyR¼     s
    (   R(   R)   R*   R+   (   R,   R-   (+   t   i18nR    Ri   R^   t   parsersR=   R\   R¸   t   sha1R:   R   t   getattrR   R   R!   R"   R$   R#   R%   R&   R`   R'   R3   R4   R8   RB   R?   R@   RR   RT   RW   R[   Rd   R…   t   objectRe   R’   R–   t   abstractvfsR¬   R«   R´   R¼   (    (    (    s3   /usr/lib/python2.7/dist-packages/mercurial/store.pyt   <module>   s>   $$				1				,		&	
		J=J                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python2.7/dist-packages/mercurial/strutil.py                                                0100644 0000000 0000000 00000001621 12413056314 021155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # strutil.py - string utilities for Mercurial
#
# Copyright 2006 Vadim Gelfer <vadim.gelfer@gmail.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

def findall(haystack, needle, start=0, end=None):
    if end is None:
        end = len(haystack)
    if end < 0:
        end += len(haystack)
    if start < 0:
        start += len(haystack)
    while start < end:
        c = haystack.find(needle, start, end)
        if c == -1:
            break
        yield c
        start = c + 1

def rfindall(haystack, needle, start=0, end=None):
    if end is None:
        end = len(haystack)
    if end < 0:
        end += len(haystack)
    if start < 0:
        start += len(haystack)
    while end >= 0:
        c = haystack.rfind(needle, start, end)
        if c == -1:
            break
        yield c
        end = c - 1
                                                                                                               usr/lib/python2.7/dist-packages/mercurial/strutil.pyc                                               0100644 0000000 0000000 00000001714 13077704337 021337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s"   d  d d „ Z d  d d „ Z d S(   i    c         c   s¤   | d  k r t |  ƒ } n  | d k  r: | t |  ƒ 7} n  | d k  rY | t |  ƒ 7} n  xD | | k  rŸ |  j | | | ƒ } | d k r Pn  | V| d } q\ Wd  S(   Ni    iÿÿÿÿi   (   t   Nonet   lent   find(   t   haystackt   needlet   startt   endt   c(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/strutil.pyt   findall   s    c         c   s¤   | d  k r t |  ƒ } n  | d k  r: | t |  ƒ 7} n  | d k  rY | t |  ƒ 7} n  xD | d k rŸ |  j | | | ƒ } | d k r Pn  | V| d } q\ Wd  S(   Ni    iÿÿÿÿi   (   R    R   t   rfind(   R   R   R   R   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/strutil.pyt   rfindall   s    N(   R    R   R
   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/strutil.pyt   <module>   s                                                       usr/lib/python2.7/dist-packages/mercurial/subrepo.py                                                0100644 0000000 0000000 00000166036 12712351006 021140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # subrepo.py - sub-repository handling for Mercurial
#
# Copyright 2009-2010 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

import errno, os, re, shutil, posixpath, sys
import xml.dom.minidom
import stat, subprocess, tarfile
from i18n import _
import config, util, node, error, cmdutil, bookmarks, match as matchmod
import phases
import pathutil
hg = None
propertycache = util.propertycache

nullstate = ('', '', 'empty')

def _expandedabspath(path):
    '''
    get a path or url and if it is a path expand it and return an absolute path
    '''
    expandedpath = util.urllocalpath(util.expandpath(path))
    u = util.url(expandedpath)
    if not u.scheme:
        path = util.normpath(os.path.abspath(u.path))
    return path

def _getstorehashcachename(remotepath):
    '''get a unique filename for the store hash cache of a remote repository'''
    return util.sha1(_expandedabspath(remotepath)).hexdigest()[0:12]

def _calcfilehash(filename):
    data = ''
    if os.path.exists(filename):
        fd = open(filename, 'rb')
        try:
            data = fd.read()
        finally:
            fd.close()
    return util.sha1(data).hexdigest()

class SubrepoAbort(error.Abort):
    """Exception class used to avoid handling a subrepo error more than once"""
    def __init__(self, *args, **kw):
        error.Abort.__init__(self, *args, **kw)
        self.subrepo = kw.get('subrepo')
        self.cause = kw.get('cause')

def annotatesubrepoerror(func):
    def decoratedmethod(self, *args, **kargs):
        try:
            res = func(self, *args, **kargs)
        except SubrepoAbort, ex:
            # This exception has already been handled
            raise ex
        except error.Abort, ex:
            subrepo = subrelpath(self)
            errormsg = str(ex) + ' ' + _('(in subrepo %s)') % subrepo
            # avoid handling this exception by raising a SubrepoAbort exception
            raise SubrepoAbort(errormsg, hint=ex.hint, subrepo=subrepo,
                               cause=sys.exc_info())
        return res
    return decoratedmethod

def state(ctx, ui):
    """return a state dict, mapping subrepo paths configured in .hgsub
    to tuple: (source from .hgsub, revision from .hgsubstate, kind
    (key in types dict))
    """
    p = config.config()
    def read(f, sections=None, remap=None):
        if f in ctx:
            try:
                data = ctx[f].data()
            except IOError, err:
                if err.errno != errno.ENOENT:
                    raise
                # handle missing subrepo spec files as removed
                ui.warn(_("warning: subrepo spec file %s not found\n") % f)
                return
            p.parse(f, data, sections, remap, read)
        else:
            raise util.Abort(_("subrepo spec file %s not found") % f)

    if '.hgsub' in ctx:
        read('.hgsub')

    for path, src in ui.configitems('subpaths'):
        p.set('subpaths', path, src, ui.configsource('subpaths', path))

    rev = {}
    if '.hgsubstate' in ctx:
        try:
            for i, l in enumerate(ctx['.hgsubstate'].data().splitlines()):
                l = l.lstrip()
                if not l:
                    continue
                try:
                    revision, path = l.split(" ", 1)
                except ValueError:
                    raise util.Abort(_("invalid subrepository revision "
                                       "specifier in .hgsubstate line %d")
                                     % (i + 1))
                rev[path] = revision
        except IOError, err:
            if err.errno != errno.ENOENT:
                raise

    def remap(src):
        for pattern, repl in p.items('subpaths'):
            # Turn r'C:\foo\bar' into r'C:\\foo\\bar' since re.sub
            # does a string decode.
            repl = repl.encode('string-escape')
            # However, we still want to allow back references to go
            # through unharmed, so we turn r'\\1' into r'\1'. Again,
            # extra escapes are needed because re.sub string decodes.
            repl = re.sub(r'\\\\([0-9]+)', r'\\\1', repl)
            try:
                src = re.sub(pattern, repl, src, 1)
            except re.error, e:
                raise util.Abort(_("bad subrepository pattern in %s: %s")
                                 % (p.source('subpaths', pattern), e))
        return src

    state = {}
    for path, src in p[''].items():
        kind = 'hg'
        if src.startswith('['):
            if ']' not in src:
                raise util.Abort(_('missing ] in subrepo source'))
            kind, src = src.split(']', 1)
            kind = kind[1:]
            src = src.lstrip() # strip any extra whitespace after ']'

        if not util.url(src).isabs():
            parent = _abssource(ctx._repo, abort=False)
            if parent:
                parent = util.url(parent)
                parent.path = posixpath.join(parent.path or '', src)
                parent.path = posixpath.normpath(parent.path)
                joined = str(parent)
                # Remap the full joined path and use it if it changes,
                # else remap the original source.
                remapped = remap(joined)
                if remapped == joined:
                    src = remap(src)
                else:
                    src = remapped

        src = remap(src)
        state[util.pconvert(path)] = (src.strip(), rev.get(path, ''), kind)

    return state

def writestate(repo, state):
    """rewrite .hgsubstate in (outer) repo with these subrepo states"""
    lines = ['%s %s\n' % (state[s][1], s) for s in sorted(state)]
    repo.wwrite('.hgsubstate', ''.join(lines), '')

def submerge(repo, wctx, mctx, actx, overwrite):
    """delegated from merge.applyupdates: merging of .hgsubstate file
    in working context, merging context and ancestor context"""
    if mctx == actx: # backwards?
        actx = wctx.p1()
    s1 = wctx.substate
    s2 = mctx.substate
    sa = actx.substate
    sm = {}

    repo.ui.debug("subrepo merge %s %s %s\n" % (wctx, mctx, actx))

    def debug(s, msg, r=""):
        if r:
            r = "%s:%s:%s" % r
        repo.ui.debug("  subrepo %s: %s %s\n" % (s, msg, r))

    for s, l in sorted(s1.iteritems()):
        a = sa.get(s, nullstate)
        ld = l # local state with possible dirty flag for compares
        if wctx.sub(s).dirty():
            ld = (l[0], l[1] + "+")
        if wctx == actx: # overwrite
            a = ld

        if s in s2:
            r = s2[s]
            if ld == r or r == a: # no change or local is newer
                sm[s] = l
                continue
            elif ld == a: # other side changed
                debug(s, "other changed, get", r)
                wctx.sub(s).get(r, overwrite)
                sm[s] = r
            elif ld[0] != r[0]: # sources differ
                if repo.ui.promptchoice(
                    _(' subrepository sources for %s differ\n'
                      'use (l)ocal source (%s) or (r)emote source (%s)?'
                      '$$ &Local $$ &Remote') % (s, l[0], r[0]), 0):
                    debug(s, "prompt changed, get", r)
                    wctx.sub(s).get(r, overwrite)
                    sm[s] = r
            elif ld[1] == a[1]: # local side is unchanged
                debug(s, "other side changed, get", r)
                wctx.sub(s).get(r, overwrite)
                sm[s] = r
            else:
                debug(s, "both sides changed")
                srepo = wctx.sub(s)
                option = repo.ui.promptchoice(
                    _(' subrepository %s diverged (local revision: %s, '
                      'remote revision: %s)\n'
                      '(M)erge, keep (l)ocal or keep (r)emote?'
                      '$$ &Merge $$ &Local $$ &Remote')
                    % (s, srepo.shortid(l[1]), srepo.shortid(r[1])), 0)
                if option == 0:
                    wctx.sub(s).merge(r)
                    sm[s] = l
                    debug(s, "merge with", r)
                elif option == 1:
                    sm[s] = l
                    debug(s, "keep local subrepo revision", l)
                else:
                    wctx.sub(s).get(r, overwrite)
                    sm[s] = r
                    debug(s, "get remote subrepo revision", r)
        elif ld == a: # remote removed, local unchanged
            debug(s, "remote removed, remove")
            wctx.sub(s).remove()
        elif a == nullstate: # not present in remote or ancestor
            debug(s, "local added, keep")
            sm[s] = l
            continue
        else:
            if repo.ui.promptchoice(
                _(' local changed subrepository %s which remote removed\n'
                  'use (c)hanged version or (d)elete?'
                  '$$ &Changed $$ &Delete') % s, 0):
                debug(s, "prompt remove")
                wctx.sub(s).remove()

    for s, r in sorted(s2.items()):
        if s in s1:
            continue
        elif s not in sa:
            debug(s, "remote added, get", r)
            mctx.sub(s).get(r)
            sm[s] = r
        elif r != sa[s]:
            if repo.ui.promptchoice(
                _(' remote changed subrepository %s which local removed\n'
                  'use (c)hanged version or (d)elete?'
                  '$$ &Changed $$ &Delete') % s, 0) == 0:
                debug(s, "prompt recreate", r)
                wctx.sub(s).get(r)
                sm[s] = r

    # record merged .hgsubstate
    writestate(repo, sm)
    return sm

def _updateprompt(ui, sub, dirty, local, remote):
    if dirty:
        msg = (_(' subrepository sources for %s differ\n'
                 'use (l)ocal source (%s) or (r)emote source (%s)?\n'
                 '$$ &Local $$ &Remote')
               % (subrelpath(sub), local, remote))
    else:
        msg = (_(' subrepository sources for %s differ (in checked out '
                 'version)\n'
                 'use (l)ocal source (%s) or (r)emote source (%s)?\n'
                 '$$ &Local $$ &Remote')
               % (subrelpath(sub), local, remote))
    return ui.promptchoice(msg, 0)

def reporelpath(repo):
    """return path to this (sub)repo as seen from outermost repo"""
    parent = repo
    while util.safehasattr(parent, '_subparent'):
        parent = parent._subparent
    return repo.root[len(pathutil.normasprefix(parent.root)):]

def subrelpath(sub):
    """return path to this subrepo as seen from outermost repo"""
    if util.safehasattr(sub, '_relpath'):
        return sub._relpath
    if not util.safehasattr(sub, '_repo'):
        return sub._path
    return reporelpath(sub._repo)

def _abssource(repo, push=False, abort=True):
    """return pull/push path of repo - either based on parent repo .hgsub info
    or on the top repo config. Abort or return None if no source found."""
    if util.safehasattr(repo, '_subparent'):
        source = util.url(repo._subsource)
        if source.isabs():
            return str(source)
        source.path = posixpath.normpath(source.path)
        parent = _abssource(repo._subparent, push, abort=False)
        if parent:
            parent = util.url(util.pconvert(parent))
            parent.path = posixpath.join(parent.path or '', source.path)
            parent.path = posixpath.normpath(parent.path)
            return str(parent)
    else: # recursion reached top repo
        if util.safehasattr(repo, '_subtoppath'):
            return repo._subtoppath
        if push and repo.ui.config('paths', 'default-push'):
            return repo.ui.config('paths', 'default-push')
        if repo.ui.config('paths', 'default'):
            return repo.ui.config('paths', 'default')
        if repo.sharedpath != repo.path:
            # chop off the .hg component to get the default path form
            return os.path.dirname(repo.sharedpath)
    if abort:
        raise util.Abort(_("default path for subrepository not found"))

def _sanitize(ui, path, ignore):
    for dirname, dirs, names in os.walk(path):
        for i, d in enumerate(dirs):
            if d.lower() == ignore:
                del dirs[i]
                break
        if os.path.basename(dirname).lower() != '.hg':
            continue
        for f in names:
            if f.lower() == 'hgrc':
                ui.warn(_("warning: removing potentially hostile 'hgrc' "
                          "in '%s'\n") % dirname)
                os.unlink(os.path.join(dirname, f))

def subrepo(ctx, path):
    """return instance of the right subrepo class for subrepo in path"""
    # subrepo inherently violates our import layering rules
    # because it wants to make repo objects from deep inside the stack
    # so we manually delay the circular imports to not break
    # scripts that don't use our demand-loading
    global hg
    import hg as h
    hg = h

    pathutil.pathauditor(ctx._repo.root)(path)
    state = ctx.substate[path]
    if state[2] not in types:
        raise util.Abort(_('unknown subrepo type %s') % state[2])
    return types[state[2]](ctx, path, state[:2])

def newcommitphase(ui, ctx):
    commitphase = phases.newcommitphase(ui)
    substate = getattr(ctx, "substate", None)
    if not substate:
        return commitphase
    check = ui.config('phases', 'checksubrepos', 'follow')
    if check not in ('ignore', 'follow', 'abort'):
        raise util.Abort(_('invalid phases.checksubrepos configuration: %s')
                         % (check))
    if check == 'ignore':
        return commitphase
    maxphase = phases.public
    maxsub = None
    for s in sorted(substate):
        sub = ctx.sub(s)
        subphase = sub.phase(substate[s][1])
        if maxphase < subphase:
            maxphase = subphase
            maxsub = s
    if commitphase < maxphase:
        if check == 'abort':
            raise util.Abort(_("can't commit in %s phase"
                               " conflicting %s from subrepository %s") %
                             (phases.phasenames[commitphase],
                              phases.phasenames[maxphase], maxsub))
        ui.warn(_("warning: changes are committed in"
                  " %s phase from subrepository %s\n") %
                (phases.phasenames[maxphase], maxsub))
        return maxphase
    return commitphase

# subrepo classes need to implement the following abstract class:

class abstractsubrepo(object):

    def storeclean(self, path):
        """
        returns true if the repository has not changed since it was last
        cloned from or pushed to a given repository.
        """
        return False

    def dirty(self, ignoreupdate=False):
        """returns true if the dirstate of the subrepo is dirty or does not
        match current stored state. If ignoreupdate is true, only check
        whether the subrepo has uncommitted changes in its dirstate.
        """
        raise NotImplementedError

    def basestate(self):
        """current working directory base state, disregarding .hgsubstate
        state and working directory modifications"""
        raise NotImplementedError

    def checknested(self, path):
        """check if path is a subrepository within this repository"""
        return False

    def commit(self, text, user, date):
        """commit the current changes to the subrepo with the given
        log message. Use given user and date if possible. Return the
        new state of the subrepo.
        """
        raise NotImplementedError

    def phase(self, state):
        """returns phase of specified state in the subrepository.
        """
        return phases.public

    def remove(self):
        """remove the subrepo

        (should verify the dirstate is not dirty first)
        """
        raise NotImplementedError

    def get(self, state, overwrite=False):
        """run whatever commands are needed to put the subrepo into
        this state
        """
        raise NotImplementedError

    def merge(self, state):
        """merge currently-saved state with the new state."""
        raise NotImplementedError

    def push(self, opts):
        """perform whatever action is analogous to 'hg push'

        This may be a no-op on some systems.
        """
        raise NotImplementedError

    def add(self, ui, match, dryrun, listsubrepos, prefix, explicitonly):
        return []

    def cat(self, ui, match, prefix, **opts):
        return 1

    def status(self, rev2, **opts):
        return [], [], [], [], [], [], []

    def diff(self, ui, diffopts, node2, match, prefix, **opts):
        pass

    def outgoing(self, ui, dest, opts):
        return 1

    def incoming(self, ui, source, opts):
        return 1

    def files(self):
        """return filename iterator"""
        raise NotImplementedError

    def filedata(self, name):
        """return file data"""
        raise NotImplementedError

    def fileflags(self, name):
        """return file flags"""
        return ''

    def archive(self, ui, archiver, prefix, match=None):
        if match is not None:
            files = [f for f in self.files() if match(f)]
        else:
            files = self.files()
        total = len(files)
        relpath = subrelpath(self)
        ui.progress(_('archiving (%s)') % relpath, 0,
                    unit=_('files'), total=total)
        for i, name in enumerate(files):
            flags = self.fileflags(name)
            mode = 'x' in flags and 0755 or 0644
            symlink = 'l' in flags
            archiver.addfile(os.path.join(prefix, self._path, name),
                             mode, symlink, self.filedata(name))
            ui.progress(_('archiving (%s)') % relpath, i + 1,
                        unit=_('files'), total=total)
        ui.progress(_('archiving (%s)') % relpath, None)
        return total

    def walk(self, match):
        '''
        walk recursively through the directory tree, finding all files
        matched by the match function
        '''
        pass

    def forget(self, ui, match, prefix):
        return ([], [])

    def revert(self, ui, substate, *pats, **opts):
        ui.warn('%s: reverting %s subrepos is unsupported\n' \
            % (substate[0], substate[2]))
        return []

    def shortid(self, revid):
        return revid

class hgsubrepo(abstractsubrepo):
    def __init__(self, ctx, path, state):
        self._path = path
        self._state = state
        r = ctx._repo
        root = r.wjoin(path)
        create = False
        if not os.path.exists(os.path.join(root, '.hg')):
            create = True
            util.makedirs(root)
        self._repo = hg.repository(r.baseui, root, create=create)
        for s, k in [('ui', 'commitsubrepos')]:
            v = r.ui.config(s, k)
            if v:
                self._repo.ui.setconfig(s, k, v, 'subrepo')
        self._repo.ui.setconfig('ui', '_usedassubrepo', 'True', 'subrepo')
        self._initrepo(r, state[0], create)

    def storeclean(self, path):
        lock = self._repo.lock()
        try:
            return self._storeclean(path)
        finally:
            lock.release()

    def _storeclean(self, path):
        clean = True
        itercache = self._calcstorehash(path)
        try:
            for filehash in self._readstorehashcache(path):
                if filehash != itercache.next():
                    clean = False
                    break
        except StopIteration:
            # the cached and current pull states have a different size
            clean = False
        if clean:
            try:
                itercache.next()
                # the cached and current pull states have a different size
                clean = False
            except StopIteration:
                pass
        return clean

    def _calcstorehash(self, remotepath):
        '''calculate a unique "store hash"

        This method is used to to detect when there are changes that may
        require a push to a given remote path.'''
        # sort the files that will be hashed in increasing (likely) file size
        filelist = ('bookmarks', 'store/phaseroots', 'store/00changelog.i')
        yield '# %s\n' % _expandedabspath(remotepath)
        for relname in filelist:
            absname = os.path.normpath(self._repo.join(relname))
            yield '%s = %s\n' % (relname, _calcfilehash(absname))

    def _getstorehashcachepath(self, remotepath):
        '''get a unique path for the store hash cache'''
        return self._repo.join(os.path.join(
            'cache', 'storehash', _getstorehashcachename(remotepath)))

    def _readstorehashcache(self, remotepath):
        '''read the store hash cache for a given remote repository'''
        cachefile = self._getstorehashcachepath(remotepath)
        if not os.path.exists(cachefile):
            return ''
        fd = open(cachefile, 'r')
        try:
            pullstate = fd.readlines()
        finally:
            fd.close()
        return pullstate

    def _cachestorehash(self, remotepath):
        '''cache the current store hash

        Each remote repo requires its own store hash cache, because a subrepo
        store may be "clean" versus a given remote repo, but not versus another
        '''
        cachefile = self._getstorehashcachepath(remotepath)
        lock = self._repo.lock()
        try:
            storehash = list(self._calcstorehash(remotepath))
            cachedir = os.path.dirname(cachefile)
            if not os.path.exists(cachedir):
                util.makedirs(cachedir, notindexed=True)
            fd = open(cachefile, 'w')
            try:
                fd.writelines(storehash)
            finally:
                fd.close()
        finally:
            lock.release()

    @annotatesubrepoerror
    def _initrepo(self, parentrepo, source, create):
        self._repo._subparent = parentrepo
        self._repo._subsource = source

        if create:
            lines = ['[paths]\n']

            def addpathconfig(key, value):
                if value:
                    lines.append('%s = %s\n' % (key, value))
                    self._repo.ui.setconfig('paths', key, value, 'subrepo')

            defpath = _abssource(self._repo, abort=False)
            defpushpath = _abssource(self._repo, True, abort=False)
            addpathconfig('default', defpath)
            if defpath != defpushpath:
                addpathconfig('default-push', defpushpath)

            fp = self._repo.opener("hgrc", "w", text=True)
            try:
                fp.write(''.join(lines))
            finally:
                fp.close()

    @annotatesubrepoerror
    def add(self, ui, match, dryrun, listsubrepos, prefix, explicitonly):
        return cmdutil.add(ui, self._repo, match, dryrun, listsubrepos,
                           os.path.join(prefix, self._path), explicitonly)

    @annotatesubrepoerror
    def cat(self, ui, match, prefix, **opts):
        rev = self._state[1]
        ctx = self._repo[rev]
        return cmdutil.cat(ui, self._repo, ctx, match, prefix, **opts)

    @annotatesubrepoerror
    def status(self, rev2, **opts):
        try:
            rev1 = self._state[1]
            ctx1 = self._repo[rev1]
            ctx2 = self._repo[rev2]
            return self._repo.status(ctx1, ctx2, **opts)
        except error.RepoLookupError, inst:
            self._repo.ui.warn(_('warning: error "%s" in subrepository "%s"\n')
                               % (inst, subrelpath(self)))
            return [], [], [], [], [], [], []

    @annotatesubrepoerror
    def diff(self, ui, diffopts, node2, match, prefix, **opts):
        try:
            node1 = node.bin(self._state[1])
            # We currently expect node2 to come from substate and be
            # in hex format
            if node2 is not None:
                node2 = node.bin(node2)
            cmdutil.diffordiffstat(ui, self._repo, diffopts,
                                   node1, node2, match,
                                   prefix=posixpath.join(prefix, self._path),
                                   listsubrepos=True, **opts)
        except error.RepoLookupError, inst:
            self._repo.ui.warn(_('warning: error "%s" in subrepository "%s"\n')
                               % (inst, subrelpath(self)))

    @annotatesubrepoerror
    def archive(self, ui, archiver, prefix, match=None):
        self._get(self._state + ('hg',))
        total = abstractsubrepo.archive(self, ui, archiver, prefix, match)
        rev = self._state[1]
        ctx = self._repo[rev]
        for subpath in ctx.substate:
            s = subrepo(ctx, subpath)
            submatch = matchmod.narrowmatcher(subpath, match)
            total += s.archive(
                ui, archiver, os.path.join(prefix, self._path), submatch)
        return total

    @annotatesubrepoerror
    def dirty(self, ignoreupdate=False):
        r = self._state[1]
        if r == '' and not ignoreupdate: # no state recorded
            return True
        w = self._repo[None]
        if r != w.p1().hex() and not ignoreupdate:
            # different version checked out
            return True
        return w.dirty() # working directory changed

    def basestate(self):
        return self._repo['.'].hex()

    def checknested(self, path):
        return self._repo._checknested(self._repo.wjoin(path))

    @annotatesubrepoerror
    def commit(self, text, user, date):
        # don't bother committing in the subrepo if it's only been
        # updated
        if not self.dirty(True):
            return self._repo['.'].hex()
        self._repo.ui.debug("committing subrepo %s\n" % subrelpath(self))
        n = self._repo.commit(text, user, date)
        if not n:
            return self._repo['.'].hex() # different version checked out
        return node.hex(n)

    @annotatesubrepoerror
    def phase(self, state):
        return self._repo[state].phase()

    @annotatesubrepoerror
    def remove(self):
        # we can't fully delete the repository as it may contain
        # local-only history
        self._repo.ui.note(_('removing subrepo %s\n') % subrelpath(self))
        hg.clean(self._repo, node.nullid, False)

    def _get(self, state):
        source, revision, kind = state
        if revision in self._repo.unfiltered():
            return True
        self._repo._subsource = source
        srcurl = _abssource(self._repo)
        other = hg.peer(self._repo, {}, srcurl)
        if len(self._repo) == 0:
            self._repo.ui.status(_('cloning subrepo %s from %s\n')
                                 % (subrelpath(self), srcurl))
            parentrepo = self._repo._subparent
            shutil.rmtree(self._repo.path)
            other, cloned = hg.clone(self._repo._subparent.baseui, {},
                                     other, self._repo.root,
                                     update=False)
            self._repo = cloned.local()
            self._initrepo(parentrepo, source, create=True)
            self._cachestorehash(srcurl)
        else:
            self._repo.ui.status(_('pulling subrepo %s from %s\n')
                                 % (subrelpath(self), srcurl))
            cleansub = self.storeclean(srcurl)
            remotebookmarks = other.listkeys('bookmarks')
            self._repo.pull(other)
            bookmarks.updatefromremote(self._repo.ui, self._repo,
                                       remotebookmarks, srcurl)
            if cleansub:
                # keep the repo clean after pull
                self._cachestorehash(srcurl)
        return False

    @annotatesubrepoerror
    def get(self, state, overwrite=False):
        inrepo = self._get(state)
        source, revision, kind = state
        repo = self._repo
        repo.ui.debug("getting subrepo %s\n" % self._path)
        if inrepo:
            urepo = repo.unfiltered()
            ctx = urepo[revision]
            if ctx.hidden():
                urepo.ui.warn(
                    _('revision %s in subrepo %s is hidden\n') \
                    % (revision[0:12], self._path))
                repo = urepo
        hg.updaterepo(repo, revision, overwrite)

    @annotatesubrepoerror
    def merge(self, state):
        self._get(state)
        cur = self._repo['.']
        dst = self._repo[state[1]]
        anc = dst.ancestor(cur)

        def mergefunc():
            if anc == cur and dst.branch() == cur.branch():
                self._repo.ui.debug("updating subrepo %s\n" % subrelpath(self))
                hg.update(self._repo, state[1])
            elif anc == dst:
                self._repo.ui.debug("skipping subrepo %s\n" % subrelpath(self))
            else:
                self._repo.ui.debug("merging subrepo %s\n" % subrelpath(self))
                hg.merge(self._repo, state[1], remind=False)

        wctx = self._repo[None]
        if self.dirty():
            if anc != dst:
                if _updateprompt(self._repo.ui, self, wctx.dirty(), cur, dst):
                    mergefunc()
            else:
                mergefunc()
        else:
            mergefunc()

    @annotatesubrepoerror
    def push(self, opts):
        force = opts.get('force')
        newbranch = opts.get('new_branch')
        ssh = opts.get('ssh')

        # push subrepos depth-first for coherent ordering
        c = self._repo['']
        subs = c.substate # only repos that are committed
        for s in sorted(subs):
            if c.sub(s).push(opts) == 0:
                return False

        dsturl = _abssource(self._repo, True)
        if not force:
            if self.storeclean(dsturl):
                self._repo.ui.status(
                    _('no changes made to subrepo %s since last push to %s\n')
                    % (subrelpath(self), dsturl))
                return None
        self._repo.ui.status(_('pushing subrepo %s to %s\n') %
            (subrelpath(self), dsturl))
        other = hg.peer(self._repo, {'ssh': ssh}, dsturl)
        res = self._repo.push(other, force, newbranch=newbranch)

        # the repo is now clean
        self._cachestorehash(dsturl)
        return res

    @annotatesubrepoerror
    def outgoing(self, ui, dest, opts):
        return hg.outgoing(ui, self._repo, _abssource(self._repo, True), opts)

    @annotatesubrepoerror
    def incoming(self, ui, source, opts):
        return hg.incoming(ui, self._repo, _abssource(self._repo, False), opts)

    @annotatesubrepoerror
    def files(self):
        rev = self._state[1]
        ctx = self._repo[rev]
        return ctx.manifest()

    def filedata(self, name):
        rev = self._state[1]
        return self._repo[rev][name].data()

    def fileflags(self, name):
        rev = self._state[1]
        ctx = self._repo[rev]
        return ctx.flags(name)

    def walk(self, match):
        ctx = self._repo[None]
        return ctx.walk(match)

    @annotatesubrepoerror
    def forget(self, ui, match, prefix):
        return cmdutil.forget(ui, self._repo, match,
                              os.path.join(prefix, self._path), True)

    @annotatesubrepoerror
    def revert(self, ui, substate, *pats, **opts):
        # reverting a subrepo is a 2 step process:
        # 1. if the no_backup is not set, revert all modified
        #    files inside the subrepo
        # 2. update the subrepo to the revision specified in
        #    the corresponding substate dictionary
        ui.status(_('reverting subrepo %s\n') % substate[0])
        if not opts.get('no_backup'):
            # Revert all files on the subrepo, creating backups
            # Note that this will not recursively revert subrepos
            # We could do it if there was a set:subrepos() predicate
            opts = opts.copy()
            opts['date'] = None
            opts['rev'] = substate[1]

            pats = []
            if not opts.get('all'):
                pats = ['set:modified()']
            self.filerevert(ui, *pats, **opts)

        # Update the repo to the revision specified in the given substate
        self.get(substate, overwrite=True)

    def filerevert(self, ui, *pats, **opts):
        ctx = self._repo[opts['rev']]
        parents = self._repo.dirstate.parents()
        if opts.get('all'):
            pats = ['set:modified()']
        else:
            pats = []
        cmdutil.revert(ui, self._repo, ctx, parents, *pats, **opts)

    def shortid(self, revid):
        return revid[:12]

class svnsubrepo(abstractsubrepo):
    def __init__(self, ctx, path, state):
        self._path = path
        self._state = state
        self._ctx = ctx
        self._ui = ctx._repo.ui
        self._exe = util.findexe('svn')
        if not self._exe:
            raise util.Abort(_("'svn' executable not found for subrepo '%s'")
                             % self._path)

    def _svncommand(self, commands, filename='', failok=False):
        cmd = [self._exe]
        extrakw = {}
        if not self._ui.interactive():
            # Making stdin be a pipe should prevent svn from behaving
            # interactively even if we can't pass --non-interactive.
            extrakw['stdin'] = subprocess.PIPE
            # Starting in svn 1.5 --non-interactive is a global flag
            # instead of being per-command, but we need to support 1.4 so
            # we have to be intelligent about what commands take
            # --non-interactive.
            if commands[0] in ('update', 'checkout', 'commit'):
                cmd.append('--non-interactive')
        cmd.extend(commands)
        if filename is not None:
            path = os.path.join(self._ctx._repo.origroot, self._path, filename)
            cmd.append(path)
        env = dict(os.environ)
        # Avoid localized output, preserve current locale for everything else.
        lc_all = env.get('LC_ALL')
        if lc_all:
            env['LANG'] = lc_all
            del env['LC_ALL']
        env['LC_MESSAGES'] = 'C'
        p = subprocess.Popen(cmd, bufsize=-1, close_fds=util.closefds,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                              universal_newlines=True, env=env, **extrakw)
        stdout, stderr = p.communicate()
        stderr = stderr.strip()
        if not failok:
            if p.returncode:
                raise util.Abort(stderr or 'exited with code %d' % p.returncode)
            if stderr:
                self._ui.warn(stderr + '\n')
        return stdout, stderr

    @propertycache
    def _svnversion(self):
        output, err = self._svncommand(['--version', '--quiet'], filename=None)
        m = re.search(r'^(\d+)\.(\d+)', output)
        if not m:
            raise util.Abort(_('cannot retrieve svn tool version'))
        return (int(m.group(1)), int(m.group(2)))

    def _wcrevs(self):
        # Get the working directory revision as well as the last
        # commit revision so we can compare the subrepo state with
        # both. We used to store the working directory one.
        output, err = self._svncommand(['info', '--xml'])
        doc = xml.dom.minidom.parseString(output)
        entries = doc.getElementsByTagName('entry')
        lastrev, rev = '0', '0'
        if entries:
            rev = str(entries[0].getAttribute('revision')) or '0'
            commits = entries[0].getElementsByTagName('commit')
            if commits:
                lastrev = str(commits[0].getAttribute('revision')) or '0'
        return (lastrev, rev)

    def _wcrev(self):
        return self._wcrevs()[0]

    def _wcchanged(self):
        """Return (changes, extchanges, missing) where changes is True
        if the working directory was changed, extchanges is
        True if any of these changes concern an external entry and missing
        is True if any change is a missing entry.
        """
        output, err = self._svncommand(['status', '--xml'])
        externals, changes, missing = [], [], []
        doc = xml.dom.minidom.parseString(output)
        for e in doc.getElementsByTagName('entry'):
            s = e.getElementsByTagName('wc-status')
            if not s:
                continue
            item = s[0].getAttribute('item')
            props = s[0].getAttribute('props')
            path = e.getAttribute('path')
            if item == 'external':
                externals.append(path)
            elif item == 'missing':
                missing.append(path)
            if (item not in ('', 'normal', 'unversioned', 'external')
                or props not in ('', 'none', 'normal')):
                changes.append(path)
        for path in changes:
            for ext in externals:
                if path == ext or path.startswith(ext + os.sep):
                    return True, True, bool(missing)
        return bool(changes), False, bool(missing)

    def dirty(self, ignoreupdate=False):
        if not self._wcchanged()[0]:
            if self._state[1] in self._wcrevs() or ignoreupdate:
                return False
        return True

    def basestate(self):
        lastrev, rev = self._wcrevs()
        if lastrev != rev:
            # Last committed rev is not the same than rev. We would
            # like to take lastrev but we do not know if the subrepo
            # URL exists at lastrev.  Test it and fallback to rev it
            # is not there.
            try:
                self._svncommand(['list', '%s@%s' % (self._state[0], lastrev)])
                return lastrev
            except error.Abort:
                pass
        return rev

    @annotatesubrepoerror
    def commit(self, text, user, date):
        # user and date are out of our hands since svn is centralized
        changed, extchanged, missing = self._wcchanged()
        if not changed:
            return self.basestate()
        if extchanged:
            # Do not try to commit externals
            raise util.Abort(_('cannot commit svn externals'))
        if missing:
            # svn can commit with missing entries but aborting like hg
            # seems a better approach.
            raise util.Abort(_('cannot commit missing svn entries'))
        commitinfo, err = self._svncommand(['commit', '-m', text])
        self._ui.status(commitinfo)
        newrev = re.search('Committed revision ([0-9]+).', commitinfo)
        if not newrev:
            if not commitinfo.strip():
                # Sometimes, our definition of "changed" differs from
                # svn one. For instance, svn ignores missing files
                # when committing. If there are only missing files, no
                # commit is made, no output and no error code.
                raise util.Abort(_('failed to commit svn changes'))
            raise util.Abort(commitinfo.splitlines()[-1])
        newrev = newrev.groups()[0]
        self._ui.status(self._svncommand(['update', '-r', newrev])[0])
        return newrev

    @annotatesubrepoerror
    def remove(self):
        if self.dirty():
            self._ui.warn(_('not removing repo %s because '
                            'it has changes.\n') % self._path)
            return
        self._ui.note(_('removing subrepo %s\n') % self._path)

        def onerror(function, path, excinfo):
            if function is not os.remove:
                raise
            # read-only files cannot be unlinked under Windows
            s = os.stat(path)
            if (s.st_mode & stat.S_IWRITE) != 0:
                raise
            os.chmod(path, stat.S_IMODE(s.st_mode) | stat.S_IWRITE)
            os.remove(path)

        path = self._ctx._repo.wjoin(self._path)
        shutil.rmtree(path, onerror=onerror)
        try:
            os.removedirs(os.path.dirname(path))
        except OSError:
            pass

    @annotatesubrepoerror
    def get(self, state, overwrite=False):
        if overwrite:
            self._svncommand(['revert', '--recursive'])
        args = ['checkout']
        if self._svnversion >= (1, 5):
            args.append('--force')
        # The revision must be specified at the end of the URL to properly
        # update to a directory which has since been deleted and recreated.
        args.append('%s@%s' % (state[0], state[1]))
        status, err = self._svncommand(args, failok=True)
        _sanitize(self._ui, self._ctx._repo.wjoin(self._path), '.svn')
        if not re.search('Checked out revision [0-9]+.', status):
            if ('is already a working copy for a different URL' in err
                and (self._wcchanged()[:2] == (False, False))):
                # obstructed but clean working copy, so just blow it away.
                self.remove()
                self.get(state, overwrite=False)
                return
            raise util.Abort((status or err).splitlines()[-1])
        self._ui.status(status)

    @annotatesubrepoerror
    def merge(self, state):
        old = self._state[1]
        new = state[1]
        wcrev = self._wcrev()
        if new != wcrev:
            dirty = old == wcrev or self._wcchanged()[0]
            if _updateprompt(self._ui, self, dirty, wcrev, new):
                self.get(state, False)

    def push(self, opts):
        # push is a no-op for SVN
        return True

    @annotatesubrepoerror
    def files(self):
        output = self._svncommand(['list', '--recursive', '--xml'])[0]
        doc = xml.dom.minidom.parseString(output)
        paths = []
        for e in doc.getElementsByTagName('entry'):
            kind = str(e.getAttribute('kind'))
            if kind != 'file':
                continue
            name = ''.join(c.data for c
                           in e.getElementsByTagName('name')[0].childNodes
                           if c.nodeType == c.TEXT_NODE)
            paths.append(name.encode('utf-8'))
        return paths

    def filedata(self, name):
        return self._svncommand(['cat'], name)[0]


class gitsubrepo(abstractsubrepo):
    def __init__(self, ctx, path, state):
        self._state = state
        self._ctx = ctx
        self._path = path
        self._relpath = os.path.join(reporelpath(ctx._repo), path)
        self._abspath = ctx._repo.wjoin(path)
        self._subparent = ctx._repo
        self._ui = ctx._repo.ui
        self._ensuregit()

    def _ensuregit(self):
        try:
            self._gitexecutable = 'git'
            out, err = self._gitnodir(['--version'])
        except OSError, e:
            if e.errno != 2 or os.name != 'nt':
                raise
            self._gitexecutable = 'git.cmd'
            out, err = self._gitnodir(['--version'])
        versionstatus = self._checkversion(out)
        if versionstatus == 'unknown':
            self._ui.warn(_('cannot retrieve git version\n'))
        elif versionstatus == 'abort':
            raise util.Abort(_('git subrepo requires at least 1.6.0 or later'))
        elif versionstatus == 'warning':
            self._ui.warn(_('git subrepo requires at least 1.6.0 or later\n'))

    @staticmethod
    def _checkversion(out):
        '''ensure git version is new enough

        >>> _checkversion = gitsubrepo._checkversion
        >>> _checkversion('git version 1.6.0')
        'ok'
        >>> _checkversion('git version 1.8.5')
        'ok'
        >>> _checkversion('git version 1.4.0')
        'abort'
        >>> _checkversion('git version 1.5.0')
        'warning'
        >>> _checkversion('git version 1.9-rc0')
        'ok'
        >>> _checkversion('git version 1.9.0.265.g81cdec2')
        'ok'
        >>> _checkversion('git version 1.9.0.GIT')
        'ok'
        >>> _checkversion('git version 12345')
        'unknown'
        >>> _checkversion('no')
        'unknown'
        '''
        m = re.search(r'^git version (\d+)\.(\d+)', out)
        if not m:
            return 'unknown'
        version = (int(m.group(1)), int(m.group(2)))
        # git 1.4.0 can't work at all, but 1.5.X can in at least some cases,
        # despite the docstring comment.  For now, error on 1.4.0, warn on
        # 1.5.0 but attempt to continue.
        if version < (1, 5):
            return 'abort'
        elif version < (1, 6):
            return 'warning'
        return 'ok'

    def _gitcommand(self, commands, env=None, stream=False):
        return self._gitdir(commands, env=env, stream=stream)[0]

    def _gitdir(self, commands, env=None, stream=False):
        return self._gitnodir(commands, env=env, stream=stream,
                              cwd=self._abspath)

    def _gitnodir(self, commands, env=None, stream=False, cwd=None):
        """Calls the git command

        The methods tries to call the git command. versions prior to 1.6.0
        are not supported and very probably fail.
        """
        self._ui.debug('%s: git %s\n' % (self._relpath, ' '.join(commands)))
        if env is None:
            env = os.environ.copy()
        # fix for Git CVE-2015-7545
        if 'GIT_ALLOW_PROTOCOL' not in env:
            env['GIT_ALLOW_PROTOCOL'] = 'file:git:http:https:ssh'
        # unless ui.quiet is set, print git's stderr,
        # which is mostly progress and useful info
        errpipe = None
        if self._ui.quiet:
            errpipe = open(os.devnull, 'w')
        p = subprocess.Popen([self._gitexecutable] + commands, bufsize=-1,
                             cwd=cwd, env=env, close_fds=util.closefds,
                             stdout=subprocess.PIPE, stderr=errpipe)
        if stream:
            return p.stdout, None

        retdata = p.stdout.read().strip()
        # wait for the child to exit to avoid race condition.
        p.wait()

        if p.returncode != 0 and p.returncode != 1:
            # there are certain error codes that are ok
            command = commands[0]
            if command in ('cat-file', 'symbolic-ref'):
                return retdata, p.returncode
            # for all others, abort
            raise util.Abort('git %s error %d in %s' %
                             (command, p.returncode, self._relpath))

        return retdata, p.returncode

    def _gitmissing(self):
        return not os.path.exists(os.path.join(self._abspath, '.git'))

    def _gitstate(self):
        return self._gitcommand(['rev-parse', 'HEAD'])

    def _gitcurrentbranch(self):
        current, err = self._gitdir(['symbolic-ref', 'HEAD', '--quiet'])
        if err:
            current = None
        return current

    def _gitremote(self, remote):
        out = self._gitcommand(['remote', 'show', '-n', remote])
        line = out.split('\n')[1]
        i = line.index('URL: ') + len('URL: ')
        return line[i:]

    def _githavelocally(self, revision):
        out, code = self._gitdir(['cat-file', '-e', revision])
        return code == 0

    def _gitisancestor(self, r1, r2):
        base = self._gitcommand(['merge-base', r1, r2])
        return base == r1

    def _gitisbare(self):
        return self._gitcommand(['config', '--bool', 'core.bare']) == 'true'

    def _gitupdatestat(self):
        """This must be run before git diff-index.
        diff-index only looks at changes to file stat;
        this command looks at file contents and updates the stat."""
        self._gitcommand(['update-index', '-q', '--refresh'])

    def _gitbranchmap(self):
        '''returns 2 things:
        a map from git branch to revision
        a map from revision to branches'''
        branch2rev = {}
        rev2branch = {}

        out = self._gitcommand(['for-each-ref', '--format',
                                '%(objectname) %(refname)'])
        for line in out.split('\n'):
            revision, ref = line.split(' ')
            if (not ref.startswith('refs/heads/') and
                not ref.startswith('refs/remotes/')):
                continue
            if ref.startswith('refs/remotes/') and ref.endswith('/HEAD'):
                continue # ignore remote/HEAD redirects
            branch2rev[ref] = revision
            rev2branch.setdefault(revision, []).append(ref)
        return branch2rev, rev2branch

    def _gittracking(self, branches):
        'return map of remote branch to local tracking branch'
        # assumes no more than one local tracking branch for each remote
        tracking = {}
        for b in branches:
            if b.startswith('refs/remotes/'):
                continue
            bname = b.split('/', 2)[2]
            remote = self._gitcommand(['config', 'branch.%s.remote' % bname])
            if remote:
                ref = self._gitcommand(['config', 'branch.%s.merge' % bname])
                tracking['refs/remotes/%s/%s' %
                         (remote, ref.split('/', 2)[2])] = b
        return tracking

    def _abssource(self, source):
        if '://' not in source:
            # recognize the scp syntax as an absolute source
            colon = source.find(':')
            if colon != -1 and '/' not in source[:colon]:
                return source
        self._subsource = source
        return _abssource(self)

    def _fetch(self, source, revision):
        if self._gitmissing():
            source = self._abssource(source)
            self._ui.status(_('cloning subrepo %s from %s\n') %
                            (self._relpath, source))
            self._gitnodir(['clone', source, self._abspath])
        if self._githavelocally(revision):
            return
        self._ui.status(_('pulling subrepo %s from %s\n') %
                        (self._relpath, self._gitremote('origin')))
        # try only origin: the originally cloned repo
        self._gitcommand(['fetch'])
        if not self._githavelocally(revision):
            raise util.Abort(_("revision %s does not exist in subrepo %s\n") %
                               (revision, self._relpath))

    @annotatesubrepoerror
    def dirty(self, ignoreupdate=False):
        if self._gitmissing():
            return self._state[1] != ''
        if self._gitisbare():
            return True
        if not ignoreupdate and self._state[1] != self._gitstate():
            # different version checked out
            return True
        # check for staged changes or modified files; ignore untracked files
        self._gitupdatestat()
        out, code = self._gitdir(['diff-index', '--quiet', 'HEAD'])
        return code == 1

    def basestate(self):
        return self._gitstate()

    @annotatesubrepoerror
    def get(self, state, overwrite=False):
        source, revision, kind = state
        if not revision:
            self.remove()
            return
        self._fetch(source, revision)
        # if the repo was set to be bare, unbare it
        if self._gitisbare():
            self._gitcommand(['config', 'core.bare', 'false'])
            if self._gitstate() == revision:
                self._gitcommand(['reset', '--hard', 'HEAD'])
                return
        elif self._gitstate() == revision:
            if overwrite:
                # first reset the index to unmark new files for commit, because
                # reset --hard will otherwise throw away files added for commit,
                # not just unmark them.
                self._gitcommand(['reset', 'HEAD'])
                self._gitcommand(['reset', '--hard', 'HEAD'])
            return
        branch2rev, rev2branch = self._gitbranchmap()

        def checkout(args):
            cmd = ['checkout']
            if overwrite:
                # first reset the index to unmark new files for commit, because
                # the -f option will otherwise throw away files added for
                # commit, not just unmark them.
                self._gitcommand(['reset', 'HEAD'])
                cmd.append('-f')
            self._gitcommand(cmd + args)
            _sanitize(self._ui, self._abspath, '.git')

        def rawcheckout():
            # no branch to checkout, check it out with no branch
            self._ui.warn(_('checking out detached HEAD in subrepo %s\n') %
                          self._relpath)
            self._ui.warn(_('check out a git branch if you intend '
                            'to make changes\n'))
            checkout(['-q', revision])

        if revision not in rev2branch:
            rawcheckout()
            return
        branches = rev2branch[revision]
        firstlocalbranch = None
        for b in branches:
            if b == 'refs/heads/master':
                # master trumps all other branches
                checkout(['refs/heads/master'])
                return
            if not firstlocalbranch and not b.startswith('refs/remotes/'):
                firstlocalbranch = b
        if firstlocalbranch:
            checkout([firstlocalbranch])
            return

        tracking = self._gittracking(branch2rev.keys())
        # choose a remote branch already tracked if possible
        remote = branches[0]
        if remote not in tracking:
            for b in branches:
                if b in tracking:
                    remote = b
                    break

        if remote not in tracking:
            # create a new local tracking branch
            local = remote.split('/', 3)[3]
            checkout(['-b', local, remote])
        elif self._gitisancestor(branch2rev[tracking[remote]], remote):
            # When updating to a tracked remote branch,
            # if the local tracking branch is downstream of it,
            # a normal `git pull` would have performed a "fast-forward merge"
            # which is equivalent to updating the local branch to the remote.
            # Since we are only looking at branching at update, we need to
            # detect this situation and perform this action lazily.
            if tracking[remote] != self._gitcurrentbranch():
                checkout([tracking[remote]])
            self._gitcommand(['merge', '--ff', remote])
            _sanitize(self._ui, self._abspath, '.git')
        else:
            # a real merge would be required, just checkout the revision
            rawcheckout()

    @annotatesubrepoerror
    def commit(self, text, user, date):
        if self._gitmissing():
            raise util.Abort(_("subrepo %s is missing") % self._relpath)
        cmd = ['commit', '-a', '-m', text]
        env = os.environ.copy()
        if user:
            cmd += ['--author', user]
        if date:
            # git's date parser silently ignores when seconds < 1e9
            # convert to ISO8601
            env['GIT_AUTHOR_DATE'] = util.datestr(date,
                                                  '%Y-%m-%dT%H:%M:%S %1%2')
        self._gitcommand(cmd, env=env)
        # make sure commit works otherwise HEAD might not exist under certain
        # circumstances
        return self._gitstate()

    @annotatesubrepoerror
    def merge(self, state):
        source, revision, kind = state
        self._fetch(source, revision)
        base = self._gitcommand(['merge-base', revision, self._state[1]])
        self._gitupdatestat()
        out, code = self._gitdir(['diff-index', '--quiet', 'HEAD'])

        def mergefunc():
            if base == revision:
                self.get(state) # fast forward merge
            elif base != self._state[1]:
                self._gitcommand(['merge', '--no-commit', revision])
            _sanitize(self._ui, self._abspath, '.git')

        if self.dirty():
            if self._gitstate() != revision:
                dirty = self._gitstate() == self._state[1] or code != 0
                if _updateprompt(self._ui, self, dirty,
                                 self._state[1][:7], revision[:7]):
                    mergefunc()
        else:
            mergefunc()

    @annotatesubrepoerror
    def push(self, opts):
        force = opts.get('force')

        if not self._state[1]:
            return True
        if self._gitmissing():
            raise util.Abort(_("subrepo %s is missing") % self._relpath)
        # if a branch in origin contains the revision, nothing to do
        branch2rev, rev2branch = self._gitbranchmap()
        if self._state[1] in rev2branch:
            for b in rev2branch[self._state[1]]:
                if b.startswith('refs/remotes/origin/'):
                    return True
        for b, revision in branch2rev.iteritems():
            if b.startswith('refs/remotes/origin/'):
                if self._gitisancestor(self._state[1], revision):
                    return True
        # otherwise, try to push the currently checked out branch
        cmd = ['push']
        if force:
            cmd.append('--force')

        current = self._gitcurrentbranch()
        if current:
            # determine if the current branch is even useful
            if not self._gitisancestor(self._state[1], current):
                self._ui.warn(_('unrelated git branch checked out '
                                'in subrepo %s\n') % self._relpath)
                return False
            self._ui.status(_('pushing branch %s of subrepo %s\n') %
                            (current.split('/', 2)[2], self._relpath))
            ret = self._gitdir(cmd + ['origin', current])
            return ret[1] == 0
        else:
            self._ui.warn(_('no branch checked out in subrepo %s\n'
                            'cannot push revision %s\n') %
                          (self._relpath, self._state[1]))
            return False

    @annotatesubrepoerror
    def remove(self):
        if self._gitmissing():
            return
        if self.dirty():
            self._ui.warn(_('not removing repo %s because '
                            'it has changes.\n') % self._relpath)
            return
        # we can't fully delete the repository as it may contain
        # local-only history
        self._ui.note(_('removing subrepo %s\n') % self._relpath)
        self._gitcommand(['config', 'core.bare', 'true'])
        for f in os.listdir(self._abspath):
            if f == '.git':
                continue
            path = os.path.join(self._abspath, f)
            if os.path.isdir(path) and not os.path.islink(path):
                shutil.rmtree(path)
            else:
                os.remove(path)

    def archive(self, ui, archiver, prefix, match=None):
        total = 0
        source, revision = self._state
        if not revision:
            return total
        self._fetch(source, revision)

        # Parse git's native archive command.
        # This should be much faster than manually traversing the trees
        # and objects with many subprocess calls.
        tarstream = self._gitcommand(['archive', revision], stream=True)
        tar = tarfile.open(fileobj=tarstream, mode='r|')
        relpath = subrelpath(self)
        ui.progress(_('archiving (%s)') % relpath, 0, unit=_('files'))
        for i, info in enumerate(tar):
            if info.isdir():
                continue
            if match and not match(info.name):
                continue
            if info.issym():
                data = info.linkname
            else:
                data = tar.extractfile(info).read()
            archiver.addfile(os.path.join(prefix, self._path, info.name),
                             info.mode, info.issym(), data)
            total += 1
            ui.progress(_('archiving (%s)') % relpath, i + 1,
                        unit=_('files'))
        ui.progress(_('archiving (%s)') % relpath, None)
        return total


    @annotatesubrepoerror
    def status(self, rev2, **opts):
        rev1 = self._state[1]
        if self._gitmissing() or not rev1:
            # if the repo is missing, return no results
            return [], [], [], [], [], [], []
        modified, added, removed = [], [], []
        self._gitupdatestat()
        if rev2:
            command = ['diff-tree', rev1, rev2]
        else:
            command = ['diff-index', rev1]
        out = self._gitcommand(command)
        for line in out.split('\n'):
            tab = line.find('\t')
            if tab == -1:
                continue
            status, f = line[tab - 1], line[tab + 1:]
            if status == 'M':
                modified.append(f)
            elif status == 'A':
                added.append(f)
            elif status == 'D':
                removed.append(f)

        deleted = unknown = ignored = clean = []
        return modified, added, removed, deleted, unknown, ignored, clean

    def shortid(self, revid):
        return revid[:7]

types = {
    'hg': hgsubrepo,
    'svn': svnsubrepo,
    'git': gitsubrepo,
    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python2.7/dist-packages/mercurial/subrepo.pyc                                               0100644 0000000 0000000 00000162413 13077704337 021314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ò)Wc           @   s&  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z e a e j Z d d d f Z d „  Z d „  Z d „  Z d e j f d	 „  ƒ  YZ d
 „  Z  d „  Z! d „  Z" d „  Z# d „  Z$ d „  Z% d „  Z& e' e( d „ Z) d „  Z* d „  Z+ d „  Z, d e- f d „  ƒ  YZ. d e. f d „  ƒ  YZ/ d e. f d „  ƒ  YZ0 d e. f d „  ƒ  YZ1 i e/ d 6e0 d 6e1 d 6Z2 d S(    iÿÿÿÿN(   t   _t    t   emptyc         C   sU   t  j t  j |  ƒ ƒ } t  j | ƒ } | j sQ t  j t j j | j ƒ ƒ }  n  |  S(   sU   
    get a path or url and if it is a path expand it and return an absolute path
    (	   t   utilt   urllocalpatht
   expandpatht   urlt   schemet   normpatht   ost   patht   abspath(   R
   t   expandedpatht   u(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _expandedabspath   s
    	!c         C   s    t  j t |  ƒ ƒ j ƒ  d d !S(   sE   get a unique filename for the store hash cache of a remote repositoryi    i   (   R   t   sha1R   t	   hexdigest(   t
   remotepath(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _getstorehashcachename   s    c         C   s[   d } t  j j |  ƒ rH t |  d ƒ } z | j ƒ  } Wd  | j ƒ  Xn  t j | ƒ j ƒ  S(   NR   t   rb(	   R	   R
   t   existst   opent   readt   closeR   R   R   (   t   filenamet   datat   fd(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _calcfilehash"   s    t   SubrepoAbortc           B   s   e  Z d  Z d „  Z RS(   sE   Exception class used to avoid handling a subrepo error more than oncec         O   s>   t  j j |  | | Ž | j d ƒ |  _ | j d ƒ |  _ d  S(   Nt   subrepot   cause(   t   errort   Abortt   __init__t   getR   R   (   t   selft   argst   kw(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR!   .   s    (   t   __name__t
   __module__t   __doc__R!   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR   ,   s   c            s   ‡  f d †  } | S(   Nc            sœ   y ˆ  |  | | Ž } Wn t  k
 r1 } | ‚ ng t j k
 r— } t |  ƒ } t | ƒ d t d ƒ | } t  | d | j d | d t j ƒ  ƒ‚ n X| S(   Nt    s   (in subrepo %s)t   hintR   R   (	   R   R   R    t
   subrelpatht   strR    R*   t   syst   exc_info(   R#   R$   t   kargst   rest   exR   t   errormsg(   t   func(    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   decoratedmethod4   s    	(    (   R3   R4   (    (   R3   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   annotatesubrepoerror3   s    c            s÷  t  j  ƒ  ‰ d d ‡  ‡ ‡ ‡ f d † ‰ d ˆ  k rC ˆ d ƒ n  x? ˆ j d ƒ D]. \ } } ˆ j d | | ˆ j d | ƒ ƒ qS Wi  } d ˆ  k rhy  x™ t ˆ  d j ƒ  j ƒ  ƒ D]{ \ } } | j ƒ  } | sÛ q· n  y | j	 d d ƒ \ } } Wn. t
 k
 r't j t d ƒ | d ƒ ‚ n X| | | <q· WWqht k
 rd} | j t j k re‚  qeqhXn  ‡ f d †  }	 i  }
 xsˆ d	 j ƒ  D]a\ } } d
 } | j d ƒ rd | k rÓt j t d ƒ ƒ ‚ n  | j	 d d ƒ \ } } | d } | j ƒ  } n  t j | ƒ j ƒ  sµt ˆ  j d t ƒ} | rµt j | ƒ } t j | j pUd	 | ƒ | _ t j | j ƒ | _ t | ƒ } |	 | ƒ } | | k r©|	 | ƒ } q²| } qµn  |	 | ƒ } | j ƒ  | j | d	 ƒ | f |
 t j | ƒ <qŽW|
 S(   s    return a state dict, mapping subrepo paths configured in .hgsub
    to tuple: (source from .hgsub, revision from .hgsubstate, kind
    (key in types dict))
    c            sŸ   |  ˆ  k r‚ y ˆ  |  j  ƒ  } WnC t k
 re } | j t j k rJ ‚  n  ˆ j t d ƒ |  ƒ d  SXˆ j |  | | | ˆ ƒ n t j t d ƒ |  ƒ ‚ d  S(   Ns(   warning: subrepo spec file %s not found
s   subrepo spec file %s not found(	   R   t   IOErrort   errnot   ENOENTt   warnR    t   parseR   R    (   t   ft   sectionst   remapR   t   err(   t   ctxt   pR   t   ui(    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR   I   s    s   .hgsubt   subpathss   .hgsubstateR)   i   s?   invalid subrepository revision specifier in .hgsubstate line %dc            s¨   x¡ ˆ  j  d ƒ D] \ } } | j d ƒ } t j d d | ƒ } y t j | | |  d ƒ }  Wq t j k
 rŸ } t j t d ƒ ˆ  j d | ƒ | f ƒ ‚ q Xq W|  S(   NRB   s   string-escapes   \\\\([0-9]+)s   \\\1i   s#   bad subrepository pattern in %s: %s(	   t   itemst   encodet   ret   subR   R   R    R    t   source(   t   srct   patternt   replt   e(   R@   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR=   o   s    $R   t   hgt   [t   ]s   missing ] in subrepo sourcet   abortN(    t   configt   Nonet   configitemst   sett   configsourcet	   enumerateR   t
   splitlinest   lstript   splitt
   ValueErrorR   R    R    R6   R7   R8   RC   t
   startswithR   t   isabst
   _abssourcet   _repot   Falset	   posixpatht   joinR
   R   R,   t   stripR"   t   pconvert(   R?   RA   R
   RH   t   revt   it   lt   revisionR>   R=   t   statet   kindt   parentt   joinedt   remapped(    (   R?   R@   R   RA   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRg   C   s\    &)
2c         C   sQ   g  t  | ƒ D] } d | | d | f ^ q } |  j d d j | ƒ d ƒ d S(   s=   rewrite .hgsubstate in (outer) repo with these subrepo statess   %s %s
i   s   .hgsubstateR   N(   t   sortedt   wwriteR`   (   t   repoRg   t   st   lines(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt
   writestate   s    1c            s¸  | | k r | j  ƒ  } n  | j } | j } | j } i  } ˆ  j j d | | | f ƒ d ‡  f d † }	 xZt | j ƒ  ƒ D]F\ }
 } | j |
 t ƒ } | } | j |
 ƒ j	 ƒ  rÒ | d | d d f } n  | | k rç | } n  |
 | k r*| |
 } | | k s| | k r%| | |
 <q~ qÄ| | k rg|	 |
 d | ƒ | j |
 ƒ j | | ƒ | | |
 <qÄ| d | d k räˆ  j j
 t d ƒ |
 | d | d f d ƒ r'|	 |
 d	 | ƒ | j |
 ƒ j | | ƒ | | |
 <q'qÄ| d | d k r.|	 |
 d
 | ƒ | j |
 ƒ j | | ƒ | | |
 <qÄ|	 |
 d ƒ | j |
 ƒ } ˆ  j j
 t d ƒ |
 | j | d ƒ | j | d ƒ f d ƒ } | d k rË| j |
 ƒ j | ƒ | | |
 <|	 |
 d | ƒ qÄ| d k rô| | |
 <|	 |
 d | ƒ qÄ| j |
 ƒ j | | ƒ | | |
 <|	 |
 d | ƒ q~ | | k rY|	 |
 d ƒ | j |
 ƒ j ƒ  q~ | t k r‚|	 |
 d ƒ | | |
 <q~ q~ ˆ  j j
 t d ƒ |
 d ƒ r~ |	 |
 d ƒ | j |
 ƒ j ƒ  q~ q~ WxÜ t | j ƒ  ƒ D]È \ }
 } |
 | k rùqÛqÛ|
 | k r8|	 |
 d | ƒ | j |
 ƒ j | ƒ | | |
 <qÛ| | |
 k rÛˆ  j j
 t d ƒ |
 d ƒ d k r£|	 |
 d | ƒ | j |
 ƒ j | ƒ | | |
 <q£qÛqÛWt ˆ  | ƒ | S(   s{   delegated from merge.applyupdates: merging of .hgsubstate file
    in working context, merging context and ancestor contexts   subrepo merge %s %s %s
R   c            s4   | r d | } n  ˆ  j  j d |  | | f ƒ d  S(   Ns   %s:%s:%ss     subrepo %s: %s %s
(   RA   t   debug(   Ro   t   msgt   r(   Rn   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRr   ®   s    i    i   t   +s   other changed, getsi    subrepository sources for %s differ
use (l)ocal source (%s) or (r)emote source (%s)?$$ &Local $$ &Remotes   prompt changed, gets   other side changed, gets   both sides changedsŠ    subrepository %s diverged (local revision: %s, remote revision: %s)
(M)erge, keep (l)ocal or keep (r)emote?$$ &Merge $$ &Local $$ &Remotes
   merge withs   keep local subrepo revisions   get remote subrepo revisions   remote removed, removes   local added, keepsm    local changed subrepository %s which remote removed
use (c)hanged version or (d)elete?$$ &Changed $$ &Deletes   prompt removes   remote added, getsm    remote changed subrepository %s which local removed
use (c)hanged version or (d)elete?$$ &Changed $$ &Deletes   prompt recreate(   t   p1t   substateRA   Rr   Rl   t	   iteritemsR"   t	   nullstateRF   t   dirtyt   promptchoiceR    t   shortidt   merget   removeRC   Rq   (   Rn   t   wctxt   mctxt   actxt	   overwritet   s1t   s2t   sat   smRr   Ro   Re   t   at   ldRt   t   srepot   option(    (   Rn   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   submerge¢   sœ    				

				0



				c         C   sW   | r( t  d ƒ t | ƒ | | f } n t  d ƒ t | ƒ | | f } |  j | d ƒ S(   Nsj    subrepository sources for %s differ
use (l)ocal source (%s) or (r)emote source (%s)?
$$ &Local $$ &Remotesƒ    subrepository sources for %s differ (in checked out version)
use (l)ocal source (%s) or (r)emote source (%s)?
$$ &Local $$ &Remotei    (   R    R+   R{   (   RA   RF   Rz   t   localt   remoteRs   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _updateprompt  s    		c         C   sE   |  } x t  j | d ƒ r' | j } q	 W|  j t t j | j ƒ ƒ S(   s9   return path to this (sub)repo as seen from outermost repot
   _subparent(   R   t   safehasattrR   t   roott   lent   pathutilt   normasprefix(   Rn   Ri   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   reporelpath  s    c         C   s?   t  j |  d ƒ r |  j St  j |  d ƒ s2 |  j St |  j ƒ S(   s7   return path to this subrepo as seen from outermost repot   _relpathR]   (   R   R   R–   t   _pathR•   R]   (   RF   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR+     s
    c         C   s~  t  j |  d ƒ rÈ t  j |  j ƒ } | j ƒ  r: t | ƒ St j | j ƒ | _ t	 |  j
 | d t ƒ} | r\t  j t  j | ƒ ƒ } t j | j p— d | j ƒ | _ t j | j ƒ | _ t | ƒ Sn” t  j |  d ƒ rá |  j S| r|  j j d d ƒ r|  j j d d ƒ S|  j j d d ƒ r7|  j j d d ƒ S|  j |  j k r\t j j |  j ƒ S| rzt  j t d ƒ ƒ ‚ n  d	 S(
   s   return pull/push path of repo - either based on parent repo .hgsub info
    or on the top repo config. Abort or return None if no source found.R   RO   R   t   _subtoppatht   pathss   default-pusht   defaults(   default path for subrepository not foundN(   R   R   R   t
   _subsourceR[   R,   R_   R   R
   R\   R   R^   Rb   R`   R˜   RA   RP   t
   sharedpathR	   t   dirnameR    R    (   Rn   t   pushRO   RG   Ri   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR\   $  s*    
!c   	      C   sÞ   x× t  j | ƒ D]Æ \ } } } x7 t | ƒ D]) \ } } | j ƒ  | k r, | | =Pq, q, Wt  j j | ƒ j ƒ  d k r} q n  xV | D]N } | j ƒ  d k r„ |  j t d ƒ | ƒ t  j t  j j	 | | ƒ ƒ q„ q„ Wq Wd  S(   Ns   .hgt   hgrcs5   warning: removing potentially hostile 'hgrc' in '%s'
(
   R	   t   walkRU   t   lowerR
   t   basenameR9   R    t   unlinkR`   (	   RA   R
   t   ignoreR   t   dirst   namesRd   t   dR;   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt	   _sanitize?  s    c         C   s„   d d l  } | a  t j |  j j ƒ | ƒ |  j | } | d t k rh t j t	 d ƒ | d ƒ ‚ n  t | d |  | | d  ƒ S(   s>   return instance of the right subrepo class for subrepo in pathiÿÿÿÿNi   s   unknown subrepo type %s(
   RL   R“   t   pathauditorR]   R‘   Rw   t   typesR   R    R    (   R?   R
   t   hRg   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR   M  s     c   
      C   sV  t  j |  ƒ } t | d d  ƒ } | s+ | S|  j d d d ƒ } | d k rh t j t d ƒ | ƒ ‚ n  | d k rx | St  j } d  } xU t	 | ƒ D]G } | j
 | ƒ } | j | | d ƒ }	 | |	 k  r” |	 } | } q” q” W| | k  rR| d k r*t j t d	 ƒ t  j | t  j | | f ƒ ‚ n  |  j t d
 ƒ t  j | | f ƒ | S| S(   NRw   t   phasest   checksubrepost   followR¤   RO   s.   invalid phases.checksubrepos configuration: %si   s=   can't commit in %s phase conflicting %s from subrepository %ssA   warning: changes are committed in %s phase from subrepository %s
(   s   ignoreR®   s   abort(   R¬   t   newcommitphaset   getattrRQ   RP   R   R    R    t   publicRl   RF   t   phaset
   phasenamesR9   (
   RA   R?   t   commitphaseRw   t   checkt   maxphaset   maxsubRo   RF   t   subphase(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR¯   ]  s6    	
t   abstractsubrepoc           B   sé   e  Z d  „  Z e d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z	 e d „ Z
 d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d d „ Z d „  Z d „  Z d „  Z d „  Z RS(   c         C   s   t  S(   s‡   
        returns true if the repository has not changed since it was last
        cloned from or pushed to a given repository.
        (   R^   (   R#   R
   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt
   storeclean€  s    c         C   s
   t  ‚ d S(   sÖ   returns true if the dirstate of the subrepo is dirty or does not
        match current stored state. If ignoreupdate is true, only check
        whether the subrepo has uncommitted changes in its dirstate.
        N(   t   NotImplementedError(   R#   t   ignoreupdate(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRz   ‡  s    c         C   s
   t  ‚ d S(   sp   current working directory base state, disregarding .hgsubstate
        state and working directory modificationsN(   R»   (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt	   basestateŽ  s    c         C   s   t  S(   s7   check if path is a subrepository within this repository(   R^   (   R#   R
   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   checknested“  s    c         C   s
   t  ‚ d S(   s¨   commit the current changes to the subrepo with the given
        log message. Use given user and date if possible. Return the
        new state of the subrepo.
        N(   R»   (   R#   t   textt   usert   date(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   commit—  s    c         C   s   t  j S(   s?   returns phase of specified state in the subrepository.
        (   R¬   R±   (   R#   Rg   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR²   ž  s    c         C   s
   t  ‚ d S(   sT   remove the subrepo

        (should verify the dirstate is not dirty first)
        N(   R»   (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR~   £  s    c         C   s
   t  ‚ d S(   sT   run whatever commands are needed to put the subrepo into
        this state
        N(   R»   (   R#   Rg   R‚   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR"   ª  s    c         C   s
   t  ‚ d S(   s/   merge currently-saved state with the new state.N(   R»   (   R#   Rg   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR}   °  s    c         C   s
   t  ‚ d S(   sh   perform whatever action is analogous to 'hg push'

        This may be a no-op on some systems.
        N(   R»   (   R#   t   opts(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRž   ´  s    c         C   s   g  S(   N(    (   R#   RA   t   matcht   dryrunt   listsubrepost   prefixt   explicitonly(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   add»  s    c         K   s   d S(   Ni   (    (   R#   RA   RÄ   RÇ   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   cat¾  s    c         K   s   g  g  g  g  g  g  g  f S(   N(    (   R#   t   rev2RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   statusÁ  s    c         K   s   d  S(   N(    (   R#   RA   t   diffoptst   node2RÄ   RÇ   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   diffÄ  s    c         C   s   d S(   Ni   (    (   R#   RA   t   destRÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   outgoingÇ  s    c         C   s   d S(   Ni   (    (   R#   RA   RG   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   incomingÊ  s    c         C   s
   t  ‚ d S(   s   return filename iteratorN(   R»   (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   filesÍ  s    c         C   s
   t  ‚ d S(   s   return file dataN(   R»   (   R#   t   name(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   filedataÑ  s    c         C   s   d S(   s   return file flagsR   (    (   R#   RÔ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt	   fileflagsÕ  s    c         C   s\  | d  k	 r: g  |  j ƒ  D] } | | ƒ r | ^ q } n |  j ƒ  } t | ƒ } t |  ƒ } | j t d ƒ | d d t d ƒ d | ƒx± t | ƒ D]£ \ }	 }
 |  j |
 ƒ } d | k rÄ d pÇ d } d	 | k } | j t	 j
 j | |  j |
 ƒ | | |  j |
 ƒ ƒ | j t d ƒ | |	 d
 d t d ƒ d | ƒq— W| j t d ƒ | d  ƒ | S(   Ns   archiving (%s)i    t   unitRÓ   t   totalt   xií  i¤  Re   i   (   RQ   RÓ   R’   R+   t   progressR    RU   RÖ   t   addfileR	   R
   R`   R—   RÕ   (   R#   RA   t   archiverRÇ   RÄ   R;   RÓ   RØ   t   relpathRd   RÔ   t   flagst   modet   symlink(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   archiveÙ  s"    .c         C   s   d S(   sv   
        walk recursively through the directory tree, finding all files
        matched by the match function
        N(    (   R#   RÄ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR    í  s    c         C   s
   g  g  f S(   N(    (   R#   RA   RÄ   RÇ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   forgetô  s    c         O   s#   | j  d | d | d f ƒ g  S(   Ns)   %s: reverting %s subrepos is unsupported
i    i   (   R9   (   R#   RA   Rw   t   patsRÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   revert÷  s    	c         C   s   | S(   N(    (   R#   t   revid(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR|   ü  s    N(   R&   R'   Rº   R^   Rz   R½   R¾   RÂ   R²   R~   R"   R}   Rž   RÉ   RÊ   RÌ   RÏ   RÑ   RÒ   RÓ   RÕ   RÖ   RQ   Rá   R    Râ   Rä   R|   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR¹   ~  s0   																				t	   hgsubrepoc           B   s¦  e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z e	 d „  ƒ Z
 e	 d „  ƒ Z e	 d	 „  ƒ Z e	 d
 „  ƒ Z e	 d „  ƒ Z e	 d! d „ ƒ Z e	 e d „ ƒ Z d „  Z d „  Z e	 d „  ƒ Z e	 d „  ƒ Z e	 d „  ƒ Z d „  Z e	 e d „ ƒ Z e	 d „  ƒ Z e	 d „  ƒ Z e	 d „  ƒ Z e	 d „  ƒ Z e	 d „  ƒ Z d „  Z d „  Z  d „  Z! e	 d „  ƒ Z" e	 d „  ƒ Z# d „  Z$ d  „  Z% RS("   c   
      C   s  | |  _  | |  _ | j } | j | ƒ } t } t j j t j j | d ƒ ƒ sg t	 } t
 j | ƒ n  t j | j | d | ƒ|  _ xQ d	 g D]F \ } } | j j | | ƒ }	 |	 r |  j j j | | |	 d ƒ q q W|  j j j d d d d ƒ |  j | | d | ƒ d  S(
   Ns   .hgt   createRA   t   commitsubreposR   t   _usedassubrepot   Truei    (   s   uiRè   (   R—   t   _stateR]   t   wjoinR^   R	   R
   R   R`   Rê   R   t   makedirsRL   t
   repositoryt   baseuiRA   RP   t	   setconfigt	   _initrepo(
   R#   R?   R
   Rg   Rt   R‘   Rç   Ro   t   kt   v(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR!      s    			!#c         C   s2   |  j  j ƒ  } z |  j | ƒ SWd  | j ƒ  Xd  S(   N(   R]   t   lockt   _storecleant   release(   R#   R
   Rô   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRº     s    c         C   sž   t  } |  j | ƒ } y: x3 |  j | ƒ D]" } | | j ƒ  k r( t } Pq( q( WWn t k
 rh t } n X| rš y | j ƒ  t } Wqš t k
 r– qš Xn  | S(   N(   Rê   t   _calcstorehasht   _readstorehashcachet   nextR^   t   StopIteration(   R#   R
   t   cleant	   itercachet   filehash(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRõ     s     


c         c   s]   d } d t  | ƒ VxA | D]9 } t j j |  j j | ƒ ƒ } d | t | ƒ f Vq Wd S(   s˜   calculate a unique "store hash"

        This method is used to to detect when there are changes that may
        require a push to a given remote path.t	   bookmarkss   store/phaserootss   store/00changelog.is   # %s
s   %s = %s
N(   s	   bookmarkss   store/phaserootss   store/00changelog.i(   R   R	   R
   R   R]   R`   R   (   R#   R   t   filelistt   relnamet   absname(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR÷   ,  s
    c         C   s(   |  j  j t j j d d t | ƒ ƒ ƒ S(   s*   get a unique path for the store hash cachet   cachet	   storehash(   R]   R`   R	   R
   R   (   R#   R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _getstorehashcachepath8  s    c         C   sV   |  j  | ƒ } t j j | ƒ s% d St | d ƒ } z | j ƒ  } Wd | j ƒ  X| S(   s7   read the store hash cache for a given remote repositoryR   Rt   N(   R  R	   R
   R   R   t	   readlinesR   (   R#   R   t	   cachefileR   t	   pullstate(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRø   =  s    c         C   s±   |  j  | ƒ } |  j j ƒ  } z t |  j | ƒ ƒ } t j j | ƒ } t j j | ƒ sp t	 j
 | d t ƒn  t | d ƒ } z | j | ƒ Wd | j ƒ  XWd | j ƒ  Xd S(   sÄ   cache the current store hash

        Each remote repo requires its own store hash cache, because a subrepo
        store may be "clean" versus a given remote repo, but not versus another
        t
   notindexedt   wN(   R  R]   Rô   t   listR÷   R	   R
   R   R   R   Rí   Rê   R   t
   writelinesR   Rö   (   R#   R   R  Rô   R  t   cachedirR   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _cachestorehashI  s    c            sÙ   | ˆ j  _ | ˆ j  _ | rÕ d g ‰  ‡  ‡ f d †  } t ˆ j  d t ƒ} t ˆ j  t d t ƒ} | d | ƒ | | k r | d | ƒ n  ˆ j  j d d d t ƒ} z | j d	 j ˆ  ƒ ƒ Wd  | j	 ƒ  Xn  d  S(
   Ns   [paths]
c            s@   | r< ˆ  j  d |  | f ƒ ˆ j j j d |  | d ƒ n  d  S(   Ns   %s = %s
R™   R   (   t   appendR]   RA   Rð   (   t   keyt   value(   Rp   R#   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   addpathconfigf  s    RO   Rš   s   default-pushRŸ   R	  R¿   R   (
   R]   R   R›   R\   R^   Rê   t   openert   writeR`   R   (   R#   t
   parentrepoRG   Rç   R  t   defpatht   defpushpatht   fp(    (   Rp   R#   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRñ   ^  s    	c      	   C   s4   t  j | |  j | | | t j j | |  j ƒ | ƒ S(   N(   t   cmdutilRÉ   R]   R	   R
   R`   R—   (   R#   RA   RÄ   RÅ   RÆ   RÇ   RÈ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÉ   w  s    c         K   s9   |  j  d } |  j | } t j | |  j | | | |  S(   Ni   (   Rë   R]   R  RÊ   (   R#   RA   RÄ   RÇ   RÃ   Rc   R?   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÊ   |  s    c         K   s   yA |  j  d } |  j | } |  j | } |  j j | | |  SWnU t j k
 r˜ } |  j j j t d ƒ | t |  ƒ f ƒ g  g  g  g  g  g  g  f SXd  S(   Ni   s*   warning: error "%s" in subrepository "%s"
(	   Rë   R]   RÌ   R   t   RepoLookupErrorRA   R9   R    R+   (   R#   RË   RÃ   t   rev1t   ctx1t   ctx2t   inst(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÌ   ‚  s    c   	      K   s»   yu t  j |  j d ƒ } | d  k	 r7 t  j | ƒ } n  t j | |  j | | | | d t j | |  j	 ƒ d t
 | Wn? t j k
 r¶ } |  j j j t d ƒ | t |  ƒ f ƒ n Xd  S(   Ni   RÇ   RÆ   s*   warning: error "%s" in subrepository "%s"
(   t   nodet   binRë   RQ   R  t   diffordiffstatR]   R_   R`   R—   Rê   R   R  RA   R9   R    R+   (	   R#   RA   RÍ   RÎ   RÄ   RÇ   RÃ   t   node1R  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÏ   Ž  s    c         C   s°   |  j  |  j d ƒ t j |  | | | | ƒ } |  j d } |  j | } x` | j D]U } t | | ƒ }	 t j | | ƒ }
 | |	 j | | t	 j
 j | |  j ƒ |
 ƒ 7} qS W| S(   NRL   i   (   s   hg(   t   _getRë   R¹   Rá   R]   Rw   R   t   matchmodt   narrowmatcherR	   R
   R`   R—   (   R#   RA   RÜ   RÇ   RÄ   RØ   Rc   R?   t   subpathRo   t   submatch(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRá   ž  s    	)c         C   s^   |  j  d } | d k r$ | r$ t S|  j d  } | | j ƒ  j ƒ  k rT | rT t S| j ƒ  S(   Ni   R   (   Rë   Rê   R]   RQ   Rv   t   hexRz   (   R#   R¼   Rt   R	  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRz   «  s    c         C   s   |  j  d j ƒ  S(   Nt   .(   R]   R'  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR½   ¶  s    c         C   s   |  j  j |  j  j | ƒ ƒ S(   N(   R]   t   _checknestedRì   (   R#   R
   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR¾   ¹  s    c         C   sy   |  j  t ƒ s  |  j d j ƒ  S|  j j j d t |  ƒ ƒ |  j j | | | ƒ } | sl |  j d j ƒ  St j | ƒ S(   NR(  s   committing subrepo %s
(	   Rz   Rê   R]   R'  RA   Rr   R+   RÂ   R  (   R#   R¿   RÀ   RÁ   t   n(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÂ   ¼  s    c         C   s   |  j  | j ƒ  S(   N(   R]   R²   (   R#   Rg   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR²   È  s    c         C   s@   |  j  j j t d ƒ t |  ƒ ƒ t j |  j  t j t	 ƒ d  S(   Ns   removing subrepo %s
(
   R]   RA   t   noteR    R+   RL   Rû   R  t   nullidR^   (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR~   Ì  s    #c         C   s°  | \ } } } | |  j  j ƒ  k r( t S| |  j  _ t |  j  ƒ } t j |  j  i  | ƒ } t |  j  ƒ d k r |  j  j j	 t
 d ƒ t |  ƒ | f ƒ |  j  j } t j |  j  j ƒ t j |  j  j j i  | |  j  j d t ƒ\ } } | j ƒ  |  _  |  j | | d t ƒ|  j | ƒ nŒ |  j  j j	 t
 d ƒ t |  ƒ | f ƒ |  j | ƒ }	 | j d ƒ }
 |  j  j | ƒ t j |  j  j |  j  |
 | ƒ |	 r¬|  j | ƒ n  t S(   Ni    s   cloning subrepo %s from %s
t   updateRç   s   pulling subrepo %s from %s
Rþ   (   R]   t
   unfilteredRê   R›   R\   RL   t   peerR’   RA   RÌ   R    R+   R   t   shutilt   rmtreeR
   t   cloneRï   R‘   R^   RŒ   Rñ   R  Rº   t   listkeyst   pullRþ   t   updatefromremote(   R#   Rg   RG   Rf   Rh   t   srcurlt   otherR  t   clonedt   cleansubt   remotebookmarks(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR"  Ó  s6    
c   
      C   s³   |  j  | ƒ } | \ } } } |  j } | j j d |  j ƒ | rœ | j ƒ  } | | }	 |	 j ƒ  rœ | j j t d ƒ | d d !|  j f ƒ | } qœ n  t	 j
 | | | ƒ d  S(   Ns   getting subrepo %s
s$   revision %s in subrepo %s is hidden
i    i   (   R"  R]   RA   Rr   R—   R.  t   hiddenR9   R    RL   t
   updaterepo(
   R#   Rg   R‚   t   inrepoRG   Rf   Rh   Rn   t   urepoR?   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR"   ò  s    	
		c            sÀ   ˆ j  ˆ ƒ ˆ j d ‰ ˆ j ˆ d ‰ ˆ j ˆ ƒ ‰  ‡  ‡ ‡ ‡ ‡ f d †  } ˆ j d  } ˆ j ƒ  rµ ˆ  ˆ k r« t ˆ j j ˆ | j ƒ  ˆ ˆ ƒ r² | ƒ  q² q¼ | ƒ  n | ƒ  d  S(   NR(  i   c              sÅ   ˆ  ˆ k r[ ˆ j  ƒ  ˆ j  ƒ  k r[ ˆ j j j d t ˆ ƒ ƒ t j ˆ j ˆ d ƒ nf ˆ  ˆ k r‡ ˆ j j j d t ˆ ƒ ƒ n: ˆ j j j d t ˆ ƒ ƒ t j ˆ j ˆ d d t ƒd  S(   Ns   updating subrepo %s
i   s   skipping subrepo %s
s   merging subrepo %s
t   remind(	   t   branchR]   RA   Rr   R+   RL   R-  R}   R^   (    (   t   anct   curt   dstR#   Rg   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt	   mergefunc	  s    $ (   R"  R]   t   ancestorRQ   Rz   RŽ   RA   (   R#   Rg   RD  R   (    (   RA  RB  RC  R#   Rg   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR}     s    
$
c         C   sG  | j  d ƒ } | j  d ƒ } | j  d ƒ } |  j d } | j } x6 t | ƒ D]( } | j | ƒ j | ƒ d k rP t SqP Wt |  j t ƒ } | sÓ |  j	 | ƒ rÓ |  j j
 j t d ƒ t |  ƒ | f ƒ d  Sn  |  j j
 j t d ƒ t |  ƒ | f ƒ t j |  j i | d 6| ƒ }	 |  j j |	 | d | ƒ}
 |  j | ƒ |
 S(	   Nt   forcet
   new_brancht   sshR   i    s4   no changes made to subrepo %s since last push to %s
s   pushing subrepo %s to %s
t	   newbranch(   R"   R]   Rw   Rl   RF   Rž   R^   R\   Rê   Rº   RA   RÌ   R    R+   RQ   RL   R/  R  (   R#   RÃ   RF  RI  RH  t   ct   subsRo   t   dsturlR7  R0   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRž     s*    		c         C   s%   t  j | |  j t |  j t ƒ | ƒ S(   N(   RL   RÑ   R]   R\   Rê   (   R#   RA   RÐ   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÑ   :  s    c         C   s%   t  j | |  j t |  j t ƒ | ƒ S(   N(   RL   RÒ   R]   R\   R^   (   R#   RA   RG   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÒ   >  s    c         C   s$   |  j  d } |  j | } | j ƒ  S(   Ni   (   Rë   R]   t   manifest(   R#   Rc   R?   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÓ   B  s    c         C   s"   |  j  d } |  j | | j ƒ  S(   Ni   (   Rë   R]   R   (   R#   RÔ   Rc   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÕ   H  s    c         C   s'   |  j  d } |  j | } | j | ƒ S(   Ni   (   Rë   R]   RÞ   (   R#   RÔ   Rc   R?   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÖ   L  s    c         C   s   |  j  d  } | j | ƒ S(   N(   R]   RQ   R    (   R#   RÄ   R?   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR    Q  s    c         C   s.   t  j | |  j | t j j | |  j ƒ t ƒ S(   N(   R  Râ   R]   R	   R
   R`   R—   Rê   (   R#   RA   RÄ   RÇ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRâ   U  s    c         O   sœ   | j  t d ƒ | d ƒ | j d ƒ s… | j ƒ  } d  | d <| d | d <g  } | j d ƒ so d g } n  |  j | | | Ž n  |  j | d	 t ƒd  S(
   Ns   reverting subrepo %s
i    t	   no_backupRÁ   i   Rc   t   alls   set:modified()R‚   (   RÌ   R    R"   t   copyRQ   t
   filerevertRê   (   R#   RA   Rw   Rã   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRä   Z  s    
c         O   sg   |  j  | d } |  j  j j ƒ  } | j d ƒ r> d g } n g  } t j | |  j  | | | | Ž d  S(   NRc   RO  s   set:modified()(   R]   t   dirstatet   parentsR"   R  Rä   (   R#   RA   Rã   RÃ   R?   RS  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRQ  r  s    c         C   s   | d  S(   Ni   (    (   R#   Rå   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR|   {  s    N(&   R&   R'   R!   Rº   Rõ   R÷   R  Rø   R  R5   Rñ   RÉ   RÊ   RÌ   RÏ   RQ   Rá   R^   Rz   R½   R¾   RÂ   R²   R~   R"  R"   R}   Rž   RÑ   RÒ   RÓ   RÕ   RÖ   R    Râ   Rä   RQ  R|   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRæ   ÿ  sH   							
								t
   svnsubrepoc           B   s¿   e  Z d  „  Z d e d „ Z e d „  ƒ Z d „  Z d „  Z d „  Z	 e d „ Z
 d „  Z e d	 „  ƒ Z e d
 „  ƒ Z e e d „ ƒ Z e d „  ƒ Z d „  Z e d „  ƒ Z d „  Z RS(   c         C   sh   | |  _  | |  _ | |  _ | j j |  _ t j d ƒ |  _ |  j sd t j	 t
 d ƒ |  j  ƒ ‚ n  d  S(   Nt   svns+   'svn' executable not found for subrepo '%s'(   R—   Rë   t   _ctxR]   RA   t   _uiR   t   findexet   _exeR    R    (   R#   R?   R
   Rg   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR!     s    				R   c         C   s•  |  j  g } i  } |  j j ƒ  sQ t j | d <| d d k rQ | j d ƒ qQ n  | j | ƒ | d  k	 rž t j	 j
 |  j j j |  j | ƒ } | j | ƒ n  t t j ƒ } | j d ƒ } | rÖ | | d <| d =n  d	 | d
 <t j | d d d t j d t j d t j d t d | | }	 |	 j ƒ  \ }
 } | j ƒ  } | s‹|	 j rkt j | pbd |	 j ƒ ‚ n  | r‹|  j j | d ƒ q‹n  |
 | f S(   Nt   stdini    R-  t   checkoutRÂ   s   --non-interactivet   LC_ALLt   LANGt   Ct   LC_MESSAGESt   bufsizeiÿÿÿÿt	   close_fdst   stdoutt   stderrt   universal_newlinest   envs   exited with code %ds   
(   s   updates   checkouts   commit(   RY  RW  t   interactivet
   subprocesst   PIPER  t   extendRQ   R	   R
   R`   RV  R]   t   origrootR—   t   dictt   environR"   t   PopenR   t   closefdsRê   t   communicateRa   t
   returncodeR    R9   (   R#   t   commandsR   t   failokt   cmdt   extrakwR
   Re  t   lc_allR@   Rb  Rc  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _svncommand‰  s6    $


	c         C   sy   |  j  d d g d d  ƒ\ } } t j d | ƒ } | sQ t j t d ƒ ƒ ‚ n  t | j d ƒ ƒ t | j d ƒ ƒ f S(   Ns	   --versions   --quietR   s   ^(\d+)\.(\d+)s    cannot retrieve svn tool versioni   i   (	   Rv  RQ   RE   t   searchR   R    R    t   intt   group(   R#   t   outputR>   t   m(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _svnversion­  s
    !c         C   s¸   |  j  d d g ƒ \ } } t j j j | ƒ } | j d ƒ } d \ } } | r® t | d j d ƒ ƒ pm d } | d j d ƒ } | r® t | d j d ƒ ƒ p¥ d } q® n  | | f S(	   Nt   infos   --xmlt   entryt   0i    Rf   RÂ   (   R  R  (   Rv  t   xmlt   domt   minidomt   parseStringt   getElementsByTagNameR,   t   getAttribute(   R#   Rz  R>   t   doct   entriest   lastrevRc   t   commits(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _wcrevsµ  s    %c         C   s   |  j  ƒ  d S(   Ni    (   RŠ  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _wcrevÄ  s    c         C   s~  |  j  d d g ƒ \ } } g  g  g  } } } t j j j | ƒ } xÇ | j d ƒ D]¶ } | j d ƒ } | su qT n  | d j d ƒ }	 | d j d ƒ }
 | j d ƒ } |	 d	 k rÆ | j | ƒ n |	 d
 k râ | j | ƒ n  |	 d k sú |
 d k rT | j | ƒ qT qT WxT | D]L } xC | D]; } | | k sJ| j | t	 j
 ƒ r"t t t | ƒ f Sq"WqWt | ƒ t t | ƒ f S(   sý   Return (changes, extchanges, missing) where changes is True
        if the working directory was changed, extchanges is
        True if any of these changes concern an external entry and missing
        is True if any change is a missing entry.
        RÌ   s   --xmlR~  s	   wc-statusi    t   itemt   propsR
   t   externalt   missingR   t   normalt   unversionedt   none(   R   R  R‘  RŽ  (   R   R’  R  (   Rv  R€  R  R‚  Rƒ  R„  R…  R  RZ   R	   t   sepRê   t   boolR^   (   R#   Rz  R>   t	   externalst   changesR  R†  RK   Ro   RŒ  R  R
   t   ext(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt
   _wcchangedÇ  s,    "c         C   s:   |  j  ƒ  d s6 |  j d |  j ƒ  k s/ | r6 t Sn  t S(   Ni    i   (   R˜  Rë   RŠ  R^   Rê   (   R#   R¼   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRz   ä  s    c         C   sh   |  j  ƒ  \ } } | | k rd y, |  j d d |  j d | f g ƒ | SWqd t j k
 r` qd Xn  | S(   NR
  s   %s@%si    (   RŠ  Rv  Rë   R   R    (   R#   Rˆ  Rc   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR½   ê  s    $c   
      C   s!  |  j  ƒ  \ } } } | s% |  j ƒ  S| rC t j t d ƒ ƒ ‚ n  | ra t j t d ƒ ƒ ‚ n  |  j d d | g ƒ \ } } |  j j | ƒ t j	 d | ƒ }	 |	 sç | j
 ƒ  sË t j t d ƒ ƒ ‚ n  t j | j ƒ  d ƒ ‚ n  |	 j ƒ  d }	 |  j j |  j d	 d
 |	 g ƒ d ƒ |	 S(   Ns   cannot commit svn externalss!   cannot commit missing svn entriesRÂ   s   -ms   Committed revision ([0-9]+).s   failed to commit svn changesiÿÿÿÿi    R-  s   -r(   R˜  R½   R   R    R    Rv  RW  RÌ   RE   Rw  Ra   RV   t   groups(
   R#   R¿   RÀ   RÁ   t   changedt
   extchangedR  t
   commitinfoR>   t   newrev(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÂ   ø  s"    
&c         C   s³   |  j  ƒ  r- |  j j t d ƒ |  j ƒ d  S|  j j t d ƒ |  j ƒ d „  } |  j j j |  j ƒ } t	 j
 | d | ƒy t j t j j | ƒ ƒ Wn t k
 r® n Xd  S(   Ns-   not removing repo %s because it has changes.
s   removing subrepo %s
c         S   st   |  t  j k	 r ‚  n  t  j | ƒ } | j t j @d k r@ ‚  n  t  j | t j | j ƒ t j Bƒ t  j | ƒ d  S(   Ni    (   R	   R~   t   statt   st_modet   S_IWRITEt   chmodt   S_IMODE(   t   functionR
   t   excinfoRo   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   onerror  s    #R¥  (   Rz   RW  R9   R    R—   R+  RV  R]   Rì   R0  R1  R	   t
   removedirsR
   R   t   OSError(   R#   R¥  R
   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR~     s    	
c         C   s4  | r |  j  d d g ƒ n  d g } |  j d k rD | j d ƒ n  | j d | d | d f ƒ |  j  | d	 t ƒ\ } } t |  j |  j j j |  j	 ƒ d
 ƒ t
 j d | ƒ s d | k rþ |  j ƒ  d  t t f k rþ |  j ƒ  |  j | d t ƒd  St j | p| j ƒ  d ƒ ‚ n  |  j j | ƒ d  S(   NRä   s   --recursiveR[  i   i   s   --forces   %s@%si    Rr  s   .svns   Checked out revision [0-9]+.s-   is already a working copy for a different URLi   R‚   iÿÿÿÿ(   i   i   (   Rv  R|  R  Rê   R¨   RW  RV  R]   Rì   R—   RE   Rw  R˜  R^   R~   R"   R   R    RV   RÌ   (   R#   Rg   R‚   R$   RÌ   R>   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR"   -  s     	%
"c         C   s€   |  j  d } | d } |  j ƒ  } | | k r| | | k pH |  j ƒ  d } t |  j |  | | | ƒ r| |  j | t ƒ q| n  d  S(   Ni   i    (   Rë   R‹  R˜  RŽ   RW  R"   R^   (   R#   Rg   t   oldt   newt   wcrevRz   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR}   C  s    
c         C   s   t  S(   N(   Rê   (   R#   RÃ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRž   M  s    c         C   s»   |  j  d d d g ƒ d } t j j j | ƒ } g  } x} | j d ƒ D]l } t | j d ƒ ƒ } | d k rt qG n  d j d	 „  | j d
 ƒ d j	 Dƒ ƒ } | j
 | j d ƒ ƒ qG W| S(   NR
  s   --recursives   --xmli    R~  Rh   t   fileR   c         s   s*   |  ]  } | j  | j k r | j Vq d  S(   N(   t   nodeTypet	   TEXT_NODER   (   t   .0RJ  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pys	   <genexpr>Z  s    RÔ   s   utf-8(   Rv  R€  R  R‚  Rƒ  R„  R,   R…  R`   t
   childNodesR  RD   (   R#   Rz  R†  R™   RK   Rh   RÔ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÓ   Q  s    c         C   s   |  j  d g | ƒ d S(   NRÊ   i    (   Rv  (   R#   RÔ   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÕ   `  s    (   R&   R'   R!   R^   Rv  t   propertycacheR|  RŠ  R‹  R˜  Rz   R½   R5   RÂ   R~   R"   R}   Rž   RÓ   RÕ   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRT  ~  s    	
$				
	t
   gitsubrepoc           B   sR  e  Z d  „  Z d „  Z e d „  ƒ Z d e d „ Z d e d „ Z	 d e d d „ Z
 d „  Z d „  Z d „  Z d	 „  Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z e e d „ ƒ Z d „  Z e e d „ ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z e d „  ƒ Z d d „ Z e d „  ƒ Z  d „  Z! RS(   c         C   sz   | |  _  | |  _ | |  _ t j j t | j ƒ | ƒ |  _ | j j	 | ƒ |  _
 | j |  _ | j j |  _ |  j ƒ  d  S(   N(   Rë   RV  R—   R	   R
   R`   R•   R]   R–   Rì   t   _abspathR   RA   RW  t
   _ensuregit(   R#   R?   R
   Rg   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR!   e  s    			!c         C   s  y% d |  _  |  j d g ƒ \ } } WnX t k
 r } | j d k sU t j d k r[ ‚  n  d |  _  |  j d g ƒ \ } } n X|  j | ƒ } | d k r´ |  j j t	 d ƒ ƒ nI | d k rØ t
 j t	 d	 ƒ ƒ ‚ n% | d
 k rý |  j j t	 d ƒ ƒ n  d  S(   Nt   gits	   --versioni   t   nts   git.cmdt   unknowns   cannot retrieve git version
RO   s,   git subrepo requires at least 1.6.0 or latert   warnings-   git subrepo requires at least 1.6.0 or later
(   t   _gitexecutablet	   _gitnodirR§  R7   R	   RÔ   t   _checkversionRW  R9   R    R   R    (   R#   t   outR>   RK   t   versionstatus(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR³  o  s    		c         C   sj   t  j d |  ƒ } | s d St | j d ƒ ƒ t | j d ƒ ƒ f } | d
 k  rV d S| d k  rf d Sd	 S(   s‘  ensure git version is new enough

        >>> _checkversion = gitsubrepo._checkversion
        >>> _checkversion('git version 1.6.0')
        'ok'
        >>> _checkversion('git version 1.8.5')
        'ok'
        >>> _checkversion('git version 1.4.0')
        'abort'
        >>> _checkversion('git version 1.5.0')
        'warning'
        >>> _checkversion('git version 1.9-rc0')
        'ok'
        >>> _checkversion('git version 1.9.0.265.g81cdec2')
        'ok'
        >>> _checkversion('git version 1.9.0.GIT')
        'ok'
        >>> _checkversion('git version 12345')
        'unknown'
        >>> _checkversion('no')
        'unknown'
        s   ^git version (\d+)\.(\d+)R¶  i   i   i   RO   i   R·  t   ok(   i   i   (   i   i   (   RE   Rw  Rx  Ry  (   R»  R{  t   version(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRº  €  s    *c         C   s   |  j  | d | d | ƒd S(   NRe  t   streami    (   t   _gitdir(   R#   Rq  Re  R¿  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gitcommand¥  s    c         C   s"   |  j  | d | d | d |  j ƒS(   NRe  R¿  t   cwd(   R¹  R²  (   R#   Rq  Re  R¿  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÀ  ¨  s    c   	      C   sl  |  j  j d |  j d j | ƒ f ƒ | d k rD t j j ƒ  } n  d | k r] d | d <n  d } |  j  j r„ t	 t j
 d ƒ } n  t j |  j g | d d d | d	 | d
 t j d t j d | ƒ} | rÚ | j d f S| j j ƒ  j ƒ  } | j ƒ  | j d k r_| j d k r_| d } | d k r:| | j f St j d | | j |  j f ƒ ‚ n  | | j f S(   sœ   Calls the git command

        The methods tries to call the git command. versions prior to 1.6.0
        are not supported and very probably fail.
        s   %s: git %s
R)   t   GIT_ALLOW_PROTOCOLs   file:git:http:https:sshR	  R`  iÿÿÿÿRÂ  Re  Ra  Rb  Rc  i    i   s   cat-files   symbolic-refs   git %s error %d in %sN(   s   cat-files   symbolic-ref(   RW  Rr   R–   R`   RQ   R	   Rl  RP  t   quietR   t   devnullRg  Rm  R¸  R   Rn  Rh  Rb  R   Ra   t   waitRp  R    (	   R#   Rq  Re  R¿  RÂ  t   errpipeR@   t   retdatat   command(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR¹  ¬  s,    &

	c         C   s#   t  j j t  j j |  j d ƒ ƒ S(   Ns   .git(   R	   R
   R   R`   R²  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gitmissingÒ  s    c         C   s   |  j  d d g ƒ S(   Ns	   rev-parset   HEAD(   RÁ  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt	   _gitstateÕ  s    c         C   s1   |  j  d d d g ƒ \ } } | r- d  } n  | S(   Ns   symbolic-refRË  s   --quiet(   RÀ  RQ   (   R#   t   currentR>   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gitcurrentbranchØ  s    	c         C   sO   |  j  d d d | g ƒ } | j d ƒ d } | j d ƒ t d ƒ } | | S(   NR   t   shows   -ns   
i   s   URL: (   RÁ  RX   t   indexR’   (   R#   R   R»  t   lineRd   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt
   _gitremoteÞ  s    c         C   s(   |  j  d d | g ƒ \ } } | d k S(   Ns   cat-files   -ei    (   RÀ  (   R#   Rf   R»  t   code(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _githavelocallyä  s    c         C   s"   |  j  d | | g ƒ } | | k S(   Ns
   merge-base(   RÁ  (   R#   t   r1t   r2t   base(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gitisancestorè  s    c         C   s   |  j  d d d g ƒ d k S(   NRP   s   --bools	   core.baret   true(   RÁ  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt
   _gitisbareì  s    c         C   s   |  j  d d d g ƒ d S(   s    This must be run before git diff-index.
        diff-index only looks at changes to file stat;
        this command looks at file contents and updates the stat.s   update-indexs   -qs	   --refreshN(   RÁ  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gitupdatestatï  s    c         C   sÊ   i  } i  } |  j  d d d g ƒ } x™ | j d ƒ D]ˆ } | j d ƒ \ } } | j d ƒ ru | j d ƒ ru q4 n  | j d ƒ r™ | j d ƒ r™ q4 n  | | | <| j | g  ƒ j | ƒ q4 W| | f S(	   sc   returns 2 things:
        a map from git branch to revision
        a map from revision to branchess   for-each-refs   --formats   %(objectname) %(refname)s   
R)   s   refs/heads/s   refs/remotes/s   /HEAD(   RÁ  RX   RZ   t   endswitht
   setdefaultR  (   R#   t
   branch2revt
   rev2branchR»  RÑ  Rf   t   ref(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gitbranchmapõ  s    
c         C   s¥   i  } x˜ | D] } | j  d ƒ r( q n  | j d d ƒ d } |  j d d | g ƒ } | r |  j d d | g ƒ } | | d | | j d d ƒ d f <q q W| S(   s4   return map of remote branch to local tracking branchs   refs/remotes/t   /i   RP   s   branch.%s.remotes   branch.%s.merges   refs/remotes/%s/%s(   RZ   RX   RÁ  (   R#   t   branchest   trackingt   bt   bnameR   Rà  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _gittracking	  s    +c         C   sQ   d | k r> | j  d ƒ } | d k r> d | |  k r> | Sn  | |  _ t |  ƒ S(   Ns   ://t   :iÿÿÿÿRâ  (   t   findR›   R\   (   R#   RG   t   colon(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR\     s    	c         C   sá   |  j  ƒ  rZ |  j | ƒ } |  j j t d ƒ |  j | f ƒ |  j d | |  j g ƒ n  |  j | ƒ rm d  S|  j j t d ƒ |  j |  j	 d ƒ f ƒ |  j
 d g ƒ |  j | ƒ sÝ t j t d ƒ | |  j f ƒ ‚ n  d  S(   Ns   cloning subrepo %s from %s
R2  s   pulling subrepo %s from %s
t   origint   fetchs)   revision %s does not exist in subrepo %s
(   RÊ  R\   RW  RÌ   R    R–   R¹  R²  RÔ  RÒ  RÁ  R   R    (   R#   RG   Rf   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   _fetch!  s    c         C   sƒ   |  j  ƒ  r |  j d d k S|  j ƒ  r- t S| rQ |  j d |  j ƒ  k rQ t S|  j ƒ  |  j d d d g ƒ \ } } | d k S(   Ni   R   s
   diff-indexs   --quietRË  (   RÊ  Rë   RÚ  Rê   RÌ  RÛ  RÀ  (   R#   R¼   R»  RÓ  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRz   1  s     
c         C   s
   |  j  ƒ  S(   N(   RÌ  (   R#   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR½   ?  s    c            sœ  | \ } ‰ } ˆ s# ˆ j  ƒ  d  Sˆ j | ˆ ƒ ˆ j ƒ  r„ ˆ j d d d g ƒ ˆ j ƒ  ˆ k rÌ ˆ j d d d g ƒ d  SnH ˆ j ƒ  ˆ k rÌ ˆ rÈ ˆ j d d g ƒ ˆ j d d d g ƒ n  d  Sˆ j ƒ  \ } } ‡ ‡ f d †  ‰  ‡  ‡ ‡ f d †  } ˆ | k r| ƒ  d  S| ˆ } d  }	 xK | D]C }
 |
 d	 k rVˆ  d	 g ƒ d  S|	 r3|
 j d
 ƒ r3|
 }	 q3q3W|	 r‘ˆ  |	 g ƒ d  Sˆ j | j	 ƒ  ƒ } | d } | | k ræx' | D] }
 |
 | k rÃ|
 } PqÃqÃWn  | | k r| j
 d d ƒ d } ˆ  d | | g ƒ nz ˆ j | | | | ƒ r‘| | ˆ j ƒ  k rbˆ  | | g ƒ n  ˆ j d d | g ƒ t ˆ j ˆ j d ƒ n | ƒ  d  S(   NRP   s	   core.baret   falset   resets   --hardRË  c            s]   d g } ˆ  r2 ˆ j  d d g ƒ | j d ƒ n  ˆ j  | |  ƒ t ˆ j ˆ j d ƒ d  S(   NR[  Rï  RË  s   -fs   .git(   RÁ  R  R¨   RW  R²  (   R$   Rs  (   R‚   R#   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR[  Y  s    	c              sG   ˆ j  j t d ƒ ˆ j ƒ ˆ j  j t d ƒ ƒ ˆ  d ˆ g ƒ d  S(   Ns)   checking out detached HEAD in subrepo %s
s5   check out a git branch if you intend to make changes
s   -q(   RW  R9   R    R–   (    (   R[  Rf   R#   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   rawcheckoutd  s    s   refs/heads/masters   refs/remotes/i    Râ  i   s   -bR}   s   --ffs   .git(   R~   Rí  RÚ  RÁ  RÌ  Rá  RQ   RZ   Rç  t   keysRX   RØ  RÎ  R¨   RW  R²  (   R#   Rg   R‚   RG   Rh   RÞ  Rß  Rð  Rã  t   firstlocalbranchRå  Rä  R   RŒ   (    (   R[  R‚   Rf   R#   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR"   B  s`    


c         C   s¡   |  j  ƒ  r+ t j t d ƒ |  j ƒ ‚ n  d d d | g } t j j ƒ  } | re | d | g 7} n  | r„ t j | d ƒ | d <n  |  j	 | d | ƒ|  j
 ƒ  S(	   Ns   subrepo %s is missingRÂ   s   -as   -ms   --authors   %Y-%m-%dT%H:%M:%S %1%2t   GIT_AUTHOR_DATERe  (   RÊ  R   R    R    R–   R	   Rl  RP  t   datestrRÁ  RÌ  (   R#   R¿   RÀ   RÁ   Rs  Re  (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÂ   ˜  s    	c            s  ˆ \ } ‰ } ˆ j  | ˆ ƒ ˆ j d ˆ ˆ j d g ƒ ‰  ˆ j ƒ  ˆ j d d d g ƒ \ } } ‡  ‡ ‡ ‡ f d †  } ˆ j ƒ  rû ˆ j ƒ  ˆ k rˆ j ƒ  ˆ j d k p¾ | d k } t ˆ j ˆ | ˆ j d d  ˆ d  ƒ rø | ƒ  qø qn | ƒ  d  S(	   Ns
   merge-basei   s
   diff-indexs   --quietRË  c              sb   ˆ  ˆ k r ˆ j  ˆ ƒ n, ˆ  ˆ j d k rH ˆ j d d ˆ g ƒ n  t ˆ j ˆ j d ƒ d  S(   Ni   R}   s   --no-commits   .git(   R"   Rë   RÁ  R¨   RW  R²  (    (   R×  Rf   R#   Rg   (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRD  ²  s
    i    i   (	   Rí  RÁ  Rë   RÛ  RÀ  Rz   RÌ  RŽ   RW  (   R#   Rg   RG   Rh   R»  RÓ  RD  Rz   (    (   R×  Rf   R#   Rg   s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR}   ª  s    
%c   
      C   så  | j  d ƒ } |  j d s  t S|  j ƒ  rK t j t d ƒ |  j ƒ ‚ n  |  j ƒ  \ } } |  j d | k r¢ x/ | |  j d D] } | j	 d ƒ r‚ t Sq‚ Wn  xI | j
 ƒ  D]; \ } } | j	 d ƒ r¯ |  j |  j d | ƒ rê t Sq¯ q¯ Wd g } | r| j d ƒ n  |  j ƒ  } | r³|  j |  j d | ƒ sY|  j j t d ƒ |  j ƒ t S|  j j t d ƒ | j d	 d
 ƒ d
 |  j f ƒ |  j | d | g ƒ }	 |	 d d k S|  j j t d ƒ |  j |  j d f ƒ t Sd  S(   NRF  i   s   subrepo %s is missings   refs/remotes/origin/Rž   s   --forces/   unrelated git branch checked out in subrepo %s
s    pushing branch %s of subrepo %s
Râ  i   Rë  i    s<   no branch checked out in subrepo %s
cannot push revision %s
(   R"   Rë   Rê   RÊ  R   R    R    R–   Rá  RZ   Rx   RØ  R  RÎ  RW  R9   R^   RÌ   RX   RÀ  (
   R#   RÃ   RF  RÞ  Rß  Rå  Rf   Rs  RÍ  t   ret(    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRž   Â  s<    	!c         C   sý   |  j  ƒ  r d  S|  j ƒ  r= |  j j t d ƒ |  j ƒ d  S|  j j t d ƒ |  j ƒ |  j d d d g ƒ x† t j	 |  j
 ƒ D]r } | d k r› qƒ n  t j j |  j
 | ƒ } t j j | ƒ rè t j j | ƒ rè t j | ƒ qƒ t j | ƒ qƒ Wd  S(   Ns-   not removing repo %s because it has changes.
s   removing subrepo %s
RP   s	   core.bareRÙ  s   .git(   RÊ  Rz   RW  R9   R    R–   R+  RÁ  R	   t   listdirR²  R
   R`   t   isdirt   islinkR0  R1  R~   (   R#   R;   R
   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR~   ê  s    %c         C   s•  d } |  j  \ } } | s | S|  j | | ƒ |  j d | g d t ƒ} t j d | d d ƒ }	 t |  ƒ }
 | j t d ƒ |
 d d t d	 ƒ ƒxà t	 |	 ƒ D]Ò \ } } | j
 ƒ  r¿ q¡ n  | rÛ | | j ƒ rÛ q¡ n  | j ƒ  ró | j } n |	 j | ƒ j ƒ  } | j t j j | |  j | j ƒ | j | j ƒ  | ƒ | d
 7} | j t d ƒ |
 | d
 d t d	 ƒ ƒq¡ W| j t d ƒ |
 d  ƒ | S(   Ni    Rá   R¿  t   fileobjRß   s   r|s   archiving (%s)R×   RÓ   i   (   Rë   Rí  RÁ  Rê   t   tarfileR   R+   RÚ   R    RU   R÷  RÔ   t   issymt   linknamet   extractfileR   RÛ   R	   R
   R`   R—   Rß   RQ   (   R#   RA   RÜ   RÇ   RÄ   RØ   RG   Rf   t	   tarstreamt   tarRÝ   Rd   R}  R   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRá   ÿ  s0    &!
c         K   sa  |  j  d } |  j ƒ  s  | r9 g  g  g  g  g  g  g  f Sg  g  g  } } } |  j ƒ  | ro d | | g } n d | g } |  j | ƒ } x© | j d ƒ D]˜ }	 |	 j d ƒ }
 |
 d k rÁ qš n  |	 |
 d |	 |
 d } } | d k rú | j | ƒ qš | d k r| j | ƒ qš | d	 k rš | j | ƒ qš qš Wg  } } } } | | | | | | | f S(
   Ni   s	   diff-trees
   diff-indexs   
s   	iÿÿÿÿt   Mt   At   D(   Rë   RÊ  RÛ  RÁ  RX   Ré  R  (   R#   RË   RÃ   R  t   modifiedt   addedt   removedRÉ  R»  RÑ  t   tabRÌ   R;   t   deletedR¶  t   ignoredRû   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyRÌ     s,    
c         C   s   | d  S(   Ni   (    (   R#   Rå   (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR|   ;  s    N("   R&   R'   R!   R³  t   staticmethodRº  RQ   R^   RÁ  RÀ  R¹  RÊ  RÌ  RÎ  RÒ  RÔ  RØ  RÚ  RÛ  Rá  Rç  R\   Rí  R5   Rz   R½   R"   RÂ   R}   Rž   R~   Rá   RÌ   R|   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyR±  d  s<   	
	%&														U( RL   RU  R´  (3   R7   R	   RE   R0  R_   R-   t   xml.dom.minidomR€  Rž  Rg  Rú  t   i18nR    RP   R   R  R   R  Rþ   RÄ   R#  R¬   R“   RQ   RL   R°  Ry   R   R   R   R    R   R5   Rg   Rq   R‹   RŽ   R•   R+   R^   Rê   R\   R¨   R   R¯   t   objectR¹   Ræ   RT  R±  Rª   (    (    (    s5   /usr/lib/python2.7/dist-packages/mercurial/subrepo.pyt   <module>   sD   H$T		
		
		Z		e						!ÿ €æÿ Û                                                                                                                                                                                                                                                     usr/lib/python2.7/dist-packages/mercurial/tagmerge.py                                               0100644 0000000 0000000 00000026354 12413056314 021254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # tagmerge.py - merge .hgtags files
#
# Copyright 2014 Angel Ezquerra <angel.ezquerra@gmail.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

# This module implements an automatic merge algorithm for mercurial's tag files
#
# The tagmerge algorithm implemented in this module is able to resolve most
# merge conflicts that currently would trigger a .hgtags merge conflict. The
# only case that it does not (and cannot) handle is that in which two tags point
# to different revisions on each merge parent _and_ their corresponding tag
# histories have the same rank (i.e. the same length). In all other cases the
# merge algorithm will choose the revision belonging to the parent with the
# highest ranked tag history. The merged tag history is the combination of both
# tag histories (special care is taken to try to combine common tag histories
# where possible).
#
# In addition to actually merging the tags from two parents, taking into
# account the base, the algorithm also tries to minimize the difference
# between the merged tag file and the first parent's tag file (i.e. it tries to
# make the merged tag order as as similar as possible to the first parent's tag
# file order).
#
# The algorithm works as follows:
# 1. read the tags from p1, p2 and the base
#     - when reading the p1 tags, also get the line numbers associated to each
#       tag node (these will be used to sort the merged tags in a way that
#       minimizes the diff to p1). Ignore the file numbers when reading p2 and
#       the base
# 2. recover the "lost tags" (i.e. those that are found in the base but not on
#    p1 or p2) and add them back to p1 and/or p2
#     - at this point the only tags that are on p1 but not on p2 are those new
#       tags that were introduced in p1. Same thing for the tags that are on p2
#       but not on p2
# 3. take all tags that are only on p1 or only on p2 (but not on the base)
#     - Note that these are the tags that were introduced between base and p1
#       and between base and p2, possibly on separate clones
# 4. for each tag found both on p1 and p2 perform the following merge algorithm:
#     - the tags conflict if their tag "histories" have the same "rank" (i.e.
#       length) _AND_ the last (current) tag is _NOT_ the same
#     - for non conflicting tags:
#         - choose which are the high and the low ranking nodes
#             - the high ranking list of nodes is the one that is longer.
#               In case of draw favor p1
#             - the merged node list is made of 3 parts:
#                 - first the nodes that are common to the beginning of both
#                   the low and the high ranking nodes
#                 - second the non common low ranking nodes
#                 - finally the non common high ranking nodes (with the last
#                   one being the merged tag node)
#             - note that this is equivalent to putting the whole low ranking
#               node list first, followed by the non common high ranking nodes
#     - note that during the merge we keep the "node line numbers", which will
#       be used when writing the merged tags to the tag file
# 5. write the merged tags taking into account to their positions in the first
#    parent (i.e. try to keep the relative ordering of the nodes that come
#    from p1). This minimizes the diff between the merged and the p1 tag files
#    This is donw by using the following algorithm
#     - group the nodes for a given tag that must be written next to each other
#         - A: nodes that come from consecutive lines on p1
#         - B: nodes that come from p2 (i.e. whose associated line number is
#              None) and are next to one of the a nodes in A
#         - each group is associated with a line number coming from p1
#     - generate a "tag block" for each of the groups
#         - a tag block is a set of consecutive "node tag" lines belonging to
#           the same tag and which will be written next to each other on the
#           merged tags file
#     - sort the "tag blocks" according to their associated number line
#         - put blocks whose nodes come all from p2 first
#     - write the tag blocks in the sorted order

import tags
import util
from node import nullid, hex
from i18n import _
import operator
hexnullid = hex(nullid)

def readtagsformerge(ui, repo, lines, fn='', keeplinenums=False):
    '''read the .hgtags file into a structure that is suitable for merging

    Sepending on the keeplinenumbers flag, clear the line numbers associated
    with each tag. Rhis is done because only the line numbers of the first
    parent are useful for merging
    '''
    filetags = tags._readtaghist(ui, repo, lines, fn=fn, recode=None,
                              calcnodelines=True)[1]
    for tagname, taginfo in filetags.items():
        if not keeplinenums:
            for el in taginfo:
                el[1] = None
    return filetags

def grouptagnodesbyline(tagnodes):
    '''
    Group nearby nodes (i.e. those that must be written next to each other)

    The input is a list of [node, position] pairs, corresponding to a given tag
    The position is the line number where the node was found on the first parent
    .hgtags file, or None for those nodes that came from the base or the second
    parent .hgtags files.

    This function groups those [node, position] pairs, returning a list of
    groups of nodes that must be written next to each other because their
    positions are consecutive or have no position preference (because their
    position is None).

    The result is a list of [position, [consecutive node list]]
    '''
    firstlinenum = None
    for hexnode, linenum in tagnodes:
        firstlinenum = linenum
        if firstlinenum is not None:
            break
    if firstlinenum is None:
        return [[None, [el[0] for el in tagnodes]]]
    tagnodes[0][1] = firstlinenum
    groupednodes = [[firstlinenum, []]]
    prevlinenum = firstlinenum
    for hexnode, linenum in tagnodes:
        if linenum is not None and linenum - prevlinenum > 1:
            groupednodes.append([linenum, []])
        groupednodes[-1][1].append(hexnode)
        if linenum is not None:
            prevlinenum = linenum
    return groupednodes

def writemergedtags(repo, mergedtags):
    '''
    write the merged tags while trying to minimize the diff to the first parent

    This function uses the ordering info stored on the merged tags dict to
    generate an .hgtags file which is correct (in the sense that its contents
    correspond to the result of the tag merge) while also being as close as
    possible to the first parent's .hgtags file.
    '''
    # group the node-tag pairs that must be written next to each other
    for tname, taglist in mergedtags.items():
        mergedtags[tname] = grouptagnodesbyline(taglist)

    # convert the grouped merged tags dict into a format that resembles the
    # final .hgtags file (i.e. a list of blocks of 'node tag' pairs)
    def taglist2string(tlist, tname):
        return '\n'.join(['%s %s' % (hexnode, tname) for hexnode in tlist])

    finaltags = []
    for tname, tags in mergedtags.items():
        for block in tags:
            block[1] = taglist2string(block[1], tname)
        finaltags += tags

    # the tag groups are linked to a "position" that can be used to sort them
    # before writing them
    # the position is calculated to ensure that the diff of the merged .hgtags
    # file to the first parent's .hgtags file is as small as possible
    finaltags.sort(key=operator.itemgetter(0))

    # finally we can join the sorted groups to get the final contents of the
    # merged .hgtags file, and then write it to disk
    mergedtagstring = '\n'.join([tags for rank, tags in finaltags if tags])
    fp = repo.wfile('.hgtags', 'wb')
    fp.write(mergedtagstring + '\n')
    fp.close()

def singletagmerge(p1nodes, p2nodes):
    '''
    merge the nodes corresponding to a single tag

    Note that the inputs are lists of node-linenum pairs (i.e. not just lists
    of nodes)
    '''
    if not p2nodes:
        return p1nodes
    if not p1nodes:
        return p2nodes

    # there is no conflict unless both tags point to different revisions
    # and have a non identical tag history
    p1currentnode = p1nodes[-1][0]
    p2currentnode = p2nodes[-1][0]
    if p1currentnode != p2currentnode and len(p1nodes) == len(p2nodes):
        # cannot merge two tags with same rank pointing to different nodes
        return None

    # which are the highest ranking (hr) / lowest ranking (lr) nodes?
    if len(p1nodes) >= len(p2nodes):
        hrnodes, lrnodes = p1nodes, p2nodes
    else:
        hrnodes, lrnodes = p2nodes, p1nodes

    # the lowest ranking nodes will be written first, followed by the highest
    # ranking nodes
    # to avoid unwanted tag rank explosion we try to see if there are some
    # common nodes that can be written only once
    commonidx = len(lrnodes)
    for n in range(len(lrnodes)):
        if hrnodes[n][0] != lrnodes[n][0]:
            commonidx = n
            break
        lrnodes[n][1] = p1nodes[n][1]

    # the merged node list has 3 parts:
    # - common nodes
    # - non common lowest ranking nodes
    # - non common highest ranking nodes
    # note that the common nodes plus the non common lowest ranking nodes is the
    # whole list of lr nodes
    return lrnodes + hrnodes[commonidx:]

def merge(repo, fcd, fco, fca):
    '''
    Merge the tags of two revisions, taking into account the base tags
    Try to minimize the diff between the merged tags and the first parent tags
    '''
    ui = repo.ui
    # read the p1, p2 and base tags
    # only keep the line numbers for the p1 tags
    p1tags = readtagsformerge(
        ui, repo, fcd.data().splitlines(), fn="p1 tags",
        keeplinenums=True)
    p2tags = readtagsformerge(
        ui, repo, fco.data().splitlines(), fn="p2 tags",
        keeplinenums=False)
    basetags = readtagsformerge(
        ui, repo, fca.data().splitlines(), fn="base tags",
        keeplinenums=False)

    # recover the list of "lost tags" (i.e. those that were found on the base
    # revision but not on one of the revisions being merged)
    basetagset = set(basetags)
    for n, pntags in enumerate((p1tags, p2tags)):
        pntagset = set(pntags)
        pnlosttagset = basetagset - pntagset
        for t in pnlosttagset:
            pntags[t] = basetags[t]
            if pntags[t][-1][0] != hexnullid:
                pntags[t].append([hexnullid, None])

    conflictedtags = []  # for reporting purposes
    mergedtags = util.sortdict(p1tags)
    # sortdict does not implement iteritems()
    for tname, p2nodes in p2tags.items():
        if tname not in mergedtags:
            mergedtags[tname] = p2nodes
            continue
        p1nodes = mergedtags[tname]
        mergednodes = singletagmerge(p1nodes, p2nodes)
        if mergednodes is None:
            conflictedtags.append(tname)
            continue
        mergedtags[tname] = mergednodes

    if conflictedtags:
        numconflicts = len(conflictedtags)
        ui.warn(_('automatic .hgtags merge failed\n'
            'the following %d tags are in conflict: %s\n')
            % (numconflicts, ', '.join(sorted(conflictedtags))))
        return True, 1

    writemergedtags(repo, mergedtags)
    ui.note(_('.hgtags merged successfully\n'))
    return False, 0

                                                                                                                                                                                                                                                                                    usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyc                                              0100644 0000000 0000000 00000013247 13077704337 021430  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s   d  d l  Z  d  d l Z d  d l m Z m Z d  d l m Z d  d l Z e e ƒ Z d e	 d „ Z
 d „  Z d „  Z d „  Z d	 „  Z d S(
   iÿÿÿÿN(   t   nullidt   hex(   t   _t    c   	   
   C   sp   t  j |  | | d | d d d t ƒd } x> | j ƒ  D]0 \ } } | s8 x | D] } d | d <qQ Wq8 q8 W| S(   s  read the .hgtags file into a structure that is suitable for merging

    Sepending on the keeplinenumbers flag, clear the line numbers associated
    with each tag. Rhis is done because only the line numbers of the first
    parent are useful for merging
    t   fnt   recodet   calcnodelinesi   N(   t   tagst   _readtaghistt   Nonet   Truet   items(	   t   uit   repot   linesR   t   keeplinenumst   filetagst   tagnamet   taginfot   el(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   readtagsformergeQ   s    c         C   sý   d } x* |  D]" \ } } | } | d k	 r Pq q W| d k rc d g  |  D] } | d ^ qI g g S| |  d d <| g  g g } | } xp |  D]h \ } } | d k	 rË | | d k rË | j | g  g ƒ n  | d d j | ƒ | d k	 r | } q q W| S(   s—  
    Group nearby nodes (i.e. those that must be written next to each other)

    The input is a list of [node, position] pairs, corresponding to a given tag
    The position is the line number where the node was found on the first parent
    .hgtags file, or None for those nodes that came from the base or the second
    parent .hgtags files.

    This function groups those [node, position] pairs, returning a list of
    groups of nodes that must be written next to each other because their
    positions are consecutive or have no position preference (because their
    position is None).

    The result is a list of [position, [consecutive node list]]
    i    i   iÿÿÿÿN(   R	   t   append(   t   tagnodest   firstlinenumt   hexnodet   linenumR   t   groupednodest   prevlinenum(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   grouptagnodesbyline`   s"    $c         C   s  x* | j  ƒ  D] \ } } t | ƒ | | <q Wd „  } g  } xL | j  ƒ  D]> \ } } x% | D] } | | d | ƒ | d <q\ W| | 7} qI W| j d t j d ƒ ƒ d j g  | D] \ } } | r± | ^ q± ƒ }	 |  j d d ƒ }
 |
 j |	 d ƒ |
 j ƒ  d S(	   sl  
    write the merged tags while trying to minimize the diff to the first parent

    This function uses the ordering info stored on the merged tags dict to
    generate an .hgtags file which is correct (in the sense that its contents
    correspond to the result of the tag merge) while also being as close as
    possible to the first parent's .hgtags file.
    c         S   s*   d j  g  |  D] } d | | f ^ q ƒ S(   Ns   
s   %s %s(   t   join(   t   tlistt   tnameR   (    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   taglist2string‘   s    i   t   keyi    s   
s   .hgtagst   wbN(	   R   R   t   sortt   operatort
   itemgetterR   t   wfilet   writet   close(   R   t
   mergedtagsR   t   taglistR    t	   finaltagsR   t   blockt   rankt   mergedtagstringt   fp(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   writemergedtags‚   s    
	.c         C   sþ   | s
 |  S|  s | S|  d d } | d d } | | k rX t  |  ƒ t  | ƒ k rX d St  |  ƒ t  | ƒ k r€ |  | } } n | |  } } t  | ƒ } xV t t  | ƒ ƒ D]B } | | d | | d k rØ | } Pn  |  | d | | d <q¬ W| | | S(   s”   
    merge the nodes corresponding to a single tag

    Note that the inputs are lists of node-linenum pairs (i.e. not just lists
    of nodes)
    iÿÿÿÿi    i   N(   t   lenR	   t   range(   t   p1nodest   p2nodest   p1currentnodet   p2currentnodet   hrnodest   lrnodest	   commonidxt   n(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   singletagmerge§   s$    $c         C   s  |  j  } t | |  | j ƒ  j ƒ  d d d t ƒ} t | |  | j ƒ  j ƒ  d d d t ƒ} t | |  | j ƒ  j ƒ  d d d t ƒ} t | ƒ } x‡ t | | f ƒ D]s \ }	 }
 t |
 ƒ } | | } xN | D]F } | | |
 | <|
 | d d t k rÏ |
 | j	 t d g ƒ qÏ qÏ Wq¦ Wg  } t j | ƒ } xx | j ƒ  D]j \ } } | | k rg| | | <q?n  | | } t | | ƒ } | d k rŸ| j	 | ƒ q?n  | | | <q?W| rõt | ƒ } | j t d ƒ | d	 j t | ƒ ƒ f ƒ t d
 f St |  | ƒ | j t d ƒ ƒ t d f S(   s›   
    Merge the tags of two revisions, taking into account the base tags
    Try to minimize the diff between the merged tags and the first parent tags
    R   s   p1 tagsR   s   p2 tagss	   base tagsiÿÿÿÿi    sI   automatic .hgtags merge failed
the following %d tags are in conflict: %s
s   , i   s   .hgtags merged successfully
N(   R   R   t   datat
   splitlinesR
   t   Falset   sett	   enumeratet	   hexnullidR   R	   t   utilt   sortdictR   R;   R1   t   warnR   R   t   sortedR0   t   note(   R   t   fcdt   fcot   fcaR   t   p1tagst   p2tagst   basetagst
   basetagsetR:   t   pntagst   pntagsett   pnlosttagsett   tt   conflictedtagsR)   R   R4   R3   t   mergednodest   numconflicts(    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   mergeÔ   sL    				
"


(   R   RB   t   nodeR    R   t   i18nR   R$   RA   R>   R   R   R0   R;   RU   (    (    (    s6   /usr/lib/python2.7/dist-packages/mercurial/tagmerge.pyt   <module>J   s   	"	%	-                                                                                                                                                                                                                                                                                                                                                         usr/lib/python2.7/dist-packages/mercurial/tags.py                                                   0100644 0000000 0000000 00000032530 12413056314 020410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # tags.py - read tag info from local repository
#
# Copyright 2009 Matt Mackall <mpm@selenic.com>
# Copyright 2009 Greg Ward <greg@gerg.ca>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

# Currently this module only deals with reading and caching tags.
# Eventually, it could take care of updating (adding/removing/moving)
# tags too.

from node import nullid, bin, hex, short
from i18n import _
import util
import encoding
import error
import errno
import time

def findglobaltags(ui, repo, alltags, tagtypes):
    '''Find global tags in repo by reading .hgtags from every head that
    has a distinct version of it, using a cache to avoid excess work.
    Updates the dicts alltags, tagtypes in place: alltags maps tag name
    to (node, hist) pair (see _readtags() below), and tagtypes maps tag
    name to tag type ("global" in this case).'''
    # This is so we can be lazy and assume alltags contains only global
    # tags when we pass it to _writetagcache().
    assert len(alltags) == len(tagtypes) == 0, \
           "findglobaltags() should be called first"

    (heads, tagfnode, cachetags, shouldwrite) = _readtagcache(ui, repo)
    if cachetags is not None:
        assert not shouldwrite
        # XXX is this really 100% correct?  are there oddball special
        # cases where a global tag should outrank a local tag but won't,
        # because cachetags does not contain rank info?
        _updatetags(cachetags, 'global', alltags, tagtypes)
        return

    seen = set()                    # set of fnode
    fctx = None
    for head in reversed(heads):        # oldest to newest
        assert head in repo.changelog.nodemap, \
               "tag cache returned bogus head %s" % short(head)

        fnode = tagfnode.get(head)
        if fnode and fnode not in seen:
            seen.add(fnode)
            if not fctx:
                fctx = repo.filectx('.hgtags', fileid=fnode)
            else:
                fctx = fctx.filectx(fnode)

            filetags = _readtags(ui, repo, fctx.data().splitlines(), fctx)
            _updatetags(filetags, 'global', alltags, tagtypes)

    # and update the cache (if necessary)
    if shouldwrite:
        _writetagcache(ui, repo, heads, tagfnode, alltags)

def readlocaltags(ui, repo, alltags, tagtypes):
    '''Read local tags in repo.  Update alltags and tagtypes.'''
    try:
        data = repo.opener.read("localtags")
    except IOError, inst:
        if inst.errno != errno.ENOENT:
            raise
        return

    # localtags is in the local encoding; re-encode to UTF-8 on
    # input for consistency with the rest of this module.
    filetags = _readtags(
        ui, repo, data.splitlines(), "localtags",
        recode=encoding.fromlocal)

    # remove tags pointing to invalid nodes
    cl = repo.changelog
    for t in filetags.keys():
        try:
            cl.rev(filetags[t][0])
        except (LookupError, ValueError):
            del filetags[t]

    _updatetags(filetags, "local", alltags, tagtypes)

def _readtaghist(ui, repo, lines, fn, recode=None, calcnodelines=False):
    '''Read tag definitions from a file (or any source of lines).
    This function returns two sortdicts with similar information:
    - the first dict, bingtaglist, contains the tag information as expected by
      the _readtags function, i.e. a mapping from tag name to (node, hist):
        - node is the node id from the last line read for that name,
        - hist is the list of node ids previously associated with it (in file
          order).  All node ids are binary, not hex.
    - the second dict, hextaglines, is a mapping from tag name to a list of
      [hexnode, line number] pairs, ordered from the oldest to the newest node.
    When calcnodelines is False the hextaglines dict is not calculated (an
    empty dict is returned). This is done to improve this function's
    performance in cases where the line numbers are not needed.
    '''

    bintaghist = util.sortdict()
    hextaglines = util.sortdict()
    count = 0

    def warn(msg):
        ui.warn(_("%s, line %s: %s\n") % (fn, count, msg))

    for nline, line in enumerate(lines):
        count += 1
        if not line:
            continue
        try:
            (nodehex, name) = line.split(" ", 1)
        except ValueError:
            warn(_("cannot parse entry"))
            continue
        name = name.strip()
        if recode:
            name = recode(name)
        try:
            nodebin = bin(nodehex)
        except TypeError:
            warn(_("node '%s' is not well formed") % nodehex)
            continue

        # update filetags
        if calcnodelines:
            # map tag name to a list of line numbers
            if name not in hextaglines:
                hextaglines[name] = []
            hextaglines[name].append([nodehex, nline])
            continue
        # map tag name to (node, hist)
        if name not in bintaghist:
            bintaghist[name] = []
        bintaghist[name].append(nodebin)
    return bintaghist, hextaglines

def _readtags(ui, repo, lines, fn, recode=None, calcnodelines=False):
    '''Read tag definitions from a file (or any source of lines).
    Return a mapping from tag name to (node, hist): node is the node id
    from the last line read for that name, and hist is the list of node
    ids previously associated with it (in file order).  All node ids are
    binary, not hex.'''
    filetags, nodelines = _readtaghist(ui, repo, lines, fn, recode=recode,
                                       calcnodelines=calcnodelines)
    for tag, taghist in filetags.items():
        filetags[tag] = (taghist[-1], taghist[:-1])
    return filetags

def _updatetags(filetags, tagtype, alltags, tagtypes):
    '''Incorporate the tag info read from one file into the two
    dictionaries, alltags and tagtypes, that contain all tag
    info (global across all heads plus local).'''

    for name, nodehist in filetags.iteritems():
        if name not in alltags:
            alltags[name] = nodehist
            tagtypes[name] = tagtype
            continue

        # we prefer alltags[name] if:
        #  it supersedes us OR
        #  mutual supersedes and it has a higher rank
        # otherwise we win because we're tip-most
        anode, ahist = nodehist
        bnode, bhist = alltags[name]
        if (bnode != anode and anode in bhist and
            (bnode not in ahist or len(bhist) > len(ahist))):
            anode = bnode
        else:
            tagtypes[name] = tagtype
        ahist.extend([n for n in bhist if n not in ahist])
        alltags[name] = anode, ahist


# The tag cache only stores info about heads, not the tag contents
# from each head.  I.e. it doesn't try to squeeze out the maximum
# performance, but is simpler has a better chance of actually
# working correctly.  And this gives the biggest performance win: it
# avoids looking up .hgtags in the manifest for every head, and it
# can avoid calling heads() at all if there have been no changes to
# the repo.

def _readtagcache(ui, repo):
    '''Read the tag cache and return a tuple (heads, fnodes, cachetags,
    shouldwrite).  If the cache is completely up-to-date, cachetags is a
    dict of the form returned by _readtags(); otherwise, it is None and
    heads and fnodes are set.  In that case, heads is the list of all
    heads currently in the repository (ordered from tip to oldest) and
    fnodes is a mapping from head to .hgtags filenode.  If those two are
    set, caller is responsible for reading tag info from each head.'''

    try:
        cachefile = repo.opener('cache/tags', 'r')
        # force reading the file for static-http
        cachelines = iter(cachefile)
    except IOError:
        cachefile = None

    # The cache file consists of lines like
    #   <headrev> <headnode> [<tagnode>]
    # where <headrev> and <headnode> redundantly identify a repository
    # head from the time the cache was written, and <tagnode> is the
    # filenode of .hgtags on that head.  Heads with no .hgtags file will
    # have no <tagnode>.  The cache is ordered from tip to oldest (which
    # is part of why <headrev> is there: a quick visual check is all
    # that's required to ensure correct order).
    #
    # This information is enough to let us avoid the most expensive part
    # of finding global tags, which is looking up <tagnode> in the
    # manifest for each head.
    cacherevs = []                      # list of headrev
    cacheheads = []                     # list of headnode
    cachefnode = {}                     # map headnode to filenode
    if cachefile:
        try:
            for line in cachelines:
                if line == "\n":
                    break
                line = line.split()
                cacherevs.append(int(line[0]))
                headnode = bin(line[1])
                cacheheads.append(headnode)
                if len(line) == 3:
                    fnode = bin(line[2])
                    cachefnode[headnode] = fnode
        except Exception:
            # corruption of the tags cache, just recompute it
            ui.warn(_('.hg/cache/tags is corrupt, rebuilding it\n'))
            cacheheads = []
            cacherevs = []
            cachefnode = {}

    tipnode = repo.changelog.tip()
    tiprev = len(repo.changelog) - 1

    # Case 1 (common): tip is the same, so nothing has changed.
    # (Unchanged tip trivially means no changesets have been added.
    # But, thanks to localrepository.destroyed(), it also means none
    # have been destroyed by strip or rollback.)
    if cacheheads and cacheheads[0] == tipnode and cacherevs[0] == tiprev:
        tags = _readtags(ui, repo, cachelines, cachefile.name)
        cachefile.close()
        return (None, None, tags, False)
    if cachefile:
        cachefile.close()               # ignore rest of file

    repoheads = repo.heads()
    # Case 2 (uncommon): empty repo; get out quickly and don't bother
    # writing an empty cache.
    if repoheads == [nullid]:
        return ([], {}, {}, False)

    # Case 3 (uncommon): cache file missing or empty.

    # Case 4 (uncommon): tip rev decreased.  This should only happen
    # when we're called from localrepository.destroyed().  Refresh the
    # cache so future invocations will not see disappeared heads in the
    # cache.

    # Case 5 (common): tip has changed, so we've added/replaced heads.

    # As it happens, the code to handle cases 3, 4, 5 is the same.

    # N.B. in case 4 (nodes destroyed), "new head" really means "newly
    # exposed".
    if not len(repo.file('.hgtags')):
        # No tags have ever been committed, so we can avoid a
        # potentially expensive search.
        return (repoheads, cachefnode, None, True)

    starttime = time.time()

    newheads = [head
                for head in repoheads
                if head not in set(cacheheads)]

    # Now we have to lookup the .hgtags filenode for every new head.
    # This is the most expensive part of finding tags, so performance
    # depends primarily on the size of newheads.  Worst case: no cache
    # file, so newheads == repoheads.
    for head in reversed(newheads):
        cctx = repo[head]
        try:
            fnode = cctx.filenode('.hgtags')
            cachefnode[head] = fnode
        except error.LookupError:
            # no .hgtags file on this head
            pass

    duration = time.time() - starttime
    ui.log('tagscache',
           'resolved %d tags cache entries from %d manifests in %0.4f '
           'seconds\n',
           len(cachefnode), len(newheads), duration)

    # Caller has to iterate over all heads, but can use the filenodes in
    # cachefnode to get to each .hgtags revision quickly.
    return (repoheads, cachefnode, None, True)

def _writetagcache(ui, repo, heads, tagfnode, cachetags):

    try:
        cachefile = repo.opener('cache/tags', 'w', atomictemp=True)
    except (OSError, IOError):
        return

    ui.log('tagscache', 'writing tags cache file with %d heads and %d tags\n',
            len(heads), len(cachetags))

    realheads = repo.heads()            # for sanity checks below
    for head in heads:
        # temporary sanity checks; these can probably be removed
        # once this code has been in crew for a few weeks
        assert head in repo.changelog.nodemap, \
               'trying to write non-existent node %s to tag cache' % short(head)
        assert head in realheads, \
               'trying to write non-head %s to tag cache' % short(head)
        assert head != nullid, \
               'trying to write nullid to tag cache'

        # This can't fail because of the first assert above.  When/if we
        # remove that assert, we might want to catch LookupError here
        # and downgrade it to a warning.
        rev = repo.changelog.rev(head)

        fnode = tagfnode.get(head)
        if fnode:
            cachefile.write('%d %s %s\n' % (rev, hex(head), hex(fnode)))
        else:
            cachefile.write('%d %s\n' % (rev, hex(head)))

    # Tag names in the cache are in UTF-8 -- which is the whole reason
    # we keep them in UTF-8 throughout this module.  If we converted
    # them local encoding on input, we would lose info writing them to
    # the cache.
    cachefile.write('\n')
    for (name, (node, hist)) in cachetags.iteritems():
        for n in hist:
            cachefile.write("%s %s\n" % (hex(n), name))
        cachefile.write("%s %s\n" % (hex(node), name))

    try:
        cachefile.close()
    except (OSError, IOError):
        pass
                                                                                                                                                                        usr/lib/python2.7/dist-packages/mercurial/tags.pyc                                                  0100644 0000000 0000000 00000021415 13077704337 020567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s½   d  d l  m Z m Z m Z m Z d  d l m Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l Z d „  Z d „  Z d e d „ Z d e d „ Z d „  Z d	 „  Z d
 „  Z d S(   iÿÿÿÿ(   t   nullidt   bint   hext   short(   t   _Nc         C   s‚  t  | ƒ t  | ƒ k o# d k n s4 t d ƒ ‚ t |  | ƒ \ } } } } | d k	 r | sh t ‚ t | d | | ƒ d St ƒ  } d }	 xÎ t | ƒ D]À }
 |
 | j j k sÉ t d t	 |
 ƒ ƒ ‚ | j
 |
 ƒ } | r› | | k r› | j | ƒ |	 s| j d d | ƒ}	 n |	 j | ƒ }	 t |  | |	 j ƒ  j ƒ  |	 ƒ } t | d | | ƒ q› q› W| r~t |  | | | | ƒ n  d S(   sD  Find global tags in repo by reading .hgtags from every head that
    has a distinct version of it, using a cache to avoid excess work.
    Updates the dicts alltags, tagtypes in place: alltags maps tag name
    to (node, hist) pair (see _readtags() below), and tagtypes maps tag
    name to tag type ("global" in this case).i    s'   findglobaltags() should be called firstt   globalNs    tag cache returned bogus head %ss   .hgtagst   fileid(   t   lent   AssertionErrort   _readtagcachet   Nonet   _updatetagst   sett   reversedt	   changelogt   nodemapR   t   gett   addt   filectxt	   _readtagst   datat
   splitlinest   _writetagcache(   t   uit   repot   alltagst   tagtypest   headst   tagfnodet	   cachetagst   shouldwritet   seent   fctxt   headt   fnodet   filetags(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyt   findglobaltags   s,    +		!c   	      C   sÚ   y | j  j d ƒ } Wn, t k
 rD } | j t j k r@ ‚  n  d SXt |  | | j ƒ  d d t j ƒ} | j	 } xN | j
 ƒ  D]@ } y | j | | d ƒ Wq t t f k
 r¾ | | =q Xq Wt | d | | ƒ d S(   s6   Read local tags in repo.  Update alltags and tagtypes.t	   localtagsNt   recodei    t   local(   t   openert   readt   IOErrort   errnot   ENOENTR   R   t   encodingt	   fromlocalR   t   keyst   revt   LookupErrort
   ValueErrorR   (	   R   R   R   R   R   t   instR#   t   clt   t(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyt   readlocaltags>   s     	c            su  t  j ƒ  } t  j ƒ  } d ‰  ‡  ‡ ‡ f d †  } x5t | ƒ D]'\ }	 }
 ˆ  d 7‰  |
 sb q@ n  y |
 j d d ƒ \ } } Wn$ t k
 r¤ | t d ƒ ƒ q@ n X| j ƒ  } | rÆ | | ƒ } n  y t | ƒ } Wn( t k
 r | t d ƒ | ƒ q@ n X| r=| | k r g  | | <n  | | j	 | |	 g ƒ q@ n  | | k rVg  | | <n  | | j	 | ƒ q@ W| | f S(   sP  Read tag definitions from a file (or any source of lines).
    This function returns two sortdicts with similar information:
    - the first dict, bingtaglist, contains the tag information as expected by
      the _readtags function, i.e. a mapping from tag name to (node, hist):
        - node is the node id from the last line read for that name,
        - hist is the list of node ids previously associated with it (in file
          order).  All node ids are binary, not hex.
    - the second dict, hextaglines, is a mapping from tag name to a list of
      [hexnode, line number] pairs, ordered from the oldest to the newest node.
    When calcnodelines is False the hextaglines dict is not calculated (an
    empty dict is returned). This is done to improve this function's
    performance in cases where the line numbers are not needed.
    i    c            s$   ˆ j  t d ƒ ˆ ˆ  |  f ƒ d  S(   Ns   %s, line %s: %s
(   t   warnR   (   t   msg(   t   countt   fnR   (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyR7   j   s    i   t    s   cannot parse entrys   node '%s' is not well formed(
   t   utilt   sortdictt	   enumeratet   splitR2   R   t   stripR   t	   TypeErrort   append(   R   R   t   linesR:   R&   t   calcnodelinest
   bintaghistt   hextaglinesR7   t   nlinet   linet   nodehext   namet   nodebin(    (   R9   R:   R   s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyt   _readtaghistW   s<    
c   
   	   C   s`   t  |  | | | d | d | ƒ\ } } x2 | j ƒ  D]$ \ } }	 |	 d |	 d  f | | <q4 W| S(   s(  Read tag definitions from a file (or any source of lines).
    Return a mapping from tag name to (node, hist): node is the node id
    from the last line read for that name, and hist is the list of node
    ids previously associated with it (in file order).  All node ids are
    binary, not hex.R&   RD   iÿÿÿÿ(   RL   t   items(
   R   R   RC   R:   R&   RD   R#   t	   nodelinest   tagt   taghist(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyR   Œ   s
    c         C   sî   xç |  j  ƒ  D]Ù \ } } | | k r? | | | <| | | <q n  | \ } } | | \ } }	 | | k r  | |	 k r  | | k s— t |	 ƒ t | ƒ k r  | } n
 | | | <| j g  |	 D] }
 |
 | k r· |
 ^ q· ƒ | | f | | <q Wd S(   s¤   Incorporate the tag info read from one file into the two
    dictionaries, alltags and tagtypes, that contain all tag
    info (global across all heads plus local).N(   t	   iteritemsR   t   extend(   R#   t   tagtypeR   R   RJ   t   nodehistt   anodet   ahistt   bnodet   bhistt   n(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyR   ˜   s    

$	
,c         C   sÒ  y" | j  d d ƒ } t | ƒ } Wn t k
 r; d } n Xg  } g  } i  } | r$y” x | D]… } | d k rt Pn  | j ƒ  } | j t | d ƒ ƒ t | d ƒ } | j | ƒ t | ƒ d k r^ t | d ƒ }	 |	 | | <q^ q^ WWq$t	 k
 r |  j
 t d ƒ ƒ g  } g  } i  } q$Xn  | j j ƒ  }
 t | j ƒ d } | rž| d |
 k rž| d | k ržt |  | | | j ƒ } | j ƒ  d d | t f S| r±| j ƒ  n  | j ƒ  } | t g k rÜg  i  i  t f St | j d	 ƒ ƒ s| | d t f St j ƒ  } g  | D] } | t | ƒ k r| ^ q} xR t | ƒ D]D } | | } y | j d	 ƒ }	 |	 | | <WqEt j k
 rˆqEXqEWt j ƒ  | } |  j d
 d t | ƒ t | ƒ | ƒ | | d t f S(   së  Read the tag cache and return a tuple (heads, fnodes, cachetags,
    shouldwrite).  If the cache is completely up-to-date, cachetags is a
    dict of the form returned by _readtags(); otherwise, it is None and
    heads and fnodes are set.  In that case, heads is the list of all
    heads currently in the repository (ordered from tip to oldest) and
    fnodes is a mapping from head to .hgtags filenode.  If those two are
    set, caller is responsible for reading tag info from each head.s
   cache/tagst   rs   
i    i   i   i   s)   .hg/cache/tags is corrupt, rebuilding it
s   .hgtagst	   tagscachesB   resolved %d tags cache entries from %d manifests in %0.4f seconds
N(   R(   t   iterR*   R
   R?   RB   t   intR   R   t	   ExceptionR7   R   R   t   tipR   RJ   t   closet   FalseR   R    t   filet   Truet   timeR   R   t   filenodet   errorR1   t   log(   R   R   t	   cachefilet
   cachelinest	   cacherevst
   cacheheadst
   cachefnodeRH   t   headnodeR"   t   tipnodet   tiprevt   tagst	   repoheadst	   starttimeR!   t   newheadst   cctxt   duration(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyR	   º   sl    	
&


	c         C   sì  y | j  d d d t ƒ} Wn t t f k
 r6 d  SX|  j d d t | ƒ t | ƒ ƒ | j ƒ  } xÝ | D]Õ } | | j j k sš t	 d t
 | ƒ ƒ ‚ | | k s¼ t	 d t
 | ƒ ƒ ‚ | t k sÔ t	 d ƒ ‚ | j j | ƒ } | j | ƒ }	 |	 r$| j d	 | t | ƒ t |	 ƒ f ƒ ql | j d
 | t | ƒ f ƒ ql W| j d ƒ xk | j ƒ  D]] \ }
 \ } } x+ | D]# } | j d t | ƒ |
 f ƒ qxW| j d t | ƒ |
 f ƒ q_Wy | j ƒ  Wn t t f k
 rçn Xd  S(   Ns
   cache/tagst   wt
   atomictempR[   s2   writing tags cache file with %d heads and %d tags
s1   trying to write non-existent node %s to tag caches(   trying to write non-head %s to tag caches#   trying to write nullid to tag caches	   %d %s %s
s   %d %s
s   
s   %s %s
(   R(   Rc   t   OSErrorR*   Rg   R   R   R   R   R   R   R    R0   R   t   writeR   RQ   R`   (   R   R   R   R   R   Rh   t	   realheadsR!   R0   R"   RJ   t   nodet   histRY   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyR   /  s8    	)!!!(   R{   R    R   R   R   t   i18nR   R<   R-   Rf   R+   Rd   R$   R6   R
   Ra   RL   R   R   R	   R   (    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/tags.pyt   <module>   s   "	)	5	"	u                                                                                                                                                                                                                                                   usr/lib/python2.7/dist-packages/mercurial/templatefilters.py                                        0100644 0000000 0000000 00000030432 12413056314 022655  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # template-filters.py - common template expansion filters
#
# Copyright 2005-2008 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

import cgi, re, os, time, urllib
import encoding, node, util
import hbisect
import templatekw

def addbreaks(text):
    """:addbreaks: Any text. Add an XHTML "<br />" tag before the end of
    every line except the last.
    """
    return text.replace('\n', '<br/>\n')

agescales = [("year", 3600 * 24 * 365, 'Y'),
             ("month", 3600 * 24 * 30, 'M'),
             ("week", 3600 * 24 * 7, 'W'),
             ("day", 3600 * 24, 'd'),
             ("hour", 3600, 'h'),
             ("minute", 60, 'm'),
             ("second", 1, 's')]

def age(date, abbrev=False):
    """:age: Date. Returns a human-readable date/time difference between the
    given date/time and the current date/time.
    """

    def plural(t, c):
        if c == 1:
            return t
        return t + "s"
    def fmt(t, c, a):
        if abbrev:
            return "%d%s" % (c, a)
        return "%d %s" % (c, plural(t, c))

    now = time.time()
    then = date[0]
    future = False
    if then > now:
        future = True
        delta = max(1, int(then - now))
        if delta > agescales[0][1] * 30:
            return 'in the distant future'
    else:
        delta = max(1, int(now - then))
        if delta > agescales[0][1] * 2:
            return util.shortdate(date)

    for t, s, a in agescales:
        n = delta // s
        if n >= 2 or s == 1:
            if future:
                return '%s from now' % fmt(t, n, a)
            return '%s ago' % fmt(t, n, a)

def basename(path):
    """:basename: Any text. Treats the text as a path, and returns the last
    component of the path after splitting by the path separator
    (ignoring trailing separators). For example, "foo/bar/baz" becomes
    "baz" and "foo/bar//" becomes "bar".
    """
    return os.path.basename(path)

def datefilter(text):
    """:date: Date. Returns a date in a Unix date format, including the
    timezone: "Mon Sep 04 15:13:13 2006 0700".
    """
    return util.datestr(text)

def domain(author):
    """:domain: Any text. Finds the first string that looks like an email
    address, and extracts just the domain component. Example: ``User
    <user@example.com>`` becomes ``example.com``.
    """
    f = author.find('@')
    if f == -1:
        return ''
    author = author[f + 1:]
    f = author.find('>')
    if f >= 0:
        author = author[:f]
    return author

def email(text):
    """:email: Any text. Extracts the first string that looks like an email
    address. Example: ``User <user@example.com>`` becomes
    ``user@example.com``.
    """
    return util.email(text)

def escape(text):
    """:escape: Any text. Replaces the special XML/XHTML characters "&", "<"
    and ">" with XML entities, and filters out NUL characters.
    """
    return cgi.escape(text.replace('\0', ''), True)

para_re = None
space_re = None

def fill(text, width, initindent='', hangindent=''):
    '''fill many paragraphs with optional indentation.'''
    global para_re, space_re
    if para_re is None:
        para_re = re.compile('(\n\n|\n\\s*[-*]\\s*)', re.M)
        space_re = re.compile(r'  +')

    def findparas():
        start = 0
        while True:
            m = para_re.search(text, start)
            if not m:
                uctext = unicode(text[start:], encoding.encoding)
                w = len(uctext)
                while 0 < w and uctext[w - 1].isspace():
                    w -= 1
                yield (uctext[:w].encode(encoding.encoding),
                       uctext[w:].encode(encoding.encoding))
                break
            yield text[start:m.start(0)], m.group(1)
            start = m.end(1)

    return "".join([util.wrap(space_re.sub(' ', util.wrap(para, width)),
                              width, initindent, hangindent) + rest
                    for para, rest in findparas()])

def fill68(text):
    """:fill68: Any text. Wraps the text to fit in 68 columns."""
    return fill(text, 68)

def fill76(text):
    """:fill76: Any text. Wraps the text to fit in 76 columns."""
    return fill(text, 76)

def firstline(text):
    """:firstline: Any text. Returns the first line of text."""
    try:
        return text.splitlines(True)[0].rstrip('\r\n')
    except IndexError:
        return ''

def hexfilter(text):
    """:hex: Any text. Convert a binary Mercurial node identifier into
    its long hexadecimal representation.
    """
    return node.hex(text)

def hgdate(text):
    """:hgdate: Date. Returns the date as a pair of numbers: "1157407993
    25200" (Unix timestamp, timezone offset).
    """
    return "%d %d" % text

def isodate(text):
    """:isodate: Date. Returns the date in ISO 8601 format: "2009-08-18 13:00
    +0200".
    """
    return util.datestr(text, '%Y-%m-%d %H:%M %1%2')

def isodatesec(text):
    """:isodatesec: Date. Returns the date in ISO 8601 format, including
    seconds: "2009-08-18 13:00:13 +0200". See also the rfc3339date
    filter.
    """
    return util.datestr(text, '%Y-%m-%d %H:%M:%S %1%2')

def indent(text, prefix):
    '''indent each non-empty line of text after first with prefix.'''
    lines = text.splitlines()
    num_lines = len(lines)
    endswithnewline = text[-1:] == '\n'
    def indenter():
        for i in xrange(num_lines):
            l = lines[i]
            if i and l.strip():
                yield prefix
            yield l
            if i < num_lines - 1 or endswithnewline:
                yield '\n'
    return "".join(indenter())

def json(obj):
    if obj is None or obj is False or obj is True:
        return {None: 'null', False: 'false', True: 'true'}[obj]
    elif isinstance(obj, int) or isinstance(obj, float):
        return str(obj)
    elif isinstance(obj, str):
        u = unicode(obj, encoding.encoding, 'replace')
        return '"%s"' % jsonescape(u)
    elif isinstance(obj, unicode):
        return '"%s"' % jsonescape(obj)
    elif util.safehasattr(obj, 'keys'):
        out = []
        for k, v in obj.iteritems():
            s = '%s: %s' % (json(k), json(v))
            out.append(s)
        return '{' + ', '.join(out) + '}'
    elif util.safehasattr(obj, '__iter__'):
        out = []
        for i in obj:
            out.append(json(i))
        return '[' + ', '.join(out) + ']'
    else:
        raise TypeError('cannot encode type %s' % obj.__class__.__name__)

def _uescape(c):
    if ord(c) < 0x80:
        return c
    else:
        return '\\u%04x' % ord(c)

_escapes = [
    ('\\', '\\\\'), ('"', '\\"'), ('\t', '\\t'), ('\n', '\\n'),
    ('\r', '\\r'), ('\f', '\\f'), ('\b', '\\b'),
    ('<', '\\u003c'), ('>', '\\u003e'), ('\0', '\\u0000')
]

def jsonescape(s):
    for k, v in _escapes:
        s = s.replace(k, v)
    return ''.join(_uescape(c) for c in s)

def localdate(text):
    """:localdate: Date. Converts a date to local date."""
    return (util.parsedate(text)[0], util.makedate()[1])

def nonempty(str):
    """:nonempty: Any text. Returns '(none)' if the string is empty."""
    return str or "(none)"

def obfuscate(text):
    """:obfuscate: Any text. Returns the input text rendered as a sequence of
    XML entities.
    """
    text = unicode(text, encoding.encoding, 'replace')
    return ''.join(['&#%d;' % ord(c) for c in text])

def permissions(flags):
    if "l" in flags:
        return "lrwxrwxrwx"
    if "x" in flags:
        return "-rwxr-xr-x"
    return "-rw-r--r--"

def person(author):
    """:person: Any text. Returns the name before an email address,
    interpreting it as per RFC 5322.

    >>> person('foo@bar')
    'foo'
    >>> person('Foo Bar <foo@bar>')
    'Foo Bar'
    >>> person('"Foo Bar" <foo@bar>')
    'Foo Bar'
    >>> person('"Foo \"buz\" Bar" <foo@bar>')
    'Foo "buz" Bar'
    >>> # The following are invalid, but do exist in real-life
    ...
    >>> person('Foo "buz" Bar <foo@bar>')
    'Foo "buz" Bar'
    >>> person('"Foo Bar <foo@bar>')
    'Foo Bar'
    """
    if '@' not in author:
        return author
    f = author.find('<')
    if f != -1:
        return author[:f].strip(' "').replace('\\"', '"')
    f = author.find('@')
    return author[:f].replace('.', ' ')

def rfc3339date(text):
    """:rfc3339date: Date. Returns a date using the Internet date format
    specified in RFC 3339: "2009-08-18T13:00:13+02:00".
    """
    return util.datestr(text, "%Y-%m-%dT%H:%M:%S%1:%2")

def rfc822date(text):
    """:rfc822date: Date. Returns a date using the same format used in email
    headers: "Tue, 18 Aug 2009 13:00:13 +0200".
    """
    return util.datestr(text, "%a, %d %b %Y %H:%M:%S %1%2")

def short(text):
    """:short: Changeset hash. Returns the short form of a changeset hash,
    i.e. a 12 hexadecimal digit string.
    """
    return text[:12]

def shortbisect(text):
    """:shortbisect: Any text. Treats `text` as a bisection status, and
    returns a single-character representing the status (G: good, B: bad,
    S: skipped, U: untested, I: ignored). Returns single space if `text`
    is not a valid bisection status.
    """
    return hbisect.shortlabel(text) or ' '

def shortdate(text):
    """:shortdate: Date. Returns a date like "2006-09-18"."""
    return util.shortdate(text)

def splitlines(text):
    """:splitlines: Any text. Split text into a list of lines."""
    return templatekw.showlist('line', text.splitlines(), 'lines')

def stringescape(text):
    return text.encode('string_escape')

def stringify(thing):
    """:stringify: Any type. Turns the value into text by converting values into
    text and concatenating them.
    """
    if util.safehasattr(thing, '__iter__') and not isinstance(thing, str):
        return "".join([stringify(t) for t in thing if t is not None])
    return str(thing)

def strip(text):
    """:strip: Any text. Strips all leading and trailing whitespace."""
    return text.strip()

def stripdir(text):
    """:stripdir: Treat the text as path and strip a directory level, if
    possible. For example, "foo" and "foo/bar" becomes "foo".
    """
    dir = os.path.dirname(text)
    if dir == "":
        return os.path.basename(text)
    else:
        return dir

def tabindent(text):
    """:tabindent: Any text. Returns the text, with every non-empty line
    except the first starting with a tab character.
    """
    return indent(text, '\t')

def urlescape(text):
    """:urlescape: Any text. Escapes all "special" characters. For example,
    "foo bar" becomes "foo%20bar".
    """
    return urllib.quote(text)

def userfilter(text):
    """:user: Any text. Returns a short representation of a user name or email
    address."""
    return util.shortuser(text)

def emailuser(text):
    """:emailuser: Any text. Returns the user portion of an email address."""
    return util.emailuser(text)

def xmlescape(text):
    text = (text
            .replace('&', '&amp;')
            .replace('<', '&lt;')
            .replace('>', '&gt;')
            .replace('"', '&quot;')
            .replace("'", '&#39;')) # &apos; invalid in HTML
    return re.sub('[\x00-\x08\x0B\x0C\x0E-\x1F]', ' ', text)

filters = {
    "addbreaks": addbreaks,
    "age": age,
    "basename": basename,
    "date": datefilter,
    "domain": domain,
    "email": email,
    "escape": escape,
    "fill68": fill68,
    "fill76": fill76,
    "firstline": firstline,
    "hex": hexfilter,
    "hgdate": hgdate,
    "isodate": isodate,
    "isodatesec": isodatesec,
    "json": json,
    "jsonescape": jsonescape,
    "localdate": localdate,
    "nonempty": nonempty,
    "obfuscate": obfuscate,
    "permissions": permissions,
    "person": person,
    "rfc3339date": rfc3339date,
    "rfc822date": rfc822date,
    "short": short,
    "shortbisect": shortbisect,
    "shortdate": shortdate,
    "splitlines": splitlines,
    "stringescape": stringescape,
    "stringify": stringify,
    "strip": strip,
    "stripdir": stripdir,
    "tabindent": tabindent,
    "urlescape": urlescape,
    "user": userfilter,
    "emailuser": emailuser,
    "xmlescape": xmlescape,
}

def websub(text, websubtable):
    """:websub: Any text. Only applies to hgweb. Applies the regular
    expression replacements defined in the websub section.
    """
    if websubtable:
        for regexp, format in websubtable:
            text = regexp.sub(format, text)
    return text

# tell hggettext to extract docstrings from these functions:
i18nfunctions = filters.values()
                                                                                                                                                                                                                                      usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyc                                       0100644 0000000 0000000 00000042654 13077704337 023045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sj  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d „  Z
 d dy d f d d{ d
 f d d} d f d d~ d f d d€ d g Z e d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d a d a d d d „ Z d  „  Z d! „  Z d" „  Z d# „  Z d$ „  Z d% „  Z d& „  Z d' „  Z d( „  Z d) „  Z  d‚ dƒ d„ d… d† d‡ dˆ d‰ dŠ d‹ g
 Z! d> „  Z" d? „  Z# d@ „  Z$ dA „  Z% dB „  Z& dC „  Z' dD „  Z( dE „  Z) dF „  Z* dG „  Z+ dH „  Z, dI „  Z- dJ „  Z. dK „  Z/ dL „  Z0 dM „  Z1 dN „  Z2 dO „  Z3 dP „  Z4 dQ „  Z5 dR „  Z6 i$ e
 dS 6e dT 6e dU 6e dV 6e dW 6e dX 6e dY 6e dZ 6e d[ 6e d\ 6e d] 6e d^ 6e d_ 6e d` 6e da 6e" db 6e# dc 6e$ dd 6e% de 6e& df 6e' dg 6e( dh 6e) di 6e* dj 6e+ dk 6e, dl 6e- dm 6e. dn 6e/ do 6e0 dp 6e1 dq 6e2 dr 6e3 ds 6e4 dt 6e5 du 6e6 dv 6Z7 dw „  Z8 e7 j9 ƒ  Z: d S(Œ   iÿÿÿÿNc         C   s   |  j  d d ƒ S(   sf   :addbreaks: Any text. Add an XHTML "<br />" tag before the end of
    every line except the last.
    s   
s   <br/>
(   t   replace(   t   text(    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   addbreaks   s    t   yeari  i   im  t   Yt   monthi   t   Mt   weeki   t   Wt   dayt   dt   hourt   ht   minutei<   t   mt   secondi   t   sc            s-  d „  ‰ ‡  ‡ f d †  } t  j  ƒ  } |  d } t } | | k r t } t d t | | ƒ ƒ } | t d d d k r¿ d Sn> t d t | | ƒ ƒ } | t d d d k r¿ t j |  ƒ Sxg t D]_ \ } } }	 | | }
 |
 d k s÷ | d k rÆ | rd | | |
 |	 ƒ Sd	 | | |
 |	 ƒ SqÆ Wd
 S(   sy   :age: Date. Returns a human-readable date/time difference between the
    given date/time and the current date/time.
    c         S   s   | d k r |  S|  d S(   Ni   R   (    (   t   tt   c(    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   plural    s    c            s+   ˆ  r d | | f Sd | ˆ |  | ƒ f S(   Ns   %d%ss   %d %s(    (   R   R   t   a(   t   abbrevR   (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   fmt$   s    i    i   i   s   in the distant futurei   s   %s from nows   %s agoN(   t   timet   Falset   Truet   maxt   intt	   agescalest   utilt	   shortdate(   t   dateR   R   t   nowt   thent   futuret   deltaR   R   R   t   n(    (   R   R   s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   age   s&    	

c         C   s   t  j j |  ƒ S(   sù   :basename: Any text. Treats the text as a path, and returns the last
    component of the path after splitting by the path separator
    (ignoring trailing separators). For example, "foo/bar/baz" becomes
    "baz" and "foo/bar//" becomes "bar".
    (   t   ost   patht   basename(   R'   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyR(   =   s    c         C   s   t  j |  ƒ S(   st   :date: Date. Returns a date in a Unix date format, including the
    timezone: "Mon Sep 04 15:13:13 2006 0700".
    (   R   t   datestr(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt
   datefilterE   s    c         C   sY   |  j  d ƒ } | d k r d S|  | d }  |  j  d ƒ } | d k rU |  |  }  n  |  S(   s¾   :domain: Any text. Finds the first string that looks like an email
    address, and extracts just the domain component. Example: ``User
    <user@example.com>`` becomes ``example.com``.
    t   @iÿÿÿÿt    i   t   >i    (   t   find(   t   authort   f(    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   domainK   s    c         C   s   t  j |  ƒ S(   s   :email: Any text. Extracts the first string that looks like an email
    address. Example: ``User <user@example.com>`` becomes
    ``user@example.com``.
    (   R   t   email(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyR2   Y   s    c         C   s   t  j |  j d d ƒ t ƒ S(   s‰   :escape: Any text. Replaces the special XML/XHTML characters "&", "<"
    and ">" with XML entities, and filters out NUL characters.
    t    R,   (   t   cgit   escapeR    R   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyR5   `   s    R,   c      	      s™   t  d k r3 t j d t j ƒ a  t j d ƒ a n  ‡  f d †  } d j g  | ƒ  D]@ \ } } t j t j	 d t j | | ƒ ƒ | | | ƒ | ^ qR ƒ S(   s/   fill many paragraphs with optional indentation.s   (

|
\s*[-*]\s*)s     +c          3   sä   d }  x× t  rß t j ˆ  |  ƒ } | s© t ˆ  |  t j ƒ } t | ƒ } x. d | k  ry | | d j ƒ  ry | d 8} qL W| |  j t j ƒ | | j t j ƒ f VPn  ˆ  |  | j d ƒ !| j	 d ƒ f V| j
 d ƒ }  q	 Wd  S(   Ni    i   (   R   t   para_ret   searcht   unicodet   encodingt   lent   isspacet   encodet   startt   groupt   end(   R=   R   t   uctextt   w(   R   (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   findparasp   s    	#$R,   t    N(
   R6   t   Nonet   ret   compileR   t   space_ret   joinR   t   wrapt   sub(   R   t   widtht
   initindentt
   hangindentRB   t   parat   rest(    (   R   s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   filli   s    	c         C   s   t  |  d ƒ S(   s7   :fill68: Any text. Wraps the text to fit in 68 columns.iD   (   RP   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   fill68ƒ   s    c         C   s   t  |  d ƒ S(   s7   :fill76: Any text. Wraps the text to fit in 76 columns.iL   (   RP   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   fill76‡   s    c         C   s7   y |  j  t ƒ d j d ƒ SWn t k
 r2 d SXd S(   s5   :firstline: Any text. Returns the first line of text.i    s   
R,   N(   t
   splitlinesR   t   rstript
   IndexError(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   firstline‹   s    c         C   s   t  j |  ƒ S(   sm   :hex: Any text. Convert a binary Mercurial node identifier into
    its long hexadecimal representation.
    (   t   nodet   hex(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   hexfilter’   s    c         C   s   d |  S(   st   :hgdate: Date. Returns the date as a pair of numbers: "1157407993
    25200" (Unix timestamp, timezone offset).
    s   %d %d(    (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   hgdate˜   s    c         C   s   t  j |  d ƒ S(   sW   :isodate: Date. Returns the date in ISO 8601 format: "2009-08-18 13:00
    +0200".
    s   %Y-%m-%d %H:%M %1%2(   R   R)   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   isodatež   s    c         C   s   t  j |  d ƒ S(   s•   :isodatesec: Date. Returns the date in ISO 8601 format, including
    seconds: "2009-08-18 13:00:13 +0200". See also the rfc3339date
    filter.
    s   %Y-%m-%d %H:%M:%S %1%2(   R   R)   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt
   isodatesec¤   s    c            sP   |  j  ƒ  ‰ t ˆ ƒ ‰ |  d d k ‰  ‡  ‡ ‡ ‡ f d †  } d j | ƒ  ƒ S(   s;   indent each non-empty line of text after first with prefix.iÿÿÿÿs   
c          3   sb   x[ t  ˆ ƒ D]M }  ˆ |  } |  r7 | j ƒ  r7 ˆ Vn  | V|  ˆ d k  sR ˆ  r d Vq q Wd  S(   Ni   s   
(   t   xranget   strip(   t   it   l(   t   endswithnewlinet   linest	   num_linest   prefix(    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   indenter°   s    
R,   (   RS   R:   RH   (   R   Rd   Re   (    (   Ra   Rb   Rc   Rd   s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   indent«   s
    c         C   s–  |  d  k s$ |  t k s$ |  t k rA i d d  6d t 6d t 6|  St |  t ƒ s_ t |  t ƒ ri t |  ƒ St |  t ƒ r› t |  t j d ƒ } d t	 | ƒ St |  t ƒ r¸ d t	 |  ƒ St
 j |  d ƒ r+g  } xC |  j ƒ  D]5 \ } } d t | ƒ t | ƒ f } | j | ƒ qÝ Wd d	 j | ƒ d
 St
 j |  d ƒ r|g  } x! |  D] } | j t | ƒ ƒ qJWd d	 j | ƒ d St d |  j j ƒ ‚ d  S(   Nt   nullt   falset   trueR    s   "%s"t   keyss   %s: %st   {s   , t   }t   __iter__t   [t   ]s   cannot encode type %s(   RD   R   R   t
   isinstanceR   t   floatt   strR8   R9   t
   jsonescapeR   t   safehasattrt	   iteritemst   jsont   appendRH   t	   TypeErrort	   __class__t   __name__(   t   objt   ut   outt   kt   vR   R_   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyRv   º   s*    $
c         C   s(   t  |  ƒ d k  r |  Sd t  |  ƒ Sd  S(   Ni€   s   \u%04x(   t   ord(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   _uescapeÒ   s    s   \s   \\t   "s   \"s   	s   \ts   
s   \ns   s   \rs   s   \fs   s   \bt   <s   \u003cR-   s   \u003eR3   s   \u0000c         C   s@   x& t  D] \ } } |  j | | ƒ }  q Wd j d „  |  Dƒ ƒ S(   NR,   c         s   s   |  ] } t  | ƒ Vq d  S(   N(   R   (   t   .0R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pys	   <genexpr>á   s    (   t   _escapesR    RH   (   R   R~   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyRs   Þ   s    c         C   s!   t  j |  ƒ d t  j ƒ  d f S(   s0   :localdate: Date. Converts a date to local date.i    i   (   R   t	   parsedatet   makedate(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   localdateã   s    c         C   s
   |  p	 d S(   s=   :nonempty: Any text. Returns '(none)' if the string is empty.s   (none)(    (   Rr   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   nonemptyç   s    c         C   s?   t  |  t j d ƒ }  d j g  |  D] } d t | ƒ ^ q" ƒ S(   s]   :obfuscate: Any text. Returns the input text rendered as a sequence of
    XML entities.
    R    R,   s   &#%d;(   R8   R9   RH   R€   (   R   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   obfuscateë   s    c         C   s$   d |  k r d Sd |  k r  d Sd S(   NR`   t
   lrwxrwxrwxt   xs
   -rwxr-xr-xs
   -rw-r--r--(    (   t   flags(    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   permissionsò   s
    c         C   sk   d |  k r |  S|  j  d ƒ } | d k rH |  |  j d ƒ j d d ƒ S|  j  d ƒ } |  |  j d d ƒ S(	   sé  :person: Any text. Returns the name before an email address,
    interpreting it as per RFC 5322.

    >>> person('foo@bar')
    'foo'
    >>> person('Foo Bar <foo@bar>')
    'Foo Bar'
    >>> person('"Foo Bar" <foo@bar>')
    'Foo Bar'
    >>> person('"Foo "buz" Bar" <foo@bar>')
    'Foo "buz" Bar'
    >>> # The following are invalid, but do exist in real-life
    ...
    >>> person('Foo "buz" Bar <foo@bar>')
    'Foo "buz" Bar'
    >>> person('"Foo Bar <foo@bar>')
    'Foo Bar'
    R+   Rƒ   iÿÿÿÿs    "s   \"R‚   t   .RC   (   R.   R^   R    (   R/   R0   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   personù   s    c         C   s   t  j |  d ƒ S(   s~   :rfc3339date: Date. Returns a date using the Internet date format
    specified in RFC 3339: "2009-08-18T13:00:13+02:00".
    s   %Y-%m-%dT%H:%M:%S%1:%2(   R   R)   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   rfc3339date  s    c         C   s   t  j |  d ƒ S(   sz   :rfc822date: Date. Returns a date using the same format used in email
    headers: "Tue, 18 Aug 2009 13:00:13 +0200".
    s   %a, %d %b %Y %H:%M:%S %1%2(   R   R)   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt
   rfc822date  s    c         C   s   |  d  S(   sp   :short: Changeset hash. Returns the short form of a changeset hash,
    i.e. a 12 hexadecimal digit string.
    i   (    (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   short   s    c         C   s   t  j |  ƒ p d S(   sü   :shortbisect: Any text. Treats `text` as a bisection status, and
    returns a single-character representing the status (G: good, B: bad,
    S: skipped, U: untested, I: ignored). Returns single space if `text`
    is not a valid bisection status.
    RC   (   t   hbisectt
   shortlabel(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   shortbisect&  s    c         C   s   t  j |  ƒ S(   s3   :shortdate: Date. Returns a date like "2006-09-18".(   R   R   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyR   .  s    c         C   s   t  j d |  j ƒ  d ƒ S(   s7   :splitlines: Any text. Split text into a list of lines.t   lineRb   (   t
   templatekwt   showlistRS   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyRS   2  s    c         C   s   |  j  d ƒ S(   Nt   string_escape(   R<   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   stringescape6  s    c         C   s^   t  j |  d ƒ rT t |  t ƒ rT d j g  |  D] } | d k	 r/ t | ƒ ^ q/ ƒ St |  ƒ S(   so   :stringify: Any type. Turns the value into text by converting values into
    text and concatenating them.
    Rm   R,   N(   R   Rt   Rp   Rr   RH   RD   t	   stringify(   t   thingR   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyRœ   9  s    "2c         C   s
   |  j  ƒ  S(   s=   :strip: Any text. Strips all leading and trailing whitespace.(   R^   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyR^   A  s    c         C   s6   t  j j |  ƒ } | d k r. t  j j |  ƒ S| Sd S(   s„   :stripdir: Treat the text as path and strip a directory level, if
    possible. For example, "foo" and "foo/bar" becomes "foo".
    R,   N(   R&   R'   t   dirnameR(   (   R   t   dir(    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   stripdirE  s    c         C   s   t  |  d ƒ S(   sz   :tabindent: Any text. Returns the text, with every non-empty line
    except the first starting with a tab character.
    s   	(   Rf   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   tabindentO  s    c         C   s   t  j |  ƒ S(   sl   :urlescape: Any text. Escapes all "special" characters. For example,
    "foo bar" becomes "foo%20bar".
    (   t   urllibt   quote(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   urlescapeU  s    c         C   s   t  j |  ƒ S(   sT   :user: Any text. Returns a short representation of a user name or email
    address.(   R   t	   shortuser(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt
   userfilter[  s    c         C   s   t  j |  ƒ S(   sC   :emailuser: Any text. Returns the user portion of an email address.(   R   t	   emailuser(   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyR§   `  s    c         C   sU   |  j  d d ƒ j  d d ƒ j  d d ƒ j  d d ƒ j  d	 d
 ƒ }  t j d d |  ƒ S(   Nt   &s   &amp;Rƒ   s   &lt;R-   s   &gt;R‚   s   &quot;t   's   &#39;s
   [ --]RC   (   R    RE   RJ   (   R   (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt	   xmlescaped  s    R   R%   R(   R   R1   R2   R5   RQ   RR   RV   RX   RZ   R[   R\   Rv   Rs   Rˆ   R‰   RŠ   RŽ   R   R‘   R’   R“   R–   R   RS   R›   Rœ   R^   R    R¡   R¤   t   userR§   Rª   c         C   s6   | r2 x) | D] \ } } | j  | |  ƒ }  q Wn  |  S(   s}   :websub: Any text. Only applies to hgweb. Applies the regular
    expression replacements defined in the websub section.
    (   RJ   (   R   t   websubtablet   regexpt   format(    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   websub”  s    i€Q i€3ái€Q i ' i€Q i€:	 i€Q (   R   i  R   (   R   i<   R   (   R   i   R   (   s   \s   \\(   R‚   s   \"(   s   	s   \t(   s   
s   \n(   s   s   \r(   s   s   \f(   s   s   \b(   Rƒ   s   \u003c(   R-   s   \u003e(   s    s   \u0000(;   R4   RE   R&   R   R¢   R9   RW   R   R”   R˜   R   R   R   R%   R(   R*   R1   R2   R5   RD   R6   RG   RP   RQ   RR   RV   RY   RZ   R[   R\   Rf   Rv   R   R…   Rs   Rˆ   R‰   RŠ   RŽ   R   R‘   R’   R“   R–   R   RS   R›   Rœ   R^   R    R¡   R¤   R¦   R§   Rª   t   filtersR¯   t   valuest   i18nfunctions(    (    (    s=   /usr/lib/python2.7/dist-packages/mercurial/templatefilters.pyt   <module>   sº   <$		"																																
						
	
                                                                                    usr/lib/python2.7/dist-packages/mercurial/templatekw.py                                             0100644 0000000 0000000 00000034544 12413056314 021636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # templatekw.py - common changeset template keywords
#
# Copyright 2005-2009 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from node import hex
import patch, util, error
import hbisect

# This helper class allows us to handle both:
#  "{files}" (legacy command-line-specific list hack) and
#  "{files % '{file}\n'}" (hgweb-style with inlining and function support)

class _hybrid(object):
    def __init__(self, gen, values, joinfmt=None):
        self.gen = gen
        self.values = values
        if joinfmt:
            self.joinfmt = joinfmt
        else:
            self.joinfmt = lambda x: x.values()[0]
    def __iter__(self):
        return self.gen
    def __call__(self):
        for x in self.values:
            yield x

def showlist(name, values, plural=None, element=None, **args):
    if not element:
        element = name
    f = _showlist(name, values, plural, **args)
    return _hybrid(f, [{element: x} for x in values])

def _showlist(name, values, plural=None, **args):
    '''expand set of values.
    name is name of key in template map.
    values is list of strings or dicts.
    plural is plural of name, if not simply name + 's'.

    expansion works like this, given name 'foo'.

    if values is empty, expand 'no_foos'.

    if 'foo' not in template map, return values as a string,
    joined by space.

    expand 'start_foos'.

    for each value, expand 'foo'. if 'last_foo' in template
    map, expand it instead of 'foo' for last key.

    expand 'end_foos'.
    '''
    templ = args['templ']
    if plural:
        names = plural
    else: names = name + 's'
    if not values:
        noname = 'no_' + names
        if noname in templ:
            yield templ(noname, **args)
        return
    if name not in templ:
        if isinstance(values[0], str):
            yield ' '.join(values)
        else:
            for v in values:
                yield dict(v, **args)
        return
    startname = 'start_' + names
    if startname in templ:
        yield templ(startname, **args)
    vargs = args.copy()
    def one(v, tag=name):
        try:
            vargs.update(v)
        except (AttributeError, ValueError):
            try:
                for a, b in v:
                    vargs[a] = b
            except ValueError:
                vargs[name] = v
        return templ(tag, **vargs)
    lastname = 'last_' + name
    if lastname in templ:
        last = values.pop()
    else:
        last = None
    for v in values:
        yield one(v)
    if last is not None:
        yield one(last, tag=lastname)
    endname = 'end_' + names
    if endname in templ:
        yield templ(endname, **args)

def getfiles(repo, ctx, revcache):
    if 'files' not in revcache:
        revcache['files'] = repo.status(ctx.p1().node(), ctx.node())[:3]
    return revcache['files']

def getlatesttags(repo, ctx, cache):
    '''return date, distance and name for the latest tag of rev'''

    if 'latesttags' not in cache:
        # Cache mapping from rev to a tuple with tag date, tag
        # distance and tag name
        cache['latesttags'] = {-1: (0, 0, 'null')}
    latesttags = cache['latesttags']

    rev = ctx.rev()
    todo = [rev]
    while todo:
        rev = todo.pop()
        if rev in latesttags:
            continue
        ctx = repo[rev]
        tags = [t for t in ctx.tags()
                if (repo.tagtype(t) and repo.tagtype(t) != 'local')]
        if tags:
            latesttags[rev] = ctx.date()[0], 0, ':'.join(sorted(tags))
            continue
        try:
            # The tuples are laid out so the right one can be found by
            # comparison.
            pdate, pdist, ptag = max(
                latesttags[p.rev()] for p in ctx.parents())
        except KeyError:
            # Cache miss - recurse
            todo.append(rev)
            todo.extend(p.rev() for p in ctx.parents())
            continue
        latesttags[rev] = pdate, pdist + 1, ptag
    return latesttags[rev]

def getrenamedfn(repo, endrev=None):
    rcache = {}
    if endrev is None:
        endrev = len(repo)

    def getrenamed(fn, rev):
        '''looks up all renames for a file (up to endrev) the first
        time the file is given. It indexes on the changerev and only
        parses the manifest if linkrev != changerev.
        Returns rename info for fn at changerev rev.'''
        if fn not in rcache:
            rcache[fn] = {}
            fl = repo.file(fn)
            for i in fl:
                lr = fl.linkrev(i)
                renamed = fl.renamed(fl.node(i))
                rcache[fn][lr] = renamed
                if lr >= endrev:
                    break
        if rev in rcache[fn]:
            return rcache[fn][rev]

        # If linkrev != rev (i.e. rev not found in rcache) fallback to
        # filectx logic.
        try:
            return repo[rev][fn].renamed()
        except error.LookupError:
            return None

    return getrenamed


def showauthor(repo, ctx, templ, **args):
    """:author: String. The unmodified author of the changeset."""
    return ctx.user()

def showbisect(repo, ctx, templ, **args):
    """:bisect: String. The changeset bisection status."""
    return hbisect.label(repo, ctx.node())

def showbranch(**args):
    """:branch: String. The name of the branch on which the changeset was
    committed.
    """
    return args['ctx'].branch()

def showbranches(**args):
    """:branches: List of strings. The name of the branch on which the
    changeset was committed. Will be empty if the branch name was
    default.
    """
    branch = args['ctx'].branch()
    if branch != 'default':
        return showlist('branch', [branch], plural='branches', **args)
    return showlist('branch', [], plural='branches', **args)

def showbookmarks(**args):
    """:bookmarks: List of strings. Any bookmarks associated with the
    changeset.
    """
    repo = args['ctx']._repo
    bookmarks = args['ctx'].bookmarks()
    hybrid = showlist('bookmark', bookmarks, **args)
    for value in hybrid.values:
        value['current'] = repo._bookmarkcurrent
    return hybrid

def showchildren(**args):
    """:children: List of strings. The children of the changeset."""
    ctx = args['ctx']
    childrevs = ['%d:%s' % (cctx, cctx) for cctx in ctx.children()]
    return showlist('children', childrevs, element='child', **args)

def showcurrentbookmark(**args):
    """:currentbookmark: String. The active bookmark, if it is
    associated with the changeset"""
    import bookmarks as bookmarks # to avoid circular import issues
    repo = args['repo']
    if bookmarks.iscurrent(repo):
        current = repo._bookmarkcurrent
        if current in args['ctx'].bookmarks():
            return current
    return ''

def showdate(repo, ctx, templ, **args):
    """:date: Date information. The date when the changeset was committed."""
    return ctx.date()

def showdescription(repo, ctx, templ, **args):
    """:desc: String. The text of the changeset description."""
    return ctx.description().strip()

def showdiffstat(repo, ctx, templ, **args):
    """:diffstat: String. Statistics of changes with the following format:
    "modified files: +added/-removed lines"
    """
    stats = patch.diffstatdata(util.iterlines(ctx.diff()))
    maxname, maxtotal, adds, removes, binary = patch.diffstatsum(stats)
    return '%s: +%s/-%s' % (len(stats), adds, removes)

def showextras(**args):
    """:extras: List of dicts with key, value entries of the 'extras'
    field of this changeset."""
    extras = args['ctx'].extra()
    c = [{'key': x[0], 'value': x[1]} for x in sorted(extras.items())]
    f = _showlist('extra', c, plural='extras', **args)
    return _hybrid(f, c, lambda x: '%s=%s' % (x['key'], x['value']))

def showfileadds(**args):
    """:file_adds: List of strings. Files added by this changeset."""
    repo, ctx, revcache = args['repo'], args['ctx'], args['revcache']
    return showlist('file_add', getfiles(repo, ctx, revcache)[1],
                    element='file', **args)

def showfilecopies(**args):
    """:file_copies: List of strings. Files copied in this changeset with
    their sources.
    """
    cache, ctx = args['cache'], args['ctx']
    copies = args['revcache'].get('copies')
    if copies is None:
        if 'getrenamed' not in cache:
            cache['getrenamed'] = getrenamedfn(args['repo'])
        copies = []
        getrenamed = cache['getrenamed']
        for fn in ctx.files():
            rename = getrenamed(fn, ctx.rev())
            if rename:
                copies.append((fn, rename[0]))

    c = [{'name': x[0], 'source': x[1]} for x in copies]
    f = _showlist('file_copy', c, plural='file_copies', **args)
    return _hybrid(f, c, lambda x: '%s (%s)' % (x['name'], x['source']))

# showfilecopiesswitch() displays file copies only if copy records are
# provided before calling the templater, usually with a --copies
# command line switch.
def showfilecopiesswitch(**args):
    """:file_copies_switch: List of strings. Like "file_copies" but displayed
    only if the --copied switch is set.
    """
    copies = args['revcache'].get('copies') or []
    c = [{'name': x[0], 'source': x[1]} for x in copies]
    f = _showlist('file_copy', c, plural='file_copies', **args)
    return _hybrid(f, c, lambda x: '%s (%s)' % (x['name'], x['source']))

def showfiledels(**args):
    """:file_dels: List of strings. Files removed by this changeset."""
    repo, ctx, revcache = args['repo'], args['ctx'], args['revcache']
    return showlist('file_del', getfiles(repo, ctx, revcache)[2],
                    element='file', **args)

def showfilemods(**args):
    """:file_mods: List of strings. Files modified by this changeset."""
    repo, ctx, revcache = args['repo'], args['ctx'], args['revcache']
    return showlist('file_mod', getfiles(repo, ctx, revcache)[0],
                    element='file', **args)

def showfiles(**args):
    """:files: List of strings. All files modified, added, or removed by this
    changeset.
    """
    return showlist('file', args['ctx'].files(), **args)

def showlatesttag(repo, ctx, templ, cache, **args):
    """:latesttag: String. Most recent global tag in the ancestors of this
    changeset.
    """
    return getlatesttags(repo, ctx, cache)[2]

def showlatesttagdistance(repo, ctx, templ, cache, **args):
    """:latesttagdistance: Integer. Longest path to the latest tag."""
    return getlatesttags(repo, ctx, cache)[1]

def showmanifest(**args):
    repo, ctx, templ = args['repo'], args['ctx'], args['templ']
    args = args.copy()
    args.update({'rev': repo.manifest.rev(ctx.changeset()[0]),
                 'node': hex(ctx.changeset()[0])})
    return templ('manifest', **args)

def shownode(repo, ctx, templ, **args):
    """:node: String. The changeset identification hash, as a 40 hexadecimal
    digit string.
    """
    return ctx.hex()

def showp1rev(repo, ctx, templ, **args):
    """:p1rev: Integer. The repository-local revision number of the changeset's
    first parent, or -1 if the changeset has no parents."""
    return ctx.p1().rev()

def showp2rev(repo, ctx, templ, **args):
    """:p2rev: Integer. The repository-local revision number of the changeset's
    second parent, or -1 if the changeset has no second parent."""
    return ctx.p2().rev()

def showp1node(repo, ctx, templ, **args):
    """:p1node: String. The identification hash of the changeset's first parent,
    as a 40 digit hexadecimal string. If the changeset has no parents, all
    digits are 0."""
    return ctx.p1().hex()

def showp2node(repo, ctx, templ, **args):
    """:p2node: String. The identification hash of the changeset's second
    parent, as a 40 digit hexadecimal string. If the changeset has no second
    parent, all digits are 0."""
    return ctx.p2().hex()

def showphase(repo, ctx, templ, **args):
    """:phase: String. The changeset phase name."""
    return ctx.phasestr()

def showphaseidx(repo, ctx, templ, **args):
    """:phaseidx: Integer. The changeset phase index."""
    return ctx.phase()

def showrev(repo, ctx, templ, **args):
    """:rev: Integer. The repository-local changeset revision number."""
    return ctx.rev()

def showsubrepos(**args):
    """:subrepos: List of strings. Updated subrepositories in the changeset."""
    ctx = args['ctx']
    substate = ctx.substate
    if not substate:
        return showlist('subrepo', [], **args)
    psubstate = ctx.parents()[0].substate or {}
    subrepos = []
    for sub in substate:
        if sub not in psubstate or substate[sub] != psubstate[sub]:
            subrepos.append(sub) # modified or newly added in ctx
    for sub in psubstate:
        if sub not in substate:
            subrepos.append(sub) # removed in ctx
    return showlist('subrepo', sorted(subrepos), **args)

def showtags(**args):
    """:tags: List of strings. Any tags associated with the changeset."""
    return showlist('tag', args['ctx'].tags(), **args)

# keywords are callables like:
# fn(repo, ctx, templ, cache, revcache, **args)
# with:
# repo - current repository instance
# ctx - the changectx being displayed
# templ - the templater instance
# cache - a cache dictionary for the whole templater run
# revcache - a cache dictionary for the current revision
keywords = {
    'author': showauthor,
    'bisect': showbisect,
    'branch': showbranch,
    'branches': showbranches,
    'bookmarks': showbookmarks,
    'children': showchildren,
    'currentbookmark': showcurrentbookmark,
    'date': showdate,
    'desc': showdescription,
    'diffstat': showdiffstat,
    'extras': showextras,
    'file_adds': showfileadds,
    'file_copies': showfilecopies,
    'file_copies_switch': showfilecopiesswitch,
    'file_dels': showfiledels,
    'file_mods': showfilemods,
    'files': showfiles,
    'latesttag': showlatesttag,
    'latesttagdistance': showlatesttagdistance,
    'manifest': showmanifest,
    'node': shownode,
    'p1rev': showp1rev,
    'p1node': showp1node,
    'p2rev': showp2rev,
    'p2node': showp2node,
    'phase': showphase,
    'phaseidx': showphaseidx,
    'rev': showrev,
    'subrepos': showsubrepos,
    'tags': showtags,
}

def _showparents(**args):
    """:parents: List of strings. The parents of the changeset in "rev:node"
    format. If the changeset has only one "natural" parent (the predecessor
    revision) nothing is shown."""
    pass

dockeywords = {
    'parents': _showparents,
}
dockeywords.update(keywords)
del dockeywords['branches']

# tell hggettext to extract docstrings from these functions:
i18nfunctions = dockeywords.values()
                                                                                                                                                            usr/lib/python2.7/dist-packages/mercurial/templatekw.pyc                                            0100644 0000000 0000000 00000043530 13077704337 022010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s¯  d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d e f d „  ƒ  YZ d d d „ Z	 d d „ Z
 d „  Z d „  Z d d	 „ Z d
 „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z  d „  Z! d „  Z" d „  Z# d  „  Z$ d! „  Z% d" „  Z& d# „  Z' d$ „  Z( d% „  Z) d& „  Z* d' „  Z+ i e d( 6e d) 6e d* 6e d+ 6e d, 6e d- 6e d. 6e d/ 6e d0 6e d1 6e d2 6e d3 6e d4 6e d5 6e d6 6e d7 6e d8 6e d9 6e  d: 6e! d; 6e" d< 6e# d= 6e% d> 6e$ d? 6e& d@ 6e' dA 6e( dB 6e) dC 6e* dD 6e+ dE 6Z, dF „  Z- i e- dG 6Z. e. j/ e, ƒ e. d+ =e. j0 ƒ  Z1 d S(H   iÿÿÿÿ(   t   hexNt   _hybridc           B   s&   e  Z d d  „ Z d „  Z d „  Z RS(   c         C   s4   | |  _  | |  _ | r$ | |  _ n d „  |  _ d  S(   Nc         S   s   |  j  ƒ  d S(   Ni    (   t   values(   t   x(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   <lambda>   s    (   t   genR   t   joinfmt(   t   selfR   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   __init__   s
    		c         C   s   |  j  S(   N(   R   (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   __iter__   s    c         c   s   x |  j  D] } | Vq
 Wd  S(   N(   R   (   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   __call__   s    N(   t   __name__t
   __module__t   NoneR   R	   R
   (    (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyR      s   	c         K   sK   | s |  } n  t  |  | | |  } t | g  | D] } i | | 6^ q1 ƒ S(   N(   t	   _showlistR   (   t   nameR   t   pluralt   elementt   argst   fR   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showlist   s    	c         +   s„  | d ‰ | r | } n
 ˆ  d } | sT d | } | ˆ k rP ˆ | |  Vn  d Sˆ  ˆ k r§ t  | d t ƒ r„ d j | ƒ Vn x | D] } t | |  Vq‹ Wd Sd | } | ˆ k rÎ ˆ | |  Vn  | j ƒ  ‰ ˆ  ‡  ‡ ‡ f d † } d	 ˆ  }	 |	 ˆ k r| j ƒ  }
 n d }
 x | D] } | | ƒ Vq$W|
 d k	 rY| |
 d
 |	 ƒVn  d | } | ˆ k r€ˆ | |  Vn  d S(   sô  expand set of values.
    name is name of key in template map.
    values is list of strings or dicts.
    plural is plural of name, if not simply name + 's'.

    expansion works like this, given name 'foo'.

    if values is empty, expand 'no_foos'.

    if 'foo' not in template map, return values as a string,
    joined by space.

    expand 'start_foos'.

    for each value, expand 'foo'. if 'last_foo' in template
    map, expand it instead of 'foo' for last key.

    expand 'end_foos'.
    t   templt   st   no_Ni    t    t   start_c            s{   y ˆ j  |  ƒ WnZ t t f k
 rm y% x |  D] \ } } | ˆ | <q1 WWqn t k
 ri |  ˆ ˆ  <qn Xn Xˆ | ˆ  S(   N(   t   updatet   AttributeErrort
   ValueError(   t   vt   tagt   at   b(   R   R   t   vargs(    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   oneL   s    t   last_R   t   end_(   t
   isinstancet   strt   joint   dictt   copyt   popR   (   R   R   R   R   t   namest   nonameR   t	   startnameR"   t   lastnamet   lastt   endname(    (   R   R   R!   s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyR   $   s>    
	





c         C   sC   d | k r; |  j  | j ƒ  j ƒ  | j ƒ  ƒ d  | d <n  | d S(   Nt   filesi   (   t   statust   p1t   node(   t   repot   ctxt   revcache(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   getfilesc   s    /c   
         s~  d | k r  i d
 d 6| d <n  | d ‰  | j  ƒ  } | g } x4| ru| j ƒ  } | ˆ  k rf qB n  |  | } g  | j ƒ  D]0 } |  j | ƒ r} |  j | ƒ d k r} | ^ q} } | rë | j ƒ  d d d j t | ƒ ƒ f ˆ  | <qB n  y/ t ‡  f d †  | j ƒ  Dƒ ƒ \ } } }	 Wn> t	 k
 rZ| j
 | ƒ | j d „  | j ƒ  Dƒ ƒ qB n X| | d	 |	 f ˆ  | <qB Wˆ  | S(   s8   return date, distance and name for the latest tag of revt
   latesttagsi    t   nulliÿÿÿÿt   localt   :c         3   s   |  ] } ˆ  | j  ƒ  Vq d  S(   N(   t   rev(   t   .0t   p(   R9   (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pys	   <genexpr>   s    c         s   s   |  ] } | j  ƒ  Vq d  S(   N(   R=   (   R>   R?   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pys	   <genexpr>…   s    i   (   i    i    R:   (   R=   R*   t   tagst   tagtypet   dateR'   t   sortedt   maxt   parentst   KeyErrort   appendt   extend(
   R5   R6   t   cacheR=   t   todot   tR@   t   pdatet   pdistt   ptag(    (   R9   s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   getlatesttagsh   s0    
		
0,,c            s:   i  ‰ ˆ  d  k r! t ˆ ƒ ‰  n  ‡  ‡ ‡ f d †  } | S(   Nc            sÌ   |  ˆ k r~ i  ˆ |  <ˆ j  |  ƒ } xV | D]K } | j | ƒ } | j | j | ƒ ƒ } | ˆ |  | <| ˆ  k r, Pq, q, Wn  | ˆ |  k rš ˆ |  | Sy ˆ | |  j ƒ  SWn t j k
 rÇ d SXd S(   sç   looks up all renames for a file (up to endrev) the first
        time the file is given. It indexes on the changerev and only
        parses the manifest if linkrev != changerev.
        Returns rename info for fn at changerev rev.N(   t   filet   linkrevt   renamedR4   t   errort   LookupErrorR   (   t   fnR=   t   flt   it   lrRR   (   t   endrevt   rcacheR5   (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   getrenamed   s    
(   R   t   len(   R5   RY   R[   (    (   RY   RZ   R5   s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   getrenamedfnŠ   s
    c         K   s
   | j  ƒ  S(   s8   :author: String. The unmodified author of the changeset.(   t   user(   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   showauthorª   s    c         K   s   t  j |  | j ƒ  ƒ S(   s0   :bisect: String. The changeset bisection status.(   t   hbisectt   labelR4   (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   showbisect®   s    c          K   s   |  d j  ƒ  S(   sV   :branch: String. The name of the branch on which the changeset was
    committed.
    R6   (   t   branch(   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   showbranch²   s    c          K   sK   |  d j  ƒ  } | d k r5 t d | g d d |  St d g  d d |  S(   s“   :branches: List of strings. The name of the branch on which the
    changeset was committed. Will be empty if the branch name was
    default.
    R6   t   defaultRc   R   t   branches(   Rc   R   (   R   Rc   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showbranches¸   s    c          K   sT   |  d j  } |  d j ƒ  } t d | |   } x | j D] } | j | d <q9 W| S(   sR   :bookmarks: List of strings. Any bookmarks associated with the
    changeset.
    R6   t   bookmarkt   current(   t   _repot	   bookmarksR   R   t   _bookmarkcurrent(   R   R5   Rk   t   hybridt   value(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showbookmarksÂ   s    c          K   sI   |  d } g  | j  ƒ  D] } d | | f ^ q } t d | d d |  S(   s:   :children: List of strings. The children of the changeset.R6   s   %d:%st   childrenR   t   child(   Rp   R   (   R   R6   t   cctxt	   childrevs(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showchildrenÍ   s    
)c          K   sO   d d l  } |  d } | j | ƒ rK | j } | |  d j  ƒ  k rK | Sn  d S(   sY   :currentbookmark: String. The active bookmark, if it is
    associated with the changesetiÿÿÿÿNR5   R6   t    (   Rk   t	   iscurrentRl   (   R   Rk   R5   Ri   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showcurrentbookmarkÓ   s    
	c         K   s
   | j  ƒ  S(   sC   :date: Date information. The date when the changeset was committed.(   RB   (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showdateÞ   s    c         K   s   | j  ƒ  j ƒ  S(   s5   :desc: String. The text of the changeset description.(   t   descriptiont   strip(   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showdescriptionâ   s    c   
      K   sS   t  j t j | j ƒ  ƒ ƒ } t  j | ƒ \ } } } } }	 d t | ƒ | | f S(   st   :diffstat: String. Statistics of changes with the following format:
    "modified files: +added/-removed lines"
    s   %s: +%s/-%s(   t   patcht   diffstatdatat   utilt	   iterlinest   difft   diffstatsumR\   (
   R5   R6   R   R   t   statst   maxnamet   maxtotalt   addst   removest   binary(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showdiffstatæ   s    c          K   sv   |  d j  ƒ  } g  t | j ƒ  ƒ D]" } i | d d 6| d d 6^ q# } t d | d d |  } t | | d	 „  ƒ S(
   s[   :extras: List of dicts with key, value entries of the 'extras'
    field of this changeset.R6   i    t   keyi   Rn   t   extraR   t   extrasc         S   s   d |  d |  d f S(   Ns   %s=%sR‰   Rn   (    (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyR   ô   s    (   RŠ   RC   t   itemsR   R   (   R   R‹   R   t   cR   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   showextrasî   s    ;c          K   sF   |  d |  d |  d } } } t  d t | | | ƒ d d d |  S(   s;   :file_adds: List of strings. Files added by this changeset.R5   R6   R7   t   file_addi   R   RP   (   R   R8   (   R   R5   R6   R7   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showfileaddsö   s     c    
      K   s  |  d |  d } } |  d j  d ƒ } | d k r¶ d | k rW t |  d ƒ | d <n  g  } | d } xL | j ƒ  D]; } | | | j ƒ  ƒ } | rt | j | | d f ƒ qt qt Wn  g  | D]" } i | d d 6| d	 d
 6^ q½ } t d | d d |  }	 t |	 | d „  ƒ S(   sZ   :file_copies: List of strings. Files copied in this changeset with
    their sources.
    RI   R6   R7   t   copiesR[   R5   i    R   i   t   sourcet	   file_copyR   t   file_copiesc         S   s   d |  d |  d f S(   Ns   %s (%s)R   R’   (    (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyR     s    N(   t   getR   R]   R1   R=   RG   R   R   (
   R   RI   R6   R‘   R[   RU   t   renameR   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showfilecopiesü   s    
!/c          K   ss   |  d j  d ƒ p g  } g  | D]" } i | d d 6| d d 6^ q  } t d | d d	 |  } t | | d
 „  ƒ S(   ss   :file_copies_switch: List of strings. Like "file_copies" but displayed
    only if the --copied switch is set.
    R7   R‘   i    R   i   R’   R“   R   R”   c         S   s   d |  d |  d f S(   Ns   %s (%s)R   R’   (    (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyR     s    (   R•   R   R   (   R   R‘   R   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showfilecopiesswitch  s    /c          K   sF   |  d |  d |  d } } } t  d t | | | ƒ d d d |  S(   s=   :file_dels: List of strings. Files removed by this changeset.R5   R6   R7   t   file_deli   R   RP   (   R   R8   (   R   R5   R6   R7   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showfiledels  s     c          K   sF   |  d |  d |  d } } } t  d t | | | ƒ d d d |  S(   s>   :file_mods: List of strings. Files modified by this changeset.R5   R6   R7   t   file_modi    R   RP   (   R   R8   (   R   R5   R6   R7   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showfilemods"  s     c          K   s   t  d |  d j ƒ  |   S(   sZ   :files: List of strings. All files modified, added, or removed by this
    changeset.
    RP   R6   (   R   R1   (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt	   showfiles(  s    c         K   s   t  |  | | ƒ d S(   sW   :latesttag: String. Most recent global tag in the ancestors of this
    changeset.
    i   (   RO   (   R5   R6   R   RI   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showlatesttag.  s    c         K   s   t  |  | | ƒ d S(   s<   :latesttagdistance: Integer. Longest path to the latest tag.i   (   RO   (   R5   R6   R   RI   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showlatesttagdistance4  s    c          K   sz   |  d |  d |  d } } } |  j  ƒ  }  |  j i | j j | j ƒ  d ƒ d 6t | j ƒ  d ƒ d 6ƒ | d |   S(   NR5   R6   R   i    R=   R4   t   manifest(   R)   R   R    R=   t	   changesetR    (   R   R5   R6   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showmanifest8  s
     &c         K   s
   | j  ƒ  S(   s\   :node: String. The changeset identification hash, as a 40 hexadecimal
    digit string.
    (   R    (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   shownode?  s    c         K   s   | j  ƒ  j ƒ  S(   s   :p1rev: Integer. The repository-local revision number of the changeset's
    first parent, or -1 if the changeset has no parents.(   R3   R=   (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt	   showp1revE  s    c         K   s   | j  ƒ  j ƒ  S(   sˆ   :p2rev: Integer. The repository-local revision number of the changeset's
    second parent, or -1 if the changeset has no second parent.(   t   p2R=   (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt	   showp2revJ  s    c         K   s   | j  ƒ  j ƒ  S(   s¦   :p1node: String. The identification hash of the changeset's first parent,
    as a 40 digit hexadecimal string. If the changeset has no parents, all
    digits are 0.(   R3   R    (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   showp1nodeO  s    c         K   s   | j  ƒ  j ƒ  S(   s­   :p2node: String. The identification hash of the changeset's second
    parent, as a 40 digit hexadecimal string. If the changeset has no second
    parent, all digits are 0.(   R¥   R    (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt
   showp2nodeU  s    c         K   s
   | j  ƒ  S(   s)   :phase: String. The changeset phase name.(   t   phasestr(   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt	   showphase[  s    c         K   s
   | j  ƒ  S(   s.   :phaseidx: Integer. The changeset phase index.(   t   phase(   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showphaseidx_  s    c         K   s
   | j  ƒ  S(   s>   :rev: Integer. The repository-local changeset revision number.(   R=   (   R5   R6   R   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showrevc  s    c          K   sÌ   |  d } | j  } | s) t d g  |   S| j ƒ  d j  p? i  } g  } x> | D]6 } | | k su | | | | k rO | j | ƒ qO qO Wx* | D]" } | | k r | j | ƒ q q Wt d t | ƒ |   S(   sE   :subrepos: List of strings. Updated subrepositories in the changeset.R6   t   subrepoi    (   t   substateR   RE   RG   RC   (   R   R6   R¯   t	   psubstatet   subrepost   sub(    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showsubreposg  s    
	 c          K   s   t  d |  d j ƒ  |   S(   s?   :tags: List of strings. Any tags associated with the changeset.R   R6   (   R   R@   (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   showtagsw  s    t   authort   bisectRc   Rf   Rk   Rp   t   currentbookmarkRB   t   desct   diffstatR‹   t	   file_addsR”   t   file_copies_switcht	   file_delst	   file_modsR1   t	   latesttagt   latesttagdistanceR    R4   t   p1revt   p1nodet   p2revt   p2nodeR«   t   phaseidxR=   R±   R@   c          K   s   d S(   s±   :parents: List of strings. The parents of the changeset in "rev:node"
    format. If the changeset has only one "natural" parent (the predecessor
    revision) nothing is shown.N(    (   R   (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   _showparents¤  s    RE   (2   R4   R    R|   R~   RS   R`   t   objectR   R   R   R   R8   RO   R]   R_   Rb   Rd   Rg   Ro   Rt   Rw   Rx   R{   Rˆ   RŽ   R   R—   R˜   Rš   Rœ   R   Rž   RŸ   R¢   R£   R¤   R¦   R§   R¨   Rª   R¬   R­   R³   R´   t   keywordsRÅ   t   dockeywordsR   R   t   i18nfunctions(    (    (    s8   /usr/lib/python2.7/dist-packages/mercurial/templatekw.pyt   <module>   s–   $?		" 				
																											
	
                                                                                                                                                                        usr/lib/python2.7/dist-packages/mercurial/templater.py                                              0100644 0000000 0000000 00000056263 12712351006 021456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # templater.py - template expansion for output
#
# Copyright 2005, 2006 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
import sys, os, re
import util, config, templatefilters, templatekw, parser, error
import types
import minirst

# template parsing

elements = {
    "(": (20, ("group", 1, ")"), ("func", 1, ")")),
    ",": (2, None, ("list", 2)),
    "|": (5, None, ("|", 5)),
    "%": (6, None, ("%", 6)),
    ")": (0, None, None),
    "symbol": (0, ("symbol",), None),
    "string": (0, ("string",), None),
    "rawstring": (0, ("rawstring",), None),
    "end": (0, None, None),
}

def tokenizer(data):
    program, start, end = data
    pos = start
    while pos < end:
        c = program[pos]
        if c.isspace(): # skip inter-token whitespace
            pass
        elif c in "(,)%|": # handle simple operators
            yield (c, None, pos)
        elif (c in '"\'' or c == 'r' and
              program[pos:pos + 2] in ("r'", 'r"')): # handle quoted strings
            if c == 'r':
                pos += 1
                c = program[pos]
                decode = False
            else:
                decode = True
            pos += 1
            s = pos
            while pos < end: # find closing quote
                d = program[pos]
                if decode and d == '\\': # skip over escaped characters
                    pos += 2
                    continue
                if d == c:
                    if not decode:
                        yield ('rawstring', program[s:pos], s)
                        break
                    yield ('string', program[s:pos], s)
                    break
                pos += 1
            else:
                raise error.ParseError(_("unterminated string"), s)
        elif c.isalnum() or c in '_':
            s = pos
            pos += 1
            while pos < end: # find end of symbol
                d = program[pos]
                if not (d.isalnum() or d == "_"):
                    break
                pos += 1
            sym = program[s:pos]
            yield ('symbol', sym, s)
            pos -= 1
        elif c == '}':
            pos += 1
            break
        else:
            raise error.ParseError(_("syntax error"), pos)
        pos += 1
    yield ('end', None, pos)

def compiletemplate(tmpl, context, strtoken="string"):
    parsed = []
    pos, stop = 0, len(tmpl)
    p = parser.parser(tokenizer, elements)
    while pos < stop:
        n = tmpl.find('{', pos)
        if n < 0:
            parsed.append((strtoken, tmpl[pos:]))
            break
        if n > 0 and tmpl[n - 1] == '\\':
            # escaped
            parsed.append((strtoken, (tmpl[pos:n - 1] + "{")))
            pos = n + 1
            continue
        if n > pos:
            parsed.append((strtoken, tmpl[pos:n]))

        pd = [tmpl, n + 1, stop]
        parseres, pos = p.parse(pd)
        parsed.append(parseres)

    return [compileexp(e, context) for e in parsed]

def compileexp(exp, context):
    t = exp[0]
    if t in methods:
        return methods[t](exp, context)
    raise error.ParseError(_("unknown method '%s'") % t)

# template evaluation

def getsymbol(exp):
    if exp[0] == 'symbol':
        return exp[1]
    raise error.ParseError(_("expected a symbol, got '%s'") % exp[0])

def getlist(x):
    if not x:
        return []
    if x[0] == 'list':
        return getlist(x[1]) + [x[2]]
    return [x]

def getfilter(exp, context):
    f = getsymbol(exp)
    if f not in context._filters:
        raise error.ParseError(_("unknown function '%s'") % f)
    return context._filters[f]

def gettemplate(exp, context):
    if exp[0] == 'string' or exp[0] == 'rawstring':
        return compiletemplate(exp[1], context, strtoken=exp[0])
    if exp[0] == 'symbol':
        return context._load(exp[1])
    raise error.ParseError(_("expected template specifier"))

def runstring(context, mapping, data):
    return data.decode("string-escape")

def runrawstring(context, mapping, data):
    return data

def runsymbol(context, mapping, key):
    v = mapping.get(key)
    if v is None:
        v = context._defaults.get(key)
    if v is None:
        try:
            v = context.process(key, mapping)
        except TemplateNotFound:
            v = ''
    if callable(v):
        return v(**mapping)
    if isinstance(v, types.GeneratorType):
        v = list(v)
        mapping[key] = v
        return v
    return v

def buildfilter(exp, context):
    func, data = compileexp(exp[1], context)
    filt = getfilter(exp[2], context)
    return (runfilter, (func, data, filt))

def runfilter(context, mapping, data):
    func, data, filt = data
    try:
        return filt(func(context, mapping, data))
    except (ValueError, AttributeError, TypeError):
        if isinstance(data, tuple):
            dt = data[1]
        else:
            dt = data
        raise util.Abort(_("template filter '%s' is not compatible with "
                           "keyword '%s'") % (filt.func_name, dt))

def buildmap(exp, context):
    func, data = compileexp(exp[1], context)
    ctmpl = gettemplate(exp[2], context)
    return (runmap, (func, data, ctmpl))

def runtemplate(context, mapping, template):
    for func, data in template:
        yield func(context, mapping, data)

def runmap(context, mapping, data):
    func, data, ctmpl = data
    d = func(context, mapping, data)
    if callable(d):
        d = d()

    lm = mapping.copy()

    for i in d:
        if isinstance(i, dict):
            lm.update(i)
            lm['originalnode'] = mapping.get('node')
            yield runtemplate(context, lm, ctmpl)
        else:
            # v is not an iterable of dicts, this happen when 'key'
            # has been fully expanded already and format is useless.
            # If so, return the expanded value.
            yield i

def buildfunc(exp, context):
    n = getsymbol(exp[1])
    args = [compileexp(x, context) for x in getlist(exp[2])]
    if n in funcs:
        f = funcs[n]
        return (f, args)
    if n in context._filters:
        if len(args) != 1:
            raise error.ParseError(_("filter %s expects one argument") % n)
        f = context._filters[n]
        return (runfilter, (args[0][0], args[0][1], f))
    raise error.ParseError(_("unknown function '%s'") % n)

def date(context, mapping, args):
    if not (1 <= len(args) <= 2):
        raise error.ParseError(_("date expects one or two arguments"))

    date = args[0][0](context, mapping, args[0][1])
    if len(args) == 2:
        fmt = stringify(args[1][0](context, mapping, args[1][1]))
        return util.datestr(date, fmt)
    return util.datestr(date)

def fill(context, mapping, args):
    if not (1 <= len(args) <= 4):
        raise error.ParseError(_("fill expects one to four arguments"))

    text = stringify(args[0][0](context, mapping, args[0][1]))
    width = 76
    initindent = ''
    hangindent = ''
    if 2 <= len(args) <= 4:
        try:
            width = int(stringify(args[1][0](context, mapping, args[1][1])))
        except ValueError:
            raise error.ParseError(_("fill expects an integer width"))
        try:
            initindent = stringify(_evalifliteral(args[2], context, mapping))
            hangindent = stringify(_evalifliteral(args[3], context, mapping))
        except IndexError:
            pass

    return templatefilters.fill(text, width, initindent, hangindent)

def pad(context, mapping, args):
    """usage: pad(text, width, fillchar=' ', right=False)
    """
    if not (2 <= len(args) <= 4):
        raise error.ParseError(_("pad() expects two to four arguments"))

    width = int(args[1][1])

    text = stringify(args[0][0](context, mapping, args[0][1]))
    if args[0][0] == runstring:
        text = stringify(runtemplate(context, mapping,
            compiletemplate(text, context)))

    right = False
    fillchar = ' '
    if len(args) > 2:
        fillchar = stringify(args[2][0](context, mapping, args[2][1]))
    if len(args) > 3:
        right = util.parsebool(args[3][1])

    if right:
        return text.rjust(width, fillchar)
    else:
        return text.ljust(width, fillchar)

def get(context, mapping, args):
    if len(args) != 2:
        # i18n: "get" is a keyword
        raise error.ParseError(_("get() expects two arguments"))

    dictarg = args[0][0](context, mapping, args[0][1])
    if not util.safehasattr(dictarg, 'get'):
        # i18n: "get" is a keyword
        raise error.ParseError(_("get() expects a dict as first argument"))

    key = args[1][0](context, mapping, args[1][1])
    yield dictarg.get(key)

def _evalifliteral(arg, context, mapping):
    t = stringify(arg[0](context, mapping, arg[1]))
    if arg[0] == runstring or arg[0] == runrawstring:
        yield runtemplate(context, mapping,
                          compiletemplate(t, context, strtoken='rawstring'))
    else:
        yield t

def if_(context, mapping, args):
    if not (2 <= len(args) <= 3):
        # i18n: "if" is a keyword
        raise error.ParseError(_("if expects two or three arguments"))

    test = stringify(args[0][0](context, mapping, args[0][1]))
    if test:
        yield _evalifliteral(args[1], context, mapping)
    elif len(args) == 3:
        yield _evalifliteral(args[2], context, mapping)

def ifcontains(context, mapping, args):
    if not (3 <= len(args) <= 4):
        # i18n: "ifcontains" is a keyword
        raise error.ParseError(_("ifcontains expects three or four arguments"))

    item = stringify(args[0][0](context, mapping, args[0][1]))
    items = args[1][0](context, mapping, args[1][1])

    # Iterating over items gives a formatted string, so we iterate
    # directly over the raw values.
    if item in [i.values()[0] for i in items()]:
        yield _evalifliteral(args[2], context, mapping)
    elif len(args) == 4:
        yield _evalifliteral(args[3], context, mapping)

def ifeq(context, mapping, args):
    if not (3 <= len(args) <= 4):
        # i18n: "ifeq" is a keyword
        raise error.ParseError(_("ifeq expects three or four arguments"))

    test = stringify(args[0][0](context, mapping, args[0][1]))
    match = stringify(args[1][0](context, mapping, args[1][1]))
    if test == match:
        yield _evalifliteral(args[2], context, mapping)
    elif len(args) == 4:
        yield _evalifliteral(args[3], context, mapping)

def join(context, mapping, args):
    if not (1 <= len(args) <= 2):
        # i18n: "join" is a keyword
        raise error.ParseError(_("join expects one or two arguments"))

    joinset = args[0][0](context, mapping, args[0][1])
    if callable(joinset):
        jf = joinset.joinfmt
        joinset = [jf(x) for x in joinset()]

    joiner = " "
    if len(args) > 1:
        joiner = stringify(args[1][0](context, mapping, args[1][1]))

    first = True
    for x in joinset:
        if first:
            first = False
        else:
            yield joiner
        yield x

def label(context, mapping, args):
    if len(args) != 2:
        # i18n: "label" is a keyword
        raise error.ParseError(_("label expects two arguments"))

    # ignore args[0] (the label string) since this is supposed to be a a no-op
    yield _evalifliteral(args[1], context, mapping)

def revset(context, mapping, args):
    """usage: revset(query[, formatargs...])
    """
    if not len(args) > 0:
        # i18n: "revset" is a keyword
        raise error.ParseError(_("revset expects one or more arguments"))

    raw = args[0][1]
    ctx = mapping['ctx']
    repo = ctx._repo

    if len(args) > 1:
        formatargs = list([a[0](context, mapping, a[1]) for a in args[1:]])
        revs = repo.revs(raw, *formatargs)
        revs = list([str(r) for r in revs])
    else:
        revsetcache = mapping['cache'].setdefault("revsetcache", {})
        if raw in revsetcache:
            revs = revsetcache[raw]
        else:
            revs = repo.revs(raw)
            revs = list([str(r) for r in revs])
            revsetcache[raw] = revs

    return templatekw.showlist("revision", revs, **mapping)

def rstdoc(context, mapping, args):
    if len(args) != 2:
        # i18n: "rstdoc" is a keyword
        raise error.ParseError(_("rstdoc expects two arguments"))

    text = stringify(args[0][0](context, mapping, args[0][1]))
    style = stringify(args[1][0](context, mapping, args[1][1]))

    return minirst.format(text, style=style, keep=['verbose'])

def shortest(context, mapping, args):
    """usage: shortest(node, minlength=4)
    """
    if not (1 <= len(args) <= 2):
        raise error.ParseError(_("shortest() expects one or two arguments"))

    node = stringify(args[0][0](context, mapping, args[0][1]))

    minlength = 4
    if len(args) > 1:
        minlength = int(args[1][1])

    cl = mapping['ctx']._repo.changelog
    def isvalid(test):
        try:
            try:
                cl.index.partialmatch(test)
            except AttributeError:
                # Pure mercurial doesn't support partialmatch on the index.
                # Fallback to the slow way.
                if cl._partialmatch(test) is None:
                    return False

            try:
                i = int(test)
                # if we are a pure int, then starting with zero will not be
                # confused as a rev; or, obviously, if the int is larger than
                # the value of the tip rev
                if test[0] == '0' or i > len(cl):
                    return True
                return False
            except ValueError:
                return True
        except error.RevlogError:
            return False

    shortest = node
    startlength = max(6, minlength)
    length = startlength
    while True:
        test = node[:length]
        if isvalid(test):
            shortest = test
            if length == minlength or length > startlength:
                return shortest
            length -= 1
        else:
            length += 1
            if len(shortest) <= length:
                return shortest

def strip(context, mapping, args):
    if not (1 <= len(args) <= 2):
        raise error.ParseError(_("strip expects one or two arguments"))

    text = stringify(args[0][0](context, mapping, args[0][1]))
    if len(args) == 2:
        chars = stringify(args[1][0](context, mapping, args[1][1]))
        return text.strip(chars)
    return text.strip()

def sub(context, mapping, args):
    if len(args) != 3:
        # i18n: "sub" is a keyword
        raise error.ParseError(_("sub expects three arguments"))

    pat = stringify(args[0][0](context, mapping, args[0][1]))
    rpl = stringify(args[1][0](context, mapping, args[1][1]))
    src = stringify(_evalifliteral(args[2], context, mapping))
    yield re.sub(pat, rpl, src)

def startswith(context, mapping, args):
    if len(args) != 2:
        # i18n: "startswith" is a keyword
        raise error.ParseError(_("startswith expects two arguments"))

    patn = stringify(args[0][0](context, mapping, args[0][1]))
    text = stringify(args[1][0](context, mapping, args[1][1]))
    if text.startswith(patn):
        return text
    return ''


def word(context, mapping, args):
    """return nth word from a string"""
    if not (2 <= len(args) <= 3):
        # i18n: "word" is a keyword
        raise error.ParseError(_("word expects two or three arguments, got %d")
                               % len(args))

    num = int(stringify(args[0][0](context, mapping, args[0][1])))
    text = stringify(args[1][0](context, mapping, args[1][1]))
    if len(args) == 3:
        splitter = stringify(args[2][0](context, mapping, args[2][1]))
    else:
        splitter = None

    tokens = text.split(splitter)
    if num >= len(tokens):
        return ''
    else:
        return tokens[num]

methods = {
    "string": lambda e, c: (runstring, e[1]),
    "rawstring": lambda e, c: (runrawstring, e[1]),
    "symbol": lambda e, c: (runsymbol, e[1]),
    "group": lambda e, c: compileexp(e[1], c),
#    ".": buildmember,
    "|": buildfilter,
    "%": buildmap,
    "func": buildfunc,
    }

funcs = {
    "date": date,
    "fill": fill,
    "get": get,
    "if": if_,
    "ifcontains": ifcontains,
    "ifeq": ifeq,
    "join": join,
    "label": label,
    "pad": pad,
    "revset": revset,
    "rstdoc": rstdoc,
    "shortest": shortest,
    "startswith": startswith,
    "strip": strip,
    "sub": sub,
    "word": word,
}

# template engine

path = ['templates', '../templates', '/usr/share/mercurial/templates']
stringify = templatefilters.stringify

def _flatten(thing):
    '''yield a single stream from a possibly nested set of iterators'''
    if isinstance(thing, str):
        yield thing
    elif not util.safehasattr(thing, '__iter__'):
        if thing is not None:
            yield str(thing)
    else:
        for i in thing:
            if isinstance(i, str):
                yield i
            elif not util.safehasattr(i, '__iter__'):
                if i is not None:
                    yield str(i)
            elif i is not None:
                for j in _flatten(i):
                    yield j

def parsestring(s, quoted=True):
    '''parse a string using simple c-like syntax.
    string must be in quotes if quoted is True.'''
    if quoted:
        if len(s) < 2 or s[0] != s[-1]:
            raise SyntaxError(_('unmatched quotes'))
        return s[1:-1].decode('string_escape')

    return s.decode('string_escape')

class engine(object):
    '''template expansion engine.

    template expansion works like this. a map file contains key=value
    pairs. if value is quoted, it is treated as string. otherwise, it
    is treated as name of template file.

    templater is asked to expand a key in map. it looks up key, and
    looks for strings like this: {foo}. it expands {foo} by looking up
    foo in map, and substituting it. expansion is recursive: it stops
    when there is no more {foo} to replace.

    expansion also allows formatting and filtering.

    format uses key to expand each item in list. syntax is
    {key%format}.

    filter uses function to transform value. syntax is
    {key|filter1|filter2|...}.'''

    def __init__(self, loader, filters={}, defaults={}):
        self._loader = loader
        self._filters = filters
        self._defaults = defaults
        self._cache = {}

    def _load(self, t):
        '''load, parse, and cache a template'''
        if t not in self._cache:
            self._cache[t] = compiletemplate(self._loader(t), self)
        return self._cache[t]

    def process(self, t, mapping):
        '''Perform expansion. t is name of map element to expand.
        mapping contains added elements for use during expansion. Is a
        generator.'''
        return _flatten(runtemplate(self, mapping, self._load(t)))

engines = {'default': engine}

def stylelist():
    paths = templatepath()
    if not paths:
        return _('no templates found, try `hg debuginstall` for more info')
    dirlist =  os.listdir(paths[0])
    stylelist = []
    for file in dirlist:
        split = file.split(".")
        if split[0] == "map-cmdline":
            stylelist.append(split[1])
    return ", ".join(sorted(stylelist))

class TemplateNotFound(util.Abort):
    pass

class templater(object):

    def __init__(self, mapfile, filters={}, defaults={}, cache={},
                 minchunk=1024, maxchunk=65536):
        '''set up template engine.
        mapfile is name of file to read map definitions from.
        filters is dict of functions. each transforms a value into another.
        defaults is dict of default map definitions.'''
        self.mapfile = mapfile or 'template'
        self.cache = cache.copy()
        self.map = {}
        self.base = (mapfile and os.path.dirname(mapfile)) or ''
        self.filters = templatefilters.filters.copy()
        self.filters.update(filters)
        self.defaults = defaults
        self.minchunk, self.maxchunk = minchunk, maxchunk
        self.ecache = {}

        if not mapfile:
            return
        if not os.path.exists(mapfile):
            raise util.Abort(_("style '%s' not found") % mapfile,
                             hint=_("available styles: %s") % stylelist())

        conf = config.config()
        conf.read(mapfile)

        for key, val in conf[''].items():
            if not val:
                raise SyntaxError(_('%s: missing value') % conf.source('', key))
            if val[0] in "'\"":
                try:
                    self.cache[key] = parsestring(val)
                except SyntaxError, inst:
                    raise SyntaxError('%s: %s' %
                                      (conf.source('', key), inst.args[0]))
            else:
                val = 'default', val
                if ':' in val[1]:
                    val = val[1].split(':', 1)
                self.map[key] = val[0], os.path.join(self.base, val[1])

    def __contains__(self, key):
        return key in self.cache or key in self.map

    def load(self, t):
        '''Get the template for the given template name. Use a local cache.'''
        if t not in self.cache:
            try:
                self.cache[t] = util.readfile(self.map[t][1])
            except KeyError, inst:
                raise TemplateNotFound(_('"%s" not in template map') %
                                       inst.args[0])
            except IOError, inst:
                raise IOError(inst.args[0], _('template file %s: %s') %
                              (self.map[t][1], inst.args[1]))
        return self.cache[t]

    def __call__(self, t, **mapping):
        ttype = t in self.map and self.map[t][0] or 'default'
        if ttype not in self.ecache:
            self.ecache[ttype] = engines[ttype](self.load,
                                                 self.filters, self.defaults)
        proc = self.ecache[ttype]

        stream = proc.process(t, mapping)
        if self.minchunk:
            stream = util.increasingchunks(stream, min=self.minchunk,
                                           max=self.maxchunk)
        return stream

def templatepath(name=None):
    '''return location of template file or directory (if no name).
    returns None if not found.'''
    normpaths = []

    # executable version (py2exe) doesn't support __file__
    if util.mainfrozen():
        module = sys.executable
    else:
        module = __file__
    for f in path:
        if f.startswith('/'):
            p = f
        else:
            fl = f.split('/')
            p = os.path.join(os.path.dirname(module), *fl)
        if name:
            p = os.path.join(p, name)
        if name and os.path.exists(p):
            return os.path.normpath(p)
        elif os.path.isdir(p):
            normpaths.append(os.path.normpath(p))

    return normpaths

def stylemap(styles, paths=None):
    """Return path to mapfile for a given style.

    Searches mapfile in the following locations:
    1. templatepath/style/map
    2. templatepath/map-style
    3. templatepath/map
    """

    if paths is None:
        paths = templatepath()
    elif isinstance(paths, str):
        paths = [paths]

    if isinstance(styles, str):
        styles = [styles]

    for style in styles:
        if not style:
            continue
        locations = [os.path.join(style, 'map'), 'map-' + style]
        locations.append('map')

        for path in paths:
            for location in locations:
                mapfile = os.path.join(path, location)
                if os.path.isfile(mapfile):
                    return style, mapfile

    raise RuntimeError("No hgweb templates found in %r" % paths)
                                                                                                                                                                                                                                                                                                                                             usr/lib/python2.7/dist-packages/mercurial/templater.pyc                                             0100644 0000000 0000000 00000062613 13077704337 021633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ò)Wc           @   s¡  d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l Z d  d l Z i	 d dY dZ f d 6d	 d d[ f d 6d d d\ f d 6d d d] f d 6d^ d 6d d_ d f d 6d d` d f d 6d da d f d 6db d 6Z d „  Z d d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d  „  Z d! „  Z d" „  Z d# „  Z d$ „  Z d% „  Z d& „  Z  d' „  Z! d( „  Z" d) „  Z# d* „  Z$ d+ „  Z% d, „  Z& d- „  Z' d. „  Z( d/ „  Z) d0 „  Z* d1 „  Z+ d2 „  Z, d3 „  Z- d4 „  Z. d5 „  Z/ i d6 „  d 6d7 „  d 6d8 „  d 6d9 „  d 6e d 6e d 6e d 6Z0 i e d: 6e  d; 6e" d< 6e$ d= 6e% d> 6e& d? 6e' d@ 6e( dA 6e! dB 6e) dC 6e* dD 6e+ dE 6e. dF 6e, dG 6e- dH 6e/ dI 6Z1 dJ dK dL g Z2 e j3 Z3 dM „  Z4 e5 dN „ Z6 dO e7 f dP „  ƒ  YZ8 i e8 dQ 6Z9 dR „  Z: dS e j; f dT „  ƒ  YZ< dU e7 f dV „  ƒ  YZ= d dW „ Z> d dX „ Z? d S(c   iÿÿÿÿ(   t   _Ni   t   groupi   t   )t   funct   (i   t   listt   ,i   t   |i   t   %i    t   symbolt   stringt	   rawstringt   endc   
      c   sU  |  \ } } } | } x+| | k  rB| | } | j  ƒ  r= nø| d k rZ | d  | f VnÛ| d k s‰ | d k rp| | | d !d k rp| d k r² | d 7} | | } t } n t } | d 7} | } xj| | k  rT| | } | r| d k r| d 7} qË n  | | k rG| s.d	 | | | !| f VPn  d
 | | | !| f VPn  | d 7} qË Wt j t d ƒ | ƒ ‚ nÅ | j ƒ  sˆ| d k r| } | d 7} x@ | | k  rÚ| | } | j ƒ  pÆ| d k sÍPn  | d 7} q›W| | | !}	 d |	 | f V| d 8} n2 | d k r| d 7} Pn t j t d ƒ | ƒ ‚ | d 7} q Wd d  | f Vd  S(   Ns   (,)%|s   "'t   ri   s   r's   r"i   s   \R   R
   s   unterminated stringR    R	   t   }s   syntax errorR   (   s   r's   r"(   t   isspacet   Nonet   Falset   Truet   errort
   ParseErrorR    t   isalnum(
   t   datat   programt   startR   t   post   ct   decodet   st   dt   sym(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt	   tokenizer   s^    


	





c         C   sG  g  } d t  |  ƒ } } t j t t ƒ } xù | | k  r&|  j d | ƒ } | d k  rs | j | |  | f ƒ Pn  | d k rÅ |  | d d k rÅ | j | |  | | d !d f ƒ | d } q. n  | | k rî | j | |  | | !f ƒ n  |  | d | g } | j | ƒ \ }	 } | j |	 ƒ q. Wg  | D] }
 t |
 | ƒ ^ q.S(   Ni    t   {i   s   \(   t   lent   parserR   t   elementst   findt   appendt   parset
   compileexp(   t   tmplt   contextt   strtokent   parsedR   t   stopt   pt   nt   pdt   parserest   e(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   compiletemplateP   s$     "
c         C   sD   |  d } | t  k r' t  | |  | ƒ St j t d ƒ | ƒ ‚ d  S(   Ni    s   unknown method '%s'(   t   methodsR   R   R    (   t   expR)   t   t(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR'   g   s    
c         C   s9   |  d d k r |  d St  j t d ƒ |  d ƒ ‚ d  S(   Ni    R	   i   s   expected a symbol, got '%s'(   R   R   R    (   R4   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt	   getsymbolo   s    c         C   s:   |  s
 g  S|  d d k r3 t  |  d ƒ |  d g S|  g S(   Ni    R   i   i   (   t   getlist(   t   x(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR7   t   s
    c         C   sB   t  |  ƒ } | | j k r7 t j t d ƒ | ƒ ‚ n  | j | S(   Ns   unknown function '%s'(   R6   t   _filtersR   R   R    (   R4   R)   t   f(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt	   getfilter{   s    c         C   su   |  d d k s  |  d d k r; t  |  d | d |  d ƒS|  d d k r\ | j |  d ƒ St j t d ƒ ƒ ‚ d  S(   Ni    R
   R   i   R*   R	   s   expected template specifier(   R2   t   _loadR   R   R    (   R4   R)   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   gettemplate   s
     c         C   s   | j  d ƒ S(   Ns   string-escape(   R   (   R)   t   mappingR   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt	   runstringˆ   s    c         C   s   | S(   N(    (   R)   R>   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   runrawstring‹   s    c         C   sµ   | j  | ƒ } | d  k r0 |  j j  | ƒ } n  | d  k ro y |  j | | ƒ } Wqo t k
 rk d } qo Xn  t | ƒ r… | |   St | t j ƒ r± t	 | ƒ } | | | <| S| S(   Nt    (
   t   getR   t	   _defaultst   processt   TemplateNotFoundt   callablet
   isinstancet   typest   GeneratorTypeR   (   R)   R>   t   keyt   v(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt	   runsymbolŽ   s    

c         C   s?   t  |  d | ƒ \ } } t |  d | ƒ } t | | | f f S(   Ni   i   (   R'   R;   t	   runfilter(   R4   R)   R   R   t   filt(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   buildfilterŸ   s    c         C   sŽ   | \ } } } y | | |  | | ƒ ƒ SWn^ t  t t f k
 r‰ t | t ƒ r^ | d } n | } t j t d ƒ | j | f ƒ ‚ n Xd  S(   Ni   s8   template filter '%s' is not compatible with keyword '%s'(	   t
   ValueErrort   AttributeErrort	   TypeErrorRG   t   tuplet   utilt   AbortR    t	   func_name(   R)   R>   R   R   RN   t   dt(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRM   ¤   s    c         C   s?   t  |  d | ƒ \ } } t |  d | ƒ } t | | | f f S(   Ni   i   (   R'   R=   t   runmap(   R4   R)   R   R   t   ctmpl(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   buildmap°   s    c         c   s,   x% | D] \ } } | |  | | ƒ Vq Wd  S(   N(    (   R)   R>   t   templateR   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   runtemplateµ   s    c         c   s¢   | \ } } } | |  | | ƒ } t  | ƒ r9 | ƒ  } n  | j ƒ  } xV | D]N } t | t ƒ r• | j | ƒ | j d ƒ | d <t |  | | ƒ VqL | VqL Wd  S(   Nt   nodet   originalnode(   RF   t   copyRG   t   dictt   updateRB   R\   (   R)   R>   R   R   RY   R   t   lmt   i(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRX   ¹   s    c         C   sæ   t  |  d ƒ } g  t |  d ƒ D] } t | | ƒ ^ q! } | t k r\ t | } | | f S| | j k rÉ t | ƒ d k r™ t j t d ƒ | ƒ ‚ n  | j | } t	 | d d | d d | f f St j t d ƒ | ƒ ‚ d  S(   Ni   i   s   filter %s expects one argumenti    s   unknown function '%s'(
   R6   R7   R'   t   funcsR9   R!   R   R   R    RM   (   R4   R)   R.   R8   t   argsR:   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt	   buildfuncÌ   s    ,

#c         C   s³   d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  | d d |  | | d d ƒ } t  | ƒ d k r¦ t | d d |  | | d d ƒ ƒ } t j | | ƒ St j | ƒ S(   Ni   i   s!   date expects one or two argumentsi    (   R!   R   R   R    t	   stringifyRT   t   datestr(   R)   R>   Re   t   datet   fmt(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRi   Ù   s    ""(c         C   sZ  d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } d } d } d } d t  | ƒ k o‘ d k n rDy2 t t | d d |  | | d d ƒ ƒ ƒ } Wn& t k
 rð t j t d ƒ ƒ ‚ n Xy< t t | d |  | ƒ ƒ } t t | d	 |  | ƒ ƒ } WqDt k
 r@qDXn  t	 j
 | | | | ƒ S(
   Ni   i   s"   fill expects one to four argumentsi    iL   RA   i   s   fill expects an integer widthi   (   R!   R   R   R    Rg   t   intRP   t   _evalifliteralt
   IndexErrort   templatefilterst   fill(   R)   R>   Re   t   textt   widtht
   initindentt
   hangindent(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRo   ã   s"    "("2 c         C   sM  d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d ƒ } t | d d |  | | d d ƒ ƒ } | d d t k r® t t |  | t | |  ƒ ƒ ƒ } n  t	 } d } t  | ƒ d k r÷ t | d d |  | | d d ƒ ƒ } n  t  | ƒ d k r#t
 j | d d ƒ } n  | r9| j | | ƒ S| j | | ƒ Sd S(	   s7   usage: pad(text, width, fillchar=' ', right=False)
    i   i   s#   pad() expects two to four argumentsi   i    t    i   N(   R!   R   R   R    Rk   Rg   R?   R\   R2   R   RT   t	   parseboolt   rjustt   ljust(   R)   R>   Re   Rq   Rp   t   rightt   fillchar(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   padø   s     "(+c         c   sª   t  | ƒ d k r* t j t d ƒ ƒ ‚ n  | d d |  | | d d ƒ } t j | d ƒ sv t j t d ƒ ƒ ‚ n  | d d |  | | d d ƒ } | j | ƒ Vd  S(   Ni   s   get() expects two argumentsi    i   RB   s&   get() expects a dict as first argument(   R!   R   R   R    RT   t   safehasattrRB   (   R)   R>   Re   t   dictargRJ   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRB     s    ""c         c   sl   t  |  d | | |  d ƒ ƒ } |  d t k s@ |  d t k rc t | | t | | d d ƒƒ Vn | Vd  S(   Ni    i   R*   R   (   Rg   R?   R@   R\   R2   (   t   argR)   R>   R5   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRl     s
      	c         c   s®   d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } | r€ t | d |  | ƒ Vn* t  | ƒ d k rª t | d |  | ƒ Vn  d  S(   Ni   i   s!   if expects two or three argumentsi    i   (   R!   R   R   R    Rg   Rl   (   R)   R>   Re   t   test(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   if_&  s    "(c         c   sö   d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } | d d |  | | d d ƒ } | g  | ƒ  D] } | j ƒ  d ^ q‘ k rÈ t | d |  | ƒ Vn* t  | ƒ d k rò t | d |  | ƒ Vn  d  S(   Ni   i   s*   ifcontains expects three or four argumentsi    i   i   (   R!   R   R   R    Rg   t   valuesRl   (   R)   R>   Re   t   itemt   itemsRc   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt
   ifcontains1  s    "(",c         c   sÜ   d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } t | d d |  | | d d ƒ ƒ } | | k r® t | d |  | ƒ Vn* t  | ƒ d k rØ t | d |  | ƒ Vn  d  S(   Ni   i   s$   ifeq expects three or four argumentsi    i   i   (   R!   R   R   R    Rg   Rl   (   R)   R>   Re   R~   t   match(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   ifeq@  s    "((c         c   s  d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  | d d |  | | d d ƒ } t | ƒ r– | j } g  | ƒ  D] } | | ƒ ^ q{ } n  d } t  | ƒ d k rÙ t | d d |  | | d d ƒ ƒ } n  t } x' | D] } | rû t } n | V| Vqæ Wd  S(   Ni   i   s!   join expects one or two argumentsi    Rt   (	   R!   R   R   R    RF   t   joinfmtRg   R   R   (   R)   R>   Re   t   joinsett   jfR8   t   joinert   first(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   joinL  s    ""	%+	c         c   sC   t  | ƒ d k r* t j t d ƒ ƒ ‚ n  t | d |  | ƒ Vd  S(   Ni   s   label expects two argumentsi   (   R!   R   R   R    Rl   (   R)   R>   Re   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   labelb  s    c         C   sN  t  | ƒ d k s* t j t d ƒ ƒ ‚ n  | d d } | d } | j } t  | ƒ d k rÎ t g  | d D]  } | d |  | | d ƒ ^ qk ƒ } | j | | Œ } t g  | D] }	 t |	 ƒ ^ q° ƒ } nm | d j d i  ƒ }
 | |
 k rý |
 | } n> | j | ƒ } t g  | D] }	 t |	 ƒ ^ qƒ } | |
 | <t	 j
 d | |  S(   s*   usage: revset(query[, formatargs...])
    i    s$   revset expects one or more argumentsi   t   ctxt   cachet   revsetcachet   revision(   R!   R   R   R    t   _repoR   t   revst   strt
   setdefaultt
   templatekwt   showlist(   R)   R>   Re   t   rawR   t   repot   at
   formatargsR’   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   revsetj  s     
	7(%
c         C   s–   t  | ƒ d k r* t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } t | d d |  | | d d ƒ ƒ } t j | d | d d g ƒS(   Ni   s   rstdoc expects two argumentsi    i   t   stylet   keept   verbose(   R!   R   R   R    Rg   t   minirstt   format(   R)   R>   Re   Rp   Rœ   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   rstdoc„  s
    ((c   
         sA  d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } d } t  | ƒ d k r‘ t | d d ƒ } n  | d j j ‰  ‡  f d †  } | } t d | ƒ } | } xo t	 r<| |  }	 | |	 ƒ r|	 } | | k s| | k r| S| d 8} qÎ | d 7} t  | ƒ | k rÎ | SqÎ Wd	 S(
   s'   usage: shortest(node, minlength=4)
    i   i   s'   shortest() expects one or two argumentsi    i   R   c            s°   y” y ˆ  j  j |  ƒ Wn* t k
 rC ˆ  j |  ƒ d  k rD t Sn Xy: t |  ƒ } |  d d k su | t ˆ  ƒ k ry t St SWn t	 k
 r’ t SXWn t
 j k
 r« t SXd  S(   Ni    t   0(   t   indext   partialmatchRQ   t   _partialmatchR   R   Rk   R!   R   RP   R   t   RevlogError(   R~   Rc   (   t   cl(    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   isvalid›  s    "	i   N(
   R!   R   R   R    Rg   Rk   R‘   t	   changelogt   maxR   (
   R)   R>   Re   R]   t	   minlengthR¨   t   shortestt   startlengtht   lengthR~   (    (   R§   s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR¬   Ž  s*    "(	

c         C   s³   d t  | ƒ k o d k n s: t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } t  | ƒ d k r© t | d d |  | | d d ƒ ƒ } | j | ƒ S| j ƒ  S(   Ni   i   s"   strip expects one or two argumentsi    (   R!   R   R   R    Rg   t   strip(   R)   R>   Re   Rp   t   chars(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR¯   Á  s    "((c         c   s®   t  | ƒ d k r* t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } t | d d |  | | d d ƒ ƒ } t t | d |  | ƒ ƒ } t j | | | ƒ Vd  S(   Ni   s   sub expects three argumentsi    i   i   (   R!   R   R   R    Rg   Rl   t   ret   sub(   R)   R>   Re   t   patt   rplt   src(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR²   Ë  s    ((c         C   s‘   t  | ƒ d k r* t j t d ƒ ƒ ‚ n  t | d d |  | | d d ƒ ƒ } t | d d |  | | d d ƒ ƒ } | j | ƒ r | Sd S(   Ni   s    startswith expects two argumentsi    i   RA   (   R!   R   R   R    Rg   t
   startswith(   R)   R>   Re   t   patnRp   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR¶   Õ  s    ((c         C   s  d t  | ƒ k o d k n sD t j t d ƒ t  | ƒ ƒ ‚ n  t t | d d |  | | d d ƒ ƒ ƒ } t | d d |  | | d d ƒ ƒ } t  | ƒ d k r× t | d d |  | | d d ƒ ƒ } n d } | j | ƒ } | t  | ƒ k rd S| | Sd S(   s   return nth word from a stringi   i   s+   word expects two or three arguments, got %di    i   RA   N(   R!   R   R   R    Rk   Rg   R   t   split(   R)   R>   Re   t   numRp   t   splittert   tokens(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   wordá  s    ".(+c         C   s   t  |  d f S(   Ni   (   R?   (   R1   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   <lambda>ö  s    c         C   s   t  |  d f S(   Ni   (   R@   (   R1   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR½   ÷  s    c         C   s   t  |  d f S(   Ni   (   RL   (   R1   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR½   ø  s    c         C   s   t  |  d | ƒ S(   Ni   (   R'   (   R1   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR½   ù  s    Ri   Ro   RB   t   ifRƒ   R…   R‹   RŒ   Rz   R›   R¡   R¬   R¶   R¯   R²   R¼   t	   templatess   ../templatess   /usr/share/mercurial/templatesc         c   sÌ   t  |  t ƒ r |  Vn± t j |  d ƒ sF |  d k	 rÈ t |  ƒ VqÈ n‚ x |  D]w } t  | t ƒ rj | VqM t j | d ƒ s™ | d k	 rÄ t | ƒ VqÄ qM | d k	 rM x t | ƒ D] } | Vq² WqM qM Wd S(   s=   yield a single stream from a possibly nested set of iteratorst   __iter__N(   RG   R“   RT   R{   R   t   _flatten(   t   thingRc   t   j(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRÁ     s    c         C   sb   | rU t  |  ƒ d k  s, |  d |  d k rA t t d ƒ ƒ ‚ n  |  d d !j d ƒ S|  j d ƒ S(   sZ   parse a string using simple c-like syntax.
    string must be in quotes if quoted is True.i   i    iÿÿÿÿs   unmatched quotesi   t   string_escape(   R!   t   SyntaxErrorR    R   (   R   t   quoted(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   parsestring*  s
    &t   enginec           B   s/   e  Z d  Z i  i  d „ Z d „  Z d „  Z RS(   s¨  template expansion engine.

    template expansion works like this. a map file contains key=value
    pairs. if value is quoted, it is treated as string. otherwise, it
    is treated as name of template file.

    templater is asked to expand a key in map. it looks up key, and
    looks for strings like this: {foo}. it expands {foo} by looking up
    foo in map, and substituting it. expansion is recursive: it stops
    when there is no more {foo} to replace.

    expansion also allows formatting and filtering.

    format uses key to expand each item in list. syntax is
    {key%format}.

    filter uses function to transform value. syntax is
    {key|filter1|filter2|...}.c         C   s(   | |  _  | |  _ | |  _ i  |  _ d  S(   N(   t   _loaderR9   RC   t   _cache(   t   selft   loadert   filterst   defaults(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   __init__H  s    			c         C   s<   | |  j  k r1 t |  j | ƒ |  ƒ |  j  | <n  |  j  | S(   s!   load, parse, and cache a template(   RÊ   R2   RÉ   (   RË   R5   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyR<   N  s    "c         C   s   t  t |  | |  j | ƒ ƒ ƒ S(   s   Perform expansion. t is name of map element to expand.
        mapping contains added elements for use during expansion. Is a
        generator.(   RÁ   R\   R<   (   RË   R5   R>   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRD   T  s    (   t   __name__t
   __module__t   __doc__RÏ   R<   RD   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRÈ   4  s   	t   defaultc          C   s‰   t  ƒ  }  |  s t d ƒ St j |  d ƒ } g  } xA | D]9 } | j d ƒ } | d d k r9 | j | d ƒ q9 q9 Wd j t | ƒ ƒ S(   Ns7   no templates found, try `hg debuginstall` for more infoi    t   .s   map-cmdlinei   s   , (   t   templatepathR    t   ost   listdirR¸   R%   R‹   t   sorted(   t   pathst   dirlistt	   stylelistt   fileR¸   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRÛ   \  s    	
RE   c           B   s   e  Z RS(    (   RÐ   RÑ   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRE   h  s   t	   templaterc           B   s;   e  Z i  i  i  d  d d „ Z d „  Z d „  Z d „  Z RS(   i   i   c         C   s  | p	 d |  _  | j ƒ  |  _ i  |  _ | r? t j j | ƒ pB d |  _ t j	 j ƒ  |  _	 |  j	 j
 | ƒ | |  _ | | |  _ |  _ i  |  _ | s™ d St j j | ƒ sÚ t j t d ƒ | d t d ƒ t ƒ  ƒ‚ n  t j ƒ  } | j | ƒ x| d j ƒ  D]\ } }	 |	 s;t t d ƒ | j d | ƒ ƒ ‚ n  |	 d d	 k r¤y t |	 ƒ |  j | <Wqt k
 r }
 t d
 | j d | ƒ |
 j d f ƒ ‚ qXqd |	 f }	 d |	 d k rÙ|	 d j d d ƒ }	 n  |	 d t j j |  j |	 d ƒ f |  j | <qWd S(   sÖ   set up template engine.
        mapfile is name of file to read map definitions from.
        filters is dict of functions. each transforms a value into another.
        defaults is dict of default map definitions.R[   RA   Ns   style '%s' not foundt   hints   available styles: %ss   %s: missing valuei    s   '"s   %s: %sRÓ   t   :i   (   t   mapfileR_   RŽ   t   mapRÖ   t   patht   dirnamet   baseRn   RÍ   Ra   RÎ   t   minchunkt   maxchunkt   ecachet   existsRT   RU   R    RÛ   t   configt   readR‚   RÅ   t   sourceRÇ   Re   R¸   R‹   (   RË   Rà   RÍ   RÎ   RŽ   Rå   Ræ   t   confRJ   t   valt   inst(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRÏ   m  s:    	!		%*c         C   s   | |  j  k p | |  j k S(   N(   RŽ   Rá   (   RË   RJ   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   __contains__•  s    c         C   s¿   | |  j  k r´ y% t j |  j | d ƒ |  j  | <Wq´ t k
 rf } t t d ƒ | j d ƒ ‚ q´ t k
 r° } t | j d t d ƒ |  j | d | j d f ƒ ‚ q´ Xn  |  j  | S(   s@   Get the template for the given template name. Use a local cache.i   s   "%s" not in template mapi    s   template file %s: %s(	   RŽ   RT   t   readfileRá   t   KeyErrorRE   R    Re   t   IOError(   RË   R5   Rî   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   load˜  s    %)c         K   s®   | |  j  k r  |  j  | d p# d } | |  j k r^ t | |  j |  j |  j ƒ |  j | <n  |  j | } | j | | ƒ } |  j rª t j	 | d |  j d |  j
 ƒ} n  | S(   Ni    RÓ   t   minRª   (   Rá   Rç   t   enginesRó   RÍ   RÎ   RD   Rå   RT   t   increasingchunksRæ   (   RË   R5   R>   t   ttypet   proct   stream(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   __call__¥  s    &	(   RÐ   RÑ   RÏ   Rï   Ró   Rú   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRÝ   k  s
   	'		c         C   sõ   g  } t  j ƒ  r t j } n t } xÊ t D]Â } | j d ƒ rI | } n0 | j d ƒ } t j j	 t j j
 | ƒ | Œ } |  r— t j j	 | |  ƒ } n  |  r¿ t j j | ƒ r¿ t j j | ƒ St j j | ƒ r+ | j t j j | ƒ ƒ q+ q+ W| S(   sZ   return location of template file or directory (if no name).
    returns None if not found.t   /(   RT   t
   mainfrozent   syst
   executablet   __file__Râ   R¶   R¸   RÖ   R‹   Rã   Rè   t   normpatht   isdirR%   (   t   namet	   normpathst   moduleR:   R-   t   fl(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyRÕ   ²  s     	! c         C   sþ   | d k r t ƒ  } n t | t ƒ r3 | g } n  t |  t ƒ rN |  g }  n  x™ |  D]‘ } | sg qU n  t j j | d ƒ d | g } | j d ƒ xP | D]H } x? | D]7 } t j j | | ƒ } t j j | ƒ r§ | | f Sq§ Wqš WqU Wt	 d | ƒ ‚ d S(   s´   Return path to mapfile for a given style.

    Searches mapfile in the following locations:
    1. templatepath/style/map
    2. templatepath/map-style
    3. templatepath/map
    Rá   s   map-s   No hgweb templates found in %rN(
   R   RÕ   RG   R“   RÖ   Râ   R‹   R%   t   isfilet   RuntimeError(   t   stylesRÙ   Rœ   t	   locationsRâ   t   locationRà   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   stylemapË  s"    	(   s   groupi   R   (   s   funci   R   (   s   listi   (   R   i   (   R   i   (   i    NN(   s   symbol(   s   string(   s	   rawstring(   i    NN(@   t   i18nR    Rý   RÖ   R±   RT   Ré   Rn   R•   R"   R   RH   RŸ   R   R#   R   R2   R'   R6   R7   R;   R=   R?   R@   RL   RO   RM   RZ   R\   RX   Rf   Ri   Ro   Rz   RB   Rl   R   Rƒ   R…   R‹   RŒ   R›   R¡   R¬   R¯   R²   R¶   R¼   R3   Rd   Râ   Rg   RÁ   R   RÇ   t   objectRÈ   Rõ   RÛ   RU   RE   RÝ   RÕ   R  (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/templater.pyt   <module>   s¦   $H
	4															
											
	3	
	
		





		
&	G                                                                                                                     usr/lib/python2.7/dist-packages/mercurial/transaction.py                                            0100644 0000000 0000000 00000023003 12413056314 021772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # transaction.py - simple journaling scheme for mercurial
#
# This transaction scheme is intended to gracefully handle program
# errors and interruptions. More serious failures like system crashes
# can be recovered with an fsck-like tool. As the whole repository is
# effectively log-structured, this should amount to simply truncating
# anything that isn't referenced in the changelog.
#
# Copyright 2005, 2006 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
import errno
import error, util

def active(func):
    def _active(self, *args, **kwds):
        if self.count == 0:
            raise error.Abort(_(
                'cannot use transaction when it is already committed/aborted'))
        return func(self, *args, **kwds)
    return _active

def _playback(journal, report, opener, entries, backupentries, unlink=True):
    for f, o, ignore in entries:
        if o or not unlink:
            try:
                fp = opener(f, 'a')
                fp.truncate(o)
                fp.close()
            except IOError:
                report(_("failed to truncate %s\n") % f)
                raise
        else:
            try:
                opener.unlink(f)
            except (IOError, OSError), inst:
                if inst.errno != errno.ENOENT:
                    raise

    backupfiles = []
    for f, b, ignore in backupentries:
        filepath = opener.join(f)
        backuppath = opener.join(b)
        try:
            util.copyfile(backuppath, filepath)
            backupfiles.append(b)
        except IOError:
            report(_("failed to recover %s\n") % f)
            raise

    opener.unlink(journal)
    backuppath = "%s.backupfiles" % journal
    if opener.exists(backuppath):
        opener.unlink(backuppath)
    for f in backupfiles:
        opener.unlink(f)

class transaction(object):
    def __init__(self, report, opener, journal, after=None, createmode=None,
            onclose=None, onabort=None):
        """Begin a new transaction

        Begins a new transaction that allows rolling back writes in the event of
        an exception.

        * `after`: called after the transaction has been committed
        * `createmode`: the mode of the journal file that will be created
        * `onclose`: called as the transaction is closing, but before it is
        closed
        * `onabort`: called as the transaction is aborting, but before any files
        have been truncated
        """
        self.count = 1
        self.usages = 1
        self.report = report
        self.opener = opener
        self.after = after
        self.onclose = onclose
        self.onabort = onabort
        self.entries = []
        self.backupentries = []
        self.map = {}
        self.backupmap = {}
        self.journal = journal
        self._queue = []
        # a dict of arguments to be passed to hooks
        self.hookargs = {}

        self.backupjournal = "%s.backupfiles" % journal
        self.file = opener.open(self.journal, "w")
        self.backupsfile = opener.open(self.backupjournal, 'w')
        if createmode is not None:
            opener.chmod(self.journal, createmode & 0666)
            opener.chmod(self.backupjournal, createmode & 0666)

    def __del__(self):
        if self.journal:
            self._abort()

    @active
    def startgroup(self):
        self._queue.append(([], []))

    @active
    def endgroup(self):
        q = self._queue.pop()
        self.entries.extend(q[0])
        self.backupentries.extend(q[1])

        offsets = []
        backups = []
        for f, o, _ in q[0]:
            offsets.append((f, o))

        for f, b, _ in q[1]:
            backups.append((f, b))

        d = ''.join(['%s\0%d\n' % (f, o) for f, o in offsets])
        self.file.write(d)
        self.file.flush()

        d = ''.join(['%s\0%s\0' % (f, b) for f, b in backups])
        self.backupsfile.write(d)
        self.backupsfile.flush()

    @active
    def add(self, file, offset, data=None):
        if file in self.map or file in self.backupmap:
            return
        if self._queue:
            self._queue[-1][0].append((file, offset, data))
            return

        self.entries.append((file, offset, data))
        self.map[file] = len(self.entries) - 1
        # add enough data to the journal to do the truncate
        self.file.write("%s\0%d\n" % (file, offset))
        self.file.flush()

    @active
    def addbackup(self, file, hardlink=True):
        """Adds a backup of the file to the transaction

        Calling addbackup() creates a hardlink backup of the specified file
        that is used to recover the file in the event of the transaction
        aborting.

        * `file`: the file path, relative to .hg/store
        * `hardlink`: use a hardlink to quickly create the backup
        """

        if file in self.map or file in self.backupmap:
            return
        backupfile = "journal.%s" % file
        if self.opener.exists(file):
            filepath = self.opener.join(file)
            backuppath = self.opener.join(backupfile)
            util.copyfiles(filepath, backuppath, hardlink=hardlink)
        else:
            self.add(file, 0)
            return

        if self._queue:
            self._queue[-1][1].append((file, backupfile))
            return

        self.backupentries.append((file, backupfile, None))
        self.backupmap[file] = len(self.backupentries) - 1
        self.backupsfile.write("%s\0%s\0" % (file, backupfile))
        self.backupsfile.flush()

    @active
    def find(self, file):
        if file in self.map:
            return self.entries[self.map[file]]
        if file in self.backupmap:
            return self.backupentries[self.backupmap[file]]
        return None

    @active
    def replace(self, file, offset, data=None):
        '''
        replace can only replace already committed entries
        that are not pending in the queue
        '''

        if file not in self.map:
            raise KeyError(file)
        index = self.map[file]
        self.entries[index] = (file, offset, data)
        self.file.write("%s\0%d\n" % (file, offset))
        self.file.flush()

    @active
    def nest(self):
        self.count += 1
        self.usages += 1
        return self

    def release(self):
        if self.count > 0:
            self.usages -= 1
        # if the transaction scopes are left without being closed, fail
        if self.count > 0 and self.usages == 0:
            self._abort()

    def running(self):
        return self.count > 0

    @active
    def close(self):
        '''commit the transaction'''
        if self.count == 1 and self.onclose is not None:
            self.onclose()

        self.count -= 1
        if self.count != 0:
            return
        self.file.close()
        self.backupsfile.close()
        self.entries = []
        if self.after:
            self.after()
        if self.opener.isfile(self.journal):
            self.opener.unlink(self.journal)
        if self.opener.isfile(self.backupjournal):
            self.opener.unlink(self.backupjournal)
            for f, b, _ in self.backupentries:
                self.opener.unlink(b)
        self.backupentries = []
        self.journal = None

    @active
    def abort(self):
        '''abort the transaction (generally called on error, or when the
        transaction is not explicitly committed before going out of
        scope)'''
        self._abort()

    def _abort(self):
        self.count = 0
        self.usages = 0
        self.file.close()
        self.backupsfile.close()

        if self.onabort is not None:
            self.onabort()

        try:
            if not self.entries and not self.backupentries:
                if self.journal:
                    self.opener.unlink(self.journal)
                if self.backupjournal:
                    self.opener.unlink(self.backupjournal)
                return

            self.report(_("transaction abort!\n"))

            try:
                _playback(self.journal, self.report, self.opener,
                          self.entries, self.backupentries, False)
                self.report(_("rollback completed\n"))
            except Exception:
                self.report(_("rollback failed - please run hg recover\n"))
        finally:
            self.journal = None


def rollback(opener, file, report):
    """Rolls back the transaction contained in the given file

    Reads the entries in the specified file, and the corresponding
    '*.backupfiles' file, to recover from an incomplete transaction.

    * `file`: a file containing a list of entries, specifying where
    to truncate each file.  The file should contain a list of
    file\0offset pairs, delimited by newlines. The corresponding
    '*.backupfiles' file should contain a list of file\0backupfile
    pairs, delimited by \0.
    """
    entries = []
    backupentries = []

    fp = opener.open(file)
    lines = fp.readlines()
    fp.close()
    for l in lines:
        try:
            f, o = l.split('\0')
            entries.append((f, int(o), None))
        except ValueError:
            report(_("couldn't read journal entry %r!\n") % l)

    backupjournal = "%s.backupfiles" % file
    if opener.exists(backupjournal):
        fp = opener.open(backupjournal)
        data = fp.read()
        if len(data) > 0:
            parts = data.split('\0')
            for i in xrange(0, len(parts), 2):
                f, b = parts[i:i + 1]
                backupentries.append((f, b, None))

    _playback(file, report, opener, entries, backupentries)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python2.7/dist-packages/mercurial/transaction.pyc                                           0100644 0000000 0000000 00000023525 13077704337 022162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sl   d  d l  m Z d  d l Z d  d l Z d  d l Z d „  Z e d „ Z d e f d „  ƒ  YZ	 d „  Z
 d S(   iÿÿÿÿ(   t   _Nc            s   ‡  f d †  } | S(   Nc            s7   |  j  d k r' t j t d ƒ ƒ ‚ n  ˆ  |  | | Ž S(   Ni    s;   cannot use transaction when it is already committed/aborted(   t   countt   errort   AbortR    (   t   selft   argst   kwds(   t   func(    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   _active   s    	(    (   R   R   (    (   R   s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   active   s    c         C   s¦  xÁ | D]¹ \ } } } | s# | r{ y* | | d ƒ }	 |	 j  | ƒ |	 j ƒ  WqÀ t k
 rw | t d ƒ | ƒ ‚  qÀ Xq y | j | ƒ Wq t t f k
 r¿ }
 |
 j t j k rÀ ‚  qÀ q Xq Wg  } x | D]y \ } } } | j | ƒ } | j | ƒ } y! t	 j
 | | ƒ | j | ƒ WqÑ t k
 rI| t d ƒ | ƒ ‚  qÑ XqÑ W| j |  ƒ d |  } | j | ƒ r„| j | ƒ n  x | D] } | j | ƒ q‹Wd  S(   Nt   as   failed to truncate %s
s   failed to recover %s
s   %s.backupfiles(   t   truncatet   closet   IOErrorR    t   unlinkt   OSErrort   errnot   ENOENTt   joint   utilt   copyfilet   appendt   exists(   t   journalt   reportt   openert   entriest   backupentriesR   t   ft   ot   ignoret   fpt   instt   backupfilest   bt   filepatht
   backuppath(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt	   _playback   s<    

t   transactionc           B   sÑ   e  Z d d d d d  „ Z d „  Z e d „  ƒ Z e d „  ƒ Z e d d „ ƒ Z e e	 d „ ƒ Z
 e d „  ƒ Z e d d „ ƒ Z e d „  ƒ Z d	 „  Z d
 „  Z e d „  ƒ Z e d „  ƒ Z d „  Z RS(   c         C   sü   d |  _  d |  _ | |  _ | |  _ | |  _ | |  _ | |  _ g  |  _ g  |  _ i  |  _	 i  |  _
 | |  _ g  |  _ i  |  _ d | |  _ | j |  j d ƒ |  _ | j |  j d ƒ |  _ | d k	 rø | j |  j | d @ƒ | j |  j | d @ƒ n  d S(   sÞ  Begin a new transaction

        Begins a new transaction that allows rolling back writes in the event of
        an exception.

        * `after`: called after the transaction has been committed
        * `createmode`: the mode of the journal file that will be created
        * `onclose`: called as the transaction is closing, but before it is
        closed
        * `onabort`: called as the transaction is aborting, but before any files
        have been truncated
        i   s   %s.backupfilest   wi¶  N(   R   t   usagesR   R   t   aftert   oncloset   onabortR   R   t   mapt	   backupmapR   t   _queuet   hookargst   backupjournalt   opent   filet   backupsfilet   Nonet   chmod(   R   R   R   R   R)   t
   createmodeR*   R+   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   __init__>   s(    														c         C   s   |  j  r |  j ƒ  n  d  S(   N(   R   t   _abort(   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   __del__c   s    	c         C   s   |  j  j g  g  f ƒ d  S(   N(   R.   R   (   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt
   startgroupg   s    c   	      C   sG  |  j  j ƒ  } |  j j | d ƒ |  j j | d ƒ g  } g  } x. | d D]" \ } } } | j | | f ƒ qN Wx. | d D]" \ } } } | j | | f ƒ q Wd j g  | D] \ } } d | | f ^ q² ƒ } |  j j | ƒ |  j j	 ƒ  d j g  | D] \ } } d | | f ^ qƒ } |  j
 j | ƒ |  j
 j	 ƒ  d  S(   Ni    i   t    s   %s %d
s   %s %s (   R.   t   popR   t   extendR   R   R   R2   t   writet   flushR3   (	   R   t   qt   offsetst   backupsR   R   R    R"   t   d(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   endgroupk   s    22c         C   s®   | |  j  k s | |  j k r" d  S|  j rP |  j d d j | | | f ƒ d  S|  j j | | | f ƒ t |  j ƒ d |  j  | <|  j j d | | f ƒ |  j j ƒ  d  S(   Niÿÿÿÿi    i   s   %s %d
(	   R,   R-   R.   R   R   t   lenR2   R>   R?   (   R   R2   t   offsett   data(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   add   s    	!c         C   s  | |  j  k s | |  j k r" d Sd | } |  j j | ƒ r{ |  j j | ƒ } |  j j | ƒ } t j | | d | ƒn |  j | d ƒ d S|  j rº |  j d d j	 | | f ƒ d S|  j
 j	 | | d f ƒ t |  j
 ƒ d |  j | <|  j j d | | f ƒ |  j j ƒ  d S(   sW  Adds a backup of the file to the transaction

        Calling addbackup() creates a hardlink backup of the specified file
        that is used to recover the file in the event of the transaction
        aborting.

        * `file`: the file path, relative to .hg/store
        * `hardlink`: use a hardlink to quickly create the backup
        Ns
   journal.%st   hardlinki    iÿÿÿÿi   s   %s %s (   R,   R-   R   R   R   R   t	   copyfilesRH   R.   R   R   R4   RE   R3   R>   R?   (   R   R2   RI   t
   backupfileR#   R$   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt	   addbackup   s     
	c         C   sF   | |  j  k r! |  j |  j  | S| |  j k rB |  j |  j | Sd  S(   N(   R,   R   R-   R   R4   (   R   R2   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   find¯   s
    c         C   sl   | |  j  k r t | ƒ ‚ n  |  j  | } | | | f |  j | <|  j j d | | f ƒ |  j j ƒ  d S(   sn   
        replace can only replace already committed entries
        that are not pending in the queue
        s   %s %d
N(   R,   t   KeyErrorR   R2   R>   R?   (   R   R2   RF   RG   t   index(    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   replace·   s    c         C   s"   |  j  d 7_  |  j d 7_ |  S(   Ni   (   R   R(   (   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   nestÅ   s    c         C   sP   |  j  d k r! |  j d 8_ n  |  j  d k rL |  j d k rL |  j ƒ  n  d  S(   Ni    i   (   R   R(   R8   (   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   releaseË   s    c         C   s   |  j  d k S(   Ni    (   R   (   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   runningÒ   s    c         C   s  |  j  d k r+ |  j d k	 r+ |  j ƒ  n  |  j  d 8_  |  j  d k rM d S|  j j ƒ  |  j j ƒ  g  |  _ |  j r† |  j ƒ  n  |  j j	 |  j
 ƒ r± |  j j |  j
 ƒ n  |  j j	 |  j ƒ r	|  j j |  j ƒ x- |  j D] \ } } } |  j j | ƒ qã Wn  g  |  _ d |  _
 d S(   s   commit the transactioni   i    N(   R   R*   R4   R2   R   R3   R   R)   R   t   isfileR   R   R0   R   (   R   R   R"   R    (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyR   Õ   s$    			c         C   s   |  j  ƒ  d S(   s   abort the transaction (generally called on error, or when the
        transaction is not explicitly committed before going out of
        scope)N(   R8   (   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   abortì   s    c         C   s,  d |  _  d |  _ |  j j ƒ  |  j j ƒ  |  j d  k	 rH |  j ƒ  n  zÓ |  j r¡ |  j r¡ |  j	 r~ |  j
 j |  j	 ƒ n  |  j r |  j
 j |  j ƒ n  d  S|  j t d ƒ ƒ y? t |  j	 |  j |  j
 |  j |  j t ƒ |  j t d ƒ ƒ Wn$ t k
 r|  j t d ƒ ƒ n XWd  d  |  _	 Xd  S(   Ni    s   transaction abort!
s   rollback completed
s(   rollback failed - please run hg recover
(   R   R(   R2   R   R3   R+   R4   R   R   R   R   R   R0   R   R    R%   t   Falset	   Exception(   R   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyR8   ó   s*    				N(   t   __name__t
   __module__R4   R7   R9   R	   R:   RD   RH   t   TrueRL   RM   RP   RQ   RR   RS   R   RU   R8   (    (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyR&   =   s$   $			c         C   sd  g  } g  } |  j  | ƒ } | j ƒ  } | j ƒ  xk | D]c } y5 | j d ƒ \ } }	 | j | t |	 ƒ d f ƒ Wq8 t k
 rš | t d ƒ | ƒ q8 Xq8 Wd | }
 |  j	 |
 ƒ rJ|  j  |
 ƒ } | j
 ƒ  } t | ƒ d k rJ| j d ƒ } xP t d t | ƒ d ƒ D]3 } | | | d !\ } } | j | | d f ƒ qWqJn  t | | |  | | ƒ d S(   sä  Rolls back the transaction contained in the given file

    Reads the entries in the specified file, and the corresponding
    '*.backupfiles' file, to recover from an incomplete transaction.

    * `file`: a file containing a list of entries, specifying where
    to truncate each file.  The file should contain a list of
    file offset pairs, delimited by newlines. The corresponding
    '*.backupfiles' file should contain a list of file backupfile
    pairs, delimited by  .
    t    s    couldn't read journal entry %r!
s   %s.backupfilesi    i   i   N(   R1   t	   readlinesR   t   splitR   t   intR4   t
   ValueErrorR    R   t   readRE   t   xrangeR%   (   R   R2   R   R   R   R   t   linest   lR   R   R0   RG   t   partst   iR"   (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   rollback  s*    
 
 (   t   i18nR    R   R   R   R	   RZ   R%   t   objectR&   Rf   (    (    (    s9   /usr/lib/python2.7/dist-packages/mercurial/transaction.pyt   <module>   s   	#Ó                                                                                                                                                                           usr/lib/python2.7/dist-packages/mercurial/treediscovery.py                                          0100644 0000000 0000000 00000012154 12413056314 022341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # discovery.py - protocol changeset discovery functions
#
# Copyright 2010 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from node import nullid, short
from i18n import _
import util, error

def findcommonincoming(repo, remote, heads=None, force=False):
    """Return a tuple (common, fetch, heads) used to identify the common
    subset of nodes between repo and remote.

    "common" is a list of (at least) the heads of the common subset.
    "fetch" is a list of roots of the nodes that would be incoming, to be
      supplied to changegroupsubset.
    "heads" is either the supplied heads, or else the remote's heads.
    """

    knownnode = repo.changelog.hasnode
    search = []
    fetch = set()
    seen = set()
    seenbranch = set()
    base = set()

    if not heads:
        heads = remote.heads()

    if repo.changelog.tip() == nullid:
        base.add(nullid)
        if heads != [nullid]:
            return [nullid], [nullid], list(heads)
        return [nullid], [], heads

    # assume we're closer to the tip than the root
    # and start by examining the heads
    repo.ui.status(_("searching for changes\n"))

    unknown = []
    for h in heads:
        if not knownnode(h):
            unknown.append(h)
        else:
            base.add(h)

    if not unknown:
        return list(base), [], list(heads)

    req = set(unknown)
    reqcnt = 0

    # search through remote branches
    # a 'branch' here is a linear segment of history, with four parts:
    # head, root, first parent, second parent
    # (a branch always has two parents (or none) by definition)
    unknown = util.deque(remote.branches(unknown))
    while unknown:
        r = []
        while unknown:
            n = unknown.popleft()
            if n[0] in seen:
                continue

            repo.ui.debug("examining %s:%s\n"
                          % (short(n[0]), short(n[1])))
            if n[0] == nullid: # found the end of the branch
                pass
            elif n in seenbranch:
                repo.ui.debug("branch already found\n")
                continue
            elif n[1] and knownnode(n[1]): # do we know the base?
                repo.ui.debug("found incomplete branch %s:%s\n"
                              % (short(n[0]), short(n[1])))
                search.append(n[0:2]) # schedule branch range for scanning
                seenbranch.add(n)
            else:
                if n[1] not in seen and n[1] not in fetch:
                    if knownnode(n[2]) and knownnode(n[3]):
                        repo.ui.debug("found new changeset %s\n" %
                                      short(n[1]))
                        fetch.add(n[1]) # earliest unknown
                    for p in n[2:4]:
                        if knownnode(p):
                            base.add(p) # latest known

                for p in n[2:4]:
                    if p not in req and not knownnode(p):
                        r.append(p)
                        req.add(p)
            seen.add(n[0])

        if r:
            reqcnt += 1
            repo.ui.progress(_('searching'), reqcnt, unit=_('queries'))
            repo.ui.debug("request %d: %s\n" %
                        (reqcnt, " ".join(map(short, r))))
            for p in xrange(0, len(r), 10):
                for b in remote.branches(r[p:p + 10]):
                    repo.ui.debug("received %s:%s\n" %
                                  (short(b[0]), short(b[1])))
                    unknown.append(b)

    # do binary search on the branches we found
    while search:
        newsearch = []
        reqcnt += 1
        repo.ui.progress(_('searching'), reqcnt, unit=_('queries'))
        for n, l in zip(search, remote.between(search)):
            l.append(n[1])
            p = n[0]
            f = 1
            for i in l:
                repo.ui.debug("narrowing %d:%d %s\n" % (f, len(l), short(i)))
                if knownnode(i):
                    if f <= 2:
                        repo.ui.debug("found new branch changeset %s\n" %
                                          short(p))
                        fetch.add(p)
                        base.add(i)
                    else:
                        repo.ui.debug("narrowed branch search to %s:%s\n"
                                      % (short(p), short(i)))
                        newsearch.append((p, i))
                    break
                p, f = i, f * 2
            search = newsearch

    # sanity check our fetch list
    for f in fetch:
        if knownnode(f):
            raise error.RepoError(_("already have changeset ")
                                  + short(f[:4]))

    base = list(base)
    if base == [nullid]:
        if force:
            repo.ui.warn(_("warning: repository is unrelated\n"))
        else:
            raise util.Abort(_("repository is unrelated"))

    repo.ui.debug("found new changesets starting at " +
                 " ".join([short(f) for f in fetch]) + "\n")

    repo.ui.progress(_('searching'), None)
    repo.ui.debug("%d total queries\n" % reqcnt)

    return base, list(fetch), heads
                                                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python2.7/dist-packages/mercurial/treediscovery.pyc                                         0100644 0000000 0000000 00000007263 13077704337 022525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sQ   d  d l  m Z m Z d  d l m Z d  d l Z d  d l Z d e d „ Z	 d S(   iÿÿÿÿ(   t   nullidt   short(   t   _Nc         C   s¼  |  j  j } g  } t ƒ  } t ƒ  } t ƒ  } t ƒ  }	 | sK | j ƒ  } n  |  j  j ƒ  t k r¥ |	 j t ƒ | t g k r• t g t g t | ƒ f St g g  | f S|  j j	 t
 d ƒ ƒ g  }
 x7 | D]/ } | | ƒ sê |
 j | ƒ qÈ |	 j | ƒ qÈ W|
 st |	 ƒ g  t | ƒ f St |
 ƒ } d } t j | j |
 ƒ ƒ }
 xý|
 rCg  } x|
 rX|
 j ƒ  } | d | k r~qVn  |  j j d t | d ƒ t | d ƒ f ƒ | d t k r¿n…| | k rá|  j j d ƒ qVnc| d rM| | d ƒ rM|  j j d t | d ƒ t | d ƒ f ƒ | j | d d !ƒ | j | ƒ n÷ | d | k rö| d | k rö| | d ƒ r¿| | d ƒ r¿|  j j d	 t | d ƒ ƒ | j | d ƒ n  x4 | d d
 !D]" } | | ƒ rÍ|	 j | ƒ qÍqÍWn  xK | d d
 !D]< } | | k r| | ƒ r| j | ƒ | j | ƒ qqW| j | d ƒ qVW| rG| d 7} |  j j t
 d ƒ | d t
 d ƒ ƒ|  j j d | d j t t | ƒ ƒ f ƒ xƒ t d t | ƒ d ƒ D]f } x] | j | | | d !ƒ D]A } |  j j d t | d ƒ t | d ƒ f ƒ |
 j | ƒ qôWqÓWqGqGWxf| r¬g  } | d 7} |  j j t
 d ƒ | d t
 d ƒ ƒx$t | | j | ƒ ƒ D]
\ } } | j | d ƒ | d } d } xÔ | D]Ì } |  j j d | t | ƒ t | ƒ f ƒ | | ƒ rŠ| d k rM|  j j d t | ƒ ƒ | j | ƒ |	 j | ƒ n9 |  j j d t | ƒ t | ƒ f ƒ | j | | f ƒ Pn  | | d } } qÏW| } q›WqGWx@ | D]8 } | | ƒ r´t j t
 d ƒ t | d
  ƒ ƒ ‚ q´q´Wt |	 ƒ }	 |	 t g k rB| r*|  j j t
 d ƒ ƒ qBt j t
 d ƒ ƒ ‚ n  |  j j d d j g  | D] } t | ƒ ^ q[ƒ d ƒ |  j j t
 d ƒ d ƒ |  j j d | ƒ |	 t | ƒ | f S(   sn  Return a tuple (common, fetch, heads) used to identify the common
    subset of nodes between repo and remote.

    "common" is a list of (at least) the heads of the common subset.
    "fetch" is a list of roots of the nodes that would be incoming, to be
      supplied to changegroupsubset.
    "heads" is either the supplied heads, or else the remote's heads.
    s   searching for changes
i    s   examining %s:%s
i   s   branch already found
s   found incomplete branch %s:%s
i   i   s   found new changeset %s
i   t	   searchingt   unitt   queriess   request %d: %s
t    i
   s   received %s:%s
s   narrowing %d:%d %s
s   found new branch changeset %s
s    narrowed branch search to %s:%s
s   already have changeset s!   warning: repository is unrelated
s   repository is unrelateds!   found new changesets starting at s   
s   %d total queries
N(   t	   changelogt   hasnodet   sett   headst   tipR    t   addt   listt   uit   statusR   t   appendt   utilt   dequet   branchest   popleftt   debugR   t   progresst   joint   mapt   xranget   lent   zipt   betweent   errort	   RepoErrort   warnt   Abortt   None(   t   repot   remoteR
   t   forcet	   knownnodet   searcht   fetcht   seent
   seenbrancht   baset   unknownt   ht   reqt   reqcntt   rt   nt   pt   bt	   newsearcht   lt   ft   i(    (    s;   /usr/lib/python2.7/dist-packages/mercurial/treediscovery.pyt   findcommonincoming   sÊ    
						""  
% !"	
%%
)	1(
   t   nodeR    R   t   i18nR   R   R   R!   t   FalseR7   (    (    (    s;   /usr/lib/python2.7/dist-packages/mercurial/treediscovery.pyt   <module>   s                                                                                                                                                                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/ui.py                                                     0100644 0000000 0000000 00000075527 12712351006 020102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # ui.py - user interface bits for mercurial
#
# Copyright 2005-2007 Matt Mackall <mpm@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

from i18n import _
import errno, getpass, os, socket, sys, tempfile, traceback
import config, scmutil, util, error, formatter
from node import hex

class ui(object):
    def __init__(self, src=None):
        # _buffers: used for temporary capture of output
        self._buffers = []
        # _bufferstates: Should the temporary capture includes stderr
        self._bufferstates = []
        self.quiet = self.verbose = self.debugflag = self.tracebackflag = False
        self._reportuntrusted = True
        self._ocfg = config.config() # overlay
        self._tcfg = config.config() # trusted
        self._ucfg = config.config() # untrusted
        self._trustusers = set()
        self._trustgroups = set()
        self.callhooks = True

        if src:
            self.fout = src.fout
            self.ferr = src.ferr
            self.fin = src.fin

            self._tcfg = src._tcfg.copy()
            self._ucfg = src._ucfg.copy()
            self._ocfg = src._ocfg.copy()
            self._trustusers = src._trustusers.copy()
            self._trustgroups = src._trustgroups.copy()
            self.environ = src.environ
            self.callhooks = src.callhooks
            self.fixconfig()
        else:
            self.fout = sys.stdout
            self.ferr = sys.stderr
            self.fin = sys.stdin

            # shared read-only environment
            self.environ = os.environ
            # we always trust global config files
            for f in scmutil.rcpath():
                self.readconfig(f, trust=True)

    def copy(self):
        return self.__class__(self)

    def formatter(self, topic, opts):
        return formatter.formatter(self, topic, opts)

    def _trusted(self, fp, f):
        st = util.fstat(fp)
        if util.isowner(st):
            return True

        tusers, tgroups = self._trustusers, self._trustgroups
        if '*' in tusers or '*' in tgroups:
            return True

        user = util.username(st.st_uid)
        group = util.groupname(st.st_gid)
        if user in tusers or group in tgroups or user == util.username():
            return True

        if self._reportuntrusted:
            self.warn(_('not trusting file %s from untrusted '
                        'user %s, group %s\n') % (f, user, group))
        return False

    def readconfig(self, filename, root=None, trust=False,
                   sections=None, remap=None):
        try:
            fp = open(filename)
        except IOError:
            if not sections: # ignore unless we were looking for something
                return
            raise

        cfg = config.config()
        trusted = sections or trust or self._trusted(fp, filename)

        try:
            cfg.read(filename, fp, sections=sections, remap=remap)
            fp.close()
        except error.ConfigError, inst:
            if trusted:
                raise
            self.warn(_("ignored: %s\n") % str(inst))

        if self.plain():
            for k in ('debug', 'fallbackencoding', 'quiet', 'slash',
                      'logtemplate', 'style',
                      'traceback', 'verbose'):
                if k in cfg['ui']:
                    del cfg['ui'][k]
            for k, v in cfg.items('defaults'):
                del cfg['defaults'][k]
        # Don't remove aliases from the configuration if in the exceptionlist
        if self.plain('alias'):
            for k, v in cfg.items('alias'):
                del cfg['alias'][k]

        if trusted:
            self._tcfg.update(cfg)
            self._tcfg.update(self._ocfg)
        self._ucfg.update(cfg)
        self._ucfg.update(self._ocfg)

        if root is None:
            root = os.path.expanduser('~')
        self.fixconfig(root=root)

    def fixconfig(self, root=None, section=None):
        if section in (None, 'paths'):
            # expand vars and ~
            # translate paths relative to root (or home) into absolute paths
            root = root or os.getcwd()
            for c in self._tcfg, self._ucfg, self._ocfg:
                for n, p in c.items('paths'):
                    if not p:
                        continue
                    if '%%' in p:
                        self.warn(_("(deprecated '%%' in path %s=%s from %s)\n")
                                  % (n, p, self.configsource('paths', n)))
                        p = p.replace('%%', '%')
                    p = util.expandpath(p)
                    if not util.hasscheme(p) and not os.path.isabs(p):
                        p = os.path.normpath(os.path.join(root, p))
                    c.set("paths", n, p)

        if section in (None, 'ui'):
            # update ui options
            self.debugflag = self.configbool('ui', 'debug')
            self.verbose = self.debugflag or self.configbool('ui', 'verbose')
            self.quiet = not self.debugflag and self.configbool('ui', 'quiet')
            if self.verbose and self.quiet:
                self.quiet = self.verbose = False
            self._reportuntrusted = self.debugflag or self.configbool("ui",
                "report_untrusted", True)
            self.tracebackflag = self.configbool('ui', 'traceback', False)

        if section in (None, 'trusted'):
            # update trust information
            self._trustusers.update(self.configlist('trusted', 'users'))
            self._trustgroups.update(self.configlist('trusted', 'groups'))

    def backupconfig(self, section, item):
        return (self._ocfg.backup(section, item),
                self._tcfg.backup(section, item),
                self._ucfg.backup(section, item),)
    def restoreconfig(self, data):
        self._ocfg.restore(data[0])
        self._tcfg.restore(data[1])
        self._ucfg.restore(data[2])

    def setconfig(self, section, name, value, source=''):
        for cfg in (self._ocfg, self._tcfg, self._ucfg):
            cfg.set(section, name, value, source)
        self.fixconfig(section=section)

    def _data(self, untrusted):
        return untrusted and self._ucfg or self._tcfg

    def configsource(self, section, name, untrusted=False):
        return self._data(untrusted).source(section, name) or 'none'

    def config(self, section, name, default=None, untrusted=False):
        if isinstance(name, list):
            alternates = name
        else:
            alternates = [name]

        for n in alternates:
            value = self._data(untrusted).get(section, n, None)
            if value is not None:
                name = n
                break
        else:
            value = default

        if self.debugflag and not untrusted and self._reportuntrusted:
            for n in alternates:
                uvalue = self._ucfg.get(section, n)
                if uvalue is not None and uvalue != value:
                    self.debug("ignoring untrusted configuration option "
                               "%s.%s = %s\n" % (section, n, uvalue))
        return value

    def configpath(self, section, name, default=None, untrusted=False):
        'get a path config item, expanded relative to repo root or config file'
        v = self.config(section, name, default, untrusted)
        if v is None:
            return None
        if not os.path.isabs(v) or "://" not in v:
            src = self.configsource(section, name, untrusted)
            if ':' in src:
                base = os.path.dirname(src.rsplit(':')[0])
                v = os.path.join(base, os.path.expanduser(v))
        return v

    def configbool(self, section, name, default=False, untrusted=False):
        """parse a configuration element as a boolean

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'true', 'yes')
        >>> u.configbool(s, 'true')
        True
        >>> u.setconfig(s, 'false', 'no')
        >>> u.configbool(s, 'false')
        False
        >>> u.configbool(s, 'unknown')
        False
        >>> u.configbool(s, 'unknown', True)
        True
        >>> u.setconfig(s, 'invalid', 'somevalue')
        >>> u.configbool(s, 'invalid')
        Traceback (most recent call last):
            ...
        ConfigError: foo.invalid is not a boolean ('somevalue')
        """

        v = self.config(section, name, None, untrusted)
        if v is None:
            return default
        if isinstance(v, bool):
            return v
        b = util.parsebool(v)
        if b is None:
            raise error.ConfigError(_("%s.%s is not a boolean ('%s')")
                                    % (section, name, v))
        return b

    def configint(self, section, name, default=None, untrusted=False):
        """parse a configuration element as an integer

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'int1', '42')
        >>> u.configint(s, 'int1')
        42
        >>> u.setconfig(s, 'int2', '-42')
        >>> u.configint(s, 'int2')
        -42
        >>> u.configint(s, 'unknown', 7)
        7
        >>> u.setconfig(s, 'invalid', 'somevalue')
        >>> u.configint(s, 'invalid')
        Traceback (most recent call last):
            ...
        ConfigError: foo.invalid is not an integer ('somevalue')
        """

        v = self.config(section, name, None, untrusted)
        if v is None:
            return default
        try:
            return int(v)
        except ValueError:
            raise error.ConfigError(_("%s.%s is not an integer ('%s')")
                                    % (section, name, v))

    def configbytes(self, section, name, default=0, untrusted=False):
        """parse a configuration element as a quantity in bytes

        Units can be specified as b (bytes), k or kb (kilobytes), m or
        mb (megabytes), g or gb (gigabytes).

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'val1', '42')
        >>> u.configbytes(s, 'val1')
        42
        >>> u.setconfig(s, 'val2', '42.5 kb')
        >>> u.configbytes(s, 'val2')
        43520
        >>> u.configbytes(s, 'unknown', '7 MB')
        7340032
        >>> u.setconfig(s, 'invalid', 'somevalue')
        >>> u.configbytes(s, 'invalid')
        Traceback (most recent call last):
            ...
        ConfigError: foo.invalid is not a byte quantity ('somevalue')
        """

        value = self.config(section, name)
        if value is None:
            if not isinstance(default, str):
                return default
            value = default
        try:
            return util.sizetoint(value)
        except error.ParseError:
            raise error.ConfigError(_("%s.%s is not a byte quantity ('%s')")
                                    % (section, name, value))

    def configlist(self, section, name, default=None, untrusted=False):
        """parse a configuration element as a list of comma/space separated
        strings

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'list1', 'this,is "a small" ,test')
        >>> u.configlist(s, 'list1')
        ['this', 'is', 'a small', 'test']
        """

        def _parse_plain(parts, s, offset):
            whitespace = False
            while offset < len(s) and (s[offset].isspace() or s[offset] == ','):
                whitespace = True
                offset += 1
            if offset >= len(s):
                return None, parts, offset
            if whitespace:
                parts.append('')
            if s[offset] == '"' and not parts[-1]:
                return _parse_quote, parts, offset + 1
            elif s[offset] == '"' and parts[-1][-1] == '\\':
                parts[-1] = parts[-1][:-1] + s[offset]
                return _parse_plain, parts, offset + 1
            parts[-1] += s[offset]
            return _parse_plain, parts, offset + 1

        def _parse_quote(parts, s, offset):
            if offset < len(s) and s[offset] == '"': # ""
                parts.append('')
                offset += 1
                while offset < len(s) and (s[offset].isspace() or
                        s[offset] == ','):
                    offset += 1
                return _parse_plain, parts, offset

            while offset < len(s) and s[offset] != '"':
                if (s[offset] == '\\' and offset + 1 < len(s)
                        and s[offset + 1] == '"'):
                    offset += 1
                    parts[-1] += '"'
                else:
                    parts[-1] += s[offset]
                offset += 1

            if offset >= len(s):
                real_parts = _configlist(parts[-1])
                if not real_parts:
                    parts[-1] = '"'
                else:
                    real_parts[0] = '"' + real_parts[0]
                    parts = parts[:-1]
                    parts.extend(real_parts)
                return None, parts, offset

            offset += 1
            while offset < len(s) and s[offset] in [' ', ',']:
                offset += 1

            if offset < len(s):
                if offset + 1 == len(s) and s[offset] == '"':
                    parts[-1] += '"'
                    offset += 1
                else:
                    parts.append('')
            else:
                return None, parts, offset

            return _parse_plain, parts, offset

        def _configlist(s):
            s = s.rstrip(' ,')
            if not s:
                return []
            parser, parts, offset = _parse_plain, [''], 0
            while parser:
                parser, parts, offset = parser(parts, s, offset)
            return parts

        result = self.config(section, name, untrusted=untrusted)
        if result is None:
            result = default or []
        if isinstance(result, basestring):
            result = _configlist(result.lstrip(' ,\n'))
            if result is None:
                result = default or []
        return result

    def has_section(self, section, untrusted=False):
        '''tell whether section exists in config.'''
        return section in self._data(untrusted)

    def configitems(self, section, untrusted=False):
        items = self._data(untrusted).items(section)
        if self.debugflag and not untrusted and self._reportuntrusted:
            for k, v in self._ucfg.items(section):
                if self._tcfg.get(section, k) != v:
                    self.debug("ignoring untrusted configuration option "
                               "%s.%s = %s\n" % (section, k, v))
        return items

    def walkconfig(self, untrusted=False):
        cfg = self._data(untrusted)
        for section in cfg.sections():
            for name, value in self.configitems(section, untrusted):
                yield section, name, value

    def plain(self, feature=None):
        '''is plain mode active?

        Plain mode means that all configuration variables which affect
        the behavior and output of Mercurial should be
        ignored. Additionally, the output should be stable,
        reproducible and suitable for use in scripts or applications.

        The only way to trigger plain mode is by setting either the
        `HGPLAIN' or `HGPLAINEXCEPT' environment variables.

        The return value can either be
        - False if HGPLAIN is not set, or feature is in HGPLAINEXCEPT
        - True otherwise
        '''
        if 'HGPLAIN' not in os.environ and 'HGPLAINEXCEPT' not in os.environ:
            return False
        exceptions = os.environ.get('HGPLAINEXCEPT', '').strip().split(',')
        if feature and exceptions:
            return feature not in exceptions
        return True

    def username(self):
        """Return default username to be used in commits.

        Searched in this order: $HGUSER, [ui] section of hgrcs, $EMAIL
        and stop searching if one of these is set.
        If not found and ui.askusername is True, ask the user, else use
        ($LOGNAME or $USER or $LNAME or $USERNAME) + "@full.hostname".
        """
        user = os.environ.get("HGUSER")
        if user is None:
            user = self.config("ui", ["username", "user"])
            if user is not None:
                user = os.path.expandvars(user)
        if user is None:
            user = os.environ.get("EMAIL")
        if user is None and self.configbool("ui", "askusername"):
            user = self.prompt(_("enter a commit username:"), default=None)
        if user is None and not self.interactive():
            try:
                user = '%s@%s' % (util.getuser(), socket.getfqdn())
                self.warn(_("no username found, using '%s' instead\n") % user)
            except KeyError:
                pass
        if not user:
            raise util.Abort(_('no username supplied'),
                             hint=_('use "hg config --edit" '
                                    'to set your username'))
        if "\n" in user:
            raise util.Abort(_("username %s contains a newline\n") % repr(user))
        return user

    def shortuser(self, user):
        """Return a short representation of a user name or email address."""
        if not self.verbose:
            user = util.shortuser(user)
        return user

    def expandpath(self, loc, default=None):
        """Return repository location relative to cwd or from [paths]"""
        if util.hasscheme(loc) or os.path.isdir(os.path.join(loc, '.hg')):
            return loc

        path = self.config('paths', loc)
        if not path and default is not None:
            path = self.config('paths', default)
        return path or loc

    def pushbuffer(self, error=False):
        """install a buffer to capture standar output of the ui object

        If error is True, the error output will be captured too."""
        self._buffers.append([])
        self._bufferstates.append(error)

    def popbuffer(self, labeled=False):
        '''pop the last buffer and return the buffered output

        If labeled is True, any labels associated with buffered
        output will be handled. By default, this has no effect
        on the output returned, but extensions and GUI tools may
        handle this argument and returned styled output. If output
        is being buffered so it can be captured and parsed or
        processed, labeled should not be set to True.
        '''
        self._bufferstates.pop()
        return "".join(self._buffers.pop())

    def write(self, *args, **opts):
        '''write args to output

        By default, this method simply writes to the buffer or stdout,
        but extensions or GUI tools may override this method,
        write_err(), popbuffer(), and label() to style output from
        various parts of hg.

        An optional keyword argument, "label", can be passed in.
        This should be a string containing label names separated by
        space. Label names take the form of "topic.type". For example,
        ui.debug() issues a label of "ui.debug".

        When labeling output for a specific command, a label of
        "cmdname.type" is recommended. For example, status issues
        a label of "status.modified" for modified files.
        '''
        if self._buffers:
            self._buffers[-1].extend([str(a) for a in args])
        else:
            for a in args:
                self.fout.write(str(a))

    def write_err(self, *args, **opts):
        try:
            if self._bufferstates and self._bufferstates[-1]:
                return self.write(*args, **opts)
            if not getattr(self.fout, 'closed', False):
                self.fout.flush()
            for a in args:
                self.ferr.write(str(a))
            # stderr may be buffered under win32 when redirected to files,
            # including stdout.
            if not getattr(self.ferr, 'closed', False):
                self.ferr.flush()
        except IOError, inst:
            if inst.errno not in (errno.EPIPE, errno.EIO, errno.EBADF):
                raise

    def flush(self):
        try: self.fout.flush()
        except (IOError, ValueError): pass
        try: self.ferr.flush()
        except (IOError, ValueError): pass

    def _isatty(self, fh):
        if self.configbool('ui', 'nontty', False):
            return False
        return util.isatty(fh)

    def interactive(self):
        '''is interactive input allowed?

        An interactive session is a session where input can be reasonably read
        from `sys.stdin'. If this function returns false, any attempt to read
        from stdin should fail with an error, unless a sensible default has been
        specified.

        Interactiveness is triggered by the value of the `ui.interactive'
        configuration variable or - if it is unset - when `sys.stdin' points
        to a terminal device.

        This function refers to input only; for output, see `ui.formatted()'.
        '''
        i = self.configbool("ui", "interactive", None)
        if i is None:
            # some environments replace stdin without implementing isatty
            # usually those are non-interactive
            return self._isatty(self.fin)

        return i

    def termwidth(self):
        '''how wide is the terminal in columns?
        '''
        if 'COLUMNS' in os.environ:
            try:
                return int(os.environ['COLUMNS'])
            except ValueError:
                pass
        return util.termwidth()

    def formatted(self):
        '''should formatted output be used?

        It is often desirable to format the output to suite the output medium.
        Examples of this are truncating long lines or colorizing messages.
        However, this is not often not desirable when piping output into other
        utilities, e.g. `grep'.

        Formatted output is triggered by the value of the `ui.formatted'
        configuration variable or - if it is unset - when `sys.stdout' points
        to a terminal device. Please note that `ui.formatted' should be
        considered an implementation detail; it is not intended for use outside
        Mercurial or its extensions.

        This function refers to output only; for input, see `ui.interactive()'.
        This function always returns false when in plain mode, see `ui.plain()'.
        '''
        if self.plain():
            return False

        i = self.configbool("ui", "formatted", None)
        if i is None:
            # some environments replace stdout without implementing isatty
            # usually those are non-interactive
            return self._isatty(self.fout)

        return i

    def _readline(self, prompt=''):
        if self._isatty(self.fin):
            try:
                # magically add command line editing support, where
                # available
                import readline
                # force demandimport to really load the module
                readline.read_history_file
                # windows sometimes raises something other than ImportError
            except Exception:
                pass

        # call write() so output goes through subclassed implementation
        # e.g. color extension on Windows
        self.write(prompt)

        # instead of trying to emulate raw_input, swap (self.fin,
        # self.fout) with (sys.stdin, sys.stdout)
        oldin = sys.stdin
        oldout = sys.stdout
        sys.stdin = self.fin
        sys.stdout = self.fout
        line = raw_input(' ')
        sys.stdin = oldin
        sys.stdout = oldout

        # When stdin is in binary mode on Windows, it can cause
        # raw_input() to emit an extra trailing carriage return
        if os.linesep == '\r\n' and line and line[-1] == '\r':
            line = line[:-1]
        return line

    def prompt(self, msg, default="y"):
        """Prompt user with msg, read response.
        If ui is not interactive, the default is returned.
        """
        if not self.interactive():
            self.write(msg, ' ', default, "\n")
            return default
        try:
            r = self._readline(self.label(msg, 'ui.prompt'))
            if not r:
                return default
            return r
        except EOFError:
            raise util.Abort(_('response expected'))

    @staticmethod
    def extractchoices(prompt):
        """Extract prompt message and list of choices from specified prompt.

        This returns tuple "(message, choices)", and "choices" is the
        list of tuple "(response character, text without &)".
        """
        parts = prompt.split('$$')
        msg = parts[0].rstrip(' ')
        choices = [p.strip(' ') for p in parts[1:]]
        return (msg,
                [(s[s.index('&') + 1].lower(), s.replace('&', '', 1))
                 for s in choices])

    def promptchoice(self, prompt, default=0):
        """Prompt user with a message, read response, and ensure it matches
        one of the provided choices. The prompt is formatted as follows:

           "would you like fries with that (Yn)? $$ &Yes $$ &No"

        The index of the choice is returned. Responses are case
        insensitive. If ui is not interactive, the default is
        returned.
        """

        msg, choices = self.extractchoices(prompt)
        resps = [r for r, t in choices]
        while True:
            r = self.prompt(msg, resps[default])
            if r.lower() in resps:
                return resps.index(r.lower())
            self.write(_("unrecognized response\n"))

    def getpass(self, prompt=None, default=None):
        if not self.interactive():
            return default
        try:
            self.write_err(self.label(prompt or _('password: '), 'ui.prompt'))
            # disable getpass() only if explicitly specified. it's still valid
            # to interact with tty even if fin is not a tty.
            if self.configbool('ui', 'nontty'):
                return self.fin.readline().rstrip('\n')
            else:
                return getpass.getpass('')
        except EOFError:
            raise util.Abort(_('response expected'))
    def status(self, *msg, **opts):
        '''write status message to output (if ui.quiet is False)

        This adds an output label of "ui.status".
        '''
        if not self.quiet:
            opts['label'] = opts.get('label', '') + ' ui.status'
            self.write(*msg, **opts)
    def warn(self, *msg, **opts):
        '''write warning message to output (stderr)

        This adds an output label of "ui.warning".
        '''
        opts['label'] = opts.get('label', '') + ' ui.warning'
        self.write_err(*msg, **opts)
    def note(self, *msg, **opts):
        '''write note to output (if ui.verbose is True)

        This adds an output label of "ui.note".
        '''
        if self.verbose:
            opts['label'] = opts.get('label', '') + ' ui.note'
            self.write(*msg, **opts)
    def debug(self, *msg, **opts):
        '''write debug message to output (if ui.debugflag is True)

        This adds an output label of "ui.debug".
        '''
        if self.debugflag:
            opts['label'] = opts.get('label', '') + ' ui.debug'
            self.write(*msg, **opts)
    def edit(self, text, user, extra={}):
        (fd, name) = tempfile.mkstemp(prefix="hg-editor-", suffix=".txt",
                                      text=True)
        try:
            f = os.fdopen(fd, "w")
            f.write(text)
            f.close()

            environ = {'HGUSER': user}
            if 'transplant_source' in extra:
                environ.update({'HGREVISION': hex(extra['transplant_source'])})
            for label in ('source', 'rebase_source'):
                if label in extra:
                    environ.update({'HGREVISION': extra[label]})
                    break

            editor = self.geteditor()

            util.system("%s \"%s\"" % (editor, name),
                        environ=environ,
                        onerr=util.Abort, errprefix=_("edit failed"),
                        out=self.fout)

            f = open(name)
            t = f.read()
            f.close()
        finally:
            os.unlink(name)

        return t

    def traceback(self, exc=None, force=False):
        '''print exception traceback if traceback printing enabled or forced.
        only to call in exception handler. returns true if traceback
        printed.'''
        if self.tracebackflag or force:
            if exc is None:
                exc = sys.exc_info()
            cause = getattr(exc[1], 'cause', None)

            if cause is not None:
                causetb = traceback.format_tb(cause[2])
                exctb = traceback.format_tb(exc[2])
                exconly = traceback.format_exception_only(cause[0], cause[1])

                # exclude frame where 'exc' was chained and rethrown from exctb
                self.write_err('Traceback (most recent call last):\n',
                               ''.join(exctb[:-1]),
                               ''.join(causetb),
                               ''.join(exconly))
            else:
                traceback.print_exception(exc[0], exc[1], exc[2],
                                          file=self.ferr)
        return self.tracebackflag or force

    def geteditor(self):
        '''return editor to use'''
        if sys.platform == 'plan9':
            # vi is the MIPS instruction simulator on Plan 9. We
            # instead default to E to plumb commit messages to
            # avoid confusion.
            editor = 'E'
        else:
            editor = 'sensible-editor'
        return (os.environ.get("HGEDITOR") or
                self.config("ui", "editor") or
                os.environ.get("VISUAL") or
                os.environ.get("EDITOR", editor))

    def progress(self, topic, pos, item="", unit="", total=None):
        '''show a progress message

        With stock hg, this is simply a debug message that is hidden
        by default, but with extensions or GUI tools it may be
        visible. 'topic' is the current operation, 'item' is a
        non-numeric marker of the current position (i.e. the currently
        in-process file), 'pos' is the current numeric position (i.e.
        revision, bytes, etc.), unit is a corresponding unit label,
        and total is the highest expected pos.

        Multiple nested topics may be active at a time.

        All topics should be marked closed by setting pos to None at
        termination.
        '''

        if pos is None or not self.debugflag:
            return

        if unit:
            unit = ' ' + unit
        if item:
            item = ' ' + item

        if total:
            pct = 100.0 * pos / total
            self.debug('%s:%s %s/%s%s (%4.2f%%)\n'
                     % (topic, item, pos, total, unit, pct))
        else:
            self.debug('%s:%s %s%s\n' % (topic, item, pos, unit))

    def log(self, service, *msg, **opts):
        '''hook for logging facility extensions

        service should be a readily-identifiable subsystem, which will
        allow filtering.
        message should be a newline-terminated string to log.
        '''
        pass

    def label(self, msg, label):
        '''style msg based on supplied label

        Like ui.write(), this just returns msg unchanged, but extensions
        and GUI tools can override it to allow styling output without
        writing it.

        ui.write(s, 'label') is equivalent to
        ui.write(ui.label(s, 'label')).
        '''
        return msg
                                                                                                                                                                         usr/lib/python2.7/dist-packages/mercurial/ui.pyc                                                    0100644 0000000 0000000 00000073460 13077704337 020255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ò)Wc           @   sÊ   d  d l  m Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l Z d  d l Z d  d l Z d  d l m Z d e f d „  ƒ  YZ d S(   iÿÿÿÿ(   t   _N(   t   hext   uic           B   s3  e  Z d3 d  „ Z d „  Z d „  Z d „  Z d3 e d3 d3 d „ Z d3 d3 d „ Z	 d „  Z
 d „  Z d d	 „ Z d
 „  Z e d „ Z d3 e d „ Z d3 e d „ Z e e d „ Z d3 e d „ Z d e d „ Z d3 e d „ Z e d „ Z e d „ Z e d „ Z d3 d „ Z d „  Z d „  Z d3 d „ Z e d „ Z e d „ Z d „  Z d „  Z d „  Z  d „  Z! d  „  Z" d! „  Z# d" „  Z$ d d# „ Z% d$ d% „ Z& e' d& „  ƒ Z( d d' „ Z) d3 d3 d( „ Z* d) „  Z+ d* „  Z, d+ „  Z- d, „  Z. i  d- „ Z/ d3 e d. „ Z0 d/ „  Z1 d d d3 d0 „ Z2 d1 „  Z3 d2 „  Z4 RS(4   c         C   sŽ  g  |  _  g  |  _ t |  _ |  _ |  _ |  _ t |  _ t	 j	 ƒ  |  _
 t	 j	 ƒ  |  _ t	 j	 ƒ  |  _ t ƒ  |  _ t ƒ  |  _ t |  _ | r0| j |  _ | j |  _ | j |  _ | j j ƒ  |  _ | j j ƒ  |  _ | j
 j ƒ  |  _
 | j j ƒ  |  _ | j j ƒ  |  _ | j |  _ | j |  _ |  j ƒ  nZ t j |  _ t j |  _ t j |  _ t j |  _ x' t j ƒ  D] } |  j | d t ƒqmWd  S(   Nt   trust(   t   _bufferst   _bufferstatest   Falset   quiett   verboset	   debugflagt   tracebackflagt   Truet   _reportuntrustedt   configt   _ocfgt   _tcfgt   _ucfgt   sett   _trustuserst   _trustgroupst	   callhookst   foutt   ferrt   fint   copyt   environt	   fixconfigt   syst   stdoutt   stderrt   stdint   ost   scmutilt   rcpatht
   readconfig(   t   selft   srct   f(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   __init__   s8    				c         C   s   |  j  |  ƒ S(   N(   t	   __class__(   R#   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR   4   s    c         C   s   t  j  |  | | ƒ S(   N(   t	   formatter(   R#   t   topict   opts(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR(   7   s    c         C   sÓ   t  j | ƒ } t  j | ƒ r" t S|  j |  j } } d | k sM d | k rQ t St  j | j ƒ } t  j | j	 ƒ } | | k sŸ | | k sŸ | t  j ƒ  k r£ t S|  j
 rÏ |  j t d ƒ | | | f ƒ n  t S(   Nt   *s6   not trusting file %s from untrusted user %s, group %s
(   t   utilt   fstatt   isownerR   R   R   t   usernamet   st_uidt	   groupnamet   st_gidR   t   warnR    R   (   R#   t   fpR%   t   stt   tuserst   tgroupst   usert   group(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   _trusted:   s    *	c         C   sñ  y t  | ƒ } Wn t k
 r0 | s* d  S‚  n Xt j ƒ  } | pX | pX |  j | | ƒ } y* | j | | d | d | ƒ| j ƒ  Wn? t j k
 rÆ }	 | r¦ ‚  n  |  j t	 d ƒ t
 |	 ƒ ƒ n X|  j ƒ  r0x, d D]$ }
 |
 | d k rÚ | d |
 =qÚ qÚ Wx+ | j d ƒ D] \ }
 } | d |
 =qWn  |  j d ƒ rmx+ | j d ƒ D] \ }
 } | d |
 =qOWn  | r™|  j j | ƒ |  j j |  j ƒ n  |  j j | ƒ |  j j |  j ƒ | d  k rÝt j j d ƒ } n  |  j d | ƒ d  S(   Nt   sectionst   remaps   ignored: %s
t   debugt   fallbackencodingR   t   slasht   logtemplatet   stylet	   tracebackR   R   t   defaultst   aliast   ~t   root(   s   debugR>   s   quiets   slashR@   RA   s	   tracebacks   verbose(   t   opent   IOErrorR   R:   t   readt   closet   errort   ConfigErrorR3   R    t   strt   plaint   itemsR   t   updateR   R   t   NoneR   t   patht
   expanduserR   (   R#   t   filenameRF   R   R;   R<   R4   t   cfgt   trustedt   instt   kt   v(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR"   M   sD    ! 
c      	   C   s0  | d k r&| p t j ƒ  } x|  j |  j |  j f D]è } xß | j d ƒ D]Î \ } } | se qM n  d | k r² |  j t d ƒ | | |  j	 d | ƒ f ƒ | j
 d d ƒ } n  t j | ƒ } t j | ƒ rt j j | ƒ rt j j t j j | | ƒ ƒ } n  | j d | | ƒ qM Wq7 Wn  | d k rå|  j d d ƒ |  _ |  j p_|  j d d ƒ |  _ |  j o~|  j d d ƒ |  _ |  j r©|  j r©t |  _ |  _ n  |  j pÄ|  j d d	 t ƒ |  _ |  j d d
 t ƒ |  _ n  | d k r,|  j j |  j d d ƒ ƒ |  j j |  j d d ƒ ƒ n  d  S(   Nt   pathss   %%s(   (deprecated '%%' in path %s=%s from %s)
t   %R   R=   R   R   t   report_untrustedRB   RV   t   userst   groups(   Ns   paths(   Ns   ui(   Ns   trusted(   RQ   R   t   getcwdR   R   R   RO   R3   R    t   configsourcet   replaceR,   t
   expandpatht	   hasschemeRR   t   isabst   normpatht   joinR   t
   configboolR	   R   R   R   R   R   R
   R   RP   t
   configlistR   (   R#   RF   t   sectiont   ct   nt   p(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR   x   s4    #$c         C   s:   |  j  j | | ƒ |  j j | | ƒ |  j j | | ƒ f S(   N(   R   t   backupR   R   (   R#   Ri   t   item(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   backupconfigš   s    c         C   s@   |  j  j | d ƒ |  j j | d ƒ |  j j | d ƒ d  S(   Ni    i   i   (   R   t   restoreR   R   (   R#   t   data(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   restoreconfigž   s    t    c         C   sM   x6 |  j  |  j |  j f D] } | j | | | | ƒ q W|  j d | ƒ d  S(   NRi   (   R   R   R   R   R   (   R#   Ri   t   namet   valuet   sourceRU   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt	   setconfig£   s    c         C   s   | r |  j  p |  j S(   N(   R   R   (   R#   t	   untrusted(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   _data¨   s    c         C   s   |  j  | ƒ j | | ƒ p d S(   Nt   none(   Ry   Rv   (   R#   Ri   Rt   Rx   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR`   «   s    c   	      C   sç   t  | t ƒ r | } n	 | g } xH | D]: } |  j | ƒ j | | d  ƒ } | d  k	 r( | } Pq( q( W| } |  j rã | rã |  j rã x[ | D]P } |  j j | | ƒ } | d  k	 rŒ | | k rŒ |  j d | | | f ƒ qŒ qŒ Wn  | S(   Ns3   ignoring untrusted configuration option %s.%s = %s
(	   t
   isinstancet   listRy   t   getRQ   R	   R   R   R=   (	   R#   Ri   Rt   t   defaultRx   t
   alternatesRk   Ru   t   uvalue(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR   ®   s     			c         C   s²   |  j  | | | | ƒ } | d k r( d St j j | ƒ sG d | k r® |  j | | | ƒ } d | k r® t j j | j d ƒ d ƒ } t j j | t j j	 | ƒ ƒ } q® n  | S(   sE   get a path config item, expanded relative to repo root or config files   ://t   :i    N(
   R   RQ   R   RR   Rd   R`   t   dirnamet   rsplitRf   RS   (   R#   Ri   Rt   R~   Rx   RY   R$   t   base(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt
   configpathÄ   s    'c         C   s   |  j  | | d | ƒ } | d k r( | St | t ƒ r; | St j | ƒ } | d k r{ t j t d ƒ | | | f ƒ ‚ n  | S(   sP  parse a configuration element as a boolean

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'true', 'yes')
        >>> u.configbool(s, 'true')
        True
        >>> u.setconfig(s, 'false', 'no')
        >>> u.configbool(s, 'false')
        False
        >>> u.configbool(s, 'unknown')
        False
        >>> u.configbool(s, 'unknown', True)
        True
        >>> u.setconfig(s, 'invalid', 'somevalue')
        >>> u.configbool(s, 'invalid')
        Traceback (most recent call last):
            ...
        ConfigError: foo.invalid is not a boolean ('somevalue')
        s   %s.%s is not a boolean ('%s')N(	   R   RQ   R{   t   boolR,   t	   parseboolRK   RL   R    (   R#   Ri   Rt   R~   Rx   RY   t   b(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRg   Ð   s    c         C   sp   |  j  | | d | ƒ } | d k r( | Sy t | ƒ SWn3 t k
 rk t j t d ƒ | | | f ƒ ‚ n Xd S(   s  parse a configuration element as an integer

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'int1', '42')
        >>> u.configint(s, 'int1')
        42
        >>> u.setconfig(s, 'int2', '-42')
        >>> u.configint(s, 'int2')
        -42
        >>> u.configint(s, 'unknown', 7)
        7
        >>> u.setconfig(s, 'invalid', 'somevalue')
        >>> u.configint(s, 'invalid')
        Traceback (most recent call last):
            ...
        ConfigError: foo.invalid is not an integer ('somevalue')
        s   %s.%s is not an integer ('%s')N(   R   RQ   t   intt
   ValueErrorRK   RL   R    (   R#   Ri   Rt   R~   Rx   RY   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt	   configintð   s    i    c         C   sˆ   |  j  | | ƒ } | d k r: t | t ƒ s1 | S| } n  y t j | ƒ SWn6 t j k
 rƒ t j t	 d ƒ | | | f ƒ ‚ n Xd S(   s©  parse a configuration element as a quantity in bytes

        Units can be specified as b (bytes), k or kb (kilobytes), m or
        mb (megabytes), g or gb (gigabytes).

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'val1', '42')
        >>> u.configbytes(s, 'val1')
        42
        >>> u.setconfig(s, 'val2', '42.5 kb')
        >>> u.configbytes(s, 'val2')
        43520
        >>> u.configbytes(s, 'unknown', '7 MB')
        7340032
        >>> u.setconfig(s, 'invalid', 'somevalue')
        >>> u.configbytes(s, 'invalid')
        Traceback (most recent call last):
            ...
        ConfigError: foo.invalid is not a byte quantity ('somevalue')
        s#   %s.%s is not a byte quantity ('%s')N(
   R   RQ   R{   RM   R,   t	   sizetointRK   t
   ParseErrorRL   R    (   R#   Ri   Rt   R~   Rx   Ru   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   configbytes  s    	c            s¬   ‡ ‡ f d †  ‰ ‡  ‡ f d †  ‰ ‡ f d †  ‰  |  j  | | d | ƒ} | d k rf | p` g  } n  t | t ƒ r¨ ˆ  | j d ƒ ƒ } | d k r¨ | pŸ g  } q¨ n  | S(   s  parse a configuration element as a list of comma/space separated
        strings

        >>> u = ui(); s = 'foo'
        >>> u.setconfig(s, 'list1', 'this,is "a small" ,test')
        >>> u.configlist(s, 'list1')
        ['this', 'is', 'a small', 'test']
        c            s$  t  } xF | t | ƒ k  rN | | j ƒ  s; | | d k rN t } | d 7} q	 W| t | ƒ k rn d  |  | f S| r„ |  j d ƒ n  | | d k r° |  d r° ˆ |  | d f S| | d k rÿ |  d d d k rÿ |  d d  | | |  d <ˆ  |  | d f S|  d c | | 7<ˆ  |  | d f S(   Nt   ,i   Rs   t   "iÿÿÿÿs   \(   R   t   lent   isspaceR   RQ   t   append(   t   partst   st   offsett
   whitespace(   t   _parse_plaint   _parse_quote(    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR˜   7  s    5$c            sN  | t  | ƒ k  r‰ | | d k r‰ |  j d ƒ | d 7} x@ | t  | ƒ k  r{ | | j ƒ  sn | | d k r{ | d 7} q< Wˆ |  | f Sx› | t  | ƒ k  r&| | d k r&| | d k r| d t  | ƒ k  r| | d d k r| d 7} |  d c d 7<n |  d c | | 7<| d 7} qŒ W| t  | ƒ k r’ˆ  |  d ƒ } | s\d |  d <n) d | d | d <|  d  }  |  j | ƒ d  |  | f S| d 7} x0 | t  | ƒ k  rÎ| | d	 k rÎ| d 7} qŸW| t  | ƒ k  r4| d t  | ƒ k r$| | d k r$|  d c d 7<| d 7} qA|  j d ƒ n d  |  | f Sˆ |  | f S(
   NR   Rs   i   R   s   \iÿÿÿÿi    t    (   Rš   R   (   R‘   R“   R’   t   extendRQ   (   R”   R•   R–   t
   real_parts(   t   _configlistR˜   (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR™   H  s@    "
%%&


%&c            s\   |  j  d ƒ }  |  s g  Sˆ  d g d } } } x% | rW | | |  | ƒ \ } } } q3 W| S(   Ns    ,Rs   i    (   t   rstrip(   R•   t   parserR”   R–   (   R˜   (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR   s  s    	Rx   s    ,
N(   R   RQ   R{   t
   basestringt   lstrip(   R#   Ri   Rt   R~   Rx   t   result(    (   R   R˜   R™   s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRh   -  s    
+	c         C   s   | |  j  | ƒ k S(   s&   tell whether section exists in config.(   Ry   (   R#   Ri   Rx   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   has_section…  s    c         C   s“   |  j  | ƒ j | ƒ } |  j r | r |  j r x[ |  j j | ƒ D]D \ } } |  j j | | ƒ | k rD |  j d | | | f ƒ qD qD Wn  | S(   Ns3   ignoring untrusted configuration option %s.%s = %s
(   Ry   RO   R	   R   R   R   R}   R=   (   R#   Ri   Rx   RO   RX   RY   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   configitems‰  s    	c         c   s[   |  j  | ƒ } xE | j ƒ  D]7 } x. |  j | | ƒ D] \ } } | | | f Vq5 Wq Wd  S(   N(   Ry   R;   R¤   (   R#   Rx   RU   Ri   Rt   Ru   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt
   walkconfig’  s    c         C   s`   d t  j k r" d t  j k r" t St  j j d d ƒ j ƒ  j d ƒ } | r\ | r\ | | k St S(   s'  is plain mode active?

        Plain mode means that all configuration variables which affect
        the behavior and output of Mercurial should be
        ignored. Additionally, the output should be stable,
        reproducible and suitable for use in scripts or applications.

        The only way to trigger plain mode is by setting either the
        `HGPLAIN' or `HGPLAINEXCEPT' environment variables.

        The return value can either be
        - False if HGPLAIN is not set, or feature is in HGPLAINEXCEPT
        - True otherwise
        t   HGPLAINt   HGPLAINEXCEPTRs   R   (   R   R   R   R}   t   stript   splitR   (   R#   t   featuret
   exceptions(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRN   ˜  s    $
c         C   sz  t  j j d ƒ } | d k rZ |  j d d d g ƒ } | d k	 rZ t  j j | ƒ } qZ n  | d k r{ t  j j d ƒ } n  | d k r· |  j d d ƒ r· |  j t	 d ƒ d d ƒ} n  | d k r|  j
 ƒ  ry7 d	 t j ƒ  t j ƒ  f } |  j t	 d
 ƒ | ƒ Wqt k
 rqXn  | sHt j t	 d ƒ d t	 d ƒ ƒ‚ n  d | k rvt j t	 d ƒ t | ƒ ƒ ‚ n  | S(   sA  Return default username to be used in commits.

        Searched in this order: $HGUSER, [ui] section of hgrcs, $EMAIL
        and stop searching if one of these is set.
        If not found and ui.askusername is True, ask the user, else use
        ($LOGNAME or $USER or $LNAME or $USERNAME) + "@full.hostname".
        t   HGUSERR   R/   R8   t   EMAILt   askusernames   enter a commit username:R~   s   %s@%ss&   no username found, using '%s' instead
s   no username suppliedt   hints+   use "hg config --edit" to set your usernames   
s   username %s contains a newline
N(   R   R   R}   RQ   R   RR   t
   expandvarsRg   t   promptR    t   interactiveR,   t   getusert   sockett   getfqdnR3   t   KeyErrort   Abortt   repr(   R#   R8   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR/   ®  s*    "c         C   s   |  j  s t j | ƒ } n  | S(   s>   Return a short representation of a user name or email address.(   R   R,   t	   shortuser(   R#   R8   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR¹   Í  s    	c         C   sx   t  j | ƒ s0 t j j t j j | d ƒ ƒ r4 | S|  j d | ƒ } | rn | d k	 rn |  j d | ƒ } n  | pw | S(   s:   Return repository location relative to cwd or from [paths]s   .hgRZ   N(   R,   Rc   R   RR   t   isdirRf   R   RQ   (   R#   t   locR~   RR   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRb   Ó  s    0c         C   s$   |  j  j g  ƒ |  j j | ƒ d S(   s}   install a buffer to capture standar output of the ui object

        If error is True, the error output will be captured too.N(   R   R“   R   (   R#   RK   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt
   pushbufferÝ  s    c         C   s#   |  j  j ƒ  d j |  j j ƒ  ƒ S(   s³  pop the last buffer and return the buffered output

        If labeled is True, any labels associated with buffered
        output will be handled. By default, this has no effect
        on the output returned, but extensions and GUI tools may
        handle this argument and returned styled output. If output
        is being buffered so it can be captured and parsed or
        processed, labeled should not be set to True.
        Rs   (   R   t   popRf   R   (   R#   t   labeled(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt	   popbufferä  s    
c         O   sd   |  j  r9 |  j  d j g  | D] } t | ƒ ^ q ƒ n' x$ | D] } |  j j t | ƒ ƒ q@ Wd S(   s½  write args to output

        By default, this method simply writes to the buffer or stdout,
        but extensions or GUI tools may override this method,
        write_err(), popbuffer(), and label() to style output from
        various parts of hg.

        An optional keyword argument, "label", can be passed in.
        This should be a string containing label names separated by
        space. Label names take the form of "topic.type". For example,
        ui.debug() issues a label of "ui.debug".

        When labeling output for a specific command, a label of
        "cmdname.type" is recommended. For example, status issues
        a label of "status.modified" for modified files.
        iÿÿÿÿN(   R   R›   RM   R   t   write(   R#   t   argsR*   t   a(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRÀ   ñ  s    	0c         O   sÜ   y› |  j  r) |  j  d r) |  j | | Ž  St |  j d t ƒ sN |  j j ƒ  n  x$ | D] } |  j j t | ƒ ƒ qU Wt |  j d t ƒ sš |  j j ƒ  n  Wn: t k
 r× } | j	 t	 j
 t	 j t	 j f k rØ ‚  qØ n Xd  S(   Niÿÿÿÿt   closed(   R   RÀ   t   getattrR   R   t   flushR   RM   RH   t   errnot   EPIPEt   EIOt   EBADF(   R#   RÁ   R*   RÂ   RW   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt	   write_err  s    !c         C   sZ   y |  j  j ƒ  Wn t t f k
 r* n Xy |  j j ƒ  Wn t t f k
 rU n Xd  S(   N(   R   RÅ   RH   RŠ   R   (   R#   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRÅ     s        c         C   s&   |  j  d d t ƒ r t St j | ƒ S(   NR   t   nontty(   Rg   R   R,   t   isatty(   R#   t   fh(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   _isatty  s    c         C   s5   |  j  d d d ƒ } | d k r1 |  j |  j ƒ S| S(   s-  is interactive input allowed?

        An interactive session is a session where input can be reasonably read
        from `sys.stdin'. If this function returns false, any attempt to read
        from stdin should fail with an error, unless a sensible default has been
        specified.

        Interactiveness is triggered by the value of the `ui.interactive'
        configuration variable or - if it is unset - when `sys.stdin' points
        to a terminal device.

        This function refers to input only; for output, see `ui.formatted()'.
        R   R²   N(   Rg   RQ   RÎ   R   (   R#   t   i(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR²   #  s    c         C   sE   d t  j k r; y t t  j d ƒ SWq; t k
 r7 q; Xn  t j ƒ  S(   s-   how wide is the terminal in columns?
        t   COLUMNS(   R   R   R‰   RŠ   R,   t	   termwidth(   R#   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRÑ   9  s    c         C   sE   |  j  ƒ  r t S|  j d d d ƒ } | d k rA |  j |  j ƒ S| S(   s*  should formatted output be used?

        It is often desirable to format the output to suite the output medium.
        Examples of this are truncating long lines or colorizing messages.
        However, this is not often not desirable when piping output into other
        utilities, e.g. `grep'.

        Formatted output is triggered by the value of the `ui.formatted'
        configuration variable or - if it is unset - when `sys.stdout' points
        to a terminal device. Please note that `ui.formatted' should be
        considered an implementation detail; it is not intended for use outside
        Mercurial or its extensions.

        This function refers to output only; for input, see `ui.interactive()'.
        This function always returns false when in plain mode, see `ui.plain()'.
        R   t	   formattedN(   RN   R   Rg   RQ   RÎ   R   (   R#   RÏ   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRÒ   C  s    c         C   sË   |  j  |  j ƒ r@ y d d  l } | j Wq@ t k
 r< q@ Xn  |  j | ƒ t j } t j } |  j t _ |  j	 t _ t
 d ƒ } | t _ | t _ t j d k rÇ | rÇ | d d k rÇ | d  } n  | S(   NiÿÿÿÿRš   s   
s   (   RÎ   R   t   readlinet   read_history_filet	   ExceptionRÀ   R   R   R   R   t	   raw_inputR   t   linesep(   R#   R±   RÓ   t   oldint   oldoutt   line(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt	   _readline_  s"    				%t   yc         C   s€   |  j  ƒ  s& |  j | d | d ƒ | Sy- |  j |  j | d ƒ ƒ } | sN | S| SWn& t k
 r{ t j t d ƒ ƒ ‚ n Xd S(   sh   Prompt user with msg, read response.
        If ui is not interactive, the default is returned.
        Rš   s   
s	   ui.prompts   response expectedN(   R²   RÀ   RÛ   t   labelt   EOFErrorR,   R·   R    (   R#   t   msgR~   t   r(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR±     s    c         C   s‘   |  j  d ƒ } | d j d ƒ } g  | d D] } | j d ƒ ^ q- } | g  | D]8 } | | j d ƒ d j ƒ  | j d d d ƒ f ^ qR f S(   sÏ   Extract prompt message and list of choices from specified prompt.

        This returns tuple "(message, choices)", and "choices" is the
        list of tuple "(response character, text without &)".
        s   $$i    Rš   i   t   &Rs   (   R©   Rž   R¨   t   indext   lowerRa   (   R±   R”   Rß   Rl   t   choicesR•   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   extractchoicesŽ  s    &c         C   s“   |  j  | ƒ \ } } g  | D] \ } } | ^ q } xX t rŽ |  j | | | ƒ } | j ƒ  | k rx | j | j ƒ  ƒ S|  j t d ƒ ƒ q7 Wd S(   se  Prompt user with a message, read response, and ensure it matches
        one of the provided choices. The prompt is formatted as follows:

           "would you like fries with that (Yn)? $$ &Yes $$ &No"

        The index of the choice is returned. Responses are case
        insensitive. If ui is not interactive, the default is
        returned.
        s   unrecognized response
N(   Rå   R   R±   Rã   Râ   RÀ   R    (   R#   R±   R~   Rß   Rä   Rà   t   tt   resps(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   promptchoiceœ  s    	c         C   s›   |  j  ƒ  s | Sy^ |  j |  j | p. t d ƒ d ƒ ƒ |  j d d ƒ r` |  j j ƒ  j d ƒ St j d ƒ SWn& t	 k
 r– t
 j t d ƒ ƒ ‚ n Xd  S(   Ns
   password: s	   ui.promptR   RË   s   
Rs   s   response expected(   R²   RÊ   RÝ   R    Rg   R   RÓ   Rž   t   getpassRÞ   R,   R·   (   R#   R±   R~   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRé   ¯  s    %c         O   s:   |  j  s6 | j d d ƒ d | d <|  j | | Ž  n  d S(   sq   write status message to output (if ui.quiet is False)

        This adds an output label of "ui.status".
        RÝ   Rs   s
    ui.statusN(   R   R}   RÀ   (   R#   Rß   R*   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   status¼  s    	c         O   s.   | j  d d ƒ d | d <|  j | | Ž  d S(   se   write warning message to output (stderr)

        This adds an output label of "ui.warning".
        RÝ   Rs   s    ui.warningN(   R}   RÊ   (   R#   Rß   R*   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR3   Ä  s    c         O   s:   |  j  r6 | j d d ƒ d | d <|  j | | Ž  n  d S(   sf   write note to output (if ui.verbose is True)

        This adds an output label of "ui.note".
        RÝ   Rs   s    ui.noteN(   R   R}   RÀ   (   R#   Rß   R*   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   noteË  s    	c         O   s:   |  j  r6 | j d d ƒ d | d <|  j | | Ž  n  d S(   sr   write debug message to output (if ui.debugflag is True)

        This adds an output label of "ui.debug".
        RÝ   Rs   s	    ui.debugN(   R	   R}   RÀ   (   R#   Rß   R*   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR=   Ó  s    	c      
   C   sB  t  j d d d d d t ƒ \ } } z	t j | d ƒ } | j | ƒ | j ƒ  i | d 6} d | k rŠ | j i t | d ƒ d	 6ƒ n  x6 d D]. } | | k r‘ | j i | | d	 6ƒ Pq‘ q‘ W|  j	 ƒ  }	 t
 j d |	 | f d | d t
 j d t d ƒ d |  j ƒt | ƒ } | j ƒ  }
 | j ƒ  Wd  t j | ƒ X|
 S(   Nt   prefixs
   hg-editor-t   suffixs   .txtt   textt   wR¬   t   transplant_sourcet
   HGREVISIONRv   t   rebase_sources   %s "%s"R   t   onerrt	   errprefixs   edit failedt   out(   s   sourceRò   (   t   tempfilet   mkstempR   R   t   fdopenRÀ   RJ   RP   R   t	   geteditorR,   t   systemR·   R    R   RG   RI   t   unlink(   R#   Rî   R8   t   extrat   fdRt   R%   R   RÝ   t   editorRæ   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   editÛ  s.    
!
c         C   sü   |  j  s | rï | d	 k r* t j ƒ  } n  t | d d d	 ƒ } | d	 k	 rÄ t j | d ƒ } t j | d ƒ } t j | d | d ƒ } |  j d d j	 | d  ƒ d j	 | ƒ d j	 | ƒ ƒ qï t j
 | d | d | d d |  j ƒn  |  j  pû | S(
   s˜   print exception traceback if traceback printing enabled or forced.
        only to call in exception handler. returns true if traceback
        printed.i   t   causei   i    s#   Traceback (most recent call last):
Rs   iÿÿÿÿt   fileN(   R
   RQ   R   t   exc_infoRÄ   RB   t	   format_tbt   format_exception_onlyRÊ   Rf   t   print_exceptionR   (   R#   t   exct   forceR   t   causetbt   exctbt   exconly(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRB   ú  s    	c         C   sg   t  j d k r d } n d } t j j d ƒ pf |  j d d ƒ pf t j j d ƒ pf t j j d | ƒ S(	   s   return editor to uset   plan9t   Es   sensible-editort   HGEDITORR   Rþ   t   VISUALt   EDITOR(   R   t   platformR   R   R}   R   (   R#   Rþ   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRù     s    	c         C   s›   | d k s |  j r d S| r- d | } n  | r@ d | } n  | rz d | | } |  j d | | | | | | f ƒ n |  j d | | | | f ƒ d S(   sx  show a progress message

        With stock hg, this is simply a debug message that is hidden
        by default, but with extensions or GUI tools it may be
        visible. 'topic' is the current operation, 'item' is a
        non-numeric marker of the current position (i.e. the currently
        in-process file), 'pos' is the current numeric position (i.e.
        revision, bytes, etc.), unit is a corresponding unit label,
        and total is the highest expected pos.

        Multiple nested topics may be active at a time.

        All topics should be marked closed by setting pos to None at
        termination.
        NRš   g      Y@s   %s:%s %s/%s%s (%4.2f%%)
s   %s:%s %s%s
(   RQ   R	   R=   (   R#   R)   t   posRn   t   unitt   totalt   pct(    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   progress   s    	c         O   s   d S(   sÌ   hook for logging facility extensions

        service should be a readily-identifiable subsystem, which will
        allow filtering.
        message should be a newline-terminated string to log.
        N(    (   R#   t   serviceRß   R*   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   log@  s    c         C   s   | S(   s%  style msg based on supplied label

        Like ui.write(), this just returns msg unchanged, but extensions
        and GUI tools can override it to allow styling output without
        writing it.

        ui.write(s, 'label') is equivalent to
        ui.write(ui.label(s, 'label')).
        (    (   R#   Rß   RÝ   (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyRÝ   I  s    
N(5   t   __name__t
   __module__RQ   R&   R   R(   R:   R   R"   R   Ro   Rr   Rw   Ry   R`   R   R…   Rg   R‹   RŽ   Rh   R£   R¤   R¥   RN   R/   R¹   Rb   R¼   R¿   RÀ   RÊ   RÅ   RÎ   R²   RÑ   RÒ   RÛ   R±   t   staticmethodRå   Rè   Ré   Rê   R3   Rë   R=   Rÿ   RB   Rù   R  R  RÝ   (    (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyR      sb   &			*"			 !X			
						
	 					 		(   t   i18nR    RÆ   Ré   R   R´   R   Rö   RB   R   R    R,   RK   R(   t   nodeR   t   objectR   (    (    (    s0   /usr/lib/python2.7/dist-packages/mercurial/ui.pyt   <module>   s   T<                                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/unionrepo.py                                              0100644 0000000 0000000 00000021004 12413056314 021462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # unionrepo.py - repository class for viewing union of repository changesets
#
# Derived from bundlerepo.py
# Copyright 2006, 2007 Benoit Boissinot <bboissin@gmail.com>
# Copyright 2013 Unity Technologies, Mads Kiilerich <madski@unity3d.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

"""Repository class for "in-memory pull" of one local repository to another,
allowing operations like diff and log with revsets.
"""

from node import nullid
from i18n import _
import os
import util, mdiff, cmdutil, scmutil
import localrepo, changelog, manifest, filelog, revlog

class unionrevlog(revlog.revlog):
    def __init__(self, opener, indexfile, revlog2, linkmapper):
        # How it works:
        # To retrieve a revision, we just need to know the node id so we can
        # look it up in revlog2.
        #
        # To differentiate a rev in the second revlog from a rev in the revlog,
        # we check revision against repotiprev.
        opener = scmutil.readonlyvfs(opener)
        revlog.revlog.__init__(self, opener, indexfile)
        self.revlog2 = revlog2

        n = len(self)
        self.repotiprev = n - 1
        self.bundlerevs = set() # used by 'bundle()' revset expression
        for rev2 in self.revlog2:
            rev = self.revlog2.index[rev2]
            # rev numbers - in revlog2, very different from self.rev
            _start, _csize, _rsize, _base, linkrev, p1rev, p2rev, node = rev

            if linkmapper is None: # link is to same revlog
                assert linkrev == rev2 # we never link back
                link = n
            else: # rev must be mapped from repo2 cl to unified cl by linkmapper
                link = linkmapper(linkrev)

            if node in self.nodemap:
                # this happens for the common revlog revisions
                self.bundlerevs.add(self.nodemap[node])
                continue

            p1node = self.revlog2.node(p1rev)
            p2node = self.revlog2.node(p2rev)

            e = (None, None, None, None,
                 link, self.rev(p1node), self.rev(p2node), node)
            self.index.insert(-1, e)
            self.nodemap[node] = n
            self.bundlerevs.add(n)
            n += 1

    def _chunk(self, rev):
        if rev <= self.repotiprev:
            return revlog.revlog._chunk(self, rev)
        return self.revlog2._chunk(self.node(rev))

    def revdiff(self, rev1, rev2):
        """return or calculate a delta between two revisions"""
        if rev1 > self.repotiprev and rev2 > self.repotiprev:
            return self.revlog2.revdiff(
                self.revlog2.rev(self.node(rev1)),
                self.revlog2.rev(self.node(rev2)))
        elif rev1 <= self.repotiprev and rev2 <= self.repotiprev:
            return self.baserevdiff(rev1, rev2)

        return mdiff.textdiff(self.revision(self.node(rev1)),
                              self.revision(self.node(rev2)))

    def revision(self, nodeorrev):
        """return an uncompressed revision of a given node or revision
        number.
        """
        if isinstance(nodeorrev, int):
            rev = nodeorrev
            node = self.node(rev)
        else:
            node = nodeorrev
            rev = self.rev(node)

        if node == nullid:
            return ""

        if rev > self.repotiprev:
            text = self.revlog2.revision(node)
            self._cache = (node, rev, text)
        else:
            text = self.baserevision(rev)
            # already cached
        return text

    def baserevision(self, nodeorrev):
        # Revlog subclasses may override 'revision' method to modify format of
        # content retrieved from revlog. To use unionrevlog with such class one
        # needs to override 'baserevision' and make more specific call here.
        return revlog.revlog.revision(self, nodeorrev)

    def baserevdiff(self, rev1, rev2):
        # Exists for the same purpose as baserevision.
        return revlog.revlog.revdiff(self, rev1, rev2)

    def addrevision(self, text, transaction, link, p1=None, p2=None, d=None):
        raise NotImplementedError
    def addgroup(self, revs, linkmapper, transaction):
        raise NotImplementedError
    def strip(self, rev, minlink):
        raise NotImplementedError
    def checksize(self):
        raise NotImplementedError

class unionchangelog(unionrevlog, changelog.changelog):
    def __init__(self, opener, opener2):
        changelog.changelog.__init__(self, opener)
        linkmapper = None
        changelog2 = changelog.changelog(opener2)
        unionrevlog.__init__(self, opener, self.indexfile, changelog2,
                             linkmapper)

    def baserevision(self, nodeorrev):
        # Although changelog doesn't override 'revision' method, some extensions
        # may replace this class with another that does. Same story with
        # manifest and filelog classes.
        return changelog.changelog.revision(self, nodeorrev)

    def baserevdiff(self, rev1, rev2):
        return changelog.changelog.revdiff(self, rev1, rev2)

class unionmanifest(unionrevlog, manifest.manifest):
    def __init__(self, opener, opener2, linkmapper):
        manifest.manifest.__init__(self, opener)
        manifest2 = manifest.manifest(opener2)
        unionrevlog.__init__(self, opener, self.indexfile, manifest2,
                             linkmapper)

    def baserevision(self, nodeorrev):
        return manifest.manifest.revision(self, nodeorrev)

    def baserevdiff(self, rev1, rev2):
        return manifest.manifest.revdiff(self, rev1, rev2)

class unionfilelog(unionrevlog, filelog.filelog):
    def __init__(self, opener, path, opener2, linkmapper, repo):
        filelog.filelog.__init__(self, opener, path)
        filelog2 = filelog.filelog(opener2, path)
        unionrevlog.__init__(self, opener, self.indexfile, filelog2,
                             linkmapper)
        self._repo = repo

    def baserevision(self, nodeorrev):
        return filelog.filelog.revision(self, nodeorrev)

    def baserevdiff(self, rev1, rev2):
        return filelog.filelog.revdiff(self, rev1, rev2)

    def _file(self, f):
        self._repo.file(f)

class unionpeer(localrepo.localpeer):
    def canpush(self):
        return False

class unionrepository(localrepo.localrepository):
    def __init__(self, ui, path, path2):
        localrepo.localrepository.__init__(self, ui, path)
        self.ui.setconfig('phases', 'publish', False, 'unionrepo')

        self._url = 'union:%s+%s' % (util.expandpath(path),
                                     util.expandpath(path2))
        self.repo2 = localrepo.localrepository(ui, path2)

    @localrepo.unfilteredpropertycache
    def changelog(self):
        return unionchangelog(self.sopener, self.repo2.sopener)

    def _clrev(self, rev2):
        """map from repo2 changelog rev to temporary rev in self.changelog"""
        node = self.repo2.changelog.node(rev2)
        return self.changelog.rev(node)

    @localrepo.unfilteredpropertycache
    def manifest(self):
        return unionmanifest(self.sopener, self.repo2.sopener,
                             self._clrev)

    def url(self):
        return self._url

    def file(self, f):
        return unionfilelog(self.sopener, f, self.repo2.sopener,
                            self._clrev, self)

    def close(self):
        self.repo2.close()

    def cancopy(self):
        return False

    def peer(self):
        return unionpeer(self)

    def getcwd(self):
        return os.getcwd() # always outside the repo

def instance(ui, path, create):
    if create:
        raise util.Abort(_('cannot create new union repository'))
    parentpath = ui.config("bundle", "mainreporoot", "")
    if not parentpath:
        # try to find the correct path to the working directory repo
        parentpath = cmdutil.findrepo(os.getcwd())
        if parentpath is None:
            parentpath = ''
    if parentpath:
        # Try to make the full path relative so we get a nice, short URL.
        # In particular, we don't want temp dir names in test outputs.
        cwd = os.getcwd()
        if parentpath == cwd:
            parentpath = ''
        else:
            cwd = os.path.join(cwd,'')
            if parentpath.startswith(cwd):
                parentpath = parentpath[len(cwd):]
    if path.startswith('union:'):
        s = path.split(":", 1)[1].split("+", 1)
        if len(s) == 1:
            repopath, repopath2 = parentpath, s[0]
        else:
            repopath, repopath2 = s
    else:
        repopath, repopath2 = parentpath, path
    return unionrepository(ui, repopath, repopath2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyc                                             0100644 0000000 0000000 00000024400 13077704337 021644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sJ  d  Z  d d l m Z d d l m Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d e j f d „  ƒ  YZ d e e j f d „  ƒ  YZ d	 e e j f d
 „  ƒ  YZ d e e j f d „  ƒ  YZ d e
 j f d „  ƒ  YZ d e
 j f d „  ƒ  YZ d „  Z d S(   s~   Repository class for "in-memory pull" of one local repository to another,
allowing operations like diff and log with revsets.
iÿÿÿÿ(   t   nullid(   t   _Nt   unionrevlogc           B   sk   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z d
 d
 d
 d „ Z	 d „  Z
 d „  Z d	 „  Z RS(   c      	   C   s†  t  j | ƒ } t j j |  | | ƒ | |  _ t |  ƒ } | d |  _ t ƒ  |  _ x,|  j D]!} |  j j	 | } | \ } }	 }
 } } } } } | d  k r¸ | | k s¯ t ‚ | } n | | ƒ } | |  j k rð |  j j |  j | ƒ q] n  |  j j | ƒ } |  j j | ƒ } d  d  d  d  | |  j | ƒ |  j | ƒ | f } |  j	 j d | ƒ | |  j | <|  j j | ƒ | d 7} q] Wd  S(   Ni   iÿÿÿÿ(   t   scmutilt   readonlyvfst   revlogt   __init__t   revlog2t   lent
   repotiprevt   sett
   bundlerevst   indext   Nonet   AssertionErrort   nodemapt   addt   nodet   revt   insert(   t   selft   openert	   indexfileR   t
   linkmappert   nt   rev2R   t   _startt   _csizet   _rsizet   _baset   linkrevt   p1revt   p2revR   t   linkt   p1nodet   p2nodet   e(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR      s0    		$c         C   s;   | |  j  k r" t j j |  | ƒ S|  j j |  j | ƒ ƒ S(   N(   R	   R   t   _chunkR   R   (   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR%   =   s    c         C   s½   | |  j  k r[ | |  j  k r[ |  j j |  j j |  j | ƒ ƒ |  j j |  j | ƒ ƒ ƒ S| |  j  k r‰ | |  j  k r‰ |  j | | ƒ St j |  j |  j | ƒ ƒ |  j |  j | ƒ ƒ ƒ S(   s1   return or calculate a delta between two revisions(	   R	   R   t   revdiffR   R   t   baserevdifft   mdifft   textdifft   revision(   R   t   rev1R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR&   B   s    	c         C   s•   t  | t ƒ r' | } |  j | ƒ } n | } |  j | ƒ } | t k rL d S| |  j k r‚ |  j j | ƒ } | | | f |  _ n |  j	 | ƒ } | S(   sT   return an uncompressed revision of a given node or revision
        number.
        t    (
   t
   isinstancet   intR   R   R    R	   R   R*   t   _cachet   baserevision(   R   t	   nodeorrevR   R   t   text(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR*   N   s    c         C   s   t  j  j |  | ƒ S(   N(   R   R*   (   R   R1   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR0   d   s    c         C   s   t  j  j |  | | ƒ S(   N(   R   R&   (   R   R+   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR'   j   s    c         C   s
   t  ‚ d  S(   N(   t   NotImplementedError(   R   R2   t   transactionR!   t   p1t   p2t   d(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   addrevisionn   s    c         C   s
   t  ‚ d  S(   N(   R3   (   R   t   revsR   R4   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   addgroupp   s    c         C   s
   t  ‚ d  S(   N(   R3   (   R   R   t   minlink(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   stripr   s    c         C   s
   t  ‚ d  S(   N(   R3   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt	   checksizet   s    N(   t   __name__t
   __module__R   R%   R&   R*   R0   R'   R   R8   R:   R<   R=   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR      s   	(							t   unionchangelogc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         C   sH   t  j  j |  | ƒ d  } t  j  | ƒ } t j |  | |  j | | ƒ d  S(   N(   t	   changelogR   R   R   R   (   R   R   t   opener2R   t
   changelog2(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR   x   s
    c         C   s   t  j  j |  | ƒ S(   N(   RA   R*   (   R   R1   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR0      s    c         C   s   t  j  j |  | | ƒ S(   N(   RA   R&   (   R   R+   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR'   …   s    (   R>   R?   R   R0   R'   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR@   w   s   		t   unionmanifestc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         C   sB   t  j  j |  | ƒ t  j  | ƒ } t j |  | |  j | | ƒ d  S(   N(   t   manifestR   R   R   (   R   R   RB   R   t	   manifest2(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR   ‰   s    c         C   s   t  j  j |  | ƒ S(   N(   RE   R*   (   R   R1   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR0      s    c         C   s   t  j  j |  | | ƒ S(   N(   RE   R&   (   R   R+   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR'   ’   s    (   R>   R?   R   R0   R'   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRD   ˆ   s   		t   unionfilelogc           B   s,   e  Z d  „  Z d „  Z d „  Z d „  Z RS(   c         C   sQ   t  j  j |  | | ƒ t  j  | | ƒ } t j |  | |  j | | ƒ | |  _ d  S(   N(   t   filelogR   R   R   t   _repo(   R   R   t   pathRB   R   t   repot   filelog2(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR   –   s
    c         C   s   t  j  j |  | ƒ S(   N(   RH   R*   (   R   R1   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR0      s    c         C   s   t  j  j |  | | ƒ S(   N(   RH   R&   (   R   R+   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR'       s    c         C   s   |  j  j | ƒ d  S(   N(   RI   t   file(   R   t   f(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   _file£   s    (   R>   R?   R   R0   R'   RO   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRG   •   s   			t	   unionpeerc           B   s   e  Z d  „  Z RS(   c         C   s   t  S(   N(   t   False(   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   canpush§   s    (   R>   R?   RR   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRP   ¦   s   t   unionrepositoryc           B   st   e  Z d  „  Z e j d „  ƒ Z d „  Z e j d „  ƒ Z d „  Z d „  Z	 d „  Z
 d „  Z d „  Z d	 „  Z RS(
   c         C   sm   t  j j |  | | ƒ |  j j d d t d ƒ d t j | ƒ t j | ƒ f |  _ t  j | | ƒ |  _	 d  S(   Nt   phasest   publisht	   unionrepos   union:%s+%s(
   t	   localrepot   localrepositoryR   t   uit	   setconfigRQ   t   utilt
   expandpatht   _urlt   repo2(   R   RY   RJ   t   path2(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyR   «   s
    c         C   s   t  |  j |  j j ƒ S(   N(   R@   t   sopenerR^   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRA   ³   s    c         C   s%   |  j  j j | ƒ } |  j j | ƒ S(   s?   map from repo2 changelog rev to temporary rev in self.changelog(   R^   RA   R   R   (   R   R   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   _clrev·   s    c         C   s   t  |  j |  j j |  j ƒ S(   N(   RD   R`   R^   Ra   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRE   ¼   s    c         C   s   |  j  S(   N(   R]   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   urlÁ   s    c         C   s"   t  |  j | |  j j |  j |  ƒ S(   N(   RG   R`   R^   Ra   (   R   RN   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRM   Ä   s    c         C   s   |  j  j ƒ  d  S(   N(   R^   t   close(   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRc   È   s    c         C   s   t  S(   N(   RQ   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   cancopyË   s    c         C   s
   t  |  ƒ S(   N(   RP   (   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   peerÎ   s    c         C   s
   t  j ƒ  S(   N(   t   ost   getcwd(   R   (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRg   Ñ   s    (   R>   R?   R   RW   t   unfilteredpropertycacheRA   Ra   RE   Rb   RM   Rc   Rd   Re   Rg   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyRS   ª   s   							c         C   sJ  | r t  j t d ƒ ƒ ‚ n  |  j d d d ƒ } | sf t j t j ƒ  ƒ } | d  k rf d } qf n  | rÇ t j ƒ  } | | k r d } qÇ t j	 j
 | d ƒ } | j | ƒ rÇ | t | ƒ } qÇ n  | j d ƒ r-| j d d ƒ d j d d ƒ } t | ƒ d k r| | d	 } } q:| \ } } n | | } } t |  | | ƒ S(
   Ns"   cannot create new union repositoryt   bundlet   mainreporootR,   s   union:t   :i   t   +i    (   R[   t   AbortR   t   configt   cmdutilt   findrepoRf   Rg   R   RJ   t   joint
   startswithR   t   splitRS   (   RY   RJ   t   createt
   parentpatht   cwdt   st   repopatht	   repopath2(    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   instanceÔ   s*    	"(   t   __doc__R   R    t   i18nR   Rf   R[   R(   Ro   R   RW   RA   RE   RH   R   R   R@   RD   RG   t	   localpeerRP   RX   RS   Rz   (    (    (    s7   /usr/lib/python2.7/dist-packages/mercurial/unionrepo.pyt   <module>   s   0<c*                                                                                                                                                                                                                                                                usr/lib/python2.7/dist-packages/mercurial/url.py                                                    0100644 0000000 0000000 00000044426 12413056314 020263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # url.py - HTTP handling for mercurial
#
# Copyright 2005, 2006, 2007, 2008 Matt Mackall <mpm@selenic.com>
# Copyright 2006, 2007 Alexis S. L. Carvalho <alexis@cecm.usp.br>
# Copyright 2006 Vadim Gelfer <vadim.gelfer@gmail.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

import urllib, urllib2, httplib, os, socket, cStringIO, base64
from i18n import _
import keepalive, util, sslutil
import httpconnection as httpconnectionmod

class passwordmgr(urllib2.HTTPPasswordMgrWithDefaultRealm):
    def __init__(self, ui):
        urllib2.HTTPPasswordMgrWithDefaultRealm.__init__(self)
        self.ui = ui

    def find_user_password(self, realm, authuri):
        authinfo = urllib2.HTTPPasswordMgrWithDefaultRealm.find_user_password(
            self, realm, authuri)
        user, passwd = authinfo
        if user and passwd:
            self._writedebug(user, passwd)
            return (user, passwd)

        if not user or not passwd:
            res = httpconnectionmod.readauthforuri(self.ui, authuri, user)
            if res:
                group, auth = res
                user, passwd = auth.get('username'), auth.get('password')
                self.ui.debug("using auth.%s.* for authentication\n" % group)
        if not user or not passwd:
            u = util.url(authuri)
            u.query = None
            if not self.ui.interactive():
                raise util.Abort(_('http authorization required for %s') %
                                 util.hidepassword(str(u)))

            self.ui.write(_("http authorization required for %s\n") %
                          util.hidepassword(str(u)))
            self.ui.write(_("realm: %s\n") % realm)
            if user:
                self.ui.write(_("user: %s\n") % user)
            else:
                user = self.ui.prompt(_("user:"), default=None)

            if not passwd:
                passwd = self.ui.getpass()

        self.add_password(realm, authuri, user, passwd)
        self._writedebug(user, passwd)
        return (user, passwd)

    def _writedebug(self, user, passwd):
        msg = _('http auth: user %s, password %s\n')
        self.ui.debug(msg % (user, passwd and '*' * len(passwd) or 'not set'))

    def find_stored_password(self, authuri):
        return urllib2.HTTPPasswordMgrWithDefaultRealm.find_user_password(
            self, None, authuri)

class proxyhandler(urllib2.ProxyHandler):
    def __init__(self, ui):
        proxyurl = ui.config("http_proxy", "host") or os.getenv('http_proxy')
        # XXX proxyauthinfo = None

        if proxyurl:
            # proxy can be proper url or host[:port]
            if not (proxyurl.startswith('http:') or
                    proxyurl.startswith('https:')):
                proxyurl = 'http://' + proxyurl + '/'
            proxy = util.url(proxyurl)
            if not proxy.user:
                proxy.user = ui.config("http_proxy", "user")
                proxy.passwd = ui.config("http_proxy", "passwd")

            # see if we should use a proxy for this url
            no_list = ["localhost", "127.0.0.1"]
            no_list.extend([p.lower() for
                            p in ui.configlist("http_proxy", "no")])
            no_list.extend([p.strip().lower() for
                            p in os.getenv("no_proxy", '').split(',')
                            if p.strip()])
            # "http_proxy.always" config is for running tests on localhost
            if ui.configbool("http_proxy", "always"):
                self.no_list = []
            else:
                self.no_list = no_list

            proxyurl = str(proxy)
            proxies = {'http': proxyurl, 'https': proxyurl}
            ui.debug('proxying through http://%s:%s\n' %
                      (proxy.host, proxy.port))
        else:
            proxies = {}

        # urllib2 takes proxy values from the environment and those
        # will take precedence if found. So, if there's a config entry
        # defining a proxy, drop the environment ones
        if ui.config("http_proxy", "host"):
            for env in ["HTTP_PROXY", "http_proxy", "no_proxy"]:
                try:
                    if env in os.environ:
                        del os.environ[env]
                except OSError:
                    pass

        urllib2.ProxyHandler.__init__(self, proxies)
        self.ui = ui

    def proxy_open(self, req, proxy, type_):
        host = req.get_host().split(':')[0]
        for e in self.no_list:
            if host == e:
                return None
            if e.startswith('*.') and host.endswith(e[2:]):
                return None
            if e.startswith('.') and host.endswith(e[1:]):
                return None

        # work around a bug in Python < 2.4.2
        # (it leaves a "\n" at the end of Proxy-authorization headers)
        baseclass = req.__class__
        class _request(baseclass):
            def add_header(self, key, val):
                if key.lower() == 'proxy-authorization':
                    val = val.strip()
                return baseclass.add_header(self, key, val)
        req.__class__ = _request

        return urllib2.ProxyHandler.proxy_open(self, req, proxy, type_)

def _gen_sendfile(orgsend):
    def _sendfile(self, data):
        # send a file
        if isinstance(data, httpconnectionmod.httpsendfile):
            # if auth required, some data sent twice, so rewind here
            data.seek(0)
            for chunk in util.filechunkiter(data):
                orgsend(self, chunk)
        else:
            orgsend(self, data)
    return _sendfile

has_https = util.safehasattr(urllib2, 'HTTPSHandler')
if has_https:
    try:
        _create_connection = socket.create_connection
    except AttributeError:
        _GLOBAL_DEFAULT_TIMEOUT = object()

        def _create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                               source_address=None):
            # lifted from Python 2.6

            msg = "getaddrinfo returns an empty list"
            host, port = address
            for res in socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM):
                af, socktype, proto, canonname, sa = res
                sock = None
                try:
                    sock = socket.socket(af, socktype, proto)
                    if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                        sock.settimeout(timeout)
                    if source_address:
                        sock.bind(source_address)
                    sock.connect(sa)
                    return sock

                except socket.error, msg:
                    if sock is not None:
                        sock.close()

            raise socket.error(msg)

class httpconnection(keepalive.HTTPConnection):
    # must be able to send big bundle as stream.
    send = _gen_sendfile(keepalive.HTTPConnection.send)

    def connect(self):
        if has_https and self.realhostport: # use CONNECT proxy
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            if _generic_proxytunnel(self):
                # we do not support client X.509 certificates
                self.sock = sslutil.ssl_wrap_socket(self.sock, None, None)
        else:
            keepalive.HTTPConnection.connect(self)

    def getresponse(self):
        proxyres = getattr(self, 'proxyres', None)
        if proxyres:
            if proxyres.will_close:
                self.close()
            self.proxyres = None
            return proxyres
        return keepalive.HTTPConnection.getresponse(self)

# general transaction handler to support different ways to handle
# HTTPS proxying before and after Python 2.6.3.
def _generic_start_transaction(handler, h, req):
    tunnel_host = getattr(req, '_tunnel_host', None)
    if tunnel_host:
        if tunnel_host[:7] not in ['http://', 'https:/']:
            tunnel_host = 'https://' + tunnel_host
        new_tunnel = True
    else:
        tunnel_host = req.get_selector()
        new_tunnel = False

    if new_tunnel or tunnel_host == req.get_full_url(): # has proxy
        u = util.url(tunnel_host)
        if new_tunnel or u.scheme == 'https': # only use CONNECT for HTTPS
            h.realhostport = ':'.join([u.host, (u.port or '443')])
            h.headers = req.headers.copy()
            h.headers.update(handler.parent.addheaders)
            return

    h.realhostport = None
    h.headers = None

def _generic_proxytunnel(self):
    proxyheaders = dict(
            [(x, self.headers[x]) for x in self.headers
             if x.lower().startswith('proxy-')])
    self.send('CONNECT %s HTTP/1.0\r\n' % self.realhostport)
    for header in proxyheaders.iteritems():
        self.send('%s: %s\r\n' % header)
    self.send('\r\n')

    # majority of the following code is duplicated from
    # httplib.HTTPConnection as there are no adequate places to
    # override functions to provide the needed functionality
    res = self.response_class(self.sock,
                              strict=self.strict,
                              method=self._method)

    while True:
        version, status, reason = res._read_status()
        if status != httplib.CONTINUE:
            break
        while True:
            skip = res.fp.readline().strip()
            if not skip:
                break
    res.status = status
    res.reason = reason.strip()

    if res.status == 200:
        while True:
            line = res.fp.readline()
            if line == '\r\n':
                break
        return True

    if version == 'HTTP/1.0':
        res.version = 10
    elif version.startswith('HTTP/1.'):
        res.version = 11
    elif version == 'HTTP/0.9':
        res.version = 9
    else:
        raise httplib.UnknownProtocol(version)

    if res.version == 9:
        res.length = None
        res.chunked = 0
        res.will_close = 1
        res.msg = httplib.HTTPMessage(cStringIO.StringIO())
        return False

    res.msg = httplib.HTTPMessage(res.fp)
    res.msg.fp = None

    # are we using the chunked-style of transfer encoding?
    trenc = res.msg.getheader('transfer-encoding')
    if trenc and trenc.lower() == "chunked":
        res.chunked = 1
        res.chunk_left = None
    else:
        res.chunked = 0

    # will the connection close at the end of the response?
    res.will_close = res._check_close()

    # do we have a Content-Length?
    # NOTE: RFC 2616, section 4.4, #3 says we ignore this if
    # transfer-encoding is "chunked"
    length = res.msg.getheader('content-length')
    if length and not res.chunked:
        try:
            res.length = int(length)
        except ValueError:
            res.length = None
        else:
            if res.length < 0:  # ignore nonsensical negative lengths
                res.length = None
    else:
        res.length = None

    # does the body have a fixed length? (of zero)
    if (status == httplib.NO_CONTENT or status == httplib.NOT_MODIFIED or
        100 <= status < 200 or # 1xx codes
        res._method == 'HEAD'):
        res.length = 0

    # if the connection remains open, and we aren't using chunked, and
    # a content-length was not provided, then assume that the connection
    # WILL close.
    if (not res.will_close and
       not res.chunked and
       res.length is None):
        res.will_close = 1

    self.proxyres = res

    return False

class httphandler(keepalive.HTTPHandler):
    def http_open(self, req):
        return self.do_open(httpconnection, req)

    def _start_transaction(self, h, req):
        _generic_start_transaction(self, h, req)
        return keepalive.HTTPHandler._start_transaction(self, h, req)

if has_https:
    class httpsconnection(httplib.HTTPSConnection):
        response_class = keepalive.HTTPResponse
        # must be able to send big bundle as stream.
        send = _gen_sendfile(keepalive.safesend)
        getresponse = keepalive.wrapgetresponse(httplib.HTTPSConnection)

        def connect(self):
            self.sock = _create_connection((self.host, self.port))

            host = self.host
            if self.realhostport: # use CONNECT proxy
                _generic_proxytunnel(self)
                host = self.realhostport.rsplit(':', 1)[0]
            self.sock = sslutil.ssl_wrap_socket(
                self.sock, self.key_file, self.cert_file,
                **sslutil.sslkwargs(self.ui, host))
            sslutil.validator(self.ui, host)(self.sock)

    class httpshandler(keepalive.KeepAliveHandler, urllib2.HTTPSHandler):
        def __init__(self, ui):
            keepalive.KeepAliveHandler.__init__(self)
            urllib2.HTTPSHandler.__init__(self)
            self.ui = ui
            self.pwmgr = passwordmgr(self.ui)

        def _start_transaction(self, h, req):
            _generic_start_transaction(self, h, req)
            return keepalive.KeepAliveHandler._start_transaction(self, h, req)

        def https_open(self, req):
            # req.get_full_url() does not contain credentials and we may
            # need them to match the certificates.
            url = req.get_full_url()
            user, password = self.pwmgr.find_stored_password(url)
            res = httpconnectionmod.readauthforuri(self.ui, url, user)
            if res:
                group, auth = res
                self.auth = auth
                self.ui.debug("using auth.%s.* for authentication\n" % group)
            else:
                self.auth = None
            return self.do_open(self._makeconnection, req)

        def _makeconnection(self, host, port=None, *args, **kwargs):
            keyfile = None
            certfile = None

            if len(args) >= 1: # key_file
                keyfile = args[0]
            if len(args) >= 2: # cert_file
                certfile = args[1]
            args = args[2:]

            # if the user has specified different key/cert files in
            # hgrc, we prefer these
            if self.auth and 'key' in self.auth and 'cert' in self.auth:
                keyfile = self.auth['key']
                certfile = self.auth['cert']

            conn = httpsconnection(host, port, keyfile, certfile, *args,
                                   **kwargs)
            conn.ui = self.ui
            return conn

class httpdigestauthhandler(urllib2.HTTPDigestAuthHandler):
    def __init__(self, *args, **kwargs):
        urllib2.HTTPDigestAuthHandler.__init__(self, *args, **kwargs)
        self.retried_req = None

    def reset_retry_count(self):
        # Python 2.6.5 will call this on 401 or 407 errors and thus loop
        # forever. We disable reset_retry_count completely and reset in
        # http_error_auth_reqed instead.
        pass

    def http_error_auth_reqed(self, auth_header, host, req, headers):
        # Reset the retry counter once for each request.
        if req is not self.retried_req:
            self.retried_req = req
            self.retried = 0
        # In python < 2.5 AbstractDigestAuthHandler raises a ValueError if
        # it doesn't know about the auth type requested. This can happen if
        # somebody is using BasicAuth and types a bad password.
        try:
            return urllib2.HTTPDigestAuthHandler.http_error_auth_reqed(
                        self, auth_header, host, req, headers)
        except ValueError, inst:
            arg = inst.args[0]
            if arg.startswith("AbstractDigestAuthHandler doesn't know "):
                return
            raise

class httpbasicauthhandler(urllib2.HTTPBasicAuthHandler):
    def __init__(self, *args, **kwargs):
        self.auth = None
        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)
        self.retried_req = None

    def http_request(self, request):
        if self.auth:
            request.add_unredirected_header(self.auth_header, self.auth)

        return request

    def https_request(self, request):
        if self.auth:
            request.add_unredirected_header(self.auth_header, self.auth)

        return request

    def reset_retry_count(self):
        # Python 2.6.5 will call this on 401 or 407 errors and thus loop
        # forever. We disable reset_retry_count completely and reset in
        # http_error_auth_reqed instead.
        pass

    def http_error_auth_reqed(self, auth_header, host, req, headers):
        # Reset the retry counter once for each request.
        if req is not self.retried_req:
            self.retried_req = req
            self.retried = 0
        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(
                        self, auth_header, host, req, headers)

    def retry_http_basic_auth(self, host, req, realm):
        user, pw = self.passwd.find_user_password(realm, req.get_full_url())
        if pw is not None:
            raw = "%s:%s" % (user, pw)
            auth = 'Basic %s' % base64.b64encode(raw).strip()
            if req.headers.get(self.auth_header, None) == auth:
                return None
            self.auth = auth
            req.add_unredirected_header(self.auth_header, auth)
            return self.parent.open(req)
        else:
            return None

handlerfuncs = []

def opener(ui, authinfo=None):
    '''
    construct an opener suitable for urllib2
    authinfo will be added to the password manager
    '''
    if ui.configbool('ui', 'usehttp2', False):
        handlers = [httpconnectionmod.http2handler(ui, passwordmgr(ui))]
    else:
        handlers = [httphandler()]
        if has_https:
            handlers.append(httpshandler(ui))

    handlers.append(proxyhandler(ui))

    passmgr = passwordmgr(ui)
    if authinfo is not None:
        passmgr.add_password(*authinfo)
        user, passwd = authinfo[2:4]
        ui.debug('http auth: user %s, password %s\n' %
                 (user, passwd and '*' * len(passwd) or 'not set'))

    handlers.extend((httpbasicauthhandler(passmgr),
                     httpdigestauthhandler(passmgr)))
    handlers.extend([h(ui, passmgr) for h in handlerfuncs])
    opener = urllib2.build_opener(*handlers)

    # 1.0 here is the _protocol_ version
    opener.addheaders = [('User-agent', 'mercurial/proto-1.0')]
    opener.addheaders.append(('Accept', 'application/mercurial-0.1'))
    return opener

def open(ui, url_, data=None):
    u = util.url(url_)
    if u.scheme:
        u.scheme = u.scheme.lower()
        url_, authinfo = u.authinfo()
    else:
        path = util.normpath(os.path.abspath(url_))
        url_ = 'file://' + urllib.pathname2url(path)
        authinfo = None
    return opener(ui, authinfo).open(url_, data)
                                                                                                                                                                                                                                          usr/lib/python2.7/dist-packages/mercurial/url.pyc                                                   0100644 0000000 0000000 00000042016 13077704337 020433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   sü  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z d  d l	 Z	 d  d l
 Z
 d  d l Z d  d l Z d e j f d „  ƒ  YZ d e j f d „  ƒ  YZ d „  Z e
 j e d ƒ Z e r#y e j Z Wq#e k
 re ƒ  Z e d d	 „ Z q#Xn  d
 e	 j f d „  ƒ  YZ d „  Z d „  Z d e	 j f d „  ƒ  YZ e r¨d e j  f d „  ƒ  YZ! d e	 j" e j# f d „  ƒ  YZ$ n  d e j% f d „  ƒ  YZ& d e j' f d „  ƒ  YZ( g  Z) d d „ Z* d d „ Z+ d S(   iÿÿÿÿN(   t   _t   passwordmgrc           B   s,   e  Z d  „  Z d „  Z d „  Z d „  Z RS(   c         C   s   t  j j |  ƒ | |  _ d  S(   N(   t   urllib2t   HTTPPasswordMgrWithDefaultRealmt   __init__t   ui(   t   selfR   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR      s    c   
      C   sê  t  j j |  | | ƒ } | \ } } | rJ | rJ |  j | | ƒ | | f S| sX | r» t j |  j | | ƒ } | r» | \ } } | j d ƒ | j d ƒ } } |  j j d | ƒ q» n  | sÉ | rºt	 j
 | ƒ }	 d  |	 _ |  j j ƒ  st	 j t d ƒ t	 j t |	 ƒ ƒ ƒ ‚ n  |  j j t d ƒ t	 j t |	 ƒ ƒ ƒ |  j j t d ƒ | ƒ | r|  j j t d ƒ | ƒ n |  j j t d ƒ d	 d  ƒ} | sº|  j j ƒ  } qºn  |  j | | | | ƒ |  j | | ƒ | | f S(
   Nt   usernamet   passwords#   using auth.%s.* for authentication
s"   http authorization required for %ss#   http authorization required for %s
s
   realm: %s
s	   user: %s
s   user:t   default(   R   R   t   find_user_passwordt   _writedebugt   httpconnectionmodt   readauthforuriR   t   gett   debugt   utilt   urlt   Nonet   queryt   interactivet   AbortR    t   hidepasswordt   strt   writet   promptt   getpasst   add_password(
   R   t   realmt   authurit   authinfot   usert   passwdt   rest   groupt   autht   u(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR
      s:    	
	c         C   s@   t  d ƒ } |  j j | | | r1 d t | ƒ p4 d f ƒ d  S(   Ns    http auth: user %s, password %s
t   *s   not set(   R    R   R   t   len(   R   R   R    t   msg(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR   8   s    c         C   s   t  j j |  d  | ƒ S(   N(   R   R   R
   R   (   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   find_stored_password<   s    	(   t   __name__t
   __module__R   R
   R   R(   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR      s   		$	t   proxyhandlerc           B   s   e  Z d  „  Z d „  Z RS(   c         C   s  | j  d d ƒ p t j d ƒ } | r| j d ƒ pB | j d ƒ sV d | d } n  t j | ƒ } | j s› | j  d d ƒ | _ | j  d d ƒ | _ n  d	 d
 g } | j g  | j	 d d ƒ D] } | j
 ƒ  ^ qÀ ƒ | j g  t j d d ƒ j d ƒ D]$ } | j ƒ  rû | j ƒ  j
 ƒ  ^ qû ƒ | j d d ƒ rDg  |  _ n	 | |  _ t | ƒ } i | d 6| d 6} | j d | j | j f ƒ n i  } | j  d d ƒ röxN d d d g D]: } y  | t j k rÚt j | =n  Wqµt k
 rîqµXqµWn  t j j |  | ƒ | |  _ d  S(   Nt
   http_proxyt   hosts   http:s   https:s   http://t   /R   R    t	   localhosts	   127.0.0.1t   not   no_proxyt    t   ,t   alwayst   httpt   httpss   proxying through http://%s:%s
t
   HTTP_PROXY(   t   configt   ost   getenvt
   startswithR   R   R   R    t   extendt
   configlistt   lowert   splitt   stript
   configboolt   no_listR   R   R-   t   portt   environt   OSErrorR   t   ProxyHandlerR   R   (   R   R   t   proxyurlt   proxyRB   t   pt   proxiest   env(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR   A   s@    !		)	%		c            sÐ   | j  ƒ  j d ƒ d } xm |  j D]b } | | k r9 d  S| j d ƒ r_ | j | d ƒ r_ d  S| j d ƒ r# | j | d ƒ r# d  Sq# W| j ‰  d ˆ  f ‡  f d †  ƒ  Y} | | _ t j j	 |  | | | ƒ S(	   Nt   :i    s   *.i   t   .i   t   _requestc              s   e  Z ‡  f d  †  Z RS(   c            s4   | j  ƒ  d k r! | j ƒ  } n  ˆ  j |  | | ƒ S(   Ns   proxy-authorization(   R>   R@   t
   add_header(   R   t   keyt   val(   t	   baseclass(    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRO      s    (   R)   R*   RO   (    (   RR   (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRN   ~   s   (
   t   get_hostR?   RB   R   R;   t   endswitht	   __class__R   RF   t
   proxy_open(   R   t   reqRH   t   type_R-   t   eRN   (    (   RR   s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRV   q   s    ""		(   R)   R*   R   RV   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR+   @   s   	0c            s   ‡  f d †  } | S(   Nc            sZ   t  | t j ƒ rI | j d ƒ x4 t j | ƒ D] } ˆ  |  | ƒ q/ Wn ˆ  |  | ƒ d  S(   Ni    (   t
   isinstanceR   t   httpsendfilet   seekR   t   filechunkiter(   R   t   datat   chunk(   t   orgsend(    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt	   _sendfileˆ   s
    (    (   R`   Ra   (    (   R`   s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   _gen_sendfile‡   s    	t   HTTPSHandlerc         C   sô   d } |  \ } } xÌ t  j | | d t  j ƒ D]¯ } | \ } } }	 }
 } d  } y\ t  j  | | |	 ƒ } | t k	 rƒ | j | ƒ n  | r™ | j | ƒ n  | j | ƒ | SWq. t  j k
 rÜ } | d  k	 rÝ | j	 ƒ  qÝ q. Xq. Wt  j | ƒ ‚ d  S(   Ns!   getaddrinfo returns an empty listi    (
   t   sockett   getaddrinfot   SOCK_STREAMR   t   _GLOBAL_DEFAULT_TIMEOUTt
   settimeoutt   bindt   connectt   errort   close(   t   addresst   timeoutt   source_addressR'   R-   RC   R!   t   aft   socktypet   protot	   canonnamet   sat   sock(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   _create_connectionš   s"    "t   httpconnectionc           B   s,   e  Z e e j j ƒ Z d  „  Z d „  Z RS(   c         C   s‡   t  rs |  j rs t j t j t j ƒ |  _ |  j j |  j |  j f ƒ t	 |  ƒ rƒ t
 j |  j d  d  ƒ |  _ qƒ n t j j |  ƒ d  S(   N(   t	   has_httpst   realhostportRd   t   AF_INETRf   Ru   Rj   R-   RC   t   _generic_proxytunnelt   sslutilt   ssl_wrap_socketR   t	   keepalivet   HTTPConnection(   R   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRj   ¶   s    !c         C   sK   t  |  d d  ƒ } | r; | j r. |  j ƒ  n  d  |  _ | St j j |  ƒ S(   Nt   proxyres(   t   getattrR   t
   will_closeRl   R€   R~   R   t   getresponse(   R   R€   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRƒ   À   s    		(   R)   R*   Rb   R~   R   t   sendRj   Rƒ   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRw   ²   s   	
c         C   sõ   t  | d d  ƒ } | r> | d  d	 k r5 d | } n  t } n | j ƒ  } t } | sh | | j ƒ  k rß t j | ƒ } | sŒ | j d k rß d j	 | j
 | j p¤ d g ƒ | _ | j j ƒ  | _ | j j |  j j ƒ d  Sn  d  | _ d  | _ d  S(
   Nt   _tunnel_hosti   s   http://s   https:/s   https://R6   RL   t   443(   s   http://s   https:/(   R   R   t   Truet   get_selectort   Falset   get_full_urlR   R   t   schemet   joinR-   RC   Ry   t   headerst   copyt   updatet   parentt
   addheaders(   t   handlert   hRW   t   tunnel_hostt
   new_tunnelR$   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   _generic_start_transactionË   s     	$	c         C   s‹  t  g  |  j D]. } | j ƒ  j d ƒ r | |  j | f ^ q ƒ } |  j d |  j ƒ x% | j ƒ  D] } |  j d | ƒ qe W|  j d ƒ |  j |  j d |  j	 d |  j
 ƒ} x^ t r| j ƒ  \ } } } | t j k râ Pn  x) t r| j j ƒ  j ƒ  } | så Pqå qå Wq´ W| | _ | j ƒ  | _ | j d k rix) t rd| j j ƒ  }	 |	 d k r<Pq<q<Wt S| d k rd	 | _ nB | j d
 ƒ rœd | _ n' | d k r´d | _ n t j | ƒ ‚ | j d k r	d  | _ d | _ d | _ t j t j ƒ  ƒ | _ t St j | j ƒ | _ d  | j _ | j j d ƒ }
 |
 ri|
 j ƒ  d k rid | _ d  | _  n	 d | _ | j! ƒ  | _ | j j d ƒ } | rñ| j rñy t" | ƒ | _ Wn t# k
 rÒd  | _ qúX| j d k  rúd  | _ qún	 d  | _ | t j$ k sC| t j% k sCd | k o/d k  n sC| j
 d k rOd | _ n  | j r~| j r~| j d  k r~d | _ n  | |  _& t S(   Ns   proxy-s   CONNECT %s HTTP/1.0
s   %s: %s
s   
t   strictt   methodiÈ   s   HTTP/1.0i
   s   HTTP/1.i   s   HTTP/0.9i	   i    i   s   transfer-encodingt   chunkeds   content-lengthid   t   HEAD('   t   dictR   R>   R;   R„   Ry   t	   iteritemst   response_classRu   R—   t   _methodR‡   t   _read_statust   httplibt   CONTINUEt   fpt   readlineR@   t   statust   reasont   versiont   UnknownProtocolR   t   lengthR™   R‚   t   HTTPMessaget	   cStringIOt   StringIOR'   R‰   t	   getheadert
   chunk_leftt   _check_closet   intt
   ValueErrort
   NO_CONTENTt   NOT_MODIFIEDR€   (   R   t   xt   proxyheaderst   headerR!   R¦   R¤   R¥   t   skipt   linet   trencR¨   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR{   à   s„    1											

	t   httphandlerc           B   s   e  Z d  „  Z d „  Z RS(   c         C   s   |  j  t | ƒ S(   N(   t   do_openRw   (   R   RW   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt	   http_openB  s    c         C   s&   t  |  | | ƒ t j j |  | | ƒ S(   N(   R–   R~   t   HTTPHandlert   _start_transaction(   R   R“   RW   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR½   E  s    (   R)   R*   R»   R½   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR¹   A  s   	t   httpsconnectionc           B   s;   e  Z e j Z e e j ƒ Z e j e	 j
 ƒ Z d  „  Z RS(   c         C   s¦   t  |  j |  j f ƒ |  _ |  j } |  j rS t |  ƒ |  j j d d ƒ d } n  t j |  j |  j	 |  j
 t j |  j | ƒ  |  _ t j |  j | ƒ |  j ƒ d  S(   NRL   i   i    (   Rv   R-   RC   Ru   Ry   R{   t   rsplitR|   R}   t   key_filet	   cert_filet	   sslkwargsR   t	   validator(   R   R-   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRj   P  s    		
(   R)   R*   R~   t   HTTPResponseR   Rb   t   safesendR„   t   wrapgetresponseR    t   HTTPSConnectionRƒ   Rj   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR¾   J  s   	t   httpshandlerc           B   s/   e  Z d  „  Z d „  Z d „  Z d d „ Z RS(   c         C   s?   t  j j |  ƒ t j j |  ƒ | |  _ t |  j ƒ |  _ d  S(   N(   R~   t   KeepAliveHandlerR   R   Rc   R   R   t   pwmgr(   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR   ]  s    	c         C   s&   t  |  | | ƒ t j j |  | | ƒ S(   N(   R–   R~   RÉ   R½   (   R   R“   RW   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR½   c  s    c         C   sŠ   | j  ƒ  } |  j j | ƒ \ } } t j |  j | | ƒ } | rn | \ } } | |  _ |  j j d | ƒ n	 d  |  _ |  j	 |  j
 | ƒ S(   Ns#   using auth.%s.* for authentication
(   RŠ   RÊ   R(   R   R   R   R#   R   R   Rº   t   _makeconnection(   R   RW   R   R   R   R!   R"   R#   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt
   https_openg  s    		c         O   sÃ   d  } d  } t | ƒ d k r+ | d } n  t | ƒ d k rJ | d } n  | d } |  j r˜ d |  j k r˜ d |  j k r˜ |  j d } |  j d } n  t | | | | | | Ž } |  j | _ | S(   Ni   i    i   RP   t   cert(   R   R&   R#   R¾   R   (   R   R-   RC   t   argst   kwargst   keyfilet   certfilet   conn(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRË   u  s    
'	N(   R)   R*   R   R½   RÌ   R   RË   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRÈ   \  s   			t   httpdigestauthhandlerc           B   s#   e  Z d  „  Z d „  Z d „  Z RS(   c         O   s#   t  j j |  | | Ž d  |  _ d  S(   N(   R   t   HTTPDigestAuthHandlerR   R   t   retried_req(   R   RÎ   RÏ   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR   ‹  s    c         C   s   d  S(   N(    (   R   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   reset_retry_count  s    c         C   s   | |  j  k	 r$ | |  _  d |  _ n  y  t j j |  | | | | ƒ SWn6 t k
 r| } | j d } | j d ƒ rv d  S‚  n Xd  S(   Ni    s'   AbstractDigestAuthHandler doesn't know (   RÕ   t   retriedR   RÔ   t   http_error_auth_reqedR°   RÎ   R;   (   R   t   auth_headerR-   RW   R   t   instt   arg(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRØ   •  s    		(   R)   R*   R   RÖ   RØ   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRÓ   Š  s   		t   httpbasicauthhandlerc           B   s>   e  Z d  „  Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   c         O   s,   d  |  _ t j j |  | | Ž d  |  _ d  S(   N(   R   R#   R   t   HTTPBasicAuthHandlerR   RÕ   (   R   RÎ   RÏ   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyR   §  s    	c         C   s&   |  j  r" | j |  j |  j  ƒ n  | S(   N(   R#   t   add_unredirected_headerRÙ   (   R   t   request(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   http_request¬  s    	c         C   s&   |  j  r" | j |  j |  j  ƒ n  | S(   N(   R#   RÞ   RÙ   (   R   Rß   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   https_request²  s    	c         C   s   d  S(   N(    (   R   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRÖ   ¸  s    c         C   s@   | |  j  k	 r$ | |  _  d |  _ n  t j j |  | | | | ƒ S(   Ni    (   RÕ   R×   R   RÝ   RØ   (   R   RÙ   R-   RW   R   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRØ   ¾  s
    		c         C   s¬   |  j  j | | j ƒ  ƒ \ } } | d  k	 r¤ d | | f } d t j | ƒ j ƒ  } | j j |  j	 d  ƒ | k rx d  S| |  _
 | j |  j	 | ƒ |  j j | ƒ Sd  Sd  S(   Ns   %s:%ss   Basic %s(   R    R
   RŠ   R   t   base64t	   b64encodeR@   R   R   RÙ   R#   RÞ   R   t   open(   R   R-   RW   R   R   t   pwt   rawR#   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   retry_http_basic_authÆ  s    !	(   R)   R*   R   Rà   Rá   RÖ   RØ   Rç   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRÜ   ¦  s   					c         C   sM  |  j  d d t ƒ r3 t j |  t |  ƒ ƒ g } n( t ƒ  g } t r[ | j t |  ƒ ƒ n  | j t	 |  ƒ ƒ t |  ƒ } | d k	 rÖ | j | Œ  | d d !\ } } |  j d | | rÈ d t | ƒ pË d f ƒ n  | j t | ƒ t | ƒ f ƒ | j g  t D] } | |  | ƒ ^ qƒ t j | Œ  } d g | _ | j j d ƒ | S(   se   
    construct an opener suitable for urllib2
    authinfo will be added to the password manager
    R   t   usehttp2i   i   s    http auth: user %s, password %s
R%   s   not sets
   User-agents   mercurial/proto-1.0t   Accepts   application/mercurial-0.1N(   s
   User-agents   mercurial/proto-1.0(   Ré   s   application/mercurial-0.1(   RA   R‰   R   t   http2handlerR   R¹   Rx   t   appendRÈ   R+   R   R   R   R&   R<   RÜ   RÓ   t   handlerfuncsR   t   build_openerR‘   (   R   R   t   handlerst   passmgrR   R    R“   t   opener(    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRð   Õ  s&    	')c         C   sŒ   t  j | ƒ } | j r? | j j ƒ  | _ | j ƒ  \ } } n4 t  j t j j | ƒ ƒ } d t	 j
 | ƒ } d  } t |  | ƒ j | | ƒ S(   Ns   file://(   R   R   R‹   R>   R   t   normpathR9   t   patht   abspatht   urllibt   pathname2urlR   Rð   Rä   (   R   t   url_R^   R$   R   Rò   (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyRä   ô  s    	(,   Rô   R   R    R9   Rd   Rª   Râ   t   i18nR    R~   R   R|   Rw   R   R   R   RF   R+   Rb   t   safehasattrRx   t   create_connectionRv   t   AttributeErrort   objectRg   R   R   R–   R{   R¼   R¹   RÇ   R¾   RÉ   Rc   RÈ   RÔ   RÓ   RÝ   RÜ   Rì   Rð   Rä   (    (    (    s1   /usr/lib/python2.7/dist-packages/mercurial/url.pyt   <module>
   s4   T$1G				a".-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python2.7/dist-packages/mercurial/util.py                                                   0100644 0000000 0000000 00000200577 12413056314 020437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # util.py - Mercurial utility functions and platform specific implementations
#
#  Copyright 2005 K. Thananchayan <thananck@yahoo.com>
#  Copyright 2005-2007 Matt Mackall <mpm@selenic.com>
#  Copyright 2006 Vadim Gelfer <vadim.gelfer@gmail.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.

"""Mercurial utility functions and platform specific implementations.

This contains helper routines that are independent of the SCM core and
hide platform-specific details from the core.
"""

from i18n import _
import error, osutil, encoding
import errno, shutil, sys, tempfile, traceback
import re as remod
import os, time, datetime, calendar, textwrap, signal, collections
import imp, socket, urllib

if os.name == 'nt':
    import windows as platform
else:
    import posix as platform

cachestat = platform.cachestat
checkexec = platform.checkexec
checklink = platform.checklink
copymode = platform.copymode
executablepath = platform.executablepath
expandglobs = platform.expandglobs
explainexit = platform.explainexit
findexe = platform.findexe
gethgcmd = platform.gethgcmd
getuser = platform.getuser
groupmembers = platform.groupmembers
groupname = platform.groupname
hidewindow = platform.hidewindow
isexec = platform.isexec
isowner = platform.isowner
localpath = platform.localpath
lookupreg = platform.lookupreg
makedir = platform.makedir
nlinks = platform.nlinks
normpath = platform.normpath
normcase = platform.normcase
openhardlinks = platform.openhardlinks
oslink = platform.oslink
parsepatchoutput = platform.parsepatchoutput
pconvert = platform.pconvert
popen = platform.popen
posixfile = platform.posixfile
quotecommand = platform.quotecommand
rename = platform.rename
samedevice = platform.samedevice
samefile = platform.samefile
samestat = platform.samestat
setbinary = platform.setbinary
setflags = platform.setflags
setsignalhandler = platform.setsignalhandler
shellquote = platform.shellquote
spawndetached = platform.spawndetached
split = platform.split
sshargs = platform.sshargs
statfiles = getattr(osutil, 'statfiles', platform.statfiles)
statisexec = platform.statisexec
statislink = platform.statislink
termwidth = platform.termwidth
testpid = platform.testpid
umask = platform.umask
unlink = platform.unlink
unlinkpath = platform.unlinkpath
username = platform.username

# Python compatibility

_notset = object()

def safehasattr(thing, attr):
    return getattr(thing, attr, _notset) is not _notset

def sha1(s=''):
    '''
    Low-overhead wrapper around Python's SHA support

    >>> f = _fastsha1
    >>> a = sha1()
    >>> a = f()
    >>> a.hexdigest()
    'da39a3ee5e6b4b0d3255bfef95601890afd80709'
    '''

    return _fastsha1(s)

def _fastsha1(s=''):
    # This function will import sha1 from hashlib or sha (whichever is
    # available) and overwrite itself with it on the first call.
    # Subsequent calls will go directly to the imported function.
    if sys.version_info >= (2, 5):
        from hashlib import sha1 as _sha1
    else:
        from sha import sha as _sha1
    global _fastsha1, sha1
    _fastsha1 = sha1 = _sha1
    return _sha1(s)

try:
    buffer = buffer
except NameError:
    if sys.version_info[0] < 3:
        def buffer(sliceable, offset=0):
            return sliceable[offset:]
    else:
        def buffer(sliceable, offset=0):
            return memoryview(sliceable)[offset:]

import subprocess
closefds = os.name == 'posix'

def popen2(cmd, env=None, newlines=False):
    # Setting bufsize to -1 lets the system decide the buffer size.
    # The default for bufsize is 0, meaning unbuffered. This leads to
    # poor performance on Mac OS X: http://bugs.python.org/issue4194
    p = subprocess.Popen(cmd, shell=True, bufsize=-1,
                         close_fds=closefds,
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                         universal_newlines=newlines,
                         env=env)
    return p.stdin, p.stdout

def popen3(cmd, env=None, newlines=False):
    stdin, stdout, stderr, p = popen4(cmd, env, newlines)
    return stdin, stdout, stderr

def popen4(cmd, env=None, newlines=False):
    p = subprocess.Popen(cmd, shell=True, bufsize=-1,
                         close_fds=closefds,
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,
                         universal_newlines=newlines,
                         env=env)
    return p.stdin, p.stdout, p.stderr, p

def version():
    """Return version information if available."""
    try:
        import __version__
        return __version__.version
    except ImportError:
        return 'unknown'

# used by parsedate
defaultdateformats = (
    '%Y-%m-%d %H:%M:%S',
    '%Y-%m-%d %I:%M:%S%p',
    '%Y-%m-%d %H:%M',
    '%Y-%m-%d %I:%M%p',
    '%Y-%m-%d',
    '%m-%d',
    '%m/%d',
    '%m/%d/%y',
    '%m/%d/%Y',
    '%a %b %d %H:%M:%S %Y',
    '%a %b %d %I:%M:%S%p %Y',
    '%a, %d %b %Y %H:%M:%S',        #  GNU coreutils "/bin/date --rfc-2822"
    '%b %d %H:%M:%S %Y',
    '%b %d %I:%M:%S%p %Y',
    '%b %d %H:%M:%S',
    '%b %d %I:%M:%S%p',
    '%b %d %H:%M',
    '%b %d %I:%M%p',
    '%b %d %Y',
    '%b %d',
    '%H:%M:%S',
    '%I:%M:%S%p',
    '%H:%M',
    '%I:%M%p',
)

extendeddateformats = defaultdateformats + (
    "%Y",
    "%Y-%m",
    "%b",
    "%b %Y",
    )

def cachefunc(func):
    '''cache the result of function calls'''
    # XXX doesn't handle keywords args
    if func.func_code.co_argcount == 0:
        cache = []
        def f():
            if len(cache) == 0:
                cache.append(func())
            return cache[0]
        return f
    cache = {}
    if func.func_code.co_argcount == 1:
        # we gain a small amount of time because
        # we don't need to pack/unpack the list
        def f(arg):
            if arg not in cache:
                cache[arg] = func(arg)
            return cache[arg]
    else:
        def f(*args):
            if args not in cache:
                cache[args] = func(*args)
            return cache[args]

    return f

try:
    collections.deque.remove
    deque = collections.deque
except AttributeError:
    # python 2.4 lacks deque.remove
    class deque(collections.deque):
        def remove(self, val):
            for i, v in enumerate(self):
                if v == val:
                    del self[i]
                    break

class sortdict(dict):
    '''a simple sorted dictionary'''
    def __init__(self, data=None):
        self._list = []
        if data:
            self.update(data)
    def copy(self):
        return sortdict(self)
    def __setitem__(self, key, val):
        if key in self:
            self._list.remove(key)
        self._list.append(key)
        dict.__setitem__(self, key, val)
    def __iter__(self):
        return self._list.__iter__()
    def update(self, src):
        for k in src:
            self[k] = src[k]
    def clear(self):
        dict.clear(self)
        self._list = []
    def items(self):
        return [(k, self[k]) for k in self._list]
    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._list.remove(key)
    def keys(self):
        return self._list
    def iterkeys(self):
        return self._list.__iter__()

class lrucachedict(object):
    '''cache most recent gets from or sets to this dictionary'''
    def __init__(self, maxsize):
        self._cache = {}
        self._maxsize = maxsize
        self._order = deque()

    def __getitem__(self, key):
        value = self._cache[key]
        self._order.remove(key)
        self._order.append(key)
        return value

    def __setitem__(self, key, value):
        if key not in self._cache:
            if len(self._cache) >= self._maxsize:
                del self._cache[self._order.popleft()]
        else:
            self._order.remove(key)
        self._cache[key] = value
        self._order.append(key)

    def __contains__(self, key):
        return key in self._cache

    def clear(self):
        self._cache.clear()
        self._order = deque()

def lrucachefunc(func):
    '''cache most recent results of function calls'''
    cache = {}
    order = deque()
    if func.func_code.co_argcount == 1:
        def f(arg):
            if arg not in cache:
                if len(cache) > 20:
                    del cache[order.popleft()]
                cache[arg] = func(arg)
            else:
                order.remove(arg)
            order.append(arg)
            return cache[arg]
    else:
        def f(*args):
            if args not in cache:
                if len(cache) > 20:
                    del cache[order.popleft()]
                cache[args] = func(*args)
            else:
                order.remove(args)
            order.append(args)
            return cache[args]

    return f

class propertycache(object):
    def __init__(self, func):
        self.func = func
        self.name = func.__name__
    def __get__(self, obj, type=None):
        result = self.func(obj)
        self.cachevalue(obj, result)
        return result

    def cachevalue(self, obj, value):
        # __dict__ assignment required to bypass __setattr__ (eg: repoview)
        obj.__dict__[self.name] = value

def pipefilter(s, cmd):
    '''filter string S through command CMD, returning its output'''
    p = subprocess.Popen(cmd, shell=True, close_fds=closefds,
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    pout, perr = p.communicate(s)
    return pout

def tempfilter(s, cmd):
    '''filter string S through a pair of temporary files with CMD.
    CMD is used as a template to create the real command to be run,
    with the strings INFILE and OUTFILE replaced by the real names of
    the temporary files generated.'''
    inname, outname = None, None
    try:
        infd, inname = tempfile.mkstemp(prefix='hg-filter-in-')
        fp = os.fdopen(infd, 'wb')
        fp.write(s)
        fp.close()
        outfd, outname = tempfile.mkstemp(prefix='hg-filter-out-')
        os.close(outfd)
        cmd = cmd.replace('INFILE', inname)
        cmd = cmd.replace('OUTFILE', outname)
        code = os.system(cmd)
        if sys.platform == 'OpenVMS' and code & 1:
            code = 0
        if code:
            raise Abort(_("command '%s' failed: %s") %
                        (cmd, explainexit(code)))
        fp = open(outname, 'rb')
        r = fp.read()
        fp.close()
        return r
    finally:
        try:
            if inname:
                os.unlink(inname)
        except OSError:
            pass
        try:
            if outname:
                os.unlink(outname)
        except OSError:
            pass

filtertable = {
    'tempfile:': tempfilter,
    'pipe:': pipefilter,
    }

def filter(s, cmd):
    "filter a string through a command that transforms its input to its output"
    for name, fn in filtertable.iteritems():
        if cmd.startswith(name):
            return fn(s, cmd[len(name):].lstrip())
    return pipefilter(s, cmd)

def binary(s):
    """return true if a string is binary data"""
    return bool(s and '\0' in s)

def increasingchunks(source, min=1024, max=65536):
    '''return no less than min bytes per chunk while data remains,
    doubling min after each chunk until it reaches max'''
    def log2(x):
        if not x:
            return 0
        i = 0
        while x:
            x >>= 1
            i += 1
        return i - 1

    buf = []
    blen = 0
    for chunk in source:
        buf.append(chunk)
        blen += len(chunk)
        if blen >= min:
            if min < max:
                min = min << 1
                nmin = 1 << log2(blen)
                if nmin > min:
                    min = nmin
                if min > max:
                    min = max
            yield ''.join(buf)
            blen = 0
            buf = []
    if buf:
        yield ''.join(buf)

Abort = error.Abort

def always(fn):
    return True

def never(fn):
    return False

def pathto(root, n1, n2):
    '''return the relative path from one place to another.
    root should use os.sep to separate directories
    n1 should use os.sep to separate directories
    n2 should use "/" to separate directories
    returns an os.sep-separated path.

    If n1 is a relative path, it's assumed it's
    relative to root.
    n2 should always be relative to root.
    '''
    if not n1:
        return localpath(n2)
    if os.path.isabs(n1):
        if os.path.splitdrive(root)[0] != os.path.splitdrive(n1)[0]:
            return os.path.join(root, localpath(n2))
        n2 = '/'.join((pconvert(root), n2))
    a, b = splitpath(n1), n2.split('/')
    a.reverse()
    b.reverse()
    while a and b and a[-1] == b[-1]:
        a.pop()
        b.pop()
    b.reverse()
    return os.sep.join((['..'] * len(a)) + b) or '.'

_hgexecutable = None

def mainfrozen():
    """return True if we are a frozen executable.

    The code supports py2exe (most common, Windows only) and tools/freeze
    (portable, not much used).
    """
    return (safehasattr(sys, "frozen") or # new py2exe
            safehasattr(sys, "importers") or # old py2exe
            imp.is_frozen("__main__")) # tools/freeze

def hgexecutable():
    """return location of the 'hg' executable.

    Defaults to $HG or 'hg' in the search path.
    """
    if _hgexecutable is None:
        hg = os.environ.get('HG')
        mainmod = sys.modules['__main__']
        if hg:
            _sethgexecutable(hg)
        elif mainfrozen():
            _sethgexecutable(sys.executable)
        elif os.path.basename(getattr(mainmod, '__file__', '')) == 'hg':
            _sethgexecutable(mainmod.__file__)
        else:
            exe = findexe('hg') or os.path.basename(sys.argv[0])
            _sethgexecutable(exe)
    return _hgexecutable

def _sethgexecutable(path):
    """set location of the 'hg' executable"""
    global _hgexecutable
    _hgexecutable = path

def system(cmd, environ={}, cwd=None, onerr=None, errprefix=None, out=None):
    '''enhanced shell command execution.
    run with environment maybe modified, maybe in different dir.

    if command fails and onerr is None, return status.  if ui object,
    print error message and return status, else raise onerr object as
    exception.

    if out is specified, it is assumed to be a file-like object that has a
    write() method. stdout and stderr will be redirected to out.'''
    try:
        sys.stdout.flush()
    except Exception:
        pass
    def py2shell(val):
        'convert python object into string that is useful to shell'
        if val is None or val is False:
            return '0'
        if val is True:
            return '1'
        return str(val)
    origcmd = cmd
    cmd = quotecommand(cmd)
    if sys.platform == 'plan9' and (sys.version_info[0] == 2
                                    and sys.version_info[1] < 7):
        # subprocess kludge to work around issues in half-baked Python
        # ports, notably bichued/python:
        if not cwd is None:
            os.chdir(cwd)
        rc = os.system(cmd)
    else:
        env = dict(os.environ)
        env.update((k, py2shell(v)) for k, v in environ.iteritems())
        env['HG'] = hgexecutable()
        if out is None or out == sys.__stdout__:
            rc = subprocess.call(cmd, shell=True, close_fds=closefds,
                                 env=env, cwd=cwd)
        else:
            proc = subprocess.Popen(cmd, shell=True, close_fds=closefds,
                                    env=env, cwd=cwd, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT)
            for line in proc.stdout:
                out.write(line)
            proc.wait()
            rc = proc.returncode
        if sys.platform == 'OpenVMS' and rc & 1:
            rc = 0
    if rc and onerr:
        errmsg = '%s %s' % (os.path.basename(origcmd.split(None, 1)[0]),
                            explainexit(rc)[0])
        if errprefix:
            errmsg = '%s: %s' % (errprefix, errmsg)
        try:
            onerr.warn(errmsg + '\n')
        except AttributeError:
            raise onerr(errmsg)
    return rc

def checksignature(func):
    '''wrap a function with code to check for calling errors'''
    def check(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except TypeError:
            if len(traceback.extract_tb(sys.exc_info()[2])) == 1:
                raise error.SignatureError
            raise

    return check

def copyfile(src, dest):
    "copy a file, preserving mode and atime/mtime"
    if os.path.lexists(dest):
        unlink(dest)
    if os.path.islink(src):
        os.symlink(os.readlink(src), dest)
    else:
        try:
            shutil.copyfile(src, dest)
            shutil.copymode(src, dest)
        except shutil.Error, inst:
            raise Abort(str(inst))

def copyfiles(src, dst, hardlink=None):
    """Copy a directory tree using hardlinks if possible"""

    if hardlink is None:
        hardlink = (os.stat(src).st_dev ==
                    os.stat(os.path.dirname(dst)).st_dev)

    num = 0
    if os.path.isdir(src):
        os.mkdir(dst)
        for name, kind in osutil.listdir(src):
            srcname = os.path.join(src, name)
            dstname = os.path.join(dst, name)
            hardlink, n = copyfiles(srcname, dstname, hardlink)
            num += n
    else:
        if hardlink:
            try:
                oslink(src, dst)
            except (IOError, OSError):
                hardlink = False
                shutil.copy(src, dst)
        else:
            shutil.copy(src, dst)
        num += 1

    return hardlink, num

_winreservednames = '''con prn aux nul
    com1 com2 com3 com4 com5 com6 com7 com8 com9
    lpt1 lpt2 lpt3 lpt4 lpt5 lpt6 lpt7 lpt8 lpt9'''.split()
_winreservedchars = ':*?"<>|'
def checkwinfilename(path):
    r'''Check that the base-relative path is a valid filename on Windows.
    Returns None if the path is ok, or a UI string describing the problem.

    >>> checkwinfilename("just/a/normal/path")
    >>> checkwinfilename("foo/bar/con.xml")
    "filename contains 'con', which is reserved on Windows"
    >>> checkwinfilename("foo/con.xml/bar")
    "filename contains 'con', which is reserved on Windows"
    >>> checkwinfilename("foo/bar/xml.con")
    >>> checkwinfilename("foo/bar/AUX/bla.txt")
    "filename contains 'AUX', which is reserved on Windows"
    >>> checkwinfilename("foo/bar/bla:.txt")
    "filename contains ':', which is reserved on Windows"
    >>> checkwinfilename("foo/bar/b\07la.txt")
    "filename contains '\\x07', which is invalid on Windows"
    >>> checkwinfilename("foo/bar/bla ")
    "filename ends with ' ', which is not allowed on Windows"
    >>> checkwinfilename("../bar")
    >>> checkwinfilename("foo\\")
    "filename ends with '\\', which is invalid on Windows"
    >>> checkwinfilename("foo\\/bar")
    "directory name ends with '\\', which is invalid on Windows"
    '''
    if path.endswith('\\'):
        return _("filename ends with '\\', which is invalid on Windows")
    if '\\/' in path:
        return _("directory name ends with '\\', which is invalid on Windows")
    for n in path.replace('\\', '/').split('/'):
        if not n:
            continue
        for c in n:
            if c in _winreservedchars:
                return _("filename contains '%s', which is reserved "
                         "on Windows") % c
            if ord(c) <= 31:
                return _("filename contains %r, which is invalid "
                         "on Windows") % c
        base = n.split('.')[0]
        if base and base.lower() in _winreservednames:
            return _("filename contains '%s', which is reserved "
                     "on Windows") % base
        t = n[-1]
        if t in '. ' and n not in '..':
            return _("filename ends with '%s', which is not allowed "
                     "on Windows") % t

if os.name == 'nt':
    checkosfilename = checkwinfilename
else:
    checkosfilename = platform.checkosfilename

def makelock(info, pathname):
    try:
        return os.symlink(info, pathname)
    except OSError, why:
        if why.errno == errno.EEXIST:
            raise
    except AttributeError: # no symlink in os
        pass

    ld = os.open(pathname, os.O_CREAT | os.O_WRONLY | os.O_EXCL)
    os.write(ld, info)
    os.close(ld)

def readlock(pathname):
    try:
        return os.readlink(pathname)
    except OSError, why:
        if why.errno not in (errno.EINVAL, errno.ENOSYS):
            raise
    except AttributeError: # no symlink in os
        pass
    fp = posixfile(pathname)
    r = fp.read()
    fp.close()
    return r

def fstat(fp):
    '''stat file object that may not have fileno method.'''
    try:
        return os.fstat(fp.fileno())
    except AttributeError:
        return os.stat(fp.name)

# File system features

def checkcase(path):
    """
    Return true if the given path is on a case-sensitive filesystem

    Requires a path (like /foo/.hg) ending with a foldable final
    directory component.
    """
    s1 = os.stat(path)
    d, b = os.path.split(path)
    b2 = b.upper()
    if b == b2:
        b2 = b.lower()
        if b == b2:
            return True # no evidence against case sensitivity
    p2 = os.path.join(d, b2)
    try:
        s2 = os.stat(p2)
        if s2 == s1:
            return False
        return True
    except OSError:
        return True

try:
    import re2
    _re2 = None
except ImportError:
    _re2 = False

class _re(object):
    def _checkre2(self):
        global _re2
        try:
            # check if match works, see issue3964
            _re2 = bool(re2.match(r'\[([^\[]+)\]', '[ui]'))
        except ImportError:
            _re2 = False

    def compile(self, pat, flags=0):
        '''Compile a regular expression, using re2 if possible

        For best performance, use only re2-compatible regexp features. The
        only flags from the re module that are re2-compatible are
        IGNORECASE and MULTILINE.'''
        if _re2 is None:
            self._checkre2()
        if _re2 and (flags & ~(remod.IGNORECASE | remod.MULTILINE)) == 0:
            if flags & remod.IGNORECASE:
                pat = '(?i)' + pat
            if flags & remod.MULTILINE:
                pat = '(?m)' + pat
            try:
                return re2.compile(pat)
            except re2.error:
                pass
        return remod.compile(pat, flags)

    @propertycache
    def escape(self):
        '''Return the version of escape corresponding to self.compile.

        This is imperfect because whether re2 or re is used for a particular
        function depends on the flags, etc, but it's the best we can do.
        '''
        global _re2
        if _re2 is None:
            self._checkre2()
        if _re2:
            return re2.escape
        else:
            return remod.escape

re = _re()

_fspathcache = {}
def fspath(name, root):
    '''Get name in the case stored in the filesystem

    The name should be relative to root, and be normcase-ed for efficiency.

    Note that this function is unnecessary, and should not be
    called, for case-sensitive filesystems (simply because it's expensive).

    The root should be normcase-ed, too.
    '''
    def find(p, contents):
        for n in contents:
            if normcase(n) == p:
                return n
        return None

    seps = os.sep
    if os.altsep:
        seps = seps + os.altsep
    # Protect backslashes. This gets silly very quickly.
    seps.replace('\\','\\\\')
    pattern = remod.compile(r'([^%s]+)|([%s]+)' % (seps, seps))
    dir = os.path.normpath(root)
    result = []
    for part, sep in pattern.findall(name):
        if sep:
            result.append(sep)
            continue

        if dir not in _fspathcache:
            _fspathcache[dir] = os.listdir(dir)
        contents = _fspathcache[dir]

        found = find(part, contents)
        if not found:
            # retry "once per directory" per "dirstate.walk" which
            # may take place for each patches of "hg qpush", for example
            contents = os.listdir(dir)
            _fspathcache[dir] = contents
            found = find(part, contents)

        result.append(found or part)
        dir = os.path.join(dir, part)

    return ''.join(result)

def checknlink(testfile):
    '''check whether hardlink count reporting works properly'''

    # testfile may be open, so we need a separate file for checking to
    # work around issue2543 (or testfile may get lost on Samba shares)
    f1 = testfile + ".hgtmp1"
    if os.path.lexists(f1):
        return False
    try:
        posixfile(f1, 'w').close()
    except IOError:
        return False

    f2 = testfile + ".hgtmp2"
    fd = None
    try:
        try:
            oslink(f1, f2)
        except OSError:
            return False

        # nlinks() may behave differently for files on Windows shares if
        # the file is open.
        fd = posixfile(f2)
        return nlinks(f2) > 1
    finally:
        if fd is not None:
            fd.close()
        for f in (f1, f2):
            try:
                os.unlink(f)
            except OSError:
                pass

def endswithsep(path):
    '''Check path ends with os.sep or os.altsep.'''
    return path.endswith(os.sep) or os.altsep and path.endswith(os.altsep)

def splitpath(path):
    '''Split path by os.sep.
    Note that this function does not use os.altsep because this is
    an alternative of simple "xxx.split(os.sep)".
    It is recommended to use os.path.normpath() before using this
    function if need.'''
    return path.split(os.sep)

def gui():
    '''Are we running in a GUI?'''
    if sys.platform == 'darwin':
        if 'SSH_CONNECTION' in os.environ:
            # handle SSH access to a box where the user is logged in
            return False
        elif getattr(osutil, 'isgui', None):
            # check if a CoreGraphics session is available
            return osutil.isgui()
        else:
            # pure build; use a safe default
            return True
    else:
        return os.name == "nt" or os.environ.get("DISPLAY")

def mktempcopy(name, emptyok=False, createmode=None):
    """Create a temporary file with the same contents from name

    The permission bits are copied from the original file.

    If the temporary file is going to be truncated immediately, you
    can use emptyok=True as an optimization.

    Returns the name of the temporary file.
    """
    d, fn = os.path.split(name)
    fd, temp = tempfile.mkstemp(prefix='.%s-' % fn, dir=d)
    os.close(fd)
    # Temporary files are created with mode 0600, which is usually not
    # what we want.  If the original file already exists, just copy
    # its mode.  Otherwise, manually obey umask.
    copymode(name, temp, createmode)
    if emptyok:
        return temp
    try:
        try:
            ifp = posixfile(name, "rb")
        except IOError, inst:
            if inst.errno == errno.ENOENT:
                return temp
            if not getattr(inst, 'filename', None):
                inst.filename = name
            raise
        ofp = posixfile(temp, "wb")
        for chunk in filechunkiter(ifp):
            ofp.write(chunk)
        ifp.close()
        ofp.close()
    except: # re-raises
        try: os.unlink(temp)
        except OSError: pass
        raise
    return temp

class atomictempfile(object):
    '''writable file object that atomically updates a file

    All writes will go to a temporary copy of the original file. Call
    close() when you are done writing, and atomictempfile will rename
    the temporary copy to the original name, making the changes
    visible. If the object is destroyed without being closed, all your
    writes are discarded.
    '''
    def __init__(self, name, mode='w+b', createmode=None):
        self.__name = name      # permanent name
        self._tempname = mktempcopy(name, emptyok=('w' in mode),
                                    createmode=createmode)
        self._fp = posixfile(self._tempname, mode)

        # delegated methods
        self.write = self._fp.write
        self.seek = self._fp.seek
        self.tell = self._fp.tell
        self.fileno = self._fp.fileno

    def close(self):
        if not self._fp.closed:
            self._fp.close()
            rename(self._tempname, localpath(self.__name))

    def discard(self):
        if not self._fp.closed:
            try:
                os.unlink(self._tempname)
            except OSError:
                pass
            self._fp.close()

    def __del__(self):
        if safehasattr(self, '_fp'): # constructor actually did something
            self.discard()

def makedirs(name, mode=None, notindexed=False):
    """recursive directory creation with parent mode inheritance"""
    try:
        makedir(name, notindexed)
    except OSError, err:
        if err.errno == errno.EEXIST:
            return
        if err.errno != errno.ENOENT or not name:
            raise
        parent = os.path.dirname(os.path.abspath(name))
        if parent == name:
            raise
        makedirs(parent, mode, notindexed)
        makedir(name, notindexed)
    if mode is not None:
        os.chmod(name, mode)

def ensuredirs(name, mode=None):
    """race-safe recursive directory creation"""
    if os.path.isdir(name):
        return
    parent = os.path.dirname(os.path.abspath(name))
    if parent != name:
        ensuredirs(parent, mode)
    try:
        os.mkdir(name)
    except OSError, err:
        if err.errno == errno.EEXIST and os.path.isdir(name):
            # someone else seems to have won a directory creation race
            return
        raise
    if mode is not None:
        os.chmod(name, mode)

def readfile(path):
    fp = open(path, 'rb')
    try:
        return fp.read()
    finally:
        fp.close()

def writefile(path, text):
    fp = open(path, 'wb')
    try:
        fp.write(text)
    finally:
        fp.close()

def appendfile(path, text):
    fp = open(path, 'ab')
    try:
        fp.write(text)
    finally:
        fp.close()

class chunkbuffer(object):
    """Allow arbitrary sized chunks of data to be efficiently read from an
    iterator over chunks of arbitrary size."""

    def __init__(self, in_iter):
        """in_iter is the iterator that's iterating over the input chunks.
        targetsize is how big a buffer to try to maintain."""
        def splitbig(chunks):
            for chunk in chunks:
                if len(chunk) > 2**20:
                    pos = 0
                    while pos < len(chunk):
                        end = pos + 2 ** 18
                        yield chunk[pos:end]
                        pos = end
                else:
                    yield chunk
        self.iter = splitbig(in_iter)
        self._queue = deque()

    def read(self, l=None):
        """Read L bytes of data from the iterator of chunks of data.
        Returns less than L bytes if the iterator runs dry.

        If size parameter is ommited, read everything"""
        left = l
        buf = []
        queue = self._queue
        while left is None or left > 0:
            # refill the queue
            if not queue:
                target = 2**18
                for chunk in self.iter:
                    queue.append(chunk)
                    target -= len(chunk)
                    if target <= 0:
                        break
                if not queue:
                    break

            chunk = queue.popleft()
            if left is not None:
                left -= len(chunk)
            if left is not None and left < 0:
                queue.appendleft(chunk[left:])
                buf.append(chunk[:left])
            else:
                buf.append(chunk)

        return ''.join(buf)

def filechunkiter(f, size=65536, limit=None):
    """Create a generator that produces the data in the file size
    (default 65536) bytes at a time, up to optional limit (default is
    to read all data).  Chunks may be less than size bytes if the
    chunk is the last chunk in the file, or the file is a socket or
    some other type of file that sometimes reads less data than is
    requested."""
    assert size >= 0
    assert limit is None or limit >= 0
    while True:
        if limit is None:
            nbytes = size
        else:
            nbytes = min(limit, size)
        s = nbytes and f.read(nbytes)
        if not s:
            break
        if limit:
            limit -= len(s)
        yield s

def makedate(timestamp=None):
    '''Return a unix timestamp (or the current time) as a (unixtime,
    offset) tuple based off the local timezone.'''
    if timestamp is None:
        timestamp = time.time()
    if timestamp < 0:
        hint = _("check your clock")
        raise Abort(_("negative timestamp: %d") % timestamp, hint=hint)
    delta = (datetime.datetime.utcfromtimestamp(timestamp) -
             datetime.datetime.fromtimestamp(timestamp))
    tz = delta.days * 86400 + delta.seconds
    return timestamp, tz

def datestr(date=None, format='%a %b %d %H:%M:%S %Y %1%2'):
    """represent a (unixtime, offset) tuple as a localized time.
    unixtime is seconds since the epoch, and offset is the time zone's
    number of seconds away from UTC. if timezone is false, do not
    append time zone to string."""
    t, tz = date or makedate()
    if t < 0:
        t = 0   # time.gmtime(lt) fails on Windows for lt < -43200
        tz = 0
    if "%1" in format or "%2" in format or "%z" in format:
        sign = (tz > 0) and "-" or "+"
        minutes = abs(tz) // 60
        format = format.replace("%z", "%1%2")
        format = format.replace("%1", "%c%02d" % (sign, minutes // 60))
        format = format.replace("%2", "%02d" % (minutes % 60))
    try:
        t = time.gmtime(float(t) - tz)
    except ValueError:
        # time was out of range
        t = time.gmtime(sys.maxint)
    s = time.strftime(format, t)
    return s

def shortdate(date=None):
    """turn (timestamp, tzoff) tuple into iso 8631 date."""
    return datestr(date, format='%Y-%m-%d')

def strdate(string, format, defaults=[]):
    """parse a localized time string and return a (unixtime, offset) tuple.
    if the string cannot be parsed, ValueError is raised."""
    def timezone(string):
        tz = string.split()[-1]
        if tz[0] in "+-" and len(tz) == 5 and tz[1:].isdigit():
            sign = (tz[0] == "+") and 1 or -1
            hours = int(tz[1:3])
            minutes = int(tz[3:5])
            return -sign * (hours * 60 + minutes) * 60
        if tz == "GMT" or tz == "UTC":
            return 0
        return None

    # NOTE: unixtime = localunixtime + offset
    offset, date = timezone(string), string
    if offset is not None:
        date = " ".join(string.split()[:-1])

    # add missing elements from defaults
    usenow = False # default to using biased defaults
    for part in ("S", "M", "HI", "d", "mb", "yY"): # decreasing specificity
        found = [True for p in part if ("%"+p) in format]
        if not found:
            date += "@" + defaults[part][usenow]
            format += "@%" + part[0]
        else:
            # We've found a specific time element, less specific time
            # elements are relative to today
            usenow = True

    timetuple = time.strptime(date, format)
    localunixtime = int(calendar.timegm(timetuple))
    if offset is None:
        # local timezone
        unixtime = int(time.mktime(timetuple))
        offset = unixtime - localunixtime
    else:
        unixtime = localunixtime + offset
    return unixtime, offset

def parsedate(date, formats=None, bias={}):
    """parse a localized date/time and return a (unixtime, offset) tuple.

    The date may be a "unixtime offset" string or in one of the specified
    formats. If the date already is a (unixtime, offset) tuple, it is returned.

    >>> parsedate(' today ') == parsedate(\
                                  datetime.date.today().strftime('%b %d'))
    True
    >>> parsedate( 'yesterday ') == parsedate((datetime.date.today() -\
                                               datetime.timedelta(days=1)\
                                              ).strftime('%b %d'))
    True
    >>> now, tz = makedate()
    >>> strnow, strtz = parsedate('now')
    >>> (strnow - now) < 1
    True
    >>> tz == strtz
    True
    """
    if not date:
        return 0, 0
    if isinstance(date, tuple) and len(date) == 2:
        return date
    if not formats:
        formats = defaultdateformats
    date = date.strip()

    if date == _('now'):
        return makedate()
    if date == _('today'):
        date = datetime.date.today().strftime('%b %d')
    elif date == _('yesterday'):
        date = (datetime.date.today() -
                datetime.timedelta(days=1)).strftime('%b %d')

    try:
        when, offset = map(int, date.split(' '))
    except ValueError:
        # fill out defaults
        now = makedate()
        defaults = {}
        for part in ("d", "mb", "yY", "HI", "M", "S"):
            # this piece is for rounding the specific end of unknowns
            b = bias.get(part)
            if b is None:
                if part[0] in "HMS":
                    b = "00"
                else:
                    b = "0"

            # this piece is for matching the generic end to today's date
            n = datestr(now, "%" + part[0])

            defaults[part] = (b, n)

        for format in formats:
            try:
                when, offset = strdate(date, format, defaults)
            except (ValueError, OverflowError):
                pass
            else:
                break
        else:
            raise Abort(_('invalid date: %r') % date)
    # validate explicit (probably user-specified) date and
    # time zone offset. values must fit in signed 32 bits for
    # current 32-bit linux runtimes. timezones go from UTC-12
    # to UTC+14
    if abs(when) > 0x7fffffff:
        raise Abort(_('date exceeds 32 bits: %d') % when)
    if when < 0:
        raise Abort(_('negative date value: %d') % when)
    if offset < -50400 or offset > 43200:
        raise Abort(_('impossible time zone offset: %d') % offset)
    return when, offset

def matchdate(date):
    """Return a function that matches a given date match specifier

    Formats include:

    '{date}' match a given date to the accuracy provided

    '<{date}' on or before a given date

    '>{date}' on or after a given date

    >>> p1 = parsedate("10:29:59")
    >>> p2 = parsedate("10:30:00")
    >>> p3 = parsedate("10:30:59")
    >>> p4 = parsedate("10:31:00")
    >>> p5 = parsedate("Sep 15 10:30:00 1999")
    >>> f = matchdate("10:30")
    >>> f(p1[0])
    False
    >>> f(p2[0])
    True
    >>> f(p3[0])
    True
    >>> f(p4[0])
    False
    >>> f(p5[0])
    False
    """

    def lower(date):
        d = {'mb': "1", 'd': "1"}
        return parsedate(date, extendeddateformats, d)[0]

    def upper(date):
        d = {'mb': "12", 'HI': "23", 'M': "59", 'S': "59"}
        for days in ("31", "30", "29"):
            try:
                d["d"] = days
                return parsedate(date, extendeddateformats, d)[0]
            except Abort:
                pass
        d["d"] = "28"
        return parsedate(date, extendeddateformats, d)[0]

    date = date.strip()

    if not date:
        raise Abort(_("dates cannot consist entirely of whitespace"))
    elif date[0] == "<":
        if not date[1:]:
            raise Abort(_("invalid day spec, use '<DATE'"))
        when = upper(date[1:])
        return lambda x: x <= when
    elif date[0] == ">":
        if not date[1:]:
            raise Abort(_("invalid day spec, use '>DATE'"))
        when = lower(date[1:])
        return lambda x: x >= when
    elif date[0] == "-":
        try:
            days = int(date[1:])
        except ValueError:
            raise Abort(_("invalid day spec: %s") % date[1:])
        if days < 0:
            raise Abort(_("%s must be nonnegative (see 'hg help dates')")
                % date[1:])
        when = makedate()[0] - days * 3600 * 24
        return lambda x: x >= when
    elif " to " in date:
        a, b = date.split(" to ")
        start, stop = lower(a), upper(b)
        return lambda x: x >= start and x <= stop
    else:
        start, stop = lower(date), upper(date)
        return lambda x: x >= start and x <= stop

def shortuser(user):
    """Return a short representation of a user name or email address."""
    f = user.find('@')
    if f >= 0:
        user = user[:f]
    f = user.find('<')
    if f >= 0:
        user = user[f + 1:]
    f = user.find(' ')
    if f >= 0:
        user = user[:f]
    f = user.find('.')
    if f >= 0:
        user = user[:f]
    return user

def emailuser(user):
    """Return the user portion of an email address."""
    f = user.find('@')
    if f >= 0:
        user = user[:f]
    f = user.find('<')
    if f >= 0:
        user = user[f + 1:]
    return user

def email(author):
    '''get email of author.'''
    r = author.find('>')
    if r == -1:
        r = None
    return author[author.find('<') + 1:r]

def ellipsis(text, maxlength=400):
    """Trim string to at most maxlength (default: 400) columns in display."""
    return encoding.trim(text, maxlength, ellipsis='...')

def unitcountfn(*unittable):
    '''return a function that renders a readable count of some quantity'''

    def go(count):
        for multiplier, divisor, format in unittable:
            if count >= divisor * multiplier:
                return format % (count / float(divisor))
        return unittable[-1][2] % count

    return go

bytecount = unitcountfn(
    (100, 1 << 30, _('%.0f GB')),
    (10, 1 << 30, _('%.1f GB')),
    (1, 1 << 30, _('%.2f GB')),
    (100, 1 << 20, _('%.0f MB')),
    (10, 1 << 20, _('%.1f MB')),
    (1, 1 << 20, _('%.2f MB')),
    (100, 1 << 10, _('%.0f KB')),
    (10, 1 << 10, _('%.1f KB')),
    (1, 1 << 10, _('%.2f KB')),
    (1, 1, _('%.0f bytes')),
    )

def uirepr(s):
    # Avoid double backslash in Windows path repr()
    return repr(s).replace('\\\\', '\\')

# delay import of textwrap
def MBTextWrapper(**kwargs):
    class tw(textwrap.TextWrapper):
        """
        Extend TextWrapper for width-awareness.

        Neither number of 'bytes' in any encoding nor 'characters' is
        appropriate to calculate terminal columns for specified string.

        Original TextWrapper implementation uses built-in 'len()' directly,
        so overriding is needed to use width information of each characters.

        In addition, characters classified into 'ambiguous' width are
        treated as wide in East Asian area, but as narrow in other.

        This requires use decision to determine width of such characters.
        """
        def __init__(self, **kwargs):
            textwrap.TextWrapper.__init__(self, **kwargs)

            # for compatibility between 2.4 and 2.6
            if getattr(self, 'drop_whitespace', None) is None:
                self.drop_whitespace = kwargs.get('drop_whitespace', True)

        def _cutdown(self, ucstr, space_left):
            l = 0
            colwidth = encoding.ucolwidth
            for i in xrange(len(ucstr)):
                l += colwidth(ucstr[i])
                if space_left < l:
                    return (ucstr[:i], ucstr[i:])
            return ucstr, ''

        # overriding of base class
        def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):
            space_left = max(width - cur_len, 1)

            if self.break_long_words:
                cut, res = self._cutdown(reversed_chunks[-1], space_left)
                cur_line.append(cut)
                reversed_chunks[-1] = res
            elif not cur_line:
                cur_line.append(reversed_chunks.pop())

        # this overriding code is imported from TextWrapper of python 2.6
        # to calculate columns of string by 'encoding.ucolwidth()'
        def _wrap_chunks(self, chunks):
            colwidth = encoding.ucolwidth

            lines = []
            if self.width <= 0:
                raise ValueError("invalid width %r (must be > 0)" % self.width)

            # Arrange in reverse order so items can be efficiently popped
            # from a stack of chucks.
            chunks.reverse()

            while chunks:

                # Start the list of chunks that will make up the current line.
                # cur_len is just the length of all the chunks in cur_line.
                cur_line = []
                cur_len = 0

                # Figure out which static string will prefix this line.
                if lines:
                    indent = self.subsequent_indent
                else:
                    indent = self.initial_indent

                # Maximum width for this line.
                width = self.width - len(indent)

                # First chunk on line is whitespace -- drop it, unless this
                # is the very beginning of the text (i.e. no lines started yet).
                if self.drop_whitespace and chunks[-1].strip() == '' and lines:
                    del chunks[-1]

                while chunks:
                    l = colwidth(chunks[-1])

                    # Can at least squeeze this chunk onto the current line.
                    if cur_len + l <= width:
                        cur_line.append(chunks.pop())
                        cur_len += l

                    # Nope, this line is full.
                    else:
                        break

                # The current line is full, and the next chunk is too big to
                # fit on *any* line (not just this one).
                if chunks and colwidth(chunks[-1]) > width:
                    self._handle_long_word(chunks, cur_line, cur_len, width)

                # If the last chunk on this line is all whitespace, drop it.
                if (self.drop_whitespace and
                    cur_line and cur_line[-1].strip() == ''):
                    del cur_line[-1]

                # Convert current line back to a string and store it in list
                # of all lines (return value).
                if cur_line:
                    lines.append(indent + ''.join(cur_line))

            return lines

    global MBTextWrapper
    MBTextWrapper = tw
    return tw(**kwargs)

def wrap(line, width, initindent='', hangindent=''):
    maxindent = max(len(hangindent), len(initindent))
    if width <= maxindent:
        # adjust for weird terminal size
        width = max(78, maxindent + 1)
    line = line.decode(encoding.encoding, encoding.encodingmode)
    initindent = initindent.decode(encoding.encoding, encoding.encodingmode)
    hangindent = hangindent.decode(encoding.encoding, encoding.encodingmode)
    wrapper = MBTextWrapper(width=width,
                            initial_indent=initindent,
                            subsequent_indent=hangindent)
    return wrapper.fill(line).encode(encoding.encoding)

def iterlines(iterator):
    for chunk in iterator:
        for line in chunk.splitlines():
            yield line

def expandpath(path):
    return os.path.expanduser(os.path.expandvars(path))

def hgcmd():
    """Return the command used to execute current hg

    This is different from hgexecutable() because on Windows we want
    to avoid things opening new shell windows like batch files, so we
    get either the python call or current executable.
    """
    if mainfrozen():
        return [sys.executable]
    return gethgcmd()

def rundetached(args, condfn):
    """Execute the argument list in a detached process.

    condfn is a callable which is called repeatedly and should return
    True once the child process is known to have started successfully.
    At this point, the child process PID is returned. If the child
    process fails to start or finishes before condfn() evaluates to
    True, return -1.
    """
    # Windows case is easier because the child process is either
    # successfully starting and validating the condition or exiting
    # on failure. We just poll on its PID. On Unix, if the child
    # process fails to start, it will be left in a zombie state until
    # the parent wait on it, which we cannot do since we expect a long
    # running process on success. Instead we listen for SIGCHLD telling
    # us our child process terminated.
    terminated = set()
    def handler(signum, frame):
        terminated.add(os.wait())
    prevhandler = None
    SIGCHLD = getattr(signal, 'SIGCHLD', None)
    if SIGCHLD is not None:
        prevhandler = signal.signal(SIGCHLD, handler)
    try:
        pid = spawndetached(args)
        while not condfn():
            if ((pid in terminated or not testpid(pid))
                and not condfn()):
                return -1
            time.sleep(0.1)
        return pid
    finally:
        if prevhandler is not None:
            signal.signal(signal.SIGCHLD, prevhandler)

try:
    any, all = any, all
except NameError:
    def any(iterable):
        for i in iterable:
            if i:
                return True
        return False

    def all(iterable):
        for i in iterable:
            if not i:
                return False
        return True

def interpolate(prefix, mapping, s, fn=None, escape_prefix=False):
    """Return the result of interpolating items in the mapping into string s.

    prefix is a single character string, or a two character string with
    a backslash as the first character if the prefix needs to be escaped in
    a regular expression.

    fn is an optional function that will be applied to the replacement text
    just before replacement.

    escape_prefix is an optional flag that allows using doubled prefix for
    its escaping.
    """
    fn = fn or (lambda s: s)
    patterns = '|'.join(mapping.keys())
    if escape_prefix:
        patterns += '|' + prefix
        if len(prefix) > 1:
            prefix_char = prefix[1:]
        else:
            prefix_char = prefix
        mapping[prefix_char] = prefix_char
    r = remod.compile(r'%s(%s)' % (prefix, patterns))
    return r.sub(lambda x: fn(mapping[x.group()[1:]]), s)

def getport(port):
    """Return the port for a given network service.

    If port is an integer, it's returned as is. If it's a string, it's
    looked up using socket.getservbyname(). If there's no matching
    service, util.Abort is raised.
    """
    try:
        return int(port)
    except ValueError:
        pass

    try:
        return socket.getservbyname(port)
    except socket.error:
        raise Abort(_("no port number associated with service '%s'") % port)

_booleans = {'1': True, 'yes': True, 'true': True, 'on': True, 'always': True,
             '0': False, 'no': False, 'false': False, 'off': False,
             'never': False}

def parsebool(s):
    """Parse s into a boolean.

    If s is not a valid boolean, returns None.
    """
    return _booleans.get(s.lower(), None)

_hexdig = '0123456789ABCDEFabcdef'
_hextochr = dict((a + b, chr(int(a + b, 16)))
                 for a in _hexdig for b in _hexdig)

def _urlunquote(s):
    """Decode HTTP/HTML % encoding.

    >>> _urlunquote('abc%20def')
    'abc def'
    """
    res = s.split('%')
    # fastpath
    if len(res) == 1:
        return s
    s = res[0]
    for item in res[1:]:
        try:
            s += _hextochr[item[:2]] + item[2:]
        except KeyError:
            s += '%' + item
        except UnicodeDecodeError:
            s += unichr(int(item[:2], 16)) + item[2:]
    return s

class url(object):
    r"""Reliable URL parser.

    This parses URLs and provides attributes for the following
    components:

    <scheme>://<user>:<passwd>@<host>:<port>/<path>?<query>#<fragment>

    Missing components are set to None. The only exception is
    fragment, which is set to '' if present but empty.

    If parsefragment is False, fragment is included in query. If
    parsequery is False, query is included in path. If both are
    False, both fragment and query are included in path.

    See http://www.ietf.org/rfc/rfc2396.txt for more information.

    Note that for backward compatibility reasons, bundle URLs do not
    take host names. That means 'bundle://../' has a path of '../'.

    Examples:

    >>> url('http://www.ietf.org/rfc/rfc2396.txt')
    <url scheme: 'http', host: 'www.ietf.org', path: 'rfc/rfc2396.txt'>
    >>> url('ssh://[::1]:2200//home/joe/repo')
    <url scheme: 'ssh', host: '[::1]', port: '2200', path: '/home/joe/repo'>
    >>> url('file:///home/joe/repo')
    <url scheme: 'file', path: '/home/joe/repo'>
    >>> url('file:///c:/temp/foo/')
    <url scheme: 'file', path: 'c:/temp/foo/'>
    >>> url('bundle:foo')
    <url scheme: 'bundle', path: 'foo'>
    >>> url('bundle://../foo')
    <url scheme: 'bundle', path: '../foo'>
    >>> url(r'c:\foo\bar')
    <url path: 'c:\\foo\\bar'>
    >>> url(r'\\blah\blah\blah')
    <url path: '\\\\blah\\blah\\blah'>
    >>> url(r'\\blah\blah\blah#baz')
    <url path: '\\\\blah\\blah\\blah', fragment: 'baz'>
    >>> url(r'file:///C:\users\me')
    <url scheme: 'file', path: 'C:\\users\\me'>

    Authentication credentials:

    >>> url('ssh://joe:xyz@x/repo')
    <url scheme: 'ssh', user: 'joe', passwd: 'xyz', host: 'x', path: 'repo'>
    >>> url('ssh://joe@x/repo')
    <url scheme: 'ssh', user: 'joe', host: 'x', path: 'repo'>

    Query strings and fragments:

    >>> url('http://host/a?b#c')
    <url scheme: 'http', host: 'host', path: 'a', query: 'b', fragment: 'c'>
    >>> url('http://host/a?b#c', parsequery=False, parsefragment=False)
    <url scheme: 'http', host: 'host', path: 'a?b#c'>
    """

    _safechars = "!~*'()+"
    _safepchars = "/!~*'()+:\\"
    _matchscheme = remod.compile(r'^[a-zA-Z0-9+.\-]+:').match

    def __init__(self, path, parsequery=True, parsefragment=True):
        # We slowly chomp away at path until we have only the path left
        self.scheme = self.user = self.passwd = self.host = None
        self.port = self.path = self.query = self.fragment = None
        self._localpath = True
        self._hostport = ''
        self._origpath = path

        if parsefragment and '#' in path:
            path, self.fragment = path.split('#', 1)
            if not path:
                path = None

        # special case for Windows drive letters and UNC paths
        if hasdriveletter(path) or path.startswith(r'\\'):
            self.path = path
            return

        # For compatibility reasons, we can't handle bundle paths as
        # normal URLS
        if path.startswith('bundle:'):
            self.scheme = 'bundle'
            path = path[7:]
            if path.startswith('//'):
                path = path[2:]
            self.path = path
            return

        if self._matchscheme(path):
            parts = path.split(':', 1)
            if parts[0]:
                self.scheme, path = parts
                self._localpath = False

        if not path:
            path = None
            if self._localpath:
                self.path = ''
                return
        else:
            if self._localpath:
                self.path = path
                return

            if parsequery and '?' in path:
                path, self.query = path.split('?', 1)
                if not path:
                    path = None
                if not self.query:
                    self.query = None

            # // is required to specify a host/authority
            if path and path.startswith('//'):
                parts = path[2:].split('/', 1)
                if len(parts) > 1:
                    self.host, path = parts
                else:
                    self.host = parts[0]
                    path = None
                if not self.host:
                    self.host = None
                    # path of file:///d is /d
                    # path of file:///d:/ is d:/, not /d:/
                    if path and not hasdriveletter(path):
                        path = '/' + path

            if self.host and '@' in self.host:
                self.user, self.host = self.host.rsplit('@', 1)
                if ':' in self.user:
                    self.user, self.passwd = self.user.split(':', 1)
                if not self.host:
                    self.host = None

            # Don't split on colons in IPv6 addresses without ports
            if (self.host and ':' in self.host and
                not (self.host.startswith('[') and self.host.endswith(']'))):
                self._hostport = self.host
                self.host, self.port = self.host.rsplit(':', 1)
                if not self.host:
                    self.host = None

            if (self.host and self.scheme == 'file' and
                self.host not in ('localhost', '127.0.0.1', '[::1]')):
                raise Abort(_('file:// URLs can only refer to localhost'))

        self.path = path

        # leave the query string escaped
        for a in ('user', 'passwd', 'host', 'port',
                  'path', 'fragment'):
            v = getattr(self, a)
            if v is not None:
                setattr(self, a, _urlunquote(v))

    def __repr__(self):
        attrs = []
        for a in ('scheme', 'user', 'passwd', 'host', 'port', 'path',
                  'query', 'fragment'):
            v = getattr(self, a)
            if v is not None:
                attrs.append('%s: %r' % (a, v))
        return '<url %s>' % ', '.join(attrs)

    def __str__(self):
        r"""Join the URL's components back into a URL string.

        Examples:

        >>> str(url('http://user:pw@host:80/c:/bob?fo:oo#ba:ar'))
        'http://user:pw@host:80/c:/bob?fo:oo#ba:ar'
        >>> str(url('http://user:pw@host:80/?foo=bar&baz=42'))
        'http://user:pw@host:80/?foo=bar&baz=42'
        >>> str(url('http://user:pw@host:80/?foo=bar%3dbaz'))
        'http://user:pw@host:80/?foo=bar%3dbaz'
        >>> str(url('ssh://user:pw@[::1]:2200//home/joe#'))
        'ssh://user:pw@[::1]:2200//home/joe#'
        >>> str(url('http://localhost:80//'))
        'http://localhost:80//'
        >>> str(url('http://localhost:80/'))
        'http://localhost:80/'
        >>> str(url('http://localhost:80'))
        'http://localhost:80/'
        >>> str(url('bundle:foo'))
        'bundle:foo'
        >>> str(url('bundle://../foo'))
        'bundle:../foo'
        >>> str(url('path'))
        'path'
        >>> str(url('file:///tmp/foo/bar'))
        'file:///tmp/foo/bar'
        >>> str(url('file:///c:/tmp/foo/bar'))
        'file:///c:/tmp/foo/bar'
        >>> print url(r'bundle:foo\bar')
        bundle:foo\bar
        >>> print url(r'file:///D:\data\hg')
        file:///D:\data\hg
        """
        if self._localpath:
            s = self.path
            if self.scheme == 'bundle':
                s = 'bundle:' + s
            if self.fragment:
                s += '#' + self.fragment
            return s

        s = self.scheme + ':'
        if self.user or self.passwd or self.host:
            s += '//'
        elif self.scheme and (not self.path or self.path.startswith('/')
                              or hasdriveletter(self.path)):
            s += '//'
            if hasdriveletter(self.path):
                s += '/'
        if self.user:
            s += urllib.quote(self.user, safe=self._safechars)
        if self.passwd:
            s += ':' + urllib.quote(self.passwd, safe=self._safechars)
        if self.user or self.passwd:
            s += '@'
        if self.host:
            if not (self.host.startswith('[') and self.host.endswith(']')):
                s += urllib.quote(self.host)
            else:
                s += self.host
        if self.port:
            s += ':' + urllib.quote(self.port)
        if self.host:
            s += '/'
        if self.path:
            # TODO: similar to the query string, we should not unescape the
            # path when we store it, the path might contain '%2f' = '/',
            # which we should *not* escape.
            s += urllib.quote(self.path, safe=self._safepchars)
        if self.query:
            # we store the query in escaped form.
            s += '?' + self.query
        if self.fragment is not None:
            s += '#' + urllib.quote(self.fragment, safe=self._safepchars)
        return s

    def authinfo(self):
        user, passwd = self.user, self.passwd
        try:
            self.user, self.passwd = None, None
            s = str(self)
        finally:
            self.user, self.passwd = user, passwd
        if not self.user:
            return (s, None)
        # authinfo[1] is passed to urllib2 password manager, and its
        # URIs must not contain credentials. The host is passed in the
        # URIs list because Python < 2.4.3 uses only that to search for
        # a password.
        return (s, (None, (s, self.host),
                    self.user, self.passwd or ''))

    def isabs(self):
        if self.scheme and self.scheme != 'file':
            return True # remote URL
        if hasdriveletter(self.path):
            return True # absolute for our purposes - can't be joined()
        if self.path.startswith(r'\\'):
            return True # Windows UNC path
        if self.path.startswith('/'):
            return True # POSIX-style
        return False

    def localpath(self):
        if self.scheme == 'file' or self.scheme == 'bundle':
            path = self.path or '/'
            # For Windows, we need to promote hosts containing drive
            # letters to paths with drive letters.
            if hasdriveletter(self._hostport):
                path = self._hostport + '/' + self.path
            elif (self.host is not None and self.path
                  and not hasdriveletter(path)):
                path = '/' + path
            return path
        return self._origpath

    def islocal(self):
        '''whether localpath will return something that posixfile can open'''
        return (not self.scheme or self.scheme == 'file'
                or self.scheme == 'bundle')

def hasscheme(path):
    return bool(url(path).scheme)

def hasdriveletter(path):
    return path and path[1:2] == ':' and path[0:1].isalpha()

def urllocalpath(path):
    return url(path, parsequery=False, parsefragment=False).localpath()

def hidepassword(u):
    '''hide user credential in a url string'''
    u = url(u)
    if u.passwd:
        u.passwd = '***'
    return str(u)

def removeauth(u):
    '''remove all authentication information from a url string'''
    u = url(u)
    u.user = u.passwd = None
    return str(u)

def isatty(fd):
    try:
        return fd.isatty()
    except AttributeError:
        return False

timecount = unitcountfn(
    (1, 1e3, _('%.0f s')),
    (100, 1, _('%.1f s')),
    (10, 1, _('%.2f s')),
    (1, 1, _('%.3f s')),
    (100, 0.001, _('%.1f ms')),
    (10, 0.001, _('%.2f ms')),
    (1, 0.001, _('%.3f ms')),
    (100, 0.000001, _('%.1f us')),
    (10, 0.000001, _('%.2f us')),
    (1, 0.000001, _('%.3f us')),
    (100, 0.000000001, _('%.1f ns')),
    (10, 0.000000001, _('%.2f ns')),
    (1, 0.000000001, _('%.3f ns')),
    )

_timenesting = [0]

def timed(func):
    '''Report the execution time of a function call to stderr.

    During development, use as a decorator when you need to measure
    the cost of a function, e.g. as follows:

    @util.timed
    def foo(a, b, c):
        pass
    '''

    def wrapper(*args, **kwargs):
        start = time.time()
        indent = 2
        _timenesting[0] += indent
        try:
            return func(*args, **kwargs)
        finally:
            elapsed = time.time() - start
            _timenesting[0] -= indent
            sys.stderr.write('%s%s: %s\n' %
                             (' ' * _timenesting[0], func.__name__,
                              timecount(elapsed)))
    return wrapper

_sizeunits = (('m', 2**20), ('k', 2**10), ('g', 2**30),
              ('kb', 2**10), ('mb', 2**20), ('gb', 2**30), ('b', 1))

def sizetoint(s):
    '''Convert a space specifier to a byte count.

    >>> sizetoint('30')
    30
    >>> sizetoint('2.2kb')
    2252
    >>> sizetoint('6M')
    6291456
    '''
    t = s.strip().lower()
    try:
        for k, u in _sizeunits:
            if t.endswith(k):
                return int(float(t[:-len(k)]) * u)
        return int(t)
    except ValueError:
        raise error.ParseError(_("couldn't parse size: %s") % s)

class hooks(object):
    '''A collection of hook functions that can be used to extend a
    function's behaviour. Hooks are called in lexicographic order,
    based on the names of their sources.'''

    def __init__(self):
        self._hooks = []

    def add(self, source, hook):
        self._hooks.append((source, hook))

    def __call__(self, *args):
        self._hooks.sort(key=lambda x: x[0])
        results = []
        for source, hook in self._hooks:
            results.append(hook(*args))
        return results

def debugstacktrace(msg='stacktrace', skip=0, f=sys.stderr, otherf=sys.stdout):
    '''Writes a message to f (stderr) with a nicely formatted stacktrace.
    Skips the 'skip' last entries. By default it will flush stdout first.
    It can be used everywhere and do intentionally not require an ui object.
    Not be used in production code but very convenient while developing.
    '''
    if otherf:
        otherf.flush()
    f.write('%s at:\n' % msg)
    entries = [('%s:%s' % (fn, ln), func)
        for fn, ln, func, _text in traceback.extract_stack()[:-skip - 1]]
    if entries:
        fnmax = max(len(entry[0]) for entry in entries)
        for fnln, func in entries:
            f.write(' %-*s in %s\n' % (fnmax, fnln, func))
    f.flush()

# convenient shortcut
dst = debugstacktrace
                                                                                                                                 usr/lib/python2.7/dist-packages/mercurial/util.pyc                                                  0100644 0000000 0000000 00000212416 13077704337 020611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ó
Ì\,Tc           @   s(  d  Z  d d l m Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z e j d k rd d l Z n d d l Z e j Z e j Z e j Z e j Z e j Z e j  Z  e j! Z! e j" Z" e j# Z# e j$ Z$ e j% Z% e j& Z& e j' Z' e j( Z( e j) Z) e j* Z* e j+ Z+ e j, Z, e j- Z- e j. Z. e j/ Z/ e j0 Z0 e j1 Z1 e j2 Z2 e j3 Z3 e j4 Z4 e j5 Z5 e j6 Z6 e j7 Z7 e j8 Z8 e j9 Z9 e j: Z: e j; Z; e j< Z< e j= Z= e j> Z> e j? Z? e j@ Z@ e jA ZA eB e d e jC ƒ ZC e jD ZD e jE ZE e jF ZF e jG ZG e jH ZH e jI ZI e jJ ZJ e jK ZK eL ƒ  ZM d „  ZN d d „ aO d d	 „ aP y
 eQ ZQ Wn? eR k
 rUe jS d
 d k  rFd
 d „ ZQ n d
 d „ ZQ n Xd d lT ZT e j d k ZU eV eW d „ ZX eV eW d „ ZY eV eW d „ ZZ d „  Z[ d d d d d d d d d d d d d d  d! d" d# d$ d% d& d' d( d) d* f Z\ e\ d+ d, d- d. f Z] d/ „  Z^ y e j_ j` e j_ Z_ Wn* ea k
 rWd0 e j_ f d1 „  ƒ  YZ_ n Xd2 eb f d3 „  ƒ  YZc d4 eL f d5 „  ƒ  YZd d6 „  Ze d7 eL f d8 „  ƒ  YZf d9 „  Zg d: „  Zh i eh d; 6eg d< 6Zi d= „  Zj d> „  Zk d? d@ dA „ Zl e jm Zm dB „  Zn dC „  Zo dD „  Zp eV aq dE „  Zr dF „  Zs dG „  Zt i  eV eV eV eV dH „ Zu dI „  Zv dJ „  Zw eV dK „ Zx dL j@ ƒ  Zy dM Zz dN „  Z{ e j d k r˜e{ Z| n	 e j| Z| dO „  Z} dP „  Z~ dQ „  Z dR „  Z€ y d d l Z eV a‚ Wn eƒ k
 rôeW a‚ n XdS eL f dT „  ƒ  YZ„ e„ ƒ  Z i  Z… dU „  Z† dV „  Z‡ dW „  Zˆ dX „  Z‰ dY „  ZŠ eW eV dZ „ Z‹ d[ eL f d\ „  ƒ  YZŒ eV eW d] „ Z eV d^ „ ZŽ d_ „  Z d` „  Z da „  Z‘ db eL f dc „  ƒ  YZ’ d@ eV dd „ Z“ eV de „ Z” eV df dg „ Z• eV dh „ Z– g  di „ Z— eV i  dj „ Z˜ dk „  Z™ dl „  Zš dm „  Z› dn „  Zœ do dp „ Z dq „  Zž ež dr ds dt >e du ƒ f dv ds dt >e dw ƒ f ds ds dt >e dx ƒ f dr ds dy >e dz ƒ f dv ds dy >e d{ ƒ f ds ds dy >e d| ƒ f dr ds dv >e d} ƒ f dv ds dv >e d~ ƒ f ds ds dv >e d ƒ f ds ds e d€ ƒ f ƒ
 ZŸ d „  Z  d‚ „  a¡ d d dƒ „ Z¢ d„ „  Z£ d… „  Z¤ d† „  Z¥ d‡ „  Z¦ y e§ e¨ f \ Z§ Z¨ Wn# eR k
 r£dˆ „  Z§ d‰ „  Z¨ n XeV eW dŠ „ Z© d‹ „  Zª i
 e« dŒ 6e« d 6e« dŽ 6e« d 6e« d 6eW d‘ 6eW d’ 6eW d“ 6eW d” 6eW d• 6Z¬ d– „  Z­ d— Z® eb d˜ „  e® Dƒ ƒ Z¯ d™ „  Z° dš eL f d› „  ƒ  YZ± dœ „  Z² d „  Z³ dž „  Z´ dŸ „  Zµ d  „  Z¶ d¡ „  Z· ež ds d¢ e d£ ƒ f dr ds e d¤ ƒ f dv ds e d¥ ƒ f ds ds e d¦ ƒ f dr d§ e d¨ ƒ f dv d§ e d© ƒ f ds d§ e dª ƒ f dr d« e d¬ ƒ f dv d« e d­ ƒ f ds d« e d® ƒ f dr d¯ e d° ƒ f dv d¯ e d± ƒ f ds d¯ e d² ƒ f ƒ Z¸ d
 g Z¹ d³ „  Zº d´ dµ dy f d¶ dµ dv f d· dµ dt f d¸ dµ dv f d¹ dµ dy f dº dµ dt f d» ds f f Z» d¼ „  Z¼ d½ eL f d¾ „  ƒ  YZ½ d¿ d
 e j¾ e j¿ dÀ „ ZÀ eÀ ZÁ d S(Á   s¹   Mercurial utility functions and platform specific implementations.

This contains helper routines that are independent of the SCM core and
hide platform-specific details from the core.
iÿÿÿÿ(   t   _Nt   ntt	   statfilesc         C   s   t  |  | t ƒ t k	 S(   N(   t   getattrt   _notset(   t   thingt   attr(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   safehasattrQ   s    t    c         C   s
   t  |  ƒ S(   s¹   
    Low-overhead wrapper around Python's SHA support

    >>> f = _fastsha1
    >>> a = sha1()
    >>> a = f()
    >>> a.hexdigest()
    'da39a3ee5e6b4b0d3255bfef95601890afd80709'
    (   t	   _fastsha1(   t   s(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   sha1T   s    c         C   sF   t  j d k r" d d l m } n d d l m } | a a | |  ƒ S(   Ni   i   iÿÿÿÿ(   R   (   t   sha(   i   i   (   t   syst   version_infot   hashlibR   R   R	   (   R
   t   _sha1(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR	   a   s
    
i    i   c         C   s   |  | S(   N(    (   t	   sliceablet   offset(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   bufferq   s    c         C   s   t  |  ƒ | S(   N(   t
   memoryview(   R   R   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR   t   s    t   posixc         C   sO   t  j |  d t d d d t d t  j d t  j d | d | ƒ} | j | j f S(	   Nt   shellt   bufsizeiÿÿÿÿt	   close_fdst   stdint   stdoutt   universal_newlinest   env(   t
   subprocesst   Popent   Truet   closefdst   PIPER   R   (   t   cmdR   t   newlinest   p(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   popen2z   s    	c         C   s+   t  |  | | ƒ \ } } } } | | | f S(   N(   t   popen4(   R"   R   R#   R   R   t   stderrR$   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   popen3…   s    c         C   sa   t  j |  d t d d d t d t  j d t  j d t  j d | d	 | ƒ} | j | j | j | f S(
   NR   R   iÿÿÿÿR   R   R   R'   R   R   (   R   R   R   R    R!   R   R   R'   (   R"   R   R#   R$   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR&   ‰   s    		c          C   s0   y d d l  }  |  j SWn t k
 r+ d SXd S(   s(   Return version information if available.iÿÿÿÿNt   unknown(   t   __version__t   versiont   ImportError(   R*   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR+   ’   s
    s   %Y-%m-%d %H:%M:%Ss   %Y-%m-%d %I:%M:%S%ps   %Y-%m-%d %H:%Ms   %Y-%m-%d %I:%M%ps   %Y-%m-%ds   %m-%ds   %m/%ds   %m/%d/%ys   %m/%d/%Ys   %a %b %d %H:%M:%S %Ys   %a %b %d %I:%M:%S%p %Ys   %a, %d %b %Y %H:%M:%Ss   %b %d %H:%M:%S %Ys   %b %d %I:%M:%S%p %Ys   %b %d %H:%M:%Ss   %b %d %I:%M:%S%ps   %b %d %H:%Ms   %b %d %I:%M%ps   %b %d %Ys   %b %ds   %H:%M:%Ss
   %I:%M:%S%ps   %H:%Ms   %I:%M%ps   %Ys   %Y-%ms   %bs   %b %Yc            sq   ˆ j  j d k r. g  ‰  ‡  ‡ f d †  } | Si  ‰  ˆ j  j d k r[ ‡  ‡ f d †  } n ‡  ‡ f d †  } | S(   s"   cache the result of function callsi    c              s-   t  ˆ  ƒ d k r% ˆ  j ˆ ƒ  ƒ n  ˆ  d S(   Ni    (   t   lent   append(    (   t   cachet   func(    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   fÂ   s    i   c            s'   |  ˆ  k r ˆ |  ƒ ˆ  |  <n  ˆ  |  S(   N(    (   t   arg(   R/   R0   (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR1   Ë   s    c             s'   |  ˆ  k r ˆ |  Œ  ˆ  |  <n  ˆ  |  S(   N(    (   t   args(   R/   R0   (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR1   Ð   s    (   t	   func_codet   co_argcount(   R0   R1   (    (   R/   R0   s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt	   cachefunc½   s    t   dequec           B   s   e  Z d  „  Z RS(   c         C   s8   x1 t  |  ƒ D]# \ } } | | k r |  | =Pq q Wd  S(   N(   t	   enumerate(   t   selft   valt   it   v(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   removeÝ   s    (   t   __name__t
   __module__R=   (    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR7   Ü   s   t   sortdictc           B   sk   e  Z d  Z d d „ Z d „  Z d „  Z d „  Z d „  Z d „  Z	 d „  Z
 d „  Z d	 „  Z d
 „  Z RS(   s   a simple sorted dictionaryc         C   s#   g  |  _  | r |  j | ƒ n  d  S(   N(   t   _listt   update(   R9   t   data(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   __init__å   s    	c         C   s
   t  |  ƒ S(   N(   R@   (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   copyé   s    c         C   sF   | |  k r |  j  j | ƒ n  |  j  j | ƒ t j |  | | ƒ d  S(   N(   RA   R=   R.   t   dictt   __setitem__(   R9   t   keyR:   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRG   ë   s    c         C   s   |  j  j ƒ  S(   N(   RA   t   __iter__(   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRI   ð   s    c         C   s#   x | D] } | | |  | <q Wd  S(   N(    (   R9   t   srct   k(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRB   ò   s    c         C   s   t  j |  ƒ g  |  _ d  S(   N(   RF   t   clearRA   (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRL   õ   s    c         C   s$   g  |  j  D] } | |  | f ^ q
 S(   N(   RA   (   R9   RK   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   itemsø   s    c         C   s$   t  j |  | ƒ |  j j | ƒ d  S(   N(   RF   t   __delitem__RA   R=   (   R9   RH   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRN   ú   s    c         C   s   |  j  S(   N(   RA   (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   keysý   s    c         C   s   |  j  j ƒ  S(   N(   RA   RI   (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   iterkeysÿ   s    N(   R>   R?   t   __doc__t   NoneRD   RE   RG   RI   RB   RL   RM   RN   RO   RP   (    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR@   ã   s   								t   lrucachedictc           B   s;   e  Z d  Z d „  Z d „  Z d „  Z d „  Z d „  Z RS(   s6   cache most recent gets from or sets to this dictionaryc         C   s"   i  |  _  | |  _ t ƒ  |  _ d  S(   N(   t   _cachet   _maxsizeR7   t   _order(   R9   t   maxsize(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRD     s    		c         C   s1   |  j  | } |  j j | ƒ |  j j | ƒ | S(   N(   RT   RV   R=   R.   (   R9   RH   t   value(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   __getitem__	  s    c         C   sq   | |  j  k r@ t |  j  ƒ |  j k rP |  j  |  j j ƒ  =qP n |  j j | ƒ | |  j  | <|  j j | ƒ d  S(   N(   RT   R-   RU   RV   t   popleftR=   R.   (   R9   RH   RX   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRG     s    c         C   s   | |  j  k S(   N(   RT   (   R9   RH   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   __contains__  s    c         C   s   |  j  j ƒ  t ƒ  |  _ d  S(   N(   RT   RL   R7   RV   (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRL     s    (   R>   R?   RQ   RD   RY   RG   R[   RL   (    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRS     s   					c            sR   i  ‰  t  ƒ  ‰ ˆ j j d k r9 ‡  ‡ ‡ f d †  } n ‡  ‡ ‡ f d †  } | S(   s+   cache most recent results of function callsi   c            sc   |  ˆ  k rA t  ˆ  ƒ d k r. ˆ  ˆ j ƒ  =n  ˆ |  ƒ ˆ  |  <n ˆ j |  ƒ ˆ j |  ƒ ˆ  |  S(   Ni   (   R-   RZ   R=   R.   (   R2   (   R/   R0   t   order(    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR1   $  s    c             sc   |  ˆ  k rA t  ˆ  ƒ d k r. ˆ  ˆ j ƒ  =n  ˆ |  Œ  ˆ  |  <n ˆ j |  ƒ ˆ j |  ƒ ˆ  |  S(   Ni   (   R-   RZ   R=   R.   (   R3   (   R/   R0   R\   (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR1   .  s    (   R7   R4   R5   (   R0   R1   (    (   R/   R0   R\   s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   lrucachefunc  s    	

t   propertycachec           B   s&   e  Z d  „  Z d d „ Z d „  Z RS(   c         C   s   | |  _  | j |  _ d  S(   N(   R0   R>   t   name(   R9   R0   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRD   ;  s    	c         C   s#   |  j  | ƒ } |  j | | ƒ | S(   N(   R0   t
   cachevalue(   R9   t   objt   typet   result(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   __get__>  s    c         C   s   | | j  |  j <d  S(   N(   t   __dict__R_   (   R9   Ra   RX   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR`   C  s    N(   R>   R?   RD   RR   Rd   R`   (    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR^   :  s   	c      
   C   sF   t  j | d t d t d t  j d t  j ƒ} | j |  ƒ \ } } | S(   s9   filter string S through command CMD, returning its outputR   R   R   R   (   R   R   R   R    R!   t   communicate(   R
   R"   R$   t   poutt   perr(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt
   pipefilterG  s    c   	      C   sƒ  d \ } } zt j d d ƒ \ } } t j | d ƒ } | j |  ƒ | j ƒ  t j d d ƒ \ } } t j | ƒ | j d | ƒ } | j d | ƒ } t j | ƒ } t	 j
 d k rÊ | d @rÊ d	 } n  | rõ t t d
 ƒ | t | ƒ f ƒ ‚ n  t | d ƒ } | j ƒ  } | j ƒ  | SWd y | r;t j | ƒ n  Wn t k
 rOn Xy | rit j | ƒ n  Wn t k
 r}n XXd S(   sè   filter string S through a pair of temporary files with CMD.
    CMD is used as a template to create the real command to be run,
    with the strings INFILE and OUTFILE replaced by the real names of
    the temporary files generated.t   prefixs   hg-filter-in-t   wbs   hg-filter-out-t   INFILEt   OUTFILEt   OpenVMSi   i    s   command '%s' failed: %st   rbN(   NN(   RR   t   tempfilet   mkstempt   ost   fdopent   writet   closet   replacet   systemR   t   platformt   AbortR    t   explainexitt   opent   readt   unlinkt   OSError(	   R
   R"   t   innamet   outnamet   infdt   fpt   outfdt   codet   r(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt
   tempfilterN  s<    
	
s	   tempfile:s   pipe:c         C   sV   xF t  j ƒ  D]8 \ } } | j | ƒ r | |  | t | ƒ j ƒ  ƒ Sq Wt |  | ƒ S(   sI   filter a string through a command that transforms its input to its output(   t   filtertablet	   iteritemst
   startswithR-   t   lstripRi   (   R
   R"   R_   t   fn(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   filterx  s    !c         C   s   t  |  o d |  k ƒ S(   s&   return true if a string is binary datat    (   t   bool(   R
   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   binary  s    i   i   c         c   sÚ   d „  } g  } d } x§ |  D]Ÿ } | j  | ƒ | t | ƒ 7} | | k r | | k  rž | d >} d | | ƒ >} | | k r† | } n  | | k rž | } qž n  d j | ƒ Vd } g  } q q W| rÖ d j | ƒ Vn  d S(   sr   return no less than min bytes per chunk while data remains,
    doubling min after each chunk until it reaches maxc         S   s9   |  s
 d Sd } x |  r0 |  d L}  | d 7} q W| d S(   Ni    i   (    (   t   xR;   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   log2†  s    	
i    i   R   N(   R.   R-   t   join(   t   sourcet   mint   maxR‘   t   buft   blent   chunkt   nmin(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   increasingchunksƒ  s&    		
	c         C   s   t  S(   N(   R   (   R‹   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   always¤  s    c         C   s   t  S(   N(   t   False(   R‹   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   never§  s    c         C   s!  | s t  | ƒ St j j | ƒ r… t j j |  ƒ d t j j | ƒ d k rg t j j |  t  | ƒ ƒ Sd j t |  ƒ | f ƒ } n  t | ƒ | j d ƒ } } | j	 ƒ  | j	 ƒ  x8 | rï | rï | d | d k rï | j
 ƒ  | j
 ƒ  q¸ W| j	 ƒ  t j j d g t | ƒ | ƒ p d S(   sa  return the relative path from one place to another.
    root should use os.sep to separate directories
    n1 should use os.sep to separate directories
    n2 should use "/" to separate directories
    returns an os.sep-separated path.

    If n1 is a relative path, it's assumed it's
    relative to root.
    n2 should always be relative to root.
    i    t   /iÿÿÿÿs   ..t   .(   t	   localpathRr   t   patht   isabst
   splitdriveR’   t   pconvertt	   splitpatht   splitt   reverset   popt   sepR-   (   t   roott   n1t   n2t   at   b(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   pathtoª  s    
,

#

c           C   s+   t  t d ƒ p* t  t d ƒ p* t j d ƒ S(   s™   return True if we are a frozen executable.

    The code supports py2exe (most common, Windows only) and tools/freeze
    (portable, not much used).
    t   frozent	   importerst   __main__(   R   R   t   impt	   is_frozen(    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt
   mainfrozenÆ  s    c          C   sÁ   t  d k r½ t j j d ƒ }  t j d } |  r> t |  ƒ q½ t ƒ  rW t t j	 ƒ q½ t j
 j t | d d ƒ ƒ d k r‹ t | j ƒ q½ t d ƒ p­ t j
 j t j d ƒ } t | ƒ n  t  S(   s]   return location of the 'hg' executable.

    Defaults to $HG or 'hg' in the search path.
    t   HGR²   t   __file__R   t   hgi    N(   t   _hgexecutableRR   Rr   t   environt   getR   t   modulest   _sethgexecutableRµ   t
   executableR¡   t   basenameR   R·   t   findexet   argv(   R¸   t   mainmodt   exe(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   hgexecutableÐ  s    	$%c         C   s
   |  a  d S(   s#   set location of the 'hg' executableN(   R¹   (   R¡   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR½   ã  s    c            sM  y t  j j ƒ  Wn t k
 r$ n Xd „  ‰  |  } t |  ƒ }  t  j d k r£ t  j d d k r£ t  j d d k  r£ | d k	 r‘ t j	 | ƒ n  t j
 |  ƒ } nt t j ƒ } | j ‡  f d †  | j ƒ  Dƒ ƒ t ƒ  | d <| d k sý | t  j k r't j |  d	 t d
 t d | d | ƒ} nm t j |  d	 t d
 t d | d | d t j d t j ƒ}	 x |	 j D] }
 | j |
 ƒ qjW|	 j ƒ  |	 j } t  j d k r¶| d @r¶d } n  | rI| rId t j j | j d d ƒ d ƒ t | ƒ d f } | rd | | f } n  y | j | d ƒ WqIt  k
 rE| | ƒ ‚ qIXn  | S(   s‹  enhanced shell command execution.
    run with environment maybe modified, maybe in different dir.

    if command fails and onerr is None, return status.  if ui object,
    print error message and return status, else raise onerr object as
    exception.

    if out is specified, it is assumed to be a file-like object that has a
    write() method. stdout and stderr will be redirected to out.c         S   s6   |  d k s |  t k r d S|  t k r, d St |  ƒ S(   s9   convert python object into string that is useful to shellt   0t   1N(   RR   Rœ   R   t   str(   R:   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   py2shellö  s
    t   plan9i    i   i   i   c         3   s'   |  ] \ } } | ˆ  | ƒ f Vq d  S(   N(    (   t   .0RK   R<   (   RÈ   (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pys	   <genexpr>  s    R¶   R   R   R   t   cwdR   R'   Rn   s   %s %ss   %s: %ss   
N(!   R   R   t   flusht	   Exceptiont   quotecommandRx   R   RR   Rr   t   chdirRw   RF   Rº   RB   Rˆ   RÄ   t
   __stdout__R   t   callR   R    R   R!   t   STDOUTRt   t   waitt
   returncodeR¡   R¿   R¦   Rz   t   warnt   AttributeError(   R"   Rº   RË   t   onerrt	   errprefixt   outt   origcmdt   rcR   t   proct   linet   errmsg(    (   RÈ   s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRw   è  sJ    
	"#
		"c            s   ‡  f d †  } | S(   s5   wrap a function with code to check for calling errorsc             s]   y ˆ  |  | Ž  SWnE t  k
 rX t t j t j ƒ  d ƒ ƒ d k rR t j ‚ n  ‚  n Xd  S(   Ni   i   (   t	   TypeErrorR-   t	   tracebackt
   extract_tbR   t   exc_infot   errort   SignatureError(   R3   t   kwargs(   R0   (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   check$  s    %(    (   R0   Ræ   (    (   R0   s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   checksignature"  s    c         C   s    t  j j | ƒ r t | ƒ n  t  j j |  ƒ rM t  j t  j |  ƒ | ƒ nO y$ t j |  | ƒ t j	 |  | ƒ Wn( t j
 k
 r› } t t | ƒ ƒ ‚ n Xd S(   s,   copy a file, preserving mode and atime/mtimeN(   Rr   R¡   t   lexistsR}   t   islinkt   symlinkt   readlinkt   shutilt   copyfilet   copymodet   ErrorRy   RÇ   (   RJ   t   destt   inst(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRí   .  s    c   	      C   sA  | d k r? t j |  ƒ j t j t j j | ƒ ƒ j k } n  d } t j j |  ƒ rÓ t j | ƒ xÐ t j	 |  ƒ D]X \ } } t j j
 |  | ƒ } t j j
 | | ƒ } t | | | ƒ \ } } | | 7} qt Wnd | ry t |  | ƒ Wq-t t f k
 rt } t j |  | ƒ q-Xn t j |  | ƒ | d 7} | | f S(   s1   Copy a directory tree using hardlinks if possiblei    i   N(   RR   Rr   t   statt   st_devR¡   t   dirnamet   isdirt   mkdirt   osutilt   listdirR’   t	   copyfilest   oslinkt   IOErrorR~   Rœ   Rì   RE   (	   RJ   t   dstt   hardlinkt   numR_   t   kindt   srcnamet   dstnamet   n(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyRù   ;  s(    $
sq   con prn aux nul
    com1 com2 com3 com4 com5 com6 com7 com8 com9
    lpt1 lpt2 lpt3 lpt4 lpt5 lpt6 lpt7 lpt8 lpt9s   :*?"<>|c         C   s  |  j  d ƒ r t d ƒ Sd |  k r/ t d ƒ Sxã |  j d d ƒ j d ƒ D]Æ } | s] qK n  xH | D]@ } | t k r„ t d ƒ | St | ƒ d k rd t d ƒ | Sqd W| j d	 ƒ d
 } | rá | j ƒ  t k rá t d ƒ | S| d } | d k rK | d k rK t d ƒ | SqK Wd S(   sJ  Check that the base-relative path is a valid filename on Windows.
    Returns None if the path is ok, or a UI string describing the problem.

    >>> checkwinfilename("just/a/normal/path")
    >>> checkwinfilename("foo/bar/con.xml")
    "filename contains 'con', which is reserved on Windows"
    >>> checkwinfilename("foo/con.xml/bar")
    "filename contains 'con', which is reserved on Windows"
    >>> checkwinfilename("foo/bar/xml.con")
    >>> checkwinfilename("foo/bar/AUX/bla.txt")
    "filename contains 'AUX', which is reserved on Windows"
    >>> checkwinfilename("foo/bar/bla:.txt")
    "filename contains ':', which is reserved on Windows"
    >>> checkwinfilename("foo/bar/b\07la.txt")
    "filename contains '\\x07', which is invalid on Windows"
    >>> checkwinfilename("foo/bar/bla ")
    "filename ends with ' ', which is not allowed on Windows"
    >>> checkwinfilename("../bar")
    >>> checkwinfilename("foo\\")
    "filename ends with '\\', which is invalid on Windows"
    >>> checkwinfilename("foo\\/bar")
    "directory name ends with '\\', which is invalid on Windows"
    s   \s3   filename ends with '\', which is invalid on Windowss   \/s9   directory name ends with '\', which is invalid on WindowsRž   s4   filename contains '%s', which is reserved on Windowsi   s1   filename contains %r, which is invalid on WindowsRŸ   i    iÿÿÿÿs   . s   ..s8   filename ends with '%s', which is not allowed on WindowsN(   t   endswithR    Rv   R¦   t   _winreservedcharst   ordt   lowert   _winreservednames(   R¡   R  t   ct   baset   t(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   checkwinfilename[  s,    

"				
	c         C   s–   y t  j |  | ƒ SWn; t k
 rA } | j t j k rR ‚  qR n t k
 rQ n Xt  j | t  j t  j Bt  j	 Bƒ } t  j
 | |  ƒ t  j | ƒ d  S(   N(   Rr   Rê   R~   t   errnot   EEXISTRÖ   R{   t   O_CREATt   O_WRONLYt   O_EXCLRt   Ru   (   t   infot   pathnamet   whyt   ld(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   makelock  s    	#c         C   s~   y t  j |  ƒ SWnD t k
 rG } | j t j t j f k rX ‚  qX n t k
 rW n Xt |  ƒ } | j ƒ  } | j	 ƒ  | S(   N(
   Rr   Rë   R~   R  t   EINVALt   ENOSYSRÖ   t	   posixfileR|   Ru   (   R  R  R‚   R…   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   readlockœ  s    	
c         C   s<   y t  j |  j ƒ  ƒ SWn t k
 r7 t  j |  j ƒ SXd S(   s1   stat file object that may not have fileno method.N(   Rr   t   fstatt   filenoRÖ   Rò   R_   (   R‚   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR  ©  s    c         C   s³   t  j |  ƒ } t  j j |  ƒ \ } } | j ƒ  } | | k r^ | j ƒ  } | | k r^ t Sn  t  j j | | ƒ } y' t  j | ƒ } | | k r• t St SWn t	 k
 r® t SXd S(   s¤   
    Return true if the given path is on a case-sensitive filesystem

    Requires a path (like /foo/.hg) ending with a foldable final
    directory component.
    N(
   Rr   Rò   R¡   R¦   t   upperR  R   R’   Rœ   R~   (   R¡   t   s1t   dR®   t   b2t   p2t   s2(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt	   checkcase²  s    t   _rec           B   s,   e  Z d  „  Z d d „ Z e d „  ƒ Z RS(   c         C   s:   y t  t j d d ƒ ƒ a Wn t k
 r5 t a n Xd  S(   Ns   \[([^\[]+)\]s   [ui](   RŽ   t   re2t   matcht   _re2R,   Rœ   (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt	   _checkre2Ð  s    i    c         C   s©   t  d k r |  j ƒ  n  t  r™ | t j t j B@d k r™ | t j @rT d | } n  | t j @rn d | } n  y t j | ƒ SWq™ t j k
 r• q™ Xn  t j | | ƒ S(   sã   Compile a regular expression, using re2 if possible

        For best performance, use only re2-compatible regexp features. The
        only flags from the re module that are re2-compatible are
        IGNORECASE and MULTILINE.i    s   (?i)s   (?m)N(	   R&  RR   R'  t   remodt
   IGNORECASEt	   MULTILINER$  t   compileRã   (   R9   t   patt   flags(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR+  Ø  s    !c         C   s1   t  d k r |  j ƒ  n  t  r& t j St j Sd S(   sÛ   Return the version of escape corresponding to self.compile.

        This is imperfect because whether re2 or re is used for a particular
        function depends on the flags, etc, but it's the best we can do.
        N(   R&  RR   R'  R$  t   escapeR(  (   R9   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR.  ë  s
    (   R>   R?   R'  R+  R^   R.  (    (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyR#  Ï  s   	c         C   sF  d „  } t  j } t  j r+ | t  j } n  | j d d ƒ t j d | | f ƒ } t  j j | ƒ } g  } xÊ | j |  ƒ D]¹ \ } } | r¡ | j	 | ƒ q| n  | t
 k rÃ t  j | ƒ t
 | <n  t
 | }	 | | |	 ƒ }
 |
 st  j | ƒ }	 |	 t
 | <| | |	 ƒ }
 n  | j	 |
 p| ƒ t  j j | | ƒ } q| Wd j | ƒ S(   s4  Get name in the case stored in the filesystem

    The name should be relative to root, and be normcase-ed for efficiency.

    Note that this function is unnecessary, and should not be
    called, for case-sensitive filesystems (simply because it's expensive).

    The root should be normcase-ed, too.
    c         S   s+   x$ | D] } t  | ƒ |  k r | Sq Wd  S(   N(   t   normcaseRR   (   R$   t   contentsR  (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   find  s    s   \s   \\s   ([^%s]+)|([%s]+)R   (   Rr   R©   t   altsepRv   R(  R+  R¡   t   normpatht   findallR.   t   _fspathcacheRø   R’   (   R_   Rª   R1  t   sepst   patternt   dirRc   t   partR©   R0  t   found(    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   fspathý  s.    
			

c      	   C   sÿ   |  d } t  j j | ƒ r  t Sy t | d ƒ j ƒ  Wn t k
 rK t SX|  d } d } zF y t | | ƒ Wn t	 k
 r„ t SXt | ƒ } t
 | ƒ d k SWd | d k	 r¾ | j ƒ  n  x9 | | f D]+ } y t  j | ƒ WqË t	 k
 rõ qË XqË WXd S(   s5   check whether hardlink count reporting works properlys   .hgtmp1t   ws   .hgtmp2i   N(   Rr   R¡   Rè   Rœ   R  Ru   Rû   RR   Rú   R~   t   nlinksR}   (   t   testfilet   f1t   f2t   fdR1   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt
   checknlink+  s.    

c         C   s+   |  j  t j ƒ p* t j o* |  j  t j ƒ S(   s)   Check path ends with os.sep or os.altsep.(   R  Rr   R©   R2  (   R¡   (    (    s2   /usr/lib/python2.7/dist-packages/mercurial/util.pyt   endswithsepM  s    c         C   s   |  j  t j ƒ S(   sâ   Split path by os.sep.
    Note that this function does not use os.altsep because this is
    an alternative of simple "xxx.split(os.sep)".
    It 