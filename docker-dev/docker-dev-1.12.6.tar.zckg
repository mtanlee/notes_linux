rverDisabledReasonNone,               Returned when isEnabled has returned YES.
   ISyncServerDisabledReasonByPreference,       Returned if syncing has been disabled with a preference
   ISyncServerDisabledReasonSharedNetworkHome,  Returned if another sync server is running against a network home directory.
   ISyncServerDisabledReasonUnresponsive,	    Returned if isEnabled has timed out messaging to the Sync Server  
   ISyncServerDisabledReasonUnknown,            Returned if the Sync Server fails to respond because of an unexpected error.
*/
- (NSError *)syncDisabledReason NS_DEPRECATED_MAC(10_4, 10_7);

- (ISyncClient *)clientWithIdentifier:(NSString *)clientId NS_DEPRECATED_MAC(10_4, 10_7);

/* Register a new client.  You specify here all the details needed to  sync the client - supported
   entities and relationships, formatters, etc.  In return, you get back an ISyncClient to use
   and abuse.

   The client description file is a plist containing a single dictionary.  The dictionary may contain
   any of the following keys.  For keys which specify a path, a full path name may be specified, but
   usually you will just want to specify a path relative to the description file.  Unless explicitly
   stated, all keys are optional.

      Type - a string identifying the type of client.  This string must be one of the
      following pre-defined values: "app" (an application like iCal or AB), "device" (a phone, Palm or
      iPod), "server" (.Mac) or "peer" (a peer-to-peer client).  Assume the client is an app if not
      explicitly specified.

      DisplayName - a string containing the display name for this client.

      ImagePath - path to an image of the client.  This must be an absolute path except
      when the description is taken from a file.  Then, it can be a path relative to the description
      file.

      Entities - a dictionary mapping entity names to an array.  The array contains
      an array of property names (both attributes and relationships), indentifying the
      properties supported by the client on each record type.  This field is required.

      PullOnlyEntities - an array containing the names of the entities for which the
      client will pull changes from the engine but will never push changes to the engine.

      PushOnlyEntities - an array containing the names of the entities for which the
      client will only push changes to the engine but for which it will never pull changes from
      the engine.

      NeverFormatsRelationships - This is deprecated on 10.6, see FormatsRelationships.

      FormatsRelationships - a Boolean that indicates that this client MIGHT format
      a relationship that it pulls. On 10.6 we have changed the default sense for clients
      and assume that they DO NOT format relationships.
      
      SyncsWith - a dictionary specifying the kinds of clients this client wants to sync
      with.  See -setShouldSynchronize:withClientsOfType: for details.  The dictionary contains the
      following keys:

         SyncAlertTypes - an array of the client types this client wants to sync with.

         SyncAlertToolPath - the path of a tool the engine will invoke when a client of
         the specified type starts syncing.  The tool can be passed multiple arguments on
         the command line.  At a minimum it will be passed "--sync" followed by the
         client's client id. It may also be passed "--entitynames" followed by a comma
         delimited list of entity names being synced. Any other arguments on the command
         line should be ignored. In particular, tools should be prepared to handle options
         on the command line that are not followed by a value. Options are always prefixed
         by --. Options and values are always delimited by spaces. In 10.6 one no value
         option that is sometimes passed to an alert tool is --oneshot.

   It is perfectly valid to call this method for a client that has already been registered to update
   the registration info.  Doing so is not required, however.  The engine will periodically stat the
   description file to see if it has changed and update the client description automagically.  This
   saves you from having to manually track changes to the client description.  If an upgrade lays down
   a new description file, for example, the engine will detect this and automatically pick up the
   changes to the client's description.

   Changing the client description may result in the engine forcing the client to slow sync on the
   next sync.  If a client adds support for additional properties in ISyncClientEntities, for
   example, the engine must slow-sync the client to guarantee the new keys are synchronized
   properly. */
- (ISyncClient *)registerClientWithIdentifier:(NSString *)clientId descriptionFilePath:(NSString *)descriptionFilePath NS_DEPRECATED_MAC(10_4, 10_7);

/* Remove a previously registered client */
- (void)unregisterClient:(ISyncClient *)client NS_DEPRECATED_MAC(10_4, 10_7);

/* Register a schema.  You can define new entities and relationships; you can extend an entity with
   additional attributes; you can specify a data validator; you can specify a conflict resolver; and
   you can provide localized names for your schema types.
   
   A schema is defined by a "Schema.plist" file contained in a .syncschema bundle which may contain additional
   images and code which support the plist.  The top-level object in the plist is a dictionary which may
   contain the following keys.  The engine will periodically check this file to see if it has changed.
   If the file has changed, the engine will automatically re-parse it to pick up the new schema
   definition.  This saves you from having to remember to manually re-register your schema in the event
   that it has changed.

    * Name - a string providing a unique name for this schema.  This key is required and
      you should never change the schema name.  Doing so will orphan the old schema definition and
      you will have to manually remove it.  We recommend using the reverse-DNS naming scheme,
	  e.g., "com.apple.Contacts".

    * MajorVersion an integer value numbered representing the major version of this schema. Schemas with different major
      numbers are used to indicate a major incompatible change. Including version information is optional
      but recommended. In future releases this information may be used for validation and to assist with schema migration.

    * MinorVersion an integer value number representing the minor version of this schema. Schemas with different minor
      numbers are used to indicate compatible schema changes. (Optional)

    * BaseName the name of a schema that this schema is extending. (Optional, used with BaseMajorVersion and BaseMinorVersion.)

    * BaseMajorVersion an integer value representing the major version of the schema that this schema is extending. (Optional. See BaseName.)

    * BaseMinorVersion an integer value representing the minor version of the schema that this schema is extending. (Optional. See BaseName.)

	* StrictParsing - a bool that allows opting in / out of the new strict validation of schemas in Leopard. This is a top level key in a schema.
	  If this value is true, Leopard strict validation will be used.
	  If this value is false, the same checking as under Tiger will be used.
	  If this value is not present, it will be based on the version of the SyncServices framework the registering binary linked against.  
	  If it linked against a Leopard framework version, strict validation will be used.
	  
    * DataClasses - an array containing various data class descriptions.  The data class
      description contains the following:

         Name - the name of the data class.  This key is required.  We recommend using the reverse-DNS
         naming scheme, e.g., "com.apple.Contacts". The name can be localized using the strings from Schema.strings
	     in the .syncschema bundle.

         ImagePath - the path of an image representing the data class.  For most data classes this
         will be the same image as would be used for the associated document type.  (E.g. Contacts
         would use AddressBook's .vcd image.)  The path can be an absolute path, but if it is not
		 then SyncServices will attempt to use it to load an image resource from the .syncschema bundle.

    * Entities - the value is an array of record type extension descriptions.  Each
      description is an NSDictionary describing an extension to an existing record type.  A
      description may contain the following keys; unless explicitly stated, all of the keys are
      optional:
      
         Name - the name of the entity.  This key is required.  We recommend using the reverse-DNS naming
         scheme, e.g., "com.apple.Contacts". The name can be localized using the strings from Schema.strings in
         the .syncschema bundle.

         ExtensionName - the name of this extension, if you are adding attributes to an
         existing entity.  The extension name is used to scope
         the property and relationship names to prevent collisions.  We recommend using
         the reverse-DNS naming scheme, e.g. com.apple.AddressBook.ContactsExtensions.

         DataClass - the name of the data class this entity belongs to.

         ExcludeFromDataChangeAlert - <true/> or <false/>.  Defaults to false if omitted.  If this flag is set then
         a change to this entity will not count towards the number of changed entities for the purpose
         of displaying the data change alert.

         Attributes - an array containing the description of all attributes in the extension.
         Each attribute description is a dictionary containing the following sub-keys.

            Name - the name of the attribute. The name can be localized using the strings from Schema.strings in
            the .syncschema bundle. The key for the localized name of an attribute is "$entity/$attribute_name",
            for example the key for the attribute with the Name "title" in the entity with the name
            "com.apple.things.Thing" would be "com.apple.things.Thing/title".

            Type - the type of the attribute.  Must be one of the valid attribute
            types, such as string, number, etc. On 10.6 set is also a supported type.
            
            ExcludeFromDataChangeAlert - <true/> or <false/>.  Defaults to false if omitted.  If this flag is set then
            a change to this attribute will not count towards the number of changed attributes for the purpose
            of displaying the data change alert.

            AutomaticConflictResolutionPolicy - A dictionary with one or two entries with the keys
            "PreferredClientTypes" and "PreferredRecord". The use of this keyword can help prevent conflicts.
            The value for the PreferredClientType entry is an array comprised of the client type strings e.g.,
            "app", "device", "server" and "peer".  The value for the PreferredRecord key is one of "Truth", "Client", or
            "LastModified". This property is per attribute and cannot be declared as a property of the
            Entity. One of the more common uses is to specify that the last modified value should alway be
            chosen. In this case, the PreferredClientTypes entry should be omitted. If both keys are specified,
            then they must be consistent with each other. In other words, if a client specifies a value for
            PreferredClientTypes of [app] and a PreferredRecord of LastModified, then the client that pushed the
            conflicting change that last modified the attribute must be of type app or a conflict will be
            generated.

         Relationships - an array containing the description of all relationships in the
         extension.  Each relationship description is a dictionary containing the following keys.

            Name - this is the name of the relationship.  This key is required. The name can be localized using the
            strings from Schema.strings in the .syncschema bundle. The key for the localized name of a relationship is
            "$entity/$relationship_name", for example the key for the relationship with the Name "children" in the entity with
            the name "com.apple.things.Thing" would be "com.apple.things.Thing/children".

            Target - an array containing the names of the target entities.  Generally, a
            relationship has a single target.  If the relative ordering between different
            entities must be maintained, you may specify multiple entities in the target.

            DeleteRule - cascade or nullify.  Defaults to "nullify".

            Ordinality - one or many.  Defaults to "one".

            Ordering - none, weak or strong.  Defaults to "none".

            Required - yes or no.  Defaults to "no".

            InverseRelationships - an array or pairs specifying this relationship's inverse
            relationships.  Each pair is a dictionary containing the following keys:

                EntityName - the name of the entity.

                RelationshipName - the name of the inverse relationship on that entity.

            ExcludeFromDataChangeAlert - <true/> or <false/>.  Defaults to false if omitted.  If this flag is set then
            a change to this relationship will not count towards the number of changed relationships for the purpose
            of displaying the data change alert.


         IdentityProperties - an array specifying the set of property names that are used to match a new
         record from a Sync client with an existing record. If the target of a one to one relationship
         is to be used, the name of the relationship is specified. 

         CompoundIdentityProperties - an array of array of property names. If a schema specifies both this
         and the IdentityProperties key, this key is preferred. When a record is pushed, a match is
         searched by using the identity keys declared in each of the sub-arraya in the order that they
         appear. This means that the arrays should not have property names in common. For example, the
         Contacts schema now declares its identity keys as [[first name, middle name, last name],
         [company name]]. This allows a contact pushed without a company name to match a record that
         was previously pushed with the same first and last name along with a company name.

         PropertyDependencies - an array specifying the set of dependencies between the
         properties.  A dependent property is one which must be pushed to a client if any of its
         dependencies are changed.  Each entry in the array is itself an array of strings, specifying
         the names of the co-dependent properties.  Entries may only include attribute names. Relationship
         names are disallowed.

         Parent - the name of a relationship back to the parent for this entity. A parent is an enclosing
         entity type which is used to bill changes for data change alerts and to house child records in the
         conflict manager display. As an example, a contact is the parent of a phone number. If there is a
         change to a phone number (or if a phone number is added or deleted), that will count as a change
         to the parent contact, rather than a change to the phone number. If there is a conflict on a
         phone number, it will appear as if the parent contact is in conflict, not the phone number. Not
         all contained objects have a parent - for example although a bookmark is contained in a folder,
         the folder is not considered the parent of the bookmark. The parent is used when a record is really
         a "part" of an enclosing record, such as the phone number which is a "part" of a contact.
    
	* Comment - used to insert optional comments to document the schema.
	
    * ManagedObjectModels - an array containing paths to one or more CoreData managed object models (.mom files).
        Relative paths are resolved against the .syncschema bundle's Resources directory.  As a special case, 
        you can specify a path like "../../../foo.mom" to load a model that lives outside the schema bundle 
        (eg. in the application's Resources directory).
        This registers every entity, attribute and relationship in the managed object model with Sync Services.  
        (Entity extensions cannot be specified in a model file.)  Information specific to Sync Services is specified 
        in the entity or property's 'User Info' dictionary:
 
        Entity User Info:
            "com.apple.syncservices.SyncName" - the value is a string specifying the name the entity will be 
            registered as with Sync Services.  Clients must use this name when refering to this entity.  
            The "sync" name may be different from the entity's name: Sync Services uses a global name space 
            for entities and to avoid collisions, we recommend a reverse-DNS naming scheme, 
            eg. "com.apple.contacts.Contact".  Names with '.'s in them don't work too well with CoreData, 
            so this key lets you specify a globally unique name for the entity.
            This key is optional.  If it's not specified, Sync Services tries to construct a unique name for 
            the entity: if the entity name has a '.' in it, we use that directly; otherwise, we catenate the 
            entity's data class name with the entity's name, separated by a '.'  eg. a "Contact" entity in 
            the "com.apple.contacts" data class would be registered with Sync Services as "com.apple.contacts.Contact" 
            
            "com.apple.syncservices.DataClass" - the value is a string specifying the name of the entity's data class.
            This key is required.
 
            "com.apple.syncservices.Parent" - the value is a string specifying the name of a relationship 
            back to the parent for this entity. A parent is an enclosing entity type which is used to bill changes for 
            data change alerts and to house child records in the conflict manager display. As an example, a contact is 
            the parent of a phone number. If there is a change to a phone number (or if a phone number is added or deleted), 
            that will count as a change to the parent contact, rather than a change to the phone number. If there is a 
            conflict on a  phone number, it will appear as if the parent contact is in conflict, not the phone number. 
            Not all contained objects have a parent - for example although a bookmark is contained in a folder,
            the folder is not considered the parent of the bookmark. The parent is used when a record is really
            a "part" of an enclosing record, such as the phone number which is a "part" of a contact.
 
            "com.apple.syncservices.Syncable" - "YES" or "NO". Defaults to "YES" if omitted. If this flag is set to "NO"
            then the entity will not be parsed and thus not synchronized.
 
            "com.apple.syncservices.ExcludeFromDataChangeAlert" - "YES" or "NO". Defaults to "NO" if omitted. 
            If this flag is set to "YES" then a change to this entity will not count towards the number of changed 
            entities for the purpose of displaying the data change alert.
 
            "com.apple.syncservices.IdentityProperties" - an array of array of strings (no, that's not a typo) specifying
            the properties that are used to match a new record from a sync client with an existing record.  Properties
            are identified by name, eg "((property1, property2, property3))".  At this time, only the first array of strings
            is used and any subsequent arrays are quietly ignored.
 
        Attribute and Relationship User Info: 
            "com.apple.syncservices.Syncable" - "YES" or "NO". Defaults to "YES" if omitted. If this flag is set to "NO"
            then the attribute / relationship will not be parsed and thus not synchronized.
 
            "com.apple.syncservices.ExcludeFromDataChangeAlert" - "YES" or "NO". Defaults to "NO" if omitted. If this flag
            is set to "YES" then a change to this attribute / relationship will not count towards the number of changed 
            entities for the purpose of displaying the data change alert.
 
   It is perfectly valid to call this method for a schema that has already been registered.  It is the
   recommended way to update a schema.  Certains kinds of changes may result in a slow sync of all
   clients synchronizing the constituent entities and relationships, however.  It depends on whether
   there is any overlap between the property and relationship descriptions which have changed with the
   properties and relationships supported by the client.  Changing a schema has serious implications for
   the clients synchronizing it - changes should not be undertaken lightly. */
- (BOOL)registerSchemaWithBundlePath:(NSString *)bundlePath NS_DEPRECATED_MAC(10_4, 10_7);

- (void)unregisterSchemaWithName:(NSString *)schemaName NS_DEPRECATED_MAC(10_4, 10_7);

/* This API is for sync clients that will only sync when another client, not of type application, is syncing
 * the same entities. This is NOT the preferred way that clients should sync their changes. However, for
 * various reasons, sometimes it is the only viable option. This API has been introduced in In 10.6, because
 * some clients, such as MobileMe, may no longer sync if they determine they have no changes to push or pull.
 * This API allows clients to indicate that they have changes to sync without the overhead of creating a sync
 * session. Clients that use this API, will always be alerted to sync whenever a client they sync with
 * requests a sync session, even if the requesting client would otherwise have no changes to push or
 * pull. Clients that trickle sync or push their changes periodically on their own should not call this
 * method.
 */
- (void)clientWithIdentifier:(NSString *)clientId needsSyncing:(BOOL)flag NS_DEPRECATED_MAC(10_6, 10_7);

/* Return a snapshot of the records in the Truth.  The Truth stores a copy of all synchronized records
   and contains the amalgamation of all properties from all clients.

   The snapshot is an immutable copy of the records, taken at the time you request it.  If the Truth is
   subsequently modified, the changes will not be reflected in the snapshot.  You can always ask for a
   new shapshot if you want an up-to-date copy.

   Do not use this method if you are syncing and want a snapshot of the Truth that is consistent with the
   sync session.  Another client may have mutated the Truth after the engine prepared your changes but
   before you ask for the snapshot.  If that happens, the records in this snapshot will not match the
   state in the session.  Use the method on ISyncSession instead. */
- (ISyncRecordSnapshot *)snapshotOfRecordsInTruthWithEntityNames:(NSArray /* NSString */ *)entityNames usingIdentifiersForClient:(ISyncClient *)client NS_DEPRECATED_MAC(10_4, 10_7);

/* Clients that register sync alert handlers may use the following three methods to manage the request modes
   of the connections that are sent alerts by the sync server. (These request modes are simply the runloop modes
   of the runloop that  is servicing the connection's sync alerts.) The API mirrors that of NSConnection. For
   example, a client that registers a sync alert handler in a process that might present a modal dialog to the
   user should add the appropriate request mode of the loop, so alerts can be handled in a timely manner even
   when the application is blocked for user input. */
- (void)addRequestMode:(NSString *)mode NS_DEPRECATED_MAC(10_4, 10_7);
- (void)removeRequestMode:(NSString *)mode NS_DEPRECATED_MAC(10_4, 10_7);
- (NSArray *)requestModes NS_DEPRECATED_MAC(10_4, 10_7);

@end

/* Distributed notification and task specific notification posted by the server when availability/enablement changes.
   If isEnabled returns NO, and a client wants to sync when syncing becomes enabled again, the client should register
   for this notification. 

   This notification is sent both in the case where syncing is enabled, and when it is disabled.
   When this notification is sent, the object of the notification is an NSString with the value @"YES"
   if syncing is enabled, and @"NO" if disabled. After receiving this notification, the client should
   still call -isEnabled to be absolutely sure of the state of syncing.

   For clients that use an ISyncManager they should register with the NSNotificationCenter not the NSDistributedNotificationCenter.
*/
SYNCSERVICES_EXPORT NSString * const ISyncAvailabilityChangedNotification NS_DEPRECATED_MAC(10_4, 10_7);

/* Exception raised when communication to the server is lost. The reason is a string aggregating
   the name, reason, and user info from the originating exception.
*/
SYNCSERVICES_EXPORT NSString * const ISyncServerUnavailableException NS_DEPRECATED_MAC(10_4, 10_7);


                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ISyncRecordReference.h                                                                              0100644 0001750 0001750 00000001434 12566230177 036423  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- ISyncRecordReference.h
 * Copyright (c) 2006, Apple Computer, Inc.  All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <SyncServices/ISyncRecordSnapshot.h>

/* An ISyncRecordReference serves as a persistent reference to a record, which 
   can be used to get that record's record identifier in the scope of any
   ISyncRecordSnapshot. An ISyncRecordReference can be encoded and saved,
   and later reconstituted to be used in another process.

   If the original record the ISyncRecordReference refers to is no longer present,
   if there is another record in the truth store that has the same identity
   fields as the original object, that record's record identifier will be
   returned. */
@interface ISyncRecordReference : NSObject <NSCoding>
{
}
@end

                                                                                                                                                                                                                                    ISyncRecordSnapshot.h                                                                               0100644 0001750 0001750 00000004631 12566230177 036326  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- ISyncRecordSnapshot.h
 * Copyright (c) 2004, Apple Computer, Inc.  All rights reserved.
 */

#import <Foundation/Foundation.h>


@interface ISyncRecordSnapshot : NSObject

/* Grab a set of records from the snap shot.  The key is the record id and the value is the record
   dictionary.  Deleted records and invalid record ids are not present - meaning there is no way to
   distinguish between the two. */
- (NSDictionary *)recordsWithIdentifiers:(NSArray /* NSString */ *)recordIds NS_DEPRECATED_MAC(10_4, 10_7);

/* Get the ids of the records which are the targets of a relationship on some record.  If the
   relationship is weakly or strongly ordered, the order of the ids in the array is the ordering of the
   objects in the relationship.  A record id may appear in the array multiple times.  If the
   relationship is a to-one relationship, there will only ever be one record id in the array. */
- (NSArray *)targetIdentifiersForRelationshipName:(NSString *)relationshipName withSourceIdentifier:(NSString *)sourceId NS_DEPRECATED_MAC(10_4, 10_7);

/* Get the ids of all records which have some record as a target of a relationship.  The ordering of
   the ids is irrelevant.  No record ids will be repeated in the array. */
- (NSArray *)sourceIdentifiersForRelationshipName:(NSString *)relationshipName withTargetIdentifier:(NSString *)sourceId NS_DEPRECATED_MAC(10_4, 10_7);

- (NSDictionary *)recordsWithMatchingAttributes:(NSDictionary *)attributes NS_DEPRECATED_MAC(10_4, 10_7);

@end


@class ISyncRecordReference;

@interface ISyncRecordSnapshot (ISyncRecordReference)
/* Get an ISyncRecordReference for a global identifier. The Snapshot can be scoped to any client,
   or global. The identifier must be in the record id scope of the Snapshot. */
- (ISyncRecordReference *) recordReferenceForRecordWithIdentifier:(NSString *)identifier NS_DEPRECATED_MAC(10_4, 10_7);

/* Get a record identifier in the Snapshot's scope for the reference. The Snapshot can be scoped to any
   client, or global. If pModified is non-nil, pModified is set to YES if any data internal to the
   ISyncRecordRefence has changed and set to NO if not. 

   Note that self will have mutated if *pModified == YES.  The Client should store the new reference
   in its configuration for subsequent use. */
- (NSString *) recordIdentifierForReference:(ISyncRecordReference *)reference isModified:(BOOL *)pModified NS_DEPRECATED_MAC(10_4, 10_7);
@end

                                                                                                       ISyncSession.h                                                                                      0100644 0001750 0001750 00000042706 12566230177 035020  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- ISyncSession.h
 * Copyright (c) 2003, Apple Computer, Inc.  All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <SyncServices/ISyncCommon.h>


@class ISyncChange, ISyncClient, ISyncRecordSnapshot;


@interface ISyncSession : NSObject

/* Phase I: negotiating the sync mode. */
+ (ISyncSession *)beginSessionWithClient:(ISyncClient *)client entityNames:(NSArray /* entity name */ *)entityNames beforeDate:(NSDate *)date NS_DEPRECATED_MAC(10_4, 10_7);

/* Returns immediately and invokes a target callback when the session can start or if the session.
   cannot be started. The target is invoked with the selector and two arguments, the ISyncClient
   and the ISyncSession. The selector should be of this form:
   -(void)client:(ISyncClient *)can beginSession:(ISyncSession *)session;
   If the session cannot be started, the session parameter is nil.
*/
+ (void)beginSessionInBackgroundWithClient:(ISyncClient *)client entityNames:(NSArray /* entity name */ *)entityNames target:(id)target selector:(SEL)selector NS_DEPRECATED_MAC(10_4, 10_7);
+ (void)cancelPreviousBeginSessionWithClient:(ISyncClient *)client NS_DEPRECATED_MAC(10_4, 10_7);

/* If a client is using sync anchors, when starting a sync session, the client passes in the previous
   sync anchors, one per entity. The anchors dictionary is a map from the entity name to the sync anchor
   value, and the values are the anchors as last set in the previous sync's calls to the methods
   clientFinishedPushingChangesWithNextAnchors or clientCommittedAcceptedChanges. As a convenience, the
   user may specify a mapping for a single entity name for some representative entity of a
   dataclass. However, if more than one mapping per dataclass is provided, then mappings are required
   for every entity name being synchronized. The lack of a mapping in this case will force the entity
   without a mapping to be refreshed.
    
   The values that are passed in are compared to the previous values. If an anchor does not match for
   an entity, then the method shouldPushAllRecordsForEntityName will return YES for this entity.
    
   If there is no value for a entity's anchor, then the entity can either be left out of the dictionary,
   or even better, the value [NSNull null] can be can be put in the dictionary for that entity name. If
   there is no value the client will be refreshed and the sync will be treated as if it is the first
   sync done by the client. The null value (or lack of value) for an anchor should be used on the
   client's first sync (when there would be no value in the client's data store), or when the data store
   is cleared or lost.

   nil is an acceptable value for the dictionary, and will always result in a full refresh sync for all
   the entities specified in the sync.

   If a client is using sync anchors, it should also call the method
   clientFinishedPushingChangesWithNextAnchors after pushing changes, and call the sync anchor variant
   of clientCommittedAcceptedChanges as outlined below. Failure to make these calls will likely result
   in the next sync of these entities being a refresh sync. Finally, an exception will be raised if
   these methods are called on a session that was created using the earlier API that did not include a
   lastAnchors argument.
*/
+ (ISyncSession *)beginSessionWithClient:(ISyncClient *)client entityNames:(NSArray /* entity name */ *)entityNames beforeDate:(NSDate *)date lastAnchors:(NSDictionary /* string entity name -> string anchor */ *)anchors NS_DEPRECATED_MAC(10_5, 10_7);

+ (void)beginSessionInBackgroundWithClient:(ISyncClient *)client entityNames:(NSArray /* entity name */ *)entityNames target:(id)target selector:(SEL)selector lastAnchors:(NSDictionary /* string entity name -> string anchor */ *)anchors NS_DEPRECATED_MAC(10_5, 10_7);

// + (ISyncSession *)beginSessionWithClient:(ISyncClient *)client entityNames:(NSArray /* entity name */ *)entityNames beforeDate:(NSDate *)date lastAnchors: (NSDictionary *)anchors hasChanges:(BOOL)flag error: (NSError **)error;

/* The default is to assume that a client will be fast syncing all the entities specified when the
   session was created.  Telling the engine that a client was reset is tantamount to saying "forget
   everything you ever knew about me and let's start over again".  In sync parlance, this is what we
   call a refresh sync.  Telling the engine that you want to push all records (ie. slow syncing) just
   means that you, the client, can't figure out which records have changed since the last sync and so
   you're going to give all of your records to the engine.  The engine will figure out what has changed
   since the last sync and only provide to you the appropriate sets of changes. */
- (void)clientDidResetEntityNames:(NSArray /* NSString */ *)entityNames NS_DEPRECATED_MAC(10_4, 10_7);
- (void)clientWantsToPushAllRecordsForEntityNames:(NSArray /* NSString */ *)entityNames NS_DEPRECATED_MAC(10_4, 10_7);

/* These methods query how the engine is going to sync you, the client. -shouldPushChangesForEntityName:
   returns NO if you should not push any changes for an entity.  -shouldPushAllRecordsForEntityName:
   returns YES if you should give to the engine all of your records.  (What we call "slow syncing" in our
   parlance.)  Converseley, -shouldPullChangesForEntityName: returns NO if the engine will not be giving
   you any changes for an entity and -shouldReplaceAllRecordsOnClientForEntityName: returns YES if you
   should delete all of your records and replace them with the records the engine will hand you.  To a
   certain extent, these values may be modified by the methods -clientDidResetEntityNames: and
   -clientWantsToPushAllRecordsForEntityNames: as described above. */
- (BOOL)shouldPushChangesForEntityName:(NSString *)entityName NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)shouldPushAllRecordsForEntityName:(NSString *)entityName NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)shouldPullChangesForEntityName:(NSString *)entityName NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)shouldReplaceAllRecordsOnClientForEntityName:(NSString *)entityName NS_DEPRECATED_MAC(10_4, 10_7);


/* Phase II: pushing changes from the client.  You can create an ISyncChange object yourself and
   push that directly, or you can give the engine the entire record and let it figure out what
   the changes are.  If you are pushing the record, it should represent the entire state of the
   record from your backing store.  At the very least, every record dictionary MUST have an attribute
   identifying the entity this record is an instance of, keyed to ISyncRecordEntityNameKey.

   Consider, for example, some (purely fictional) contact with two email address.  The path of the
   first name is "first name".  There are two relationships involving this contact, one for the
   home address and one for the email addresses.  There is one home address, identified by the
   record 1492.address1, and two email addresses, 1492.email1 and 1492.email2.  The record dictionaries
   for these four records might look something like the following:

        1492 {
            ISyncRecordEntityNameKey = Contact;
            first name = Edgar;
            last name = Qwerty;
            Contact to Address = ( 1492.address1 );
            Contact to EmailAddress = ( 1492.email1, 1492.email2 );
        }
        
        1492.address1 {
            ISyncRecordEntityNameKey = Address;
            label = home;
            street = 123 Main St.;
            city = Everywhere;
            country = USA;
            postal code = 90210;
        }

        1492.email1 {
            ISyncRecordEntityNameKey = EmailAddress;
            type = home;
            email = asdf@asdf.com;
        }

        1492.email2 {
            ISyncRecordEntityNameKey = EmailAddress;
            type = work;
            label = summer cottage;
            email = qwerty@keyboard.com;
        }
*/
- (void)pushChange:(ISyncChange *)change NS_DEPRECATED_MAC(10_4, 10_7);
- (void)pushChangesFromRecord:(NSDictionary *)record withIdentifier:(NSString *)recordId NS_DEPRECATED_MAC(10_4, 10_7);

/* A convenience to delete a record so you don't have to manually construct an ISyncChange. */
- (void)deleteRecordWithIdentifier:(NSString *)recordId NS_DEPRECATED_MAC(10_4, 10_7);

/* The proverbial "soft delete".  This indicates that a record no longer exists on the client but this
   should not be considered a delete.  This method is special in that it can be used during either the
   push phase and the pull phase.

   You may specify whether or not you want the record back (as an add) during the next pull phase.  If you
   call this method during the push phase and say YES, the record will be re-applied in the pull phase
   of this same session.  If you call this method during the pull phase, it will be replaced in the
   pull phase of the next session. 

   When invoked with flag set to NO during the pulling phase, this is equivalent
   to refusing a record using the method clientRefusedChangesForRecordWithIdentifier:

   This method will not touch the client info, if any, associated with this record.
*/
- (void)clientLostRecordWithIdentifier:(NSString *)recordId shouldReplaceOnNextSync:(BOOL)flag NS_DEPRECATED_MAC(10_4, 10_7);

/* If a client is using Sync Anchors, after pushing all changes, a client must create a new sync anchor
   string for each entity name that was synced, save the anchors in the client datastore, and pass the
   anchors to clientFinishedPushingChangesWithNextAnchors. As a convenience a single representative
   entity name to anchor mapping may be used for all of the entities in a dataclass. If the client is
   pulling the truth, the anchor is specified when calling clientCommittedAcceptedChanges.
*/
- (void)clientFinishedPushingChangesWithNextAnchors:(NSDictionary /* string entity  name -> string anchor */ *)anchors NS_DEPRECATED_MAC(10_5, 10_7);

/* Phase III: pulling changes for the client.  The entities that you specify here must be a subset of
   the entities specified when the session was created. */
- (BOOL)prepareToPullChangesForEntityNames:(NSArray /* NSString */ *)entityNames beforeDate:(NSDate *)date NS_DEPRECATED_MAC(10_4, 10_7);
- (void)prepareToPullChangesInBackgroundForEntityNames:(NSArray /* NSString */ *)entityNames target:(id)target selector:(SEL)selector NS_DEPRECATED_MAC(10_4, 10_7);

- (NSEnumerator /* ISyncChange */ *)changeEnumeratorForEntityNames:(NSArray /* NSString */ *)entityNames NS_DEPRECATED_MAC(10_4, 10_7);

- (void)clientAcceptedChangesForRecordWithIdentifier:(NSString *)recordId formattedRecord:(NSDictionary *)formattedRecord newRecordIdentifier:(NSString *)recordId NS_DEPRECATED_MAC(10_4, 10_7);

/* This method informs the sync engine that the client has
   refused to apply the changes for the record specified by recordIdentifier.

   After invoking this method, the sync engine will not send the same change
   during any subsequent syncs unless the record is modified. Use filtering if
   you want to permanently ignore some records. Refusing a record does not
   change the local id mapping for the client. Invoking this method will not
   effect other clients participating in the same sync session.

   This method will not touch the client info, if any, associated with this record.
*/
- (void)clientRefusedChangesForRecordWithIdentifier:(NSString *)recordId NS_DEPRECATED_MAC(10_4, 10_7);
- (void)clientCommittedAcceptedChanges NS_DEPRECATED_MAC(10_4, 10_7);
/* If a client is using sync anchors, after accepting pulled changes, a client must create a new sync anchor
   string for each entity that was synced, save the anchors in the client datastore, and pass the anchors to
   the call to clientCommittedAcceptedChangesWithNextAnchors. As a convenience a single representative entity
   name to anchor mapping may be used for all of the entities in a dataclass. If a client is pushing the
   truth, this method won't be called, but that is fine, as the sync anchors passed into the method
   clientFinishedPushingChangesWithNextAnchors will be used.
*/
- (void)clientCommittedAcceptedChangesWithNextAnchors:(NSDictionary /* string entity name -> string anchor */ *)anchors NS_DEPRECATED_MAC(10_5, 10_7);

- (void)clientChangedRecordIdentifiers:(NSDictionary *)oldToNew NS_DEPRECATED_MAC(10_4, 10_7);

- (BOOL)isCancelled NS_DEPRECATED_MAC(10_4, 10_7);
- (void)cancelSyncing NS_DEPRECATED_MAC(10_4, 10_7);
- (void)finishSyncing NS_DEPRECATED_MAC(10_4, 10_7);

/* Conduit-specific, unsynchronized information stored with a record.  The data is removed when
   the client removes the associated record.  You can specify any object here, but it must conform
   to the NSCoding protocol. */
- (id)clientInfoForRecordWithIdentifier:(NSString *)recordId NS_DEPRECATED_MAC(10_4, 10_7);
- (void)setClientInfo:(id <NSCoding>)clientInfo forRecordWithIdentifier:(NSString *)recordId NS_DEPRECATED_MAC(10_4, 10_7);

/* Return a snapshot of the records in the Truth.  ISyncSession creates two snap shots during the sync.
   The first is made when the session is created.  The second is made at the same time as the changes
   for the client are prepared (when -prepareToPullChangesForEntityNames:beforeDate: is called).
   Compare to the method on ISyncManager. */
- (ISyncRecordSnapshot *)snapshotOfRecordsInTruth NS_DEPRECATED_MAC(10_4, 10_7);

/* Clients can call this method to inform the server that they are still alive
   but doing something that keeps them busy and prevents them from talking to the server
   process. This will prevent the server from timing them out on the watchdog. */ 
- (void)ping NS_DEPRECATED_MAC(10_5, 10_7);

@end


/* This exception may be thrown from any instance method on ISyncSession.  It indicates that the sync
   session has been cancelled, either directly on the session using -cancelSyncing or externally by
   someone else.

   If a sync is cancelled during the negotiate phase, the negotiations simply fail and
   +beginSessionWithClient:entityNames:beforeDate:(NSDate *)date returns nil.

   If a sync is cancelled during the push phase, no further changes from the client will be accepted.  The
   changes that have been accepted will be discarded.  If a client cannot provide those changes on a
   subsequent sync, it must force a slow sync.  The client cannot proceed to the mingle and pull
   phases.

   If a sync is cancelled during the mingle phase (ie. the exception is thrown from
   -prepareToPullChangesForEntityNames:beforeDate:), the changes that have been accepted from the
   client will still be applied.  On the next sync the client should only supply new changes.
   The client cannot proceed to the pull phase.

   If a sync is cancelled during the pull phase, the changes that have not been accepted or rejected by
   the client and explicitly committed (using -clientCommittedAcceptedChanges) will be given to the
   client again on a subsequent sync.  After a cancellation, a client may continue to accept or reject
   the changes it received prior to the cancellation; it may invoke -clientCommittedAcceptedChanges to
   indicate its acceptance of these changes; and it may use -clientChangedRecordIdentifiers: to update
   the client Ids.  It will not be given any further changes, however. */
SYNCSERVICES_EXPORT NSString * const ISyncSessionCancelledException NS_DEPRECATED_MAC(10_4, 10_7);

SYNCSERVICES_EXPORT NSString * const ISyncSessionUnavailableException NS_DEPRECATED_MAC(10_4, 10_7);

/* This exception may be thrown during the push phase.  It is thrown when the engine detects the client
   trying to push "bad" data - bad data being defined as anything which fails a data validation test.
   The engine has some built in validators, to check records conform to a schema specification.

   I wish I could say the exception will be thrown as soon as a bad record is applied by the client, but
   this may not be the case.  Some validation checks can only be done when additional context has been
   gathered; and for efficiency reasons, the engine may defer processing until a threshold of changes
   have been applied.

   The userInfo object in the exception contains the list of rejected records and the reasons for each. */
SYNCSERVICES_EXPORT NSString * const    ISyncInvalidRecordException NS_DEPRECATED_MAC(10_4, 10_7);
SYNCSERVICES_EXPORT NSString * const    ISyncInvalidRecordIdentifiersKey NS_DEPRECATED_MAC(10_4, 10_7); // an array of record ids
SYNCSERVICES_EXPORT NSString * const    ISyncInvalidRecordReasonsKey NS_DEPRECATED_MAC(10_4, 10_7); // a dictionary, keyed by record id
SYNCSERVICES_EXPORT NSString * const    ISyncInvalidRecordsKey NS_DEPRECATED_MAC(10_4, 10_7); // a dictionary, keyed by record id


/* These exceptions are thrown when trying to synchronize an invalid entity (one that has not been
   registered) or a valid entity that the client was not registered to synchronize. */
SYNCSERVICES_EXPORT NSString * const ISyncInvalidEntityException NS_DEPRECATED_MAC(10_4, 10_7);
SYNCSERVICES_EXPORT NSString * const ISyncUnsupportedEntityException NS_DEPRECATED_MAC(10_4, 10_7);

/* Other exceptions that can be generated on 10.6 include
 * ISyncInvalidSchemaException and ISyncInvalidArgumentsException.  These are
 * declared in SyncServicesErrors.h. On 10.5.6 NSInternalInconsistencyException
 * or NSInvalidArgumentsException exceptions when raised indicate an internal
 * problem that was encountered either because of some sort of data corruption,
 * an internal bug, or an unhandled condition. */


/* Every record passed to the sync engine (and every record received from the sync engine) must be
   associated with an entity.  The name of the entity is stored in the record dictionary using
   this key. */
SYNCSERVICES_EXPORT NSString * const ISyncRecordEntityNameKey NS_DEPRECATED_MAC(10_4, 10_7);
                                                          ISyncSessionDriver.h                                                                                0100644 0001750 0001750 00000045262 12566230177 036174  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- ISyncSessionDriver.h
 * Copyright (c) 2003, Apple Computer, Inc.  All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <SyncServices/ISyncCommon.h>

@protocol ISyncSessionDriverDataSource;

/* These are the allowed return values for - (ISyncSessionDriverMode)preferredSyncModeForEntityName:(NSString *)entity;
   A value of Fast indicates that we should attempt a fast sync with the server
    - note that the sync server may instead require a slow sync
   A value of Slow indicates that the Data Source will be asked for every record
   A value of Refresh indicates that the driver will call clientDidResetEntityNames:(NSArray *)entityNames
   on the ISyncSession being driven.  See ISyncSession.h for a discussion on sync modes */
typedef enum {
    ISyncSessionDriverModeFast = 1,
    ISyncSessionDriverModeSlow,
    ISyncSessionDriverModeRefresh,
} ISyncSessionDriverMode NS_DEPRECATED_MAC(10_4, 10_7);

/* These are the allowed return values for 
   - (ISyncSessionDriverChangeResult)applyChange:(ISyncChange *)change
      forEntityName:(NSString *)entityName
      remappedRecordIdentifier:(NSString **)outRecordIdentifier
      formattedRecord:(NSDictionary **)outRecord
      error:(NSError **)outError;
   A value of Refused means that the incoming change was refused by the client.
   A value of Accepted means that the incoming change was accepted by the client.
   A value of Ignored means that the incoming change will neither be accepted nor rejected by the client.
    If no other action is taken on the record in question, the client will pull the record on its next sync.
   A value of Error means that an error has occured, and that the sync should be cancelled.
*/
typedef enum {
    ISyncSessionDriverChangeRefused = 0,
    ISyncSessionDriverChangeAccepted,
    ISyncSessionDriverChangeIgnored,
    ISyncSessionDriverChangeError
} ISyncSessionDriverChangeResult NS_DEPRECATED_MAC(10_4, 10_7);

@class ISyncClient, ISyncSession, ISyncChange;

@interface ISyncSessionDriver : NSObject {
}

/* The designated method to create an ISyncSessionDriver.
   The driver can be reused for multiple sync sessions.
   Sample usage case:
   ISyncSessionDriver *sessionDriver = [[ISyncSessionDriver sessionDriverWithDataSource:myDataSource] retain];
   BOOL success = [sessionDriver sync];
   if (!success) myError = [sessionDriver lastError]; */
+ (ISyncSessionDriver *)sessionDriverWithDataSource:(id <ISyncSessionDriverDataSource>)dataSource NS_DEPRECATED_MAC(10_4, 10_7);

/* Initiate a sync.
   The driver will register the ISyncClient if it is not already registered.
   The driver will create an ISyncSession. */
- (BOOL)sync NS_DEPRECATED_MAC(10_4, 10_7);

/* This initiates an asynchronous sync.
   If the driver is unable to create a sync session, this call will return NO, and outError will contain the error.
   If the driver is able to create a sync session, this call will return YES.  Any errors that occur during a sync
   will cause sessionDriverDidCancelSession: to be called, and the error will be available via lastError
   Clients invoking this method must pay attention to the
   delegate callbacks sessionDriverDidFinishSession: and sessionDriverDidCancelSession: to determine
   if the sync succeeded or failed. */
- (BOOL)startAsynchronousSync:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

/* If a previous call to sync returned NO, this method will return the error associated with that failed sync.
   This error is only valid until the driver begins a new sync */
- (NSError *)lastError NS_DEPRECATED_MAC(10_4, 10_7);

/* Get the data source object, which implements the ISyncSessionDriverDataSource Protocol.
   When an ISyncSessionDriver instance receives a sync invocation, it will 
   call back to the data source object for its data. */
- (id <ISyncSessionDriverDataSource>)dataSource NS_DEPRECATED_MAC(10_4, 10_7);

/* Set and get the delegate object.  If no delegate is supplied, an ISyncSessionDriver will use the
   dataSource object as the delegate. */
- (void)setDelegate:(id /*implements ISyncSessionDriverDelegate Informal Protocol*/)delegate NS_DEPRECATED_MAC(10_4, 10_7);
- (id /*implements ISyncSessionDriverDelegate Informal Protocol*/)delegate NS_DEPRECATED_MAC(10_4, 10_7);

/* Set and get shouldSyncOnAlert.  If this is true, then the driver will register as a sync alert handler.
   When the client is requested to join a sync, the driver will initiate a sync, and behave as though
   its -sync method was invoked. 
   This value defaults to NO */
- (void)setHandlesSyncAlerts:(BOOL)yesOrNo NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)handlesSyncAlerts NS_DEPRECATED_MAC(10_4, 10_7);

/* Get the ISyncClient. The ISyncSessionDriver will construct an ISyncClient with the clientIdentifier
   specified by the data source. */
- (ISyncClient *)client NS_DEPRECATED_MAC(10_4, 10_7);

/* Get the ISyncSession.  The ISyncSessionDriver will create an ISyncSession as part of its
   sync method.  When the driver returns from an invocation of sync, and when either of 
   the delegate methods
   - (void)sessionDriverDidFinishSession:(ISyncSessionDriver *)sender;
   - (void)sessionDriverDidCancelSession:(ISyncSessionDriver *)sender;
   are called, the session object is no longer valid, and the driver will return nil.
   This method should be called only on the same thread in which the sync method has been invoked. */
- (ISyncSession *)session NS_DEPRECATED_MAC(10_4, 10_7);

/* Finish the current sync session.  This method should be used when a client wants to prematurely finish a sync session.
   This method should be used instead of [[sessionDriver session] finishSyncing] for all ISyncSessionDriverDataSources.
   If this method is invoked while the Driver is waiting for the Data Source to return from a callback,
   the return value of that callback is dropped. */
- (void)finishSyncing NS_DEPRECATED_MAC(10_4, 10_7);

@end

@protocol ISyncSessionDriverDataSource

/* Returns a unique client identifier to represent the client to the sync engine.
   This method is invoked when creating a sync client before beginning a sync session.
   Each client is identified by an id.  There are no restrictions on the content or length of an
   id, but it must be unique across all clients.  This is specified when the client is registered
   and can never be changed afterwards. */
- (NSString *)clientIdentifier NS_DEPRECATED_MAC(10_4, 10_7);

/* Returns a NSURL to the client's description property list.
   See ISyncManager.h for documentation regarding the layout of this plist. */
- (NSURL *)clientDescriptionURL NS_DEPRECATED_MAC(10_4, 10_7);

/* Returns a NSArray of NSURLs, each of which is a Schema Bundle
   See ISyncManager.h for documentation regarding the layout of schema bundles. */
- (NSArray * /* NSURL */)schemaBundleURLs NS_DEPRECATED_MAC(10_4, 10_7);

/* Method called during the negotiate phase of an ISyncSession */

/* Returns the sync type the client wants for any entity. */
- (ISyncSessionDriverMode)preferredSyncModeForEntityName:(NSString *)entity NS_DEPRECATED_MAC(10_4, 10_7);


/* Method called during the push phase of an ISyncSession */

/* Called with an entity to be slow synced. This returns a dictionary mapping one or more
   records (value) to their record identifiers (key). The records should be dictionaries
   suitable to be passed in to the sync server.
   To help with memory performance, the data source may choose to only return some records 
   during any given invocation of this method.  In that case, the data source should set
   *moreComing to YES.  The driver will repeatedly call this method on the data source with the
   same entity name, until the data source does not set *moreComing to YES.
   If the data source has no records to return, it should return an empty NSDictionary.
   If an error occurs in the data source, it should return nil, and set *outError to an NSError.
   If nil is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError. */
- (NSDictionary *)recordsForEntityName:(NSString *)entity moreComing:(BOOL *)moreComing error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);


/* Methods called during the pull phase of an ISyncSession */

/* Apply the specified ISyncChange.
   If the change is of type ISyncChangeTypeAdd or ISyncChangeTypeModify, and the change was accepted,
   the client can specify a local id by setting *outRecordIdentifier.  If the client formats the incoming record,
   it should set *outRecord to the new record.  If the client does not format the incoming record, it
   should not set *outRecord.
   outRecordIdentifier and outRecord will never be nil for ISyncChangeTypeAdd and ISyncChangeTypeModify
   If *outRecordIdentifier is not set, and the change is of type ISyncChangeTypeAdd, the record's global id will be used.
   If *outRecordIdentifier is not set, and the change is of type ISyncChangeTypeModify, the record's current local id will be used.
   If the change is of type ISyncChangeTypeDelete, *outRecordIdentifier and *outRecord are ignored.
   If an error occurs in the data source, it should return ISyncSessionDriverChangeError,
   and set *outError to an NSError.
   If ISyncSessionDriverChangeError is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError. */
- (ISyncSessionDriverChangeResult)applyChange:(ISyncChange *)change forEntityName:(NSString *)entityName remappedRecordIdentifier:(NSString **)outRecordIdentifier formattedRecord:(NSDictionary **)outRecord error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

/* Called when the data source should remove all its records for an entity
   Clients should return YES if the resulting deletes were accepted.
   If an error occurs in the data source, it should return NO, and set *outError to an NSError.
   If NO is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError. */
- (BOOL)deleteAllRecordsForEntityName:(NSString *)entityName error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

@optional

/* Returns a NSArray of NSStrings, each of which represents an entity to be synced
 Return an empty array to specify that no entities should be synced
 If this method is not implemented, ISyncSessionDriver will construct sync sessions
 with each entity listed in the client description that is enabled for the client. */
- (NSArray * /* NSString */)entityNamesToSync NS_DEPRECATED_MAC(10_4, 10_7);

/* This optional method should be implemented by clients that wish to pull a subset
 of the entities being pushed.  If this method is not implemented, ISyncSessionDriver
 will pull the same entities that were pushed
 Return an empty array to specify that no entities should be pulled */
- (NSArray * /* NSString */)entityNamesToPull NS_DEPRECATED_MAC(10_4, 10_7);

/* How long the client will wait for the Sync Server to begin a new session.
 If the data source doesn't implement this method, the default is 60.0 seconds */
- (NSTimeInterval)sessionBeginTimeout NS_DEPRECATED_MAC(10_4, 10_7);

/* How long the client will wait for the Sync Server in prepareToPullChanges
 If the client doesn't implement this method, the default is 600.0 seconds */
- (NSTimeInterval)sessionPullChangesTimeout NS_DEPRECATED_MAC(10_4, 10_7);

/* A data source must implement both, or neither of the following methods.
 See ISyncSession.h for a description of sync anchors
 lastSyncAnchorForEntityName: will be called immediately after a session is begun.
 nextSyncAnchorForEntityName: will be called immediately before prepareToPullChanges...
 is called on a sync session, and immediately before clientCommittedAcceptedChanges
 is called on a sync session.  An ISyncSessionDriver calls clientCommittedAcceptedChanges
 once per session, just before calling finishSyncing on that session.
 */

/* The data source should return the stored sync anchor from the last sync for the given entity name.
 * A client may specify a single anchor for a representative entity that will be used for all entities
 * in the dataclass. Such a representative entity must always be syncd by the client. If a client uses
 * a representative entity, then this method should return nil for all the other entities in a dataclass.*/
- (NSString *)lastAnchorForEntityName:(NSString *)entityName NS_DEPRECATED_MAC(10_4, 10_7);

/* The data source should create a new sync anchor for the given entity name, and store it
 alongside the data being synced. As in lastAnchorForEntityName: a client may specify a single
 anchor  for a representative entity of a dataclass. */
- (NSString *)nextAnchorForEntityName:(NSString *)entityName NS_DEPRECATED_MAC(10_4, 10_7);

/* Methods called during the push phase of an ISyncSession */

/* Called with an entity to be fast synced. This returns a dictionary mapping one or more
 records (value) to their record identifiers (key).
 The values should be full sync records.
 To help with memory performance, the data source may choose to only return some records
 during any given invocation of this method.  In that case, the data source should set
 *moreComing to YES.  The driver will repeatedly call this method on the data source with the
 same entity name, until the data source does not set *moreComing to YES.
 All sync session driver data sources that request a fast sync must respond to
 one or both of this message and changesForEntityName:moreComing:
 If the data source has no changed records to return, it should return an empty NSDictionary.
 If an error occurs in the data source, it should return nil, and set *outError to an NSError.
 If nil is returned, the sync session will be cancelled, the sync method will return NO, and
 calls to lastError will return *outError. */
- (NSDictionary *)changedRecordsForEntityName:(NSString *)entity moreComing:(BOOL *)moreComing error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

/* Called with an entity to be fast synced. This returns an array of one or more ISyncChange-s.
 To help with memory performance, the data source may choose to only return some changes 
 during any given invocation of this method.  In that case, the data source should set
 *moreComing to YES.  The driver will repeatedly call this method on the data source with the
 same entity name, until the data source does not set *moreComing to YES.
 All sync session driver data sources that request a fast sync must respond to 
 one or both of this message and changedRecordsForEntityName:moreComing:
 If the data source has no changed records to return, it should return an empty NSArray.
 If an error occurs in the data source, it should return nil, and set *outError to an NSError.
 If nil is returned, the sync session will be cancelled, the sync method will return NO, and
 calls to lastError will return *outError. */
- (NSArray *)changesForEntityName:(NSString *)entity moreComing:(BOOL *)moreComing error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

/* Called with an entity to be fast synced.  This returns an array of record identifiers of
 the deleted records for pushing.
 This method is an alternative to returning ISyncChanges of type ISyncChangeTypeDelete from a
 call to changesForEntityName:moreComing:
 To help with memory performance, the data source may choose to only return some record identifiers
 during any given invocation of this method.  In that case, the data source should set
 *moreComing to YES.  The driver will repeatedly call this method on the data source with the
 same entity name, until the data source does not set *moreComing to YES.
 If the data source has no identifiers of deleted records to return, it should return an empty NSArray.
 If an error occurs in the data source, it should return nil, and set *outError to an NSError.
 If nil is returned, the sync session will be cancelled, the sync method will return NO, and
 calls to lastError will return *outError. */
- (NSArray *)identifiersForRecordsToDeleteForEntityName:(NSString *)entityName moreComing:(BOOL *)moreComing error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

@end


@interface NSObject (ISyncSessionDriverDelegate)

/* Convenience methods.  These are called back to the client at different stages of the sync.
   If an error occurs in the delegate, it should return NO, and set *outError to an NSError.
   If NO is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError.
   Beware that if the delegate raises in any of these callbacks
   (except sessionDriverWillCancelSession:, sessionDriverDidCancelSession:, and sessionDriverDidFinishSession:)
   any existing sync session will be cancelled. */
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender didRegisterClientAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender willNegotiateAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender didNegotiateAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender willPushAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender didPushAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender willPullAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender didPullAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

/* Either the Finish callbacks or Cancel callbacks will be called.
   If the Finish callbacks are called, the Cancel callbacks will not be called.
   If the Cancel callbacks are called, the Finish callbacks will not be called. */
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender willFinishSessionAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);
/* For the following callbacks, either the session is completed
   (sessionDriverDidFinishSession: and sessionDriverDidCancelSession:)
   or the session is already set to cancel, due to a previous error
   (sessionDriverWillCancelSession:) */
- (void)sessionDriverDidFinishSession:(ISyncSessionDriver *)sender NS_DEPRECATED_MAC(10_4, 10_7);
- (void)sessionDriverWillCancelSession:(ISyncSessionDriver *)sender NS_DEPRECATED_MAC(10_4, 10_7);
- (void)sessionDriverDidCancelSession:(ISyncSessionDriver *)sender NS_DEPRECATED_MAC(10_4, 10_7);

/* This delegate method is called when the session driver receives a sync alert.  It allows a client to do any setup before the
   session driver calls its sync: method. If this method is implemented in a client, a failure to establish a session during a
   sync alert will cause the sessionDriver to call the sessionDriverDidCancelSession: delegate. */
- (BOOL)sessionDriver:(ISyncSessionDriver *)sender didReceiveSyncAlertAndReturnError:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7);

@end

                                                                                                                                                                                                                                                                                                                                              ISyncUIHelper.h                                                                                     0100644 0001750 0001750 00000010662 12566230177 035046  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- ISyncUIHelper.h
 * Copyright (c) 2004, Apple Computer, Inc.  All rights reserved.
 */

/* Schema authors who wish to have more control over the display of their changed records (in the DCA), 
   and their conflicts (in Conflict Resolver.app), than just changing the names of attributes, etc.
   will need to implement their own custom UI code, which will be loaded into the syncuid.app (for the DCA),
   or Conflict Resolver.app (for Conflicts) at runtime and asked various questions about how to format
   records best for display.
 
   .syncschema files need to have a "UIHelperClass" key at the top level of their
   Schema.plist file specifying which class in the .syncschema bundle to load for
   information about how to display records.
 
   The class specified with the key "UIHelperClass" should implement at least part
   of the "SyncUIHelperInformalProtocol".  Since this is an informal protocol, classes
   can implement as few or as many of the methods described therin as they see fit.
 
   For each of these methods, there are three possible return values.
   An NSAttributedString with length > 0 will be displayed as is
   An NSAttributedString with length == 0 will be displayed as the localized version of <empty>
   A nil return value means that the default implementation should be used 
*/

#import <Foundation/Foundation.h>

@interface NSObject (SyncUIHelperInformalProtocol)

/* This is implemented by clients wishing to override the default display
   for various value types.  (example strings as URLs, colors, bitfields, images, etc.)
   Clients are passed in the record being displayed,
   and are expected to pass back a corresponding string for the given property name.
 
   The base case is for propertyNames to contain 1 item.  For properties that are specified 
   in a schema as dependent properties, each dependent property will be in propertyNames.
   If a ui helper returns a non-nil value when called with multiple property names,
   the returned value will be considered sufficient to represent all the dependent properties.
   Thus, only one value will be dispayed for those properties, next to the localized
   display name of the first property name.
   If a ui helper returns nil when propertyNames contains more than one property,
   the ui helper will be called again with a separate call for each dependent property.
 
   comparisonRecords is an array of records next to which the current record will be shown.
   For the Data Change Alert case, comparisonRecords will have the "new" or "old" record.
   For the Conflict Resolver case, comparisonRecords will have each record involved in the conflict

   defaultAttributes is a dictionary containing attributes that should be applied to the
   returned NSAttributedString.  The UI helper may alter these attributes as it sees fit.
   
   The suggested formatting is System Font 12pt, and the suggested color for modified values
   is (red: 47, green: 20, blue: 232)
 */

- (NSAttributedString *)attributedStringForPropertiesWithNames:(NSArray *)propertyNames inRecord:(NSDictionary *)record comparisonRecords:(NSArray *)comparisonRecords defaultAttributes:(NSDictionary *)defaultAttributes NS_DEPRECATED_MAC(10_4, 10_7);

/* This allows schemas to return a custom identity string
   including for example a picture (using NSTextAttachment) or specially colored text
   this is displayed at the top of the Record cell
 
   comparisonRecords is an array of records next to which the current record will be shown.
   For the Data Change Alert case, comparisonRecords will have the "new" or "old" record.
   For the Conflict Resolver case, comparisonRecords will have each record involved in the conflict
 
   NOTE: it is recommended that identity strings returned from this
   method be two lines long.  The first line of the returned string should contain the attributes
   in firstLineAttributes.  The second line of the returned string should contain the attributes
   in secondLineAttributes.  The UI helper may alter these attributes as it sees fit.
   
   The suggested formatting is System Font 14 pt Bold for the first line, and System Font 12pt
   for any following lines.
 */
- (NSAttributedString *)attributedStringForIdentityPropertiesWithNames:(NSArray *)propertyNames inRecord:(NSDictionary *)record comparisonRecords:(NSArray *)comparisonRecords firstLineAttributes:(NSDictionary *)firstLineAttributes secondLineAttributes:(NSDictionary *)secondLineAttributes NS_DEPRECATED_MAC(10_4, 10_7);


@end


                                                                              SyncServices.h                                                                                      0100644 0001750 0001750 00000001113 12566230177 035032  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- SyncServices.h
 * Copyright (c) 2003, Apple Computer, Inc.  All rights reserved. 
 */

#import <Foundation/Foundation.h>
#import <SyncServices/ISyncCommon.h>
#import <SyncServices/ISyncChange.h>
#import <SyncServices/ISyncClient.h>
#import <SyncServices/ISyncFilter.h>
#import <SyncServices/ISyncManager.h>
#import <SyncServices/ISyncRecordSnapshot.h>
#import <SyncServices/ISyncRecordReference.h>
#import <SyncServices/ISyncSession.h>
#import <SyncServices/ISyncSessionDriver.h>

#import <SyncServices/ISyncCoreData.h>

#import <SyncServices/SyncServicesErrors.h>
                                                                                                                                                                                                                                                                                                                                                                                                                                                     SyncServicesErrors.h                                                                                0100644 0001750 0001750 00000003706 12566230177 036241  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Headers                                                                /*
 * SyncServices -- SyncServicesErrors.h
 * Copyright (c) 2006, Apple Computer, Inc.  All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <SyncServices/ISyncCommon.h>


// Predefined domain for errors from SyncServices APIs.
SYNCSERVICES_EXPORT NSString *const ISyncErrorDomain NS_DEPRECATED_MAC(10_5, 10_7);

enum {
    ISyncSessionClientAlreadySyncingError =        100, // a sync session was requested for a client already participating in a session
    ISyncSessionUserCanceledSessionError =         101, // the user canceled a sync via the data change alert
    ISyncSessionDriverRegistrationError =          200, // an ISyncSessionDriver was unable to register a client
    ISyncSessionDriverPullFailureError =           201, // an ISyncSessionDriver failed an -[ISyncSession prepareToPullChangesForEntityNames:beforeDate:] call
	ISyncSessionDriverFatalError =			       300  // ISyncSessionDriver received a fatal error
} NS_DEPRECATED_MAC(10_4, 10_7);

typedef enum {
	ISyncServerDisabledReasonNone = 1000,        // Returned when isEnabled has not been called or has returned YES.
	ISyncServerDisabledReasonByPreference,      // Returned if syncing has been disabled with a preference
	ISyncServerDisabledReasonSharedNetworkHome,// Returned if another sync server is running against a network home directory.
	ISyncServerDisabledReasonUnresponsive,	 // Returned if isEnabled has timed out messaging to the Sync Server  
	ISyncServerDisabledReasonUnknown,           // Returned if the Sync Server fails to respond because of an unexpected error.
} ISyncServerDisabledReason NS_DEPRECATED_MAC(10_4, 10_7);


SYNCSERVICES_EXPORT NSString * const ISyncInvalidSchemaException NS_DEPRECATED_MAC(10_4, 10_7);    // Raised when a client tries to register an invalid schema or schema extension.
SYNCSERVICES_EXPORT NSString * const ISyncInvalidArgumentsException NS_DEPRECATED_MAC(10_4, 10_7); // Raised when the sync services API is passed bad or inconsistent arguments.

                                                          Modules/                                                                                            0040755 0001750 0001750 00000000000 12612224746 032302  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A                                                                        module.modulemap                                                                                    0100644 0001750 0001750 00000000215 12566230230 035460  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A/Modules                                                                framework module SyncServices [extern_c] {
    umbrella header "SyncServices.h"
    requires !swift
    export *
    module * { export * }
}
                                                                                                                                                                                                                                                                                                                                                                                   SyncServices.tbd                                                                                    0100644 0001750 0001750 00000243104 12571375071 034010  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions/A                                                                        ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/SyncServices.framework/Versions/A/SyncServices
current-version: 724.0
compatibility-version: 48.0
exports:         
  - archs:           [ x86_64 ]
    symbols:         [ '_OBJC_EHTYPE_$_ISDException' ]
    objc-ivars:      [ _IDMapping._globalId, _IDMapping._localId, _ISDAdminDatabase._dataManager, 
                       _ISDAdminDatabase._dataObjectsToConfigureWithDataManager, 
                       _ISDAdminDatabase._getAllClientsStatement, _ISDAdminDatabase._getEarliestGenerationsForEntitiesStatement, 
                       _ISDAdminDatabase._getMostRecentSyncDatesForClientsStatement, 
                       _ISDAdminDatabase._getSyncGenerationStatement, _ISDAdminDatabase._getSyncPlanBeforeDateStatement, 
                       _ISDAdminDatabase._getSyncStateStatement, _ISDAdminDatabase._getTableNamesStatement, 
                       _ISDAdminDatabase._insertClientStatement, _ISDAdminDatabase._purgeClientSyncModesStatement, 
                       _ISDAdminDatabase._purgeSyncDetailStatement, _ISDAdminDatabase._recordSyncModesStatement, 
                       _ISDAdminDatabase._recordSyncPlanStatement, _ISDAdminDatabase._removeClientStatement, 
                       _ISDAdminDatabase._removeSyncStateForClientStatement, 
                       _ISDAdminDatabase._removeSyncStateForEntityStatement, 
                       _ISDAdminDatabase._setSyncGenerationStatement, _ISDAdminDatabase._setSyncStateStatement, 
                       _ISDAdminDatabase._threadWithLock, _ISDAdminDatabase._transactionLock, 
                       _ISDCallHistory._callHistory, _ISDCallHistory._clientIdentifier, 
                       _ISDCallHistory._filename, _ISDCallHistory._saveCallHistoryAggressively, 
                       _ISDChange._changeSourceIndex, _ISDChange._clientId, 
                       _ISDChange._entityName, _ISDChange._fromGeneration, 
                       _ISDChange._identityHash, _ISDChange._modificationDate, 
                       _ISDChange._propertyChanges, _ISDChange._recordId, 
                       _ISDChange._toGeneration, _ISDChange._type, _ISDChangeBuilder._change, 
                       _ISDChangeBuilder._clientId, _ISDChangeBuilder._clientIsTrusted, 
                       _ISDChangeBuilder._clientRecordStore, _ISDChangeBuilder._defaultPropertyNames, 
                       _ISDChangeBuilder._delegate, _ISDChangeBuilder._deletedPropertyNames, 
                       _ISDChangeBuilder._deltas, _ISDChangeBuilder._entity, 
                       _ISDChangeBuilder._fromGeneration, _ISDChangeBuilder._hasNewRecord, 
                       _ISDChangeBuilder._hasOldRecord, _ISDChangeBuilder._isPushingTruth, 
                       _ISDChangeBuilder._missingCodependentPropertyNames, 
                       _ISDChangeBuilder._newRelationshipValuesAreTuples, 
                       _ISDChangeBuilder._newValues, _ISDChangeBuilder._oldUnformattedRelationships, 
                       _ISDChangeBuilder._oldValues, _ISDChangeBuilder._produceDeletesForMissingNewValues, 
                       _ISDChangeBuilder._recordId, _ISDChangeBuilder._relationshipNewReferences, 
                       _ISDChangeBuilder._supportedPropertyNames, _ISDChangeBuilder._takeMissingCodependentValuesFromOldValues, 
                       _ISDChangeBuilder._toGeneration, _ISDChangeEnumerator._clientRecordCache, 
                       _ISDChangeEnumerator._clientRecordCacheIndex, _ISDChangeEnumerator._clientStore, 
                       _ISDChangeEnumerator._recordIdIndex, _ISDChangeEnumerator._recordIds, 
                       _ISDChangeEnumerator._session, _ISDChangeEnumerator._truth, 
                       _ISDChangeEnumerator._truthRecordCache, _ISDChangeEnumerator._truthRecordCacheIndex, 
                       _ISDChangePuller._mapper, _ISDChangePuller._record, 
                       _ISDChangePusher._clientFormatsRelationships, _ISDChangePusher._clientId, 
                       _ISDChangePusher._record, _ISDChangeStore._addChanges, 
                       _ISDChangeStore._addedChangeIndex, _ISDChangeStore._changes, 
                       _ISDChangeStore._deletedAddedRecordIdsIndex, _ISDChangeStore._didSkipRecordsWhenEnumerating, 
                       _ISDChangeStore._dirty, _ISDChangeStore._dirtyCoderDelegate, 
                       _ISDChangeStore._enumeratedRecordIds, _ISDChangeStore._flushCount, 
                       _ISDChangeStore._modifiedChangeIndex, _ISDChangeStore._path, 
                       _ISDChangeStore._recordIdReferences, _ISDClient._clientId, 
                       _ISDClient._clientType, _ISDClient._descriptionFile, 
                       _ISDClient._displayName, _ISDClient._filterData, 
                       _ISDClient._formatterBundle, _ISDClient._formatterBundleClassName, 
                       _ISDClient._hasDynamicSyncAlertHandler, _ISDClient._idNumber, 
                       _ISDClient._imageFile, _ISDClient._isAppProvider, 
                       _ISDClient._localizationBundleRef, _ISDClient._neverFormatsRelationships, 
                       _ISDClient._syncAlertTool, _ISDClient._syncAlertTypes, 
                       _ISDClient._syncStates, _ISDClient._synchronizesAllEntities, 
                       _ISDClient._syncsAfterClients, _ISDClient._trackRecordModificationTimes, 
                       _ISDClient._useLocalIdsForGUIDs, _ISDClientState._changeStore, 
                       _ISDClientState._clientId, _ISDClientState._dataDirectory, 
                       _ISDClientState._dirtyCoderDelegate, _ISDClientState._flushCount, 
                       _ISDClientState._isLocalClientType, _ISDClientState._isTransferClient, 
                       _ISDClientState._recordIdMapper, _ISDClientState._recordStore, 
                       _ISDClientState._resetHandler, _ISDConflict._dataClassName, 
                       _ISDConflict._deletedRecordMap, _ISDConflict._entityName, 
                       _ISDConflict._identityKeys, _ISDConflict._propertyConflicts, 
                       _ISDConflict._propertyDependencies, _ISDConflict._recordId, 
                       _ISDConflictChangeEnumerator._changeQueue, _ISDConflictChangeEnumerator._conflictEnumerator, 
                       _ISDConflictChangeEnumerator._conflictManager, _ISDConflictChangeEnumerator._entityNames, 
                       _ISDConflictChangeEnumerator._generation, _ISDConflictManager._addedChanges, 
                       _ISDConflictManager._conflictWrappers, _ISDConflictManager._conflicts, 
                       _ISDConflictManager._deletedRecordMap, _ISDConflictManager._deltaFileNames, 
                       _ISDConflictManager._directory, _ISDConflictManager._flushCount, 
                       _ISDConflictManager._lastSyncedGeneration, _ISDConflictManager._nextDeltaNumber, 
                       _ISDConflictManager._recordIdDataReferenceMap, _ISDConflictManager._resolvedConflicts, 
                       _ISDConflictManager._validateConflictsOnRead, _ISDConflictManager._validateConflictsOnWrite, 
                       _ISDDataClass._appProviderIdentifier, _ISDDataClass._bundleRef, 
                       _ISDDataClass._category, _ISDDataClass._imagePath, 
                       _ISDDataClass._longName, _ISDDataClass._name, _ISDDataClass._uiHelperClassName, 
                       _ISDDataClass._versionInfo, _ISDDataDatabase._addGlobalEquivalents, 
                       _ISDDataDatabase._addRecordDataReferenceStatement, 
                       _ISDDataDatabase._addRecordStatement, _ISDDataDatabase._addRelationshipTupleStatement, 
                       _ISDDataDatabase._addUnformattedRelationshipTupleStatement, 
                       _ISDDataDatabase._containsRecordStatement, _ISDDataDatabase._deleteGlobalEquivalentsByNativeId, 
                       _ISDDataDatabase._deleteRecordsByRowid, _ISDDataDatabase._deleteStillBornRecords, 
                       _ISDDataDatabase._deleteTuplesByRowid, _ISDDataDatabase._fastSourceEnumerateStatement, 
                       _ISDDataDatabase._fastTargetEnumerateStatement, 
                       _ISDDataDatabase._getAddCountsStatement, _ISDDataDatabase._getAllRecordDataReferencesStatement, 
                       _ISDDataDatabase._getAllRecordIdsThatHaveDataRefsStatement, 
                       _ISDDataDatabase._getDeleteCountsStatement, _ISDDataDatabase._getEntitiesForRecordIdsStatement, 
                       _ISDDataDatabase._getEntitiesInTruthStatement, _ISDDataDatabase._getEquivalentIds, 
                       _ISDDataDatabase._getNativeRecordId, _ISDDataDatabase._getRecordCountsStatement, 
                       _ISDDataDatabase._getRecordDataReferencesForRecordIdAndPropertyStatement, 
                       _ISDDataDatabase._getRecordDataReferencesForRecordIdsStatement, 
                       _ISDDataDatabase._getRecordIdsAddedAfterGenerationStatement, 
                       _ISDDataDatabase._getRecordIdsFromRowidsStatement, 
                       _ISDDataDatabase._getRecordIdsOfRecordsWithStatesAndWithEntityNumbersStatement, 
                       _ISDDataDatabase._getRecordIdsOfRecordsWithoutStatesAndWithEntityNumbersStatement, 
                       _ISDDataDatabase._getRecordIdsStatement, _ISDDataDatabase._getRecordIdsThatExist, 
                       _ISDDataDatabase._getRecordIdsThatExistIncludeDeleted, 
                       _ISDDataDatabase._getRecordIdsThatHaveDataRefsWithEntityNumberStatement, 
                       _ISDDataDatabase._getRecordIdsToBeAppliedWithEntityNumberStatement, 
                       _ISDDataDatabase._getRecordIdsToPurge, _ISDDataDatabase._getRecordIdsUnappliedStatement, 
                       _ISDDataDatabase._getRecordIdsWithEntityNumberStatement, 
                       _ISDDataDatabase._getRecordPropertiesForEntityStatement, 
                       _ISDDataDatabase._getRecordPropertiesStatement, 
                       _ISDDataDatabase._getRecordsAlteredSinceGenerationStatement, 
                       _ISDDataDatabase._getRecordsWithPropertiesStatement, 
                       _ISDDataDatabase._getRecordsWithoutPropertiesStatement, 
                       _ISDDataDatabase._getRelationshipTuplesStatement, 
                       _ISDDataDatabase._getRowidsAddedAfterGenerationStatement, 
                       _ISDDataDatabase._getRowidsForRecordIdsStatement, 
                       _ISDDataDatabase._getToBeAppliedCountWithEntityNumberStatement, 
                       _ISDDataDatabase._getTupleRowsToPurge, _ISDDataDatabase._getUndeletedRecordIdsWithEntityNumberStatement, 
                       _ISDDataDatabase._getUnformattedTuplesStatement, 
                       _ISDDataDatabase._lastGenerationForEntitiesStatement, 
                       _ISDDataDatabase._removeAllTuplesStatement, _ISDDataDatabase._removeAllUnformattedTuplesStatement, 
                       _ISDDataDatabase._removeGlobalEquivalents, _ISDDataDatabase._removePropertiesStatement, 
                       _ISDDataDatabase._removeRecordDataReferencesForRecordIdWithPropertyStatement, 
                       _ISDDataDatabase._removeRecordDataReferencesForRecordIdsStatement, 
                       _ISDDataDatabase._removeRecordsStatement, _ISDDataDatabase._removeSelectedTuplesStatement, 
                       _ISDDataDatabase._removeSelectedUnformattedTuplesStatement, 
                       _ISDDataDatabase._removeTupleReferencesStatement, 
                       _ISDDataDatabase._removeTuplesStatement, _ISDDataDatabase._removeUnformattedTupleReferencesStatement, 
                       _ISDDataDatabase._removeUnformattedTuplesStatement, 
                       _ISDDataDatabase._replaceRecordIdInDataReferencesStatement, 
                       _ISDDataDatabase._replaceRecordIdInRecordStatement, 
                       _ISDDataDatabase._replaceRecordIdInRelationshipFromStatement, 
                       _ISDDataDatabase._replaceRecordIdInRelationshipToStatement, 
                       _ISDDataDatabase._replaceRecordIdInUnformattedFromStatement, 
                       _ISDDataDatabase._replaceRecordIdInUnformattedToStatement, 
                       _ISDDataDatabase._replaceTupleIdInRelationshipStatement, 
                       _ISDDataDatabase._replaceTupleIdInUnformattedStatement, 
                       _ISDDataDatabase._setDeletedStatement, _ISDDataDatabase._setDeletedTupleStatement, 
                       _ISDDataDatabase._setLastChangedGenerationStatement, 
                       _ISDDataDatabase._setRecordIdsHaveDataReferencesStatement, 
                       _ISDDataDatabase._setRecordStateStatement, _ISDDataDatabase._setRecordStateToBeAppliedStatement, 
                       _ISDDataDatabase._setToBeAppliedByEntityStatement, 
                       _ISDDataDatabase._setToBeAppliedStatement, _ISDDataDatabase._updateRecordPropertiesStatement, 
                       _ISDDataDatabase._updateRecordStatement, _ISDDataDirectoryVersion._version, 
                       _ISDDataManager._adminDatabase, _ISDDataManager._adminDatabasePath, 
                       _ISDDataManager._anchor, _ISDDataManager._associatedNameNumberProvider, 
                       _ISDDataManager._clientAdminDataChanged, _ISDDataManager._clientSyncStateChanged, 
                       _ISDDataManager._clients, _ISDDataManager._dataClasses, 
                       _ISDDataManager._dataDirectory, _ISDDataManager._dataVersion, 
                       _ISDDataManager._entities, _ISDDataManager._schemaAdminDataChanged, 
                       _ISDDataManager._schemas, _ISDDataManager._schemasArchivePath, 
                       _ISDDataManager._shouldBumpAnchorOnNextChange, _ISDDataManager._shouldUpdateMetadataOnEnableFlush, 
                       _ISDDataManager._shouldWriteSchemasArchiveToDisk, 
                       _ISDDataManager._syncGeneration, _ISDDataManager._syncingClientListPath, 
                       _ISDDataObject._anchor, _ISDDataObject._comment, 
                       _ISDDataObject._dataManager, _ISDDataObject._topParent, 
                       _ISDDataReference._data, _ISDDataReference._dataWrapper, 
                       _ISDDataWrapper._dataCache, _ISDDataWrapper._extension, 
                       _ISDDataWrapper._faultFailure, _ISDDataWrapper._guid, 
                       _ISDDataWrapper._hash, _ISDDataWrapper._length, 
                       _ISDDataWrapper._moddate, _ISDDataWrapper._previousExtension, 
                       _ISDDataWrapper._propertyName, _ISDDataWrapper._recordId, 
                       _ISDDataWrapper._signature, _ISDDataWrapper._subdir, 
                       _ISDDatabase._dataVersion, _ISDDatabase._db, _ISDDatabase._dirtyCoderDelegate, 
                       _ISDDatabase._globalStringTable, _ISDDatabase._tracingPrefix, 
                       _ISDEntity._attributes, _ISDEntity._bundleRef, _ISDEntity._dataClass, 
                       _ISDEntity._excludeFromAirbagCount, _ISDEntity._hasPropertiesWithLastModifiedResolutionPolicy, 
                       _ISDEntity._idNumber, _ISDEntity._name, _ISDEntity._parentName, 
                       _ISDEntity._propertiesByName, _ISDEntity._propertyDependencies, 
                       _ISDEntity._relationships, _ISDEntity._uiHelperClassName, 
                       _ISDEntity._versionInfo, _ISDEntityComponent._attributes, 
                       _ISDEntityComponent._entity, _ISDEntityComponent._extensionName, 
                       _ISDEntityComponent._relationships, _ISDException.mLogReasonOnly, 
                       _ISDException.mLogStackTraceMode, _ISDFastCDSyncHelper._changeWithIdentifierStatement, 
                       _ISDFastCDSyncHelper._db, _ISDFastCDSyncHelper._deleteAllChangesForEntityStatement, 
                       _ISDFastCDSyncHelper._deleteAllChangesStatement, 
                       _ISDFastCDSyncHelper._isUpdater, _ISDFastCDSyncHelper._lock, 
                       _ISDFastCDSyncHelper._nextChangesForEntityStatement, 
                       _ISDFastCDSyncHelper._nextChangesStatement, _ISDFastCDSyncHelper._objectForKeyStatement, 
                       _ISDFastCDSyncHelper._persistentStore, _ISDFastCDSyncHelper._removeChangeStatement, 
                       _ISDFastCDSyncHelper._removeObjectForKeyStatement, 
                       _ISDFastCDSyncHelper._setObjectForKeyStatement, 
                       _ISDFastCDSyncHelper._storagePath, _ISDFastCDSyncHelper._syncContext, 
                       _ISDFastCDSyncHelper._updateChangeStatement, _ISDFileReference._aliasData, 
                       _ISDFileReference._bundleId, _ISDFileReference._bundleRelativePath, 
                       _ISDFileReference._path, _ISDFileReference._persistentId, 
                       _ISDFileReference._timestamp, _ISDFileReference._windowsBinRelativePath, 
                       _ISDFiltratorThingy._clearDirtyRecordIds, _ISDFiltratorThingy._client, 
                       _ISDFiltratorThingy._clientRecordStore, _ISDFiltratorThingy._currentRecordIdsForFilter, 
                       _ISDFiltratorThingy._entities, _ISDFiltratorThingy._filter, 
                       _ISDFiltratorThingy._filterRemovedRecordIds, _ISDFiltratorThingy._filterReplacedRecordIds, 
                       _ISDFiltratorThingy._filteredOrRejectedIds, _ISDFiltratorThingy._filteredRecordIds, 
                       _ISDFiltratorThingy._isServerClientType, _ISDFiltratorThingy._mapper, 
                       _ISDFiltratorThingy._modifiedRecordIds, _ISDFiltratorThingy._processedRecords, 
                       _ISDFiltratorThingy._recordIdsForFilter, _ISDFiltratorThingy._recordIdsToRejectOutOfHand, 
                       _ISDFiltratorThingy._recordIdsWithReferrersToRefilter, 
                       _ISDFiltratorThingy._referringRelationshipNames, 
                       _ISDFiltratorThingy._rejectedRecordIds, _ISDFiltratorThingy._requiredRelationshipNames, 
                       _ISDFiltratorThingy._skipMarkingAsProcessed, _ISDFiltratorThingy._sourceIdsForFilter, 
                       _ISDFiltratorThingy._truthRecordStore, _ISDFiltratorThingy._unappliedRecordIds, 
                       _ISDGlobalId._bytes, _ISDGlobalId._hash, _ISDIdMapDatabase._addMappingStatement, 
                       _ISDIdMapDatabase._allMappingStatement, _ISDIdMapDatabase._flushCount, 
                       _ISDIdMapDatabase._getMappingForGlobalIdStatement, 
                       _ISDIdMapDatabase._getMappingForLocalIdStatement, 
                       _ISDIdMapDatabase._purgeMappingsForLocalIdsStatement, 
                       _ISDIdMapDatabase._removeLocalIdMappingStatement, 
                       _ISDIdMapDatabase._removeMappingStatement, _ISDIdMapDatabase._removeMappingsForGlobalIdsStatement, 
                       _ISDIdMapDatabase._removeMappingsForLocalIdsStatement, 
                       _ISDIdMapDatabase._updateMappingStatement, _ISDInstrumentedEnumerator._callHistory, 
                       _ISDInstrumentedEnumerator._enumerator, _ISDNameNumberMapping._last, 
                       _ISDNameNumberMapping._mappingName, _ISDNameNumberMapping._nameToNumber, 
                       _ISDNameNumberMapping._numberToName, _ISDNameNumberMapping._providedBy, 
                       _ISDNameNumberMapping._zeroMapping, _ISDNameNumberProvider._basis, 
                       _ISDNameNumberProvider._canCreate, _ISDNameNumberProvider._canSave, 
                       _ISDNameNumberProvider._clientMapping, _ISDNameNumberProvider._entityMapping, 
                       _ISDNameNumberProvider._inRefresh, _ISDNameNumberProvider._irreplaceable, 
                       _ISDNameNumberProvider._isValid, _ISDNameNumberProvider._mapsInitialized, 
                       _ISDNameNumberProvider._useRegardless, _ISDObjectGraphWrapper._data, 
                       _ISDPersistentStoreSyncer._contextsToMonitor, _ISDPersistentStoreSyncer._contextsToReload, 
                       _ISDPersistentStoreSyncer._deletedObjects, _ISDPersistentStoreSyncer._error, 
                       _ISDPersistentStoreSyncer._fastSyncHelpers, _ISDPersistentStoreSyncer._isSyncing, 
                       _ISDPersistentStoreSyncer._objectsToFormat, _ISDPersistentStoreSyncer._persistentStoreCoordinator, 
                       _ISDPersistentStoreSyncer._qualifiedEntityNames, 
                       _ISDPersistentStoreSyncer._relations, _ISDPersistentStoreSyncer._session, 
                       _ISDPersistentStoreSyncer._syncClient, _ISDPersistentStoreSyncer._syncContext, 
                       _ISDPersistentStoreSyncer._syncEntityNames, _ISDPersistentStoreSyncer._syncHandler, 
                       _ISDPersistentStoreSyncer._synchronizedEntities, 
                       _ISDPersistentStoreSyncer._updatedObjects, _ISDProperty._automagicConflictResolverClassName, 
                       _ISDProperty._bundleRef, _ISDProperty._enumValues, 
                       _ISDProperty._flags, _ISDProperty._fullName, _ISDProperty._name, 
                       _ISDProperty._preferredClientTypesForAutomagicResolution, 
                       _ISDProperty._subtype, _ISDProperty._type, _ISDProperty._uiHelperClassName, 
                       _ISDPropertyChange._action, _ISDPropertyChange._propertyValue, 
                       _ISDPropertyConflict._modified, _ISDPropertyConflict._propertyChangesPerClientId, 
                       _ISDPropertyConflict._propertyNames, _ISDPropertyConflict._recordId, 
                       _ISDPropertyConflict._userValues, _ISDPropertyConflict._winningClientId, 
                       _ISDPropertyValue._clientNumber, _ISDPropertyValue._collectionType, 
                       _ISDPropertyValue._deletedValue, _ISDPropertyValue._generation, 
                       _ISDPropertyValue._isDefaultValue, _ISDPropertyValue._name, 
                       _ISDPropertyValue._type, _ISDPropertyValue._unformattedValue, 
                       _ISDPropertyValue._value, _ISDQuickDirtyCoder._bytes, 
                       _ISDQuickDirtyCoder._classVersionTable, _ISDQuickDirtyCoder._data, 
                       _ISDQuickDirtyCoder._delegate, _ISDQuickDirtyCoder._isReading, 
                       _ISDQuickDirtyCoder._path, _ISDQuickDirtyCoder._propertyName, 
                       _ISDQuickDirtyCoder._recordid, _ISDQuickDirtyCoder._stringIndexTable, 
                       _ISDQuickDirtyCoder._strings, _ISDQuickDirtyCoder._userInfo, 
                       _ISDRecord._addedGeneration, _ISDRecord._deleted, 
                       _ISDRecord._entityNumber, _ISDRecord._lastChangedByClientNumber, 
                       _ISDRecord._lastChangedGeneration, _ISDRecord._propertyValues, 
                       _ISDRecord._propertyValuesIncludeDataReferences, 
                       _ISDRecord._recordId, _ISDRecord._relationshipMap, 
                       _ISDRecord._reorderOnlyPropertyNames, _ISDRecord._state, 
                       _ISDRecord._unformattedRelationshipValues, _ISDRecordIdMap._entityNumber, 
                       _ISDRecordIdMap._globalId, _ISDRecordIdMap._localId, 
                       _ISDRecordIdMapDatabase._addMappingStatement, _ISDRecordIdMapDatabase._addUnknownRecordTypeStatement, 
                       _ISDRecordIdMapDatabase._allGlobalIdsStatement, 
                       _ISDRecordIdMapDatabase._allLocalIdsStatement, _ISDRecordIdMapDatabase._allMappingsStatement, 
                       _ISDRecordIdMapDatabase._countMappingsStatement, 
                       _ISDRecordIdMapDatabase._getMappingForGlobalIdStatement, 
                       _ISDRecordIdMapDatabase._getMappingForLocalIdStatement, 
                       _ISDRecordIdMapDatabase._getUnknownRecordIdsStatement, 
                       _ISDRecordIdMapDatabase._getUnknownTypeForRecordIdStatement, 
                       _ISDRecordIdMapDatabase._removeAllUnknownRecordsTypeStatement, 
                       _ISDRecordIdMapDatabase._removeMappingsForEntityNamesStatement, 
                       _ISDRecordIdMapDatabase._removeMappingsForGlobalIdsStatement, 
                       _ISDRecordIdMapDatabase._removeOneMappingForGlobalIdStatement, 
                       _ISDRecordIdMapDatabase._removeUnknownRecordTypeStatement, 
                       _ISDRecordIdMapper._constructedIdMapper, _ISDRecordIdMapper._dirty, 
                       _ISDRecordIdMapper._entityNames, _ISDRecordIdMapper._flushCount, 
                       _ISDRecordIdMapper._globalIdMap, _ISDRecordIdMapper._localIdMap, 
                       _ISDRecordIdMapper._newLocalIdMappings, _ISDRecordIdMapper._path, 
                       _ISDRecordIdMapper._phantomUnresolvedIdMap, _ISDRecordIdMapper._unknownRecordTypes, 
                       _ISDRecordIdMapper._unresolvedLocalIdMap, _ISDRecordIdMapper._useLocalsAsGlobals, 
                       _ISDRecordStore._clientData, _ISDRecordStore._dataDirectory, 
                       _ISDRecordStore._database, _ISDRecordStore._filteredTupleReferences, 
                       _ISDRecordStore._flushCount, _ISDRecordStore._formattedAwayProperties, 
                       _ISDRecordStore._recordIdentifiersToFormattedAwayProperties, 
                       _ISDRecordStore._segmentNameForEntity, _ISDRecordStore._truthDatabaseForSegment, 
                       _ISDRecordStore._truthDatabases, _ISDRelationship._anonymousInverseRelationshipNames, 
                       _ISDRelationship._inverseRelationships, _ISDRelationship._source, 
                       _ISDRelationship._targets, _ISDSchema._bundleRef, 
                       _ISDSchema._conflictResolverClassName, _ISDSchema._dataClasses, 
                       _ISDSchema._descriptionFile, _ISDSchema._entityComponents, 
                       _ISDSchema._name, _ISDSchema._uiHelperClassName, 
                       _ISDSchema._validatorClassName, _ISDSchemaParser._dataClasses, 
                       _ISDSchemaParser._entities, _ISDSchemaParser._existingDataclasses, 
                       _ISDSchemaParser._existingEntities, _ISDSchemaParser._relaxSchemaParsing, 
                       _ISDSchemaParser._schemas, _ISDSchemaParser._undefinedObjects, 
                       _ISDServer._calendarRequestPort, _ISDServer._clientConnections, 
                       _ISDServer._dataManager, _ISDServer._fileLocker, 
                       _ISDServer._fileLockerTimer, _ISDServer._inactivityInterval, 
                       _ISDServer._inactivityTimer, _ISDServer._isPrivateInstance, 
                       _ISDServer._launchDate, _ISDServer._syncManager, 
                       _ISDServer._tickCount, _ISDServer._timerRefreshDate, 
                       _ISDServer._uiHandlerConnection, _ISDSqliteChangeStore._changesMap, 
                       _ISDSqliteChangeStore._db, _ISDSqliteChangeStore._enumeratedChanges, 
                       _ISDSqliteChangeStore._flushCount, _ISDSqliteChangeStore._fromRow, 
                       _ISDSqliteChangeStore._greatestEnumeratedToGeneration, 
                       _ISDSqliteChangeStore._lastRowEnumerated, _ISDSqliteChangeStore._maxToEnumerate, 
                       _ISDSqliteChangeStore._numGenerationsToRetain, _ISDSqliteChangeStore._numberEnumerated, 
                       _ISDSqliteChangeStore._path, _ISDSqliteChangeStore._referencesRowsMap, 
                       _ISDSqliteChangeStoreDatabase._cachedIdReferencesCount, 
                       _ISDSqliteChangeStoreDatabase._clientId, _ISDSqliteChangeStoreDatabase._coder, 
                       _ISDSqliteChangeStoreDatabase._coderWriteData, _ISDSqliteChangeStoreDatabase._deleteChangesWithRowIds, 
                       _ISDSqliteChangeStoreDatabase._deleteReferencedIdsForChangesWithRowIds, 
                       _ISDSqliteChangeStoreDatabase._getChangesForAllEntities, 
                       _ISDSqliteChangeStoreDatabase._getChangesForEntityNames, 
                       _ISDSqliteChangeStoreDatabase._getChangesWithReferencesToRecordId, 
                       _ISDSqliteChangeStoreDatabase._getEarliestGenerationOfRecordsForEntityName, 
                       _ISDSqliteChangeStoreDatabase._getEntityNamesOfAddedRecords, 
                       _ISDSqliteChangeStoreDatabase._getLatestGenerationOfRecordsForEntityName, 
                       _ISDSqliteChangeStoreDatabase._getProcessedChanges, 
                       _ISDSqliteChangeStoreDatabase._getProcessedChangesForEntityNames, 
                       _ISDSqliteChangeStoreDatabase._getRowIdsForChanges, 
                       _ISDSqliteChangeStoreDatabase._getRowIdsForChangesWithEntityNames, 
                       _ISDSqliteChangeStoreDatabase._getRowIdsForEnumeratedChangesLessThanGeneration, 
                       _ISDSqliteChangeStoreDatabase._getUnprocessedDeletedRecordIds, 
                       _ISDSqliteChangeStoreDatabase._getUnprocessedDeletedRecordIdsWithEntityNames, 
                       _ISDSqliteChangeStoreDatabase._insertChangeStatement, 
                       _ISDSqliteChangeStoreDatabase._insertReferencesToChangesStatement, 
                       _ISDSqliteChangeStoreDatabase._markChangesAsEnumerated, 
                       _ISDSqliteChangeStoreDatabase._numberOfChanges, 
                       _ISDSqliteChangeStoreDatabase._numberOfChangesForEntities, 
                       _ISDSqliteChangeStoreDatabase._numberOfDeletes, 
                       _ISDSqliteChangeStoreDatabase._removeAllChangesForEntityNames, 
                       _ISDSqliteChangeStoreDatabase._removeReferencesToChangesStatement, 
                       _ISDSqliteChangeStoreDatabase._updateChangeStatement, 
                       _ISDSqliteChangeStoreDatabase._updateReferencedId, 
                       _ISDSqliteChangeStoreDatabase._updateReferencedIdAndChangeId, 
                       _ISDSqliteRecordIdMapper._mapDatabase, _ISDStructuredDelta._changePuller, 
                       _ISDStructuredDelta._changePusher, _ISDStructuredDelta._clientFormatsRelationships, 
                       _ISDStructuredDelta._clientIsTrusted, _ISDStructuredDelta._clientState, 
                       _ISDStructuredDelta._currentGeneration, _ISDStructuredDelta._entities, 
                       _ISDStructuredDelta._relationshipValidationDelegate, 
                       _ISDStructuredDelta._supportedPropertyNames, _ISDStructuredDelta._syncStates, 
                       _ISDSyncJob._canRunWithRunningSyncPlans, _ISDSyncJob._context, 
                       _ISDSyncJob._isRunning, _ISDSyncJob._selector, _ISDSyncJob._shouldRunBeforePendingSyncPlans, 
                       _ISDSyncJob._target, _ISDSyncManager._dataDirectory, 
                       _ISDSyncManager._dataManager, _ISDSyncManager._deviceParticipantTimeoutInterval, 
                       _ISDSyncManager._isKillable, _ISDSyncManager._jobs, 
                       _ISDSyncManager._lastSyncDate, _ISDSyncManager._otherParticipantTimeoutInterval, 
                       _ISDSyncManager._pendingPlans, _ISDSyncManager._pendingSyncAfterParticipants, 
                       _ISDSyncManager._plans, _ISDSyncManager._runningPlans, 
                       _ISDSyncManager._syncAfterParticipants, _ISDSyncManager._syncAfterParticipantsPlanMap, 
                       _ISDSyncManager._syncCount, _ISDSyncManager._syncPlansAwaitingNegotiation, 
                       _ISDSyncManager._syncServerName, _ISDSyncParticipant._alerted, 
                       _ISDSyncParticipant._callbackTarget, _ISDSyncParticipant._client, 
                       _ISDSyncParticipant._clientId, _ISDSyncParticipant._clientState, 
                       _ISDSyncParticipant._clientSyncStates, _ISDSyncParticipant._entityNames, 
                       _ISDSyncParticipant._entityNamesHavingTruthPulled, 
                       _ISDSyncParticipant._formatterBundle, _ISDSyncParticipant._phase, 
                       _ISDSyncParticipant._pushTruthApprovalTable, _ISDSyncParticipant._responseDate, 
                       _ISDSyncParticipant._synchronizesAllEntities, _ISDSyncParticipant._transientSyncModes, 
                       _ISDSyncParticipant._useLocalIdsForGuids, _ISDSyncPlan._allClients, 
                       _ISDSyncPlan._cancelledClientIdentifiers, _ISDSyncPlan._clientIdTypeMapping, 
                       _ISDSyncPlan._closureOfEntitiesBeingMingled, _ISDSyncPlan._confusedPushers, 
                       _ISDSyncPlan._contestedPushers, _ISDSyncPlan._createDate, 
                       _ISDSyncPlan._dataClassesWithRecordsInTruth, _ISDSyncPlan._dataDirectory, 
                       _ISDSyncPlan._dataManager, _ISDSyncPlan._delegate, 
                       _ISDSyncPlan._endDate, _ISDSyncPlan._entitiesMapping, 
                       _ISDSyncPlan._entitiesToMarkAsRefreshedAfterPushPhase, 
                       _ISDSyncPlan._entityNameToEntityMapping, _ISDSyncPlan._isCancelled, 
                       _ISDSyncPlan._isOneShotPlan, _ISDSyncPlan._isPullOnly, 
                       _ISDSyncPlan._isSyncAfterPlan, _ISDSyncPlan._mingler, 
                       _ISDSyncPlan._minglerException, _ISDSyncPlan._minglerProcess, 
                       _ISDSyncPlan._minglerTask, _ISDSyncPlan._negotiatedClientModes, 
                       _ISDSyncPlan._participantRequiresMingle, _ISDSyncPlan._participants, 
                       _ISDSyncPlan._phase, _ISDSyncPlan._pushersHaveBeenNegotiated, 
                       _ISDSyncPlan._removedClientIdentifiers, _ISDSyncPlan._skipSyncAfterClients, 
                       _ISDSyncPlan._startDate, _ISDSyncPlan._syncGeneration, 
                       _ISDSyncPlan._syncingClientIdentifiers, _ISDSyncPlan._syncingEntityNamesSet, 
                       _ISDSyncPlan._toBeMingled, _ISDSyncPlan._unapprovedUncontestedPushers, 
                       _ISDSyncPlan._uncontestedPushers, _ISDSyncPlan._unpushedResetEntityNames, 
                       _ISDSyncPlan._uuid, _ISDSyncPlan._waitingToNegotiate, 
                       _ISDSyncPlan._watchdog, _ISDSyncPlan._winningPushers, 
                       _ISDSyncState._clientCanPullOnly, _ISDSyncState._clientCanPushOnly, 
                       _ISDSyncState._clientWantsToPullTruth, _ISDSyncState._enabled, 
                       _ISDSyncState._entityName, _ISDSyncState._lastSyncDate, 
                       _ISDSyncState._lastSyncGeneration, _ISDSyncState._lastSyncStatus, 
                       _ISDSyncState._propertyNames, _ISDSyncState._requestedMode, 
                       _ISDSyncState._shouldRefilter, _ISDSyncState._syncMode, 
                       _ISyncAlwaysAcceptFilter._entityNames, _ISyncConcreteChange._changes, 
                       _ISyncConcreteChange._clientNumber, _ISyncConcreteChange._minglerChange, 
                       _ISyncConcreteChange._record, _ISyncConcreteChange._recordId, 
                       _ISyncConcreteChange._type, _ISyncConcreteClient._client, 
                       _ISyncConcreteClient._closureComputationIsDisabled, 
                       _ISyncConcreteClient._isInvalid, _ISyncConcreteClient._syncManager, 
                       _ISyncConcreteClient._syncSession, _ISyncConcreteManager._allSchemaDataWasFetched, 
                       _ISyncConcreteManager._clientAnchor, _ISyncConcreteManager._clientPlanIdentifiers, 
                       _ISyncConcreteManager._clients, _ISyncConcreteManager._dataClasses, 
                       _ISyncConcreteManager._dataDirectoryPath, _ISyncConcreteManager._dataReferencesDirectory, 
                       _ISyncConcreteManager._enabled, _ISyncConcreteManager._entities, 
                       _ISyncConcreteManager._initialPlanIdentifier, _ISyncConcreteManager._lastAvailableServerPID, 
                       _ISyncConcreteManager._logDirectoryPath, _ISyncConcreteManager._nameNumberProvider, 
                       _ISyncConcreteManager._needToFetchAllClients, _ISyncConcreteManager._notifyClientSyncStateToken, 
                       _ISyncConcreteManager._notifyClientToken, _ISyncConcreteManager._notifyPlansToken, 
                       _ISyncConcreteManager._notifySchemaCacheInvalidToken, 
                       _ISyncConcreteManager._notifySchemaToken, _ISyncConcreteManager._removeClientFromSyncPlanIfClientDoesntBeginSession, 
                       _ISyncConcreteManager._runLoopModes, _ISyncConcreteManager._schemaAnchor, 
                       _ISyncConcreteManager._server, _ISyncConcreteManager._serverPID, 
                       _ISyncConcreteManager._syncAlertHandlers, _ISyncConcreteManager._syncPlans, 
                       _ISyncConcreteManager._task, _ISyncConcreteManager._unavailableCheckDate, 
                       _ISyncConcreteManager._unavailableReason, _ISyncConcreteRecordGraphNode._addedChildNodes, 
                       _ISyncConcreteRecordGraphNode._cachedRecord, _ISyncConcreteRecordGraphNode._changeType, 
                       _ISyncConcreteRecordGraphNode._changedKeys, _ISyncConcreteRecordGraphNode._changedRelationshipNames, 
                       _ISyncConcreteRecordGraphNode._deletedChildNodes, 
                       _ISyncConcreteRecordGraphNode._displayKeys, _ISyncConcreteRecordGraphNode._identityKeys, 
                       _ISyncConcreteRecordGraphNode._modifiedChildNodes, 
                       _ISyncConcreteRecordGraphNode._parentNode, _ISyncConcreteRecordGraphNode._recordIdentifier, 
                       _ISyncConcreteRecordGraphNode._recordView, _ISyncConcreteRecordGraphNode._relationshipNames, 
                       _ISyncConcreteRecordGraphNode._topLevelParentNode, 
                       _ISyncConcreteRecordReference._attributes, _ISyncConcreteRecordReference._entityNumber, 
                       _ISyncConcreteRecordReference._globalRecordIdentifier, 
                       _ISyncConcreteRecordSnapshot._entityNames, _ISyncConcreteRecordSnapshot._mapper, 
                       _ISyncConcreteRecordSnapshot._session, _ISyncConcreteRecordSnapshot._truth, 
                       _ISyncConcreteRecordView._cachedRecords, _ISyncConcreteRecordView._clientStoreIdToTruthIdMap, 
                       _ISyncConcreteRecordView._conflictManager, _ISyncConcreteRecordView._recordStore, 
                       _ISyncConcreteRecordView._snapshot, _ISyncConcreteRecordView._truthIdToClientStoreIdMap, 
                       _ISyncConcreteSession._acceptedClientRecords, _ISyncConcreteSession._acceptedFormattedRecordsWithDataReferences, 
                       _ISyncConcreteSession._acceptedUnknowns, _ISyncConcreteSession._accumulatedPulledAdds, 
                       _ISyncConcreteSession._accumulatedPulledDeletes, 
                       _ISyncConcreteSession._accumulatedPulledModifies, 
                       _ISyncConcreteSession._accumulatedPushedAdds, _ISyncConcreteSession._accumulatedPushedDeletes, 
                       _ISyncConcreteSession._accumulatedPushedModifies, 
                       _ISyncConcreteSession._addCount, _ISyncConcreteSession._addedRecordIdentifiers, 
                       _ISyncConcreteSession._anchorPhase, _ISyncConcreteSession._anchorRefreshSyncEntities, 
                       _ISyncConcreteSession._anchorSlowSyncEntities, _ISyncConcreteSession._applyPushedChanges, 
                       _ISyncConcreteSession._callbackSelector, _ISyncConcreteSession._callbackSessionArgument, 
                       _ISyncConcreteSession._callbackTarget, _ISyncConcreteSession._cancelReason, 
                       _ISyncConcreteSession._cancelUserInfo, _ISyncConcreteSession._changeStoreHasChanges, 
                       _ISyncConcreteSession._client, _ISyncConcreteSession._clientId, 
                       _ISyncConcreteSession._clientRecordCache, _ISyncConcreteSession._clientState, 
                       _ISyncConcreteSession._currentGeneration, _ISyncConcreteSession._dataReferencesToSave, 
                       _ISyncConcreteSession._deleteCount, _ISyncConcreteSession._deletedGlobalIds, 
                       _ISyncConcreteSession._deletedRecordIdentifiers, 
                       _ISyncConcreteSession._entities, _ISyncConcreteSession._entityNames, 
                       _ISyncConcreteSession._ignoreDecodedDataWrapper, 
                       _ISyncConcreteSession._knownRecordEntityNumbers, 
                       _ISyncConcreteSession._lastServerPingDate, _ISyncConcreteSession._lostRecordIds, 
                       _ISyncConcreteSession._lostRecordIdsForReplacement, 
                       _ISyncConcreteSession._modifiedRecordIdentifiers, 
                       _ISyncConcreteSession._modifiesDuringPushing, _ISyncConcreteSession._modifyCount, 
                       _ISyncConcreteSession._newPhase, _ISyncConcreteSession._pendingCancel, 
                       _ISyncConcreteSession._pendingNextAnchors, _ISyncConcreteSession._phase, 
                       _ISyncConcreteSession._planId, _ISyncConcreteSession._pushCount, 
                       _ISyncConcreteSession._pushedAddedRecordIds, _ISyncConcreteSession._pushedCacheSize, 
                       _ISyncConcreteSession._pushedChangesCache, _ISyncConcreteSession._pushedChangesObserver, 
                       _ISyncConcreteSession._pushedDeletesCache, _ISyncConcreteSession._pushedRecordsCache, 
                       _ISyncConcreteSession._rebuildIndicesAfterPushing, 
                       _ISyncConcreteSession._recordBeingPushed, _ISyncConcreteSession._recordIdsNotToPropagate, 
                       _ISyncConcreteSession._recordIdsToDeleteAfterPushing, 
                       _ISyncConcreteSession._recordIdsWithDataReferencesToDelete, 
                       _ISyncConcreteSession._refreshSyncingEntityNames, 
                       _ISyncConcreteSession._rejectedClientRecords, _ISyncConcreteSession._rejectedUnknowns, 
                       _ISyncConcreteSession._relationshipInfoMap, _ISyncConcreteSession._running, 
                       _ISyncConcreteSession._sessionResponse, _ISyncConcreteSession._shouldInvokeCallback, 
                       _ISyncConcreteSession._slowSyncingEntityNames, _ISyncConcreteSession._snapshot, 
                       _ISyncConcreteSession._structuredDelta, _ISyncConcreteSession._syncStates, 
                       _ISyncConcreteSession._truth, _ISyncConcreteSession._truthPullers, 
                       _ISyncConcreteSession._unacceptedClientRecords, 
                       _ISyncConcreteSession._unchangedRecordIds, _ISyncConcreteSession._vacuumClientStateAfterSync, 
                       _ISyncConcreteSession._waitingRunLoop, _ISyncConcreteSession.enterMinglingTime, 
                       _ISyncConcreteSession.enterPullingTime, _ISyncConcreteSession.enterPushingTime, 
                       _ISyncConcreteSession.enterSessionCreateTime, _ISyncConcreteSessionDriver._client, 
                       _ISyncConcreteSessionDriver._dataSource, _ISyncConcreteSessionDriver._dataSourceSupportedMethodsHash, 
                       _ISyncConcreteSessionDriver._delegate, _ISyncConcreteSessionDriver._delegateSupportedMethodsHash, 
                       _ISyncConcreteSessionDriver._failure, _ISyncConcreteSessionDriver._filteredEntityNames, 
                       _ISyncConcreteSessionDriver._finishCalled, _ISyncConcreteSessionDriver._handlesSyncAlerts, 
                       _ISyncConcreteSessionDriver._inCallback, _ISyncConcreteSessionDriver._lastError, 
                       _ISyncConcreteSessionDriver._session, _ISyncConjunctionFilter._filters, 
                       _ISyncConjunctionFilter._ignoreLocals, _ISyncConjunctionFilter._isAndConjunction, 
                       _ISyncConjunctionFilter._shouldApplyUnsupportedRecords, 
                       _ISyncConjunctionFilter._supportedEntityNames, _ISyncFileLocker._delegate, 
                       _ISyncFileLocker._hostname, _ISyncFileLocker._hostuuid, 
                       _ISyncFileLocker._lockResult, _ISyncFileLocker._path, 
                       _ISyncFileLocker._secondsToTimeout, _ISyncInstrumentedSession._callHistory, 
                       _ISyncPlan._createDate, _ISyncPlan._endDate, _ISyncPlan._participantInfos, 
                       _ISyncPlan._planId, _ISyncPlan._startDate, _ISyncPlan._syncManager, 
                       _ISyncPlan._syncPhase, _ISyncPlan._syncStatus, _ISyncRecordViewWithConflicts._clientId, 
                       _ISyncRecordWithConflictGraphNode._freezeDriedRecord, 
                       _ISyncRecordWithConflictGraphNode._isdConflict, 
                       _ISyncSimplyIgnoreLocalsFilter._entityNames, _ISyncTCCAccessOperation._accessGranted, 
                       _ISyncTCCAccessOperation._isExecuting, _ISyncTCCAccessOperation._isFinished, 
                       _RelationshipInformation._entityName, _RelationshipInformation._legalTypes, 
                       _RelationshipInformation._modsToCheckPerRecord, 
                       _RelationshipInformation._relationship, _RelationshipInformation._session, 
                       _RelationshipInformation._typeMap ]
  - archs:           [ i386, x86_64 ]
    symbols:         [ _ISDArrayAsGlobalIds, _ISDAsGlobalId, _ISDAvailabilityChangedNotification, 
                       _ISDBadNewsException, _ISDCleanupExtraLogFiles, 
                       _ISDCleanupLogFiles, _ISDDefaultDoublePrecision, 
                       _ISDEnableAllFacilities, _ISDEnableFacility, _ISDGetHostUUIDString, 
                       _ISDGlobalIdException, _ISDInitializeLogging, _ISDIsAppleInternalUser, 
                       _ISDMessageTrace, _ISDMinglerRunLoopMode, _ISDPropertyValueShouldNotEncodeTuplesKey, 
                       _ISDRemoveOrMoveAside, _ISDRollLogsInDirectory, 
                       _ISDSQLiteCannotOpenDatabaseException, _ISDSQLiteNotSQLiteDatabaseException, 
                       _ISDSQLiteObjectBindingException, _ISDSQLiteStatementExecutionException, 
                       _ISDSQLiteStatementPreparationException, _ISDSQLiteTimeoutReachedException, 
                       _ISDServerIsRunningPort, _ISDSetLogFileDirectory, 
                       _ISDStringFromSyncMode, _ISDSyncDatabaseIsClosedException, 
                       _ISDSyncingWithOtherClients, _ISyncAbstractClassException, 
                       _ISyncAddedConflictsKey, _ISyncAirbagAddedRecordIdsKey, 
                       _ISyncAirbagChangesKey, _ISyncAirbagClientIdKey, 
                       _ISyncAirbagDeletedRecordIdsKey, _ISyncAirbagDeletedSubEntityIds, 
                       _ISyncAirbagIdentityMatchedRecordIdMap, _ISyncAirbagModifiedRecordIdsKey, 
                       _ISyncAirbagSubEntityToClientParentKey, _ISyncAirbagSubEntityToEntityName, 
                       _ISyncAirbagSubEntityToTruthParentKey, _ISyncAttribute_Bookmarks_Bookmark_Name, 
                       _ISyncAttribute_Bookmarks_Bookmark_Position, _ISyncAttribute_Bookmarks_Bookmark_Url, 
                       _ISyncAttribute_Bookmarks_Folder_Name, _ISyncAttribute_Bookmarks_Folder_Position, 
                       _ISyncAttribute_Calendars_Attendee_CommonName, _ISyncAttribute_Calendars_Attendee_Delegatedfrom, 
                       _ISyncAttribute_Calendars_Attendee_Delegatedto, 
                       _ISyncAttribute_Calendars_Attendee_DirectoryEntry, 
                       _ISyncAttribute_Calendars_Attendee_Email, _ISyncAttribute_Calendars_Attendee_Role, 
                       _ISyncAttribute_Calendars_Attendee_Rsvp, _ISyncAttribute_Calendars_Attendee_Status, 
                       _ISyncAttribute_Calendars_Attendee_UserType, _ISyncAttribute_Calendars_AudioAlarm_Description, 
                       _ISyncAttribute_Calendars_AudioAlarm_RepeatCount, 
                       _ISyncAttribute_Calendars_AudioAlarm_RepeatInterval, 
                       _ISyncAttribute_Calendars_AudioAlarm_Summary, _ISyncAttribute_Calendars_AudioAlarm_Triggerdate, 
                       _ISyncAttribute_Calendars_AudioAlarm_Triggerduration, 
                       _ISyncAttribute_Calendars_CalDAVAccount_DisplayName, 
                       _ISyncAttribute_Calendars_CalDAVAccount_FullName, 
                       _ISyncAttribute_Calendars_CalDAVAccount_IsAutoDiscovery, 
                       _ISyncAttribute_Calendars_CalDAVAccount_Login, _ISyncAttribute_Calendars_CalDAVAccount_Order, 
                       _ISyncAttribute_Calendars_CalDAVAccount_PrincipalURL, 
                       _ISyncAttribute_Calendars_CalDAVAccount_RefreshInterval, 
                       _ISyncAttribute_Calendars_CalDAVAccount_UseKerberos, 
                       _ISyncAttribute_Calendars_CalendarOrder_Identity, 
                       _ISyncAttribute_Calendars_Calendar_Color, _ISyncAttribute_Calendars_Calendar_Notes, 
                       _ISyncAttribute_Calendars_Calendar_ReadOnly, _ISyncAttribute_Calendars_Calendar_Title, 
                       _ISyncAttribute_Calendars_Calendar_Url, _ISyncAttribute_Calendars_DisplayAlarm_Description, 
                       _ISyncAttribute_Calendars_DisplayAlarm_RepeatCount, 
                       _ISyncAttribute_Calendars_DisplayAlarm_RepeatInterval, 
                       _ISyncAttribute_Calendars_DisplayAlarm_Triggerdate, 
                       _ISyncAttribute_Calendars_DisplayAlarm_Triggerduration, 
                       _ISyncAttribute_Calendars_Event_AllDay, _ISyncAttribute_Calendars_Event_Classification, 
                       _ISyncAttribute_Calendars_Event_Description, _ISyncAttribute_Calendars_Event_EndDate, 
                       _ISyncAttribute_Calendars_Event_ExceptionDates, 
                       _ISyncAttribute_Calendars_Event_InvitationId, _ISyncAttribute_Calendars_Event_InvitationSequence, 
                       _ISyncAttribute_Calendars_Event_InvitationTimestamp, 
                       _ISyncAttribute_Calendars_Event_Location, _ISyncAttribute_Calendars_Event_OriginalDate, 
                       _ISyncAttribute_Calendars_Event_Priority, _ISyncAttribute_Calendars_Event_StartDate, 
                       _ISyncAttribute_Calendars_Event_Status, _ISyncAttribute_Calendars_Event_Summary, 
                       _ISyncAttribute_Calendars_Event_Url, _ISyncAttribute_Calendars_MailAlarm_Description, 
                       _ISyncAttribute_Calendars_MailAlarm_Recipients, 
                       _ISyncAttribute_Calendars_MailAlarm_RepeatCount, 
                       _ISyncAttribute_Calendars_MailAlarm_RepeatInterval, 
                       _ISyncAttribute_Calendars_MailAlarm_Summary, _ISyncAttribute_Calendars_MailAlarm_Triggerdate, 
                       _ISyncAttribute_Calendars_MailAlarm_Triggerduration, 
                       _ISyncAttribute_Calendars_Organizer_CommonName, 
                       _ISyncAttribute_Calendars_Organizer_DirectoryEntry, 
                       _ISyncAttribute_Calendars_Organizer_Email, _ISyncAttribute_Calendars_Recurrence_Bydaydays, 
                       _ISyncAttribute_Calendars_Recurrence_Bydayfreq, 
                       _ISyncAttribute_Calendars_Recurrence_Bymonth, _ISyncAttribute_Calendars_Recurrence_Bymonthday, 
                       _ISyncAttribute_Calendars_Recurrence_Bysetpos, _ISyncAttribute_Calendars_Recurrence_Byweeknumber, 
                       _ISyncAttribute_Calendars_Recurrence_Byyearday, 
                       _ISyncAttribute_Calendars_Recurrence_Count, _ISyncAttribute_Calendars_Recurrence_Frequency, 
                       _ISyncAttribute_Calendars_Recurrence_Interval, _ISyncAttribute_Calendars_Recurrence_Until, 
                       _ISyncAttribute_Calendars_Recurrence_Weekstartday, 
                       _ISyncAttribute_Calendars_Task_Classification, _ISyncAttribute_Calendars_Task_CompletionDate, 
                       _ISyncAttribute_Calendars_Task_Description, _ISyncAttribute_Calendars_Task_DueDate, 
                       _ISyncAttribute_Calendars_Task_DueDateIsDateOnly, 
                       _ISyncAttribute_Calendars_Task_ExceptionDates, _ISyncAttribute_Calendars_Task_OriginalDate, 
                       _ISyncAttribute_Calendars_Task_Priority, _ISyncAttribute_Calendars_Task_StartDate, 
                       _ISyncAttribute_Calendars_Task_Status, _ISyncAttribute_Calendars_Task_Summary, 
                       _ISyncAttribute_Calendars_Task_Url, _ISyncAttribute_Com_Apple_Notes_Attachment_AttachmentID, 
                       _ISyncAttribute_Com_Apple_Notes_Attachment_Content, 
                       _ISyncAttribute_Com_Apple_Notes_Attachment_ContentType, 
                       _ISyncAttribute_Com_Apple_Notes_Attachment_Name, 
                       _ISyncAttribute_Com_Apple_Notes_Keyword_Name, _ISyncAttribute_Com_Apple_Notes_Note_Author, 
                       _ISyncAttribute_Com_Apple_Notes_Note_Content, _ISyncAttribute_Com_Apple_Notes_Note_ContentType, 
                       _ISyncAttribute_Com_Apple_Notes_Note_DateCreated, 
                       _ISyncAttribute_Com_Apple_Notes_Note_DateModified, 
                       _ISyncAttribute_Com_Apple_Notes_Note_Subject, _ISyncAttribute_Contacts_CalendarURI_Label, 
                       _ISyncAttribute_Contacts_CalendarURI_Type, _ISyncAttribute_Contacts_CalendarURI_Value, 
                       _ISyncAttribute_Contacts_Contact_Birthday, _ISyncAttribute_Contacts_Contact_Birthday_Calendar_Identifier, 
                       _ISyncAttribute_Contacts_Contact_CompanyName, _ISyncAttribute_Contacts_Contact_CompanyNameYomi, 
                       _ISyncAttribute_Contacts_Contact_Department, _ISyncAttribute_Contacts_Contact_DisplayAsCompany, 
                       _ISyncAttribute_Contacts_Contact_DisplayOrder, _ISyncAttribute_Contacts_Contact_DisplayType, 
                       _ISyncAttribute_Contacts_Contact_FirstName, _ISyncAttribute_Contacts_Contact_FirstNameYomi, 
                       _ISyncAttribute_Contacts_Contact_Hobby, _ISyncAttribute_Contacts_Contact_Image, 
                       _ISyncAttribute_Contacts_Contact_JobTitle, _ISyncAttribute_Contacts_Contact_LastName, 
                       _ISyncAttribute_Contacts_Contact_LastNameYomi, _ISyncAttribute_Contacts_Contact_MaidenName, 
                       _ISyncAttribute_Contacts_Contact_MiddleName, _ISyncAttribute_Contacts_Contact_MiddleNameYomi, 
                       _ISyncAttribute_Contacts_Contact_Nickname, _ISyncAttribute_Contacts_Contact_Notes, 
                       _ISyncAttribute_Contacts_Contact_OriginalImage, 
                       _ISyncAttribute_Contacts_Contact_ShortName, _ISyncAttribute_Contacts_Contact_Suffix, 
                       _ISyncAttribute_Contacts_Contact_TickerSymbol, _ISyncAttribute_Contacts_Contact_Title, 
                       _ISyncAttribute_Contacts_CustomField_Label, _ISyncAttribute_Contacts_CustomField_Value, 
                       _ISyncAttribute_Contacts_Date_Calendar_Identifier, 
                       _ISyncAttribute_Contacts_Date_Label, _ISyncAttribute_Contacts_Date_Type, 
                       _ISyncAttribute_Contacts_Date_Value, _ISyncAttribute_Contacts_EmailAddress_Label, 
                       _ISyncAttribute_Contacts_EmailAddress_Type, _ISyncAttribute_Contacts_EmailAddress_Value, 
                       _ISyncAttribute_Contacts_Group_Name, _ISyncAttribute_Contacts_Group_Qualifier, 
                       _ISyncAttribute_Contacts_IM_Extended_Service_Type, 
                       _ISyncAttribute_Contacts_IM_Label, _ISyncAttribute_Contacts_IM_Service, 
                       _ISyncAttribute_Contacts_IM_Type, _ISyncAttribute_Contacts_IM_User, 
                       _ISyncAttribute_Contacts_ImageTransformationInfo_Height, 
                       _ISyncAttribute_Contacts_ImageTransformationInfo_OriginX, 
                       _ISyncAttribute_Contacts_ImageTransformationInfo_OriginY, 
                       _ISyncAttribute_Contacts_ImageTransformationInfo_Type, 
                       _ISyncAttribute_Contacts_ImageTransformationInfo_Width, 
                       _ISyncAttribute_Contacts_PhoneNumber_Label, _ISyncAttribute_Contacts_PhoneNumber_Type, 
                       _ISyncAttribute_Contacts_PhoneNumber_Value, _ISyncAttribute_Contacts_RelatedName_Label, 
                       _ISyncAttribute_Contacts_RelatedName_Type, _ISyncAttribute_Contacts_RelatedName_Value, 
                       _ISyncAttribute_Contacts_StreetAddress_City, _ISyncAttribute_Contacts_StreetAddress_Country, 
                       _ISyncAttribute_Contacts_StreetAddress_CountryCode, 
                       _ISyncAttribute_Contacts_StreetAddress_Label, _ISyncAttribute_Contacts_StreetAddress_PostalCode, 
                       _ISyncAttribute_Contacts_StreetAddress_State, _ISyncAttribute_Contacts_StreetAddress_Street, 
                       _ISyncAttribute_Contacts_StreetAddress_Type, _ISyncAttribute_Contacts_URL_Label, 
                       _ISyncAttribute_Contacts_URL_Type, _ISyncAttribute_Contacts_URL_Value, 
                       _ISyncAttribute_Contacts_Value, _ISyncAutomaticConflictResolutionPolicyKey, 
                       _ISyncAvailabilityChangedNotification, _ISyncChangePropertyActionKey, 
                       _ISyncChangePropertyClear, _ISyncChangePropertyNameKey, 
                       _ISyncChangePropertySet, _ISyncChangePropertyValueIsDefaultKey, 
                       _ISyncChangePropertyValueKey, _ISyncChangedConflictsKey, 
                       _ISyncClientAlreadySyncingException, _ISyncClientClientInfoKey, 
                       _ISyncClientDataCorruptedException, _ISyncClientDisplayNameKey, 
                       _ISyncClientDisplayNameVistaOrLaterKey, _ISyncClientEntitiesKey, 
                       _ISyncClientFormatsRelationships, _ISyncClientFormatterBundleClassKey, 
                       _ISyncClientFormatterBundlePathKey, _ISyncClientImageBundleIdKey, 
                       _ISyncClientImageBundleRelativePathKey, _ISyncClientImagePathKey, 
                       _ISyncClientLocalizationBundlePathKey, _ISyncClientNeverFormatsRelationships, 
                       _ISyncClientPullOnlyEntitiesKey, _ISyncClientPushOnlyEntitiesKey, 
                       _ISyncClientSyncAlertToolBundleIdKey, _ISyncClientSyncAlertToolBundleRelativePathKey, 
                       _ISyncClientSyncAlertToolPathKey, _ISyncClientSyncAlertTypesKey, 
                       _ISyncClientSyncAllEntitiesKey, _ISyncClientSyncChangesOnlyKey, 
                       _ISyncClientSyncsAfterKey, _ISyncClientSyncsWithKey, 
                       _ISyncClientTypeApplication, _ISyncClientTypeDevice, 
                       _ISyncClientTypeKey, _ISyncClientTypePeer, _ISyncClientTypeServer, 
                       _ISyncConflictDeletedPropertyNamesKey, _ISyncConflictPropertiesKey, 
                       _ISyncConflictsChangedNotification, _ISyncCoreDataEntityDataClassKey, 
                       _ISyncCoreDataEntityParentKey, _ISyncCoreDataEntitySyncNameKey, 
                       _ISyncCoreDataExcludeFromDataChangeAlertKey, _ISyncCoreDataPropertyIdentityPropertiesKey, 
                       _ISyncCoreDataSyncableKey, _ISyncDataClassCategoryKey, 
                       _ISyncDataClassImageKey, _ISyncDataClassImagePathKey, 
                       _ISyncDataClassLongNameKey, _ISyncDataClassNameKey, 
                       _ISyncDataClass_Bookmarks, _ISyncDataClass_Calendars, 
                       _ISyncDataClass_Com_Apple_Notes, _ISyncDataClass_Contacts, 
                       _ISyncDataDirectoryCorruptedException, _ISyncDataReferenceException, 
                       _ISyncDataTypeArray, _ISyncDataTypeBoolean, _ISyncDataTypeCalendarDate, 
                       _ISyncDataTypeColor, _ISyncDataTypeData, _ISyncDataTypeDate, 
                       _ISyncDataTypeDictionary, _ISyncDataTypeEnum, _ISyncDataTypeNumber, 
                       _ISyncDataTypeSet, _ISyncDataTypeString, _ISyncDataTypeURL, 
                       _ISyncDataWrapperErrorDomain, _ISyncDeletedConflictsKey, 
                       _ISyncEntityAttributeEnumValuesKey, _ISyncEntityAttributeNameKey, 
                       _ISyncEntityAttributeRequiredKey, _ISyncEntityAttributeSubtypeKey, 
                       _ISyncEntityAttributeTypeKey, _ISyncEntityAttributesKey, 
                       _ISyncEntityCompoundIdentityPropertiesKey, _ISyncEntityDataClassNameKey, 
                       _ISyncEntityExtensionNameKey, _ISyncEntityIdentityPropertiesKey, 
                       _ISyncEntityNameKey, _ISyncEntityParentKey, _ISyncEntityPropertyDependenciesKey, 
                       _ISyncEntityPropertyIdentityKey, _ISyncEntityPropertyRequiredKey, 
                       _ISyncEntityRelationshipDeleteRuleCascade, _ISyncEntityRelationshipDeleteRuleKey, 
                       _ISyncEntityRelationshipDeleteRuleNullify, _ISyncEntityRelationshipInverseRelationshipEntityNameKey, 
                       _ISyncEntityRelationshipInverseRelationshipRelationshipNameKey, 
                       _ISyncEntityRelationshipInverseRelationshipsKey, 
                       _ISyncEntityRelationshipMatchableKey, _ISyncEntityRelationshipNameKey, 
                       _ISyncEntityRelationshipOrderingKey, _ISyncEntityRelationshipOrderingNone, 
                       _ISyncEntityRelationshipOrderingStrong, _ISyncEntityRelationshipOrderingWeak, 
                       _ISyncEntityRelationshipOrdinalityKey, _ISyncEntityRelationshipOrdinalityMany, 
                       _ISyncEntityRelationshipOrdinalityOne, _ISyncEntityRelationshipRequiredKey, 
                       _ISyncEntityRelationshipTargetKey, _ISyncEntityRelationshipsKey, 
                       _ISyncEntity_Bookmarks_Bookmark, _ISyncEntity_Bookmarks_Folder, 
                       _ISyncEntity_Calendars_Attendee, _ISyncEntity_Calendars_AudioAlarm, 
                       _ISyncEntity_Calendars_CalDAVAccount, _ISyncEntity_Calendars_Calendar, 
                       _ISyncEntity_Calendars_CalendarOrder, _ISyncEntity_Calendars_DisplayAlarm, 
                       _ISyncEntity_Calendars_Event, _ISyncEntity_Calendars_MailAlarm, 
                       _ISyncEntity_Calendars_Organizer, _ISyncEntity_Calendars_Recurrence, 
                       _ISyncEntity_Calendars_Task, _ISyncEntity_Com_Apple_Notes_Attachment, 
                       _ISyncEntity_Com_Apple_Notes_Keyword, _ISyncEntity_Com_Apple_Notes_Note, 
                       _ISyncEntity_Contacts_CalendarURI, _ISyncEntity_Contacts_Contact, 
                       _ISyncEntity_Contacts_CustomField, _ISyncEntity_Contacts_Date, 
                       _ISyncEntity_Contacts_EmailAddress, _ISyncEntity_Contacts_Group, 
                       _ISyncEntity_Contacts_IM, _ISyncEntity_Contacts_ImageTransformationInfo, 
                       _ISyncEntity_Contacts_PhoneNumber, _ISyncEntity_Contacts_RelatedName, 
                       _ISyncEntity_Contacts_StreetAddress, _ISyncEntity_Contacts_URL, 
                       _ISyncEnumValue_Contacts_Date_Type_Anniversary, 
                       _ISyncEnumValue_Contacts_Date_Type_Other, _ISyncEnumValue_Contacts_EmailAddress_Type_Home, 
                       _ISyncEnumValue_Contacts_EmailAddress_Type_Other, 
                       _ISyncEnumValue_Contacts_EmailAddress_Type_Work, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_Home, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_HomeFax, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_Main, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_Mobile, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_Other, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_Pager, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_Work, 
                       _ISyncEnumValue_Contacts_PhoneNumber_Type_WorkFax, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Assistant, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Brother, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Child, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Father, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Friend, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Manager, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Mother, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Other, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Parent, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Partner, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Sister, 
                       _ISyncEnumValue_Contacts_RelatedName_Type_Spouse, 
                       _ISyncEnumValue_Contacts_StreetAddress_Type_Home, 
                       _ISyncEnumValue_Contacts_StreetAddress_Type_Other, 
                       _ISyncEnumValue_Contacts_StreetAddress_Type_Work, 
                       _ISyncEnumValue_Contacts_URL_IM_Type_Home, _ISyncEnumValue_Contacts_URL_IM_Type_Other, 
                       _ISyncEnumValue_Contacts_URL_IM_Type_Work, _ISyncEnumValue_Contacts_URL_Type_Home, 
                       _ISyncEnumValue_Contacts_URL_Type_HomePage, _ISyncEnumValue_Contacts_URL_Type_Other, 
                       _ISyncEnumValue_Contacts_URL_Type_Work, _ISyncErrorDomain, 
                       _ISyncExcludeFromDataChangeAlertKey, _ISyncFilesystemFullException, 
                       _ISyncInvalidArgumentsException, _ISyncInvalidEntityException, 
                       _ISyncInvalidRecordException, _ISyncInvalidRecordIdentifiersKey, 
                       _ISyncInvalidRecordReasonsKey, _ISyncInvalidRecordsKey, 
                       _ISyncInvalidSchemaException, _ISyncInvalidSchemaVersion, 
                       _ISyncJobChangedNotification, _ISyncJobEndedObject, 
                       _ISyncManagerException, _ISyncMinglerCrashedException, 
                       _ISyncNameNumberMappingException, _ISyncPlanAddedParticipantObject, 
                       _ISyncPlanCanceledFromUINotification, _ISyncPlanCancellingObject, 
                       _ISyncPlanChangedNotification, _ISyncPlanClientIdentifiersKey, 
                       _ISyncPlanCreatedObject, _ISyncPlanDataclassNamesKey, 
                       _ISyncPlanEndedObject, _ISyncPlanEntityNamesKey, 
                       _ISyncPlanIdentifierKey, _ISyncPlanMinglingObject, 
                       _ISyncPlanPullingObject, _ISyncPlanPushingObject, 
                       _ISyncPlanRemovedParticipantObject, _ISyncPlanStatusCancelledValue, 
                       _ISyncPlanStatusFinishedValue, _ISyncPlanStatusKey, 
                       _ISyncPlanTimestampKey, _ISyncRecordDefaultedPropertyNamesKey, 
                       _ISyncRecordEntityNameKey, _ISyncRecordGlobalIdEquivalentsKey, 
                       _ISyncRecordGlobalIdentityKey, _ISyncRecordKeepAwayFromServersKey, 
                       _ISyncRecordModificationTimestampKey, _ISyncRelationship_Bookmarks_Bookmark_Parent, 
                       _ISyncRelationship_Bookmarks_Folder_Children, _ISyncRelationship_Bookmarks_Folder_Parent, 
                       _ISyncRelationship_Calendars_Attendee_Owner, _ISyncRelationship_Calendars_AudioAlarm_Owner, 
                       _ISyncRelationship_Calendars_CalendarOrder_Calendars, 
                       _ISyncRelationship_Calendars_Calendar_Events, _ISyncRelationship_Calendars_Calendar_Tasks, 
                       _ISyncRelationship_Calendars_DisplayAlarm_Owner, 
                       _ISyncRelationship_Calendars_Event_Attendees, _ISyncRelationship_Calendars_Event_AudioAlarms, 
                       _ISyncRelationship_Calendars_Event_Calendar, _ISyncRelationship_Calendars_Event_DetachedEvents, 
                       _ISyncRelationship_Calendars_Event_DisplayAlarms, 
                       _ISyncRelationship_Calendars_Event_MailAlarms, _ISyncRelationship_Calendars_Event_MainEvent, 
                       _ISyncRelationship_Calendars_Event_Organizer, _ISyncRelationship_Calendars_Event_Recurrences, 
                       _ISyncRelationship_Calendars_MailAlarm_Owner, _ISyncRelationship_Calendars_Organizer_Owner, 
                       _ISyncRelationship_Calendars_Recurrence_Owner, _ISyncRelationship_Calendars_Task_Attendees, 
                       _ISyncRelationship_Calendars_Task_AudioAlarms, _ISyncRelationship_Calendars_Task_Calendar, 
                       _ISyncRelationship_Calendars_Task_DetachedTasks, 
                       _ISyncRelationship_Calendars_Task_DisplayAlarms, 
                       _ISyncRelationship_Calendars_Task_MailAlarms, _ISyncRelationship_Calendars_Task_MainTask, 
                       _ISyncRelationship_Calendars_Task_Organizer, _ISyncRelationship_Calendars_Task_Recurrences, 
                       _ISyncRelationship_Com_Apple_Notes_Attachment_Note, 
                       _ISyncRelationship_Com_Apple_Notes_Note_Attachments, 
                       _ISyncRelationship_Com_Apple_Notes_Note_Keywords, 
                       _ISyncRelationship_Contacts_CalendarURI_Contact, 
                       _ISyncRelationship_Contacts_Contact_CalendarURIs, 
                       _ISyncRelationship_Contacts_Contact_CustomFields, 
                       _ISyncRelationship_Contacts_Contact_Dates, _ISyncRelationship_Contacts_Contact_EmailAddresses, 
                       _ISyncRelationship_Contacts_Contact_IMs, _ISyncRelationship_Contacts_Contact_ImageTransformationInfo, 
                       _ISyncRelationship_Contacts_Contact_ParentGroups, 
                       _ISyncRelationship_Contacts_Contact_PhoneNumbers, 
                       _ISyncRelationship_Contacts_Contact_PrimaryCalendarURI, 
                       _ISyncRelationship_Contacts_Contact_PrimaryCustomField, 
                       _ISyncRelationship_Contacts_Contact_PrimaryDate, 
                       _ISyncRelationship_Contacts_Contact_PrimaryEmailAddress, 
                       _ISyncRelationship_Contacts_Contact_PrimaryIM, _ISyncRelationship_Contacts_Contact_PrimaryPhoneNumber, 
                       _ISyncRelationship_Contacts_Contact_PrimaryRelatedName, 
                       _ISyncRelationship_Contacts_Contact_PrimaryStreetAddress, 
                       _ISyncRelationship_Contacts_Contact_PrimaryURL, 
                       _ISyncRelationship_Contacts_Contact_RelatedNames, 
                       _ISyncRelationship_Contacts_Contact_StreetAddresses, 
                       _ISyncRelationship_Contacts_Contact_URLs, _ISyncRelationship_Contacts_CustomField_Contact, 
                       _ISyncRelationship_Contacts_Date_Contact, _ISyncRelationship_Contacts_EmailAddress_Contact, 
                       _ISyncRelationship_Contacts_Group_DistributionEmailAddresses, 
                       _ISyncRelationship_Contacts_Group_DistributionPhoneNumbers, 
                       _ISyncRelationship_Contacts_Group_DistributionStreetAddresses, 
                       _ISyncRelationship_Contacts_Group_Members, _ISyncRelationship_Contacts_Group_ParentGroups, 
                       _ISyncRelationship_Contacts_IM_Contact, _ISyncRelationship_Contacts_ImageTransformationInfo_Contact, 
                       _ISyncRelationship_Contacts_PhoneNumber_Contact, 
                       _ISyncRelationship_Contacts_RelatedName_Contact, 
                       _ISyncRelationship_Contacts_StreetAddress_Contact, 
                       _ISyncRelationship_Contacts_URL_Contact, _ISyncResolutionPolicyClient, 
                       _ISyncResolutionPolicyLastModified, _ISyncResolutionPolicyPreferredClientTypesKey, 
                       _ISyncResolutionPolicyPreferredRecordKey, _ISyncResolutionPolicyTruth, 
                       _ISyncResolvedConflictsKey, _ISyncSchemaBaseMajorVersionKey, 
                       _ISyncSchemaBaseMinorVersionKey, _ISyncSchemaBaseNameKey, 
                       _ISyncSchemaCommentKey, _ISyncSchemaConflictResolverClassKey, 
                       _ISyncSchemaConflictUIHelperClassKey, _ISyncSchemaDataClassesKey, 
                       _ISyncSchemaEntitiesKey, _ISyncSchemaMajorVersionKey, 
                       _ISyncSchemaManagedObjectModelsKey, _ISyncSchemaMinorVersionKey, 
                       _ISyncSchemaNameKey, _ISyncSchemaStrictParsingKey, 
                       _ISyncSchemaUIHelperClassKey, _ISyncSchemaValidatorClassKey, 
                       _ISyncServerDisabledByPreferenceReason, _ISyncServerDisabledSharedNetworkHomeReason, 
                       _ISyncServerDisabledUnknownReason, _ISyncServerDisabledUnresponsiveReason, 
                       _ISyncServerNotDisabledReason, _ISyncServerUnavailableAnotherComputerRunningSyncServer, 
                       _ISyncServerUnavailableException, _ISyncSessionCancelledException, 
                       _ISyncSessionRunLoopMode, _ISyncSessionUnavailableException, 
                       _ISyncTruthPusherClientIdKey, _ISyncTruthPusherReasonKey, 
                       _ISyncTruthPusherWantsToPullTruthKey, _ISyncUnsupportedEntityException, 
                       _SyncServicesVersionNumber, _SyncServicesVersionString, 
                       __ISDActiveClientCheckIntervalDefault, __ISDActiveClientCheckKey, 
                       __ISDAirbagAnimationInterval, __ISDAirbagDataclassBlacklist, 
                       __ISDAirbagIsEnabled, __ISDAirbagMinimumRecordsInTruthForDataclass, 
                       __ISDAirbagSetAnimationInterval, __ISDAirbagSetEnabled, 
                       __ISDAirbagSetThreshold, __ISDAirbagThreshold, __ISDAirbagTimeout, 
                       __ISDAllocUUID, __ISDAllocUUIDString, __ISDAllowMultipleAppClients, 
                       __ISDAllowUnresolvedReferences, __ISDAlwaysShowAirbagIsEnabled, 
                       __ISDAlwaysShowAirbagSetEnabled, __ISDAreDataWrappersDisabled, 
                       __ISDArrayOfDictionariesFromQueryCallback, __ISDBackdoorListenerPort, 
                       __ISDBrandString, __ISDChangeSourceVacuumThreshold, 
                       __ISDCleanStringForFileSystem, __ISDCleanupCallHistory, 
                       __ISDCleanupExtraBeehiveBackupFiles, __ISDClientNameSymlinkPathForClient, 
                       __ISDClientReceiveTimeout, __ISDClientSendTimeout, 
                       __ISDClientSyncAlertHandlerBootstrapName, __ISDComputeClosureOfEntityNames, 
                       __ISDComputeConservativeClosureOfEntityNames, __ISDComputeFileSystemNodeSize, 
                       __ISDConnectRetryCount, __ISDConnectTimeout, __ISDCopyUUIDAsData, 
                       __ISDCopyUUIDAsString, __ISDCreateUUID, __ISDDataDirectoryPathForClient, 
                       __ISDDataWrapperThresholdSize, __ISDDatabaseAccessStatus, 
                       __ISDDefaultDataDirectoryPath, __ISDDefaultLogDirectoryPath, 
                       __ISDDefaultSyncServicesDirectoryPath, __ISDDefaultSyncServicesLogDirectoryPath, 
                       __ISDDisableLogAlways, __ISDDisableMessageTracing, 
                       __ISDDisableUIHelpers, __ISDDisabledServer, __ISDDomainString, 
                       __ISDEnsureDirectoryPathExists, __ISDEntityNamesToDataclassNames, 
                       __ISDFileSystemSafeString, __ISDFileSystemSafeStringUsingHash, 
                       __ISDFileSystemSafeStringUsingHex, __ISDGetToplevelDataDirectory, 
                       __ISDGetTruthDatabaseDirectoryForSegmentNamed, __ISDHexDataDirectoryPathForClient, 
                       __ISDHomeDirectoryIsOnSharedNetworkDrive, __ISDInitializeLogging, 
                       __ISDIsContactSyncingAllowed, __ISDIsDatabaseAtPathCorrupted, 
                       __ISDIsSyncingEnabled, __ISDLimitAlwaysShowAirbagDataclasses, 
                       __ISDLog, __ISDLogDirectoryPathForClient, __ISDLogEverythingPrefsKey, 
                       __ISDLogLevel, __ISDLogLevelPrefsKey, __ISDLogLevelToString, 
                       __ISDLogSql, __ISDLogStackTraceOnException, __ISDLogSuppressKey, 
                       __ISDMaxSessionCreationTime, __ISDMessageTrace, 
                       __ISDNewActiveClientCheckDate, __ISDNewPurgeAndVacuumDate, 
                       __ISDNumberOfBeehiveBackupFilesToKeep, __ISDNumberOfLogFiles, 
                       __ISDPotentialLogFileNames, __ISDPruneFilePath, 
                       __ISDPurgeAndVacuumIntervalDefault, __ISDPurgeTimeKey, 
                       __ISDSPathForSQLiteDatabase, __ISDSQLiteBlowOut, 
                       __ISDSQLiteTraceSQL, __ISDSQliteFullIOErrCorruptionHandler, 
                       __ISDSaveClientDataBeforeMingler, __ISDSaveDataDirectorySnapshot, 
                       __ISDSaveDirectoryPathInDirectory, __ISDSaveSyncServicesDirectoryForException, 
                       __ISDServerBootstrapName, __ISDServerPath, __ISDSetActiveClientCheckIntervalDefault, 
                       __ISDSetAllowUnresolvedReferences, __ISDSetAreDataWrappersDisabled, 
                       __ISDSetDisabledServer, __ISDSetNumberOfLogFiles, 
                       __ISDSetShouldCompressClientState, __ISDSetShouldEnableBackdoorListener, 
                       __ISDSetShouldEnableDebugMenu, __ISDSetShouldEnableGrowlNotifications, 
                       __ISDSetShouldExcludeSyncingPreferences, __ISDSetShouldSaveAdditionalInfoWhenMingleFails, 
                       __ISDSetShouldSaveCallHistory, __ISDSetShouldSaveCallHistoryForEveryCall, 
                       __ISDSetShouldSaveClientState, __ISDSetShouldSavePushedChanges, 
                       __ISDSetShouldUseSmartExceptionsInSyncServer, __ISDSetShowAnchorMismatchDialog, 
                       __ISDSetShowDetailOnLoad, __ISDSetSyncingEnabled, 
                       __ISDShouldCleanupAllCallHistory, __ISDShouldCompressClientState, 
                       __ISDShouldDisableUIHelpers, __ISDShouldEnableBackdoorListener, 
                       __ISDShouldEnableDebugMenu, __ISDShouldEnableGrowlNotifications, 
                       __ISDShouldExcludeSyncingPreferences, __ISDShouldLog, 
                       __ISDShouldLogEverything, __ISDShouldLogKey, __ISDShouldLogPersonalInfo, 
                       __ISDShouldRequireLowercaseTypes, __ISDShouldSaveAdditionalInfoWhenMingleFails, 
                       __ISDShouldSaveCallHistory, __ISDShouldSaveCallHistoryForEveryCall, 
                       __ISDShouldSaveClientState, __ISDShouldSavePushedChanges, 
                       __ISDShouldUseSmartExceptionsInSyncServer, __ISDShouldValidateClients, 
                       __ISDShouldValidatePushedChangesAndRecords, __ISDShouldValidateTypesInSchemas, 
                       __ISDShowAnchorMismatchDialog, __ISDShowDetailOnLoad, 
                       __ISDSqliteCacheSize, __ISDStringToLogLevel, __ISDSyncAlertReceiveTimeout, 
                       __ISDSyncAlertSendTimeout, __ISDSyncDirectoryFileSystemSupportsHardLinks, 
                       __ISDSyncPlanKeepCheckKey, __ISDSyncUIDaemonReceiveTimeout, 
                       __ISDSyncUIDaemonSendTimeout, __ISDSyncingEntitiesAllowed, 
                       __ISDSyncsAfterHysteresis, __ISDUnregisteredClientName, 
                       __ISDUseExtendedFiltering, __ISDVLog, __ISD_UTNameNumberSetup, 
                       __ISD_UTNameNumberTearDown, __ISDfileIsLocked, __ISyncAssertFailed, 
                       __ISyncPreconditionFailed, __ISyncPrivateInstance, 
                       __WarnAboutUsingISyncDataClassImageKey, ___ISDDefaultSyncServicesDirectoryPath, 
                       ___ISDDefaultSyncServicesLogDirectoryPath, ___ISyncThouShallNotSubclass, 
                       __dataclassNamesForEntities, __executeSQL, __executeStatement, 
                       __gDataDirectoryPath, __insertIdReferences, __isRunningInServer, 
                       __runningInServer, __setIsRunningInServer, _beginExclusiveTransaction, 
                       _beginImmediateTransaction, _beginTransaction, _checkin_mach_service, 
                       _commitTransaction, _conflictsCount, _createCalendarRequestPort, 
                       _databaseGotCorrupted, _databasePath, _getColumnDescriptionWithSql, 
                       _googleFound, _integrityResult, _isd_addRecordIdToArray, 
                       _isd_clientAsNumber, _isd_clientName, _isd_clientNumber, 
                       _isd_entityAsNumber, _isd_entityName, _isd_entityNumber, 
                       _isd_mapArray, _kConflictResolver, _kSSUID, _kSyncMenu, 
                       _kUUIDExpectedDataLength, _kUUIDExpectedStringLength, 
                       _rollbackTransaction, _sqliteExecute, _sqliteExecuteWithCallback, 
                       _sqliteExecuteWithCallbackAndOptions, _syncServerPreference ]
    objc-classes:    [ _DataMgrBasedNameNumberProvider, _DefaultNameNumberProvider, 
                       _IDMapping, _ISDAdminDatabase, _ISDCallHistory, 
                       _ISDChange, _ISDChangeBuilder, _ISDChangeEnumerator, 
                       _ISDChangePuller, _ISDChangePusher, _ISDChangeStore, 
                       _ISDClient, _ISDClientState, _ISDConflict, _ISDConflictAddEnumerator, 
                       _ISDConflictChangeEnumerator, _ISDConflictManager, 
                       _ISDDataClass, _ISDDataDatabase, _ISDDataDirectoryVersion, 
                       _ISDDataManager, _ISDDataObject, _ISDDataReference, 
                       _ISDDataWrapper, _ISDDatabase, _ISDDigestMaker, 
                       _ISDDisabledServer, _ISDEntity, _ISDEntityComponent, 
                       _ISDException, _ISDFastCDSyncHelper, _ISDFileReference, 
                       _ISDFiltratorThingy, _ISDGlobalId, _ISDIdMapDatabase, 
                       _ISDInstrumentedEnumerator, _ISDKeyedArchiverHelperToRemoveSyncStates, 
                       _ISDNameNumberMapping, _ISDNameNumberProvider, _ISDObjectGraphWrapper, 
                       _ISDPersistentStoreSyncer, _ISDPreNameNumberMapIdMapDatabase, 
                       _ISDProperty, _ISDPropertyChange, _ISDPropertyConflict, 
                       _ISDPropertyValue, _ISDQuickDirtyCoder, _ISDRecord, 
                       _ISDRecordIdMap, _ISDRecordIdMapDatabase, _ISDRecordIdMapper, 
                       _ISDRecordStore, _ISDRelationship, _ISDSaveSyncServicesDirectoryCopyHandler, 
                       _ISDSchema, _ISDSchemaParser, _ISDServer, _ISDServerFileLockerDelegate, 
                       _ISDSqliteChangeStore, _ISDSqliteChangeStoreDatabase, 
                       _ISDSqliteRecordIdMapper, _ISDStructuredDelta, _ISDSyncJob, 
                       _ISDSyncManager, _ISDSyncParticipant, _ISDSyncPlan, 
                       _ISDSyncState, _ISyncAlwaysAcceptFilter, _ISyncChange, 
                       _ISyncClient, _ISyncConcreteChange, _ISyncConcreteClient, 
                       _ISyncConcreteManager, _ISyncConcreteRecordGraphNode, 
                       _ISyncConcreteRecordReference, _ISyncConcreteRecordSnapshot, 
                       _ISyncConcreteRecordView, _ISyncConcreteSession, 
                       _ISyncConcreteSessionDriver, _ISyncConjunctionFilter, 
                       _ISyncFileLocker, _ISyncFilter, _ISyncInstrumentedSession, 
                       _ISyncManager, _ISyncPlan, _ISyncRecordGraphNode, 
                       _ISyncRecordReference, _ISyncRecordSnapshot, _ISyncRecordView, 
                       _ISyncRecordViewWithConflicts, _ISyncRecordWithConflictGraphNode, 
                       _ISyncSession, _ISyncSessionDriver, _ISyncSimplyIgnoreLocalsFilter, 
                       _ISyncTCCAccessOperation, _PresetNameNumberProvider, 
                       _RelationshipInformation, _ServerBasedNameNumberProvider, 
                       _SyncClientNameNumberProvider ]
...
                                                                                                                                                                                                                                                                                                                                                                                                                                                            Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 032150  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/Versions                                                                          osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SyncServices.framework/module.map     0100644 0001750 0001750 00000000457 12566173266 030760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        framework module SyncServices [extern_c] {
  umbrella header "SyncServices.h"

  export *
  module * { export * }

  explicit module ISyncConflictPropertyType {
    header "ISyncConflictPropertyType.h"
    export *
  }

  explicit module ISyncUIHelper {
    header "ISyncUIHelper.h"
    export *
  }
}

                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/System.framework/                     0040755 0001750 0001750 00000000000 12612224746 025625  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/System.framework/System.tbd           0120777 0001750 0001750 00000000000 12620245063 035003  2Versions/Current/System.tbd                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/System.framework/Versions/            0040755 0001750 0001750 00000000000 12612224746 027435  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/System.framework/Versions/B/          0040755 0001750 0001750 00000000000 12612224746 027616  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/System.framework/Versions/B/System.tbd0120777 0001750 0001750 00000000000 12620245063 037472  2../../../../../../usr/lib/libSystem.B.tbd                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/System.framework/Versions/Current     0120777 0001750 0001750 00000000000 12620245063 031074  2B                                                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/        0040755 0001750 0001750 00000000000 12612224746 030355  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Headers 0120777 0001750 0001750 00000000000 12620245063 036371  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Modules 0120777 0001750 0001750 00000000000 12620245063 036463  2Versions/Current/Modules                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        SystemConfiguration.tbd                                                                             0120777 0001750 0001750 00000000000 12620245063 044734  2Versions/Current/SystemConfiguration.tbd                                                            ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework                                                                            Versions/                                                                                           0040755 0001750 0001750 00000000000 12612224746 032106  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework                                                                            A/                                                                                                  0040755 0001750 0001750 00000000000 12612224746 032266  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions                                                                   Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224746 033641  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A                                                                 CaptiveNetwork.h                                                                                    0100644 0001750 0001750 00000015616 12567450664 036776  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2009-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _CAPTIVENETWORK_H
#define _CAPTIVENETWORK_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header CaptiveNetwork
	@discussion The CaptiveNetwork API allows applications to interact
		with Captive Network Support. Captive Network Support is a
		system component responsible for detecting and help users
		navigate networks that require interaction before providing
		internet access. The most common Captive Networks are WiFi
		Hotspots in places like airports, restaurants, and hotels.
		Captive Network Support will attempt to authenticate if
		possible or drop a user in to a web sheet if authentication
		is not possible. In the web sheet the user has an opportunity
		to authenticate or disassociate from the network.

		The following APIs are designed for third party applications
		that may handle authentication on these networks on behalf of
		the user.

		These APIs are treated as advisory only.
		There is no guarantee or contract that the operating system
		will take the intended action.

	@note IMPORTANT: This API is deprecated starting in iOS 9.
		For captive network applications, this has been completely
		replaced by <NetworkExtension/NEHotspotHelper.h>.
		For other applications, there is no direct replacement.
		Please file a bug describing your use of this API so that
		we can consider your requirements as this situation evolves.
 */

#define CN_DEPRECATION_NOTICE						\
    "For captive network applications, this has been completely "	\
    "replaced by <NetworkExtension/NEHotspotHelper.h>. "		\
    "For other applications, there is no direct replacement. "		\
    "Please file a bug describing your use of this API to that "	\
    "we can consider your requirements as this situation evolves."

__BEGIN_DECLS

/*!
	@function CNSetSupportedSSIDs
	@discussion Provides Captive Network Support with an updated list of
		SSIDs that this application will perform authentication on.

		Captive Network Support suppresses showing the Web Sheet
		for a captive Wi-Fi network if that network's SSID is in the
		specified list.

		On iOS, the registrations persist until the application is
		removed from the device.

		On MacOSX, the registrations persist as long as the application
		is running.

	@param ssidArray A CFArray of CFStrings of the SSIDs.
	@result Returns TRUE if the operation succeeded, FALSE otherwise.
 */
Boolean
CNSetSupportedSSIDs	(CFArrayRef	ssidArray)
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_8, __MAC_NA,
				       __IPHONE_4_0, __IPHONE_9_0,
				       "Replaced by <NetworkExtension/NEHotspotHelper.h>");

/*!
	@function CNMarkPortalOnline
	@discussion Tells Captive Network Support that your application has
		authenticated the device to the network. Captive Network Support
		will notify the rest of the system that WiFi is now a viable
		interface.
	@param interfaceName Name of the interface that is now online.
	@result Returns TRUE if the operation succeeded, FALSE otherwise.
 */
Boolean
CNMarkPortalOnline	(CFStringRef	interfaceName)
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_8, __MAC_NA,
				       __IPHONE_4_0, __IPHONE_9_0,
				       "Replaced by <NetworkExtension/NEHotspotHelper.h>");

/*!
	@function CNMarkPortalOffline
	@discussion Tells Captive Network Support that the device is not
		authenticated on the given network interface.
	@param interfaceName Name of the interface that is still captive.
	@result Returns TRUE if the operation succeeded, FALSE otherwise.
 */
Boolean
CNMarkPortalOffline	(CFStringRef	interfaceName)
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_8, __MAC_NA,
				       __IPHONE_4_0, __IPHONE_9_0,
				       "Replaced by <NetworkExtension/NEHotspotHelper.h>");

/*!
 @function CNCopySupportedInterfaces
 @discussion copies a list of all interfaces CaptiveNetworkSupport is monitoring.
 @result An array of CFStringRef- BSD interface names.
	 Returns NULL if an error was encountered.
	 You MUST release the returned value.
 */
CFArrayRef __nullable
CNCopySupportedInterfaces	(void)
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_8, __MAC_NA,
				       __IPHONE_4_1, __IPHONE_9_0,
				       CN_DEPRECATION_NOTICE);

/*!
 @constant kCNNetworkInfoKeySSIDData
 @discussion NetworkInfo Dictionary key for SSID in CFData format
 */
extern const CFStringRef kCNNetworkInfoKeySSIDData
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_NA, __MAC_NA,
				       __IPHONE_4_1, __IPHONE_9_0,
				       CN_DEPRECATION_NOTICE);

/*!
 @constant kCNNetworkInfoKeySSID
 @discussion NetworkInfo Dictionary key for SSID in CFString format
 */
extern const CFStringRef kCNNetworkInfoKeySSID
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_NA, __MAC_NA,
				       __IPHONE_4_1, __IPHONE_9_0,
				       CN_DEPRECATION_NOTICE);

/*!
 @constant kCNNetworkInfoKeyBSSID
 @discussion NetworkInfo Dictionary key for BSSID in CFString format
 */
extern const CFStringRef kCNNetworkInfoKeyBSSID
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_NA, __MAC_NA,
				       __IPHONE_4_1, __IPHONE_9_0,
				       CN_DEPRECATION_NOTICE);

/*!
 @function CNCopyCurrentNetworkInfo
 @discussion Returns the Network Info for the specified interface.
	For example, Network Info dictionary will contain the following
	keys, and values:
	<pre>
	@textblock
	Keys                      : Values
	=======================================
	kCNNetworkInfoKeySSIDData : CFDataRef
	kCNNetworkInfoKeySSID     : CFStringRef
	kCNNetworkInfoKeyBSSID    : CFStringRef
	@/textblock
	</pre>
 @param interfaceName Name of the interface you are interested in
 @result Network Info dictionary associated with the interface.
	 Returns NULL if an error was encountered.
	 You MUST release the returned value.
 */
CFDictionaryRef __nullable
CNCopyCurrentNetworkInfo	(CFStringRef interfaceName)
    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_NA, __MAC_NA,
				       __IPHONE_4_1, __IPHONE_9_0,
				       CN_DEPRECATION_NOTICE);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _CAPTIVENETWORK_H */
                                                                                                                  DHCPClientPreferences.h                                                                             0100644 0001750 0001750 00000005701 12567450664 040062  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2001, 2004, 2005, 2008, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _DHCPCLIENTPREFERENCES_H
#define _DHCPCLIENTPREFERENCES_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CFString.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header DHCPClientPreferences
	@discussion The DHCPClientPreferences API allows applications to get and update DHCP preferences.
		DHCP preferences are in the form of DHCP option codes, which are defined in RFC 2132.
 */

__BEGIN_DECLS

/*!
	@function DHCPClientPreferencesSetApplicationOptions
	@discussion Updates the DHCP client preferences to include the
		given list of options for the given application ID.
	@param applicationID The application's preference ID, for example:
		"com.apple.SystemPreferences".
	@param options An array of 8-bit values containing the
		DHCP option codes (see RFC 2132) for this application ID.
		A NULL value will clear the list of options for this
		application ID.
	@param count The number of elements in the options parameter.
	@result Returns TRUE if the operation succeeded, FALSE otherwise.
 */

Boolean
DHCPClientPreferencesSetApplicationOptions	(CFStringRef			applicationID,
						 UInt8		* __nullable	options,
						 CFIndex			count)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function DHCPClientPreferencesCopyApplicationOptions
	@discussion Copies the requested DHCP options for the
		given application ID.
	@param applicationID The application's preference ID, for example
		"com.apple.SystemPreferences".
	@param count The number of elements in the returned array.
	@result Returns the list of options for the given application ID, or
		NULL if no options are defined or an error occurred.

		When you are finished, use free() to release a non-NULL return value.
 */

UInt8 * __nullable
DHCPClientPreferencesCopyApplicationOptions	(CFStringRef	applicationID,
						 CFIndex	*count)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _DHCPCLIENTPREFERENCES_H */
                                                               SCDynamicStore.h                                                                                    0100644 0001750 0001750 00000040512 12567450664 036651  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000, 2001, 2003-2005, 2008-2010, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCDYNAMICSTORE_H
#define _SCDYNAMICSTORE_H

#include <Availability.h>
#include <TargetConditionals.h>
#include <sys/cdefs.h>
#include <dispatch/dispatch.h>
#include <CoreFoundation/CoreFoundation.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCDynamicStore
	@discussion The SCDynamicStore API provides access to the key-value
		pairs in the dynamic store of a running system.  The dynamic
		store contains, among other items, a copy of the configuration
		settings for the currently active set (which is sometimes
		refered to as the location) and information about the current
		network state.

		The functions in the SCDynamicStore API allow you to find
		key-value pairs, add or remove key-value pairs, add or change
		values, and request notifications.

		To use the functions of the SCDynamicStore API, you must first
		establish a dynamic store session using the SCDynamicStoreCreate
		function.  When you are finished with the session, use CFRelease
		to close it.
 */


/*!
	@typedef SCDynamicStoreRef
	@discussion This is the handle to an open a dynamic store session
		with the system configuration daemon.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCDynamicStore *	SCDynamicStoreRef;

/*!
	@typedef SCDynamicStoreContext
	Structure containing user-specified data and callbacks for an
	SCDynamicStore session.
	@field version The version number of the structure type being passed
		in as a parameter to the SCDynamicStore creation function.
		This structure is version 0.
	@field info A C pointer to a user-specified block of data.
	@field retain The callback used to add a retain for the info field.
		If this parameter is not a pointer to a function of the correct
		prototype, the behavior is undefined.  The value may be NULL.
	@field release The calllback used to remove a retain previously added
		for the info field.  If this parameter is not a pointer to a
		function of the correct prototype, the behavior is undefined.
		The value may be NULL.
	@field copyDescription The callback used to provide a description of
		the info field.
 */
typedef struct {
	CFIndex		version;
	void *		__nullable info;
	const void	* __nonnull (* __nullable retain)(const void *info);
	void		(* __nullable release)(const void *info);
	CFStringRef	__nonnull (* __nullable copyDescription)(const void *info);
} SCDynamicStoreContext;

/*!
	@typedef SCDynamicStoreCallBack
	@discussion Type of callback function used when notification of
		changes to the dynamic store is delivered.
	@param store The dynamic store session.
	@param changedKeys The list of changed keys.

		The list includes any specific SCDynamicStore keys that
		changed (add, update, remove, notify) since the last call
		to SCDynamicStoreSetNotificationKeys or since the last
		notification callback. The list also includes any specific
		keys matching one of the pattern string(s) that changed.

		An empty list indicates that the SCDynamicStore server
		restarted and that any assumptions based on prior content
		of the SCDynamicStore should be disgarded.

	@param info A C pointer to a user-specified block of data.
 */
typedef void (*SCDynamicStoreCallBack)	(
					SCDynamicStoreRef			store,
					CFArrayRef				changedKeys,
					void			* __nullable	info
					);


__BEGIN_DECLS

/*!
	@function SCDynamicStoreGetTypeID
	@discussion Returns the type identifier of all SCDynamicStore instances.
 */
CFTypeID
SCDynamicStoreGetTypeID			(void)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);


/*!
	@function SCDynamicStoreCreate
	@discussion Creates a new session used to interact with the dynamic
		store maintained by the System Configuration server.
	@param allocator The CFAllocator that should be used to allocate
		memory for the local dynamic store object.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param name A string that describes the name of the calling
		process or plug-in of the caller.
	@param callout The function to be called when a watched value
		in the dynamic store is changed.
		A NULL value can be specified if no callouts are
		desired.
	@param context The SCDynamicStoreContext associated with the callout.
	@result Returns a reference to the new SCDynamicStore session.
		You must release the returned value.
 */
SCDynamicStoreRef __nullable
SCDynamicStoreCreate			(
					CFAllocatorRef			__nullable	allocator,
					CFStringRef					name,
					SCDynamicStoreCallBack		__nullable	callout,
					SCDynamicStoreContext		* __nullable	context
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCreateWithOptions
	@discussion Creates a new session used to interact with the dynamic
		store maintained by the System Configuration server.
	@param allocator The CFAllocator that should be used to allocate
		memory for the local dynamic store object.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param name A string that describes the name of the calling
		process or plug-in of the caller.
	@param storeOptions A CFDictionary containing options for the
		dynamic store session (such as whether all keys added or set
		into the dynamic store should be per-session keys).

		Currently available options include:

		<TABLE BORDER>
		<TR>
			<TH>key</TD>
			<TH>value</TD>
		</TR>
		<TR>
			<TD>kSCDynamicStoreUseSessionKeys</TD>
			<TD>CFBooleanRef</TD>
		</TR>
		</TABLE>

		A NULL value can be specified if no options are desired.
	@param callout The function to be called when a watched value
		in the dynamic store is changed.
		A NULL value can be specified if no callouts are
		desired.
	@param context The SCDynamicStoreContext associated with the callout.
	@result Returns a reference to the new SCDynamicStore session.
		You must release the returned value.
 */
SCDynamicStoreRef __nullable
SCDynamicStoreCreateWithOptions		(
					CFAllocatorRef			__nullable	allocator,
					CFStringRef					name,
					CFDictionaryRef			__nullable	storeOptions,
					SCDynamicStoreCallBack		__nullable	callout,
					SCDynamicStoreContext		* __nullable	context
					)				__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

extern const CFStringRef	kSCDynamicStoreUseSessionKeys		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);	/* CFBoolean */

/*!
	@function SCDynamicStoreCreateRunLoopSource
	@discussion Creates a CFRunLoopSource object that can be added to the
		application's run loop.  All dynamic store notifications are
		delivered using this run loop source.
	@param allocator The CFAllocator that should be used to allocate
		memory for this run loop source.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param store A reference to the dynamic store session.
	@param order On platforms which support it, for source versions
		which support it, this parameter determines the order in
		which the sources which are ready to be processed are
		handled. A lower order number causes processing before
		higher order number sources. It is inadvisable to depend
		on the order number for any architectural or design aspect
		of code. In the absence of any reason to do otherwise,
		zero should be used.
	@result A reference to the new CFRunLoopSource.
		You must release the returned value.

 */
CFRunLoopSourceRef __nullable
SCDynamicStoreCreateRunLoopSource	(
					CFAllocatorRef			__nullable	allocator,
					SCDynamicStoreRef				store,
					CFIndex						order
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreSetDispatchQueue
	@discussion Initiates notifications for the Notification
		Keys in store to the callback contained in store.
	@param store A reference to the dynamic store session.
	@param queue The dispatch queue to run the callback function on.
		Pass NULL to disable notifications, and release the queue.
	@result Returns TRUE on success, FALSE on failure.

 */
Boolean
SCDynamicStoreSetDispatchQueue		(
					SCDynamicStoreRef				store,
					dispatch_queue_t		__nullable	queue
					)				__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyKeyList
	@discussion Returns an array of CFString keys representing the
		current dynamic store entries that match a specified pattern.
	@param store The dynamic store session.
	@param pattern A regex(3) regular expression pattern
		used to match the dynamic store keys.
	@result Returns the list of matching keys; NULL if an error was
		encountered.
		You must release the returned value.
 */
CFArrayRef __nullable
SCDynamicStoreCopyKeyList		(
					SCDynamicStoreRef		__nullable	store,
					CFStringRef					pattern
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreAddValue
	@discussion Adds the key-value pair to the dynamic store if no
		such key already exists.
	@param store The dynamic store session.
	@param key The key of the value to add to the dynamic store.
	@param value The value to add to the dynamic store.
	@result Returns TRUE if the key was added; FALSE if the key was already
		present in the dynamic store or if an error was encountered.
 */
Boolean
SCDynamicStoreAddValue			(
					SCDynamicStoreRef		__nullable	store,
					CFStringRef					key,
					CFPropertyListRef				value
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreAddTemporaryValue
	@discussion Temporarily adds the key-value pair to the dynamic store
		if no such key already exists.  Unless the key is updated by another
		session, the key-value pair will be removed automatically when the
		session is closed.
	@param store The dynamic store session.
	@param key The key of the value to add to the dynamic store.
	@param value The value to add to the dynamic store.
	@result Returns TRUE if the key was added; FALSE if the key was already
		present in the dynamic store or if an error was encountered.
 */
Boolean
SCDynamicStoreAddTemporaryValue		(
					SCDynamicStoreRef		store,
					CFStringRef			key,
					CFPropertyListRef		value
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyValue
	@discussion Gets the value of the specified key from the dynamic store.
	@param store The dynamic store session.
	@param key The key associated with the value you want to get.
	@result Returns the value from the dynamic store that is associated with the given
		key; NULL if no value was located or an error was encountered.
		You must release the returned value.
 */
CFPropertyListRef __nullable
SCDynamicStoreCopyValue			(
					SCDynamicStoreRef		__nullable	store,
					CFStringRef					key
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyMultiple
	@discussion Gets the values of multiple keys in the dynamic store.
	@param store The dynamic store session.
	@param keys The keys associated with the values you want to get; NULL if no specific
		keys are requested.
	@param patterns An array of regex(3) pattern strings used to match the keys; NULL
		if no key patterns are requested.
	@result Returns a dictionary containing the key-value pairs of specific keys and the
		key-value pairs of keys that matched the specified patterns;
		NULL if an error was encountered.
		You must release the returned value.
 */
CFDictionaryRef __nullable
SCDynamicStoreCopyMultiple		(
					SCDynamicStoreRef		__nullable	store,
					CFArrayRef			__nullable	keys,
					CFArrayRef			__nullable	patterns
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreSetValue
	@discussion Adds or replaces a value in the dynamic store for
		the specified key.
	@param store The dynamic store session.
	@param key The key you want to set.
	@param value The value to add to or replace in the dynamic store.
	@result Returns TRUE if the key was updated; FALSE if an error was encountered.
 */
Boolean
SCDynamicStoreSetValue			(
					SCDynamicStoreRef		__nullable	store,
					CFStringRef					key,
					CFPropertyListRef				value
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreSetMultiple
	@discussion Updates multiple values in the dynamic store.
	@param store The dynamic store session.
	@param keysToSet A dictionary of key-value pairs you want to set into the dynamic store.
	@param keysToRemove An array of keys you want to remove from the dynamic store.
	@param keysToNotify An array of keys to flag as changed (without changing their values).
	@result Returns TRUE if the dynamic store updates were successful; FALSE if an error was encountered.
 */
Boolean
SCDynamicStoreSetMultiple		(
					SCDynamicStoreRef		__nullable	store,
					CFDictionaryRef			__nullable	keysToSet,
					CFArrayRef			__nullable	keysToRemove,
					CFArrayRef			__nullable	keysToNotify
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreRemoveValue
	@discussion Removes the value of the specified key from the
		dynamic store.
	@param store The dynamic store session.
	@param key The key of the value you want to remove.
	@result Returns TRUE if the key was removed; FALSE if no value was
		located or an error was encountered.
 */
Boolean
SCDynamicStoreRemoveValue		(
					SCDynamicStoreRef		__nullable	store,
					CFStringRef					key
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreNotifyValue
	@discussion Triggers a notification to be delivered for the
		specified key in the dynamic store.
	@param store The dynamic store session.
	@param key The key that should be flagged as changed.  Any dynamic store sessions
		that are monitoring this key will received a notification.  Note that the
		key's value is not updated.
	@result Returns TRUE if the notification was processed; FALSE if an error was encountered.
 */
Boolean
SCDynamicStoreNotifyValue		(
					SCDynamicStoreRef		__nullable	store,
					CFStringRef					key
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreSetNotificationKeys
	@discussion Specifies a set of specific keys and key patterns
		that should be monitored for changes.
	@param store The dynamic store session being watched.
	@param keys An array of keys to be monitored; NULL if no specific keys
		are to be monitored.
	@param patterns An array of regex(3) pattern strings used to match keys to be monitored;
		NULL if no key patterns are to be monitored.
	@result Returns TRUE if the set of notification keys and patterns was successfully
		updated; FALSE if an error was encountered.
 */
Boolean
SCDynamicStoreSetNotificationKeys	(
					SCDynamicStoreRef				store,
					CFArrayRef			__nullable	keys,
					CFArrayRef			__nullable	patterns
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyNotifiedKeys
	@discussion Returns an array of CFString keys representing the
		dynamic store entries that have changed since this
		function was last called.  If possible, your application should
		use the notification functions instead of polling for the list
		of changed keys returned by this function.
	@param store The dynamic store session.
	@result Returns the list of changed keys;
		NULL if an error was encountered.
		You must release the returned value.
 */
CFArrayRef __nullable
SCDynamicStoreCopyNotifiedKeys		(
					SCDynamicStoreRef		store
					)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _SCDYNAMICSTORE_H */
                                                                                                                                                                                      SCDynamicStoreCopyDHCPInfo.h                                                                        0100644 0001750 0001750 00000010375 12567450664 040763  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2001, 2002, 2004, 2005, 2008, 2012, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCDYNAMICSTORECOPYDHCPINFO_H
#define _SCDYNAMICSTORECOPYDHCPINFO_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SCDynamicStore.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCDynamicStoreCopyDHCPInfo
	@discussion The functions of the SCDynamicStoreCopyDHCPInfo API
		provide access to information returned by the DHCP or
		BOOTP server.
 */


__BEGIN_DECLS

/*!
	@function SCDynamicStoreCopyDHCPInfo
	@discussion Copies the DHCP information for the requested serviceID,
		or the primary service if serviceID == NULL.
	@param store An SCDynamicStoreRef representing the dynamic store session
		that should be used for communication with the server.
		If NULL, a temporary session will be used.
	@param serviceID A CFStringRef containing the requested service.
		If NULL, returns information for the primary service.
	@result Returns a dictionary containing DHCP information if successful;
		NULL otherwise.
		Use the DHCPInfoGetOption function to retrieve
		individual options from the returned dictionary.

		A non-NULL return value must be released using CFRelease().
 */
CFDictionaryRef __nullable
SCDynamicStoreCopyDHCPInfo	(SCDynamicStoreRef	__nullable	store,
				 CFStringRef		__nullable	serviceID)	__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function DHCPInfoGetOptionData
	@discussion Returns a non-NULL CFDataRef containing the DHCP
		option data, if present.
	@param info The non-NULL DHCP information dictionary returned by
		calling SCDynamicStoreCopyDHCPInfo.
	@param code The DHCP option code (see RFC 2132) to return
		data for.
	@result Returns a non-NULL CFDataRef containing the option data;
		NULL if the requested option data is not present.

		The return value must NOT be released.
 */
CFDataRef __nullable
DHCPInfoGetOptionData		(CFDictionaryRef	info,
				 UInt8			code)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function DHCPInfoGetLeaseStartTime
	@discussion Returns a CFDateRef corresponding to the lease start time,
		if present.
	@param info The non-NULL DHCP information dictionary returned by
		calling SCDynamicStoreCopyDHCPInfo.
	@result Returns a non-NULL CFDateRef if lease start time information is
		present; NULL if the information is not present or if the
		configuration method is not DHCP.

		The return value must NOT be released.
 */
CFDateRef __nullable
DHCPInfoGetLeaseStartTime	(CFDictionaryRef	info)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);


/*!
	@function DHCPInfoGetLeaseExpirationTime
	@discussion Returns a CFDateRef corresponding to the lease expiration time,
		if present.
	@param info The non-NULL DHCP information dictionary returned by
		calling SCDynamicStoreCopyDHCPInfo.
	@result Returns a non-NULL CFDateRef if the DHCP lease has an expiration;
		NULL if the lease is infinite i.e. has no expiration, or the
		configuration method is not DHCP. An infinite lease can be determined
		by a non-NULL lease start time (see DHCPInfoGetLeaseStartTime above).

		The return value must NOT be released.
*/
CFDateRef __nullable
DHCPInfoGetLeaseExpirationTime	(CFDictionaryRef	info)		__OSX_AVAILABLE_STARTING(__MAC_10_8,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _SCDYNAMICSTORECOPYDHCPINFO_H */
                                                                                                                                                                                                                                                                   SCDynamicStoreCopySpecific.h                                                                        0100644 0001750 0001750 00000015737 12567450664 041165  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000-2005, 2008, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCDYNAMICSTORECOPYSPECIFIC_H
#define _SCDYNAMICSTORECOPYSPECIFIC_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SCDynamicStore.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCDynamicStoreCopySpecific
	@discussion The functions of the SCDynamicStoreCopySpecific API
		allow an application to determine specific configuration
		information about the current system (for example, the
		computer or sharing name, the currently logged-in user, etc.).
 */


__BEGIN_DECLS

/*!
	@function SCDynamicStoreCopyComputerName
	@discussion Gets the current computer name.
	@param store An SCDynamicStoreRef representing the dynamic store
		session that should be used for communication with the server.
		If NULL, a temporary session will be used.
	@param nameEncoding A pointer to memory that, if non-NULL, will be
		filled with the encoding associated with the computer or
		host name.
	@result Returns the current computer name;
		NULL if the name has not been set or if an error was encountered.
		You must release the returned value.
 */
CFStringRef __nullable
SCDynamicStoreCopyComputerName		(
					SCDynamicStoreRef	__nullable	store,
					CFStringEncoding	* __nullable	nameEncoding
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyConsoleUser
	@discussion Gets the name, user ID, and group ID of the currently
		logged-in user.

		Note: this function only provides information about the
		      primary console.  It does not provide any details
		      about console sessions that have fast user switched
		      out or about other consoles.
	@param store An SCDynamicStoreRef representing the dynamic store
		session that should be used for communication with the server.
		If NULL, a temporary session will be used.
	@param uid A pointer to memory that will be filled with the user ID
		of the current console user. If NULL, this value will not
		be returned.
	@param gid A pointer to memory that will be filled with the group ID
		of the current console user. If NULL, this value will not be
		returned.
	@result Returns the user currently logged into the system;
		NULL if no user is logged in or if an error was encountered.
		You must release the returned value.
 */
CFStringRef __nullable
SCDynamicStoreCopyConsoleUser		(
					SCDynamicStoreRef	__nullable	store,
					uid_t			* __nullable	uid,
					gid_t			* __nullable	gid
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyLocalHostName
	@discussion Gets the current local host name.
	@param store An SCDynamicStoreRef representing the dynamic store
		session that should be used for communication with the server.
		If NULL, a temporary session will be used.
	@result Returns the current local host name;
		NULL if the name has not been set or if an error was encountered.
		You must release the returned value.
 */
CFStringRef __nullable
SCDynamicStoreCopyLocalHostName		(
					SCDynamicStoreRef	__nullable	store
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyLocation
	@discussion Gets the current location identifier.
	@param store An SCDynamicStoreRef representing the dynamic store
		session that should be used for communication with the server.
		If NULL, a temporary session will be used.
	@result Returns a string representing the current location identifier;
		NULL if no location identifier has been defined or if an error
		was encountered.
		You must release the returned value.
 */
CFStringRef __nullable
SCDynamicStoreCopyLocation		(
					SCDynamicStoreRef	__nullable	store
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreCopyProxies
	@discussion Gets the current internet proxy settings.
		The returned proxy settings dictionary includes:

		<TABLE BORDER>
		<TR>
			<TH>key</TD>
			<TH>type</TD>
			<TH>description</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesExceptionsList</TD>
			<TD>CFArray[CFString]</TD>
			<TD>Host name patterns which should bypass the proxy</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesHTTPEnable</TD>
			<TD>CFNumber (0 or 1)</TD>
			<TD>Enables/disables the use of an HTTP proxy</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesHTTPProxy</TD>
			<TD>CFString</TD>
			<TD>The proxy host</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesHTTPPort</TD>
			<TD>CFNumber</TD>
			<TD>The proxy port number</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesHTTPSEnable</TD>
			<TD>CFNumber (0 or 1)</TD>
			<TD>Enables/disables the use of an HTTPS proxy</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesHTTPSProxy</TD>
			<TD>CFString</TD>
			<TD>The proxy host</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesHTTPSPort</TD>
			<TD>CFNumber</TD>
			<TD>The proxy port number</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesFTPEnable</TD>
			<TD>CFNumber (0 or 1)</TD>
			<TD>Enables/disables the use of an FTP proxy</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesFTPProxy</TD>
			<TD>CFString</TD>
			<TD>The proxy host</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesFTPPort</TD>
			<TD>CFNumber</TD>
			<TD>The proxy port number</TD>
		</TR>
		<TR>
			<TD>kSCPropNetProxiesFTPPassive</TD>
			<TD>CFNumber (0 or 1)</TD>
			<TD>Enable passive mode operation for use behind connection
			filter-ing firewalls.</TD>
		</TR>
		</TABLE>

		Other key-value pairs are defined in the SCSchemaDefinitions.h
		header file.
	@param store An SCDynamicStoreRef representing the dynamic store
		session that should be used for communication with the server.
		If NULL, a temporary session will be used.
	@result Returns a dictionary containing key-value pairs that represent
		the current internet proxy settings;
		NULL if no proxy settings have been defined or if an error
		was encountered.
		You must release the returned value.
 */
CFDictionaryRef __nullable
SCDynamicStoreCopyProxies		(
					SCDynamicStoreRef	__nullable	store
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _SCDYNAMICSTORECOPYSPECIFIC_H */
                                 SCDynamicStoreKey.h                                                                                 0100644 0001750 0001750 00000024030 12567450664 037317  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000-2002, 2004, 2005, 2008, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCDYNAMICSTOREKEY_H
#define _SCDYNAMICSTOREKEY_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCDynamicStoreKey
	@discussion The SCDynamicStoreKey API provides convenience functions
		that an application can use to create a correctly formatted
		dynamic store key for accessing specific items in the dynamic
		store.  An application can then use the resulting string in
		any function that requires a dynamic store key.
 */


__BEGIN_DECLS

/*
 * SCDynamicStoreKeyCreate
 * - convenience routines that create a CFString key for an item in the store
 */

/*!
	@function SCDynamicStoreKeyCreate
	@discussion Creates a dynamic store key using the given format.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param fmt A CFStringRef describing the format for this key.
	@result Returns a string containing the formatted key.
 */
CFStringRef
SCDynamicStoreKeyCreate				(
						CFAllocatorRef	__nullable	allocator,
						CFStringRef			fmt,
						...
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateNetworkGlobalEntity
	@discussion Creates a dynamic store key that can be used to access
		a specific global (as opposed to a per-service or per-interface)
		network configuration entity.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param domain A string specifying the desired domain, such as the
		requested configuration (kSCDynamicStoreDomainSetup) or the
		actual state (kSCDynamicStoreDomainState).
	@param entity A string containing the specific global entity, such
		as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
	@result Returns a string containing the formatted key.

 */
CFStringRef
SCDynamicStoreKeyCreateNetworkGlobalEntity	(
						CFAllocatorRef	__nullable	allocator,
						CFStringRef			domain,
						CFStringRef			entity
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateNetworkInterface
	@discussion Creates a dynamic store key that can be used to access
		the network interface configuration information stored in
		the dynamic store.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param domain A string specifying the desired domain, such as the
		requested configuration (kSCDynamicStoreDomainSetup) or the
		actual state (kSCDynamicStoreDomainState).
	@result Returns a string containing the formatted key.

 */
CFStringRef
SCDynamicStoreKeyCreateNetworkInterface		(
						CFAllocatorRef	__nullable	allocator,
						CFStringRef			domain
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateNetworkInterfaceEntity
	@discussion Creates a dynamic store key that can be used to access
		the per-interface network configuration information stored in
		the dynamic store.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param domain A string specifying the desired domain, such as the
		requested configuration (kSCDynamicStoreDomainSetup) or the
		actual state (kSCDynamicStoreDomainState).
	@param ifname A string containing the interface name or a regular
		expression pattern.
	@param entity A string containing the specific global entity, such
		as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
	@result Returns a string containing the formatted key.

 */
CFStringRef
SCDynamicStoreKeyCreateNetworkInterfaceEntity	(
						CFAllocatorRef	__nullable	allocator,
						CFStringRef			domain,
						CFStringRef			ifname,
						CFStringRef	__nullable	entity
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateNetworkServiceEntity
	@discussion Creates a dynamic store key that can be used to access
		the per-service network configuration information stored in
		the dynamic store.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@param domain A string specifying the desired domain, such as the
		requested configuration (kSCDynamicStoreDomainSetup) or the
		actual state (kSCDynamicStoreDomainState).
	@param serviceID A string containing the service ID or a regular
		expression pattern.
	@param entity A string containing the specific global entity, such
		as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
	@result Returns a string containing the formatted key.


 */
CFStringRef
SCDynamicStoreKeyCreateNetworkServiceEntity	(
						CFAllocatorRef	__nullable	allocator,
						CFStringRef			domain,
						CFStringRef			serviceID,
						CFStringRef	__nullable	entity
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateComputerName
	@discussion Creates a key that can be used in conjuntion with
		SCDynamicStoreSetNotificationKeys function to receive
		notifications when the current computer name changes.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@result Returns a notification string for the current computer or
		host name.
*/
CFStringRef
SCDynamicStoreKeyCreateComputerName		(
						CFAllocatorRef	__nullable	allocator
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateConsoleUser
	@discussion Creates a key that can be used in conjunction with
		SCDynamicStoreSetNotificationKeys function to receive
		notifications when the current console user changes.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@result Returns a notification string for the current console user.
*/
CFStringRef
SCDynamicStoreKeyCreateConsoleUser		(
						CFAllocatorRef	__nullable	allocator
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateHostNames
	@discussion Creates a key that can be used in conjunction with the
		SCDynamicStoreSetNotificationKeys function to receive
		notifications when the HostNames entity changes.  The
		HostNames entity includes the local host name.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@result Returns a notification string for the HostNames entity.
*/
CFStringRef
SCDynamicStoreKeyCreateHostNames		(
						CFAllocatorRef	__nullable	allocator
						)		__OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateLocation
	@discussion Creates a key that can be used in conjunction with the
		SCDynamicStoreSetNotificationKeys function to receive
		notifications when the location identifier changes.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@result Returns a notification string for the current location
		identifier.
*/
CFStringRef
SCDynamicStoreKeyCreateLocation			(
						CFAllocatorRef	__nullable	allocator
						)		__OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);

/*!
	@function SCDynamicStoreKeyCreateProxies
	@discussion Creates a key that can be used in conjunction with
		the SCDynamicStoreSetNotificationKeys function to receive
		notifications when the current network proxy settings
		(such as HTTP or FTP) are changed.
	@param allocator The CFAllocator that should be used to allocate
		memory for this key.
		This parameter may be NULL in which case the current
		default CFAllocator is used. If this reference is not
		a valid CFAllocator, the behavior is undefined.
	@result Returns a notification string for the current proxy settings.
*/
CFStringRef
SCDynamicStoreKeyCreateProxies			(
						CFAllocatorRef	__nullable	allocator
						)		__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _SCDYNAMICSTOREKEY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        SCNetwork.h                                                                                         0100644 0001750 0001750 00000017233 12567450664 035705  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000, 2001, 2003-2009, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCNETWORK_H
#define _SCNETWORK_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <CoreFoundation/CoreFoundation.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCNetwork
	@discussion The SCNetwork API contains functions an application can
		use to determine remote host reachability and notify the
		system of configuration changes.

		The two SCNetworkCheckReachability functions allow an
		application to determine the status of the system's current
		network configuration and the reachability of a target host
		or address.

		"Reachability" reflects whether a data packet, sent by an
		application into the network stack, can leave the local
		computer.  Note that reachability does <i>not</i> guarantee
		that the data packet will actually be received by the host.
 */

/*!
	@enum SCNetworkConnectionFlags
	@discussion Flags that indicate whether the specified network
		nodename or address is reachable, whether a connection is
		required, and whether some user intervention may be required
		when establishing a connection.

		Note: the SCNetworkConnection flags have been deprecated
		in favor of the newer SCNetworkReachability flags defined
		in SCNetworkReachability.h.
	@constant kSCNetworkFlagsTransientConnection
		This flag indicates that the specified nodename or address can
		be reached via a transient connection, such as PPP.
	@constant kSCNetworkFlagsReachable
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration.
	@constant kSCNetworkFlagsConnectionRequired
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.

		As an example, this status would be returned for a dialup
		connection that was not currently active, but could handle
		network traffic for the target system.
	@constant kSCNetworkFlagsConnectionAutomatic
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.  Any traffic directed
		to the specified name or address will initiate the connection.
	@constant kSCNetworkFlagsInterventionRequired
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.  In addition, some
		form of user intervention will be required to establish this
		connection, such as providing a password, an authentication
		token, etc.

		Note: At the present time, this flag will only be returned
		in the case where you have a dial-on-traffic configuration
		(ConnectionAutomatic), where an attempt to connect has
		already been made, and where some error (e.g. no dial tone,
		no answer, bad password, ...) was encountered during the
		automatic connection attempt.  In this case the PPP controller
		will stop attempting to establish a connection until the user
		has intervened.
	@constant kSCNetworkFlagsIsLocalAddress
		This flag indicates that the specified nodename or address
		is one associated with a network interface on the current
		system.
	@constant kSCNetworkFlagsIsDirect
		This flag indicates that network traffic to the specified
		nodename or address will not go through a gateway, but is
		routed directly to one of the interfaces in the system.
 */
enum {
	kSCNetworkFlagsTransientConnection	= 1<<0,
	kSCNetworkFlagsReachable		= 1<<1,
	kSCNetworkFlagsConnectionRequired	= 1<<2,
	kSCNetworkFlagsConnectionAutomatic	= 1<<3,
	kSCNetworkFlagsInterventionRequired	= 1<<4,
	kSCNetworkFlagsIsLocalAddress		= 1<<16,
	kSCNetworkFlagsIsDirect			= 1<<17,
};
typedef	uint32_t	SCNetworkConnectionFlags;

__BEGIN_DECLS

/*!
	@function SCNetworkCheckReachabilityByAddress
	@discussion Determines if the given network address is
		reachable using the current network configuration.

		Note: this API has been deprecated but you can
		      get equivalent results with :
<pre>
	SCNetworkReachabiltyRef   target;
	SCNetworkReachabiltyFlags flags = 0;
	Boolean                   ok;

	target = SCNetworkReachabilityCreateWithAddress(NULL, address);
	ok = SCNetworkReachabilityGetFlags(target, &flags);
	CFRelease(target);
</pre>
	@param address The network address of the desired host.
	@param addrlen The length, in bytes, of the address.
	@param flags A pointer to memory that will be filled with a
		set of SCNetworkConnectionFlags detailing the reachability
		of the specified address.
	@result Returns TRUE if the network connection flags are valid;
		FALSE if the status could not be determined.
 */
Boolean
SCNetworkCheckReachabilityByAddress	(
					const struct sockaddr		*address,
					socklen_t			addrlen,
					SCNetworkConnectionFlags	*flags
					)				__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);

/*!
	@function SCNetworkCheckReachabilityByName
	@discussion Determines if the given network host or node name is
		reachable using the current network configuration.

		Note: this API has been deprecated but you can
		      get equivalent results with :
<pre>
	SCNetworkReachabilityRef   target;
	SCNetworkReachabilityFlags flags = 0;
	Boolean                   ok;

	target = SCNetworkReachabilityCreateWithName(NULL, name);
	ok = SCNetworkReachabilityGetFlags(target, &flags);
	CFRelease(target);
</pre>
	@param nodename The node name of the desired host. This name would
		be the same as that passed to the gethostbyname(3) or
		getaddrinfo(3) functions.
	@param flags A pointer to memory that will be filled with a
		set of SCNetworkConnectionFlags detailing the reachability
		of the specified node name.
	@result Returns TRUE if the network connection flags are valid;
		FALSE if the status could not be determined.
 */
Boolean
SCNetworkCheckReachabilityByName	(
					const char			*nodename,
					SCNetworkConnectionFlags	*flags
					)				__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceRefreshConfiguration
	@discussion Sends a notification to interested configuration agents
		to have them immediately retry their configuration over a
		particular network interface.

		Note: This function must be invoked by root (uid == 0).
	@param ifName The BSD name of the network interface, such as
		CFSTR("en0").
	@result Returns TRUE if the notification was sent; FALSE otherwise.
	@deprecated in version 10.4. Replaced with SCNetworkInterfaceForceConfigurationRefresh.
 */
Boolean
SCNetworkInterfaceRefreshConfiguration	(
					CFStringRef			ifName
					)				__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SCNETWORK_H */
                                                                                                                                                                                                                                                                                                                                                                     SCNetworkConfiguration.h                                                                            0100644 0001750 0001750 00000137344 12567450664 040443  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2004-2011, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCNETWORKCONFIGURATION_H
#define _SCNETWORKCONFIGURATION_H

#include <Availability.h>
#include <TargetConditionals.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SystemConfiguration.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCNetworkConfiguration
	@discussion The SCNetworkConfiguration API provides access to the
		stored network configuration.  The functions include
		providing access to the network capable devices on the
		system, the network sets, network services, and network
		protocols.

		Note: When using the SCNetworkConfiguraiton APIs you must
		keep in mind that in order for any of your changes to be
		committed to permanent storage a call must be made to the
		SCPreferencesCommitChanges function.
 */


/*!
	@group Interface configuration
 */

#pragma mark -
#pragma mark SCNetworkInterface configuration (typedefs, consts)

/*!
	@typedef SCNetworkInterfaceRef
	@discussion This is the type of a reference to an object that represents
		a network interface.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCNetworkInterface * SCNetworkInterfaceRef;

/*!
	@const kSCNetworkInterfaceType6to4
 */
extern const CFStringRef kSCNetworkInterfaceType6to4						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeBluetooth
 */
extern const CFStringRef kSCNetworkInterfaceTypeBluetooth					__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeBond
 */
extern const CFStringRef kSCNetworkInterfaceTypeBond						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeEthernet
 */
extern const CFStringRef kSCNetworkInterfaceTypeEthernet					__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeFireWire
 */
extern const CFStringRef kSCNetworkInterfaceTypeFireWire					__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeIEEE80211
 */
extern const CFStringRef kSCNetworkInterfaceTypeIEEE80211					__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);	// IEEE 802.11, AirPort

/*!
	@const kSCNetworkInterfaceTypeIPSec
 */
extern const CFStringRef kSCNetworkInterfaceTypeIPSec						__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeIrDA
 */
extern const CFStringRef kSCNetworkInterfaceTypeIrDA						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeL2TP
 */
extern const CFStringRef kSCNetworkInterfaceTypeL2TP						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeModem
 */
extern const CFStringRef kSCNetworkInterfaceTypeModem						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypePPP
 */
extern const CFStringRef kSCNetworkInterfaceTypePPP						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypePPTP
 */
extern const CFStringRef kSCNetworkInterfaceTypePPTP						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeSerial
 */
extern const CFStringRef kSCNetworkInterfaceTypeSerial						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeVLAN
 */
extern const CFStringRef kSCNetworkInterfaceTypeVLAN						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceTypeWWAN
 */
extern const CFStringRef kSCNetworkInterfaceTypeWWAN						__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/* special network interfaces (and types) */

/*!
	@const kSCNetworkInterfaceTypeIPv4
 */
extern const CFStringRef kSCNetworkInterfaceTypeIPv4						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkInterfaceIPv4
	@discussion A network interface that can used for layering other
		interfaces (e.g. 6to4, IPSec, PPTP, L2TP) over an existing
		IPv4 network.
 */
extern const SCNetworkInterfaceRef kSCNetworkInterfaceIPv4					__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@group Interface configuration (Bond)
 */

#pragma mark -

/*!
	@typedef SCBondInterfaceRef
	@discussion This is the type of a reference to an object that represents
		an Ethernet Bond interface.
 */
typedef SCNetworkInterfaceRef SCBondInterfaceRef;

/*!
	@typedef SCBondStatusRef
	@discussion This is the type of a reference to an object that represents
		the status of an Ethernet Bond interface.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCBondStatus *		SCBondStatusRef;

/*!
	@enum Ethernet Bond Aggregation Status (kSCBondStatusDeviceAggregationStatus) codes
	@discussion Returned status codes.
	@constant kSCBondStatusOK		Enabled, active, running, ...
	@constant kSCBondStatusLinkInvalid	The link state was not valid (i.e. down, half-duplex, wrong speed)
	@constant kSCBondStatusNoPartner	The port on the switch that the device is connected doesn't seem to have 802.3ad Link Aggregation enabled
	@constant kSCBondStatusNotInActiveGroup	We're talking to a partner, but the link aggregation group is different from the one that's active
	@constant kSCBondStatusUnknown		Non-specific failure
 */
enum {
	kSCBondStatusOK			= 0,	/* enabled, active, running, ... */
	kSCBondStatusLinkInvalid	= 1,	/* The link state was not valid (i.e. down, half-duplex, wrong speed) */
	kSCBondStatusNoPartner		= 2,	/* The port on the switch that the device is connected doesn't seem to have 802.3ad Link Aggregation enabled */
	kSCBondStatusNotInActiveGroup	= 3,	/* We're talking to a partner, but the link aggregation group is different from the one that's active */
	kSCBondStatusUnknown		= 999	/* Non-specific failure */
};

/*!
	@const kSCBondStatusDeviceAggregationStatus
 */
extern const CFStringRef kSCBondStatusDeviceAggregationStatus	/* CFNumber */			__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCBondStatusDeviceCollecting
 */
extern const CFStringRef kSCBondStatusDeviceCollecting		/* CFNumber (0 or 1) */		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCBondStatusDeviceDistributing
 */
extern const CFStringRef kSCBondStatusDeviceDistributing	/* CFNumber (0 or 1) */		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@group Interface configuration (VLAN)
 */

#pragma mark -

/*!
	@typedef SCVLANInterfaceRef
	@discussion This is the type of a reference to an object that represents
		a Virtual LAN (VLAN) interface.
 */
typedef SCNetworkInterfaceRef SCVLANInterfaceRef;


/*!
	@group Protocol configuration
 */

#pragma mark -
#pragma mark SCNetworkProtocol configuration (typedefs, consts)

/*!
	@typedef SCNetworkProtocolRef
	@discussion This is the type of a reference to an object that represents
		a network protocol.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCNetworkProtocol * SCNetworkProtocolRef;

/* network "protocol" types */

/*!
	@const kSCNetworkProtocolTypeAppleTalk
 */
extern const CFStringRef kSCNetworkProtocolTypeAppleTalk					__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);

/*!
	@const kSCNetworkProtocolTypeDNS
 */
extern const CFStringRef kSCNetworkProtocolTypeDNS						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkProtocolTypeIPv4
 */
extern const CFStringRef kSCNetworkProtocolTypeIPv4						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkProtocolTypeIPv6
 */
extern const CFStringRef kSCNetworkProtocolTypeIPv6						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkProtocolTypeProxies
 */
extern const CFStringRef kSCNetworkProtocolTypeProxies						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@const kSCNetworkProtocolTypeSMB
 */
extern const CFStringRef kSCNetworkProtocolTypeSMB						__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@group Service configuration
 */

#pragma mark -
#pragma mark SCNetworkService configuration (typedefs, consts)

/*!
	@typedef SCNetworkServiceRef
	@discussion This is the type of a reference to an object that represents
		a network service.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCNetworkService * SCNetworkServiceRef;


/*!
	@group Set configuration
 */

#pragma mark -
#pragma mark SCNetworkSet configuration (typedefs, consts)

/*!
	@typedef SCNetworkSetRef
	@discussion This is the type of a reference to an object that represents
		a network set.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCNetworkSet	* SCNetworkSetRef;


__BEGIN_DECLS


/* --------------------------------------------------------------------------------
 * INTERFACES
 * -------------------------------------------------------------------------------- */

/*!
	@group Interface configuration
 */

#pragma mark -
#pragma mark SCNetworkInterface configuration (APIs)

/*!
	@function SCNetworkInterfaceGetTypeID
	@discussion Returns the type identifier of all SCNetworkInterface instances.
 */
CFTypeID
SCNetworkInterfaceGetTypeID			(void)						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceCopyAll
	@discussion Returns all network capable interfaces on the system.
	@result The list of interfaces on the system.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkInterfaceRef's */
SCNetworkInterfaceCopyAll			(void)						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetSupportedInterfaceTypes
	@discussion Identify all of the network interface types (e.g. PPP) that
		can be layered on top of this interface.
	@param interface The network interface.
	@result The list of SCNetworkInterface types supported by the interface;
		NULL if no interface types are supported.
 */
CFArrayRef /* of kSCNetworkInterfaceTypeXXX CFStringRef's */ __nullable
SCNetworkInterfaceGetSupportedInterfaceTypes	(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetSupportedProtocolTypes
	@discussion Identify all of the network protocol types (e.g. IPv4, IPv6) that
		can be layered on top of this interface.
	@param interface The network interface.
	@result The list of SCNetworkProtocol types supported by the interface;
		NULL if no protocol types are supported.
 */
CFArrayRef /* of kSCNetworkProtocolTypeXXX CFStringRef's */ __nullable
SCNetworkInterfaceGetSupportedProtocolTypes	(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceCreateWithInterface
	@discussion Create a new network interface layered on top of another.  For
		example, this function would be used to create a "PPP" interface
		on top of a "modem".
	@param interface The network interface.
	@param interfaceType The type of SCNetworkInterface to be layered on
		top of the provided interface.
	@result A reference to the new SCNetworkInterface.
		You must release the returned value.
 */
SCNetworkInterfaceRef __nullable
SCNetworkInterfaceCreateWithInterface		(SCNetworkInterfaceRef		interface,
						 CFStringRef			interfaceType)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetBSDName
	@discussion Returns the BSD interface (en0) or device name (modem)
		for the interface.
	@param interface The network interface.
	@result The BSD name associated with the interface (e.g. "en0");
		NULL if no BSD name is available.
 */
CFStringRef __nullable
SCNetworkInterfaceGetBSDName			(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetConfiguration
	@discussion Returns the configuration settings associated with a interface.
	@param interface The network interface.
	@result The configuration settings associated with the interface;
		NULL if no configuration settings are associated with the interface
		or an error was encountered.
 */
CFDictionaryRef __nullable
SCNetworkInterfaceGetConfiguration		(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetExtendedConfiguration
	@discussion Returns the configuration settings associated with a interface.
	@param interface The network interface.
	@param extendedType A string representing the type of extended information (e.g. EAPOL).
	@result The configuration settings associated with the interface;
		NULL if no configuration settings are associated with the interface
		or an error was encountered.
 */
CFDictionaryRef __nullable
SCNetworkInterfaceGetExtendedConfiguration	(SCNetworkInterfaceRef		interface,
						 CFStringRef			extendedType)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetHardwareAddressString
	@discussion Returns a displayable link layer address for the interface.
	@param interface The network interface.
	@result A string representing the hardware (MAC) address for the interface.
 */
CFStringRef __nullable
SCNetworkInterfaceGetHardwareAddressString	(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetInterface
	@discussion For layered network interfaces, return the underlying interface.
	@param interface The network interface.
	@result The underlying network interface;
		NULL if this is a leaf interface.
 */
SCNetworkInterfaceRef __nullable
SCNetworkInterfaceGetInterface			(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetInterfaceType
	@discussion Returns the associated network interface type.
	@param interface The network interface.
	@result The interface type.
 */
CFStringRef __nullable
SCNetworkInterfaceGetInterfaceType		(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceGetLocalizedDisplayName
	@discussion Returns the localized name (e.g. "Ethernet", "FireWire") for
		the interface.
	@param interface The network interface.
	@result A localized, display name for the interface;
		NULL if no name is available.
 */
CFStringRef __nullable
SCNetworkInterfaceGetLocalizedDisplayName	(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceSetConfiguration
	@discussion Stores the configuration settings for the interface.
	@param interface The network interface.
	@param config The configuration settings to associate with this interface.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCNetworkInterfaceSetConfiguration		(SCNetworkInterfaceRef		interface,
						 CFDictionaryRef		config)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceSetExtendedConfiguration
	@discussion Stores the configuration settings for the interface.
	@param interface The network interface.
	@param config The configuration settings to associate with this interface.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCNetworkInterfaceSetExtendedConfiguration	(SCNetworkInterfaceRef		interface,
						 CFStringRef			extendedType,
						 CFDictionaryRef		config)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

#pragma mark -

/*!
	@function SCNetworkInterfaceCopyMediaOptions
	@discussion For the specified network interface, returns information
		about the currently requested media options, the active media
		options, and the media options which are available.
	@param interface The desired network interface.
	@param current A pointer to memory that will be filled with a CFDictionaryRef
		representing the currently requested media options (subtype, options).
		If NULL, the current options will not be returned.
	@param active A pointer to memory that will be filled with a CFDictionaryRef
		representing the active media options (subtype, options).
		If NULL, the active options will not be returned.
	@param available A pointer to memory that will be filled with a CFArrayRef
		representing the possible media options (subtype, options).
		If NULL, the available options will not be returned.
	@param filter A boolean indicating whether the available options should be
		filtered to exclude those options which would not normally be
		requested by a user/admin (e.g. hw-loopback).
	@result TRUE if requested information has been returned.
 */
Boolean
SCNetworkInterfaceCopyMediaOptions		(SCNetworkInterfaceRef						interface,
						 CFDictionaryRef		__nullable	* __nullable	current,
						 CFDictionaryRef		__nullable	* __nullable	active,
						 CFArrayRef			__nullable	* __nullable	available,
						 Boolean					filter)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceCopyMediaSubTypes
	@discussion For the provided interface configuration options, return a list
		of available media subtypes.
	@param available The available options as returned by the
		SCNetworkInterfaceCopyMediaOptions function.
	@result An array of available media subtypes CFString's (e.g. 10BaseT/UTP,
		100baseTX, etc).  NULL if no subtypes are available.
 */
CFArrayRef __nullable
SCNetworkInterfaceCopyMediaSubTypes		(CFArrayRef			available)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceCopyMediaSubTypeOptions
	@discussion For the provided interface configuration options and specific
		subtype, return a list of available media options.
	@param available The available options as returned by the
		SCNetworkInterfaceCopyMediaOptions function.
	@param subType The subtype
	@result An array of available media options.  Each of the available options
		is returned as an array of CFString's (e.g. <half-duplex>,
		<full-duplex,flow-control>).  NULL if no options are available.
 */
CFArrayRef __nullable
SCNetworkInterfaceCopyMediaSubTypeOptions	(CFArrayRef			available,
						 CFStringRef			subType)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceCopyMTU
	@discussion For the specified network interface, returns information
		about the currently MTU setting and the range of allowable
		values.
	@param interface The desired network interface.
	@param mtu_cur A pointer to memory that will be filled with the current
		MTU setting for the interface.
	@param mtu_min A pointer to memory that will be filled with the minimum
		MTU setting for the interface.  If negative, the minimum setting
		could not be determined.
	@param mtu_max A pointer to memory that will be filled with the maximum
		MTU setting for the interface.  If negative, the maximum setting
		could not be determined.
	@result TRUE if requested information has been returned.
 */
Boolean
SCNetworkInterfaceCopyMTU			(SCNetworkInterfaceRef				interface,
						 int				* __nullable	mtu_cur,
						 int				* __nullable	mtu_min,
						 int				* __nullable	mtu_max)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceSetMediaOptions
	@discussion For the specified network interface, sets the requested
		media subtype and options.
	@param interface The desired network interface.
	@param subtype The desired media subtype (e.g. "autoselect", "100baseTX", ...).
	@param options The desired media options (e.g. "half-duplex", "full-duplex", ...).
	@result TRUE if the configuration was updated; FALSE if an error was encountered.
 */
Boolean
SCNetworkInterfaceSetMediaOptions		(SCNetworkInterfaceRef		interface,
						 CFStringRef			subtype,
						 CFArrayRef			options)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceSetMTU
	@discussion For the specified network interface, sets the
		requested MTU setting.
	@param interface The desired network interface.
	@param mtu The desired MTU setting for the interface.
	@result TRUE if the configuration was updated; FALSE if an error was encountered.
 */
Boolean
SCNetworkInterfaceSetMTU			(SCNetworkInterfaceRef		interface,
						 int				mtu)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkInterfaceForceConfigurationRefresh
	@discussion Sends a notification to interested network configuration
		agents to immediately retry their configuration. For example,
		calling this function will cause the DHCP client to contact
		the DHCP server immediately rather than waiting until its
		timeout has expired.  The utility of this function is to
		allow the caller to give a hint to the system that the
		network infrastructure or configuration has changed.

		Note: This function requires root (euid==0) privilege or,
		alternatively, you may pass an SCNetworkInterface which
		is derived from a sequence of calls to :

			SCPreferencesCreateWithAuthorization
			SCNetworkSetCopy...
			SCNetworkServiceGetInterface
	@param interface The desired network interface.
	@result Returns TRUE if the notification was sent; FALSE otherwise.
 */
Boolean
SCNetworkInterfaceForceConfigurationRefresh	(SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@group Interface configuration (Bond)
 */

#pragma mark -
#pragma mark SCBondInterface configuration (APIs)

/*!
	@function SCBondInterfaceCopyAll
	@discussion Returns all Ethernet Bond interfaces on the system.
	@param prefs The "preferences" session.
	@result The list of Ethernet Bond interfaces on the system.
		You must release the returned value.
 */
CFArrayRef /* of SCBondInterfaceRef's */
SCBondInterfaceCopyAll				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceCopyAvailableMemberInterfaces
	@discussion Returns all network capable devices on the system
		that can be added to an Ethernet Bond interface.
	@param prefs The "preferences" session.
	@result The list of interfaces.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkInterfaceRef's */
SCBondInterfaceCopyAvailableMemberInterfaces	(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceCreate
	@discussion Create a new SCBondInterface interface.
	@param prefs The "preferences" session.
	@result A reference to the new SCBondInterface.
		You must release the returned value.
 */
SCBondInterfaceRef __nullable
SCBondInterfaceCreate				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceRemove
	@discussion Removes the SCBondInterface from the configuration.
	@param bond The SCBondInterface interface.
	@result TRUE if the interface was removed; FALSE if an error was encountered.
 */
Boolean
SCBondInterfaceRemove				(SCBondInterfaceRef		bond)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceGetMemberInterfaces
	@discussion Returns the member interfaces for the specified Ethernet Bond interface.
	@param bond The SCBondInterface interface.
	@result The list of interfaces.
 */
CFArrayRef /* of SCNetworkInterfaceRef's */ __nullable
SCBondInterfaceGetMemberInterfaces		(SCBondInterfaceRef		bond)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceGetOptions
	@discussion Returns the configuration settings associated with a Ethernet Bond interface.
	@param bond The SCBondInterface interface.
	@result The configuration settings associated with the Ethernet Bond interface;
		NULL if no changes to the default configuration have been saved.
 */
CFDictionaryRef __nullable
SCBondInterfaceGetOptions			(SCBondInterfaceRef		bond)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceSetMemberInterfaces
	@discussion Sets the member interfaces for the specified Ethernet Bond interface.
	@param bond The SCBondInterface interface.
	@param members The desired member interfaces.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCBondInterfaceSetMemberInterfaces		(SCBondInterfaceRef		bond,
						 CFArrayRef			members) /* of SCNetworkInterfaceRef's */
												__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceSetLocalizedDisplayName
	@discussion Sets the localized display name for the specified Ethernet Bond interface.
	@param bond The SCBondInterface interface.
	@param newName The new display name.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCBondInterfaceSetLocalizedDisplayName		(SCBondInterfaceRef		bond,
						 CFStringRef			newName)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondInterfaceSetOptions
	@discussion Sets the configuration settings for the specified Ethernet Bond interface.
	@param bond The SCBondInterface interface.
	@param newOptions The new configuration settings.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCBondInterfaceSetOptions			(SCBondInterfaceRef		bond,
						 CFDictionaryRef		newOptions)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

#pragma mark -

/*!
	@function SCBondInterfaceCopyStatus
	@discussion Returns the status of the specified Ethernet Bond interface.
	@param bond The SCBondInterface interface.
	@result The status associated with the interface.
		You must release the returned value.
 */
SCBondStatusRef __nullable
SCBondInterfaceCopyStatus			(SCBondInterfaceRef	bond)			__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondStatusGetTypeID
	@discussion Returns the type identifier of all SCBondStatus instances.
 */
CFTypeID
SCBondStatusGetTypeID				(void)						__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondStatusGetMemberInterfaces
	@discussion Returns the member interfaces that are represented with the
		Ethernet Bond interface.
	@param bondStatus The Ethernet Bond status.
	@result The list of interfaces.
 */
CFArrayRef __nullable /* of SCNetworkInterfaceRef's */
SCBondStatusGetMemberInterfaces			(SCBondStatusRef	bondStatus)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCBondStatusGetInterfaceStatus
	@discussion Returns the status of a specific member interface of an
		Ethernet Bond or the status of the bond as a whole.
	@param bondStatus The Ethernet Bond status.
	@param interface The specific member interface; NULL if you want the
		status of the Ethernet Bond.
	@result The interface status.

	Note: at present, no information about the status of the Ethernet
	      Bond is returned.  As long as one member interface is active
	      then the bond should be operational.
 */
CFDictionaryRef __nullable
SCBondStatusGetInterfaceStatus			(SCBondStatusRef			bondStatus,
						 SCNetworkInterfaceRef	__nullable	interface)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@group Interface configuration (VLAN)
 */

#pragma mark -
#pragma mark SCVLANInterface configuration (APIs)

/*!
	@function SCVLANInterfaceCopyAll
	@discussion Returns all VLAN interfaces on the system.
	@result The list of VLAN interfaces on the system.
		You must release the returned value.
 */
CFArrayRef /* of SCVLANInterfaceRef's */
SCVLANInterfaceCopyAll				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceCopyAvailablePhysicalInterfaces
	@discussion Returns the network capable devices on the system
		that can be associated with a VLAN interface.
	@result The list of interfaces.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkInterfaceRef's */
SCVLANInterfaceCopyAvailablePhysicalInterfaces	(void)						__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceCreate
	@discussion Create a new SCVLANInterface interface.
	@param prefs The "preferences" session.
	@param physical The physical interface to associate with the VLAN.
	@param tag The tag to associate with the VLAN.
	@result A reference to the new SCVLANInterface.
		You must release the returned value.

	Note: the tag must be in the range (1 <= tag <= 4094)
 */
SCVLANInterfaceRef __nullable
SCVLANInterfaceCreate				(SCPreferencesRef		prefs,
						 SCNetworkInterfaceRef		physical,
						 CFNumberRef			tag)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceRemove
	@discussion Removes the SCVLANInterface from the configuration.
	@param vlan The SCVLANInterface interface.
	@result TRUE if the interface was removed; FALSE if an error was encountered.
 */
Boolean
SCVLANInterfaceRemove				(SCVLANInterfaceRef		vlan)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceGetPhysicalInterface
	@discussion Returns the physical interface for the specified VLAN interface.
	@param vlan The SCVLANInterface interface.
	@result The list of interfaces.
 */
SCNetworkInterfaceRef __nullable
SCVLANInterfaceGetPhysicalInterface		(SCVLANInterfaceRef		vlan)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceGetTag
	@discussion Returns the tag for the specified VLAN interface.
	@param vlan The SCVLANInterface interface.
	@result The tag.
 */
CFNumberRef __nullable
SCVLANInterfaceGetTag				(SCVLANInterfaceRef		vlan)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceGetOptions
	@discussion Returns the configuration settings associated with the VLAN interface.
	@param vlan The SCVLANInterface interface.
	@result The configuration settings associated with the VLAN interface;
		NULL if no changes to the default configuration have been saved.
 */
CFDictionaryRef __nullable
SCVLANInterfaceGetOptions			(SCVLANInterfaceRef		vlan)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceSetPhysicalInterfaceAndTag
	@discussion Updates the specified VLAN interface.
	@param vlan The SCVLANInterface interface.
	@param physical The physical interface to associate with the VLAN.
	@param tag The tag to associate with the VLAN.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.

	Note: the tag must be in the range (1 <= tag <= 4094)
 */
Boolean
SCVLANInterfaceSetPhysicalInterfaceAndTag	(SCVLANInterfaceRef		vlan,
						 SCNetworkInterfaceRef		physical,
						 CFNumberRef			tag)		__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceSetLocalizedDisplayName
	@discussion Sets the localized display name for the specified VLAN interface.
	@param vlan The SCVLANInterface interface.
	@param newName The new display name.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCVLANInterfaceSetLocalizedDisplayName		(SCVLANInterfaceRef		vlan,
						 CFStringRef			newName)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCVLANInterfaceSetOptions
	@discussion Sets the configuration settings for the specified VLAN interface.
	@param vlan The SCVLANInterface interface.
	@param newOptions The new configuration settings.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCVLANInterfaceSetOptions			(SCVLANInterfaceRef		vlan,
						 CFDictionaryRef		newOptions)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);


/* --------------------------------------------------------------------------------
 * PROTOCOLS
 * -------------------------------------------------------------------------------- */

/*!
	@group Protocol configuration
 */

#pragma mark -
#pragma mark SCNetworkProtocol configuration (APIs)

/*!
	@function SCNetworkProtocolGetTypeID
	@discussion Returns the type identifier of all SCNetworkProtocol instances.
 */
CFTypeID
SCNetworkProtocolGetTypeID			(void)						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkProtocolGetConfiguration
	@discussion Returns the configuration settings associated with the protocol.
	@param protocol The network protocol.
	@result The configuration settings associated with the protocol;
		NULL if no configuration settings are associated with the protocol
		or an error was encountered.
 */
CFDictionaryRef __nullable
SCNetworkProtocolGetConfiguration		(SCNetworkProtocolRef		protocol)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkProtocolGetEnabled
	@discussion Returns whether this protocol has been enabled.
	@param protocol The network protocol.
	@result TRUE if the protocol is enabled.
 */
Boolean
SCNetworkProtocolGetEnabled			(SCNetworkProtocolRef		protocol)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkProtocolGetProtocolType
	@discussion Returns the associated network protocol type.
	@param protocol The network protocol.
	@result The protocol type.
 */
CFStringRef __nullable
SCNetworkProtocolGetProtocolType		(SCNetworkProtocolRef		protocol)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkProtocolSetConfiguration
	@discussion Stores the configuration settings for the protocol.
	@param protocol The network protocol.
	@param config The configuration settings to associate with this protocol.
	@result TRUE if the configuration was stored; FALSE if an error was encountered.
 */
Boolean
SCNetworkProtocolSetConfiguration		(SCNetworkProtocolRef		protocol,
						 CFDictionaryRef		config)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkProtocolSetEnabled
	@discussion Enables or disables the protocol.
	@param protocol The network protocol.
	@param enabled TRUE if the protocol should be enabled.
	@result TRUE if the enabled status was saved; FALSE if an error was encountered.
 */
Boolean
SCNetworkProtocolSetEnabled			(SCNetworkProtocolRef		protocol,
						 Boolean			enabled)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/* --------------------------------------------------------------------------------
 * SERVICES
 * -------------------------------------------------------------------------------- */

/*!
	@group Service configuration
 */

#pragma mark -
#pragma mark SCNetworkService configuration (APIs)

/*!
	@function SCNetworkServiceGetTypeID
	@discussion Returns the type identifier of all SCNetworkService instances.
 */
CFTypeID
SCNetworkServiceGetTypeID			(void)						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceAddProtocolType
	@discussion Adds a network protocol of the specified type to the
		service.  The protocal configuration is set to default values
		that are appropriate for the interface associated with the
		service.
	@param service The network service.
	@param protocolType The type of SCNetworkProtocol to be added to the service.
	@result TRUE if the protocol was added to the service; FALSE if the
		protocol was already present or an error was encountered.
 */
Boolean
SCNetworkServiceAddProtocolType			(SCNetworkServiceRef		service,
						 CFStringRef			protocolType)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceCopyAll
	@discussion Returns all available network services for the specified preferences.
	@param prefs The "preferences" session.
	@result The list of SCNetworkService services associated with the preferences.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkServiceRef's */ __nullable
SCNetworkServiceCopyAll				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceCopyProtocols
	@discussion Returns all network protocols associated with the service.
	@param service The network service.
	@result The list of SCNetworkProtocol protocols associated with the service.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkProtocolRef's */ __nullable
SCNetworkServiceCopyProtocols			(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceCreate
	@discussion Create a new network service for the specified interface in the
		configuration.
	@param prefs The "preferences" session.
	@result A reference to the new SCNetworkService.
		You must release the returned value.
 */
SCNetworkServiceRef __nullable
SCNetworkServiceCreate				(SCPreferencesRef		prefs,
						 SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceCopy
	@discussion Returns the network service with the specified identifier.
	@param prefs The "preferences" session.
	@param serviceID The unique identifier for the service.
	@result A reference to the SCNetworkService from the associated preferences;
		NULL if the serviceID does not exist in the preferences or if an
		error was encountered.
		You must release the returned value.
 */
SCNetworkServiceRef __nullable
SCNetworkServiceCopy				(SCPreferencesRef		prefs,
						 CFStringRef			serviceID)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceEstablishDefaultConfiguration
	@discussion Establishes the "default" configuration for a network
		service.  This configuration includes the addition of
		network protocols for the service (with "default"
		configuration options).
	@param service The network service.
	@result TRUE if the configuration was updated; FALSE if an error was encountered.
*/
Boolean
SCNetworkServiceEstablishDefaultConfiguration	(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkServiceGetEnabled
	@discussion Returns whether this service has been enabled.
	@param service The network service.
	@result TRUE if the service is enabled.
 */
Boolean
SCNetworkServiceGetEnabled			(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceGetInterface
	@discussion Returns the network interface associated with the service.
	@param service The network service.
	@result A reference to the SCNetworkInterface associated with the service;
		NULL if an error was encountered.
 */
SCNetworkInterfaceRef __nullable
SCNetworkServiceGetInterface			(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceGetName
	@discussion Returns the [user specified] name associated with the service.
	@param service The network service.
	@result The [user specified] name.
 */
CFStringRef __nullable
SCNetworkServiceGetName				(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceCopyProtocol
	@discussion Returns the network protocol of the specified type for
		the service.
	@param service The network service.
	@result A reference to the SCNetworkProtocol associated with the service;
		NULL if this protocol has not been added or if an error was encountered.
		You must release the returned value.
 */
SCNetworkProtocolRef __nullable
SCNetworkServiceCopyProtocol			(SCNetworkServiceRef		service,
						 CFStringRef			protocolType)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceGetServiceID
	@discussion Returns the identifier for the service.
	@param service The network service.
	@result The service identifier.
 */
CFStringRef __nullable
SCNetworkServiceGetServiceID			(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceRemove
	@discussion Removes the network service from the configuration.
	@param service The network service.
	@result TRUE if the service was removed; FALSE if an error was encountered.
 */
Boolean
SCNetworkServiceRemove				(SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceRemoveProtocolType
	@discussion Removes the network protocol of the specified type from the service.
	@param service The network service.
	@param protocolType The type of SCNetworkProtocol to be removed from the service.
	@result TRUE if the protocol was removed to the service; FALSE if the
		protocol was not configured or an error was encountered.
 */
Boolean
SCNetworkServiceRemoveProtocolType		(SCNetworkServiceRef		service,
						 CFStringRef			protocolType)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceSetEnabled
	@discussion Enables or disables the service.
	@param service The network service.
	@param enabled TRUE if the service should be enabled.
	@result TRUE if the enabled status was saved; FALSE if an error was encountered.
 */
Boolean
SCNetworkServiceSetEnabled			(SCNetworkServiceRef		service,
						 Boolean			enabled)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkServiceSetName
	@discussion Stores the [user specified] name for the service.
	@param service The network service.
	@param name The [user defined] name to associate with the service.
	@result TRUE if the name was saved; FALSE if an error was encountered.

	Note: although not technically required, the [user specified] names
	for all services within any given set should be unique.  As such, an
	error will be returned if you attemp to name two services with the
	same string.
 */
Boolean
SCNetworkServiceSetName				(SCNetworkServiceRef		service,
						 CFStringRef			name)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);


/* --------------------------------------------------------------------------------
 * SETS
 * -------------------------------------------------------------------------------- */

/*!
	@group Set configuration
 */

#pragma mark -
#pragma mark SCNetworkSet configuration (APIs)

/*!
	@function SCNetworkSetGetTypeID
	@discussion Returns the type identifier of all SCNetworkSet instances.
 */
CFTypeID
SCNetworkSetGetTypeID				(void)						__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetAddService
	@discussion Adds the network service to the set.
	@param set The network set.
	@param service The service to be added.
	@result TRUE if the service was added to the set; FALSE if the
		service was already present or an error was encountered.

	Note: prior to Mac OS X 10.5, the Network Preferences UI
	did not support having a single service being a member of
	more than one set.  An error will be returned if you attempt
	to add a service to more than one set on a pre-10.5 system.
 */
Boolean
SCNetworkSetAddService				(SCNetworkSetRef		set,
						 SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetContainsInterface
	@discussion Checks if an interface is represented by at least one
		network service in the specified set.
	@param set The network set.
	@param interface The network interface.
	@result TRUE if the interface is represented in the set; FALSE if not.
 */
Boolean
SCNetworkSetContainsInterface			(SCNetworkSetRef		set,
						 SCNetworkInterfaceRef		interface)	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCNetworkSetCopyAll
	@discussion Returns all available sets for the specified preferences.
	@param prefs The "preferences" session.
	@result The list of SCNetworkSet sets associated with the preferences.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkSetRef's */ __nullable
SCNetworkSetCopyAll				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetCopyCurrent
	@discussion Returns the "current" set.
	@param prefs The "preferences" session.
	@result The current set; NULL if no current set has been defined.
 */
SCNetworkSetRef __nullable
SCNetworkSetCopyCurrent				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetCopyServices
	@discussion Returns all network services associated with the set.
	@param set The network set.
	@result The list of SCNetworkService services associated with the set.
		You must release the returned value.
 */
CFArrayRef /* of SCNetworkServiceRef's */ __nullable
SCNetworkSetCopyServices			(SCNetworkSetRef		set)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetCreate
	@discussion Create a new set in the configuration.
	@param prefs The "preferences" session.
	@result A reference to the new SCNetworkSet.
		You must release the returned value.
 */
SCNetworkSetRef __nullable
SCNetworkSetCreate				(SCPreferencesRef		prefs)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetCopy
	@discussion Returns the set with the specified identifier.
	@param prefs The "preferences" session.
	@param setID The unique identifier for the set.
	@result A reference to the SCNetworkSet from the associated preferences;
		NULL if the setID does not exist in the preferences or if an
		error was encountered.
		You must release the returned value.
 */
SCNetworkSetRef __nullable
SCNetworkSetCopy				(SCPreferencesRef		prefs,
						 CFStringRef			setID)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetGetName
	@discussion Returns the [user specified] name associated with the set.
	@param set The network set.
	@result The [user specified] name.
 */
CFStringRef __nullable
SCNetworkSetGetName				(SCNetworkSetRef		set)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetGetSetID
	@discussion Returns the identifier for the set.
	@param set The network set.
	@result The set identifier.
 */
CFStringRef __nullable
SCNetworkSetGetSetID				(SCNetworkSetRef		set)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetGetServiceOrder
	@discussion Returns the [user specified] ordering of network services
		within the set.
	@param set The network set.
	@result The ordered list of CFStringRef service identifiers associated
		with the set;
		NULL if no service order has been specified or if an error
		was encountered.
 */
CFArrayRef /* of serviceID CFStringRef's */ __nullable
SCNetworkSetGetServiceOrder			(SCNetworkSetRef		set)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetRemove
	@discussion Removes the set from the configuration.
	@param set The network set.
	@result TRUE if the set was removed; FALSE if an error was encountered.
 */
Boolean
SCNetworkSetRemove				(SCNetworkSetRef		set)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetRemoveService
	@discussion Removes the network service from the set.
	@param set The network set.
	@param service The service to be removed.
	@result TRUE if the service was removed from the set; FALSE if the
		service was not already present or an error was encountered.
 */
Boolean
SCNetworkSetRemoveService			(SCNetworkSetRef		set,
						 SCNetworkServiceRef		service)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetSetCurrent
	@discussion Specifies the set that should be the "current" set.
	@param set The network set.
	@result TRUE if the current set was updated;
		FALSE if an error was encountered.
 */
Boolean
SCNetworkSetSetCurrent				(SCNetworkSetRef		set)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetSetName
	@discussion Stores the [user specified] name for the set.
	@param set The network set.
	@param name The [user defined] name to associate with the set.
	@result TRUE if the name was saved; FALSE if an error was encountered.

	Note: although not technically required, the [user specified] names
	for all set should be unique.  As such, an error will be returned if
	you attemp to name two sets with the same string.
 */
Boolean
SCNetworkSetSetName				(SCNetworkSetRef		set,
						 CFStringRef			name)		__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCNetworkSetSetServiceOrder
	@discussion Stores the [user specified] ordering of network services for the set.
	@param set The network set.
	@param newOrder The ordered list of CFStringRef service identifiers for the set.
	@result TRUE if the new service order was saved; FALSE if an error was encountered.
 */
Boolean
SCNetworkSetSetServiceOrder			(SCNetworkSetRef		set,
						 CFArrayRef			newOrder)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);	/* serviceID CFStringRef's */


__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif	/* _SCNETWORKCONFIGURATION_H */
                                                                                                                                                                                                                                                                                            SCNetworkConnection.h                                                                               0100644 0001750 0001750 00000052112 12567450664 037720  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2003-2006, 2008-2010, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCNETWORKCONNECTION_H
#define _SCNETWORKCONNECTION_H

#include <Availability.h>
#include <TargetConditionals.h>
#include <sys/cdefs.h>
#include <dispatch/dispatch.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SystemConfiguration.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCNetworkConnection
	@discussion The SCNetworkConnection API contains functions that allow
		an application to control connection-oriented services defined
		in the system and get connection-status information.

		The functions in the SCNetworkConnection API allow you to
		control and get information about existing services only.
		If you need to create, change, or remove services, you
		should use the SCNetworkConfiguration API instead.

		Note: Currently, only PPP services can be controlled.
 */


/*!
	@typedef SCNetworkConnectionRef
	@discussion This is the handle to manage a connection-oriented service.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCNetworkConnection * SCNetworkConnectionRef;


/*!
	@typedef SCNetworkConnectionContext
	@discussion Structure containing user-specified data and callbacks
		for a SCNetworkConnection.
	@field version The version number of the structure type being passed
		in as a parameter to the SCNetworkConnectionCreateWithServiceID
		function.  This structure is version 0.
	@field info A C pointer to a user-specified block of data.
	@field retain The callback used to add a retain for the info field.
		If this parameter is not a pointer to a function of the correct
		prototype, the behavior is undefined.  The value may be NULL.
	@field release The calllback used to remove a retain previously added
		for the info field.  If this parameter is not a pointer to a
		function of the correct prototype, the behavior is undefined.
		The value may be NULL.
	@field copyDescription The callback used to provide a description of
		the info field.
 */
typedef struct {
	CFIndex         version;
	void *          __nullable info;
	const void      * __nonnull (* __nullable retain)(const void *info);
	void            (* __nullable release)(const void *info);
	CFStringRef     __nonnull (* __nullable copyDescription)(const void *info);
} SCNetworkConnectionContext;



/*!
	@enum SCNetworkConnectionStatus
	@discussion Status of the network connection.
		This status is intended to be generic and high level.
		An extended status, specific to the type of network
		connection is also available for applications that
		need additonal information.
	@constant kSCNetworkConnectionInvalid
		The network connection refers to an invalid service.
	@constant kSCNetworkConnectionDisconnected
		The network connection is disconnected.
	@constant kSCNetworkConnectionConnecting
		The network connection is connecting.
	@constant kSCNetworkConnectionConnected
		The network connection is connected.
	@constant kSCNetworkConnectionDisconnecting
		The network connection is disconnecting.
 */
typedef CF_ENUM(int32_t, SCNetworkConnectionStatus) {
	kSCNetworkConnectionInvalid		=  -1,
	kSCNetworkConnectionDisconnected	=  0,
	kSCNetworkConnectionConnecting		=  1,
	kSCNetworkConnectionConnected		=  2,
	kSCNetworkConnectionDisconnecting	=  3
};


/*!
	@enum SCNetworkConnectionPPPStatus
	@discussion PPP-specific status of the network connection.
		This status is returned as part of the extended information
		for a PPP service.
		Note: additional status might be returned in the future.
		Your application should be prepared to receive an unknown value.
	@constant kSCNetworkConnectionPPPDisconnected
		PPP is disconnected.
	@constant kSCNetworkConnectionPPPInitializing
		PPP is initializing.
	@constant kSCNetworkConnectionPPPConnectingLink
		PPP is connecting the lower connection layer (for example,
		the modem is dialing out).
	@constant kSCNetworkConnectionPPPDialOnTraffic
		PPP is waiting for networking traffic to automatically
		establish the connection.
	@constant kSCNetworkConnectionPPPNegotiatingLink
		The PPP lower layer is connected and PPP is negotiating the
		link layer (LCP protocol).
	@constant kSCNetworkConnectionPPPAuthenticating
		PPP is authenticating to the server (PAP, CHAP, MS-CHAP or
		EAP protocols).
	@constant kSCNetworkConnectionPPPWaitingForCallBack
		PPP is waiting for the server to call back.
	@constant kSCNetworkConnectionPPPNegotiatingNetwork
		PPP is now authenticated and negotiating the networking
		layer (IPCP or IPv6CP protocols)
	@constant kSCNetworkConnectionPPPConnected
		PPP is now fully connected for at least one networking layer.
		Additional networking protocol might still be negotiating.
	@constant kSCNetworkConnectionPPPTerminating
		PPP networking and link protocols are terminating.
	@constant kSCNetworkConnectionPPPDisconnectingLink
		PPP is disconnecting the lower level (for example, the modem
		is hanging up).
	@constant kSCNetworkConnectionPPPHoldingLinkOff
		PPP is disconnected and maintaining the link temporarily off.
	@constant kSCNetworkConnectionPPPSuspended
		PPP is suspended as a result of the suspend command (for
		example, when a V.92 Modem is On Hold).
	@constant kSCNetworkConnectionPPPWaitingForRedial
		PPP has found a busy server and is waiting for redial.
 */
typedef CF_ENUM(int32_t, SCNetworkConnectionPPPStatus) {
	kSCNetworkConnectionPPPDisconnected		=  0,
	kSCNetworkConnectionPPPInitializing		=  1,
	kSCNetworkConnectionPPPConnectingLink		=  2,
	kSCNetworkConnectionPPPDialOnTraffic		=  3,
	kSCNetworkConnectionPPPNegotiatingLink		=  4,
	kSCNetworkConnectionPPPAuthenticating		=  5,
	kSCNetworkConnectionPPPWaitingForCallBack	=  6,
	kSCNetworkConnectionPPPNegotiatingNetwork	=  7,
	kSCNetworkConnectionPPPConnected		=  8,
	kSCNetworkConnectionPPPTerminating		=  9,
	kSCNetworkConnectionPPPDisconnectingLink	=  10,
	kSCNetworkConnectionPPPHoldingLinkOff		=  11,
	kSCNetworkConnectionPPPSuspended		=  12,
	kSCNetworkConnectionPPPWaitingForRedial		=  13
};

/*!
	@typedef SCNetworkConnectionCallBack
	@discussion Type of the callback function used when a
		status event is delivered.
	@param status The connection status.
	@param connection The connection reference.
	@param info Application-specific information.
 */
typedef void (*SCNetworkConnectionCallBack)	(
						SCNetworkConnectionRef				connection,
						SCNetworkConnectionStatus			status,
						void			    *	__nullable	info
						);



/*
    Keys for the statistics dictionary
*/

#define kSCNetworkConnectionBytesIn		CFSTR("BytesIn")		/* CFNumber */
#define kSCNetworkConnectionBytesOut		CFSTR("BytesOut")		/* CFNumber */
#define kSCNetworkConnectionPacketsIn		CFSTR("PacketsIn")		/* CFNumber */
#define kSCNetworkConnectionPacketsOut		CFSTR("PacketsOut")		/* CFNumber */
#define kSCNetworkConnectionErrorsIn		CFSTR("ErrorsIn")		/* CFNumber */
#define kSCNetworkConnectionErrorsOut		CFSTR("ErrorsOut")		/* CFNumber */


/*
 Keys for the SCNetworkConnectionCopyUserPreferences() "selectionOptions"
 dictionary
 */

/*!
	@define kSCNetworkConnectionSelectionOptionOnDemandHostName
	@discussion A host name that will be used to select the
		"best" SCNetworkConnection.
 */
#define kSCNetworkConnectionSelectionOptionOnDemandHostName	CFSTR("OnDemandHostName")	// CFString
												// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)

/*!
	@define kSCNetworkConnectionSelectionOptionOnDemandRetry
	@discussion A boolean value used to indicate whether a DNS query has
		already been issued for the specified OnDemand host name.
 */
#define kSCNetworkConnectionSelectionOptionOnDemandRetry	CFSTR("OnDemandRetry")		// CFBoolean
												// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA)

__BEGIN_DECLS

/*!
	@function SCNetworkConnectionGetTypeID
	@discussion Returns the type identifier of all SCNetworkConnection
		instances.
 */
CFTypeID
SCNetworkConnectionGetTypeID			(void)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionCopyUserPreferences
	@discussion Provides the default service ID and a dictionary of user
		options for the connection.  Applications can use the
		returned serviceID and userOptions values to open a
		connection on the fly.
	@param selectionOptions Currently unimplemented. Pass NULL for this
		version.
	@param serviceID Reference to the default serviceID for starting
		connections, this value will be returned by the function.
	@param userOptions Reference to default userOptions for starting
		connections, this will be returned by the function.
	@result Returns TRUE if there is a valid service to dial;
		FALSE if the function was unable to retrieve a service to dial.
 */
Boolean
SCNetworkConnectionCopyUserPreferences		(
						CFDictionaryRef				  __nullable	selectionOptions,
						CFStringRef		__nonnull	* __nullable	serviceID,
						CFDictionaryRef		__nonnull	* __nullable	userOptions
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionCreateWithServiceID
	@discussion Creates a new connection reference to use for getting
		the status or for connecting or disconnecting the associated
		service.
	@param allocator The CFAllocator that should be used to allocate
		memory for the connection structure.  This parameter may be
		NULL in which case the current default CFAllocator is used.
		If this reference is not a valid CFAllocator, the behavior
		is undefined.
	@param serviceID A string that defines the service identifier
		of the connection.  Service identifiers uniquely identify
		services in the system configuration database.
	@param callout The function to be called when the status
		of the connection changes.  If this parameter is NULL, the
		application will not receive notifications of status change
		and will need to poll for updates.
	@param context The SCNetworkConnectionContext associated with the
		callout.
	@result Returns a reference to the new SCNetworkConnection.
 */
SCNetworkConnectionRef __nullable
SCNetworkConnectionCreateWithServiceID		(
						CFAllocatorRef			__nullable	allocator,
						CFStringRef					serviceID,
						SCNetworkConnectionCallBack	__nullable	callout,
						SCNetworkConnectionContext	* __nullable	context
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionCopyServiceID
	@discussion Returns the service ID associated with the SCNetworkConnection.
	@param connection The SCNetworkConnection to obtain status from.
	@result Returns the service ID associated with the SCNetworkConnection.
 */
CFStringRef __nullable
SCNetworkConnectionCopyServiceID		(
						SCNetworkConnectionRef		connection
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionGetStatus
	@discussion Returns the status of the SCNetworkConnection.
		A status is one of the following values:
<pre>
@textblock
&#32
	kSCNetworkConnectionInvalid
	kSCNetworkConnectionDisconnected
	kSCNetworkConnectionConnecting
	kSCNetworkConnectionDisconnecting
	kSCNetworkConnectionConnected
@/textblock
</pre>
	@param connection The SCNetworkConnection to obtain status from.
	@result Returns the status value.
*/
SCNetworkConnectionStatus
SCNetworkConnectionGetStatus			(
						SCNetworkConnectionRef		connection
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionCopyExtendedStatus
	@discussion Returns the extended status of the connection.
		An extended status dictionary contains specific dictionaries
		describing the status for each subcomponent of the service.

		For example, a status dictionary will contain the following
		sub-dictionaries, keys, and values:
<pre>
@textblock
&#32
	IPv4  : Addresses      : the assigned IP address.
&#32
	PPP   : Status         : the PPP-specific status of type
				 SCNetworkConnectionPPPStatus.
&#32
		LastCause      : Available when the status is "Disconnected"
				 and contains the last error associated with
				 connecting or disconnecting.
&#32
		ConnectTime    : the time when the connection was
				 established.
&#32
	Modem : ConnectSpeed   : the speed of the modem connection
				 in bits/second.
&#32
	IPSec : Status         : the IPSec-specific status of type
				 SCNetworkConnectionIPSecStatus
&#32
		ConnectTime    : the time when the connection was
				 established.

@/textblock
</pre>
		Other dictionaries could be present for PPPoE, PPTP, and L2TP.

		The status dictionary may be extended in the future to contain
		additional information.
	@param connection The SCNetworkConnection to obtain status from.
	@result Returns the status dictionary.
		If NULL is returned, the error can be retrieved using the SCError function.
 */
CFDictionaryRef __nullable
SCNetworkConnectionCopyExtendedStatus		(
						SCNetworkConnectionRef		connection
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionCopyStatistics
	@discussion Returns the statistics of the SCNetworkConnection.
		A statistic dictionary contains specific dictionaries
		with statistics for each subcomponent of the service.

		For example, a statistics dictionary will contain the following
		sub-dictionaries, keys, and values:
<pre>
@textblock
&#32
	PPP : BytesIn    :
	PPP : BytesOut   : Contains the number of bytes going up into
			   (or coming out of) the network stack for
			   any networking protocol without the PPP
			   headers and trailers.
&#32
	PPP : PacketsIn  :
	PPP : PacketsOut : Contains the number of packets going up into
			   (or coming out of) the network stack for
			   any networking protocol without the PPP
			   headers and trailers.
&#32
	PPP : ErrorsIn   :
	PPP : ErrorsOut  : Contains the number of errors going up into
			   (or coming out of) the network stack for
			   any networking protocol without the PPP
			   headers and trailers.
@/textblock
</pre>
		The statistics dictionary may be extended in the future to
		contain additional information.
	@param connection The SCNetworkConnection to obtained statistics from.
	@result Returns the statistics dictionary.
		If NULL is returned, the error can be retrieved using the SCError function.
 */
CFDictionaryRef __nullable
SCNetworkConnectionCopyStatistics		(
						SCNetworkConnectionRef		connection
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionStart
	@discussion Starts the connection for the SCNetworkConnection.
		The connection process is asynchronous and the function will
		return immediately.  The connection status can be obtained
		by polling or by callback.  The connection is made with the
		default settings from the administrator.  Some of the settings
		can be overridden for the duration of the connection.  These
		are specified in an options dictionary.  The options dictionary
		uses the same format as a network service defined in the system
		configuration preferences schema.

		Note: Starting and stopping of connections is implicitly
		arbitrated.  Calling SCNetworkConnectionStart on a connection
		already started will indicate that the application has
		interest in the connection and it shouldn't be stopped by
		anyone else.
	@param connection The SCNetworkConnection to start.
	@param userOptions The options dictionary to start the connection with.
		If userOptions is NULL, the default settings will be used.
		If userOptions are specified, they must be in the same format
		as network services stored in the system configuration
		preferences schema.  The options will override the default
		settings defined for the service.

		For security reasons, not all options can be overridden; the
		appropriate merging of all settings will be done before the
		connection is established, and inappropriate options will be
		ignored.
	@param linger This parameter indicates whether or not the connection
		can stay around when the application no longer has interest
		in it.  A typical application should pass FALSE, and the
		connection will be automatically stopped when the reference
		is released or if the application quits.  If the application
		passes TRUE, the application can release the reference or
		exit and the connection will be maintained until a timeout
		event, until a specific stop request occurs, or until an
		error is encountered.
	@result Returns TRUE if the connection was correctly started (the
		actual connection is not established yet, and the connection
		status needs to be periodically checked); FALSE if the
		connection request was not started.  The error must be
		retrieved from the SCError function.
 */
Boolean
SCNetworkConnectionStart			(
						SCNetworkConnectionRef				connection,
						CFDictionaryRef			__nullable	userOptions,
						Boolean						linger
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionStop
	@discussion Stops the connection for the SCNetworkConnection.
		The disconnection process is asynchronous and the function
		will return immediately.  The connection status can be
		obtained by polling or by callback.  This function performs
		an arbitrated stop of the connection.  If several applications
		have marked their interest in the connection, by calling
		SCNetworkConnectionStart, the call will succeed but the
		actual connection will be maintained until the last interested
		application calls SCNetworkConnectionStop.

		In certain cases, you might want to stop the connection anyway.
		In these cases, you set the forceDisconnect argument to TRUE.
	@param connection The SCNetworkConnection to stop.
	@result Returns TRUE if the disconnection request succeeded;
		FALSE if the disconnection request failed.
		The error must be retrieved from the SCError function.
 */
Boolean
SCNetworkConnectionStop				(
						SCNetworkConnectionRef		connection,
						Boolean				forceDisconnect
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionCopyUserOptions
	@discussion Copies the user options used to start the connection.
		This is a mechanism a client can use to retrieve the user options
		previously passed to the SCNetworkConnectionStart function.
	@param connection The SCNetworkConnection to obtain options from.
	@result Returns the service dictionary containing the connection options.
		The dictionary can be empty if no user options were used.
		If NULL is returned, the error can be retrieved using the SCError function.
 */
CFDictionaryRef __nullable
SCNetworkConnectionCopyUserOptions		(
						SCNetworkConnectionRef		connection
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionScheduleWithRunLoop
	@discussion Schedules a connection with the run loop.
	@param connection The SCNetworkConnection to schedule.
	@param runLoop The run loop to schedule with.
	@param runLoopMode The run loop mode.
	@result Returns TRUE if the connection is scheduled successfully;
		FALSE if the scheduling failed.
		The error can be retrieved using the SCError function.
 */
Boolean
SCNetworkConnectionScheduleWithRunLoop		(
						SCNetworkConnectionRef		connection,
						CFRunLoopRef			runLoop,
						CFStringRef			runLoopMode
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	@function SCNetworkConnectionUnscheduleFromRunLoop
	@discussion Unschedules a connection from the run loop.
	@param connection The SCNetworkConnection to unschedule.
	@param runLoop The run loop to unschedule from.
	@param runLoopMode The run loop mode.
	@result Returns TRUE if the connection is unscheduled successfully;
		FALSE if the unscheduling failed.
		The error can be retrieved using the SCError function.
 */
Boolean
SCNetworkConnectionUnscheduleFromRunLoop	(
						SCNetworkConnectionRef		connection,
						CFRunLoopRef			runLoop,
						CFStringRef			runLoopMode
						)			__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);


/*!
	 @function SCNetworkConnectionSetDispatchQueue
	 @discussion Caller provides a dispatch queue on which the callback contained in connection will run.
	 @param connection The SCNetworkConnection to notify.
	 @param queue The libdispatch queue to run the callback on.
		Pass NULL to disable notifications, and release queue.
	 @result Returns TRUE if the notifications have been enabled/disabled as desired;
		 FALSE if not.
		 The error can be retrieved using the SCError function.
 */
Boolean
SCNetworkConnectionSetDispatchQueue		(
						 SCNetworkConnectionRef				connection,
						 dispatch_queue_t		__nullable	queue
						 )			__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SCNETWORKCONNECTION_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                      SCNetworkReachability.h                                                                             0100644 0001750 0001750 00000033246 12567450664 040230  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2003-2005, 2008-2010, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCNETWORKREACHABILITY_H
#define _SCNETWORKREACHABILITY_H

#include <Availability.h>
#include <TargetConditionals.h>
#include <sys/cdefs.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SCNetwork.h>
#include <dispatch/dispatch.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCNetworkReachability
	@discussion The SCNetworkReachability API allows an application to
		determine the status of a system's current network
		configuration and the reachability of a target host.
		In addition, reachability can be monitored with notifications
		that are sent when the status has changed.

		"Reachability" reflects whether a data packet, sent by
		an application into the network stack, can leave the local
		computer.
		Note that reachability does <i>not</i> guarantee that the data
		packet will actually be received by the host.
 */

/*!
	@typedef SCNetworkReachabilityRef
	@discussion This is the handle to a network address or name.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCNetworkReachability * SCNetworkReachabilityRef;


/*!
	@typedef SCNetworkReachabilityContext
	Structure containing user-specified data and callbacks for SCNetworkReachability.
	@field version The version number of the structure type being passed
		in as a parameter to the SCDynamicStore creation function.
		This structure is version 0.
	@field info A C pointer to a user-specified block of data.
	@field retain The callback used to add a retain for the info field.
		If this parameter is not a pointer to a function of the correct
		prototype, the behavior is undefined.  The value may be NULL.
	@field release The calllback used to remove a retain previously added
		for the info field.  If this parameter is not a pointer to a
		function of the correct prototype, the behavior is undefined.
		The value may be NULL.
	@field copyDescription The callback used to provide a description of
		the info field.
 */
typedef struct {
	CFIndex		version;
	void *		__nullable info;
	const void	* __nonnull (* __nullable retain)(const void *info);
	void		(* __nullable release)(const void *info);
	CFStringRef	__nonnull (* __nullable copyDescription)(const void *info);
} SCNetworkReachabilityContext;

/*!
	@enum SCNetworkReachabilityFlags
	@discussion Flags that indicate whether the specified network
		nodename or address is reachable, whether a connection is
		required, and whether some user intervention may be required
		when establishing a connection.
	@constant kSCNetworkReachabilityFlagsTransientConnection
		This flag indicates that the specified nodename or address can
		be reached via a transient connection, such as PPP.
	@constant kSCNetworkReachabilityFlagsReachable
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration.
	@constant kSCNetworkReachabilityFlagsConnectionRequired
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.

		As an example, this status would be returned for a dialup
		connection that was not currently active, but could handle
		network traffic for the target system.
	@constant kSCNetworkReachabilityFlagsConnectionOnTraffic
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.  Any traffic directed
		to the specified name or address will initiate the connection.

		Note: this flag was previously named kSCNetworkReachabilityFlagsConnectionAutomatic
	@constant kSCNetworkReachabilityFlagsInterventionRequired
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.  In addition, some
		form of user intervention will be required to establish this
		connection, such as providing a password, an authentication
		token, etc.

		Note: At the present time, this flag will only be returned
		in the case where you have a dial-on-traffic configuration
		(ConnectionOnTraffic), where an attempt to connect has
		already been made, and where some error (e.g. no dial tone,
		no answer, bad password, ...) was encountered during the
		automatic connection attempt.  In this case the PPP controller
		will stop attempting to establish a connection until the user
		has intervened.
	@constant kSCNetworkReachabilityFlagsConnectionOnDemand
		This flag indicates that the specified nodename or address can
		be reached using the current network configuration, but a
		connection must first be established.
		The connection will be established "On Demand" by the
		CFSocketStream APIs.
		Other APIs will not establish the connection.
	@constant kSCNetworkReachabilityFlagsIsLocalAddress
		This flag indicates that the specified nodename or address
		is one associated with a network interface on the current
		system.
	@constant kSCNetworkReachabilityFlagsIsDirect
		This flag indicates that network traffic to the specified
		nodename or address will not go through a gateway, but is
		routed directly to one of the interfaces in the system.
#if	TARGET_OS_IPHONE
	@constant kSCNetworkReachabilityFlagsIsWWAN
		This flag indicates that the specified nodename or address can
		be reached via an EDGE, GPRS, or other "cell" connection.
#endif	// TARGET_OS_IPHONE
 */
typedef CF_OPTIONS(uint32_t, SCNetworkReachabilityFlags) {
	kSCNetworkReachabilityFlagsTransientConnection	= 1<<0,
	kSCNetworkReachabilityFlagsReachable		= 1<<1,
	kSCNetworkReachabilityFlagsConnectionRequired	= 1<<2,
	kSCNetworkReachabilityFlagsConnectionOnTraffic	= 1<<3,
	kSCNetworkReachabilityFlagsInterventionRequired	= 1<<4,
	kSCNetworkReachabilityFlagsConnectionOnDemand	= 1<<5,	// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)
	kSCNetworkReachabilityFlagsIsLocalAddress	= 1<<16,
	kSCNetworkReachabilityFlagsIsDirect		= 1<<17,
#if	TARGET_OS_IPHONE
	kSCNetworkReachabilityFlagsIsWWAN		= 1<<18,
#endif	// TARGET_OS_IPHONE

	kSCNetworkReachabilityFlagsConnectionAutomatic	= kSCNetworkReachabilityFlagsConnectionOnTraffic
};

/*!
	@typedef SCNetworkReachabilityCallBack
	@discussion Type of the callback function used when the
		reachability of a network address or name changes.
	@param target The SCNetworkReachability reference being monitored
		for changes.
	@param flags The new SCNetworkReachabilityFlags representing the
		reachability status of the network address/name.
	@param info A C pointer to a user-specified block of data.
 */
typedef void (*SCNetworkReachabilityCallBack)	(
						SCNetworkReachabilityRef			target,
						SCNetworkReachabilityFlags			flags,
						void			     *	__nullable	info
						);

__BEGIN_DECLS

/*!
	@function SCNetworkReachabilityCreateWithAddress
	@discussion Creates a reference to the specified network
		address.  This reference can be used later to monitor the
		reachability of the target host.
	@param address The address of the desired host.
	@result Returns a reference to the new immutable SCNetworkReachabilityRef.

		 You must release the returned value.
 */
SCNetworkReachabilityRef __nullable
SCNetworkReachabilityCreateWithAddress		(
						CFAllocatorRef			__nullable	allocator,
						const struct sockaddr				*address
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilityCreateWithAddressPair
	@discussion Creates a reference to the specified network
		address.  This reference can be used later to monitor the
		reachability of the target host.
	@param localAddress The local address associated with a network
		connection.  If NULL, only the remote address is of interest.
	@param remoteAddress The remote address associated with a network
		connection.  If NULL, only the local address is of interest.
	@result Returns a reference to the new immutable SCNetworkReachabilityRef.

		 You must release the returned value.
 */
SCNetworkReachabilityRef __nullable
SCNetworkReachabilityCreateWithAddressPair	(
						CFAllocatorRef			__nullable	allocator,
						const struct sockaddr		* __nullable	localAddress,
						const struct sockaddr		* __nullable	remoteAddress
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilityCreateWithName
	@discussion Creates a reference to the specified network host or node
		name.  This reference can be used later to monitor the
		reachability of the target host.
	@param nodename The node name of the desired host.
		This name would be the same as that passed to the
		gethostbyname(3) or getaddrinfo(3) functions.
	@result Returns a reference to the new immutable SCNetworkReachabilityRef.

		You must release the returned value.
 */
SCNetworkReachabilityRef __nullable
SCNetworkReachabilityCreateWithName		(
						CFAllocatorRef			__nullable	allocator,
						const char					*nodename
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilityGetTypeID
	@discussion Returns the type identifier of all SCNetworkReachability
		instances.
 */
CFTypeID
SCNetworkReachabilityGetTypeID			(void)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);


/*!
	@function SCNetworkReachabilityGetFlags
	@discussion Determines if the given target is reachable using the
		current network configuration.
	@param target The network reference associated with the address or name
		to be checked for reachability.
	@param flags A pointer to memory that will be filled with the
		SCNetworkReachabilityFlags detailing the reachability
		of the specified target.
	@result Returns TRUE if the network connection flags are valid;
		FALSE if the status could not be determined.
 */
Boolean
SCNetworkReachabilityGetFlags			(
						SCNetworkReachabilityRef	target,
						SCNetworkReachabilityFlags	*flags
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilitySetCallback
	@discussion Assigns a client to a target, which receives callbacks
		when the reachability of the target changes.
	@param target The network reference associated with the address or
		name to be checked for reachability.
	@param callout The function to be called when the reachability of the
		target changes.  If NULL, the current client for the target
		is removed.
	@param context The SCNetworkReachabilityContext associated with
		the callout.  The value may be NULL.
	@result Returns TRUE if the notification client was successfully set.
 */
Boolean
SCNetworkReachabilitySetCallback		(
						SCNetworkReachabilityRef			target,
						SCNetworkReachabilityCallBack	__nullable	callout,
						SCNetworkReachabilityContext	* __nullable	context
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilityScheduleWithRunLoop
	@discussion Schedules the given target with the given run loop and mode.
	@param target The address or name that is set up for asynchronous
		notifications.  Must be non-NULL.
	@param runLoop A reference to a run loop on which the target should
		be scheduled.  Must be non-NULL.
	@param runLoopMode The mode on which to schedule the target.
		Must be non-NULL.
	@result Returns TRUE if the target is scheduled successfully;
		FALSE otherwise.
 */
Boolean
SCNetworkReachabilityScheduleWithRunLoop	(
						SCNetworkReachabilityRef	target,
						CFRunLoopRef			runLoop,
						CFStringRef			runLoopMode
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilityUnscheduleFromRunLoop
	@discussion Unschedules the given target from the given run loop
		and mode.
	@param target The address or name that is set up for asynchronous
		notifications.  Must be non-NULL.
	@param runLoop A reference to a run loop from which the target
		should be unscheduled.  Must be non-NULL.
	@param runLoopMode The mode on which to unschedule the target.
		Must be non-NULL.
	@result Returns TRUE if the target is unscheduled successfully;
		FALSE otherwise.
 */
Boolean
SCNetworkReachabilityUnscheduleFromRunLoop	(
						SCNetworkReachabilityRef	target,
						CFRunLoopRef			runLoop,
						CFStringRef			runLoopMode
						)				__OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);

/*!
	@function SCNetworkReachabilitySetDispatchQueue
	@discussion Schedules callbacks for the given target on the given
		dispatch queue.
	@param target The address or name that is set up for asynchronous
		notifications.  Must be non-NULL.
	@param queue A libdispatch queue to run the callback on. Pass NULL to disable notifications, and release queue.
	@result Returns TRUE if the target is unscheduled successfully;
		FALSE otherwise.
 */
Boolean
SCNetworkReachabilitySetDispatchQueue		(
						SCNetworkReachabilityRef			target,
						dispatch_queue_t		__nullable	queue
						)				__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SCNETWORKREACHABILITY_H */
                                                                                                                                                                                                                                                                                                                                                          SCPreferences.h                                                                                     0100644 0001750 0001750 00000040173 12567450664 036514  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000, 2001, 2004, 2005, 2007-2010, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCPREFERENCES_H
#define _SCPREFERENCES_H

#include <Availability.h>
#include <TargetConditionals.h>
#include <sys/cdefs.h>
#include <dispatch/dispatch.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SCDynamicStore.h>

#if	!TARGET_OS_IPHONE
#include <Security/Security.h>
#else	// !TARGET_OS_IPHONE
typedef const struct AuthorizationOpaqueRef *	AuthorizationRef;
#endif	// !TARGET_OS_IPHONE

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCPreferences
	@discussion The SCPreferences API allows an application to load and
		store XML configuration data in a controlled manner and provide
		the necessary notifications to other applications that need to
		be aware of configuration changes.

		To access configuration preferences, you must first establish a
		preferences session using the SCPreferencesCreate function.
		To identify a specific set of preferences to access, you pass a
		value in the prefsID parameter.
		A NULL value indicates that the default system preferences are
		to be accessed.
		A string that starts with a leading "/" character specifies
		the absolute path to the file containing the preferences to
		be accessed.
		A string that does not start with a leading "/" character
		specifies a file relative to the default system preferences
		directory.

		When you are finished with the preferences session, use
		CFRelease to close it.
 */


/*!
	@typedef SCPreferencesRef
	@discussion This is the handle to an open preferences session for
		accessing system configuration preferences.
 */
typedef const struct CF_BRIDGED_TYPE(id) __SCPreferences *	SCPreferencesRef;

/*!
	@enum SCPreferencesNotification
	@discussion Used with the SCPreferencesCallBack callback
		to describe the type of notification.
	@constant kSCPreferencesNotificationCommit Indicates when new
		preferences have been saved.
	@constant kSCPreferencesNotificationApply Key Indicates when a
		request has been made to apply the currently saved
		preferences to the active system configuration.
 */
typedef CF_OPTIONS(uint32_t, SCPreferencesNotification) {
	kSCPreferencesNotificationCommit	= 1<<0,	// __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA)
	kSCPreferencesNotificationApply		= 1<<1	// __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA)
};

/*!
	@typedef SCPreferencesContext
	Structure containing user-specified data and callbacks for SCPreferences.
	@field version The version number of the structure type being passed
		in as a parameter to the SCPreferencesSetCallback function.
		This structure is version 0.
	@field info A C pointer to a user-specified block of data.
	@field retain The callback used to add a retain for the info field.
		If this parameter is not a pointer to a function of the correct
		prototype, the behavior is undefined.
		The value may be NULL.
	@field release The calllback used to remove a retain previously added
		for the info field.
		If this parameter is not a pointer to a function of the
		correct prototype, the behavior is undefined.
		The value may be NULL.
	@field copyDescription The callback used to provide a description of
		the info field.
 */
typedef struct {
	CFIndex		version;
	void *		__nullable info;
	const void	* __nonnull (* __nullable retain)(const void *info);
	void		(* __nullable release)(const void *info);
	CFStringRef	__nonnull (* __nullable copyDescription)(const void *info);
} SCPreferencesContext;

/*!
	@typedef SCPreferencesCallBack
	@discussion Type of the callback function used when the
		preferences have been updated and/or applied.
	@param prefs The preferences session.
	@param notificationType The type of notification, such as changes
		committed, changes applied, etc.
	@param info A C pointer to a user-specified block of data.
 */
typedef void (*SCPreferencesCallBack)   (
					SCPreferencesRef				prefs,
					SCPreferencesNotification			notificationType,
					void			     *	__nullable	info
					);


__BEGIN_DECLS

/*!
	@function SCPreferencesGetTypeID
	@discussion Returns the type identifier of all SCPreferences instances.
 */
CFTypeID
SCPreferencesGetTypeID			(void)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesCreate
	@discussion Initiates access to the per-system set of configuration
		preferences.
	@param allocator The CFAllocator that should be used to allocate
		memory for this preferences session.
		This parameter may be NULL in which case the current
		default CFAllocator is used.
		If this reference is not a valid CFAllocator, the behavior
		is undefined.
	@param name A string that describes the name of the calling
		process.
	@param prefsID A string that identifies the name of the
		group of preferences to be accessed or updated.
	@result Returns a reference to the new SCPreferences.
		You must release the returned value.
 */
SCPreferencesRef __nullable
SCPreferencesCreate			(
					CFAllocatorRef		__nullable	allocator,
					CFStringRef				name,
					CFStringRef		__nullable	prefsID
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);


/*!
	@function SCPreferencesCreateWithAuthorization
	@discussion Initiates access to the per-system set of configuration
		preferences.
	@param allocator The CFAllocator that should be used to allocate
		memory for this preferences session.
		This parameter may be NULL in which case the current
		default CFAllocator is used.
		If this reference is not a valid CFAllocator, the behavior
		is undefined.
	@param name A string that describes the name of the calling
		process.
	@param prefsID A string that identifies the name of the
		group of preferences to be accessed or updated.
	@param authorization An authorization reference that is used to
		authorize any access to the enhanced privileges needed
		to manage the preferences session.
	@result Returns a reference to the new SCPreferences.
		You must release the returned value.
 */
SCPreferencesRef __nullable
SCPreferencesCreateWithAuthorization	(
					CFAllocatorRef		__nullable	allocator,
					CFStringRef				name,
					CFStringRef		__nullable	prefsID,
					AuthorizationRef	__nullable	authorization
					)			__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);

/*!
	@function SCPreferencesLock
	@discussion Locks access to the configuration preferences.

		This function obtains exclusive access to the configuration
		preferences.  Clients attempting to obtain exclusive access
		to the preferences will either receive a kSCStatusPrefsBusy
		error or block waiting for the lock to be released.
	@param prefs The preferences session.
	@param wait A boolean flag indicating whether the calling process
		should block waiting for another process to complete its update
		operation and release its lock.
	@result Returns TRUE if the lock was obtained;
		FALSE if an error occurred.
 */
Boolean
SCPreferencesLock			(
					SCPreferencesRef	prefs,
					Boolean			wait
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesCommitChanges
	@discussion Commits changes made to the configuration preferences to
		persistent storage.

		This function commits any changes to permanent storage.
		Implicit calls to the SCPreferencesLock and SCPreferencesUnlock
		functions will be made if exclusive access has not already been
		established.

		Note: This routine commits changes to persistent storage.
		Call the SCPreferencesApplyChanges function to apply the
		changes to the running system.
	@param prefs The preferences session.
	@result Returns TRUE if the lock was obtained;
		FALSE if an error occurred.
 */
Boolean
SCPreferencesCommitChanges		(
					SCPreferencesRef	prefs
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesApplyChanges
	@discussion Requests that the currently stored configuration
		preferences be applied to the active configuration.
	@param prefs The preferences session.
	@result Returns TRUE if the lock was obtained;
		FALSE if an error occurred.
 */
Boolean
SCPreferencesApplyChanges		(
					SCPreferencesRef	prefs
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesUnlock
	@discussion Releases exclusive access to the configuration preferences.

		This function releases the exclusive access lock to the
		preferences.  Other clients will be now be able to establish
		exclusive access to the preferences.
	@param prefs The preferences session.
	@result Returns TRUE if the lock was obtained;
		FALSE if an error occurred.
 */
Boolean
SCPreferencesUnlock			(
					SCPreferencesRef	prefs
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesGetSignature
	@discussion Returns a sequence of bytes that can be used to determine
		if the saved configuration preferences have changed.
	@param prefs The preferences session.
	@result Returns a CFDataRef that reflects the signature of the configuration
		preferences at the time of the call to the SCPreferencesCreate function.
 */
CFDataRef __nullable
SCPreferencesGetSignature		(
					SCPreferencesRef	prefs
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesCopyKeyList
	@discussion Returns an array of currently defined preference keys.
	@param prefs The preferences session.
	@result Returns the list of keys.
		You must release the returned value.
 */
CFArrayRef __nullable
SCPreferencesCopyKeyList		(
					SCPreferencesRef	prefs
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesGetValue
	@discussion Returns the data associated with a preference key.

		This function retrieves data associated with the specified
		key.

		Note: To avoid inadvertantly reading stale data, first call
		the SCPreferencesLock function.
	@param prefs The preferences session.
	@param key The preference key to be returned.
	@result Returns the value associated with the specified preference key;
		NULL if no value was located.
 */
CFPropertyListRef __nullable
SCPreferencesGetValue			(
					SCPreferencesRef	prefs,
					CFStringRef		key
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesAddValue
	@discussion Adds data for a preference key.

		This function associates new data with the specified key.
		To commit these changes to permanent storage, a call must
		be made to the SCPreferencesCommitChanges function.
	@param prefs The preferences session.
	@param key The preference key to be updated.
	@param value The CFPropertyListRef object containing the
		value to be associated with the specified preference key.
	@result Returns TRUE if the value was added;
		FALSE if the key already exists or
		if an error occurred.
 */
Boolean
SCPreferencesAddValue			(
					SCPreferencesRef	prefs,
					CFStringRef		key,
					CFPropertyListRef	value
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesSetValue
	@discussion Updates the data associated with a preference key.

		This function adds or replaces the value associated with the
		specified key.  To commit these changes to permanent storage
		a call must be made to the SCPreferencesCommitChanges function.
	@param prefs The preferences session.
	@param key The preference key to be updated.
	@param value The CFPropertyListRef object containing the
		data to be associated with the specified preference key.
	@result Returns TRUE if the value was set;
		FALSE if an error occurred.
 */
Boolean
SCPreferencesSetValue			(
					SCPreferencesRef	prefs,
					CFStringRef		key,
					CFPropertyListRef	value
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesRemoveValue
	@discussion Removes the data associated with a preference key.

		This function removes the data associated with the specified
		key.  To commit these changes to permanent storage a call must
		be made to the SCPreferencesCommitChanges function.
	@param prefs The preferences session.
	@param key The preference key to be removed.
	@result Returns TRUE if the value was removed;
		FALSE if the key did not exist or if an error occurred.
 */
Boolean
SCPreferencesRemoveValue		(
					SCPreferencesRef	prefs,
					CFStringRef		key
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesSetCallback
	@discussion Assigns a callback to a preferences session.  The function
		is called when the changes to the preferences have been
		committed or applied.
	@param prefs The preferences session.
	@param callout The function to be called when the preferences have
		been changed or applied.
		If NULL, the current callback is removed.
	@param context The SCPreferencesContext associated with
		the callout.
	@result Returns TRUE if the notification client was successfully set.
 */
Boolean
SCPreferencesSetCallback		(
					SCPreferencesRef			prefs,
					SCPreferencesCallBack	__nullable	callout,
					SCPreferencesContext	* __nullable	context
					)			__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCPreferencesScheduleWithRunLoop
	@discussion Schedule commit and apply notifications for the specified
		preferences session using the specified run loop and mode.
	@param prefs The preferences session.
	@param runLoop A reference to a run loop on which the notification
		should be scheduled.
		Must be non-NULL.
	@param runLoopMode The mode on which to schedule the notification.
		Must be non-NULL.
	@result Returns TRUE if the notifications are successfully scheduled;
		FALSE otherwise.
 */
Boolean
SCPreferencesScheduleWithRunLoop	(
					SCPreferencesRef	prefs,
					CFRunLoopRef		runLoop,
					CFStringRef		runLoopMode
					)			__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCPreferencesUnscheduleFromRunLoop
	@discussion Unschedule commit and apply notifications for the specified
		preferences session from the specified run loop and mode.
	@param prefs The preferences session.
	@param runLoop A reference to a run loop from which the notification
		should be unscheduled.
		Must be non-NULL.
	@param runLoopMode The mode on which to unschedule the notification.
		Must be non-NULL.
	@result Returns TRUE if the notifications are successfully unscheduled;
		FALSE otherwise.
 */
Boolean
SCPreferencesUnscheduleFromRunLoop	(
					SCPreferencesRef	prefs,
					CFRunLoopRef		runLoop,
					CFStringRef		runLoopMode
					)			__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

/*!
	@function SCPreferencesSetDispatchQueue
	@discussion Schedule commit and apply notifications for the specified
		preferences session.
	@param prefs The preferences session.
	@param queue The dispatch queue to run the callback function on.
	@result Returns TRUE if the notifications are successfully scheduled;
		FALSE otherwise.
 */
Boolean
SCPreferencesSetDispatchQueue		(
					 SCPreferencesRef			prefs,
					 dispatch_queue_t	__nullable	queue
					 )			__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);

/*!
	@function SCPreferencesSynchronize
	@discussion Synchronizes accessed preferences with committed changes.

		Any references to preference values returned by calls to the
		SCPreferencesGetValue function are no longer valid unless they
		were explicitly retained or copied.  Any preference values
		that were updated (add, set, remove) but not committed will
		be discarded.
	@param prefs The preferences session.
 */
void
SCPreferencesSynchronize		(
					SCPreferencesRef	prefs
					)			__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SCPREFERENCES_H */
                                                                                                                                                                                                                                                                                                                                                                                                     SCPreferencesPath.h                                                                                 0100644 0001750 0001750 00000013235 12567450664 037330  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000, 2001, 2004, 2005, 2008, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCPREFERENCESPATH_H
#define _SCPREFERENCESPATH_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SCPreferences.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCPreferencesPath
	@discussion The SCPreferencesPath API allows an application to
		load and store XML configuration data in a controlled
		manner and provide the necessary notifications to other
		applications that need to be aware of configuration
		changes.

		The functions in the SCPreferencesPath API make certain
		assumptions about the layout of the preferences data.
		These functions view the data as a collection of dictionaries
		of key-value pairs and an associated path name.
		The root path ("/") identifies the top-level dictionary.
		Additional path components specify the keys for subdictionaries.

		For example, the following dictionary can be accessed via
		two paths.  The root ("/") path would return a dictionary
		with all keys and values.  The path "/path1" would only
		return the dictionary with the "key3" and "key4" properties.

	<pre>
	@textblock
	<dict>
		<key>key1</key>
		<string>val1</string>
		<key>key2</key>
		<string>val2</string>
		<key>path1</key>
		<dict>
			<key>key3</key>
			<string>val3</string>
			<key>key4</key>
			<string>val4</string>
		</dict>
	</dict>
	@/textblock
	</pre>

	Each dictionary can also include the kSCResvLink ("__LINK__") key.
	The value associated with this key is interpreted as a link to
	another path.  If this key is present, a call to the
	SCPreferencesPathGetValue function returns the dictionary
	specified by the link.
 */


__BEGIN_DECLS

/*!
	@function SCPreferencesPathCreateUniqueChild
	@discussion Creates a new path component within the dictionary
		hierarchy.
	@param prefs The preferences session.
	@param prefix A string that represents the parent path.
	@result Returns a string representing the new (unique) child path; NULL
		if the specified path does not exist.
 */
CFStringRef __nullable
SCPreferencesPathCreateUniqueChild	(
					SCPreferencesRef	prefs,
					CFStringRef		prefix
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesPathGetValue
	@discussion Returns the dictionary associated with the specified
		path.
	@param prefs The preferences session.
	@param path A string that represents the path to be returned.
	@result Returns the dictionary associated with the specified path; NULL
		if the path does not exist.
 */
CFDictionaryRef __nullable
SCPreferencesPathGetValue		(
					SCPreferencesRef	prefs,
					CFStringRef		path
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesPathGetLink
	@discussion Returns the link (if one exists) associated with the
		specified path.
	@param prefs The preferences session.
	@param path A string that represents the path to be returned.
	@result Returns the dictionary associated with the specified path; NULL
		if the path is not a link or does not exist.
 */
CFStringRef __nullable
SCPreferencesPathGetLink		(
					SCPreferencesRef	prefs,
					CFStringRef		path
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesPathSetValue
	@discussion Associates a dictionary with the specified path.
	@param prefs The preferences session.
	@param path A string that represents the path to be updated.
	@param value A dictionary that represents the data to be
		stored at the specified path.
	@result Returns TRUE if successful; FALSE otherwise.
 */
Boolean
SCPreferencesPathSetValue		(
					SCPreferencesRef	prefs,
					CFStringRef		path,
					CFDictionaryRef		value
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesPathSetLink
	@discussion Associates a link to a second dictionary at the
		specified path.
	@param prefs The preferences session.
	@param path A string that represents the path to be updated.
	@param link A string that represents the link to be stored
		at the specified path.
	@result Returns TRUE if successful; FALSE otherwise.
 */
Boolean
SCPreferencesPathSetLink		(
					SCPreferencesRef	prefs,
					CFStringRef		path,
					CFStringRef		link
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesPathRemoveValue
	@discussion Removes the data associated with the specified path.
	@param prefs The preferences session.
	@param path A string that represents the path to be returned.
	@result Returns TRUE if successful; FALSE otherwise.
 */
Boolean
SCPreferencesPathRemoveValue		(
					SCPreferencesRef	prefs,
					CFStringRef		path
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SCPREFERENCESPATH_H */
                                                                                                                                                                                                                                                                                                                                                                   SCPreferencesSetSpecific.h                                                                          0100644 0001750 0001750 00000006163 12567450664 040637  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000-2002, 2004, 2005, 2008, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SCPREFERENCESSETSPECIFIC_H
#define _SCPREFERENCESSETSPECIFIC_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>
#include <SystemConfiguration/SCPreferences.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@header SCPreferencesSetSpecific
	@discussion The functions in the SCPreferencesSetSpecific API allow
		an application to set specific configuration information
		about the current system (for example, the computer or
		sharing name).

		To access configuration preferences, you must first establish
		a preferences session using the SCPreferencesCreate function.
 */


__BEGIN_DECLS

/*!
	@function SCPreferencesSetComputerName
	@discussion Updates the computer name preference.

		Note: To commit these changes to permanent storage you must
		call the SCPreferencesCommitChanges function.
		In addition, you must call the SCPreferencesApplyChanges
		function for the new name to become active.
	@param prefs The preferences session.
	@param name The computer name to be set.
	@param nameEncoding The encoding associated with the computer name.
	@result Returns TRUE if successful; FALSE otherwise.
 */
Boolean
SCPreferencesSetComputerName		(
					SCPreferencesRef	prefs,
					CFStringRef		name,
					CFStringEncoding	nameEncoding
					)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);

/*!
	@function SCPreferencesSetLocalHostName
	@discussion Updates the local host name.

		Note: To commit these changes to permanent storage you must
		call the SCPreferencesCommitChanges function.
		In addition, you must call the SCPreferencesApplyChanges
		function for the new name to become active.
	@param prefs The preferences session.
	@param name The local host name to be set.

	Note: this string must conform to the naming conventions of a DNS host
		name as specified in RFC 1034 (section 3.5).
	@result Returns TRUE if successful; FALSE otherwise.
 */
Boolean
SCPreferencesSetLocalHostName		(
					SCPreferencesRef	prefs,
					CFStringRef		name
					)			__OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SCPREFERENCESSETSPECIFIC_H */
                                                                                                                                                                                                                                                                                                                                                                                                             SCSchemaDefinitions.h                                                                               0100644 0001750 0001750 00000317034 12567450664 037652  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * This file is automatically generated
 * DO NOT EDIT!
 */

/*
 * Reserved Keys
 *
 *   kSCResvLink                                        "__LINK__"                     CFString
 *   kSCResvInactive                                    "__INACTIVE__"
 *
 * Generic Keys
 *
 *   kSCPropInterfaceName                               "InterfaceName"                CFString
 *   kSCPropMACAddress                                  "MACAddress"                   CFString
 *   kSCPropUserDefinedName                             "UserDefinedName"              CFString
 *   kSCPropVersion                                     "Version"                      CFString
 *
 * Preference Keys
 *
 *   kSCPrefCurrentSet                                  "CurrentSet"                   CFString
 *   kSCPrefNetworkServices                             "NetworkServices"              CFDictionary
 *   kSCPrefSets                                        "Sets"                         CFDictionary
 *   kSCPrefSystem                                      "System"                       CFDictionary
 *
 * Component Keys
 *
 *   kSCCompNetwork                                     "Network"
 *   kSCCompService                                     "Service"
 *   kSCCompGlobal                                      "Global"
 *   kSCCompHostNames                                   "HostNames"
 *   kSCCompInterface                                   "Interface"
 *   kSCCompSystem                                      "System"
 *   kSCCompUsers                                       "Users"
 *
 *   --- Regex pattern which matches any component ---
 *   kSCCompAnyRegex                                    "[^/]+"
 *
 * Network Entity Keys
 *
 *   kSCEntNetAirPort                                   "AirPort"                      CFDictionary
 *   kSCEntNetDHCP                                      "DHCP"                         CFDictionary
 *   kSCEntNetDNS                                       "DNS"                          CFDictionary
 *   kSCEntNetEthernet                                  "Ethernet"                     CFDictionary
 *   kSCEntNetFireWire                                  "FireWire"                     CFDictionary
 *   kSCEntNetInterface                                 "Interface"                    CFDictionary
 *   kSCEntNetIPSec                                     "IPSec"                        CFDictionary
 *   kSCEntNetIPv4                                      "IPv4"                         CFDictionary
 *   kSCEntNetIPv6                                      "IPv6"                         CFDictionary
 *   kSCEntNetL2TP                                      "L2TP"                         CFDictionary
 *   kSCEntNetLink                                      "Link"                         CFDictionary
 *   kSCEntNetModem                                     "Modem"                        CFDictionary
 *   kSCEntNetPPP                                       "PPP"                          CFDictionary
 *   kSCEntNetPPPoE                                     "PPPoE"                        CFDictionary
 *   kSCEntNetPPPSerial                                 "PPPSerial"                    CFDictionary
 *   kSCEntNetPPTP                                      "PPTP"                         CFDictionary
 *   kSCEntNetProxies                                   "Proxies"                      CFDictionary
 *   kSCEntNetSMB                                       "SMB"                          CFDictionary
 *   kSCEntNet6to4                                      "6to4"                         CFDictionary
 *
 * kSCCompNetwork Properties
 *
 *   kSCPropNetOverridePrimary                          "OverridePrimary"              CFNumber (0 or 1)
 *   kSCPropNetServiceOrder                             "ServiceOrder"                 CFArray[CFString]
 *   kSCPropNetPPPOverridePrimary                       "PPPOverridePrimary"           CFNumber (0 or 1)
 *
 * kSCCompNetworkInterface Properties
 *
 *   kSCPropNetInterfaces                               "Interfaces"                   CFArray[CFString]
 *
 * kSCCompNetworkHostNames Properties
 *
 *   kSCPropNetLocalHostName                            "LocalHostName"                CFString
 *
 * kSCEntNetDNS Entity Keys
 *
 *   kSCPropNetDNSDomainName                            "DomainName"                   CFString
 *   kSCPropNetDNSOptions                               "Options"                      CFString
 *   kSCPropNetDNSSearchDomains                         "SearchDomains"                CFArray[CFString]
 *   kSCPropNetDNSSearchOrder                           "SearchOrder"                  CFNumber
 *   kSCPropNetDNSServerAddresses                       "ServerAddresses"              CFArray[CFString]
 *   kSCPropNetDNSServerPort                            "ServerPort"                   CFNumber
 *   kSCPropNetDNSServerTimeout                         "ServerTimeout"                CFNumber
 *   kSCPropNetDNSSortList                              "SortList"                     CFArray[CFString]
 *   kSCPropNetDNSSupplementalMatchDomains              "SupplementalMatchDomains"     CFArray[CFString]
 *   kSCPropNetDNSSupplementalMatchOrders               "SupplementalMatchOrders"      CFArray[CFNumber]
 *
 * kSCEntNetEthernet (Hardware) Entity Keys
 *
 *   kSCPropNetEthernetMediaSubType                     "MediaSubType"                 CFString
 *   kSCPropNetEthernetMediaOptions                     "MediaOptions"                 CFArray[CFString]
 *   kSCPropNetEthernetMTU                              "MTU"                          CFNumber
 *
 * kSCEntNetFireWire (Hardware) Entity Keys
 *
 *   * RESERVED FOR FUTURE USE *
 *
 * kSCEntNetInterface Entity Keys
 *
 *   kSCPropNetInterfaceDeviceName                      "DeviceName"                   CFString
 *   kSCPropNetInterfaceHardware                        "Hardware"                     CFString
 *   kSCPropNetInterfaceType                            "Type"                         CFString
 *   kSCPropNetInterfaceSubType                         "SubType"                      CFString
 *   kSCPropNetInterfaceSupportsModemOnHold             "SupportsModemOnHold"          CFNumber (0 or 1)
 *
 *   --- kSCPropNetInterfaceType values ---
 *   kSCValNetInterfaceTypeEthernet                     "Ethernet"
 *   kSCValNetInterfaceTypeFireWire                     "FireWire"
 *   kSCValNetInterfaceTypePPP                          "PPP"
 *   kSCValNetInterfaceType6to4                         "6to4"
 *   kSCValNetInterfaceTypeIPSec                        "IPSec"
 *
 *   --- kSCPropNetServiceSubType values (for PPP) ---
 *   kSCValNetInterfaceSubTypePPPoE                     "PPPoE"
 *   kSCValNetInterfaceSubTypePPPSerial                 "PPPSerial"
 *   kSCValNetInterfaceSubTypePPTP                      "PPTP"
 *   kSCValNetInterfaceSubTypeL2TP                      "L2TP"
 *
 * kSCEntNetIPSec Entity Keys
 *
 *   kSCPropNetIPSecAuthenticationMethod                "AuthenticationMethod"         CFString
 *   kSCPropNetIPSecLocalCertificate                    "LocalCertificate"             CFData
 *   kSCPropNetIPSecLocalIdentifier                     "LocalIdentifier"              CFString
 *   kSCPropNetIPSecLocalIdentifierType                 "LocalIdentifierType"          CFString
 *   kSCPropNetIPSecSharedSecret                        "SharedSecret"                 CFString
 *   kSCPropNetIPSecSharedSecretEncryption              "SharedSecretEncryption"       CFString
 *   kSCPropNetIPSecConnectTime                         "ConnectTime"                  CFNumber
 *   kSCPropNetIPSecRemoteAddress                       "RemoteAddress"                CFString
 *   kSCPropNetIPSecStatus                              "Status"                       CFNumber
 *   kSCPropNetIPSecXAuthEnabled                        "XAuthEnabled"                 CFNumber (0 or 1)
 *   kSCPropNetIPSecXAuthName                           "XAuthName"                    CFString
 *   kSCPropNetIPSecXAuthPassword                       "XAuthPassword"                CFString
 *   kSCPropNetIPSecXAuthPasswordEncryption             "XAuthPasswordEncryption"      CFString
 *
 *   --- kSCPropNetIPSecAuthenticationMethod values ---
 *   kSCValNetIPSecAuthenticationMethodSharedSecret     "SharedSecret"
 *   kSCValNetIPSecAuthenticationMethodCertificate      "Certificate"
 *   kSCValNetIPSecAuthenticationMethodHybrid           "Hybrid"
 *
 *   --- kSCPropNetIPSecLocalIdentifierType values ---
 *   kSCValNetIPSecLocalIdentifierTypeKeyID             "KeyID"
 *
 *   --- kSCPropNetIPSecSharedSecretEncryption values ---
 *   kSCValNetIPSecSharedSecretEncryptionKeychain       "Keychain"
 *
 *   --- kSCPropNetIPSecXAuthPasswordEncryption values ---
 *   kSCValNetIPSecXAuthPasswordEncryptionKeychain      "Keychain"
 *   kSCValNetIPSecXAuthPasswordEncryptionPrompt        "Prompt"
 *
 * kSCEntNetIPv4 Entity Keys
 *
 *   kSCPropNetIPv4Addresses                            "Addresses"                    CFArray[CFString]
 *   kSCPropNetIPv4ConfigMethod                         "ConfigMethod"                 CFString
 *   kSCPropNetIPv4DHCPClientID                         "DHCPClientID"                 CFString
 *   kSCPropNetIPv4Router                               "Router"                       CFString
 *   kSCPropNetIPv4SubnetMasks                          "SubnetMasks"                  CFArray[CFString]
 *   kSCPropNetIPv4DestAddresses                        "DestAddresses"                CFArray[CFString]
 *   kSCPropNetIPv4BroadcastAddresses                   "BroadcastAddresses"           CFArray[CFString]
 *
 *   --- kSCPropNetIPv4ConfigMethod values ---
 *   kSCValNetIPv4ConfigMethodAutomatic                 "Automatic"
 *   kSCValNetIPv4ConfigMethodBOOTP                     "BOOTP"
 *   kSCValNetIPv4ConfigMethodDHCP                      "DHCP"
 *   kSCValNetIPv4ConfigMethodINFORM                    "INFORM"
 *   kSCValNetIPv4ConfigMethodLinkLocal                 "LinkLocal"
 *   kSCValNetIPv4ConfigMethodManual                    "Manual"
 *   kSCValNetIPv4ConfigMethodPPP                       "PPP"
 *
 * kSCEntNetIPv6 Entity Keys
 *
 *   kSCPropNetIPv6Addresses                            "Addresses"                    CFArray[CFString]
 *   kSCPropNetIPv6ConfigMethod                         "ConfigMethod"                 CFString
 *   kSCPropNetIPv6DestAddresses                        "DestAddresses"                CFArray[CFString]
 *   kSCPropNetIPv6Flags                                "Flags"                        CFNumber
 *   kSCPropNetIPv6PrefixLength                         "PrefixLength"                 CFArray[CFNumber]
 *   kSCPropNetIPv6Router                               "Router"                       CFString
 *
 *   --- kSCPropNetIPv6ConfigMethod values ---
 *   kSCValNetIPv6ConfigMethodAutomatic                 "Automatic"
 *   kSCValNetIPv6ConfigMethodLinkLocal                 "LinkLocal"
 *   kSCValNetIPv6ConfigMethodManual                    "Manual"
 *   kSCValNetIPv6ConfigMethodRouterAdvertisement       "RouterAdvertisement"
 *   kSCValNetIPv6ConfigMethod6to4                      "6to4"
 *
 * kSCEntNet6to4 Entity Keys
 *
 *   kSCPropNet6to4Relay                                "Relay"                        CFString
 *
 * kSCEntNetLink Entity Keys
 *
 *   kSCPropNetLinkActive                               "Active"                       CFBoolean
 *   kSCPropNetLinkDetaching                            "Detaching"                    CFBoolean
 *
 * kSCEntNetModem (Hardware) Entity Keys
 *
 *   kSCPropNetModemAccessPointName                     "AccessPointName"              CFString
 *   kSCPropNetModemConnectionPersonality               "ConnectionPersonality"        CFString
 *   kSCPropNetModemConnectionScript                    "ConnectionScript"             CFString
 *   kSCPropNetModemConnectSpeed                        "ConnectSpeed"                 CFNumber
 *   kSCPropNetModemDataCompression                     "DataCompression"              CFNumber (0 or 1)
 *   kSCPropNetModemDeviceContextID                     "DeviceContextID"              CFString
 *   kSCPropNetModemDeviceModel                         "DeviceModel"                  CFString
 *   kSCPropNetModemDeviceVendor                        "DeviceVendor"                 CFString
 *   kSCPropNetModemDialMode                            "DialMode"                     CFString
 *   kSCPropNetModemErrorCorrection                     "ErrorCorrection"              CFNumber (0 or 1)
 *   kSCPropNetModemHoldCallWaitingAudibleAlert         "HoldCallWaitingAudibleAlert"  CFNumber (0 or 1)
 *   kSCPropNetModemHoldDisconnectOnAnswer              "HoldDisconnectOnAnswer"       CFNumber (0 or 1)
 *   kSCPropNetModemHoldEnabled                         "HoldEnabled"                  CFNumber (0 or 1)
 *   kSCPropNetModemHoldReminder                        "HoldReminder"                 CFNumber (0 or 1)
 *   kSCPropNetModemHoldReminderTime                    "HoldReminderTime"             CFNumber
 *   kSCPropNetModemNote                                "Note"                         CFString
 *   kSCPropNetModemPulseDial                           "PulseDial"                    CFNumber (0 or 1)
 *   kSCPropNetModemSpeaker                             "Speaker"                      CFNumber (0 or 1)
 *   kSCPropNetModemSpeed                               "Speed"                        CFNumber
 *
 *   --- kSCPropNetModemDialMode values ---
 *   kSCValNetModemDialModeIgnoreDialTone               "IgnoreDialTone"
 *   kSCValNetModemDialModeManual                       "Manual"
 *   kSCValNetModemDialModeWaitForDialTone              "WaitForDialTone"
 *
 * kSCEntNetPPP Entity Keys
 *
 *   kSCPropNetPPPACSPEnabled                           "ACSPEnabled"                  CFNumber (0 or 1)
 *   kSCPropNetPPPConnectTime                           "ConnectTime"                  CFNumber
 *   kSCPropNetPPPDeviceLastCause                       "DeviceLastCause"              CFNumber
 *   kSCPropNetPPPDialOnDemand                          "DialOnDemand"                 CFNumber (0 or 1)
 *   kSCPropNetPPPDisconnectOnFastUserSwitch            "DisconnectOnFastUserSwitch"   CFNumber (0 or 1)
 *   kSCPropNetPPPDisconnectOnIdle                      "DisconnectOnIdle"             CFNumber (0 or 1)
 *   kSCPropNetPPPDisconnectOnIdleTimer                 "DisconnectOnIdleTimer"        CFNumber
 *   kSCPropNetPPPDisconnectOnLogout                    "DisconnectOnLogout"           CFNumber (0 or 1)
 *   kSCPropNetPPPDisconnectOnSleep                     "DisconnectOnSleep"            CFNumber (0 or 1)
 *   kSCPropNetPPPDisconnectTime                        "DisconnectTime"               CFNumber
 *   kSCPropNetPPPIdleReminderTimer                     "IdleReminderTimer"            CFNumber
 *   kSCPropNetPPPIdleReminder                          "IdleReminder"                 CFNumber (0 or 1)
 *   kSCPropNetPPPLastCause                             "LastCause"                    CFNumber
 *   kSCPropNetPPPLogfile                               "Logfile"                      CFString
 *   kSCPropNetPPPPlugins                               "Plugins"                      CFArray[CFString]
 *   kSCPropNetPPPRetryConnectTime                      "RetryConnectTime"             CFNumber
 *   kSCPropNetPPPSessionTimer                          "SessionTimer"                 CFNumber
 *   kSCPropNetPPPStatus                                "Status"                       CFNumber
 *   kSCPropNetPPPUseSessionTimer                       "UseSessionTimer"              CFNumber (0 or 1)
 *   kSCPropNetPPPVerboseLogging                        "VerboseLogging"               CFNumber (0 or 1)
 *
 *   --- Auth: ---
 *   kSCPropNetPPPAuthEAPPlugins                        "AuthEAPPlugins"               CFArray[CFString]
 *   kSCPropNetPPPAuthName                              "AuthName"                     CFString
 *   kSCPropNetPPPAuthPassword                          "AuthPassword"                 CFString
 *   kSCPropNetPPPAuthPasswordEncryption                "AuthPasswordEncryption"       CFString
 *   kSCPropNetPPPAuthPrompt                            "AuthPrompt"                   CFString
 *   kSCPropNetPPPAuthProtocol                          "AuthProtocol"                 CFArray[CFString]
 *
 *   --- kSCPropNetPPPAuthPasswordEncryption values ---
 *   kSCValNetPPPAuthPasswordEncryptionKeychain         "Keychain"
 *   kSCValNetPPPAuthPasswordEncryptionToken            "Token"
 *
 *   --- kSCPropNetPPPAuthPrompt values ---
 *   kSCValNetPPPAuthPromptBefore                       "Before"                       CFString
 *   kSCValNetPPPAuthPromptAfter                        "After"                        CFString
 *
 *   --- kSCPropNetPPPAuthProtocol values ---
 *   kSCValNetPPPAuthProtocolCHAP                       "CHAP"                         CFString
 *   kSCValNetPPPAuthProtocolEAP                        "EAP"                          CFString
 *   kSCValNetPPPAuthProtocolMSCHAP1                    "MSCHAP1"                      CFString
 *   kSCValNetPPPAuthProtocolMSCHAP2                    "MSCHAP2"                      CFString
 *   kSCValNetPPPAuthProtocolPAP                        "PAP"                          CFString
 *
 *   --- Comm: ---
 *   kSCPropNetPPPCommAlternateRemoteAddress            "CommAlternateRemoteAddress"   CFString
 *   kSCPropNetPPPCommConnectDelay                      "CommConnectDelay"             CFNumber
 *   kSCPropNetPPPCommDisplayTerminalWindow             "CommDisplayTerminalWindow"    CFNumber (0 or 1)
 *   kSCPropNetPPPCommRedialCount                       "CommRedialCount"              CFNumber
 *   kSCPropNetPPPCommRedialEnabled                     "CommRedialEnabled"            CFNumber (0 or 1)
 *   kSCPropNetPPPCommRedialInterval                    "CommRedialInterval"           CFNumber
 *   kSCPropNetPPPCommRemoteAddress                     "CommRemoteAddress"            CFString
 *   kSCPropNetPPPCommTerminalScript                    "CommTerminalScript"           CFString
 *   kSCPropNetPPPCommUseTerminalScript                 "CommUseTerminalScript"        CFNumber (0 or 1)
 *
 *   --- CCP: ---
 *   kSCPropNetPPPCCPEnabled                            "CCPEnabled"                   CFNumber (0 or 1)
 *   kSCPropNetPPPCCPMPPE40Enabled                      "CCPMPPE40Enabled"             CFNumber (0 or 1)
 *   kSCPropNetPPPCCPMPPE128Enabled                     "CCPMPPE128Enabled"            CFNumber (0 or 1)
 *
 *   --- IPCP: ---
 *   kSCPropNetPPPIPCPCompressionVJ                     "IPCPCompressionVJ"            CFNumber (0 or 1)
 *   kSCPropNetPPPIPCPUsePeerDNS                        "IPCPUsePeerDNS"               CFNumber (0 or 1)
 *
 *   --- LCP: ---
 *   kSCPropNetPPPLCPEchoEnabled                        "LCPEchoEnabled"               CFNumber (0 or 1)
 *   kSCPropNetPPPLCPEchoFailure                        "LCPEchoFailure"               CFNumber
 *   kSCPropNetPPPLCPEchoInterval                       "LCPEchoInterval"              CFNumber
 *   kSCPropNetPPPLCPCompressionACField                 "LCPCompressionACField"        CFNumber (0 or 1)
 *   kSCPropNetPPPLCPCompressionPField                  "LCPCompressionPField"         CFNumber (0 or 1)
 *   kSCPropNetPPPLCPMRU                                "LCPMRU"                       CFNumber
 *   kSCPropNetPPPLCPMTU                                "LCPMTU"                       CFNumber
 *   kSCPropNetPPPLCPReceiveACCM                        "LCPReceiveACCM"               CFNumber
 *   kSCPropNetPPPLCPTransmitACCM                       "LCPTransmitACCM"              CFNumber
 *
 * kSCEntNetPPPoE Entity Keys
 *
 *   * RESERVED FOR FUTURE USE *
 *
 * kSCEntNetPPPSerial Entity Keys
 *
 *   * RESERVED FOR FUTURE USE *
 *
 * kSCEntNetPPTP Entity Keys
 *
 *   * RESERVED FOR FUTURE USE *
 *
 * kSCEntNetL2TP Entity Keys
 *
 *   kSCPropNetL2TPIPSecSharedSecret                    "IPSecSharedSecret"            CFString
 *   kSCPropNetL2TPIPSecSharedSecretEncryption          "IPSecSharedSecretEncryption"  CFString
 *   kSCPropNetL2TPTransport                            "Transport"                    CFString
 *
 *   --- kSCPropNetL2TPIPSecSharedSecretEncryption values ---
 *   kSCValNetL2TPIPSecSharedSecretEncryptionKeychain   "Keychain"
 *
 *   --- kSCPropNetL2TPTransport values ---
 *   kSCValNetL2TPTransportIP                           "IP"
 *   kSCValNetL2TPTransportIPSec                        "IPSec"
 *
 * kSCEntNetProxies Entity Keys
 *
 *   kSCPropNetProxiesExceptionsList                    "ExceptionsList"               CFArray[CFString]
 *   kSCPropNetProxiesExcludeSimpleHostnames            "ExcludeSimpleHostnames"       CFNumber (0 or 1)
 *   kSCPropNetProxiesFTPEnable                         "FTPEnable"                    CFNumber (0 or 1)
 *   kSCPropNetProxiesFTPPassive                        "FTPPassive"                   CFNumber (0 or 1)
 *   kSCPropNetProxiesFTPPort                           "FTPPort"                      CFNumber
 *   kSCPropNetProxiesFTPProxy                          "FTPProxy"                     CFString
 *   kSCPropNetProxiesGopherEnable                      "GopherEnable"                 CFNumber (0 or 1)
 *   kSCPropNetProxiesGopherPort                        "GopherPort"                   CFNumber
 *   kSCPropNetProxiesGopherProxy                       "GopherProxy"                  CFString
 *   kSCPropNetProxiesHTTPEnable                        "HTTPEnable"                   CFNumber (0 or 1)
 *   kSCPropNetProxiesHTTPPort                          "HTTPPort"                     CFNumber
 *   kSCPropNetProxiesHTTPProxy                         "HTTPProxy"                    CFString
 *   kSCPropNetProxiesHTTPSEnable                       "HTTPSEnable"                  CFNumber (0 or 1)
 *   kSCPropNetProxiesHTTPSPort                         "HTTPSPort"                    CFNumber
 *   kSCPropNetProxiesHTTPSProxy                        "HTTPSProxy"                   CFString
 *   kSCPropNetProxiesRTSPEnable                        "RTSPEnable"                   CFNumber (0 or 1)
 *   kSCPropNetProxiesRTSPPort                          "RTSPPort"                     CFNumber
 *   kSCPropNetProxiesRTSPProxy                         "RTSPProxy"                    CFString
 *   kSCPropNetProxiesSOCKSEnable                       "SOCKSEnable"                  CFNumber (0 or 1)
 *   kSCPropNetProxiesSOCKSPort                         "SOCKSPort"                    CFNumber
 *   kSCPropNetProxiesSOCKSProxy                        "SOCKSProxy"                   CFString
 *   kSCPropNetProxiesProxyAutoConfigEnable             "ProxyAutoConfigEnable"        CFNumber (0 or 1)
 *   kSCPropNetProxiesProxyAutoConfigJavaScript         "ProxyAutoConfigJavaScript"    CFString
 *   kSCPropNetProxiesProxyAutoConfigURLString          "ProxyAutoConfigURLString"     CFString
 *   kSCPropNetProxiesProxyAutoDiscoveryEnable          "ProxyAutoDiscoveryEnable"     CFNumber (0 or 1)
 *
 * kSCEntNetSMB Entity Keys
 *
 *   kSCPropNetSMBNetBIOSName                           "NetBIOSName"                  CFString
 *   kSCPropNetSMBNetBIOSNodeType                       "NetBIOSNodeType"              CFString
 *   kSCPropNetSMBNetBIOSScope                          "NetBIOSScope"                 CFString
 *   kSCPropNetSMBWINSAddresses                         "WINSAddresses"                CFArray[CFString]
 *   kSCPropNetSMBWorkgroup                             "Workgroup"                    CFString
 *
 *   --- kSCPropNetSMBNetBIOSNodeType values ---
 *   kSCValNetSMBNetBIOSNodeTypeBroadcast               "Broadcast"
 *   kSCValNetSMBNetBIOSNodeTypePeer                    "Peer"
 *   kSCValNetSMBNetBIOSNodeTypeMixed                   "Mixed"
 *   kSCValNetSMBNetBIOSNodeTypeHybrid                  "Hybrid"
 *
 * kSCCompUsers Entity Keys
 *
 *   kSCEntUsersConsoleUser                             "ConsoleUser"
 *
 * kSCCompSystem Properties
 *
 *   kSCPropSystemComputerName                          "ComputerName"                 CFString
 *   kSCPropSystemComputerNameEncoding                  "ComputerNameEncoding"         CFNumber
 *
 * SCDynamicStore "domain" prefixes
 *
 *   kSCDynamicStoreDomainFile                          "File:"
 *   kSCDynamicStoreDomainPlugin                        "Plugin:"
 *   kSCDynamicStoreDomainSetup                         "Setup:"
 *   kSCDynamicStoreDomainState                         "State:"
 *   kSCDynamicStoreDomainPrefs                         "Prefs:"
 *
 * Preference ("location") Keys
 *
 *   kSCDynamicStorePropSetupCurrentSet                 "CurrentSet"                   CFString
 *   kSCDynamicStorePropSetupLastUpdated                "LastUpdated"
 *
 * Common/shared Keys
 *
 *   kSCDynamicStorePropNetInterfaces                   "Interfaces"                   CFArray[CFString]
 *   kSCDynamicStorePropNetPrimaryInterface             "PrimaryInterface"             CFString
 *   kSCDynamicStorePropNetPrimaryService               "PrimaryService"               CFString
 *   kSCDynamicStorePropNetServiceIDs                   "ServiceIDs"                   CFArray[CFString]
 */


#ifndef	_SCSCHEMADEFINITIONS_H
#define	_SCSCHEMADEFINITIONS_H

#include <Availability.h>
#include <TargetConditionals.h>
#include <CoreFoundation/CFString.h>

/*!
 *	@header SCSchemaDefinitions
 */


CF_ASSUME_NONNULL_BEGIN

/*!
  @const kSCResvLink
  @discussion Value is a CFString
 */
extern const CFStringRef kSCResvLink                                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCResvLink kSCResvLink

/*!
  @const kSCResvInactive
 */
extern const CFStringRef kSCResvInactive                                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCResvInactive kSCResvInactive

/*!
  @const kSCPropInterfaceName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropInterfaceName                               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropInterfaceName kSCPropInterfaceName

/*!
  @const kSCPropMACAddress
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropMACAddress                                  __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropMACAddress kSCPropMACAddress

/*!
  @const kSCPropUserDefinedName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropUserDefinedName                             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropUserDefinedName kSCPropUserDefinedName

/*!
  @const kSCPropVersion
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropVersion                                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropVersion kSCPropVersion

/*!
  @group Preference Keys
 */

/*!
  @const kSCPrefCurrentSet
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPrefCurrentSet                                  __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPrefCurrentSet kSCPrefCurrentSet

/*!
  @const kSCPrefNetworkServices
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCPrefNetworkServices                             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPrefNetworkServices kSCPrefNetworkServices

/*!
  @const kSCPrefSets
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCPrefSets                                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPrefSets kSCPrefSets

/*!
  @const kSCPrefSystem
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCPrefSystem                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPrefSystem kSCPrefSystem

/*!
  @group Component Keys
 */

/*!
  @const kSCCompNetwork
 */
extern const CFStringRef kSCCompNetwork                                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompNetwork kSCCompNetwork

/*!
  @const kSCCompService
 */
extern const CFStringRef kSCCompService                                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompService kSCCompService

/*!
  @const kSCCompGlobal
 */
extern const CFStringRef kSCCompGlobal                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompGlobal kSCCompGlobal

/*!
  @const kSCCompHostNames
 */
extern const CFStringRef kSCCompHostNames                                   __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCCompHostNames kSCCompHostNames

/*!
  @const kSCCompInterface
 */
extern const CFStringRef kSCCompInterface                                   __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompInterface kSCCompInterface

/*!
  @const kSCCompSystem
 */
extern const CFStringRef kSCCompSystem                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompSystem kSCCompSystem

/*!
  @const kSCCompUsers
 */
extern const CFStringRef kSCCompUsers                                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompUsers kSCCompUsers

/*!
  @const kSCCompAnyRegex
 */
extern const CFStringRef kSCCompAnyRegex                                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCCompAnyRegex kSCCompAnyRegex

/*!
  @group Network Entity Keys
 */

/*!
  @const kSCEntNetAirPort
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetAirPort                                   __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetAirPort kSCEntNetAirPort

/*!
  @const kSCEntNetAppleTalk
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetAppleTalk                                 __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCEntNetAppleTalk kSCEntNetAppleTalk

/*!
  @const kSCEntNetDHCP
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetDHCP                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetDHCP kSCEntNetDHCP

/*!
  @const kSCEntNetDNS
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetDNS                                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetDNS kSCEntNetDNS

/*!
  @const kSCEntNetEthernet
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetEthernet                                  __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetEthernet kSCEntNetEthernet

/*!
  @const kSCEntNetFireWire
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetFireWire                                  __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCEntNetFireWire kSCEntNetFireWire

/*!
  @const kSCEntNetInterface
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetInterface                                 __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetInterface kSCEntNetInterface

/*!
  @const kSCEntNetIPSec
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetIPSec                                     __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCEntNetIPSec kSCEntNetIPSec

/*!
  @const kSCEntNetIPv4
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetIPv4                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetIPv4 kSCEntNetIPv4

/*!
  @const kSCEntNetIPv6
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetIPv6                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetIPv6 kSCEntNetIPv6

/*!
  @const kSCEntNetL2TP
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetL2TP                                      __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCEntNetL2TP kSCEntNetL2TP

/*!
  @const kSCEntNetLink
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetLink                                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetLink kSCEntNetLink

/*!
  @const kSCEntNetModem
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetModem                                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetModem kSCEntNetModem

/*!
  @const kSCEntNetNetInfo
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetNetInfo                                   __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCEntNetNetInfo kSCEntNetNetInfo

/*!
  @const kSCEntNetPPP
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetPPP                                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetPPP kSCEntNetPPP

/*!
  @const kSCEntNetPPPoE
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetPPPoE                                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetPPPoE kSCEntNetPPPoE

/*!
  @const kSCEntNetPPPSerial
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetPPPSerial                                 __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCEntNetPPPSerial kSCEntNetPPPSerial

/*!
  @const kSCEntNetPPTP
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetPPTP                                      __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCEntNetPPTP kSCEntNetPPTP

/*!
  @const kSCEntNetProxies
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetProxies                                   __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntNetProxies kSCEntNetProxies

/*!
  @const kSCEntNetSMB
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNetSMB                                       __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCEntNetSMB kSCEntNetSMB

/*!
  @const kSCEntNet6to4
  @discussion Value is a CFDictionary
 */
extern const CFStringRef kSCEntNet6to4                                      __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCEntNet6to4 kSCEntNet6to4

/*!
  @group kSCCompNetwork Properties
 */

/*!
  @const kSCPropNetOverridePrimary
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetOverridePrimary                          __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetOverridePrimary kSCPropNetOverridePrimary

/*!
  @const kSCPropNetServiceOrder
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetServiceOrder                             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetServiceOrder kSCPropNetServiceOrder

/*!
  @const kSCPropNetPPPOverridePrimary
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPOverridePrimary                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPOverridePrimary kSCPropNetPPPOverridePrimary

/*!
  @group kSCCompNetworkInterface Properties
 */

/*!
  @const kSCPropNetInterfaces
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetInterfaces                               __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetInterfaces kSCPropNetInterfaces

/*!
  @group kSCCompNetworkHostNames Properties
 */

/*!
  @const kSCPropNetLocalHostName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetLocalHostName                            __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetLocalHostName kSCPropNetLocalHostName

/*!
  @group kSCEntNetAirPort (Hardware) Entity Keys
 */

/*!
  @const kSCPropNetAirPortAllowNetCreation
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetAirPortAllowNetCreation                  __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortAllowNetCreation kSCPropNetAirPortAllowNetCreation

/*!
  @const kSCPropNetAirPortAuthPassword
  @discussion Value is a CFData
 */
extern const CFStringRef kSCPropNetAirPortAuthPassword                      __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortAuthPassword kSCPropNetAirPortAuthPassword

/*!
  @const kSCPropNetAirPortAuthPasswordEncryption
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetAirPortAuthPasswordEncryption            __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortAuthPasswordEncryption kSCPropNetAirPortAuthPasswordEncryption

/*!
  @const kSCPropNetAirPortJoinMode
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetAirPortJoinMode                          __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortJoinMode kSCPropNetAirPortJoinMode

/*!
  @const kSCPropNetAirPortPowerEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetAirPortPowerEnabled                      __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortPowerEnabled kSCPropNetAirPortPowerEnabled

/*!
  @const kSCPropNetAirPortPreferredNetwork
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetAirPortPreferredNetwork                  __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortPreferredNetwork kSCPropNetAirPortPreferredNetwork

/*!
  @const kSCPropNetAirPortSavePasswords
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetAirPortSavePasswords                     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAirPortSavePasswords kSCPropNetAirPortSavePasswords

/*!
  @const kSCValNetAirPortJoinModeAutomatic
 */
extern const CFStringRef kSCValNetAirPortJoinModeAutomatic                  __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAirPortJoinModeAutomatic kSCValNetAirPortJoinModeAutomatic

/*!
  @const kSCValNetAirPortJoinModePreferred
 */
extern const CFStringRef kSCValNetAirPortJoinModePreferred                  __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAirPortJoinModePreferred kSCValNetAirPortJoinModePreferred

/*!
  @const kSCValNetAirPortJoinModeRanked
 */
extern const CFStringRef kSCValNetAirPortJoinModeRanked                     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAirPortJoinModeRanked kSCValNetAirPortJoinModeRanked

/*!
  @const kSCValNetAirPortJoinModeRecent
 */
extern const CFStringRef kSCValNetAirPortJoinModeRecent                     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAirPortJoinModeRecent kSCValNetAirPortJoinModeRecent

/*!
  @const kSCValNetAirPortJoinModeStrongest
 */
extern const CFStringRef kSCValNetAirPortJoinModeStrongest                  __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAirPortJoinModeStrongest kSCValNetAirPortJoinModeStrongest

/*!
  @const kSCValNetAirPortAuthPasswordEncryptionKeychain
 */
extern const CFStringRef kSCValNetAirPortAuthPasswordEncryptionKeychain     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3,__MAC_10_9,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAirPortAuthPasswordEncryptionKeychain kSCValNetAirPortAuthPasswordEncryptionKeychain

/*!
  @group kSCEntNetAppleTalk Entity Keys
 */

/*!
  @const kSCPropNetAppleTalkComputerName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetAppleTalkComputerName                    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkComputerName kSCPropNetAppleTalkComputerName

/*!
  @const kSCPropNetAppleTalkComputerNameEncoding
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetAppleTalkComputerNameEncoding            __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkComputerNameEncoding kSCPropNetAppleTalkComputerNameEncoding

/*!
  @const kSCPropNetAppleTalkConfigMethod
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetAppleTalkConfigMethod                    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkConfigMethod kSCPropNetAppleTalkConfigMethod

/*!
  @const kSCPropNetAppleTalkDefaultZone
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetAppleTalkDefaultZone                     __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkDefaultZone kSCPropNetAppleTalkDefaultZone

/*!
  @const kSCPropNetAppleTalkNetworkID
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetAppleTalkNetworkID                       __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkNetworkID kSCPropNetAppleTalkNetworkID

/*!
  @const kSCPropNetAppleTalkNetworkRange
  @discussion Value is a CFArray[CFNumber]
 */
extern const CFStringRef kSCPropNetAppleTalkNetworkRange                    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_2,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkNetworkRange kSCPropNetAppleTalkNetworkRange

/*!
  @const kSCPropNetAppleTalkNodeID
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetAppleTalkNodeID                          __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkNodeID kSCPropNetAppleTalkNodeID

/*!
  @const kSCPropNetAppleTalkSeedNetworkRange
  @discussion Value is a CFArray[CFNumber]
 */
extern const CFStringRef kSCPropNetAppleTalkSeedNetworkRange                __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkSeedNetworkRange kSCPropNetAppleTalkSeedNetworkRange

/*!
  @const kSCPropNetAppleTalkSeedZones
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetAppleTalkSeedZones                       __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetAppleTalkSeedZones kSCPropNetAppleTalkSeedZones

/*!
  @const kSCValNetAppleTalkConfigMethodNode
 */
extern const CFStringRef kSCValNetAppleTalkConfigMethodNode                 __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAppleTalkConfigMethodNode kSCValNetAppleTalkConfigMethodNode

/*!
  @const kSCValNetAppleTalkConfigMethodRouter
 */
extern const CFStringRef kSCValNetAppleTalkConfigMethodRouter               __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAppleTalkConfigMethodRouter kSCValNetAppleTalkConfigMethodRouter

/*!
  @const kSCValNetAppleTalkConfigMethodSeedRouter
 */
extern const CFStringRef kSCValNetAppleTalkConfigMethodSeedRouter           __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetAppleTalkConfigMethodSeedRouter kSCValNetAppleTalkConfigMethodSeedRouter

/*!
  @group kSCEntNetDNS Entity Keys
 */

/*!
  @const kSCPropNetDNSDomainName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetDNSDomainName                            __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetDNSDomainName kSCPropNetDNSDomainName

/*!
  @const kSCPropNetDNSOptions
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetDNSOptions                               __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetDNSOptions kSCPropNetDNSOptions

/*!
  @const kSCPropNetDNSSearchDomains
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetDNSSearchDomains                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetDNSSearchDomains kSCPropNetDNSSearchDomains

/*!
  @const kSCPropNetDNSSearchOrder
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetDNSSearchOrder                           __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetDNSSearchOrder kSCPropNetDNSSearchOrder

/*!
  @const kSCPropNetDNSServerAddresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetDNSServerAddresses                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetDNSServerAddresses kSCPropNetDNSServerAddresses

/*!
  @const kSCPropNetDNSServerPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetDNSServerPort                            __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetDNSServerPort kSCPropNetDNSServerPort

/*!
  @const kSCPropNetDNSServerTimeout
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetDNSServerTimeout                         __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetDNSServerTimeout kSCPropNetDNSServerTimeout

/*!
  @const kSCPropNetDNSSortList
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetDNSSortList                              __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetDNSSortList kSCPropNetDNSSortList

/*!
  @const kSCPropNetDNSSupplementalMatchDomains
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetDNSSupplementalMatchDomains              __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetDNSSupplementalMatchDomains kSCPropNetDNSSupplementalMatchDomains

/*!
  @const kSCPropNetDNSSupplementalMatchOrders
  @discussion Value is a CFArray[CFNumber]
 */
extern const CFStringRef kSCPropNetDNSSupplementalMatchOrders               __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetDNSSupplementalMatchOrders kSCPropNetDNSSupplementalMatchOrders

/*!
  @group kSCEntNetEthernet (Hardware) Entity Keys
 */

/*!
  @const kSCPropNetEthernetMediaSubType
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetEthernetMediaSubType                     __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetEthernetMediaSubType kSCPropNetEthernetMediaSubType

/*!
  @const kSCPropNetEthernetMediaOptions
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetEthernetMediaOptions                     __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetEthernetMediaOptions kSCPropNetEthernetMediaOptions

/*!
  @const kSCPropNetEthernetMTU
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetEthernetMTU                              __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetEthernetMTU kSCPropNetEthernetMTU

/*!
  @group kSCEntNetFireWire (Hardware) Entity Keys
 */

/*!
  @group kSCEntNetInterface Entity Keys
 */

/*!
  @const kSCPropNetInterfaceDeviceName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetInterfaceDeviceName                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetInterfaceDeviceName kSCPropNetInterfaceDeviceName

/*!
  @const kSCPropNetInterfaceHardware
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetInterfaceHardware                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetInterfaceHardware kSCPropNetInterfaceHardware

/*!
  @const kSCPropNetInterfaceType
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetInterfaceType                            __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetInterfaceType kSCPropNetInterfaceType

/*!
  @const kSCPropNetInterfaceSubType
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetInterfaceSubType                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetInterfaceSubType kSCPropNetInterfaceSubType

/*!
  @const kSCPropNetInterfaceSupportsModemOnHold
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetInterfaceSupportsModemOnHold             __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetInterfaceSupportsModemOnHold kSCPropNetInterfaceSupportsModemOnHold

/*!
  @const kSCValNetInterfaceTypeEthernet
 */
extern const CFStringRef kSCValNetInterfaceTypeEthernet                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetInterfaceTypeEthernet kSCValNetInterfaceTypeEthernet

/*!
  @const kSCValNetInterfaceTypeFireWire
 */
extern const CFStringRef kSCValNetInterfaceTypeFireWire                     __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetInterfaceTypeFireWire kSCValNetInterfaceTypeFireWire

/*!
  @const kSCValNetInterfaceTypePPP
 */
extern const CFStringRef kSCValNetInterfaceTypePPP                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetInterfaceTypePPP kSCValNetInterfaceTypePPP

/*!
  @const kSCValNetInterfaceType6to4
 */
extern const CFStringRef kSCValNetInterfaceType6to4                         __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetInterfaceType6to4 kSCValNetInterfaceType6to4

/*!
  @const kSCValNetInterfaceTypeIPSec
 */
extern const CFStringRef kSCValNetInterfaceTypeIPSec                        __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCValNetInterfaceTypeIPSec kSCValNetInterfaceTypeIPSec

/*!
  @const kSCValNetInterfaceSubTypePPPoE
 */
extern const CFStringRef kSCValNetInterfaceSubTypePPPoE                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetInterfaceSubTypePPPoE kSCValNetInterfaceSubTypePPPoE

/*!
  @const kSCValNetInterfaceSubTypePPPSerial
 */
extern const CFStringRef kSCValNetInterfaceSubTypePPPSerial                 __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetInterfaceSubTypePPPSerial kSCValNetInterfaceSubTypePPPSerial

/*!
  @const kSCValNetInterfaceSubTypePPTP
 */
extern const CFStringRef kSCValNetInterfaceSubTypePPTP                      __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCValNetInterfaceSubTypePPTP kSCValNetInterfaceSubTypePPTP

/*!
  @const kSCValNetInterfaceSubTypeL2TP
 */
extern const CFStringRef kSCValNetInterfaceSubTypeL2TP                      __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetInterfaceSubTypeL2TP kSCValNetInterfaceSubTypeL2TP

/*!
  @group kSCEntNetIPSec Entity Keys
 */

/*!
  @const kSCPropNetIPSecAuthenticationMethod
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecAuthenticationMethod                __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetIPSecAuthenticationMethod kSCPropNetIPSecAuthenticationMethod

/*!
  @const kSCPropNetIPSecLocalCertificate
  @discussion Value is a CFData
 */
extern const CFStringRef kSCPropNetIPSecLocalCertificate                    __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetIPSecLocalCertificate kSCPropNetIPSecLocalCertificate

/*!
  @const kSCPropNetIPSecLocalIdentifier
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecLocalIdentifier                     __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetIPSecLocalIdentifier kSCPropNetIPSecLocalIdentifier

/*!
  @const kSCPropNetIPSecLocalIdentifierType
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecLocalIdentifierType                 __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetIPSecLocalIdentifierType kSCPropNetIPSecLocalIdentifierType

/*!
  @const kSCPropNetIPSecSharedSecret
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecSharedSecret                        __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetIPSecSharedSecret kSCPropNetIPSecSharedSecret

/*!
  @const kSCPropNetIPSecSharedSecretEncryption
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecSharedSecretEncryption              __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetIPSecSharedSecretEncryption kSCPropNetIPSecSharedSecretEncryption

/*!
  @const kSCPropNetIPSecConnectTime
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetIPSecConnectTime                         __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecConnectTime kSCPropNetIPSecConnectTime

/*!
  @const kSCPropNetIPSecRemoteAddress
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecRemoteAddress                       __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecRemoteAddress kSCPropNetIPSecRemoteAddress

/*!
  @const kSCPropNetIPSecStatus
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetIPSecStatus                              __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecStatus kSCPropNetIPSecStatus

/*!
  @const kSCPropNetIPSecXAuthEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetIPSecXAuthEnabled                        __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecXAuthEnabled kSCPropNetIPSecXAuthEnabled

/*!
  @const kSCPropNetIPSecXAuthName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecXAuthName                           __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecXAuthName kSCPropNetIPSecXAuthName

/*!
  @const kSCPropNetIPSecXAuthPassword
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecXAuthPassword                       __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecXAuthPassword kSCPropNetIPSecXAuthPassword

/*!
  @const kSCPropNetIPSecXAuthPasswordEncryption
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPSecXAuthPasswordEncryption             __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCPropNetIPSecXAuthPasswordEncryption kSCPropNetIPSecXAuthPasswordEncryption

/*!
  @const kSCValNetIPSecAuthenticationMethodSharedSecret
 */
extern const CFStringRef kSCValNetIPSecAuthenticationMethodSharedSecret     __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetIPSecAuthenticationMethodSharedSecret kSCValNetIPSecAuthenticationMethodSharedSecret

/*!
  @const kSCValNetIPSecAuthenticationMethodCertificate
 */
extern const CFStringRef kSCValNetIPSecAuthenticationMethodCertificate      __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetIPSecAuthenticationMethodCertificate kSCValNetIPSecAuthenticationMethodCertificate

/*!
  @const kSCValNetIPSecAuthenticationMethodHybrid
 */
extern const CFStringRef kSCValNetIPSecAuthenticationMethodHybrid           __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetIPSecAuthenticationMethodHybrid kSCValNetIPSecAuthenticationMethodHybrid

/*!
  @const kSCValNetIPSecLocalIdentifierTypeKeyID
 */
extern const CFStringRef kSCValNetIPSecLocalIdentifierTypeKeyID             __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetIPSecLocalIdentifierTypeKeyID kSCValNetIPSecLocalIdentifierTypeKeyID

/*!
  @const kSCValNetIPSecSharedSecretEncryptionKeychain
 */
extern const CFStringRef kSCValNetIPSecSharedSecretEncryptionKeychain       __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetIPSecSharedSecretEncryptionKeychain kSCValNetIPSecSharedSecretEncryptionKeychain

/*!
  @const kSCValNetIPSecXAuthPasswordEncryptionKeychain
 */
extern const CFStringRef kSCValNetIPSecXAuthPasswordEncryptionKeychain      __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCValNetIPSecXAuthPasswordEncryptionKeychain kSCValNetIPSecXAuthPasswordEncryptionKeychain

/*!
  @const kSCValNetIPSecXAuthPasswordEncryptionPrompt
 */
extern const CFStringRef kSCValNetIPSecXAuthPasswordEncryptionPrompt        __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCValNetIPSecXAuthPasswordEncryptionPrompt kSCValNetIPSecXAuthPasswordEncryptionPrompt

/*!
  @group kSCEntNetIPv4 Entity Keys
 */

/*!
  @const kSCPropNetIPv4Addresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetIPv4Addresses                            __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4Addresses kSCPropNetIPv4Addresses

/*!
  @const kSCPropNetIPv4ConfigMethod
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPv4ConfigMethod                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4ConfigMethod kSCPropNetIPv4ConfigMethod

/*!
  @const kSCPropNetIPv4DHCPClientID
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPv4DHCPClientID                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4DHCPClientID kSCPropNetIPv4DHCPClientID

/*!
  @const kSCPropNetIPv4Router
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPv4Router                               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4Router kSCPropNetIPv4Router

/*!
  @const kSCPropNetIPv4SubnetMasks
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetIPv4SubnetMasks                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4SubnetMasks kSCPropNetIPv4SubnetMasks

/*!
  @const kSCPropNetIPv4DestAddresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetIPv4DestAddresses                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4DestAddresses kSCPropNetIPv4DestAddresses

/*!
  @const kSCPropNetIPv4BroadcastAddresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetIPv4BroadcastAddresses                   __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv4BroadcastAddresses kSCPropNetIPv4BroadcastAddresses

/*!
  @const kSCValNetIPv4ConfigMethodAutomatic
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodAutomatic                 __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodAutomatic kSCValNetIPv4ConfigMethodAutomatic

/*!
  @const kSCValNetIPv4ConfigMethodBOOTP
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodBOOTP                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodBOOTP kSCValNetIPv4ConfigMethodBOOTP

/*!
  @const kSCValNetIPv4ConfigMethodDHCP
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodDHCP                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodDHCP kSCValNetIPv4ConfigMethodDHCP

/*!
  @const kSCValNetIPv4ConfigMethodINFORM
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodINFORM                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodINFORM kSCValNetIPv4ConfigMethodINFORM

/*!
  @const kSCValNetIPv4ConfigMethodLinkLocal
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodLinkLocal                 __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodLinkLocal kSCValNetIPv4ConfigMethodLinkLocal

/*!
  @const kSCValNetIPv4ConfigMethodManual
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodManual                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodManual kSCValNetIPv4ConfigMethodManual

/*!
  @const kSCValNetIPv4ConfigMethodPPP
 */
extern const CFStringRef kSCValNetIPv4ConfigMethodPPP                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetIPv4ConfigMethodPPP kSCValNetIPv4ConfigMethodPPP

/*!
  @group kSCEntNetIPv6 Entity Keys
 */

/*!
  @const kSCPropNetIPv6Addresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetIPv6Addresses                            __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv6Addresses kSCPropNetIPv6Addresses

/*!
  @const kSCPropNetIPv6ConfigMethod
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPv6ConfigMethod                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetIPv6ConfigMethod kSCPropNetIPv6ConfigMethod

/*!
  @const kSCPropNetIPv6DestAddresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetIPv6DestAddresses                        __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetIPv6DestAddresses kSCPropNetIPv6DestAddresses

/*!
  @const kSCPropNetIPv6Flags
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetIPv6Flags                                __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetIPv6Flags kSCPropNetIPv6Flags

/*!
  @const kSCPropNetIPv6PrefixLength
  @discussion Value is a CFArray[CFNumber]
 */
extern const CFStringRef kSCPropNetIPv6PrefixLength                         __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetIPv6PrefixLength kSCPropNetIPv6PrefixLength

/*!
  @const kSCPropNetIPv6Router
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetIPv6Router                               __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetIPv6Router kSCPropNetIPv6Router

/*!
  @const kSCValNetIPv6ConfigMethodAutomatic
 */
extern const CFStringRef kSCValNetIPv6ConfigMethodAutomatic                 __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetIPv6ConfigMethodAutomatic kSCValNetIPv6ConfigMethodAutomatic

/*!
  @const kSCValNetIPv6ConfigMethodLinkLocal
 */
extern const CFStringRef kSCValNetIPv6ConfigMethodLinkLocal                 __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_NA);
#define kSCValNetIPv6ConfigMethodLinkLocal kSCValNetIPv6ConfigMethodLinkLocal

/*!
  @const kSCValNetIPv6ConfigMethodManual
 */
extern const CFStringRef kSCValNetIPv6ConfigMethodManual                    __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetIPv6ConfigMethodManual kSCValNetIPv6ConfigMethodManual

/*!
  @const kSCValNetIPv6ConfigMethodRouterAdvertisement
 */
extern const CFStringRef kSCValNetIPv6ConfigMethodRouterAdvertisement       __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetIPv6ConfigMethodRouterAdvertisement kSCValNetIPv6ConfigMethodRouterAdvertisement

/*!
  @const kSCValNetIPv6ConfigMethod6to4
 */
extern const CFStringRef kSCValNetIPv6ConfigMethod6to4                      __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetIPv6ConfigMethod6to4 kSCValNetIPv6ConfigMethod6to4

/*!
  @group kSCEntNet6to4 Entity Keys
 */

/*!
  @const kSCPropNet6to4Relay
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNet6to4Relay                                __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNet6to4Relay kSCPropNet6to4Relay

/*!
  @group kSCEntNetLink Entity Keys
 */

/*!
  @const kSCPropNetLinkActive
  @discussion Value is a CFBoolean
 */
extern const CFStringRef kSCPropNetLinkActive                               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetLinkActive kSCPropNetLinkActive

/*!
  @const kSCPropNetLinkDetaching
  @discussion Value is a CFBoolean
 */
extern const CFStringRef kSCPropNetLinkDetaching                            __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetLinkDetaching kSCPropNetLinkDetaching

/*!
  @group kSCEntNetModem (Hardware) Entity Keys
 */

/*!
  @const kSCPropNetModemAccessPointName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemAccessPointName                     __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetModemAccessPointName kSCPropNetModemAccessPointName

/*!
  @const kSCPropNetModemConnectionPersonality
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemConnectionPersonality               __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetModemConnectionPersonality kSCPropNetModemConnectionPersonality

/*!
  @const kSCPropNetModemConnectionScript
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemConnectionScript                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemConnectionScript kSCPropNetModemConnectionScript

/*!
  @const kSCPropNetModemConnectSpeed
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetModemConnectSpeed                        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemConnectSpeed kSCPropNetModemConnectSpeed

/*!
  @const kSCPropNetModemDataCompression
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemDataCompression                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemDataCompression kSCPropNetModemDataCompression

/*!
  @const kSCPropNetModemDeviceContextID
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemDeviceContextID                     __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetModemDeviceContextID kSCPropNetModemDeviceContextID

/*!
  @const kSCPropNetModemDeviceModel
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemDeviceModel                         __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetModemDeviceModel kSCPropNetModemDeviceModel

/*!
  @const kSCPropNetModemDeviceVendor
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemDeviceVendor                        __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetModemDeviceVendor kSCPropNetModemDeviceVendor

/*!
  @const kSCPropNetModemDialMode
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemDialMode                            __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemDialMode kSCPropNetModemDialMode

/*!
  @const kSCPropNetModemErrorCorrection
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemErrorCorrection                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemErrorCorrection kSCPropNetModemErrorCorrection

/*!
  @const kSCPropNetModemHoldCallWaitingAudibleAlert
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemHoldCallWaitingAudibleAlert         __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemHoldCallWaitingAudibleAlert kSCPropNetModemHoldCallWaitingAudibleAlert

/*!
  @const kSCPropNetModemHoldDisconnectOnAnswer
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemHoldDisconnectOnAnswer              __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemHoldDisconnectOnAnswer kSCPropNetModemHoldDisconnectOnAnswer

/*!
  @const kSCPropNetModemHoldEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemHoldEnabled                         __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemHoldEnabled kSCPropNetModemHoldEnabled

/*!
  @const kSCPropNetModemHoldReminder
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemHoldReminder                        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemHoldReminder kSCPropNetModemHoldReminder

/*!
  @const kSCPropNetModemHoldReminderTime
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetModemHoldReminderTime                    __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemHoldReminderTime kSCPropNetModemHoldReminderTime

/*!
  @const kSCPropNetModemNote
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetModemNote                                __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetModemNote kSCPropNetModemNote

/*!
  @const kSCPropNetModemPulseDial
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemPulseDial                           __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemPulseDial kSCPropNetModemPulseDial

/*!
  @const kSCPropNetModemSpeaker
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetModemSpeaker                             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemSpeaker kSCPropNetModemSpeaker

/*!
  @const kSCPropNetModemSpeed
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetModemSpeed                               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetModemSpeed kSCPropNetModemSpeed

/*!
  @const kSCValNetModemDialModeIgnoreDialTone
 */
extern const CFStringRef kSCValNetModemDialModeIgnoreDialTone               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetModemDialModeIgnoreDialTone kSCValNetModemDialModeIgnoreDialTone

/*!
  @const kSCValNetModemDialModeManual
 */
extern const CFStringRef kSCValNetModemDialModeManual                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetModemDialModeManual kSCValNetModemDialModeManual

/*!
  @const kSCValNetModemDialModeWaitForDialTone
 */
extern const CFStringRef kSCValNetModemDialModeWaitForDialTone              __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetModemDialModeWaitForDialTone kSCValNetModemDialModeWaitForDialTone

/*!
  @group kSCEntNetNetInfo Entity Keys
 */

/*!
  @const kSCPropNetNetInfoBindingMethods
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetNetInfoBindingMethods                    __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetNetInfoBindingMethods kSCPropNetNetInfoBindingMethods

/*!
  @const kSCPropNetNetInfoServerAddresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetNetInfoServerAddresses                   __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetNetInfoServerAddresses kSCPropNetNetInfoServerAddresses

/*!
  @const kSCPropNetNetInfoServerTags
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetNetInfoServerTags                        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetNetInfoServerTags kSCPropNetNetInfoServerTags

/*!
  @const kSCPropNetNetInfoBroadcastServerTag
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetNetInfoBroadcastServerTag                __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetNetInfoBroadcastServerTag kSCPropNetNetInfoBroadcastServerTag

/*!
  @const kSCValNetNetInfoBindingMethodsBroadcast
 */
extern const CFStringRef kSCValNetNetInfoBindingMethodsBroadcast            __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetNetInfoBindingMethodsBroadcast kSCValNetNetInfoBindingMethodsBroadcast

/*!
  @const kSCValNetNetInfoBindingMethodsDHCP
 */
extern const CFStringRef kSCValNetNetInfoBindingMethodsDHCP                 __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetNetInfoBindingMethodsDHCP kSCValNetNetInfoBindingMethodsDHCP

/*!
  @const kSCValNetNetInfoBindingMethodsManual
 */
extern const CFStringRef kSCValNetNetInfoBindingMethodsManual               __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetNetInfoBindingMethodsManual kSCValNetNetInfoBindingMethodsManual

/*!
  @const kSCValNetNetInfoDefaultServerTag
 */
extern const CFStringRef kSCValNetNetInfoDefaultServerTag                   __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_5,__IPHONE_NA,__IPHONE_NA);
#define kSCValNetNetInfoDefaultServerTag kSCValNetNetInfoDefaultServerTag

/*!
  @group kSCEntNetPPP Entity Keys
 */

/*!
  @const kSCPropNetPPPACSPEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPACSPEnabled                           __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetPPPACSPEnabled kSCPropNetPPPACSPEnabled

/*!
  @const kSCPropNetPPPConnectTime
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPConnectTime                           __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPConnectTime kSCPropNetPPPConnectTime

/*!
  @const kSCPropNetPPPDeviceLastCause
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPDeviceLastCause                       __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPDeviceLastCause kSCPropNetPPPDeviceLastCause

/*!
  @const kSCPropNetPPPDialOnDemand
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPDialOnDemand                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPDialOnDemand kSCPropNetPPPDialOnDemand

/*!
  @const kSCPropNetPPPDisconnectOnFastUserSwitch
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPDisconnectOnFastUserSwitch            __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetPPPDisconnectOnFastUserSwitch kSCPropNetPPPDisconnectOnFastUserSwitch

/*!
  @const kSCPropNetPPPDisconnectOnIdle
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPDisconnectOnIdle                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPDisconnectOnIdle kSCPropNetPPPDisconnectOnIdle

/*!
  @const kSCPropNetPPPDisconnectOnIdleTimer
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPDisconnectOnIdleTimer                 __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPDisconnectOnIdleTimer kSCPropNetPPPDisconnectOnIdleTimer

/*!
  @const kSCPropNetPPPDisconnectOnLogout
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPDisconnectOnLogout                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPDisconnectOnLogout kSCPropNetPPPDisconnectOnLogout

/*!
  @const kSCPropNetPPPDisconnectOnSleep
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPDisconnectOnSleep                     __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPDisconnectOnSleep kSCPropNetPPPDisconnectOnSleep

/*!
  @const kSCPropNetPPPDisconnectTime
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPDisconnectTime                        __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetPPPDisconnectTime kSCPropNetPPPDisconnectTime

/*!
  @const kSCPropNetPPPIdleReminderTimer
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPIdleReminderTimer                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPIdleReminderTimer kSCPropNetPPPIdleReminderTimer

/*!
  @const kSCPropNetPPPIdleReminder
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPIdleReminder                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPIdleReminder kSCPropNetPPPIdleReminder

/*!
  @const kSCPropNetPPPLastCause
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLastCause                             __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPLastCause kSCPropNetPPPLastCause

/*!
  @const kSCPropNetPPPLogfile
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPLogfile                               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLogfile kSCPropNetPPPLogfile

/*!
  @const kSCPropNetPPPPlugins
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetPPPPlugins                               __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPPlugins kSCPropNetPPPPlugins

/*!
  @const kSCPropNetPPPRetryConnectTime
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPRetryConnectTime                      __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetPPPRetryConnectTime kSCPropNetPPPRetryConnectTime

/*!
  @const kSCPropNetPPPSessionTimer
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPSessionTimer                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPSessionTimer kSCPropNetPPPSessionTimer

/*!
  @const kSCPropNetPPPStatus
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPStatus                                __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPStatus kSCPropNetPPPStatus

/*!
  @const kSCPropNetPPPUseSessionTimer
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPUseSessionTimer                       __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPUseSessionTimer kSCPropNetPPPUseSessionTimer

/*!
  @const kSCPropNetPPPVerboseLogging
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPVerboseLogging                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPVerboseLogging kSCPropNetPPPVerboseLogging

/*!
  @const kSCPropNetPPPAuthEAPPlugins
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetPPPAuthEAPPlugins                        __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetPPPAuthEAPPlugins kSCPropNetPPPAuthEAPPlugins

/*!
  @const kSCPropNetPPPAuthName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPAuthName                              __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPAuthName kSCPropNetPPPAuthName

/*!
  @const kSCPropNetPPPAuthPassword
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPAuthPassword                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPAuthPassword kSCPropNetPPPAuthPassword

/*!
  @const kSCPropNetPPPAuthPasswordEncryption
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPAuthPasswordEncryption                __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPAuthPasswordEncryption kSCPropNetPPPAuthPasswordEncryption

/*!
  @const kSCPropNetPPPAuthPrompt
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPAuthPrompt                            __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetPPPAuthPrompt kSCPropNetPPPAuthPrompt

/*!
  @const kSCPropNetPPPAuthProtocol
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetPPPAuthProtocol                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPAuthProtocol kSCPropNetPPPAuthProtocol

/*!
  @const kSCValNetPPPAuthPasswordEncryptionKeychain
 */
extern const CFStringRef kSCValNetPPPAuthPasswordEncryptionKeychain         __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetPPPAuthPasswordEncryptionKeychain kSCValNetPPPAuthPasswordEncryptionKeychain

/*!
  @const kSCValNetPPPAuthPasswordEncryptionToken
 */
extern const CFStringRef kSCValNetPPPAuthPasswordEncryptionToken            __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetPPPAuthPasswordEncryptionToken kSCValNetPPPAuthPasswordEncryptionToken

/*!
  @const kSCValNetPPPAuthPromptBefore
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthPromptBefore                       __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetPPPAuthPromptBefore kSCValNetPPPAuthPromptBefore

/*!
  @const kSCValNetPPPAuthPromptAfter
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthPromptAfter                        __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetPPPAuthPromptAfter kSCValNetPPPAuthPromptAfter

/*!
  @const kSCValNetPPPAuthProtocolCHAP
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthProtocolCHAP                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetPPPAuthProtocolCHAP kSCValNetPPPAuthProtocolCHAP

/*!
  @const kSCValNetPPPAuthProtocolEAP
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthProtocolEAP                        __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetPPPAuthProtocolEAP kSCValNetPPPAuthProtocolEAP

/*!
  @const kSCValNetPPPAuthProtocolMSCHAP1
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthProtocolMSCHAP1                    __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetPPPAuthProtocolMSCHAP1 kSCValNetPPPAuthProtocolMSCHAP1

/*!
  @const kSCValNetPPPAuthProtocolMSCHAP2
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthProtocolMSCHAP2                    __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetPPPAuthProtocolMSCHAP2 kSCValNetPPPAuthProtocolMSCHAP2

/*!
  @const kSCValNetPPPAuthProtocolPAP
  @discussion Value is a CFString
 */
extern const CFStringRef kSCValNetPPPAuthProtocolPAP                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCValNetPPPAuthProtocolPAP kSCValNetPPPAuthProtocolPAP

/*!
  @const kSCPropNetPPPCommAlternateRemoteAddress
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPCommAlternateRemoteAddress            __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommAlternateRemoteAddress kSCPropNetPPPCommAlternateRemoteAddress

/*!
  @const kSCPropNetPPPCommConnectDelay
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPCommConnectDelay                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommConnectDelay kSCPropNetPPPCommConnectDelay

/*!
  @const kSCPropNetPPPCommDisplayTerminalWindow
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPCommDisplayTerminalWindow             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommDisplayTerminalWindow kSCPropNetPPPCommDisplayTerminalWindow

/*!
  @const kSCPropNetPPPCommRedialCount
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPCommRedialCount                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommRedialCount kSCPropNetPPPCommRedialCount

/*!
  @const kSCPropNetPPPCommRedialEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPCommRedialEnabled                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommRedialEnabled kSCPropNetPPPCommRedialEnabled

/*!
  @const kSCPropNetPPPCommRedialInterval
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPCommRedialInterval                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommRedialInterval kSCPropNetPPPCommRedialInterval

/*!
  @const kSCPropNetPPPCommRemoteAddress
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPCommRemoteAddress                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommRemoteAddress kSCPropNetPPPCommRemoteAddress

/*!
  @const kSCPropNetPPPCommTerminalScript
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetPPPCommTerminalScript                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPCommTerminalScript kSCPropNetPPPCommTerminalScript

/*!
  @const kSCPropNetPPPCommUseTerminalScript
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPCommUseTerminalScript                 __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPCommUseTerminalScript kSCPropNetPPPCommUseTerminalScript

/*!
  @const kSCPropNetPPPCCPEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPCCPEnabled                            __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_NA);
#define kSCPropNetPPPCCPEnabled kSCPropNetPPPCCPEnabled

/*!
  @const kSCPropNetPPPCCPMPPE40Enabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPCCPMPPE40Enabled                      __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetPPPCCPMPPE40Enabled kSCPropNetPPPCCPMPPE40Enabled

/*!
  @const kSCPropNetPPPCCPMPPE128Enabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPCCPMPPE128Enabled                     __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetPPPCCPMPPE128Enabled kSCPropNetPPPCCPMPPE128Enabled

/*!
  @const kSCPropNetPPPIPCPCompressionVJ
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPIPCPCompressionVJ                     __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPIPCPCompressionVJ kSCPropNetPPPIPCPCompressionVJ

/*!
  @const kSCPropNetPPPIPCPUsePeerDNS
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPIPCPUsePeerDNS                        __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetPPPIPCPUsePeerDNS kSCPropNetPPPIPCPUsePeerDNS

/*!
  @const kSCPropNetPPPLCPEchoEnabled
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPLCPEchoEnabled                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPEchoEnabled kSCPropNetPPPLCPEchoEnabled

/*!
  @const kSCPropNetPPPLCPEchoFailure
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLCPEchoFailure                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPEchoFailure kSCPropNetPPPLCPEchoFailure

/*!
  @const kSCPropNetPPPLCPEchoInterval
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLCPEchoInterval                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPEchoInterval kSCPropNetPPPLCPEchoInterval

/*!
  @const kSCPropNetPPPLCPCompressionACField
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPLCPCompressionACField                 __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPCompressionACField kSCPropNetPPPLCPCompressionACField

/*!
  @const kSCPropNetPPPLCPCompressionPField
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetPPPLCPCompressionPField                  __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPCompressionPField kSCPropNetPPPLCPCompressionPField

/*!
  @const kSCPropNetPPPLCPMRU
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLCPMRU                                __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPMRU kSCPropNetPPPLCPMRU

/*!
  @const kSCPropNetPPPLCPMTU
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLCPMTU                                __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPMTU kSCPropNetPPPLCPMTU

/*!
  @const kSCPropNetPPPLCPReceiveACCM
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLCPReceiveACCM                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPReceiveACCM kSCPropNetPPPLCPReceiveACCM

/*!
  @const kSCPropNetPPPLCPTransmitACCM
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetPPPLCPTransmitACCM                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetPPPLCPTransmitACCM kSCPropNetPPPLCPTransmitACCM

/*!
  @group kSCEntNetPPPoE Entity Keys
 */

/*!
  @group kSCEntNetPPPSerial Entity Keys
 */

/*!
  @group kSCEntNetPPTP Entity Keys
 */

/*!
  @group kSCEntNetL2TP Entity Keys
 */

/*!
  @const kSCPropNetL2TPIPSecSharedSecret
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetL2TPIPSecSharedSecret                    __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetL2TPIPSecSharedSecret kSCPropNetL2TPIPSecSharedSecret

/*!
  @const kSCPropNetL2TPIPSecSharedSecretEncryption
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetL2TPIPSecSharedSecretEncryption          __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetL2TPIPSecSharedSecretEncryption kSCPropNetL2TPIPSecSharedSecretEncryption

/*!
  @const kSCPropNetL2TPTransport
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetL2TPTransport                            __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCPropNetL2TPTransport kSCPropNetL2TPTransport

/*!
  @const kSCValNetL2TPIPSecSharedSecretEncryptionKeychain
 */
extern const CFStringRef kSCValNetL2TPIPSecSharedSecretEncryptionKeychain   __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetL2TPIPSecSharedSecretEncryptionKeychain kSCValNetL2TPIPSecSharedSecretEncryptionKeychain

/*!
  @const kSCValNetL2TPTransportIP
 */
extern const CFStringRef kSCValNetL2TPTransportIP                           __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetL2TPTransportIP kSCValNetL2TPTransportIP

/*!
  @const kSCValNetL2TPTransportIPSec
 */
extern const CFStringRef kSCValNetL2TPTransportIPSec                        __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA);
#define kSCValNetL2TPTransportIPSec kSCValNetL2TPTransportIPSec

/*!
  @group kSCEntNetProxies Entity Keys
 */

/*!
  @const kSCPropNetProxiesExceptionsList
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetProxiesExceptionsList                    __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesExceptionsList kSCPropNetProxiesExceptionsList

/*!
  @const kSCPropNetProxiesExcludeSimpleHostnames
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesExcludeSimpleHostnames            __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetProxiesExcludeSimpleHostnames kSCPropNetProxiesExcludeSimpleHostnames

/*!
  @const kSCPropNetProxiesFTPEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesFTPEnable                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesFTPEnable kSCPropNetProxiesFTPEnable

/*!
  @const kSCPropNetProxiesFTPPassive
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesFTPPassive                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesFTPPassive kSCPropNetProxiesFTPPassive

/*!
  @const kSCPropNetProxiesFTPPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetProxiesFTPPort                           __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesFTPPort kSCPropNetProxiesFTPPort

/*!
  @const kSCPropNetProxiesFTPProxy
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesFTPProxy                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesFTPProxy kSCPropNetProxiesFTPProxy

/*!
  @const kSCPropNetProxiesGopherEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesGopherEnable                      __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesGopherEnable kSCPropNetProxiesGopherEnable

/*!
  @const kSCPropNetProxiesGopherPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetProxiesGopherPort                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesGopherPort kSCPropNetProxiesGopherPort

/*!
  @const kSCPropNetProxiesGopherProxy
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesGopherProxy                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesGopherProxy kSCPropNetProxiesGopherProxy

/*!
  @const kSCPropNetProxiesHTTPEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesHTTPEnable                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesHTTPEnable kSCPropNetProxiesHTTPEnable

/*!
  @const kSCPropNetProxiesHTTPPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetProxiesHTTPPort                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesHTTPPort kSCPropNetProxiesHTTPPort

/*!
  @const kSCPropNetProxiesHTTPProxy
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesHTTPProxy                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesHTTPProxy kSCPropNetProxiesHTTPProxy

/*!
  @const kSCPropNetProxiesHTTPSEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesHTTPSEnable                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesHTTPSEnable kSCPropNetProxiesHTTPSEnable

/*!
  @const kSCPropNetProxiesHTTPSPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetProxiesHTTPSPort                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesHTTPSPort kSCPropNetProxiesHTTPSPort

/*!
  @const kSCPropNetProxiesHTTPSProxy
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesHTTPSProxy                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesHTTPSProxy kSCPropNetProxiesHTTPSProxy

/*!
  @const kSCPropNetProxiesRTSPEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesRTSPEnable                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesRTSPEnable kSCPropNetProxiesRTSPEnable

/*!
  @const kSCPropNetProxiesRTSPPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetProxiesRTSPPort                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesRTSPPort kSCPropNetProxiesRTSPPort

/*!
  @const kSCPropNetProxiesRTSPProxy
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesRTSPProxy                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesRTSPProxy kSCPropNetProxiesRTSPProxy

/*!
  @const kSCPropNetProxiesSOCKSEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesSOCKSEnable                       __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesSOCKSEnable kSCPropNetProxiesSOCKSEnable

/*!
  @const kSCPropNetProxiesSOCKSPort
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropNetProxiesSOCKSPort                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesSOCKSPort kSCPropNetProxiesSOCKSPort

/*!
  @const kSCPropNetProxiesSOCKSProxy
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesSOCKSProxy                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropNetProxiesSOCKSProxy kSCPropNetProxiesSOCKSProxy

/*!
  @const kSCPropNetProxiesProxyAutoConfigEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesProxyAutoConfigEnable             __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetProxiesProxyAutoConfigEnable kSCPropNetProxiesProxyAutoConfigEnable

/*!
  @const kSCPropNetProxiesProxyAutoConfigJavaScript
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesProxyAutoConfigJavaScript         __OSX_AVAILABLE_STARTING(__MAC_10_7,__IPHONE_NA);
#define kSCPropNetProxiesProxyAutoConfigJavaScript kSCPropNetProxiesProxyAutoConfigJavaScript

/*!
  @const kSCPropNetProxiesProxyAutoConfigURLString
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetProxiesProxyAutoConfigURLString          __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetProxiesProxyAutoConfigURLString kSCPropNetProxiesProxyAutoConfigURLString

/*!
  @const kSCPropNetProxiesProxyAutoDiscoveryEnable
  @discussion Value is a CFNumber (0 or 1)
 */
extern const CFStringRef kSCPropNetProxiesProxyAutoDiscoveryEnable          __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_NA);
#define kSCPropNetProxiesProxyAutoDiscoveryEnable kSCPropNetProxiesProxyAutoDiscoveryEnable

/*!
  @group kSCEntNetSMB Entity Keys
 */

/*!
  @const kSCPropNetSMBNetBIOSName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetSMBNetBIOSName                           __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetSMBNetBIOSName kSCPropNetSMBNetBIOSName

/*!
  @const kSCPropNetSMBNetBIOSNodeType
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetSMBNetBIOSNodeType                       __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetSMBNetBIOSNodeType kSCPropNetSMBNetBIOSNodeType

/*!
  @const kSCPropNetSMBNetBIOSScope
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetSMBNetBIOSScope                          __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_7,__IPHONE_NA,__IPHONE_NA);
#define kSCPropNetSMBNetBIOSScope kSCPropNetSMBNetBIOSScope

/*!
  @const kSCPropNetSMBWINSAddresses
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCPropNetSMBWINSAddresses                         __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetSMBWINSAddresses kSCPropNetSMBWINSAddresses

/*!
  @const kSCPropNetSMBWorkgroup
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropNetSMBWorkgroup                             __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCPropNetSMBWorkgroup kSCPropNetSMBWorkgroup

/*!
  @const kSCValNetSMBNetBIOSNodeTypeBroadcast
 */
extern const CFStringRef kSCValNetSMBNetBIOSNodeTypeBroadcast               __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetSMBNetBIOSNodeTypeBroadcast kSCValNetSMBNetBIOSNodeTypeBroadcast

/*!
  @const kSCValNetSMBNetBIOSNodeTypePeer
 */
extern const CFStringRef kSCValNetSMBNetBIOSNodeTypePeer                    __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetSMBNetBIOSNodeTypePeer kSCValNetSMBNetBIOSNodeTypePeer

/*!
  @const kSCValNetSMBNetBIOSNodeTypeMixed
 */
extern const CFStringRef kSCValNetSMBNetBIOSNodeTypeMixed                   __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetSMBNetBIOSNodeTypeMixed kSCValNetSMBNetBIOSNodeTypeMixed

/*!
  @const kSCValNetSMBNetBIOSNodeTypeHybrid
 */
extern const CFStringRef kSCValNetSMBNetBIOSNodeTypeHybrid                  __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
#define kSCValNetSMBNetBIOSNodeTypeHybrid kSCValNetSMBNetBIOSNodeTypeHybrid

/*!
  @group kSCCompUsers Entity Keys
 */

/*!
  @const kSCEntUsersConsoleUser
 */
extern const CFStringRef kSCEntUsersConsoleUser                             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCEntUsersConsoleUser kSCEntUsersConsoleUser

/*!
  @group kSCCompSystem Properties
 */

/*!
  @const kSCPropSystemComputerName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropSystemComputerName                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropSystemComputerName kSCPropSystemComputerName

/*!
  @const kSCPropSystemComputerNameEncoding
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropSystemComputerNameEncoding                  __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCPropSystemComputerNameEncoding kSCPropSystemComputerNameEncoding

/*!
  @group SCDynamicStore "domain" prefixes
 */

/*!
  @const kSCDynamicStoreDomainFile
 */
extern const CFStringRef kSCDynamicStoreDomainFile                          __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStoreDomainFile kSCDynamicStoreDomainFile

/*!
  @const kSCDynamicStoreDomainPlugin
 */
extern const CFStringRef kSCDynamicStoreDomainPlugin                        __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStoreDomainPlugin kSCDynamicStoreDomainPlugin

/*!
  @const kSCDynamicStoreDomainSetup
 */
extern const CFStringRef kSCDynamicStoreDomainSetup                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStoreDomainSetup kSCDynamicStoreDomainSetup

/*!
  @const kSCDynamicStoreDomainState
 */
extern const CFStringRef kSCDynamicStoreDomainState                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStoreDomainState kSCDynamicStoreDomainState

/*!
  @const kSCDynamicStoreDomainPrefs
 */
extern const CFStringRef kSCDynamicStoreDomainPrefs                         __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStoreDomainPrefs kSCDynamicStoreDomainPrefs

/*!
  @group Preference ("location") Keys
 */

/*!
  @const kSCDynamicStorePropSetupCurrentSet
  @discussion Value is a CFString
 */
extern const CFStringRef kSCDynamicStorePropSetupCurrentSet                 __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStorePropSetupCurrentSet kSCDynamicStorePropSetupCurrentSet

/*!
  @const kSCDynamicStorePropSetupLastUpdated
 */
extern const CFStringRef kSCDynamicStorePropSetupLastUpdated                __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStorePropSetupLastUpdated kSCDynamicStorePropSetupLastUpdated

/*!
  @group Common/shared Keys
 */

/*!
  @const kSCDynamicStorePropNetInterfaces
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCDynamicStorePropNetInterfaces                   __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStorePropNetInterfaces kSCDynamicStorePropNetInterfaces

/*!
  @const kSCDynamicStorePropNetPrimaryInterface
  @discussion Value is a CFString
 */
extern const CFStringRef kSCDynamicStorePropNetPrimaryInterface             __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStorePropNetPrimaryInterface kSCDynamicStorePropNetPrimaryInterface

/*!
  @const kSCDynamicStorePropNetPrimaryService
  @discussion Value is a CFString
 */
extern const CFStringRef kSCDynamicStorePropNetPrimaryService               __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStorePropNetPrimaryService kSCDynamicStorePropNetPrimaryService

/*!
  @const kSCDynamicStorePropNetServiceIDs
  @discussion Value is a CFArray[CFString]
 */
extern const CFStringRef kSCDynamicStorePropNetServiceIDs                   __OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_NA);
#define kSCDynamicStorePropNetServiceIDs kSCDynamicStorePropNetServiceIDs

/*!
  @const kSCPropUsersConsoleUserName
  @discussion Value is a CFString
 */
extern const CFStringRef kSCPropUsersConsoleUserName                        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_4,__IPHONE_NA,__IPHONE_NA);
#define kSCPropUsersConsoleUserName kSCPropUsersConsoleUserName

/*!
  @const kSCPropUsersConsoleUserUID
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropUsersConsoleUserUID                         __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_4,__IPHONE_NA,__IPHONE_NA);
#define kSCPropUsersConsoleUserUID kSCPropUsersConsoleUserUID

/*!
  @const kSCPropUsersConsoleUserGID
  @discussion Value is a CFNumber
 */
extern const CFStringRef kSCPropUsersConsoleUserGID                         __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_1,__MAC_10_4,__IPHONE_NA,__IPHONE_NA);
#define kSCPropUsersConsoleUserGID kSCPropUsersConsoleUserGID

CF_ASSUME_NONNULL_END

#endif	/* _SCSCHEMADEFINITIONS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    SystemConfiguration.h                                                                               0100644 0001750 0001750 00000015604 12567450664 040042  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Headers                                                         /*
 * Copyright (c) 2000-2004, 2006, 2008-2010, 2012, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _SYSTEMCONFIGURATION_H
#define _SYSTEMCONFIGURATION_H

#include <Availability.h>
#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>


/*!
	@header SystemConfiguration
	@discussion The System Configuration framework provides access to the
		data used to configure a running system.  The APIs provided
		by this framework communicate with the configd daemon.

		The configd daemon manages a dynamic store reflecting the
		desired configuration settings as well as the current state
		of the system.  The daemon provides a notification mechanism
		for processes that need to be aware of changes made to the
		data.  Lastly, the daemon loads a number of bundles (or
		plug-ins) that monitor low-level kernel events and, through
		a set of policy modules, keep the state data up to date.
 */

/*!
	@enum Error codes
	@discussion Returned error codes.
	@constant kSCStatusOK			Success
	@constant kSCStatusFailed		Non-specific Failure
	@constant kSCStatusInvalidArgument	Invalid argument
	@constant kSCStatusAccessError		Permission denied
	@constant kSCStatusNoKey		No such key
	@constant kSCStatusKeyExists		Data associated with key already defined
	@constant kSCStatusLocked		Lock already held
	@constant kSCStatusNeedLock		Lock required for this operation
	@constant kSCStatusNoStoreSession	Configuration daemon session not active
	@constant kSCStatusNoStoreServer	Configuration daemon not (or no longer) available
	@constant kSCStatusNotifierActive	Notifier is currently active
	@constant kSCStatusNoPrefsSession	Preferences session not active
	@constant kSCStatusPrefsBusy		Preferences update currently in progress
	@constant kSCStatusNoConfigFile		Configuration file not found
	@constant kSCStatusNoLink		No such link
	@constant kSCStatusStale		Write attempted on stale version of object
	@constant kSCStatusMaxLink		Maximum link count exceeded
	@constant kSCStatusReachabilityUnknown
		A determination could not be made regarding the reachability
		of the specified nodename or address.
	@constant kSCStatusConnectionNoService	Network service for connection not available
*/
enum {
	/*
	 * Generic error codes
	 */
	kSCStatusOK				= 0,	/* Success */
	kSCStatusFailed				= 1001,	/* Non-specific failure */
	kSCStatusInvalidArgument		= 1002,	/* Invalid argument */
	kSCStatusAccessError			= 1003,	/* Permission denied
							   - must be root to obtain lock
							   - could not create access/create preferences
							 */
	kSCStatusNoKey				= 1004,	/* No such key */
	kSCStatusKeyExists			= 1005,	/* Key already defined */
	kSCStatusLocked				= 1006,	/* Lock already held */
	kSCStatusNeedLock			= 1007,	/* Lock required for this operation */
	/*
	 * SCDynamicStore error codes
	 */
	kSCStatusNoStoreSession			= 2001,	/* Configuration daemon session not active */
	kSCStatusNoStoreServer			= 2002,	/* Configuration daemon not (no longer) available */
	kSCStatusNotifierActive			= 2003,	/* Notifier is currently active */
	/*
	 * SCPreferences error codes
	 */
	kSCStatusNoPrefsSession			= 3001,	/* Preference session not active */
	kSCStatusPrefsBusy			= 3002,	/* Preferences update currently in progress */
	kSCStatusNoConfigFile			= 3003,	/* Configuration file not found */
	kSCStatusNoLink				= 3004,	/* No such link */
	kSCStatusStale				= 3005,	/* Write attempted on stale version of object */
	kSCStatusMaxLink			= 3006,	/* Maximum link count exceeded */
	/*
	 * SCNetwork error codes
	 */
	kSCStatusReachabilityUnknown		= 4001,	/* Network reachability cannot be determined */
	/*
	 * SCNetworkConnection error codes
	 */
	kSCStatusConnectionNoService		= 5001,	/* Network service for connection not available
							   __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_2_0)
							 */
	kSCStatusConnectionIgnore               = 5002, /* Network connection information not available at this time
							   __OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_6_0)
							 */
};


/* SCDynamicStore APIs */
#include <SystemConfiguration/SCDynamicStore.h>
#include <SystemConfiguration/SCDynamicStoreKey.h>
#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>

/* SCPreferences APIs */
#include <SystemConfiguration/SCPreferences.h>
#include <SystemConfiguration/SCPreferencesPath.h>
#include <SystemConfiguration/SCPreferencesSetSpecific.h>

/* Schema Definitions (for SCDynamicStore and SCPreferences) */
#include <SystemConfiguration/SCSchemaDefinitions.h>

/* SCNetworkConfiguration APIs */
#include <SystemConfiguration/SCNetworkConfiguration.h>

/* SCNetworkReachability and SCNetworkConnection APIs */
#include <SystemConfiguration/SCNetwork.h>
#include <SystemConfiguration/SCNetworkReachability.h>
#include <SystemConfiguration/SCNetworkConnection.h>

CF_IMPLICIT_BRIDGING_ENABLED
CF_ASSUME_NONNULL_BEGIN

/*!
	@const kCFErrorDomainSystemConfiguration
	@discussion CFError domain associated with errors reported by
		the SystemConfiguration.framework.
 */
extern const CFStringRef	kCFErrorDomainSystemConfiguration	__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);

__BEGIN_DECLS

/*!
	@function SCCopyLastError
	@discussion Returns the most recent status or error code generated
		as the result of calling a System Configuration framework API.
	@result Returns the last error encountered.
 */
CFErrorRef	SCCopyLastError		(void)				__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);

/*!
	@function SCError
	@discussion Returns the most recent status or error code generated
		as the result of calling a System Configuration framework API.
	@result Returns the last error encountered.
 */
int		SCError			(void)				__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_2_0);

/*!
	@function SCErrorString
	@discussion Returns a pointer to the message string
		associated with the specified status or error.
	@param status The SCDynamicStoreStatus to be returned.
	@result Returns a pointer to the error message string.
 */
const char *	SCErrorString		(int	status)			__OSX_AVAILABLE_STARTING(__MAC_10_1,__IPHONE_2_0);

__END_DECLS

CF_ASSUME_NONNULL_END
CF_IMPLICIT_BRIDGING_DISABLED

#endif /* _SYSTEMCONFIGURATION_H */
                                                                                                                            Modules/                                                                                            0040755 0001750 0001750 00000000000 12612224746 033676  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A                                                                 module.modulemap                                                                                    0100644 0001750 0001750 00000000642 12567450706 037075  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/Modules                                                         framework module SystemConfiguration [extern_c] {
  umbrella header "SystemConfiguration.h"

  export *
  module * { export * }

  explicit module CaptiveNetwork {
    header "CaptiveNetwork.h"
    export *
  }

  explicit module DHCPClientPreferences {
    header "DHCPClientPreferences.h"
    export *
  }

  explicit module SCDynamicStoreCopyDHCPInfo {
    header "SCDynamicStoreCopyDHCPInfo.h"
    export *
  }
}

                                                                                              SystemConfiguration.tbd                                                                             0100644 0001750 0001750 00000126346 12571375071 037010  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions/A                                                                 ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration
current-version: 801.1.1
exports:         
  - archs:           [ i386, x86_64 ]
    symbols:         [ _CNCopySupportedInterfaces, _CNMarkPortalOffline, 
                       _CNMarkPortalOnline, _CNSetSupportedSSIDs, _DHCPClientPreferencesCopyApplicationOptions, 
                       _DHCPClientPreferencesSetApplicationOptions, _DHCPInfoGetLeaseExpirationTime, 
                       _DHCPInfoGetLeaseStartTime, _DHCPInfoGetOptionData, 
                       _DeviceOnHoldCreate, _DeviceOnHoldGetStatus, _DeviceOnHoldGetTypeID, 
                       _DeviceOnHoldResume, _DeviceOnHoldSuspend, _IPMonitorControlGetInterfacePrimaryRank, 
                       _IsDeviceOnHoldSupported, _SCBondInterfaceCopyAll, 
                       _SCBondInterfaceCopyAvailableMemberInterfaces, _SCBondInterfaceCopyStatus, 
                       _SCBondInterfaceCreate, _SCBondInterfaceGetMemberInterfaces, 
                       _SCBondInterfaceGetMode, _SCBondInterfaceGetOptions, 
                       _SCBondInterfaceRemove, _SCBondInterfaceSetLocalizedDisplayName, 
                       _SCBondInterfaceSetMemberInterfaces, _SCBondInterfaceSetMode, 
                       _SCBondInterfaceSetOptions, _SCBondStatusGetInterfaceStatus, 
                       _SCBondStatusGetMemberInterfaces, _SCBondStatusGetTypeID, 
                       _SCBridgeInterfaceCopyAll, _SCBridgeInterfaceCopyAvailableMemberInterfaces, 
                       _SCBridgeInterfaceCreate, _SCBridgeInterfaceGetMemberInterfaces, 
                       _SCBridgeInterfaceGetOptions, _SCBridgeInterfaceRemove, 
                       _SCBridgeInterfaceSetLocalizedDisplayName, _SCBridgeInterfaceSetMemberInterfaces, 
                       _SCBridgeInterfaceSetOptions, _SCCopyLastError, 
                       _SCDynamicStoreAddTemporaryValue, _SCDynamicStoreAddValue, 
                       _SCDynamicStoreAddWatchedKey, _SCDynamicStoreCopyComputerName, 
                       _SCDynamicStoreCopyConsoleInformation, _SCDynamicStoreCopyConsoleUser, 
                       _SCDynamicStoreCopyDHCPInfo, _SCDynamicStoreCopyKeyList, 
                       _SCDynamicStoreCopyLocalHostName, _SCDynamicStoreCopyLocation, 
                       _SCDynamicStoreCopyMultiple, _SCDynamicStoreCopyNotifiedKeys, 
                       _SCDynamicStoreCopyProxies, _SCDynamicStoreCopyProxiesWithOptions, 
                       _SCDynamicStoreCopyValue, _SCDynamicStoreCreate, 
                       _SCDynamicStoreCreateRunLoopSource, _SCDynamicStoreCreateWithOptions, 
                       _SCDynamicStoreGetTypeID, _SCDynamicStoreKeyCreate, 
                       _SCDynamicStoreKeyCreateComputerName, _SCDynamicStoreKeyCreateConsoleUser, 
                       _SCDynamicStoreKeyCreateHostNames, _SCDynamicStoreKeyCreateLocation, 
                       _SCDynamicStoreKeyCreateNetworkGlobalEntity, _SCDynamicStoreKeyCreateNetworkInterface, 
                       _SCDynamicStoreKeyCreateNetworkInterfaceEntity, 
                       _SCDynamicStoreKeyCreateNetworkServiceEntity, _SCDynamicStoreKeyCreatePreferences, 
                       _SCDynamicStoreKeyCreateProxies, _SCDynamicStoreNotifyCancel, 
                       _SCDynamicStoreNotifyFileDescriptor, _SCDynamicStoreNotifySignal, 
                       _SCDynamicStoreNotifyValue, _SCDynamicStoreNotifyWait, 
                       _SCDynamicStoreRemoveValue, _SCDynamicStoreRemoveWatchedKey, 
                       _SCDynamicStoreSetConsoleInformation, _SCDynamicStoreSetConsoleUser, 
                       _SCDynamicStoreSetDisconnectCallBack, _SCDynamicStoreSetDispatchQueue, 
                       _SCDynamicStoreSetMultiple, _SCDynamicStoreSetNotificationKeys, 
                       _SCDynamicStoreSetValue, _SCDynamicStoreSnapshot, 
                       _SCError, _SCErrorString, _SCLOG, _SCLog, _SCLoggerCreate, 
                       _SCLoggerGetFlags, _SCLoggerLog, _SCLoggerSetFlags, 
                       _SCLoggerVLog, _SCNetworkCheckReachabilityByAddress, 
                       _SCNetworkCheckReachabilityByName, _SCNetworkConnectionCanTunnelAddress, 
                       _SCNetworkConnectionCopyAllUserPreferences, _SCNetworkConnectionCopyAvailableServices, 
                       _SCNetworkConnectionCopyCurrentUserPreferences, 
                       _SCNetworkConnectionCopyExtendedStatus, _SCNetworkConnectionCopyFlowDivertToken, 
                       _SCNetworkConnectionCopyOnDemandInfo, _SCNetworkConnectionCopyServiceID, 
                       _SCNetworkConnectionCopyStatistics, _SCNetworkConnectionCopyUserOptions, 
                       _SCNetworkConnectionCopyUserPreferences, _SCNetworkConnectionCreate, 
                       _SCNetworkConnectionCreateUserPreferences, _SCNetworkConnectionCreateWithService, 
                       _SCNetworkConnectionCreateWithServiceID, _SCNetworkConnectionGetReachabilityInfo, 
                       _SCNetworkConnectionGetService, _SCNetworkConnectionGetServiceIdentifier, 
                       _SCNetworkConnectionGetStatus, _SCNetworkConnectionGetStatusFromNEStatus, 
                       _SCNetworkConnectionGetType, _SCNetworkConnectionGetTypeID, 
                       _SCNetworkConnectionIsOnDemandSuspended, _SCNetworkConnectionOnDemandShouldRetryOnFailure, 
                       _SCNetworkConnectionRefreshOnDemandState, _SCNetworkConnectionResume, 
                       _SCNetworkConnectionScheduleWithRunLoop, _SCNetworkConnectionSelectServiceWithOptions, 
                       _SCNetworkConnectionSetClientAuditInfo, _SCNetworkConnectionSetClientInfo, 
                       _SCNetworkConnectionSetDispatchQueue, _SCNetworkConnectionStart, 
                       _SCNetworkConnectionStartWithUserPreferences, _SCNetworkConnectionStop, 
                       _SCNetworkConnectionSuspend, _SCNetworkConnectionTriggerOnDemandIfNeeded, 
                       _SCNetworkConnectionUnscheduleFromRunLoop, _SCNetworkInterfaceCheckPassword, 
                       _SCNetworkInterfaceCopyAll, _SCNetworkInterfaceCopyCapability, 
                       _SCNetworkInterfaceCopyMTU, _SCNetworkInterfaceCopyMediaOptions, 
                       _SCNetworkInterfaceCopyMediaSubTypeOptions, _SCNetworkInterfaceCopyMediaSubTypes, 
                       _SCNetworkInterfaceCopyPassword, _SCNetworkInterfaceCreateWithInterface, 
                       _SCNetworkInterfaceForceConfigurationRefresh, _SCNetworkInterfaceGetBSDName, 
                       _SCNetworkInterfaceGetConfiguration, _SCNetworkInterfaceGetDisableUntilNeeded, 
                       _SCNetworkInterfaceGetExtendedConfiguration, _SCNetworkInterfaceGetHardwareAddressString, 
                       _SCNetworkInterfaceGetInterface, _SCNetworkInterfaceGetInterfaceType, 
                       _SCNetworkInterfaceGetLocalizedDisplayName, _SCNetworkInterfaceGetPrimaryRank, 
                       _SCNetworkInterfaceGetSupportedInterfaceTypes, _SCNetworkInterfaceGetSupportedProtocolTypes, 
                       _SCNetworkInterfaceGetTypeID, _SCNetworkInterfaceRefreshConfiguration, 
                       _SCNetworkInterfaceRemovePassword, _SCNetworkInterfaceSetCapability, 
                       _SCNetworkInterfaceSetConfiguration, _SCNetworkInterfaceSetDisableUntilNeeded, 
                       _SCNetworkInterfaceSetExtendedConfiguration, _SCNetworkInterfaceSetMTU, 
                       _SCNetworkInterfaceSetMediaOptions, _SCNetworkInterfaceSetPassword, 
                       _SCNetworkInterfaceSetPrimaryRank, _SCNetworkProtocolGetConfiguration, 
                       _SCNetworkProtocolGetEnabled, _SCNetworkProtocolGetProtocolType, 
                       _SCNetworkProtocolGetTypeID, _SCNetworkProtocolSetConfiguration, 
                       _SCNetworkProtocolSetEnabled, _SCNetworkProxiesCopyMatching, 
                       _SCNetworkProxiesCopyMatchingWithOptions, _SCNetworkReachabilityCopyResolvedAddress, 
                       _SCNetworkReachabilityCreateWithAddress, _SCNetworkReachabilityCreateWithAddressPair, 
                       _SCNetworkReachabilityCreateWithName, _SCNetworkReachabilityCreateWithOptions, 
                       _SCNetworkReachabilityGetFlags, _SCNetworkReachabilityGetInterfaceIndex, 
                       _SCNetworkReachabilityGetTypeID, _SCNetworkReachabilityScheduleWithRunLoop, 
                       _SCNetworkReachabilitySetCallback, _SCNetworkReachabilitySetDispatchQueue, 
                       _SCNetworkReachabilityUnscheduleFromRunLoop, _SCNetworkServiceAddProtocolType, 
                       _SCNetworkServiceCopy, _SCNetworkServiceCopyAll, 
                       _SCNetworkServiceCopyExternalID, _SCNetworkServiceCopyProtocol, 
                       _SCNetworkServiceCopyProtocols, _SCNetworkServiceCreate, 
                       _SCNetworkServiceEstablishDefaultConfiguration, 
                       _SCNetworkServiceGetEnabled, _SCNetworkServiceGetInterface, 
                       _SCNetworkServiceGetName, _SCNetworkServiceGetPrimaryRank, 
                       _SCNetworkServiceGetServiceID, _SCNetworkServiceGetTypeID, 
                       _SCNetworkServiceRemove, _SCNetworkServiceRemoveProtocolType, 
                       _SCNetworkServiceSetEnabled, _SCNetworkServiceSetExternalID, 
                       _SCNetworkServiceSetName, _SCNetworkServiceSetPrimaryRank, 
                       _SCNetworkSetAddService, _SCNetworkSetContainsInterface, 
                       _SCNetworkSetCopy, _SCNetworkSetCopyAll, _SCNetworkSetCopyAvailableInterfaces, 
                       _SCNetworkSetCopyCurrent, _SCNetworkSetCopySelectedVPNService, 
                       _SCNetworkSetCopyServices, _SCNetworkSetCreate, 
                       _SCNetworkSetEstablishDefaultConfiguration, _SCNetworkSetEstablishDefaultInterfaceConfiguration, 
                       _SCNetworkSetGetName, _SCNetworkSetGetServiceOrder, 
                       _SCNetworkSetGetSetID, _SCNetworkSetGetTypeID, _SCNetworkSetRemove, 
                       _SCNetworkSetRemoveService, _SCNetworkSetSetCurrent, 
                       _SCNetworkSetSetName, _SCNetworkSetSetSelectedVPNService, 
                       _SCNetworkSetSetServiceOrder, _SCNetworkSignatureCopyActiveIdentifierForAddress, 
                       _SCNetworkSignatureCopyActiveIdentifiers, _SCNetworkSignatureCopyIdentifierForConnectedSocket, 
                       _SCPreferencesAddValue, _SCPreferencesApplyChanges, 
                       _SCPreferencesCommitChanges, _SCPreferencesCopyKeyList, 
                       _SCPreferencesCreate, _SCPreferencesCreateWithAuthorization, 
                       _SCPreferencesCreateWithOptions, _SCPreferencesGetHostName, 
                       _SCPreferencesGetSignature, _SCPreferencesGetTypeID, 
                       _SCPreferencesGetValue, _SCPreferencesLock, _SCPreferencesPathCreateUniqueChild, 
                       _SCPreferencesPathGetLink, _SCPreferencesPathGetValue, 
                       _SCPreferencesPathRemoveValue, _SCPreferencesPathSetLink, 
                       _SCPreferencesPathSetValue, _SCPreferencesRemoveAllValues, 
                       _SCPreferencesRemoveValue, _SCPreferencesScheduleWithRunLoop, 
                       _SCPreferencesSetCallback, _SCPreferencesSetComputerName, 
                       _SCPreferencesSetDispatchQueue, _SCPreferencesSetHostName, 
                       _SCPreferencesSetLocalHostName, _SCPreferencesSetValue, 
                       _SCPreferencesSynchronize, _SCPreferencesUnlock, 
                       _SCPreferencesUnscheduleFromRunLoop, _SCPrint, _SCTrace, 
                       _SCUserPreferencesCheckInterfacePassword, _SCUserPreferencesCopyExtendedInterfaceConfiguration, 
                       _SCUserPreferencesCopyInterfaceConfiguration, _SCUserPreferencesCopyInterfacePassword, 
                       _SCUserPreferencesCopyName, _SCUserPreferencesGetTypeID, 
                       _SCUserPreferencesGetUniqueID, _SCUserPreferencesIsForced, 
                       _SCUserPreferencesRemove, _SCUserPreferencesRemoveInterfacePassword, 
                       _SCUserPreferencesSetCurrent, _SCUserPreferencesSetExtendedInterfaceConfiguration, 
                       _SCUserPreferencesSetInterfaceConfiguration, _SCUserPreferencesSetInterfacePassword, 
                       _SCUserPreferencesSetName, _SCVLANInterfaceCopyAll, 
                       _SCVLANInterfaceCopyAvailablePhysicalInterfaces, 
                       _SCVLANInterfaceCreate, _SCVLANInterfaceGetOptions, 
                       _SCVLANInterfaceGetPhysicalInterface, _SCVLANInterfaceGetTag, 
                       _SCVLANInterfaceRemove, _SCVLANInterfaceSetLocalizedDisplayName, 
                       _SCVLANInterfaceSetOptions, _SCVLANInterfaceSetPhysicalInterfaceAndTag, 
                       _SystemConfigurationVersionNumber, _SystemConfigurationVersionString, 
                       _VPNAppLayerCopyMatchingService, _VPNAppLayerGetMatchingServiceIdentifier, 
                       _VPNApplicationInstalled, _VPNApplicationRemoved, 
                       _VPNConfigurationConnectionStart, _VPNConfigurationConnectionStop, 
                       _VPNConfigurationCopy, _VPNConfigurationCopyAll, 
                       _VPNConfigurationCopyAppRule, _VPNConfigurationCopyAppRuleIDs, 
                       _VPNConfigurationCopyCertificate, _VPNConfigurationCopyIdentities, 
                       _VPNConfigurationCopyLastConnectionError, _VPNConfigurationCopyPersistentData, 
                       _VPNConfigurationCopyVendorData, _VPNConfigurationCreate, 
                       _VPNConfigurationCreateWithOptions, _VPNConfigurationEnableVPNType, 
                       _VPNConfigurationGetEnabled, _VPNConfigurationGetName, 
                       _VPNConfigurationGetStatus, _VPNConfigurationGetTunnelType, 
                       _VPNConfigurationIsVPNTypeEnabled, _VPNConfigurationRemove, 
                       _VPNConfigurationRemoveAppRule, _VPNConfigurationScheduleWithRunLoop, 
                       _VPNConfigurationSendMessage, _VPNConfigurationSet, 
                       _VPNConfigurationSetAppRule, _VPNConfigurationSetAuthorization, 
                       _VPNConfigurationSetCallback, _VPNConfigurationSetEnabled, 
                       _VPNConfigurationSetMessageCallback, _VPNConfigurationSetName, 
                       _VPNConfigurationSetPersistentData, _VPNConfigurationSetVendorData, 
                       _VPNConfigurationUnscheduleFromRunLoop, _VPNConfigurationValidateCertificate, 
                       _VPNCopyLastError, _VPNFlowCanAcceptBytes, _VPNFlowCopyError, 
                       _VPNFlowCopyProperty, _VPNFlowDatagramCopyNext, 
                       _VPNFlowDatagramSend, _VPNFlowGetTypeID, _VPNFlowHasBytesAvailable, 
                       _VPNFlowOpen, _VPNFlowReadClose, _VPNFlowScheduleWithRunLoop, 
                       _VPNFlowSetDispatchQueue, _VPNFlowSetEventHandler, 
                       _VPNFlowSetProperty, _VPNFlowStreamRead, _VPNFlowStreamWrite, 
                       _VPNFlowUnscheduleFromRunLoop, _VPNFlowWriteClose, 
                       _VPNSerializeData, _VPNServiceCopyAll, _VPNServiceCopyAllMatchingExternalID, 
                       _VPNServiceCopyAppRule, _VPNServiceCopyAppRuleIDs, 
                       _VPNServiceIsManagedAppVPN, _VPNServiceRemoveAppRule, 
                       _VPNServiceSetAppRule, _VPNTunnelAuthenticate, _VPNTunnelClearConfiguration, 
                       _VPNTunnelCopyPersistentData, _VPNTunnelCopySavedConfiguration, 
                       _VPNTunnelCopySavedConfigurationName, _VPNTunnelCopySavedVendorData, 
                       _VPNTunnelCopySocketInfo, _VPNTunnelCryptoAddConfigurations, 
                       _VPNTunnelCryptoDisable, _VPNTunnelCryptoEnable, 
                       _VPNTunnelCryptoGenerateIndex, _VPNTunnelCryptoRemoveConfigurations, 
                       _VPNTunnelCryptoStartDataTraffic, _VPNTunnelCryptoStopDataTraffic, 
                       _VPNTunnelDisplayBanner, _VPNTunnelEnvironmentEventComplete, 
                       _VPNTunnelFetchCredentialComplete, _VPNTunnelIPCSendMessage, 
                       _VPNTunnelIncrementDataReceived, _VPNTunnelIncrementDataSent, 
                       _VPNTunnelLog, _VPNTunnelSetConfigurationEntities, 
                       _VPNTunnelSetPersistentData, _VPNTunnelSetStatus, 
                       _VPNTunnelSetTunnelSocket, _VPNTunnelUpdatePlugin, 
                       _VPNUnserializeData, __SCBondInterfaceCopyActive, 
                       __SCBondInterfaceUpdateConfiguration, __SCBridgeInterfaceCopyActive, 
                       __SCBridgeInterfaceUpdateConfiguration, __SCCopyDescription, 
                       __SCDPluginExecCommand, __SCDPluginExecCommand2, 
                       __SCDPluginExecInit, __SCErrorSet, __SCHelperExec, 
                       __SCNetworkConfigurationCheckValidity, __SCNetworkConfigurationCheckValidityWithPreferences, 
                       __SCNetworkConfigurationCopyMigrationPaths, __SCNetworkConfigurationCopyMigrationRemovePaths, 
                       __SCNetworkConfigurationPerformMigration, __SCNetworkInterfaceCompare, 
                       __SCNetworkInterfaceCopyActive, __SCNetworkInterfaceCopyAllWithPreferences, 
                       __SCNetworkInterfaceCopyBTPANInterface, __SCNetworkInterfaceCopyInterfaceInfo, 
                       __SCNetworkInterfaceCopySlashDevPath, __SCNetworkInterfaceCreateWithBSDName, 
                       __SCNetworkInterfaceCreateWithEntity, __SCNetworkInterfaceCreateWithIONetworkInterfaceObject, 
                       __SCNetworkInterfaceForceConfigurationRefresh, __SCNetworkInterfaceGetConfigurationAction, 
                       __SCNetworkInterfaceGetHardwareAddress, __SCNetworkInterfaceGetIOInterfaceNamePrefix, 
                       __SCNetworkInterfaceGetIOInterfaceType, __SCNetworkInterfaceGetIOInterfaceUnit, 
                       __SCNetworkInterfaceGetIOPath, __SCNetworkInterfaceGetIORegistryEntryID, 
                       __SCNetworkInterfaceIsBluetoothP2P, __SCNetworkInterfaceIsBluetoothPAN, 
                       __SCNetworkInterfaceIsBluetoothPAN_NAP, __SCNetworkInterfaceIsBuiltin, 
                       __SCNetworkInterfaceIsHiddenConfiguration, __SCNetworkInterfaceIsModemV92, 
                       __SCNetworkInterfaceIsPhysicalEthernet, __SCNetworkInterfaceIsTethered, 
                       __SCNetworkInterfaceIsThunderbolt, __SCNetworkMigrationAreConfigurationsIdentical, 
                       __SCNetworkReachabilityCopyTargetDescription, __SCNetworkReachabilityCopyTargetFlags, 
                       __SCNetworkServiceCompare, __SCNetworkServiceCopyActive, 
                       __SCNetworkServiceIsVPN, __SCNetworkServiceSetServiceID, 
                       __SCNetworkSetSetSetID, __SCPreferencesCopyComputerName, 
                       __SCPreferencesSystemKeychainPasswordItemCopy, __SCPreferencesSystemKeychainPasswordItemExists, 
                       __SCPreferencesSystemKeychainPasswordItemRemove, 
                       __SCPreferencesSystemKeychainPasswordItemSet, __SCSecKeychainCopySystemKeychain, 
                       __SCSecKeychainPasswordItemCopy, __SCSecKeychainPasswordItemExists, 
                       __SCSecKeychainPasswordItemRemove, __SCSecKeychainPasswordItemSet, 
                       __SCSerialize, __SCSerializeData, __SCSerializeMultiple, 
                       __SCSerializeString, __SCUnserialize, __SCUnserializeData, 
                       __SCUnserializeMultiple, __SCUnserializeString, 
                       __SCVLANInterfaceCopyActive, __SCVLANInterfaceUpdateConfiguration, 
                       __SC_CFBundleCopyNonLocalizedString, __SC_CFBundleGet, 
                       __SC_CFMachPortCreateWithPort, __SC_CFStringIsValidDNSName, 
                       __SC_CFStringIsValidNetBIOSName, __SC_cfstring_to_cstring, 
                       __SC_checkResolverReachabilityByAddress, __SC_copyBacktrace, 
                       __SC_crash, __SC_domainEndsWithDomain, __SC_dos_encoding_and_codepage, 
                       __SC_getconninfo, __SC_hostMatchesDomain, __SC_hw_model, 
                       __SC_isInstallEnvironment, __SC_logMachPortReferences, 
                       __SC_logMachPortStatus, __SC_sendMachMessage, __SC_sockaddr_to_string, 
                       __SC_stringIsValidDNSName, __SC_string_to_sockaddr, 
                       __SC_trimDomain, ___SCDynamicStoreCreatePrivate, 
                       ___SCNetworkConnectionCopyOnDemandInfoWithName, 
                       ___SCNetworkConnectionIPv4AddressMatchesRoutes, 
                       ___SCNetworkConnectionIPv6AddressMatchesRoutes, 
                       ___SCNetworkConnectionMaskIPv6Address, ___SCNetworkConnectionUseNetworkExtension, 
                       ___SCNetworkConnectionUsingNetworkExtension, ___SCNetworkInterfaceCreateCapabilities, 
                       ___SCNetworkInterfaceCreateMediaOptions, __sc_debug, 
                       __sc_log, __sc_verbose, __scprefs_observer_cancel, 
                       __scprefs_observer_watch, _isa_xpc_bool, _isa_xpc_connection, 
                       _isa_xpc_dictionary, _isa_xpc_error, _kCFErrorDomainSystemConfiguration, 
                       _kCFErrorDomainVPNTunnel, _kSCBondStatusDeviceAggregationStatus, 
                       _kSCBondStatusDeviceCollecting, _kSCBondStatusDeviceDistributing, 
                       _kSCCompAnyRegex, _kSCCompGlobal, _kSCCompHostNames, 
                       _kSCCompInterface, _kSCCompNetwork, _kSCCompService, 
                       _kSCCompSystem, _kSCCompUsers, _kSCConsoleSessionConsoleSet, 
                       _kSCConsoleSessionID, _kSCConsoleSessionLoginDone, 
                       _kSCConsoleSessionLoginwindowSafeLogin, _kSCConsoleSessionOnConsole, 
                       _kSCConsoleSessionSystemSafeBoot, _kSCConsoleSessionUID, 
                       _kSCConsoleSessionUserName, _kSCDynamicStoreDomainFile, 
                       _kSCDynamicStoreDomainPlugin, _kSCDynamicStoreDomainPrefs, 
                       _kSCDynamicStoreDomainSetup, _kSCDynamicStoreDomainState, 
                       _kSCDynamicStorePropNetInterfaces, _kSCDynamicStorePropNetPrimaryInterface, 
                       _kSCDynamicStorePropNetPrimaryService, _kSCDynamicStorePropNetServiceIDs, 
                       _kSCDynamicStorePropSetupCurrentSet, _kSCDynamicStorePropSetupLastUpdated, 
                       _kSCDynamicStoreUseSessionKeys, _kSCEntNet6to4, 
                       _kSCEntNetActiveDuringSleepRequested, _kSCEntNetActiveDuringSleepSupported, 
                       _kSCEntNetAirPort, _kSCEntNetAppLayer, _kSCEntNetAppleTalk, 
                       _kSCEntNetDHCP, _kSCEntNetDNS, _kSCEntNetEAPOL, 
                       _kSCEntNetEthernet, _kSCEntNetFireWire, _kSCEntNetIPSec, 
                       _kSCEntNetIPv4, _kSCEntNetIPv4RouterARPAlive, _kSCEntNetIPv4RouterARPFailure, 
                       _kSCEntNetIPv6, _kSCEntNetInterface, _kSCEntNetL2TP, 
                       _kSCEntNetLink, _kSCEntNetLinkIssues, _kSCEntNetLinkQuality, 
                       _kSCEntNetLoopback, _kSCEntNetModem, _kSCEntNetNetInfo, 
                       _kSCEntNetOnDemand, _kSCEntNetPPP, _kSCEntNetPPPSerial, 
                       _kSCEntNetPPPoE, _kSCEntNetPPTP, _kSCEntNetProxies, 
                       _kSCEntNetSMB, _kSCEntNetService, _kSCEntNetVPN, 
                       _kSCEntUsersConsoleUser, _kSCNetworkConfigurationMigrationActionKey, 
                       _kSCNetworkConfigurationRepair, _kSCNetworkInterfaceIPv4, 
                       _kSCNetworkInterfaceLoopback, _kSCNetworkInterfaceType6to4, 
                       _kSCNetworkInterfaceTypeBluetooth, _kSCNetworkInterfaceTypeBond, 
                       _kSCNetworkInterfaceTypeBridge, _kSCNetworkInterfaceTypeEthernet, 
                       _kSCNetworkInterfaceTypeFireWire, _kSCNetworkInterfaceTypeIEEE80211, 
                       _kSCNetworkInterfaceTypeIPSec, _kSCNetworkInterfaceTypeIPv4, 
                       _kSCNetworkInterfaceTypeIrDA, _kSCNetworkInterfaceTypeL2TP, 
                       _kSCNetworkInterfaceTypeLoopback, _kSCNetworkInterfaceTypeModem, 
                       _kSCNetworkInterfaceTypePPP, _kSCNetworkInterfaceTypePPTP, 
                       _kSCNetworkInterfaceTypeSerial, _kSCNetworkInterfaceTypeVLAN, 
                       _kSCNetworkInterfaceTypeVPN, _kSCNetworkInterfaceTypeWWAN, 
                       _kSCNetworkProtocolTypeAppleTalk, _kSCNetworkProtocolTypeDNS, 
                       _kSCNetworkProtocolTypeIPv4, _kSCNetworkProtocolTypeIPv6, 
                       _kSCNetworkProtocolTypeProxies, _kSCNetworkProtocolTypeSMB, 
                       _kSCPrefCurrentSet, _kSCPrefNetworkServices, _kSCPrefSets, 
                       _kSCPrefSystem, _kSCPrefVirtualNetworkInterfaces, 
                       _kSCPreferencesUseEntitlementAuthorization, _kSCPropConfirmedInterfaceName, 
                       _kSCPropDisableUntilNeeded, _kSCPropInterfaceName, 
                       _kSCPropMACAddress, _kSCPropNet6to4Relay, _kSCPropNetAirPortAllowNetCreation, 
                       _kSCPropNetAirPortAuthPassword, _kSCPropNetAirPortAuthPasswordEncryption, 
                       _kSCPropNetAirPortJoinMode, _kSCPropNetAirPortPowerEnabled, 
                       _kSCPropNetAirPortPreferredNetwork, _kSCPropNetAirPortSavePasswords, 
                       _kSCPropNetAppleTalkComputerName, _kSCPropNetAppleTalkComputerNameEncoding, 
                       _kSCPropNetAppleTalkConfigMethod, _kSCPropNetAppleTalkDefaultZone, 
                       _kSCPropNetAppleTalkNetworkID, _kSCPropNetAppleTalkNetworkRange, 
                       _kSCPropNetAppleTalkNodeID, _kSCPropNetAppleTalkSeedNetworkRange, 
                       _kSCPropNetAppleTalkSeedZones, _kSCPropNetDNSConfirmedServiceID, 
                       _kSCPropNetDNSDomainName, _kSCPropNetDNSOptions, 
                       _kSCPropNetDNSSearchDomains, _kSCPropNetDNSSearchOrder, 
                       _kSCPropNetDNSServerAddresses, _kSCPropNetDNSServerPort, 
                       _kSCPropNetDNSServerTimeout, _kSCPropNetDNSServiceIdentifier, 
                       _kSCPropNetDNSSortList, _kSCPropNetDNSSupplementalMatchDomains, 
                       _kSCPropNetDNSSupplementalMatchDomainsNoSearch, 
                       _kSCPropNetDNSSupplementalMatchOrders, _kSCPropNetEthernetCapabilityAV, 
                       _kSCPropNetEthernetCapabilityJUMBO_MTU, _kSCPropNetEthernetCapabilityLRO, 
                       _kSCPropNetEthernetCapabilityRXCSUM, _kSCPropNetEthernetCapabilityTSO, 
                       _kSCPropNetEthernetCapabilityTSO4, _kSCPropNetEthernetCapabilityTSO6, 
                       _kSCPropNetEthernetCapabilityTXCSUM, _kSCPropNetEthernetCapabilityVLAN_HWTAGGING, 
                       _kSCPropNetEthernetCapabilityVLAN_MTU, _kSCPropNetEthernetMTU, 
                       _kSCPropNetEthernetMediaOptions, _kSCPropNetEthernetMediaSubType, 
                       _kSCPropNetIPSecAuthenticationMethod, _kSCPropNetIPSecConnectTime, 
                       _kSCPropNetIPSecDisconnectOnWake, _kSCPropNetIPSecDisconnectOnWakeTimer, 
                       _kSCPropNetIPSecLastCause, _kSCPropNetIPSecLocalCertificate, 
                       _kSCPropNetIPSecLocalIdentifier, _kSCPropNetIPSecLocalIdentifierType, 
                       _kSCPropNetIPSecOnDemandEnabled, _kSCPropNetIPSecOnDemandMatchDomainsAlways, 
                       _kSCPropNetIPSecOnDemandMatchDomainsNever, _kSCPropNetIPSecOnDemandMatchDomainsOnRetry, 
                       _kSCPropNetIPSecRemoteAddress, _kSCPropNetIPSecSharedSecret, 
                       _kSCPropNetIPSecSharedSecretEncryption, _kSCPropNetIPSecStatus, 
                       _kSCPropNetIPSecXAuthEnabled, _kSCPropNetIPSecXAuthName, 
                       _kSCPropNetIPSecXAuthPassword, _kSCPropNetIPSecXAuthPasswordEncryption, 
                       _kSCPropNetIPv4ARPResolvedHardwareAddress, _kSCPropNetIPv4ARPResolvedIPAddress, 
                       _kSCPropNetIPv4AdditionalRoutes, _kSCPropNetIPv4Addresses, 
                       _kSCPropNetIPv4BroadcastAddresses, _kSCPropNetIPv4ConfigMethod, 
                       _kSCPropNetIPv4DHCPClientID, _kSCPropNetIPv4DestAddresses, 
                       _kSCPropNetIPv4ExcludedRoutes, _kSCPropNetIPv4IncludedRoutes, 
                       _kSCPropNetIPv4RouteDestinationAddress, _kSCPropNetIPv4RouteGatewayAddress, 
                       _kSCPropNetIPv4RouteInterfaceName, _kSCPropNetIPv4RouteSubnetMask, 
                       _kSCPropNetIPv4Router, _kSCPropNetIPv4SubnetMasks, 
                       _kSCPropNetIPv6AdditionalRoutes, _kSCPropNetIPv6Addresses, 
                       _kSCPropNetIPv6ConfigMethod, _kSCPropNetIPv6DestAddresses, 
                       _kSCPropNetIPv6ExcludedRoutes, _kSCPropNetIPv6Flags, 
                       _kSCPropNetIPv6IncludedRoutes, _kSCPropNetIPv6PrefixLength, 
                       _kSCPropNetIPv6RouteDestinationAddress, _kSCPropNetIPv6RouteGatewayAddress, 
                       _kSCPropNetIPv6RouteInterfaceName, _kSCPropNetIPv6RoutePrefixLength, 
                       _kSCPropNetIPv6Router, _kSCPropNetIgnoreLinkStatus, 
                       _kSCPropNetInterfaceDeviceName, _kSCPropNetInterfaceHardware, 
                       _kSCPropNetInterfaceSubType, _kSCPropNetInterfaceSupportsModemOnHold, 
                       _kSCPropNetInterfaceType, _kSCPropNetInterfaces, 
                       _kSCPropNetL2TPIPSecSharedSecret, _kSCPropNetL2TPIPSecSharedSecretEncryption, 
                       _kSCPropNetL2TPTransport, _kSCPropNetLinkActive, 
                       _kSCPropNetLinkDetaching, _kSCPropNetLinkExpensive, 
                       _kSCPropNetLinkIssuesInfo, _kSCPropNetLinkIssuesModuleID, 
                       _kSCPropNetLinkIssuesTimeStamp, _kSCPropNetLinkQuality, 
                       _kSCPropNetLocalHostName, _kSCPropNetModemAccessPointName, 
                       _kSCPropNetModemConnectSpeed, _kSCPropNetModemConnectionPersonality, 
                       _kSCPropNetModemConnectionScript, _kSCPropNetModemDataCompression, 
                       _kSCPropNetModemDeviceContextID, _kSCPropNetModemDeviceModel, 
                       _kSCPropNetModemDeviceVendor, _kSCPropNetModemDialMode, 
                       _kSCPropNetModemErrorCorrection, _kSCPropNetModemHoldCallWaitingAudibleAlert, 
                       _kSCPropNetModemHoldDisconnectOnAnswer, _kSCPropNetModemHoldEnabled, 
                       _kSCPropNetModemHoldReminder, _kSCPropNetModemHoldReminderTime, 
                       _kSCPropNetModemNote, _kSCPropNetModemPulseDial, 
                       _kSCPropNetModemSpeaker, _kSCPropNetModemSpeed, 
                       _kSCPropNetNetInfoBindingMethods, _kSCPropNetNetInfoBroadcastServerTag, 
                       _kSCPropNetNetInfoServerAddresses, _kSCPropNetNetInfoServerTags, 
                       _kSCPropNetOverridePrimary, _kSCPropNetPPPACSPEnabled, 
                       _kSCPropNetPPPAuthEAPPlugins, _kSCPropNetPPPAuthName, 
                       _kSCPropNetPPPAuthPassword, _kSCPropNetPPPAuthPasswordEncryption, 
                       _kSCPropNetPPPAuthPrompt, _kSCPropNetPPPAuthProtocol, 
                       _kSCPropNetPPPCCPEnabled, _kSCPropNetPPPCCPMPPE128Enabled, 
                       _kSCPropNetPPPCCPMPPE40Enabled, _kSCPropNetPPPCommAlternateRemoteAddress, 
                       _kSCPropNetPPPCommConnectDelay, _kSCPropNetPPPCommDisplayTerminalWindow, 
                       _kSCPropNetPPPCommRedialCount, _kSCPropNetPPPCommRedialEnabled, 
                       _kSCPropNetPPPCommRedialInterval, _kSCPropNetPPPCommRemoteAddress, 
                       _kSCPropNetPPPCommTerminalScript, _kSCPropNetPPPCommUseTerminalScript, 
                       _kSCPropNetPPPConnectTime, _kSCPropNetPPPDeviceLastCause, 
                       _kSCPropNetPPPDialOnDemand, _kSCPropNetPPPDisconnectOnFastUserSwitch, 
                       _kSCPropNetPPPDisconnectOnIdle, _kSCPropNetPPPDisconnectOnIdleTimer, 
                       _kSCPropNetPPPDisconnectOnLogout, _kSCPropNetPPPDisconnectOnSleep, 
                       _kSCPropNetPPPDisconnectOnWake, _kSCPropNetPPPDisconnectOnWakeTimer, 
                       _kSCPropNetPPPDisconnectTime, _kSCPropNetPPPIPCPCompressionVJ, 
                       _kSCPropNetPPPIPCPUsePeerDNS, _kSCPropNetPPPIdleReminder, 
                       _kSCPropNetPPPIdleReminderTimer, _kSCPropNetPPPLCPCompressionACField, 
                       _kSCPropNetPPPLCPCompressionPField, _kSCPropNetPPPLCPEchoEnabled, 
                       _kSCPropNetPPPLCPEchoFailure, _kSCPropNetPPPLCPEchoInterval, 
                       _kSCPropNetPPPLCPMRU, _kSCPropNetPPPLCPMTU, _kSCPropNetPPPLCPReceiveACCM, 
                       _kSCPropNetPPPLCPTransmitACCM, _kSCPropNetPPPLastCause, 
                       _kSCPropNetPPPLogfile, _kSCPropNetPPPOnDemandDomains, 
                       _kSCPropNetPPPOnDemandEnabled, _kSCPropNetPPPOnDemandHostName, 
                       _kSCPropNetPPPOnDemandMatchDomainsAlways, _kSCPropNetPPPOnDemandMatchDomainsNever, 
                       _kSCPropNetPPPOnDemandMatchDomainsOnRetry, _kSCPropNetPPPOnDemandMode, 
                       _kSCPropNetPPPOnDemandPriority, _kSCPropNetPPPOverridePrimary, 
                       _kSCPropNetPPPPlugins, _kSCPropNetPPPRetryConnectTime, 
                       _kSCPropNetPPPSessionTimer, _kSCPropNetPPPStatus, 
                       _kSCPropNetPPPUseSessionTimer, _kSCPropNetPPPVerboseLogging, 
                       _kSCPropNetProxiesBypassAllowed, _kSCPropNetProxiesExceptionsList, 
                       _kSCPropNetProxiesExcludeSimpleHostnames, _kSCPropNetProxiesFTPEnable, 
                       _kSCPropNetProxiesFTPPassive, _kSCPropNetProxiesFTPPort, 
                       _kSCPropNetProxiesFTPProxy, _kSCPropNetProxiesFallBackAllowed, 
                       _kSCPropNetProxiesGopherEnable, _kSCPropNetProxiesGopherPort, 
                       _kSCPropNetProxiesGopherProxy, _kSCPropNetProxiesHTTPEnable, 
                       _kSCPropNetProxiesHTTPPort, _kSCPropNetProxiesHTTPProxy, 
                       _kSCPropNetProxiesHTTPSEnable, _kSCPropNetProxiesHTTPSPort, 
                       _kSCPropNetProxiesHTTPSProxy, _kSCPropNetProxiesProxyAutoConfigEnable, 
                       _kSCPropNetProxiesProxyAutoConfigJavaScript, _kSCPropNetProxiesProxyAutoConfigURLString, 
                       _kSCPropNetProxiesProxyAutoDiscoveryEnable, _kSCPropNetProxiesRTSPEnable, 
                       _kSCPropNetProxiesRTSPPort, _kSCPropNetProxiesRTSPProxy, 
                       _kSCPropNetProxiesSOCKSEnable, _kSCPropNetProxiesSOCKSPort, 
                       _kSCPropNetProxiesSOCKSProxy, _kSCPropNetProxiesScoped, 
                       _kSCPropNetProxiesServiceSpecific, _kSCPropNetProxiesServices, 
                       _kSCPropNetProxiesSupplemental, _kSCPropNetProxiesSupplementalMatchDomain, 
                       _kSCPropNetProxiesSupplementalMatchDomains, _kSCPropNetProxiesSupplementalMatchOrders, 
                       _kSCPropNetSMBNetBIOSName, _kSCPropNetSMBNetBIOSNodeType, 
                       _kSCPropNetSMBNetBIOSScope, _kSCPropNetSMBWINSAddresses, 
                       _kSCPropNetSMBWorkgroup, _kSCPropNetServiceOrder, 
                       _kSCPropNetServicePrimaryRank, _kSCPropNetServiceUserDefinedName, 
                       _kSCPropNetVPNAppRules, _kSCPropNetVPNAuthCredentialPassword, 
                       _kSCPropNetVPNAuthName, _kSCPropNetVPNAuthPassword, 
                       _kSCPropNetVPNAuthPasswordEncryption, _kSCPropNetVPNAuthPasswordPluginType, 
                       _kSCPropNetVPNAuthenticationMethod, _kSCPropNetVPNConnectTime, 
                       _kSCPropNetVPNDisconnectOnFastUserSwitch, _kSCPropNetVPNDisconnectOnIdle, 
                       _kSCPropNetVPNDisconnectOnIdleTimer, _kSCPropNetVPNDisconnectOnLogout, 
                       _kSCPropNetVPNDisconnectOnSleep, _kSCPropNetVPNDisconnectOnWake, 
                       _kSCPropNetVPNDisconnectOnWakeTimer, _kSCPropNetVPNLocalCertificate, 
                       _kSCPropNetVPNLogfile, _kSCPropNetVPNMTU, _kSCPropNetVPNOnDemandEnabled, 
                       _kSCPropNetVPNOnDemandMatchAppEnabled, _kSCPropNetVPNOnDemandMatchDomainsAlways, 
                       _kSCPropNetVPNOnDemandMatchDomainsNever, _kSCPropNetVPNOnDemandMatchDomainsOnRetry, 
                       _kSCPropNetVPNOnDemandRuleAction, _kSCPropNetVPNOnDemandRuleActionParameters, 
                       _kSCPropNetVPNOnDemandRuleActionParametersDomainAction, 
                       _kSCPropNetVPNOnDemandRuleActionParametersDomains, 
                       _kSCPropNetVPNOnDemandRuleActionParametersRequiredDNSServers, 
                       _kSCPropNetVPNOnDemandRuleActionParametersRequiredURLStringProbe, 
                       _kSCPropNetVPNOnDemandRuleDNSDomainMatch, _kSCPropNetVPNOnDemandRuleDNSServerAddressMatch, 
                       _kSCPropNetVPNOnDemandRuleInterfaceTypeMatch, _kSCPropNetVPNOnDemandRuleSSIDMatch, 
                       _kSCPropNetVPNOnDemandRuleURLStringProbe, _kSCPropNetVPNOnDemandRules, 
                       _kSCPropNetVPNOnDemandSuspended, _kSCPropNetVPNPluginCapability, 
                       _kSCPropNetVPNRemoteAddress, _kSCPropNetVPNStatus, 
                       _kSCPropNetVPNVerboseLogging, _kSCPropSystemComputerName, 
                       _kSCPropSystemComputerNameEncoding, _kSCPropSystemComputerNameRegion, 
                       _kSCPropSystemHostName, _kSCPropUserDefinedName, 
                       _kSCPropUsersConsoleUserGID, _kSCPropUsersConsoleUserName, 
                       _kSCPropUsersConsoleUserUID, _kSCPropVersion, _kSCPropVirtualNetworkInterfacesBondInterfaces, 
                       _kSCPropVirtualNetworkInterfacesBondMode, _kSCPropVirtualNetworkInterfacesBondOptions, 
                       _kSCPropVirtualNetworkInterfacesBridgeInterfaces, 
                       _kSCPropVirtualNetworkInterfacesBridgeOptions, _kSCPropVirtualNetworkInterfacesVLANInterface, 
                       _kSCPropVirtualNetworkInterfacesVLANOptions, _kSCPropVirtualNetworkInterfacesVLANTag, 
                       _kSCProxiesNoGlobal, _kSCResvInactive, _kSCResvLink, 
                       _kSCValNetAirPortAuthPasswordEncryptionKeychain, 
                       _kSCValNetAirPortJoinModeAutomatic, _kSCValNetAirPortJoinModePreferred, 
                       _kSCValNetAirPortJoinModeRanked, _kSCValNetAirPortJoinModeRecent, 
                       _kSCValNetAirPortJoinModeStrongest, _kSCValNetAppleTalkConfigMethodNode, 
                       _kSCValNetAppleTalkConfigMethodRouter, _kSCValNetAppleTalkConfigMethodSeedRouter, 
                       _kSCValNetIPSecAuthenticationMethodCertificate, 
                       _kSCValNetIPSecAuthenticationMethodHybrid, _kSCValNetIPSecAuthenticationMethodSharedSecret, 
                       _kSCValNetIPSecLocalIdentifierTypeKeyID, _kSCValNetIPSecSharedSecretEncryptionKeychain, 
                       _kSCValNetIPSecXAuthPasswordEncryptionKeychain, 
                       _kSCValNetIPSecXAuthPasswordEncryptionPrompt, _kSCValNetIPv4ConfigMethodAutomatic, 
                       _kSCValNetIPv4ConfigMethodBOOTP, _kSCValNetIPv4ConfigMethodDHCP, 
                       _kSCValNetIPv4ConfigMethodFailover, _kSCValNetIPv4ConfigMethodINFORM, 
                       _kSCValNetIPv4ConfigMethodLinkLocal, _kSCValNetIPv4ConfigMethodManual, 
                       _kSCValNetIPv4ConfigMethodPPP, _kSCValNetIPv6ConfigMethod6to4, 
                       _kSCValNetIPv6ConfigMethodAutomatic, _kSCValNetIPv6ConfigMethodLinkLocal, 
                       _kSCValNetIPv6ConfigMethodManual, _kSCValNetIPv6ConfigMethodRouterAdvertisement, 
                       _kSCValNetInterfaceSubTypeL2TP, _kSCValNetInterfaceSubTypePPPSerial, 
                       _kSCValNetInterfaceSubTypePPPoE, _kSCValNetInterfaceSubTypePPTP, 
                       _kSCValNetInterfaceType6to4, _kSCValNetInterfaceTypeEthernet, 
                       _kSCValNetInterfaceTypeFireWire, _kSCValNetInterfaceTypeIPSec, 
                       _kSCValNetInterfaceTypeLoopback, _kSCValNetInterfaceTypePPP, 
                       _kSCValNetInterfaceTypeVPN, _kSCValNetL2TPIPSecSharedSecretEncryptionKeychain, 
                       _kSCValNetL2TPTransportIP, _kSCValNetL2TPTransportIPSec, 
                       _kSCValNetModemDialModeIgnoreDialTone, _kSCValNetModemDialModeManual, 
                       _kSCValNetModemDialModeWaitForDialTone, _kSCValNetNetInfoBindingMethodsBroadcast, 
                       _kSCValNetNetInfoBindingMethodsDHCP, _kSCValNetNetInfoBindingMethodsManual, 
                       _kSCValNetNetInfoDefaultServerTag, _kSCValNetPPPAuthPasswordEncryptionKeychain, 
                       _kSCValNetPPPAuthPasswordEncryptionToken, _kSCValNetPPPAuthPromptAfter, 
                       _kSCValNetPPPAuthPromptBefore, _kSCValNetPPPAuthProtocolCHAP, 
                       _kSCValNetPPPAuthProtocolEAP, _kSCValNetPPPAuthProtocolMSCHAP1, 
                       _kSCValNetPPPAuthProtocolMSCHAP2, _kSCValNetPPPAuthProtocolPAP, 
                       _kSCValNetPPPOnDemandModeAggressive, _kSCValNetPPPOnDemandModeCompatible, 
                       _kSCValNetPPPOnDemandModeConservative, _kSCValNetPPPOnDemandPriorityDefault, 
                       _kSCValNetPPPOnDemandPriorityHigh, _kSCValNetPPPOnDemandPriorityLow, 
                       _kSCValNetSMBNetBIOSNodeTypeBroadcast, _kSCValNetSMBNetBIOSNodeTypeHybrid, 
                       _kSCValNetSMBNetBIOSNodeTypeMixed, _kSCValNetSMBNetBIOSNodeTypePeer, 
                       _kSCValNetServicePrimaryRankFirst, _kSCValNetServicePrimaryRankLast, 
                       _kSCValNetServicePrimaryRankNever, _kSCValNetServicePrimaryRankScoped, 
                       _kSCValNetVPNAppRuleAccountIdentifierMatch, _kSCValNetVPNAppRuleDNSDomainMatch, 
                       _kSCValNetVPNAppRuleExecutableDesignatedRequirement, 
                       _kSCValNetVPNAppRuleExecutableMatch, _kSCValNetVPNAppRuleExecutableSigningIdentifier, 
                       _kSCValNetVPNAppRuleExecutableUUID, _kSCValNetVPNAppRuleIdentifier, 
                       _kSCValNetVPNAuthPasswordEncryptionExternal, _kSCValNetVPNAuthPasswordEncryptionKeychain, 
                       _kSCValNetVPNAuthPasswordEncryptionPrompt, _kSCValNetVPNAuthenticationMethodCertificate, 
                       _kSCValNetVPNAuthenticationMethodPassword, _kSCValNetVPNOnDemandRuleActionAllow, 
                       _kSCValNetVPNOnDemandRuleActionConnect, _kSCValNetVPNOnDemandRuleActionDisconnect, 
                       _kSCValNetVPNOnDemandRuleActionEvaluateConnection, 
                       _kSCValNetVPNOnDemandRuleActionIgnore, _kSCValNetVPNOnDemandRuleActionParametersDomainActionConnectIfNeeded, 
                       _kSCValNetVPNOnDemandRuleActionParametersDomainActionNeverConnect, 
                       _kSCValNetVPNOnDemandRuleInterfaceTypeMatchEthernet, 
                       _kSCValNetVPNOnDemandRuleInterfaceTypeMatchWiFi, 
                       _kSCValNetVPNPluginCapabilityAuth, _kSCValNetVPNPluginCapabilityConnect, 
                       _kVPNConfigurationKeyCertificateRef, _kVPNConfigurationKeyPersistentRef, 
                       _kVPNConfigurationOptionTunnelType, _kVPNFlowPropertyAppRuleIdentifier, 
                       _kVPNFlowPropertyAppUnique, _kVPNFlowPropertyDestinationEndpoint, 
                       _kVPNFlowPropertyDestinationName, _kVPNFlowPropertyNetworkServiceType, 
                       _kVPNFlowPropertyTunnelSocketNativeHandle, _kVPNFlowPropertyType, 
                       _snhelper_flow_divert_uuid_policy_add, _snhelper_flow_divert_uuid_policy_clear, 
                       _snhelper_flow_divert_uuid_policy_remove, _snhelper_get_uuid_for_app ]
...
                                                                                                                                                                                                                                                                                          Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 033544  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SystemConfiguration.framework/Versions                                                                   osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/                      0040755 0001750 0001750 00000000000 12612224746 025223  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Headers               0120777 0001750 0001750 00000000000 12620245063 033237  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Modules               0120777 0001750 0001750 00000000000 12620245063 033331  2Versions/Current/Modules                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/TWAIN.tbd             0120777 0001750 0001750 00000000000 12620245063 033375  2Versions/Current/TWAIN.tbd                                                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/             0040755 0001750 0001750 00000000000 12612224746 027033  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/A/           0040755 0001750 0001750 00000000000 12612224746 027213  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/A/Headers/   0040755 0001750 0001750 00000000000 12612224746 030566  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        TWAIN.h                                                                                             0100644 0001750 0001750 00000243224 12566223017 031544  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/A/Headers                                                                        /* ======================================================================== *\

  Copyright (C) 1991, 1992 TWAIN Working Group: Aldus, Caere, Eastman-Kodak,
  Hewlett-Packard and Logitech Corporations.  All rights reserved.

  Copyright (C) 1997 TWAIN Working Group: Bell+Howell, Canon, DocuMagix, 
  Fujitsu, Genoa Technology, Hewlett-Packard, Kofax Imaging Products, and
  Ricoh Corporation.  All rights reserved.
 
  Copyright  1998 TWAIN Working Group: Adobe Systems Incorporated, 
  Canon Information Systems, Eastman Kodak Company, 
  Fujitsu Computer Products of America, Genoa Technology, 
  Hewlett-Packard Company, Intel Corporation, Kofax Image Products, 
  JFL Peripheral Solutions Inc., Ricoh Corporation, and Xerox Corporation.  
  All rights reserved.

  Copyright  2000 TWAIN Working Group: Adobe Systems Incorporated, 
  Canon Information Systems, Digimarc Corporation, Eastman Kodak Company, 
  Fujitsu Computer Products of America, Hewlett-Packard Company, 
  JFL Peripheral Solutions Inc., Ricoh Corporation, and Xerox Corporation.  
  All rights reserved.


  TWAIN.h -  This is the definitive include file for applications and
          data sources written to the TWAIN specification.
          It defines constants, data structures, messages etc.
          for the public interface to TWAIN.
 
  Revision History:
    version 1.0, March 6, 1992.  TWAIN 1.0.
    version 1.1, January 1993.   Tech Notes 1.1
    version 1.5, June 1993.      Specification Update 1.5
                                 Change DC to TW 
                                 Change filename from DC.H to TWAIN.H
    version 1.5, July 1993.      Remove spaces from country identifiers
 
    version 1.7, July 1997       Added Capabilities and data structure for 
                                 document imaging and digital cameras.
                                 KHL.
    version 1.7, July 1997       Inserted Borland compatibile structure packing
                                 directives provided by Mentor.  JMH
    version 1.7, Aug 1997        Expanded file tabs to spaces.  
                                 NOTE: future authors should be sure to have 
                                 their editors set to automatically expand tabs 
                                 to spaces (original tab setting was 4 spaces).
    version 1.7, Sept 1997       Added job control values
                                 Added return codes
    version 1.7, Sept 1997       changed definition of pRGBRESPONSE to 
                                 pTW_RGBRESPONSE
    version 1.7  Aug 1998        Added missing TWEI_BARCODEROTATION values
                                 TWBCOR_ types JMH
    version 1.8  August 1998     Added new types and definitions required
                                 for 1.8 Specification JMH
    version 1.8  January 1999    Changed search mode from SRCH_ to TWBD_ as
                                 in 1.8 Specification, added TWBT_MAXICODE	JMH
	  version 1.8  January 1999    Removed undocumented duplicate AUTO<cap> JMH
    version 1.8  March 1999      Removed undocumented 1.8 caps:
                                 CAP_FILESYSTEM
                                 CAP_PAPERBINDING
                                 CAP_PASSTHRU
                                 CAP_POWERDOWNTIME
                                 ICAP_AUTODISCARDBLANKPAGES
                               * CAP_PAGEMULTIPLEACQUIRE - is CAP_REACQUIREALLOWED,
							                   requires spec change.  JMH
                                 Added Mac structure packing modifications JMH
	  version 1.9  March 2000	     Added new types and definations required
	                               for 1.9 Specification MLM
	  version 1.9  March 2000	     Added ICAP_JPEGQUALITY, TWJQ_ values,
                                 updated TWON_PROTOCOLMINOR for Release v1.9 MN
                   November 2000 removed Mac packing modifications
                   				 capitilized ParID in TW_SETUPFILEXFER2 for consistency
                   				 
\* ======================================================================== */

#ifndef TWAIN
#define TWAIN

/*  SDH - 02/08/95 - TWUNK */
/*  Force 32-bit twain to use same packing of twain structures as existing */
/*  16-bit twain.  This allows 16/32-bit thunking.                         */
#ifdef  WIN32
    #ifdef __BORLANDC__ //(Mentor June 13, 1996) if using a Borland compiler
        #pragma option -a2  //(Mentor June 13, 1996) switch to word alignment
    #else   //(Mentor June 13, 1996) if we're using some other compiler
        #pragma pack (push, before_twain)
        #pragma pack (2)
    #endif  //(Mentor June 13, 1996)
#else   /* WIN32 */
#endif  /* WIN32 */

/****************************************************************************
 * TWAIN Version                                                            *
 ****************************************************************************/
#define TWON_PROTOCOLMINOR   9        /* Changed for Version 1.9            */
#define TWON_PROTOCOLMAJOR   1

/****************************************************************************
 * Platform Dependent Definitions and Typedefs                              *
 ****************************************************************************/

/* Define one of the following, depending on the platform */
#define _MAC_
/* #define _UNIX_  */
/* #define _MSWIN_ */

#ifdef  _MSWIN_
    typedef HANDLE         TW_HANDLE;
    typedef LPVOID         TW_MEMREF;

    /*  SDH - 05/05/95 - TWUNK */
    /*  For common code between 16 and 32 bits.  */
    #ifdef  WIN32
        #define TW_HUGE
    #else   /* WIN32 */
        #define TW_HUGE    huge
    #endif  /* WIN32 */
    typedef BYTE TW_HUGE * HPBYTE;
    typedef void TW_HUGE * HPVOID;
#endif  /* _MSWIN_ */

#ifdef  _MAC_
    #ifndef PASCAL
    #define PASCAL         pascal
    #endif
    
    #ifndef FAR
    #define FAR
    #endif
    
    typedef char          *TW_HANDLE;
    typedef char          *TW_MEMREF;

#pragma options align = power

#endif  /* _MAC_ */

#ifdef  _UNIX_
    #define PASCAL         pascal
    typedef unsigned char *TW_HANDLE;
    typedef unsigned char *TW_MEMREF;
#endif  /* _UNIX_ */

/****************************************************************************
 * Type Definitions                                                         *
 ****************************************************************************/

/* String types. These include room for the strings and a NULL char,     *
 * or, on the Mac, a length byte followed by the string.                 *
 * TW_STR255 must hold less than 256 chars so length fits in first byte. */
#ifdef _MAC_
typedef unsigned char    TW_STR32[34],     FAR *pTW_STR32;
typedef unsigned char    TW_STR64[66],     FAR *pTW_STR64;
typedef unsigned char    TW_STR128[130],   FAR *pTW_STR128;
typedef unsigned char    TW_STR255[256],   FAR *pTW_STR255;
#else
typedef char    TW_STR32[34],     FAR *pTW_STR32;
typedef char    TW_STR64[66],     FAR *pTW_STR64;
typedef char    TW_STR128[130],   FAR *pTW_STR128;
typedef char    TW_STR255[256],   FAR *pTW_STR255;
typedef char    TW_STR1024[1026], FAR *pTW_STR1024;   /* added 1.9 */
typedef wchar_t TW_UNI512[512],   FAR *pTW_UNI512;    /* added 1.9 */
#endif

/* Numeric types. */
typedef char           TW_INT8,   FAR *pTW_INT8;
typedef short          TW_INT16,  FAR *pTW_INT16; 
typedef int            TW_INT32,  FAR *pTW_INT32;
typedef unsigned char  TW_UINT8,  FAR *pTW_UINT8;
typedef unsigned short TW_UINT16, FAR *pTW_UINT16;
typedef unsigned int   TW_UINT32, FAR *pTW_UINT32;
typedef unsigned short TW_BOOL,   FAR *pTW_BOOL; 

/* Fixed point structure type. */
typedef struct TW_FIX32 {
    TW_INT16     Whole;        /* maintains the sign */
    TW_UINT16    Frac;
} TW_FIX32,  FAR *pTW_FIX32;

/****************************************************************************
 * Structure Definitions                                                    *
 ****************************************************************************/

/* No DAT needed. */
typedef struct TW_CIEPOINT {
   TW_FIX32   X;
   TW_FIX32   Y;
   TW_FIX32   Z;
} TW_CIEPOINT, FAR * pTW_CIEPOINT;

/* No DAT needed. */
typedef struct TW_DECODEFUNCTION {
   TW_FIX32   StartIn;
   TW_FIX32   BreakIn;
   TW_FIX32   EndIn;
   TW_FIX32   StartOut;
   TW_FIX32   BreakOut;
   TW_FIX32   EndOut;
   TW_FIX32   Gamma;
   TW_FIX32   SampleCount;  /* if =0 use the gamma */
} TW_DECODEFUNCTION, FAR * pTW_DECODEFUNCTION;

/* No DAT needed. */
typedef struct TW_ELEMENT8 {
   TW_UINT8    Index;    /* Value used to index into the color table. */
   TW_UINT8    Channel1; /* First  tri-stimulus value (e.g Red)       */
   TW_UINT8    Channel2; /* Second tri-stimulus value (e.g Green)     */
   TW_UINT8    Channel3; /* Third  tri-stimulus value (e.g Blue)      */
} TW_ELEMENT8, FAR * pTW_ELEMENT8;

/* No DAT.  Defines a frame rectangle in ICAP_UNITS coordinates. */
typedef struct TW_FRAME {
   TW_FIX32   Left;
   TW_FIX32   Top;
   TW_FIX32   Right;
   TW_FIX32   Bottom;
} TW_FRAME, FAR * pTW_FRAME;

/* No DAT needed.  Used to manage memory buffers. */
typedef struct TW_MEMORY {
   TW_UINT32  Flags;  /* Any combination of the TWMF_ constants.           */
   TW_UINT32  Length; /* Number of bytes stored in buffer TheMem.          */
   TW_MEMREF  TheMem; /* Pointer or handle to the allocated memory buffer. */
} TW_MEMORY, FAR * pTW_MEMORY;

/* No DAT needed. */
typedef struct TW_TRANSFORMSTAGE {
   TW_DECODEFUNCTION   Decode[3];
   TW_FIX32            Mix[3][3];
} TW_TRANSFORMSTAGE, FAR * pTW_TRANSFORMSTAGE;

/* No DAT needed.  Describes version of software currently running. */
typedef struct TW_VERSION {
   TW_UINT16  MajorNum;  /* Major revision number of the software. */
   TW_UINT16  MinorNum;  /* Incremental revision number of the software. */
   TW_UINT16  Language;  /* e.g. TWLG_SWISSFRENCH */
   TW_UINT16  Country;   /* e.g. TWCY_SWITZERLAND */
   TW_STR32   Info;      /* e.g. "1.0b3 Beta release" */
} TW_VERSION, FAR * pTW_VERSION;

/* TWON_ARRAY. Container for array of values (a simplified TW_ENUMERATION) */
typedef struct TW_ARRAY {
   TW_UINT16  ItemType;
   TW_UINT32  NumItems;    /* How many items in ItemList           */
   TW_UINT8   ItemList[1]; /* Array of ItemType values starts here */
} TW_ARRAY, FAR * pTW_ARRAY;

/* TWON_ENUMERATION. Container for a collection of values. */
typedef struct TW_ENUMERATION {
   TW_UINT16  ItemType;
   TW_UINT32  NumItems;     /* How many items in ItemList                 */
   TW_UINT32  CurrentIndex; /* Current value is in ItemList[CurrentIndex] */
   TW_UINT32  DefaultIndex; /* Powerup value is in ItemList[DefaultIndex] */
   TW_UINT8   ItemList[1];  /* Array of ItemType values starts here       */
} TW_ENUMERATION, FAR * pTW_ENUMERATION;

/* TWON_ONEVALUE. Container for one value. */
typedef struct TW_ONEVALUE {
   TW_UINT16  ItemType;
   TW_UINT32  Item;
} TW_ONEVALUE, FAR * pTW_ONEVALUE;

/* TWON_RANGE. Container for a range of values. */
typedef struct TW_RANGE {
   TW_UINT16  ItemType;
   TW_UINT32  MinValue;     /* Starting value in the range.           */
   TW_UINT32  MaxValue;     /* Final value in the range.              */
   TW_UINT32  StepSize;     /* Increment from MinValue to MaxValue.   */
   TW_UINT32  DefaultValue; /* Power-up value.                        */
   TW_UINT32  CurrentValue; /* The value that is currently in effect. */
} TW_RANGE, FAR * pTW_RANGE;

/* DAT_CAPABILITY. Used by application to get/set capability from/in a data source. */
typedef struct TW_CAPABILITY {
   TW_UINT16  Cap; /* id of capability to set or get, e.g. CAP_BRIGHTNESS */
   TW_UINT16  ConType; /* TWON_ONEVALUE, _RANGE, _ENUMERATION or _ARRAY   */
   TW_HANDLE  hContainer; /* Handle to container of type Dat              */
} TW_CAPABILITY, FAR * pTW_CAPABILITY;

/* DAT_CIECOLOR. */
typedef struct TW_CIECOLOR {
   TW_UINT16           ColorSpace;
   TW_INT16            LowEndian;
   TW_INT16            DeviceDependent;
   TW_INT32            VersionNumber;
   TW_TRANSFORMSTAGE   StageABC;
   TW_TRANSFORMSTAGE   StageLMN;
   TW_CIEPOINT         WhitePoint;
   TW_CIEPOINT         BlackPoint;
   TW_CIEPOINT         WhitePaper;
   TW_CIEPOINT         BlackInk;
   TW_FIX32            Samples[1];
} TW_CIECOLOR, FAR * pTW_CIECOLOR;

/* DAT_EVENT. For passing events down from the application to the DS. */
typedef struct TW_EVENT {
   TW_MEMREF  pEvent;    /* Windows pMSG or Mac pEvent.                 */
   TW_UINT16  TWMessage; /* TW msg from data source, e.g. MSG_XFERREADY */
} TW_EVENT, FAR * pTW_EVENT;

/* DAT_GRAYRESPONSE */
typedef struct TW_GRAYRESPONSE {
   TW_ELEMENT8         Response[1];
} TW_GRAYRESPONSE, FAR * pTW_GRAYRESPONSE;

/* DAT_IDENTITY. Identifies the program/library/code resource. */
typedef struct TW_IDENTITY {
   TW_MEMREF  Id;              /* Unique number.  In Windows, application hWnd      */
   TW_VERSION Version;         /* Identifies the piece of code              */
   TW_UINT16  ProtocolMajor;   /* Application and DS must set to TWON_PROTOCOLMAJOR */
   TW_UINT16  ProtocolMinor;   /* Application and DS must set to TWON_PROTOCOLMINOR */
   TW_UINT32  SupportedGroups; /* Bit field OR combination of DG_ constants */
   TW_STR32   Manufacturer;    /* Manufacturer name, e.g. "Hewlett-Packard" */
   TW_STR32   ProductFamily;   /* Product family name, e.g. "ScanJet"       */
   TW_STR32   ProductName;     /* Product name, e.g. "ScanJet Plus"         */
} TW_IDENTITY, FAR * pTW_IDENTITY;

/* DAT_IMAGEINFO. Application gets detailed image info from DS with this. */
typedef struct TW_IMAGEINFO {
   TW_FIX32   XResolution;      /* Resolution in the horizontal             */
   TW_FIX32   YResolution;      /* Resolution in the vertical               */
   TW_INT32   ImageWidth;       /* Columns in the image, -1 if unknown by DS*/
   TW_INT32   ImageLength;      /* Rows in the image, -1 if unknown by DS   */
   TW_INT16   SamplesPerPixel;  /* Number of samples per pixel, 3 for RGB   */
   TW_INT16   BitsPerSample[8]; /* Number of bits for each sample           */
   TW_INT16   BitsPerPixel;     /* Number of bits for each padded pixel     */
   TW_BOOL    Planar;           /* True if Planar, False if chunky          */
   TW_INT16   PixelType;        /* How to interp data; photo interp (TWPT_) */
   TW_UINT16  Compression;      /* How the data is compressed (TWCP_xxxx)   */
} TW_IMAGEINFO, FAR * pTW_IMAGEINFO;

/* DAT_IMAGELAYOUT. Provides image layout information in current units. */
typedef struct TW_IMAGELAYOUT {
   TW_FRAME   Frame;          /* Frame coords within larger document */
   TW_UINT32  DocumentNumber;
   TW_UINT32  PageNumber;     /* Reset when you go to next document  */
   TW_UINT32  FrameNumber;    /* Reset when you go to next page      */
} TW_IMAGELAYOUT, FAR * pTW_IMAGELAYOUT;

/* DAT_IMAGEMEMXFER. Used to pass image data (e.g. in strips) from DS to application.*/
typedef struct TW_IMAGEMEMXFER {
   TW_UINT16  Compression;  /* How the data is compressed                */
   TW_UINT32  BytesPerRow;  /* Number of bytes in a row of data          */
   TW_UINT32  Columns;      /* How many columns                          */
   TW_UINT32  Rows;         /* How many rows                             */
   TW_UINT32  XOffset;      /* How far from the side of the image        */
   TW_UINT32  YOffset;      /* How far from the top of the image         */
   TW_UINT32  BytesWritten; /* How many bytes written in Memory          */
   TW_MEMORY  Memory;       /* Mem struct used to pass actual image data */
} TW_IMAGEMEMXFER, FAR * pTW_IMAGEMEMXFER;

/* Changed in 1.1: QuantTable, HuffmanDC, HuffmanAC TW_MEMREF -> TW_MEMORY  */
/* DAT_JPEGCOMPRESSION. Based on JPEG Draft International Std, ver 10918-1. */
typedef struct TW_JPEGCOMPRESSION {
   TW_UINT16   ColorSpace;       /* One of the TWPT_xxxx values                */
   TW_UINT32   SubSampling;      /* Two word "array" for subsampling values    */
   TW_UINT16   NumComponents;    /* Number of color components in image        */
   TW_UINT16   RestartFrequency; /* Frequency of restart marker codes in MDU's */
   TW_UINT16   QuantMap[4];      /* Mapping of components to QuantTables       */
   TW_MEMORY   QuantTable[4];    /* Quantization tables                        */
   TW_UINT16   HuffmanMap[4];    /* Mapping of components to Huffman tables    */
   TW_MEMORY   HuffmanDC[2];     /* DC Huffman tables                          */
   TW_MEMORY   HuffmanAC[2];     /* AC Huffman tables                          */
} TW_JPEGCOMPRESSION, FAR * pTW_JPEGCOMPRESSION;

/* DAT_PALETTE8. Color palette when TWPT_PALETTE pixels xfer'd in mem buf. */
typedef struct TW_PALETTE8 {
   TW_UINT16    NumColors;   /* Number of colors in the color table.  */
   TW_UINT16    PaletteType; /* TWPA_xxxx, specifies type of palette. */
   TW_ELEMENT8  Colors[256]; /* Array of palette values starts here.  */
} TW_PALETTE8, FAR * pTW_PALETTE8;

/* DAT_PENDINGXFERS. Used with MSG_ENDXFER to indicate additional data. */
typedef struct TW_PENDINGXFERS {
   TW_UINT16 Count;
   union {
      TW_UINT32 EOJ;
      TW_UINT32 Reserved;
   } TW_JOBCONTROL;
} TW_PENDINGXFERS, FAR *pTW_PENDINGXFERS;

/* DAT_RGBRESPONSE */
typedef struct TW_RGBRESPONSE {
   TW_ELEMENT8         Response[1];
} TW_RGBRESPONSE, FAR * pTW_RGBRESPONSE;

/* DAT_SETUPFILEXFER. Sets up DS to application data transfer via a file. */
typedef struct TW_SETUPFILEXFER {
   TW_STR255 FileName;
   TW_UINT16 Format;   /* Any TWFF_ constant */
   TW_INT16  VRefNum;  /* Used for Mac only  */
} TW_SETUPFILEXFER, FAR * pTW_SETUPFILEXFER;

/* DAT_SETUPFILEXFER2. Sets up DS to application data transfer via a file. */
/* Added 1.9                                                               */
typedef struct TW_SETUPFILEXFER2 {
   TW_MEMREF FileName;     /* Pointer to file name text */
   TW_UINT16 FileNameType; /* TWTY_STR1024 or TWTY_UNI512 */
   TW_UINT16 Format;       /* Any TWFF_ constant */
   TW_INT16  VRefNum;      /* Used for Mac only  */
   TW_UINT32 ParID;        /* Used for Mac only */
} TW_SETUPFILEXFER2, FAR * pTW_SETUPFILEXFER2;

/* DAT_SETUPMEMXFER. Sets up DS to application data transfer via a memory buffer. */
typedef struct TW_SETUPMEMXFER {
   TW_UINT32 MinBufSize;
   TW_UINT32 MaxBufSize;
   TW_UINT32 Preferred;
} TW_SETUPMEMXFER, FAR * pTW_SETUPMEMXFER;

/* DAT_STATUS. Application gets detailed status info from a data source with this. */
typedef struct TW_STATUS {
   TW_UINT16  ConditionCode; /* Any TWCC_ constant     */
   TW_UINT16  Reserved;      /* Future expansion space */
} TW_STATUS, FAR * pTW_STATUS;

/* DAT_USERINTERFACE. Coordinates UI between application and data source. */
typedef struct TW_USERINTERFACE {
   TW_BOOL    ShowUI;  /* TRUE if DS should bring up its UI           */
   TW_BOOL    ModalUI; /* For Mac only - true if the DS's UI is modal */
   TW_HANDLE  hParent; /* For windows only - Application window handle        */
} TW_USERINTERFACE, FAR * pTW_USERINTERFACE;

/* SDH - 03/21/95 - TWUNK */
/* DAT_TWUNKIDENTITY. Provides DS identity and 'other' information necessary */
/*                    across thunk link. */
typedef struct TW_TWUNKIDENTITY {
   TW_IDENTITY identity;        /* Identity of data source.                 */
   TW_STR255   dsPath;          /* Full path and file name of data source.  */
} TW_TWUNKIDENTITY, FAR * pTW_TWUNKIDENTITY;

/* SDH - 03/21/95 - TWUNK */
/* Provides DS_Entry parameters over thunk link. */
typedef struct
{
    TW_INT8     destFlag;       /* TRUE if dest is not NULL                 */
    TW_IDENTITY dest;           /* Identity of data source (if used)        */
    TW_INT32    dataGroup;      /* DSM_Entry dataGroup parameter            */
    TW_INT16    dataArgType;    /* DSM_Entry dataArgType parameter          */
    TW_INT16    message;        /* DSM_Entry message parameter              */
    TW_INT32    pDataSize;      /* Size of pData (0 if NULL)                */
    //  TW_MEMREF   pData;      /* Based on implementation specifics, a     */
                                /* pData parameter makes no sense in this   */
                                /* structure, but data (if provided) will be*/
                                /* appended in the data block.              */
   } TW_TWUNKDSENTRYPARAMS, FAR * pTW_TWUNKDSENTRYPARAMS;

/* SDH - 03/21/95 - TWUNK */
/* Provides DS_Entry results over thunk link. */
typedef struct
{
    TW_UINT16   returnCode;     /* Thunker DsEntry return code.             */
    TW_UINT16   conditionCode;  /* Thunker DsEntry condition code.          */
    TW_INT32    pDataSize;      /* Size of pData (0 if NULL)                */
    //  TW_MEMREF   pData;      /* Based on implementation specifics, a     */
                                /* pData parameter makes no sense in this   */
                                /* structure, but data (if provided) will be*/
                                /* appended in the data block.              */
} TW_TWUNKDSENTRYRETURN, FAR * pTW_TWUNKDSENTRYRETURN;

/* WJD - 950818 */
/* Added for 1.6 Specification */
/* TWAIN 1.6 CAP_SUPPORTEDCAPSEXT structure */
typedef struct
{
    TW_UINT16 Cap;   /* Which CAP/ICAP info is relevant to */
    TW_UINT16 Properties;  /* Messages this CAP/ICAP supports */
} TW_CAPEXT, FAR * pTW_CAPEXT;

/* ----------------------------------------------------------------------- *\

  Version 1.7:      Added Following data structure for Document Imaging 
  July 1997         Enhancement.
  KHL               TW_CUSTOMDSDATA --  For Saving and Restoring Source's 
                                        state.
                    TW_INFO         --  Each attribute for extended image
                                        information.
                    TW_EXTIMAGEINFO --  Extended image information structure.

\* ----------------------------------------------------------------------- */

typedef struct TW_CUSTOMDSDATA {
    TW_UINT32  InfoLength;     /* Length of Information in bytes.  */
    TW_HANDLE  hData;          /* Place holder for data, DS Allocates */
}TW_CUSTOMDSDATA, FAR *pTW_CUSTOMDSDATA;

typedef struct TW_INFO {
    TW_UINT16   InfoID;
    TW_UINT16   ItemType;
    TW_UINT16   NumItems;
    TW_UINT16   CondCode;
    TW_UINT32   Item;
}TW_INFO, FAR* pTW_INFO;

typedef struct TW_EXTIMAGEINFO {
    TW_UINT32   NumInfos;
    TW_INFO     Info[1];
}TW_EXTIMAGEINFO, FAR* pTW_EXTIMAGEINFO;

/* Added 1.8 */

/* DAT_AUDIOINFO, information about audio data */
typedef struct TW_AUDIOINFO {
   TW_STR255  Name;       /* name of audio data */
   TW_UINT32  Reserved;   /* reserved space */
} TW_AUDIOINFO, FAR * pTW_AUDIOINFO;

/* DAT_DEVICEEVENT, information about events */
typedef struct TW_DEVICEEVENT {
   TW_UINT32  Event;                  /* One of the TWDE_xxxx values. */
   TW_STR255  DeviceName;             /* The name of the device that generated the event */
   TW_UINT32  BatteryMinutes;         /* Battery Minutes Remaining    */
   TW_INT16   BatteryPercentage;      /* Battery Percentage Remaining */
   TW_INT32   PowerSupply;            /* Power Supply                 */
   TW_FIX32   XResolution;            /* Resolution                   */
   TW_FIX32   YResolution;            /* Resolution                   */
   TW_UINT32  FlashUsed2;             /* Flash Used2                  */
   TW_UINT32  AutomaticCapture;       /* Automatic Capture            */
   TW_UINT32  TimeBeforeFirstCapture; /* Automatic Capture            */
   TW_UINT32  TimeBetweenCaptures;    /* Automatic Capture            */
} TW_DEVICEEVENT, FAR * pTW_DEVICEEVENT;

/* DAT_FILESYSTEM, information about TWAIN file system */
typedef struct TW_FILESYSTEM {
   /* DG_CONTROL / DAT_FILESYSTEM / MSG_xxxx fields     */
   TW_STR255  InputName; /* The name of the input or source file */
   TW_STR255  OutputName; /* The result of an operation or the name of a destination file */
   TW_MEMREF  Context; /* Source specific data used to remember state information */
   /* DG_CONTROL / DAT_FILESYSTEM / MSG_DELETE field    */
   int        Recursive; /* recursively delete all sub-directories */
   /* DG_CONTROL / DAT_FILESYSTEM / MSG_GETINFO fields  */
   TW_INT32   FileType; /* One of the TWFT_xxxx values */
   TW_UINT32  Size; /* Size of current FileType */
   TW_STR32   CreateTimeDate; /* creation date of the file */
   TW_STR32   ModifiedTimeDate; /* last date the file was modified */
   TW_UINT32  FreeSpace; /* bytes of free space on the current device */
   TW_INT32   NewImageSize; /* estimate of the amount of space a new image would take up */
   TW_UINT32  NumberOfFiles; /* number of files, depends on FileType */
   TW_UINT32  NumberOfSnippets; /* number of audio snippets */
   TW_UINT32  DeviceGroupMask; /* used to group cameras (ex: front/rear bitonal, front/rear grayscale...) */
   char       Reserved[508]; /**/
} TW_FILESYSTEM, FAR * pTW_FILESYSTEM;

/* DAT_PASSTHRU, device dependant data to pass through Data Source */
typedef struct TW_PASSTHRU {
   TW_MEMREF  pCommand;        /* Pointer to Command buffer */
   TW_UINT32  CommandBytes;    /* Number of bytes in Command buffer */
   TW_INT32   Direction;       /* One of the TWDR_xxxx values.  Defines the direction of data flow */
   TW_MEMREF  pData;           /* Pointer to Data buffer */
   TW_UINT32  DataBytes;       /* Number of bytes in Data buffer */
   TW_UINT32  DataBytesXfered; /* Number of bytes successfully transferred */
} TW_PASSTHRU, FAR * pTW_PASSTHRU;

/* DAT_SETUPAUDIOFILEXFER, information required to setup an audio file transfer */
typedef struct TW_SETUPAUDIOFILEXFER {
   TW_STR255  FileName; /* full path target file */
   TW_UINT16  Format;   /* one of TWAF_xxxx */
   TW_INT16 VRefNum;
} TW_SETUPAUDIOFILEXFER, FAR * pTW_SETUPAUDIOFILEXFER;

/* Added 2.0 */

/* TW_CALLBACK, used to register/invoke callbacks */
typedef struct TW_CALLBACK {
    TW_MEMREF 	CallBackProc;		/* DSMENTRYPROC used with DAT_CALLBACK/MSG_REGISTER_CALLBACK */
    TW_MEMREF	RefCon;				/* refCon used with DAT_CALLBACK/MSG_REGISTER_CALLBACK and DAT_CALLBACK/MSG_INVOKE_CALLBACK */
    TW_INT16    Message;			/* message used with DAT_CALLBACK/MSG_INVOKE_CALLBACK */
} TW_CALLBACK, FAR * pTW_CALLBACK;

/****************************************************************************
 * Generic Constants                                                        *
 ****************************************************************************/

#define TWON_ARRAY           3 /* indicates TW_ARRAY container       */
#define TWON_ENUMERATION     4 /* indicates TW_ENUMERATION container */
#define TWON_ONEVALUE        5 /* indicates TW_ONEVALUE container    */
#define TWON_RANGE           6 /* indicates TW_RANGE container       */

#define TWON_ICONID          962 /* res Id of icon used in USERSELECT lbox */
#define TWON_DSMID           461 /* res Id of the DSM version num resource */
#define TWON_DSMCODEID       63  /* res Id of the Mac SM Code resource     */

#define TWON_DONTCARE8       0xff
#define TWON_DONTCARE16      0xffff
#define TWON_DONTCARE32      0xffffffff

/* Flags used in TW_MEMORY structure. */
#define TWMF_APPOWNS     0x1
#define TWMF_DSMOWNS     0x2
#define TWMF_DSOWNS      0x4
#define TWMF_POINTER     0x8
#define TWMF_HANDLE      0x10

/* Palette types for TW_PALETTE8 */
#define TWPA_RGB         0
#define TWPA_GRAY        1
#define TWPA_CMY         2

/* There are four containers used for capabilities negotiation:
 *    TWON_ONEVALUE, TWON_RANGE, TWON_ENUMERATION, TWON_ARRAY
 * In each container structure ItemType can be TWTY_INT8, TWTY_INT16, etc.
 * The kind of data stored in the container can be determined by doing
 * DCItemSize[ItemType] where the following is defined in TWAIN glue code:
 *          DCItemSize[]= { sizeof(TW_INT8),
 *                          sizeof(TW_INT16),
 *                          etc.
 *                          sizeof(TW_UINT32) };
 *
 */

#define TWTY_INT8        0x0000    /* Means Item is a TW_INT8   */
#define TWTY_INT16       0x0001    /* Means Item is a TW_INT16  */
#define TWTY_INT32       0x0002    /* Means Item is a TW_INT32  */

#define TWTY_UINT8       0x0003    /* Means Item is a TW_UINT8  */
#define TWTY_UINT16      0x0004    /* Means Item is a TW_UINT16 */
#define TWTY_UINT32      0x0005    /* Means Item is a TW_UINT32 */

#define TWTY_BOOL        0x0006    /* Means Item is a TW_BOOL   */

#define TWTY_FIX32       0x0007    /* Means Item is a TW_FIX32  */

#define TWTY_FRAME       0x0008    /* Means Item is a TW_FRAME  */

#define TWTY_STR32       0x0009    /* Means Item is a TW_STR32  */
#define TWTY_STR64       0x000a    /* Means Item is a TW_STR64  */
#define TWTY_STR128      0x000b    /* Means Item is a TW_STR128 */
#define TWTY_STR255      0x000c    /* Means Item is a TW_STR255 */
#define TWTY_STR1024     0x000d    /* Means Item is a TW_STR1024...added 1.9 */
#define TWTY_UNI512      0x000e    /* Means Item is a TW_UNI512...added 1.9 */

/****************************************************************************
 * Capability Constants                                                     *
 ****************************************************************************/

/* ICAP_BITORDER values (BO_ means Bit Order) */
#define TWBO_LSBFIRST    0
#define TWBO_MSBFIRST    1

/* ICAP_COMPRESSION values (CP_ means ComPression ) */
#define TWCP_NONE        0
#define TWCP_PACKBITS    1
#define TWCP_GROUP31D    2 /* Follows CCITT spec (no End Of Line)          */
#define TWCP_GROUP31DEOL 3 /* Follows CCITT spec (has End Of Line)         */
#define TWCP_GROUP32D    4 /* Follows CCITT spec (use cap for K Factor)    */
#define TWCP_GROUP4      5 /* Follows CCITT spec                           */
#define TWCP_JPEG        6 /* Use capability for more info                 */
#define TWCP_LZW         7 /* Must license from Unisys and IBM to use      */
#define TWCP_JBIG        8 /* For Bitonal images  -- Added 1.7 KHL         */
/* Added 1.8 */
#define TWCP_PNG         9
#define TWCP_RLE4        10
#define TWCP_RLE8        11
#define TWCP_BITFIELDS   12


/* ICAP_IMAGEFILEFORMAT values (FF_means File Format)   */
#define TWFF_TIFF        0    /* Tagged Image File Format     */
#define TWFF_PICT        1    /* Macintosh PICT               */
#define TWFF_BMP         2    /* Windows Bitmap               */
#define TWFF_XBM         3    /* X-Windows Bitmap             */
#define TWFF_JFIF        4    /* JPEG File Interchange Format */
#define TWFF_FPX         5    /* Flash Pix                    */
#define TWFF_TIFFMULTI   6    /* Multi-page tiff file         */
#define TWFF_PNG         7
#define TWFF_SPIFF       8
#define TWFF_EXIF        9


/* ICAP_FILTER values (FT_ means Filter Type) */
#define TWFT_RED         0
#define TWFT_GREEN       1
#define TWFT_BLUE        2
#define TWFT_NONE        3
#define TWFT_WHITE       4
#define TWFT_CYAN        5
#define TWFT_MAGENTA     6
#define TWFT_YELLOW      7
#define TWFT_BLACK       8

/* ICAP_LIGHTPATH values (LP_ means Light Path) */
#define TWLP_REFLECTIVE   0
#define TWLP_TRANSMISSIVE 1

/* ICAP_LIGHTSOURCE values (LS_ means Light Source) */
#define TWLS_RED         0
#define TWLS_GREEN       1
#define TWLS_BLUE        2
#define TWLS_NONE        3
#define TWLS_WHITE       4
#define TWLS_UV          5
#define TWLS_IR          6

/* ICAP_ORIENTATION values (OR_ means ORientation) */
#define TWOR_ROT0        0
#define TWOR_ROT90       1
#define TWOR_ROT180      2
#define TWOR_ROT270      3
#define TWOR_PORTRAIT    TWOR_ROT0
#define TWOR_LANDSCAPE   TWOR_ROT270

/* ICAP_PLANARCHUNKY values (PC_ means Planar/Chunky ) */
#define TWPC_CHUNKY      0
#define TWPC_PLANAR      1

/* ICAP_PIXELFLAVOR values (PF_ means Pixel Flavor) */
#define TWPF_CHOCOLATE   0  /* zero pixel represents darkest shade  */
#define TWPF_VANILLA     1  /* zero pixel represents lightest shade */

/* ICAP_PIXELTYPE values (PT_ means Pixel Type) */
#define TWPT_BW          0 /* Black and White */
#define TWPT_GRAY        1
#define TWPT_RGB         2
#define TWPT_PALETTE     3
#define TWPT_CMY         4
#define TWPT_CMYK        5
#define TWPT_YUV         6
#define TWPT_YUVK        7
#define TWPT_CIEXYZ      8

/* ICAP_SUPPORTEDSIZES values (SS_ means Supported Sizes) */
#define TWSS_NONE        0
#define TWSS_A4LETTER    1
#define TWSS_B5LETTER    2
#define TWSS_USLETTER    3
#define TWSS_USLEGAL     4
/* Added 1.5 */
#define TWSS_A5          5
#define TWSS_B4          6
#define TWSS_B6          7
//#define TWSS_B          8
/* Added 1.7 */
#define TWSS_USLEDGER    9
#define TWSS_USEXECUTIVE 10
#define TWSS_A3          11
#define TWSS_B3          12
#define TWSS_A6          13
#define TWSS_C4          14
#define TWSS_C5          15
#define TWSS_C6          16
/* Added 1.8 */
#define TWSS_4A0          17
#define TWSS_2A0          18
#define TWSS_A0           19
#define TWSS_A1           20
#define TWSS_A2           21
#define TWSS_A4           TWSS_A4LETTER
#define TWSS_A7           22
#define TWSS_A8           23
#define TWSS_A9           24
#define TWSS_A10          25
#define TWSS_ISOB0        26
#define TWSS_ISOB1        27
#define TWSS_ISOB2        28
#define TWSS_ISOB3        TWSS_B3
#define TWSS_ISOB4        TWSS_B4
#define TWSS_ISOB5        29
#define TWSS_ISOB6        TWSS_B6
#define TWSS_ISOB7        30
#define TWSS_ISOB8        31
#define TWSS_ISOB9        32
#define TWSS_ISOB10       33
#define TWSS_JISB0        34
#define TWSS_JISB1        35
#define TWSS_JISB2        36
#define TWSS_JISB3        37
#define TWSS_JISB4        38
#define TWSS_JISB5        TWSS_B5LETTER
#define TWSS_JISB6        39
#define TWSS_JISB7        40
#define TWSS_JISB8        41
#define TWSS_JISB9        42
#define TWSS_JISB10       43
#define TWSS_C0           44
#define TWSS_C1           45
#define TWSS_C2           46
#define TWSS_C3           47
#define TWSS_C7           48
#define TWSS_C8           49
#define TWSS_C9           50
#define TWSS_C10          51
#define TWSS_USSTATEMENT  52
#define TWSS_BUSINESSCARD 53

/* ICAP_XFERMECH values (SX_ means Setup XFer) */
#define TWSX_NATIVE      0
#define TWSX_FILE        1
#define TWSX_MEMORY      2
#define TWSX_FILE2       3    /* added 1.9 */

/* ICAP_UNITS values (UN_ means UNits) */
#define TWUN_INCHES      0
#define TWUN_CENTIMETERS 1
#define TWUN_PICAS       2
#define TWUN_POINTS      3
#define TWUN_TWIPS       4
#define TWUN_PIXELS      5

/* Added 1.5 */
/* ICAP_BITDEPTHREDUCTION values (BR_ means Bitdepth Reduction) */
#define TWBR_THRESHOLD     0
#define TWBR_HALFTONE      1
#define TWBR_CUSTHALFTONE  2
#define TWBR_DIFFUSION     3

/* Added 1.7 */
/* ICAP_DUPLEX values */
#define TWDX_NONE         0
#define TWDX_1PASSDUPLEX  1
#define TWDX_2PASSDUPLEX  2

/* Added 1.7 */
/* TWEI_BARCODETYPE values */
#define TWBT_3OF9                 0
#define TWBT_2OF5INTERLEAVED      1
#define TWBT_2OF5NONINTERLEAVED   2
#define TWBT_CODE93               3
#define TWBT_CODE128              4
#define TWBT_UCC128               5
#define TWBT_CODABAR              6
#define TWBT_UPCA                 7
#define TWBT_UPCE                 8
#define TWBT_EAN8                 9
#define TWBT_EAN13                10
#define TWBT_POSTNET              11
#define TWBT_PDF417               12
/* Added 1.8 */
#define TWBT_2OF5INDUSTRIAL       13
#define TWBT_2OF5MATRIX           14
#define TWBT_2OF5DATALOGIC        15
#define TWBT_2OF5IATA             16
#define TWBT_3OF9FULLASCII        17
#define TWBT_CODABARWITHSTARTSTOP 18
#define TWBT_MAXICODE             19

/* Added 1.7 */
/* TWEI_DESKEWSTATUS values */
#define TWDSK_SUCCESS     0
#define TWDSK_REPORTONLY  1
#define TWDSK_FAIL        2
#define TWDSK_DISABLED    3

/* Added 1.7 */
/* TWEI_PATCHCODE values */
#define TWPCH_PATCH1      0
#define TWPCH_PATCH2      1
#define TWPCH_PATCH3      2
#define TWPCH_PATCH4      3
#define TWPCH_PATCH6      4
#define TWPCH_PATCHT      5

/* Added 1.7 */
/* CAP_JOBCONTROL values */
#define TWJC_NONE   0
#define TWJC_JSIC   1
#define TWJC_JSIS   2
#define TWJC_JSXC   3
#define TWJC_JSXS   4
                  
/* Added 1.7 */
/* TWEI_BARCODEROTATION values (BCOR_ means barcode rotation) */
#define TWBCOR_ROT0   0
#define TWBCOR_ROT90  1
#define TWBCOR_ROT180 2
#define TWBCOR_ROT270 3
#define TWBCOR_ROTX   4

/* Added 1.8 */
/* ACAP_AUDIOFILEFORMAT values (AF_ means audio format) */
#define TWAF_WAV      0
#define TWAF_AIFF     1
#define TWAF_AU       3
#define TWAF_SND      4

/* CAP_ALARMS values (AL_ means alarms) */
#define TWAL_ALARM          0
#define TWAL_FEEDERERROR    1
#define TWAL_FEEDERWARNING  2
#define TWAL_BARCODE        3
#define TWAL_DOUBLEFEED     4
#define TWAL_JAM            5
#define TWAL_PATCHCODE      6
#define TWAL_POWER          7
#define TWAL_SKEW           8

/* CAP_CLEARBUFFERS values (CB_ means clear buffers) */
#define TWCB_AUTO           0
#define TWCB_CLEAR          1
#define TWCB_NOCLEAR        2

/* CAP_DEVICEEVENT values (DE_ means device event) */
#define TWDE_CUSTOMEVENTS           0x8000      
#define TWDE_CHECKAUTOMATICCAPTURE  0
#define TWDE_CHECKBATTERY           1
#define TWDE_CHECKDEVICEONLINE      2
#define TWDE_CHECKFLASH             3
#define TWDE_CHECKPOWERSUPPLY       4
#define TWDE_CHECKRESOLUTION        5
#define TWDE_DEVICEADDED            6
#define TWDE_DEVICEOFFLINE          7
#define TWDE_DEVICEREADY            8
#define TWDE_DEVICEREMOVED          9
#define TWDE_IMAGECAPTURED          10
#define TWDE_IMAGEDELETED           11
#define TWDE_PAPERDOUBLEFEED        12
#define TWDE_PAPERJAM               13
#define TWDE_LAMPFAILURE            14
#define TWDE_POWERSAVE              15
#define TWDE_POWERSAVENOTIFY        16

/* CAP_FEEDERALIGNMENT values (FA_ means feeder alignment) */
#define TWFA_NONE   0
#define TWFA_LEFT   1
#define TWFA_CENTER 2
#define TWFA_RIGHT  3

/* CAP_FEEDERORDER values (FO_ means feeder order) */
#define TWFO_FIRSTPAGEFIRST 0
#define TWFO_LASTPAGEFIRST  1

/* CAP_FILESYSTEM values (FS_ means file system) */
#define TWFS_FILESYSTEM       0
#define TWFS_RECURSIVEDELETE  1

/* CAP_POWERSUPPLY values (PS_ means power supply) */
#define TWPS_EXTERNAL 0
#define TWPS_BATTERY  1

/* CAP_PRINTER values (PR_ means printer) */
#define TWPR_IMPRINTERTOPBEFORE     0
#define TWPR_IMPRINTERTOPAFTER      1
#define TWPR_IMPRINTERBOTTOMBEFORE  2
#define TWPR_IMPRINTERBOTTOMAFTER   3
#define TWPR_ENDORSERTOPBEFORE      4
#define TWPR_ENDORSERTOPAFTER       5
#define TWPR_ENDORSERBOTTOMBEFORE   6
#define TWPR_ENDORSERBOTTOMAFTER    7

/* CAP_PRINTERMODE values (PM_ means printer mode) */
#define TWPM_SINGLESTRING     0
#define TWPM_MULTISTRING      1
#define TWPM_COMPOUNDSTRING   2

/* ICAP_BARCODESEARCHMODE values (TWBD_ means search) */
#define TWBD_HORZ     0
#define TWBD_VERT     1
#define TWBD_HORZVERT 2
#define TWBD_VERTHORZ 3

/* ICAP_FLASHUSED2 values (FL_ means flash) */
#define TWFL_NONE     0
#define TWFL_OFF      1
#define TWFL_ON       2
#define TWFL_AUTO     3
#define TWFL_REDEYE   4

/* ICAP_FLIPROTATION values (FR_ means flip rotation) */
#define TWFR_BOOK     0
#define TWFR_FANFOLD  1

/* ICAP_IMAGEFILTER values (IF_ means image filter) */
#define TWIF_NONE     0
#define TWIF_AUTO     1
#define TWIF_LOWPASS  2
#define TWIF_BANDPASS 3
#define TWIF_HIGHPASS 4
#define TWIF_TEXT     TWIF_BANDPASS
#define TWIF_FINELINE TWIF_HIGHPASS

/* ICAP_NOISEFILTER values (NF_ means noise filter) */
#define TWNF_NONE         0
#define TWNF_AUTO         1
#define TWNF_LONEPIXEL    2
#define TWNF_MAJORITYRULE 3

/* ICAP_OVERSCAN values (OV_ means overscan) */
#define TWOV_NONE       0
#define TWOV_AUTO       1
#define TWOV_TOPBOTTOM  2
#define TWOV_LEFTRIGHT  3
#define TWOV_ALL        4

/* TW_FILESYSTEM.FileType values (FT_ means file type) */
#define TWFY_CAMERA         0
#define TWFY_CAMERATOP      1
#define TWFY_CAMERABOTTOM   2
#define TWFY_CAMERAPREVIEW  3
#define TWFY_DOMAIN         4
#define TWFY_HOST           5
#define TWFY_DIRECTORY      6
#define TWFY_IMAGE          7
#define TWFY_UNKNOWN        8

/* ICAP_JPEGQUALITY values (JQ_ means jpeg quality) */
#define TWJQ_UNKNOWN       -4 
#define TWJQ_LOW           -3
#define TWJQ_MEDIUM        -2
#define TWJQ_HIGH          -1

/****************************************************************************
 * Country Constants                                                        *
 ****************************************************************************/

#define TWCY_AFGHANISTAN   1001
#define TWCY_ALGERIA        213
#define TWCY_AMERICANSAMOA  684
#define TWCY_ANDORRA        033
#define TWCY_ANGOLA        1002
#define TWCY_ANGUILLA      8090
#define TWCY_ANTIGUA       8091
#define TWCY_ARGENTINA       54
#define TWCY_ARUBA          297
#define TWCY_ASCENSIONI     247
#define TWCY_AUSTRALIA       61
#define TWCY_AUSTRIA         43
#define TWCY_BAHAMAS       8092
#define TWCY_BAHRAIN        973
#define TWCY_BANGLADESH     880
#define TWCY_BARBADOS      8093
#define TWCY_BELGIUM         32
#define TWCY_BELIZE         501
#define TWCY_BENIN          229
#define TWCY_BERMUDA       8094
#define TWCY_BHUTAN        1003
#define TWCY_BOLIVIA        591
#define TWCY_BOTSWANA       267
#define TWCY_BRITAIN          6
#define TWCY_BRITVIRGINIS  8095
#define TWCY_BRAZIL          55
#define TWCY_BRUNEI         673
#define TWCY_BULGARIA       359
#define TWCY_BURKINAFASO   1004
#define TWCY_BURMA         1005
#define TWCY_BURUNDI       1006
#define TWCY_CAMAROON       237
#define TWCY_CANADA           2
#define TWCY_CAPEVERDEIS    238
#define TWCY_CAYMANIS      8096
#define TWCY_CENTRALAFREP  1007
#define TWCY_CHAD          1008
#define TWCY_CHILE           56
#define TWCY_CHINA           86
#define TWCY_CHRISTMASIS   1009
#define TWCY_COCOSIS       1009
#define TWCY_COLOMBIA        57
#define TWCY_COMOROS       1010
#define TWCY_CONGO         1011
#define TWCY_COOKIS        1012
#define TWCY_COSTARICA     506
#define TWCY_CUBA           005
#define TWCY_CYPRUS         357
#define TWCY_CZECHOSLOVAKIA  42
#define TWCY_DENMARK         45
#define TWCY_DJIBOUTI      1013
#define TWCY_DOMINICA      8097
#define TWCY_DOMINCANREP   8098
#define TWCY_EASTERIS      1014
#define TWCY_ECUADOR        593
#define TWCY_EGYPT           20
#define TWCY_ELSALVADOR     503
#define TWCY_EQGUINEA      1015
#define TWCY_ETHIOPIA       251
#define TWCY_FALKLANDIS    1016
#define TWCY_FAEROEIS       298
#define TWCY_FIJIISLANDS    679
#define TWCY_FINLAND        358
#define TWCY_FRANCE          33
#define TWCY_FRANTILLES     596
#define TWCY_FRGUIANA       594
#define TWCY_FRPOLYNEISA    689
#define TWCY_FUTANAIS      1043
#define TWCY_GABON          241
#define TWCY_GAMBIA         220
#define TWCY_GERMANY         49
#define TWCY_GHANA          233
#define TWCY_GIBRALTER      350
#define TWCY_GREECE          30
#define TWCY_GREENLAND      299
#define TWCY_GRENADA       8099
#define TWCY_GRENEDINES    8015
#define TWCY_GUADELOUPE     590
#define TWCY_GUAM           671
#define TWCY_GUANTANAMOBAY 5399
#define TWCY_GUATEMALA      502
#define TWCY_GUINEA         224
#define TWCY_GUINEABISSAU  1017
#define TWCY_GUYANA         592
#define TWCY_HAITI          509
#define TWCY_HONDURAS       504
#define TWCY_HONGKONG      852
#define TWCY_HUNGARY         36
#define TWCY_ICELAND        354
#define TWCY_INDIA           91
#define TWCY_INDONESIA       62
#define TWCY_IRAN            98
#define TWCY_IRAQ           964
#define TWCY_IRELAND        353
#define TWCY_ISRAEL         972
#define TWCY_ITALY           39
#define TWCY_IVORYCOAST    225
#define TWCY_JAMAICA       8010
#define TWCY_JAPAN           81
#define TWCY_JORDAN         962
#define TWCY_KENYA          254
#define TWCY_KIRIBATI      1018
#define TWCY_KOREA           82
#define TWCY_KUWAIT         965
#define TWCY_LAOS          1019
#define TWCY_LEBANON       1020
#define TWCY_LIBERIA        231
#define TWCY_LIBYA          218
#define TWCY_LIECHTENSTEIN   41
#define TWCY_LUXENBOURG     352
#define TWCY_MACAO          853
#define TWCY_MADAGASCAR    1021
#define TWCY_MALAWI         265
#define TWCY_MALAYSIA        60
#define TWCY_MALDIVES       960
#define TWCY_MALI          1022
#define TWCY_MALTA          356
#define TWCY_MARSHALLIS     692
#define TWCY_MAURITANIA    1023
#define TWCY_MAURITIUS      230
#define TWCY_MEXICO           3
#define TWCY_MICRONESIA     691
#define TWCY_MIQUELON       508
#define TWCY_MONACO          33
#define TWCY_MONGOLIA      1024
#define TWCY_MONTSERRAT    8011
#define TWCY_MOROCCO        212
#define TWCY_MOZAMBIQUE    1025
#define TWCY_NAMIBIA        264
#define TWCY_NAURU         1026
#define TWCY_NEPAL          977
#define TWCY_NETHERLANDS     31
#define TWCY_NETHANTILLES   599
#define TWCY_NEVIS         8012
#define TWCY_NEWCALEDONIA   687
#define TWCY_NEWZEALAND      64
#define TWCY_NICARAGUA      505
#define TWCY_NIGER          227
#define TWCY_NIGERIA        234
#define TWCY_NIUE          1027
#define TWCY_NORFOLKI      1028
#define TWCY_NORWAY          47
#define TWCY_OMAN           968
#define TWCY_PAKISTAN        92
#define TWCY_PALAU         1029
#define TWCY_PANAMA         507
#define TWCY_PARAGUAY       595
#define TWCY_PERU            51
#define TWCY_PHILLIPPINES    63
#define TWCY_PITCAIRNIS    1030
#define TWCY_PNEWGUINEA     675
#define TWCY_POLAND          48
#define TWCY_PORTUGAL       351
#define TWCY_QATAR          974
#define TWCY_REUNIONI      1031
#define TWCY_ROMANIA         40
#define TWCY_RWANDA         250
#define TWCY_SAIPAN         670
#define TWCY_SANMARINO       39
#define TWCY_SAOTOME       1033
#define TWCY_SAUDIARABIA    966
#define TWCY_SENEGAL        221
#define TWCY_SEYCHELLESIS  1034
#define TWCY_SIERRALEONE   1035
#define TWCY_SINGAPORE       65
#define TWCY_SOLOMONIS     1036
#define TWCY_SOMALI        1037
#define TWCY_SOUTHAFRICA    27
#define TWCY_SPAIN           34
#define TWCY_SRILANKA        94
#define TWCY_STHELENA      1032
#define TWCY_STKITTS       8013
#define TWCY_STLUCIA       8014
#define TWCY_STPIERRE       508
#define TWCY_STVINCENT     8015
#define TWCY_SUDAN         1038
#define TWCY_SURINAME       597
#define TWCY_SWAZILAND      268
#define TWCY_SWEDEN          46
#define TWCY_SWITZERLAND     41
#define TWCY_SYRIA         1039
#define TWCY_TAIWAN         886
#define TWCY_TANZANIA       255
#define TWCY_THAILAND        66
#define TWCY_TOBAGO        8016
#define TWCY_TOGO           228
#define TWCY_TONGAIS        676
#define TWCY_TRINIDAD      8016
#define TWCY_TUNISIA        216
#define TWCY_TURKEY          90
#define TWCY_TURKSCAICOS   8017
#define TWCY_TUVALU        1040
#define TWCY_UGANDA         256
#define TWCY_USSR             7
#define TWCY_UAEMIRATES     971
#define TWCY_UNITEDKINGDOM   44
#define TWCY_USA              1
#define TWCY_URUGUAY        598
#define TWCY_VANUATU       1041
#define TWCY_VATICANCITY     39
#define TWCY_VENEZUELA       58
#define TWCY_WAKE          1042
#define TWCY_WALLISIS      1043
#define TWCY_WESTERNSAHARA 1044
#define TWCY_WESTERNSAMOA  1045
#define TWCY_YEMEN         1046
#define TWCY_YUGOSLAVIA      38
#define TWCY_ZAIRE          243
#define TWCY_ZAMBIA         260
#define TWCY_ZIMBABWE       263
/* Added for 1.8 */
#define TWCY_ALBANIA        355
#define TWCY_ARMENIA        374
#define TWCY_AZERBAIJAN     994
#define TWCY_BELARUS        375
#define TWCY_BOSNIAHERZGO   387
#define TWCY_CAMBODIA       855
#define TWCY_CROATIA        385
#define TWCY_CZECHREPUBLIC  420
#define TWCY_DIEGOGARCIA    246
#define TWCY_ERITREA        291
#define TWCY_ESTONIA        372
#define TWCY_GEORGIA        995
#define TWCY_LATVIA         371
#define TWCY_LESOTHO        266
#define TWCY_LITHUANIA      370
#define TWCY_MACEDONIA      389
#define TWCY_MAYOTTEIS      269
#define TWCY_MOLDOVA        373
#define TWCY_MYANMAR        95
#define TWCY_NORTHKOREA     850
#define TWCY_PUERTORICO     787
#define TWCY_RUSSIA         7
#define TWCY_SERBIA         381
#define TWCY_SLOVAKIA       421
#define TWCY_SLOVENIA       386
#define TWCY_SOUTHKOREA     82
#define TWCY_UKRAINE        380
#define TWCY_USVIRGINIS     340
#define TWCY_VIETNAM        84

/****************************************************************************
 * Language Constants                                                       *
 ****************************************************************************/

#define TWLG_DAN              0 /* Danish                 */
#define TWLG_DUT              1 /* Dutch                  */
#define TWLG_ENG              2 /* International English  */
#define TWLG_FCF              3 /* French Canadian        */
#define TWLG_FIN              4 /* Finnish                */
#define TWLG_FRN              5 /* French                 */
#define TWLG_GER              6 /* German                 */
#define TWLG_ICE              7 /* Icelandic              */
#define TWLG_ITN              8 /* Italian                */
#define TWLG_NOR              9 /* Norwegian              */
#define TWLG_POR             10 /* Portuguese             */
#define TWLG_SPA             11 /* Spanish                */
#define TWLG_SWE             12 /* Swedish                */
#define TWLG_USA             13 /* U.S. English           */
/* Added for 1.8 */
#define TWLG_USERLOCALE           -1
#define TWLG_AFRIKAANS            14  
#define TWLG_ALBANIA              15
#define TWLG_ARABIC               16
#define TWLG_ARABIC_ALGERIA       17
#define TWLG_ARABIC_BAHRAIN       18
#define TWLG_ARABIC_EGYPT         19
#define TWLG_ARABIC_IRAQ          20
#define TWLG_ARABIC_JORDAN        21
#define TWLG_ARABIC_KUWAIT        22
#define TWLG_ARABIC_LEBANON       23
#define TWLG_ARABIC_LIBYA         24
#define TWLG_ARABIC_MOROCCO       25
#define TWLG_ARABIC_OMAN          26
#define TWLG_ARABIC_QATAR         27
#define TWLG_ARABIC_SAUDIARABIA   28
#define TWLG_ARABIC_SYRIA         29
#define TWLG_ARABIC_TUNISIA       30
#define TWLG_ARABIC_UAE           31 /* United Arabic Emirates */
#define TWLG_ARABIC_YEMEN         32
#define TWLG_BASQUE               33
#define TWLG_BYELORUSSIAN         34
#define TWLG_BULGARIAN            35
#define TWLG_CATALAN              36
#define TWLG_CHINESE              37
#define TWLG_CHINESE_HONGKONG     38
#define TWLG_CHINESE_PRC          39 /* People's Republic of China */
#define TWLG_CHINESE_SINGAPORE    40
#define TWLG_CHINESE_SIMPLIFIED   41
#define TWLG_CHINESE_TAIWAN       42
#define TWLG_CHINESE_TRADITIONAL  43
#define TWLG_CROATIA              44
#define TWLG_CZECH                45
#define TWLG_DANISH               TWLG_DAN
#define TWLG_DUTCH                TWLG_DUT
#define TWLG_DUTCH_BELGIAN        46
#define TWLG_ENGLISH              TWLG_ENG
#define TWLG_ENGLISH_AUSTRALIAN   47
#define TWLG_ENGLISH_CANADIAN     48
#define TWLG_ENGLISH_IRELAND      49
#define TWLG_ENGLISH_NEWZEALAND   50
#define TWLG_ENGLISH_SOUTHAFRICA  51
#define TWLG_ENGLISH_UK           52
#define TWLG_ENGLISH_USA          TWLG_USA
#define TWLG_ESTONIAN             53
#define TWLG_FAEROESE             54
#define TWLG_FARSI                55
#define TWLG_FINNISH              TWLG_FIN
#define TWLG_FRENCH               TWLG_FRN
#define TWLG_FRENCH_BELGIAN       56
#define TWLG_FRENCH_CANADIAN      TWLG_FCF
#define TWLG_FRENCH_LUXEMBOURG    57
#define TWLG_FRENCH_SWISS         58
#define TWLG_GERMAN               TWLG_GER
#define TWLG_GERMAN_AUSTRIAN      59
#define TWLG_GERMAN_LUXEMBOURG    60
#define TWLG_GERMAN_LIECHTENSTEIN 61
#define TWLG_GERMAN_SWISS         62
#define TWLG_GREEK                63
#define TWLG_HEBREW               64
#define TWLG_HUNGARIAN            65
#define TWLG_ICELANDIC            TWLG_ICE
#define TWLG_INDONESIAN           66
#define TWLG_ITALIAN              TWLG_ITN
#define TWLG_ITALIAN_SWISS        67
#define TWLG_JAPANESE             68
#define TWLG_KOREAN               69
#define TWLG_KOREAN_JOHAB         70
#define TWLG_LATVIAN              71
#define TWLG_LITHUANIAN           72
#define TWLG_NORWEGIAN            TWLG_NOR
#define TWLG_NORWEGIAN_BOKMAL     73
#define TWLG_NORWEGIAN_NYNORSK    74
#define TWLG_POLISH               75
#define TWLG_PORTUGUESE           TWLG_POR
#define TWLG_PORTUGUESE_BRAZIL    76
#define TWLG_ROMANIAN             77
#define TWLG_RUSSIAN              78
#define TWLG_SERBIAN_LATIN        79
#define TWLG_SLOVAK               80
#define TWLG_SLOVENIAN            81
#define TWLG_SPANISH              TWLG_SPA
#define TWLG_SPANISH_MEXICAN      82
#define TWLG_SPANISH_MODERN       83
#define TWLG_SWEDISH              TWLG_SWE
#define TWLG_THAI                 84
#define TWLG_TURKISH              85
#define TWLG_UKRANIAN             86
/* More stuff added for 1.8 */
#define TWLG_ASSAMESE             87
#define TWLG_BENGALI              88
#define TWLG_BIHARI               89
#define TWLG_BODO                 90
#define TWLG_DOGRI                91
#define TWLG_GUJARATI             92
#define TWLG_HARYANVI             93
#define TWLG_HINDI                94
#define TWLG_KANNADA              95
#define TWLG_KASHMIRI             96
#define TWLG_MALAYALAM            97
#define TWLG_MARATHI              98
#define TWLG_MARWARI              99
#define TWLG_MEGHALAYAN          100
#define TWLG_MIZO                101
#define TWLG_NAGA                102
#define TWLG_ORISSI              103
#define TWLG_PUNJABI             104
#define TWLG_PUSHTU              105
#define TWLG_SERBIAN_CYRILLIC    106
#define TWLG_SIKKIMI             107
#define TWLG_SWEDISH_FINLAND     108
#define TWLG_TAMIL               109
#define TWLG_TELUGU              110
#define TWLG_TRIPURI             111
#define TWLG_URDU                112
#define TWLG_VIETNAMESE          113

/****************************************************************************
 * Data Groups                                                              *
 ****************************************************************************/

/* More Data Groups may be added in the future.
 * Possible candidates include text, vector graphics, sound, etc.
 * NOTE: Data Group constants must be powers of 2 as they are used
 *       as bitflags when Application asks DSM to present a list of DSs.
 */

#define DG_CONTROL          0x0001L /* data pertaining to control       */
#define DG_IMAGE            0x0002L /* data pertaining to raster images */
/* Added 1.8 */
#define DG_AUDIO            0x0004L /* data pertaining to audio */

/****************************************************************************
 * Data Argument Types                                                      *
 ****************************************************************************/

/*  SDH - 03/23/95 - WATCH                                                  */
/*  The thunker requires knowledge about size of data being passed in the   */
/*  lpData parameter to DS_Entry (which is not readily available due to     */
/*  type LPVOID.  Thus, we key off the DAT_ argument to determine the size. */
/*  This has a couple implications:                                         */
/*  1) Any additional DAT_ features require modifications to the thunk code */
/*     for thunker support.                                                 */
/*  2) Any applications which use the custom capabailites are not supported */
/*     under thunking since we have no way of knowing what size data (if    */
/*     any) is being passed.                                                */

#define DAT_NULL            0x0000 /* No data or structure. */
#define DAT_CUSTOMBASE      0x8000 /* Base of custom DATs.  */

/* Data Argument Types for the DG_CONTROL Data Group. */
#define DAT_CAPABILITY      0x0001 /* TW_CAPABILITY                        */
#define DAT_EVENT           0x0002 /* TW_EVENT                             */
#define DAT_IDENTITY        0x0003 /* TW_IDENTITY                          */
#define DAT_PARENT          0x0004 /* TW_HANDLE, application win handle in Windows */
#define DAT_PENDINGXFERS    0x0005 /* TW_PENDINGXFERS                      */
#define DAT_SETUPMEMXFER    0x0006 /* TW_SETUPMEMXFER                      */
#define DAT_SETUPFILEXFER   0x0007 /* TW_SETUPFILEXFER                     */
#define DAT_STATUS          0x0008 /* TW_STATUS                            */
#define DAT_USERINTERFACE   0x0009 /* TW_USERINTERFACE                     */
#define DAT_XFERGROUP       0x000a /* TW_UINT32                            */
/*  SDH - 03/21/95 - TWUNK                                         */
/*  Additional message required for thunker to request the special */
/*  identity information.                                          */
#define DAT_TWUNKIDENTITY   0x000b /* TW_TWUNKIDENTITY                     */
#define DAT_CUSTOMDSDATA    0x000c /* TW_CUSTOMDSDATA.                     */
/* Added 1.8 */
#define DAT_DEVICEEVENT     0x000d /* TW_DEVICEEVENT                       */
#define DAT_FILESYSTEM      0x000e /* TW_FILESYSTEM                        */
#define DAT_PASSTHRU        0x000f /* TW_PASSTHRU                          */
/* Added 2.0 */
#define DAT_CALLBACK 		0x0010

/* Data Argument Types for the DG_IMAGE Data Group. */
#define DAT_IMAGEINFO       0x0101 /* TW_IMAGEINFO                         */
#define DAT_IMAGELAYOUT     0x0102 /* TW_IMAGELAYOUT                       */
#define DAT_IMAGEMEMXFER    0x0103 /* TW_IMAGEMEMXFER                      */
#define DAT_IMAGENATIVEXFER 0x0104 /* TW_UINT32 loword is hDIB, PICHandle  */
#define DAT_IMAGEFILEXFER   0x0105 /* Null data                            */
#define DAT_CIECOLOR        0x0106 /* TW_CIECOLOR                          */
#define DAT_GRAYRESPONSE    0x0107 /* TW_GRAYRESPONSE                      */
#define DAT_RGBRESPONSE     0x0108 /* TW_RGBRESPONSE                       */
#define DAT_JPEGCOMPRESSION 0x0109 /* TW_JPEGCOMPRESSION                   */
#define DAT_PALETTE8        0x010a /* TW_PALETTE8                          */
#define DAT_EXTIMAGEINFO    0x010b /* TW_EXTIMAGEINFO -- for 1.7 Spec.     */

/* Added 1.8 */
/* Data Argument Types for the DG_AUDIO Data Group. */
#define DAT_AUDIOFILEXFER   0x0201 /* Null data                            */
#define DAT_AUDIOINFO       0x0202 /* TW_AUDIOINFO                         */
#define DAT_AUDIONATIVEXFER 0x0203 /* TW_UINT32 handle to WAV, (AIFF Mac)  */

/* Added 1.9 */
#define DAT_SETUPFILEXFER2 	0x0301 /* New file xfer operation              */

/****************************************************************************
 * Messages                                                                 *
 ****************************************************************************/

/* All message constants are unique.
 * Messages are grouped according to which DATs they are used with.*/

#define MSG_NULL         0x0000 /* Used in TW_EVENT structure               */
#define MSG_CUSTOMBASE   0x8000 /* Base of custom messages                  */

/* Generic messages may be used with any of several DATs.                   */
#define MSG_GET          0x0001 /* Get one or more values                   */
#define MSG_GETCURRENT   0x0002 /* Get current value                        */
#define MSG_GETDEFAULT   0x0003 /* Get default (e.g. power up) value        */
#define MSG_GETFIRST     0x0004 /* Get first of a series of items, e.g. DSs */
#define MSG_GETNEXT      0x0005 /* Iterate through a series of items.       */
#define MSG_SET          0x0006 /* Set one or more values                   */
#define MSG_RESET        0x0007 /* Set current value to default value       */
#define MSG_QUERYSUPPORT 0x0008 /* Get supported operations on the cap.     */

/* Messages used with DAT_NULL                                              */
#define MSG_XFERREADY    0x0101 /* The data source has data ready           */
#define MSG_CLOSEDSREQ   0x0102 /* Request for Application. to close DS             */
#define MSG_CLOSEDSOK    0x0103 /* Tell the Application. to save the state.         */
/* Added 1.8 */
#define MSG_DEVICEEVENT  0X0104 /* Some event has taken place               */

/* Messages used with a pointer to a DAT_STATUS structure                   */
#define MSG_CHECKSTATUS  0x0201 /* Get status information                   */

/* Messages used with a pointer to DAT_PARENT data                          */
#define MSG_OPENDSM      0x0301 /* Open the DSM                             */
#define MSG_CLOSEDSM     0x0302 /* Close the DSM                            */

/* Messages used with a pointer to a DAT_IDENTITY structure                 */
#define MSG_OPENDS       0x0401 /* Open a data source                       */
#define MSG_CLOSEDS      0x0402 /* Close a data source                      */
#define MSG_USERSELECT   0x0403 /* Put up a dialog of all DS                */

/* Messages used with a pointer to a DAT_USERINTERFACE structure            */
#define MSG_DISABLEDS    0x0501 /* Disable data transfer in the DS          */
#define MSG_ENABLEDS     0x0502 /* Enable data transfer in the DS           */
#define MSG_ENABLEDSUIONLY  0x0503  /* Enable for saving DS state only.     */

/* Messages used with a pointer to a DAT_EVENT structure                    */
#define MSG_PROCESSEVENT 0x0601

/* Messages used with a pointer to a DAT_PENDINGXFERS structure             */
#define MSG_ENDXFER      0x0701
#define MSG_STOPFEEDER   0x0702

/* Added 1.8 */
/* Messages used with a pointer to a DAT_FILESYSTEM structure               */
#define MSG_CHANGEDIRECTORY   0x0801
#define MSG_CREATEDIRECTORY   0x0802
#define MSG_DELETE            0x0803
#define MSG_FORMATMEDIA       0x0804 
#define MSG_GETCLOSE          0x0805
#define MSG_GETFIRSTFILE      0x0806
#define MSG_GETINFO           0x0807
#define MSG_GETNEXTFILE       0x0808
#define MSG_RENAME            0x0809
#define MSG_COPY              0x080A
#define MSG_AUTOMATICCAPTUREDIRECTORY 0x080B

/* Messages used with a pointer to a DAT_PASSTHRU structure                 */
#define MSG_PASSTHRU          0x0901

/* Added 2.0 */
/* Messages used with DAT_CALLBACK */
#define MSG_REGISTER_CALLBACK	0x0902
#define MSG_INVOKE_CALLBACK		0x0903


/****************************************************************************
 * Capabilities                                                             *
 ****************************************************************************/

#define CAP_CUSTOMBASE          0x8000 /* Base of custom capabilities */

/* all data sources are REQUIRED to support these caps */
#define CAP_XFERCOUNT           0x0001

/* image data sources are REQUIRED to support these caps */
#define ICAP_COMPRESSION        0x0100
#define ICAP_PIXELTYPE          0x0101
#define ICAP_UNITS              0x0102 /* default is TWUN_INCHES */
#define ICAP_XFERMECH           0x0103

/* all data sources MAY support these caps */
#define CAP_AUTHOR                  0x1000
#define CAP_CAPTION                 0x1001
#define CAP_FEEDERENABLED           0x1002
#define CAP_FEEDERLOADED            0x1003
#define CAP_TIMEDATE                0x1004
#define CAP_SUPPORTEDCAPS           0x1005
#define CAP_EXTENDEDCAPS            0x1006
#define CAP_AUTOFEED                0x1007
#define CAP_CLEARPAGE               0x1008
#define CAP_FEEDPAGE                0x1009
#define CAP_REWINDPAGE              0x100a
#define CAP_INDICATORS              0x100b   /* Added 1.1 */
#define CAP_SUPPORTEDCAPSEXT        0x100c   /* Added 1.6 */
#define CAP_PAPERDETECTABLE         0x100d   /* Added 1.6 */
#define CAP_UICONTROLLABLE          0x100e   /* Added 1.6 */
#define CAP_DEVICEONLINE            0x100f   /* Added 1.6 */
#define CAP_AUTOSCAN                0x1010   /* Added 1.6 */
#define CAP_THUMBNAILSENABLED       0x1011   /* Added 1.7 */
#define CAP_DUPLEX                  0x1012   /* Added 1.7 */
#define CAP_DUPLEXENABLED           0x1013   /* Added 1.7 */
#define CAP_ENABLEDSUIONLY          0x1014   /* Added 1.7 */
#define CAP_CUSTOMDSDATA            0x1015   /* Added 1.7 */
#define CAP_ENDORSER                0x1016   /* Added 1.7 */
#define CAP_JOBCONTROL              0x1017   /* Added 1.7 */
#define CAP_ALARMS                  0x1018   /* Added 1.8 */
#define CAP_ALARMVOLUME             0x1019   /* Added 1.8 */
#define CAP_AUTOMATICCAPTURE        0x101a   /* Added 1.8 */
#define CAP_TIMEBEFOREFIRSTCAPTURE  0x101b   /* Added 1.8 */
#define CAP_TIMEBETWEENCAPTURES     0x101c   /* Added 1.8 */
#define CAP_CLEARBUFFERS            0x101d   /* Added 1.8 */
#define CAP_MAXBATCHBUFFERS         0x101e   /* Added 1.8 */
#define CAP_DEVICETIMEDATE          0x101f   /* Added 1.8 */
#define CAP_POWERSUPPLY             0x1020   /* Added 1.8 */
#define CAP_CAMERAPREVIEWUI         0x1021   /* Added 1.8 */
#define CAP_DEVICEEVENT             0x1022   /* Added 1.8 */
#define CAP_SERIALNUMBER            0x1024   /* Added 1.8 */
#define CAP_PRINTER                 0x1026   /* Added 1.8 */
#define CAP_PRINTERENABLED          0x1027   /* Added 1.8 */
#define CAP_PRINTERINDEX            0x1028   /* Added 1.8 */
#define CAP_PRINTERMODE             0x1029   /* Added 1.8 */
#define CAP_PRINTERSTRING           0x102a   /* Added 1.8 */
#define CAP_PRINTERSUFFIX           0x102b   /* Added 1.8 */
#define CAP_LANGUAGE                0x102c   /* Added 1.8 */
#define CAP_FEEDERALIGNMENT         0x102d   /* Added 1.8 */
#define CAP_FEEDERORDER             0x102e   /* Added 1.8 */
#define CAP_REACQUIREALLOWED        0x1030   /* Added 1.8 */
#define CAP_BATTERYMINUTES          0x1032   /* Added 1.8 */
#define CAP_BATTERYPERCENTAGE       0x1033   /* Added 1.8 */
 
/* image data sources MAY support these caps */
#define ICAP_AUTOBRIGHT                   0x1100
#define ICAP_BRIGHTNESS                   0x1101
#define ICAP_CONTRAST                     0x1103
#define ICAP_CUSTHALFTONE                 0x1104
#define ICAP_EXPOSURETIME                 0x1105
#define ICAP_FILTER                       0x1106
#define ICAP_FLASHUSED                    0x1107
#define ICAP_GAMMA                        0x1108
#define ICAP_HALFTONES                    0x1109
#define ICAP_HIGHLIGHT                    0x110a
#define ICAP_IMAGEFILEFORMAT              0x110c
#define ICAP_LAMPSTATE                    0x110d
#define ICAP_LIGHTSOURCE                  0x110e
#define ICAP_ORIENTATION                  0x1110
#define ICAP_PHYSICALWIDTH                0x1111
#define ICAP_PHYSICALHEIGHT               0x1112
#define ICAP_SHADOW                       0x1113
#define ICAP_FRAMES                       0x1114
#define ICAP_XNATIVERESOLUTION            0x1116
#define ICAP_YNATIVERESOLUTION            0x1117
#define ICAP_XRESOLUTION                  0x1118
#define ICAP_YRESOLUTION                  0x1119
#define ICAP_MAXFRAMES                    0x111a
#define ICAP_TILES                        0x111b
#define ICAP_BITORDER                     0x111c
#define ICAP_CCITTKFACTOR                 0x111d
#define ICAP_LIGHTPATH                    0x111e
#define ICAP_PIXELFLAVOR                  0x111f
#define ICAP_PLANARCHUNKY                 0x1120
#define ICAP_ROTATION                     0x1121
#define ICAP_SUPPORTEDSIZES               0x1122
#define ICAP_THRESHOLD                    0x1123
#define ICAP_XSCALING                     0x1124
#define ICAP_YSCALING                     0x1125
#define ICAP_BITORDERCODES                0x1126
#define ICAP_PIXELFLAVORCODES             0x1127
#define ICAP_JPEGPIXELTYPE                0x1128
#define ICAP_TIMEFILL                     0x112a
#define ICAP_BITDEPTH                     0x112b
#define ICAP_BITDEPTHREDUCTION            0x112c  /* Added 1.5 */
#define ICAP_UNDEFINEDIMAGESIZE           0x112d  /* Added 1.6 */
#define ICAP_IMAGEDATASET                 0x112e  /* Added 1.7 */
#define ICAP_EXTIMAGEINFO                 0x112f  /* Added 1.7 */
#define ICAP_MINIMUMHEIGHT                0x1130  /* Added 1.7 */
#define ICAP_MINIMUMWIDTH                 0x1131  /* Added 1.7 */
#define ICAP_FLIPROTATION                 0x1136  /* Added 1.8 */
#define ICAP_BARCODEDETECTIONENABLED      0x1137  /* Added 1.8 */
#define ICAP_SUPPORTEDBARCODETYPES        0x1138  /* Added 1.8 */
#define ICAP_BARCODEMAXSEARCHPRIORITIES   0x1139  /* Added 1.8 */
#define ICAP_BARCODESEARCHPRIORITIES      0x113a  /* Added 1.8 */
#define ICAP_BARCODESEARCHMODE            0x113b  /* Added 1.8 */
#define ICAP_BARCODEMAXRETRIES            0x113c  /* Added 1.8 */
#define ICAP_BARCODETIMEOUT               0x113d  /* Added 1.8 */
#define ICAP_ZOOMFACTOR                   0x113e  /* Added 1.8 */
#define ICAP_PATCHCODEDETECTIONENABLED    0x113f  /* Added 1.8 */
#define ICAP_SUPPORTEDPATCHCODETYPES      0x1140  /* Added 1.8 */
#define ICAP_PATCHCODEMAXSEARCHPRIORITIES 0x1141  /* Added 1.8 */
#define ICAP_PATCHCODESEARCHPRIORITIES    0x1142  /* Added 1.8 */
#define ICAP_PATCHCODESEARCHMODE          0x1143  /* Added 1.8 */
#define ICAP_PATCHCODEMAXRETRIES          0x1144  /* Added 1.8 */
#define ICAP_PATCHCODETIMEOUT             0x1145  /* Added 1.8 */
#define ICAP_FLASHUSED2                   0x1146  /* Added 1.8 */
#define ICAP_IMAGEFILTER                  0x1147  /* Added 1.8 */
#define ICAP_NOISEFILTER                  0x1148  /* Added 1.8 */
#define ICAP_OVERSCAN                     0x1149  /* Added 1.8 */
#define ICAP_AUTOMATICBORDERDETECTION     0x1150  /* Added 1.8 */
#define ICAP_AUTOMATICDESKEW              0x1151  /* Added 1.8 */
#define ICAP_AUTOMATICROTATE              0x1152  /* Added 1.8 */
#define ICAP_JPEGQUALITY                  0x1153  /* Added 1.9 */

/* image data sources MAY support these audio caps */
#define ACAP_AUDIOFILEFORMAT    0x1201  /* Added 1.8 */
#define ACAP_XFERMECH           0x1202  /* Added 1.8 */

/* ----------------------------------------------------------------------- *\

  Version 1.7:      Following is Extended Image Info Attributes.
  July 1997         
  KHL               

\* ----------------------------------------------------------------------- */

#define TWEI_BARCODEX               0x1200
#define TWEI_BARCODEY               0x1201
#define TWEI_BARCODETEXT            0x1202
#define TWEI_BARCODETYPE            0x1203
#define TWEI_DESHADETOP             0x1204
#define TWEI_DESHADELEFT            0x1205
#define TWEI_DESHADEHEIGHT          0x1206
#define TWEI_DESHADEWIDTH           0x1207
#define TWEI_DESHADESIZE            0x1208
#define TWEI_SPECKLESREMOVED        0x1209
#define TWEI_HORZLINEXCOORD         0x120A
#define TWEI_HORZLINEYCOORD         0x120B
#define TWEI_HORZLINELENGTH         0x120C
#define TWEI_HORZLINETHICKNESS      0x120D
#define TWEI_VERTLINEXCOORD         0x120E
#define TWEI_VERTLINEYCOORD         0x120F
#define TWEI_VERTLINELENGTH         0x1210
#define TWEI_VERTLINETHICKNESS      0x1211
#define TWEI_PATCHCODE              0x1212
#define TWEI_ENDORSEDTEXT           0x1213
#define TWEI_FORMCONFIDENCE         0x1214
#define TWEI_FORMTEMPLATEMATCH      0x1215
#define TWEI_FORMTEMPLATEPAGEMATCH  0x1216
#define TWEI_FORMHORZDOCOFFSET      0x1217
#define TWEI_FORMVERTDOCOFFSET      0x1218
#define TWEI_BARCODECOUNT           0x1219
#define TWEI_BARCODECONFIDENCE      0x121A
#define TWEI_BARCODEROTATION        0x121B
#define TWEI_BARCODETEXTLENGTH      0x121C
#define TWEI_DESHADECOUNT           0x121D
#define TWEI_DESHADEBLACKCOUNTOLD   0x121E
#define TWEI_DESHADEBLACKCOUNTNEW   0x121F
#define TWEI_DESHADEBLACKRLMIN      0x1220
#define TWEI_DESHADEBLACKRLMAX      0x1221
#define TWEI_DESHADEWHITECOUNTOLD   0x1222
#define TWEI_DESHADEWHITECOUNTNEW   0x1223
#define TWEI_DESHADEWHITERLMIN      0x1224
#define TWEI_DESHADEWHITERLAVE      0x1225
#define TWEI_DESHADEWHITERLMAX      0x1226
#define TWEI_BLACKSPECKLESREMOVED   0x1227
#define TWEI_WHITESPECKLESREMOVED   0x1228
#define TWEI_HORZLINECOUNT          0x1229
#define TWEI_VERTLINECOUNT          0x122A
#define TWEI_DESKEWSTATUS           0x122B
#define TWEI_SKEWORIGINALANGLE      0x122C
#define TWEI_SKEWFINALANGLE         0x122D
#define TWEI_SKEWCONFIDENCE         0x122E
#define TWEI_SKEWWINDOWX1           0x122F
#define TWEI_SKEWWINDOWY1           0x1230
#define TWEI_SKEWWINDOWX2           0x1231
#define TWEI_SKEWWINDOWY2           0x1232
#define TWEI_SKEWWINDOWX3           0x1233
#define TWEI_SKEWWINDOWY3           0x1234
#define TWEI_SKEWWINDOWX4           0x1235
#define TWEI_SKEWWINDOWY4           0x1236
#define TWEI_BOOKNAME               0x1238  /* added 1.9 */
#define TWEI_CHAPTERNUMBER          0x1239  /* added 1.9 */
#define TWEI_DOCUMENTNUMBER         0x123A  /* added 1.9 */
#define TWEI_PAGENUMBER             0x123B  /* added 1.9 */
#define TWEI_CAMERA           	    0x123C  /* added 1.9 */
#define TWEI_FRAMENUMBER            0x123D  /* added 1.9 */
#define TWEI_FRAME	            0x123E  /* added 1.9 */
#define TWEI_PIXELFLAVOR            0x123F  /* added 1.9 */

#define TWEJ_NONE                   0x0000
#define TWEJ_MIDSEPARATOR           0x0001
#define TWEJ_PATCH1                 0x0002
#define TWEJ_PATCH2                 0x0003
#define TWEJ_PATCH3                 0x0004
#define TWEJ_PATCH4                 0x0005
#define TWEJ_PATCH6                 0x0006
#define TWEJ_PATCHT                 0x0007

/* Added 1.8 */
/* TW_PASSTHRU.Direction values */
#define TWDR_GET                1
#define TWDR_SET                2   

/***************************************************************************
 *            Return Codes and Condition Codes section                     *
 ***************************************************************************/

/* Return Codes: DSM_Entry and DS_Entry may return any one of these values. */
#define TWRC_CUSTOMBASE     0x8000

#define TWRC_SUCCESS          0
#define TWRC_FAILURE          1 /* Application may get TW_STATUS for info on failure */
#define TWRC_CHECKSTATUS      2 /* "tried hard"; get status                  */
#define TWRC_CANCEL           3
#define TWRC_DSEVENT          4
#define TWRC_NOTDSEVENT       5
#define TWRC_XFERDONE         6
#define TWRC_ENDOFLIST        7 /* After MSG_GETNEXT if nothing left         */
#define TWRC_INFONOTSUPPORTED 8
#define TWRC_DATANOTAVAILABLE 9

/* Condition Codes: Application gets these by doing DG_CONTROL DAT_STATUS MSG_GET.  */
#define TWCC_CUSTOMBASE         0x8000

#define TWCC_SUCCESS            0 /* It worked!                                */
#define TWCC_BUMMER             1 /* Failure due to unknown causes             */
#define TWCC_LOWMEMORY          2 /* Not enough memory to perform operation    */
#define TWCC_NODS               3 /* No Data Source                            */
#define TWCC_MAXCONNECTIONS     4 /* DS is connected to max possible applications      */
#define TWCC_OPERATIONERROR     5 /* DS or DSM reported error, application shouldn't   */
#define TWCC_BADCAP             6 /* Unknown capability                        */
#define TWCC_BADPROTOCOL        9 /* Unrecognized MSG DG DAT combination       */
#define TWCC_BADVALUE           10 /* Data parameter out of range              */
#define TWCC_SEQERROR           11 /* DG DAT MSG out of expected sequence      */
#define TWCC_BADDEST            12 /* Unknown destination Application/Source in DSM_Entry */
#define TWCC_CAPUNSUPPORTED     13 /* Capability not supported by source            */
#define TWCC_CAPBADOPERATION    14 /* Operation not supported by capability         */
#define TWCC_CAPSEQERROR        15 /* Capability has dependancy on other capability */
/* Added 1.8 */
#define TWCC_DENIED             16 /* File System operation is denied (file is protected) */
#define TWCC_FILEEXISTS         17 /* Operation failed because file already exists. */
#define TWCC_FILENOTFOUND       18 /* File not found */
#define TWCC_NOTEMPTY           19 /* Operation failed because directory is not empty */
#define TWCC_PAPERJAM           20  /* The feeder is jammed */
#define TWCC_PAPERDOUBLEFEED    21  /* The feeder detected multiple pages */
#define TWCC_FILEWRITEERROR     22  /* Error writing the file (meant for things like disk full conditions) */
#define TWCC_CHECKDEVICEONLINE  23  /* The device went offline prior to or during this operation */


/* bit patterns: for query the operation that are supported by the data source on a capability */
/* Application gets these through DG_CONTROL/DAT_CAPABILITY/MSG_QUERYSUPPORT */
/* Added 1.6 */
#define TWQC_GET           0x0001 
#define TWQC_SET           0x0002
#define TWQC_GETDEFAULT    0x0004
#define TWQC_GETCURRENT    0x0008
#define TWQC_RESET         0x0010


/****************************************************************************
 * Entry Points                                                             *
 ****************************************************************************/

/**********************************************************************
 * Function: DSM_Entry, the only entry point into the Data Source Manager.
 *
 * Parameters:
 *  pOrigin Identifies the source module of the message. This could
 *          identify an Application, a Source, or the Source Manager.
 *
 *  pDest   Identifies the destination module for the message.
 *          This could identify an application or a data source.
 *          If this is NULL, the message goes to the Source Manager.
 *
 *  DG      The Data Group. 
 *          Example: DG_IMAGE.
 *
 *  DAT     The Data Attribute Type.
 *          Example: DAT_IMAGEMEMXFER.
 *    
 *  MSG     The message.  Messages are interpreted by the destination module
 *          with respect to the Data Group and the Data Attribute Type.  
 *          Example: MSG_GET.
 *
 *  pData   A pointer to the data structure or variable identified 
 *          by the Data Attribute Type.
 *          Example: (TW_MEMREF)&ImageMemXfer
 *                   where ImageMemXfer is a TW_IMAGEMEMXFER structure.
 *                    
 * Returns:
 *  ReturnCode
 *         Example: TWRC_SUCCESS.
 *
 ********************************************************************/

/* Don't mangle the name "DSM_Entry" if we're compiling in C++! */
#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef  _MSWIN_
TW_UINT16 FAR PASCAL DSM_Entry( pTW_IDENTITY pOrigin,
                                pTW_IDENTITY pDest,
                                TW_UINT32    DG,
                                TW_UINT16    DAT,
                                TW_UINT16    MSG,
                                TW_MEMREF    pData);

typedef TW_UINT16 (FAR PASCAL *DSMENTRYPROC)(pTW_IDENTITY, pTW_IDENTITY,
                                             TW_UINT32,    TW_UINT16,
                                             TW_UINT16,    TW_MEMREF);
#elif defined _MAC_
TW_UINT16 DSM_Entry ( pTW_IDENTITY pOrigin,
                      pTW_IDENTITY pDest,
                      TW_UINT32    DG,
                      TW_UINT16    DAT,
                      TW_UINT16    MSG,
                      TW_MEMREF    pData );

typedef TW_UINT16 (*DSMENTRYPROC) ( pTW_IDENTITY	pOrigin, 
									pTW_IDENTITY	pDest,
                                  	TW_UINT32		DG,    
                                  	TW_UINT16		DAT,
                                  	TW_UINT16		MSG,    
                                  	TW_MEMREF		pData );

#else   /* _MSWIN_ */

FAR PASCAL TW_UINT16 DSM_Entry( pTW_IDENTITY pOrigin,
                                pTW_IDENTITY pDest,
                                TW_UINT32    DG,
                                TW_UINT16    DAT,
                                TW_UINT16    MSG,
                                TW_MEMREF    pData);

typedef TW_UINT16 (*DSMENTRYPROC)(pTW_IDENTITY, pTW_IDENTITY,
                                  TW_UINT32,    TW_UINT16,
                                  TW_UINT16,    TW_MEMREF);
#endif  /* _MSWIN_ */

#ifdef  __cplusplus
}
#endif  /* cplusplus */


/**********************************************************************
 * Function: DS_Entry, the entry point provided by a Data Source.
 *
 * Parameters:
 *  pOrigin Identifies the source module of the message. This could
 *          identify an application or the Data Source Manager.
 *
 *  DG      The Data Group. 
 *          Example: DG_IMAGE.
 *           
 *  DAT     The Data Attribute Type.
 *          Example: DAT_IMAGEMEMXFER.
 *    
 *  MSG     The message.  Messages are interpreted by the data source
 *          with respect to the Data Group and the Data Attribute Type.
 *          Example: MSG_GET.
 *
 *  pData   A pointer to the data structure or variable identified 
 *          by the Data Attribute Type.
 *          Example: (TW_MEMREF)&ImageMemXfer
 *                   where ImageMemXfer is a TW_IMAGEMEMXFER structure.
 *                    
 * Returns:
 *  ReturnCode
 *          Example: TWRC_SUCCESS.
 *
 * Note:
 *  The DSPROC type is only used by an application when it calls
 *  a Data Source directly, bypassing the Data Source Manager.
 *
 ********************************************************************/
/* Don't mangle the name "DS_Entry" if we're compiling in C++! */
#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef  _MSWIN_
  #ifdef _WIN32
     __declspec(dllexport) TW_UINT16 FAR PASCAL DS_Entry (pTW_IDENTITY pOrigin,
                                                          TW_UINT32    DG, 
                                                          TW_UINT16    DAT, 
                                                          TW_UINT16    MSG, 
                                                          TW_MEMREF    pData);
  #else   /* _WIN32 */
     TW_UINT16 FAR PASCAL DS_Entry (pTW_IDENTITY pOrigin,
                                    TW_UINT32    DG, 
                                    TW_UINT16    DAT, 
                                    TW_UINT16    MSG, 
                                    TW_MEMREF    pData);
  #endif  /* _WIN32 */
  
  typedef TW_UINT16 (FAR PASCAL *DSENTRYPROC) (pTW_IDENTITY pOrigin,
                                               TW_UINT32    DG, 
                                               TW_UINT16    DAT, 
                                               TW_UINT16    MSG, 
                                               TW_MEMREF    pData);
#elif defined _MAC_
TW_UINT16 DS_Entry ( pTW_IDENTITY pOrigin, 
                     TW_UINT32    DG, 
                     TW_UINT16    DAT, 
                     TW_UINT16    MSG, 
                     TW_MEMREF    pData );

typedef TW_UINT16 (*DSENTRYPROC) ( pTW_IDENTITY	pOrigin,
                                   TW_UINT32	DG,    
                                   TW_UINT16	DAT,
                                   TW_UINT16	MSG,    
                                   TW_MEMREF	pData );
#else  
FAR PASCAL TW_UINT16 DS_Entry( pTW_IDENTITY pOrigin, 
                               TW_UINT32    DG, 
                               TW_UINT16    DAT, 
                               TW_UINT16    MSG, 
                               TW_MEMREF    pData);

typedef TW_UINT16 (*DSENTRYPROC)(pTW_IDENTITY,
                                  TW_UINT32,    TW_UINT16,
                                  TW_UINT16,    TW_MEMREF);
#endif  /* _MSWIN_ */

#ifdef  __cplusplus
}
#endif  /* cplusplus */

/*  SDH - 02/08/95 - TWUNK */
/*  Force 32-bit twain to use same packing of twain structures as existing */
/*  16-bit twain.  This allows 16/32-bit thunking. */
#ifdef  WIN32
    #ifdef __BORLANDC__ //(Mentor June 13, 1996) if we're using a Borland compiler
        #pragma option -a.  //(Mentor October 30, 1996) switch back to original alignment
    #else   //(Mentor June 13, 1996) if NOT using a Borland compiler
        #pragma pack (pop, before_twain)
    #endif  //(Mentor June 13, 1996)
#else   /* WIN32 */
#endif  /* WIN32 */

#ifdef _MAC_
#pragma options align = reset
#endif
#endif  /* TWAIN */
                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/A/Modules/   0040755 0001750 0001750 00000000000 12612224746 030623  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        module.modulemap                                                                                    0100644 0001750 0001750 00000000145 12566223067 033736  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/A/Modules                                                                       framework module TWAIN [extern_c] {
  umbrella header "TWAIN.h"
  export *
  module * { export * }
}
                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/A/TWAIN.tbd  0100644 0001750 0001750 00000000353 12571375071 030570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/TWAIN.framework/Versions/A/TWAIN
exports:         
  - archs:           [ i386, x86_64 ]
    symbols:         [ _DSM_Entry ]
...
                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/TWAIN.framework/Versions/Current      0120777 0001750 0001750 00000000000 12620245063 030471  2A                                                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/                        0040755 0001750 0001750 00000000000 12612224747 025064  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Headers                 0120777 0001750 0001750 00000000000 12620245063 033077  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Tcl.tbd                 0120777 0001750 0001750 00000000000 12620245063 032735  2Versions/Current/Tcl.tbd                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/               0040755 0001750 0001750 00000000000 12612224746 026673  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/           0040755 0001750 0001750 00000000000 12612224746 027204  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/   0040755 0001750 0001750 00000000000 12612224746 030557  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        tcl-private/                                                                                        0040755 0001750 0001750 00000000000 12612224746 032732  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers                                                                       tclCompile.h                                                                                        0100644 0001750 0001750 00000141615 12566232275 035207  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclCompile.h --
 *
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-2000 by Scriptics Corporation.
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
 * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclCompile.h,v 1.33.2.2 2007/09/13 15:28:11 das Exp $
 */

#ifndef _TCLCOMPILATION
#define _TCLCOMPILATION 1

#ifndef _TCLINT
#include "tclInt.h"
#endif /* _TCLINT */

#ifdef BUILD_tcl
# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 *------------------------------------------------------------------------
 * Variables related to compilation. These are used in tclCompile.c,
 * tclExecute.c, tclBasic.c, and their clients.
 *------------------------------------------------------------------------
 */

#ifdef TCL_COMPILE_DEBUG
/*
 * Variable that controls whether compilation tracing is enabled and, if so,
 * what level of tracing is desired:
 *    0: no compilation tracing
 *    1: summarize compilation of top level cmds and proc bodies
 *    2: display all instructions of each ByteCode compiled
 * This variable is linked to the Tcl variable "tcl_traceCompile".
 */

extern int 		tclTraceCompile;
#endif

#ifdef TCL_COMPILE_DEBUG
/*
 * Variable that controls whether execution tracing is enabled and, if so,
 * what level of tracing is desired:
 *    0: no execution tracing
 *    1: trace invocations of Tcl procs only
 *    2: trace invocations of all (not compiled away) commands
 *    3: display each instruction executed
 * This variable is linked to the Tcl variable "tcl_traceExec".
 */

extern int 		tclTraceExec;
#endif

/*
 *------------------------------------------------------------------------
 * Data structures related to compilation.
 *------------------------------------------------------------------------
 */

/*
 * The structure used to implement Tcl "exceptions" (exceptional returns):
 * for example, those generated in loops by the break and continue commands,
 * and those generated by scripts and caught by the catch command. This
 * ExceptionRange structure describes a range of code (e.g., a loop body),
 * the kind of exceptions (e.g., a break or continue) that might occur, and
 * the PC offsets to jump to if a matching exception does occur. Exception
 * ranges can nest so this structure includes a nesting level that is used
 * at runtime to find the closest exception range surrounding a PC. For
 * example, when a break command is executed, the ExceptionRange structure
 * for the most deeply nested loop, if any, is found and used. These
 * structures are also generated for the "next" subcommands of for loops
 * since a break there terminates the for command. This means a for command
 * actually generates two LoopInfo structures.
 */

typedef enum {
    LOOP_EXCEPTION_RANGE,	/* Exception's range is part of a loop.
				 * Break and continue "exceptions" cause
				 * jumps to appropriate PC offsets. */
    CATCH_EXCEPTION_RANGE	/* Exception's range is controlled by a
				 * catch command. Errors in the range cause
				 * a jump to a catch PC offset. */
} ExceptionRangeType;

typedef struct ExceptionRange {
    ExceptionRangeType type;	/* The kind of ExceptionRange. */
    int nestingLevel;		/* Static depth of the exception range.
				 * Used to find the most deeply-nested
				 * range surrounding a PC at runtime. */
    int codeOffset;		/* Offset of the first instruction byte of
				 * the code range. */
    int numCodeBytes;		/* Number of bytes in the code range. */
    int breakOffset;		/* If LOOP_EXCEPTION_RANGE, the target PC
				 * offset for a break command in the range. */
    int continueOffset;		/* If LOOP_EXCEPTION_RANGE and not -1, the
				 * target PC offset for a continue command in
				 * the code range. Otherwise, ignore this range
				 * when processing a continue command. */
    int catchOffset;		/* If a CATCH_EXCEPTION_RANGE, the target PC
				 * offset for any "exception" in range. */
} ExceptionRange;

/*
 * Structure used to map between instruction pc and source locations. It
 * defines for each compiled Tcl command its code's starting offset and 
 * its source's starting offset and length. Note that the code offset
 * increases monotonically: that is, the table is sorted in code offset
 * order. The source offset is not monotonic.
 */

typedef struct CmdLocation {
    int codeOffset;		/* Offset of first byte of command code. */
    int numCodeBytes;		/* Number of bytes for command's code. */
    int srcOffset;		/* Offset of first char of the command. */
    int numSrcBytes;		/* Number of command source chars. */
} CmdLocation;

#ifdef TCL_TIP280
/*
 * TIP #280
 * Structure to record additional location information for byte code.
 * This information is internal and not saved. I.e. tbcload'ed code
 * will not have this information. It records the lines for all words
 * of all commands found in the byte code. The association with a
 * ByteCode structure BC is done through the 'lineBCPtr' HashTable in
 * Interp, keyed by the address of BC. Also recorded is information
 * coming from the context, i.e. type of the frame and associated
 * information, like the path of a sourced file.
 */

typedef struct ECL {
  int  srcOffset; /* cmd location to find the entry */
  int  nline;     /* Number of words in the command */
  int* line;      /* line information for all words in the command */
  int** next;     /* Transient information during compile, ICL tracking */
} ECL;

typedef struct ExtCmdLoc {
  int      type;  /* Context type */
  Tcl_Obj* path;  /* Path of the sourced file the command is in */
  ECL*     loc;   /* Command word locations (lines) */
  int      nloc;  /* Number of allocated entries in 'loc' */
  int      nuloc; /* Number of used entries in 'loc' */
  Tcl_HashTable litInfo; /* Indexed by bytecode 'PC', to have the
			  * information accessible per command and
			  * argument, not per whole bytecode. Value is
			  * index of command in 'loc', giving us the
			  * literals to associate with line
			  * information as command argument, see
			  * TclArgumentBCEnter() */
} ExtCmdLoc;
#endif

/*
 * CompileProcs need the ability to record information during compilation
 * that can be used by bytecode instructions during execution. The AuxData
 * structure provides this "auxiliary data" mechanism. An arbitrary number
 * of these structures can be stored in the ByteCode record (during
 * compilation they are stored in a CompileEnv structure). Each AuxData
 * record holds one word of client-specified data (often a pointer) and is
 * given an index that instructions can later use to look up the structure
 * and its data.
 *
 * The following definitions declare the types of procedures that are called
 * to duplicate or free this auxiliary data when the containing ByteCode
 * objects are duplicated and freed. Pointers to these procedures are kept
 * in the AuxData structure.
 */

typedef ClientData (AuxDataDupProc)  _ANSI_ARGS_((ClientData clientData));
typedef void       (AuxDataFreeProc) _ANSI_ARGS_((ClientData clientData));

/*
 * We define a separate AuxDataType struct to hold type-related information
 * for the AuxData structure. This separation makes it possible for clients
 * outside of the TCL core to manipulate (in a limited fashion!) AuxData;
 * for example, it makes it possible to pickle and unpickle AuxData structs.
 */

typedef struct AuxDataType {
    char *name;					/* the name of the type. Types can be
                                 * registered and found by name */
    AuxDataDupProc *dupProc;	/* Callback procedure to invoke when the
                                 * aux data is duplicated (e.g., when the
                                 * ByteCode structure containing the aux
                                 * data is duplicated). NULL means just
                                 * copy the source clientData bits; no
                                 * proc need be called. */
    AuxDataFreeProc *freeProc;	/* Callback procedure to invoke when the
                                 * aux data is freed. NULL means no
                                 * proc need be called. */
} AuxDataType;

/*
 * The definition of the AuxData structure that holds information created
 * during compilation by CompileProcs and used by instructions during
 * execution.
 */

typedef struct AuxData {
    AuxDataType *type;		/* pointer to the AuxData type associated with
                             * this ClientData. */
    ClientData clientData;	/* The compilation data itself. */
} AuxData;

/*
 * Structure defining the compilation environment. After compilation, fields
 * describing bytecode instructions are copied out into the more compact
 * ByteCode structure defined below.
 */

#define COMPILEENV_INIT_CODE_BYTES    250
#define COMPILEENV_INIT_NUM_OBJECTS    60
#define COMPILEENV_INIT_EXCEPT_RANGES   5
#define COMPILEENV_INIT_CMD_MAP_SIZE   40
#define COMPILEENV_INIT_AUX_DATA_SIZE   5

typedef struct CompileEnv {
    Interp *iPtr;		/* Interpreter containing the code being
				 * compiled. Commands and their compile
				 * procs are specific to an interpreter so
				 * the code emitted will depend on the
				 * interpreter. */
    char *source;		/* The source string being compiled by
				 * SetByteCodeFromAny. This pointer is not
				 * owned by the CompileEnv and must not be
				 * freed or changed by it. */
    int numSrcBytes;		/* Number of bytes in source. */
    Proc *procPtr;		/* If a procedure is being compiled, a
				 * pointer to its Proc structure; otherwise
				 * NULL. Used to compile local variables.
				 * Set from information provided by
				 * ObjInterpProc in tclProc.c. */
    int numCommands;		/* Number of commands compiled. */
    int exceptDepth;		/* Current exception range nesting level;
				 * -1 if not in any range currently. */
    int maxExceptDepth;		/* Max nesting level of exception ranges;
				 * -1 if no ranges have been compiled. */
    int maxStackDepth;		/* Maximum number of stack elements needed
				 * to execute the code. Set by compilation
				 * procedures before returning. */
    int currStackDepth;         /* Current stack depth. */
    LiteralTable localLitTable;	/* Contains LiteralEntry's describing
				 * all Tcl objects referenced by this
				 * compiled code. Indexed by the string
				 * representations of the literals. Used to
				 * avoid creating duplicate objects. */
    unsigned char *codeStart;	/* Points to the first byte of the code. */
    unsigned char *codeNext;	/* Points to next code array byte to use. */
    unsigned char *codeEnd;	/* Points just after the last allocated
				 * code array byte. */
    int mallocedCodeArray;      /* Set 1 if code array was expanded 
				 * and codeStart points into the heap.*/
    LiteralEntry *literalArrayPtr;
    				/* Points to start of LiteralEntry array. */
    int literalArrayNext;	/* Index of next free object array entry. */
    int literalArrayEnd;	/* Index just after last obj array entry. */
    int mallocedLiteralArray;   /* 1 if object array was expanded and
                                 * objArray points into the heap, else 0. */
    ExceptionRange *exceptArrayPtr;
    				/* Points to start of the ExceptionRange
				 * array. */
    int exceptArrayNext;	/* Next free ExceptionRange array index.
				 * exceptArrayNext is the number of ranges
				 * and (exceptArrayNext-1) is the index of
				 * the current range's array entry. */
    int exceptArrayEnd;		/* Index after the last ExceptionRange
				 * array entry. */
    int mallocedExceptArray;	/* 1 if ExceptionRange array was expanded
				 * and exceptArrayPtr points in heap,
				 * else 0. */
    CmdLocation *cmdMapPtr;	/* Points to start of CmdLocation array.
				 * numCommands is the index of the next
				 * entry to use; (numCommands-1) is the
				 * entry index for the last command. */
    int cmdMapEnd;		/* Index after last CmdLocation entry. */
    int mallocedCmdMap;		/* 1 if command map array was expanded and
				 * cmdMapPtr points in the heap, else 0. */
    AuxData *auxDataArrayPtr;   /* Points to auxiliary data array start. */
    int auxDataArrayNext;	/* Next free compile aux data array index.
				 * auxDataArrayNext is the number of aux
				 * data items and (auxDataArrayNext-1) is
				 * index of current aux data array entry. */
    int auxDataArrayEnd;	/* Index after last aux data array entry. */
    int mallocedAuxDataArray;	/* 1 if aux data array was expanded and
				 * auxDataArrayPtr points in heap else 0. */
    unsigned char staticCodeSpace[COMPILEENV_INIT_CODE_BYTES];
                                /* Initial storage for code. */
    LiteralEntry staticLiteralSpace[COMPILEENV_INIT_NUM_OBJECTS];
                                /* Initial storage of LiteralEntry array. */
    ExceptionRange staticExceptArraySpace[COMPILEENV_INIT_EXCEPT_RANGES];
                                /* Initial ExceptionRange array storage. */
    CmdLocation staticCmdMapSpace[COMPILEENV_INIT_CMD_MAP_SIZE];
                                /* Initial storage for cmd location map. */
    AuxData staticAuxDataArraySpace[COMPILEENV_INIT_AUX_DATA_SIZE];
                                /* Initial storage for aux data array. */
#ifdef TCL_TIP280
    /* TIP #280 */
    ExtCmdLoc* extCmdMapPtr;    /* Extended command location information
				 * for 'info frame'. */
    int        line;            /* First line of the script, based on the
				 * invoking context, then the line of the
				 * command currently compiled. */
    ContLineLoc* clLoc;  /* If not NULL, the table holding the
			  * locations of the invisible continuation
			  * lines in the input script, to adjust the
			  * line counter. */
    int*         clNext; /* If not NULL, it refers to the next slot in
			  * clLoc to check for an invisible
			  * continuation line. */
#endif
} CompileEnv;

/*
 * The structure defining the bytecode instructions resulting from compiling
 * a Tcl script. Note that this structure is variable length: a single heap
 * object is allocated to hold the ByteCode structure immediately followed
 * by the code bytes, the literal object array, the ExceptionRange array,
 * the CmdLocation map, and the compilation AuxData array.
 */

/*
 * A PRECOMPILED bytecode struct is one that was generated from a compiled
 * image rather than implicitly compiled from source
 */
#define TCL_BYTECODE_PRECOMPILED		0x0001

typedef struct ByteCode {
    TclHandle interpHandle;	/* Handle for interpreter containing the
				 * compiled code.  Commands and their compile
				 * procs are specific to an interpreter so the
				 * code emitted will depend on the
				 * interpreter. */
    int compileEpoch;		/* Value of iPtr->compileEpoch when this
				 * ByteCode was compiled. Used to invalidate
				 * code when, e.g., commands with compile
				 * procs are redefined. */
    Namespace *nsPtr;		/* Namespace context in which this code
				 * was compiled. If the code is executed
				 * if a different namespace, it must be
				 * recompiled. */
    int nsEpoch;		/* Value of nsPtr->resolverEpoch when this
				 * ByteCode was compiled. Used to invalidate
				 * code when new namespace resolution rules
				 * are put into effect. */
    int refCount;		/* Reference count: set 1 when created
				 * plus 1 for each execution of the code
				 * currently active. This structure can be
				 * freed when refCount becomes zero. */
    unsigned int flags;		/* flags describing state for the codebyte.
                                 * this variable holds ORed values from the
                                 * TCL_BYTECODE_ masks defined above */
    char *source;		/* The source string from which this
				 * ByteCode was compiled. Note that this
				 * pointer is not owned by the ByteCode and
				 * must not be freed or modified by it. */
    Proc *procPtr;		/* If the ByteCode was compiled from a
				 * procedure body, this is a pointer to its
				 * Proc structure; otherwise NULL. This
				 * pointer is also not owned by the ByteCode
				 * and must not be freed by it. */
    size_t structureSize;	/* Number of bytes in the ByteCode structure
				 * itself. Does not include heap space for
				 * literal Tcl objects or storage referenced
				 * by AuxData entries. */
    int numCommands;		/* Number of commands compiled. */
    int numSrcBytes;		/* Number of source bytes compiled. */
    int numCodeBytes;		/* Number of code bytes. */
    int numLitObjects;		/* Number of objects in literal array. */
    int numExceptRanges;	/* Number of ExceptionRange array elems. */
    int numAuxDataItems;	/* Number of AuxData items. */
    int numCmdLocBytes;		/* Number of bytes needed for encoded
				 * command location information. */
    int maxExceptDepth;		/* Maximum nesting level of ExceptionRanges;
				 * -1 if no ranges were compiled. */
    int maxStackDepth;		/* Maximum number of stack elements needed
				 * to execute the code. */
    unsigned char *codeStart;	/* Points to the first byte of the code.
				 * This is just after the final ByteCode
				 * member cmdMapPtr. */
    Tcl_Obj **objArrayPtr;	/* Points to the start of the literal
				 * object array. This is just after the
				 * last code byte. */
    ExceptionRange *exceptArrayPtr;
    				/* Points to the start of the ExceptionRange
				 * array. This is just after the last
				 * object in the object array. */
    AuxData *auxDataArrayPtr;   /* Points to the start of the auxiliary data
				 * array. This is just after the last entry
				 * in the ExceptionRange array. */
    unsigned char *codeDeltaStart;
				/* Points to the first of a sequence of
				 * bytes that encode the change in the
				 * starting offset of each command's code.
				 * If -127<=delta<=127, it is encoded as 1
				 * byte, otherwise 0xFF (128) appears and
				 * the delta is encoded by the next 4 bytes.
				 * Code deltas are always positive. This
				 * sequence is just after the last entry in
				 * the AuxData array. */
    unsigned char *codeLengthStart;
				/* Points to the first of a sequence of
				 * bytes that encode the length of each
				 * command's code. The encoding is the same
				 * as for code deltas. Code lengths are
				 * always positive. This sequence is just
				 * after the last entry in the code delta
				 * sequence. */
    unsigned char *srcDeltaStart;
				/* Points to the first of a sequence of
				 * bytes that encode the change in the
				 * starting offset of each command's source.
				 * The encoding is the same as for code
				 * deltas. Source deltas can be negative.
				 * This sequence is just after the last byte
				 * in the code length sequence. */
    unsigned char *srcLengthStart;
				/* Points to the first of a sequence of
				 * bytes that encode the length of each
				 * command's source. The encoding is the
				 * same as for code deltas. Source lengths
				 * are always positive. This sequence is
				 * just after the last byte in the source
				 * delta sequence. */
#ifdef TCL_COMPILE_STATS
    Tcl_Time createTime;	/* Absolute time when the ByteCode was
				 * created. */
#endif /* TCL_COMPILE_STATS */
} ByteCode;

/*
 * Opcodes for the Tcl bytecode instructions. These must correspond to
 * the entries in the table of instruction descriptions,
 * tclInstructionTable, in tclCompile.c. Also, the order and number of
 * the expression opcodes (e.g., INST_LOR) must match the entries in
 * the array operatorStrings in tclExecute.c.
 */

/* Opcodes 0 to 9 */
#define INST_DONE			0
#define INST_PUSH1			1
#define INST_PUSH4			2
#define INST_POP			3
#define INST_DUP			4
#define INST_CONCAT1			5
#define INST_INVOKE_STK1		6
#define INST_INVOKE_STK4		7
#define INST_EVAL_STK			8
#define INST_EXPR_STK			9

/* Opcodes 10 to 23 */
#define INST_LOAD_SCALAR1		10
#define INST_LOAD_SCALAR4		11
#define INST_LOAD_SCALAR_STK		12
#define INST_LOAD_ARRAY1		13
#define INST_LOAD_ARRAY4		14
#define INST_LOAD_ARRAY_STK		15
#define INST_LOAD_STK			16
#define INST_STORE_SCALAR1		17
#define INST_STORE_SCALAR4		18
#define INST_STORE_SCALAR_STK		19
#define INST_STORE_ARRAY1		20
#define INST_STORE_ARRAY4		21
#define INST_STORE_ARRAY_STK		22
#define INST_STORE_STK			23

/* Opcodes 24 to 33 */
#define INST_INCR_SCALAR1		24
#define INST_INCR_SCALAR_STK		25
#define INST_INCR_ARRAY1		26
#define INST_INCR_ARRAY_STK		27
#define INST_INCR_STK			28
#define INST_INCR_SCALAR1_IMM		29
#define INST_INCR_SCALAR_STK_IMM	30
#define INST_INCR_ARRAY1_IMM		31
#define INST_INCR_ARRAY_STK_IMM		32
#define INST_INCR_STK_IMM		33

/* Opcodes 34 to 39 */
#define INST_JUMP1			34
#define INST_JUMP4			35
#define INST_JUMP_TRUE1			36
#define INST_JUMP_TRUE4			37
#define INST_JUMP_FALSE1		38
#define INST_JUMP_FALSE4	        39

/* Opcodes 40 to 64 */
#define INST_LOR			40
#define INST_LAND			41
#define INST_BITOR			42
#define INST_BITXOR			43
#define INST_BITAND			44
#define INST_EQ				45
#define INST_NEQ			46
#define INST_LT				47
#define INST_GT				48
#define INST_LE				49
#define INST_GE				50
#define INST_LSHIFT			51
#define INST_RSHIFT			52
#define INST_ADD			53
#define INST_SUB			54
#define INST_MULT			55
#define INST_DIV			56
#define INST_MOD			57
#define INST_UPLUS			58
#define INST_UMINUS			59
#define INST_BITNOT			60
#define INST_LNOT			61
#define INST_CALL_BUILTIN_FUNC1		62
#define INST_CALL_FUNC1			63
#define INST_TRY_CVT_TO_NUMERIC		64

/* Opcodes 65 to 66 */
#define INST_BREAK			65
#define INST_CONTINUE			66

/* Opcodes 67 to 68 */
#define INST_FOREACH_START4		67
#define INST_FOREACH_STEP4		68

/* Opcodes 69 to 72 */
#define INST_BEGIN_CATCH4		69
#define INST_END_CATCH			70
#define INST_PUSH_RESULT		71
#define INST_PUSH_RETURN_CODE		72

/* Opcodes 73 to 78 */
#define INST_STR_EQ			73
#define INST_STR_NEQ			74
#define INST_STR_CMP			75
#define INST_STR_LEN			76
#define INST_STR_INDEX			77
#define INST_STR_MATCH			78

/* Opcodes 78 to 81 */
#define INST_LIST			79
#define INST_LIST_INDEX			80
#define INST_LIST_LENGTH		81

/* Opcodes 82 to 87 */
#define INST_APPEND_SCALAR1		82
#define INST_APPEND_SCALAR4		83
#define INST_APPEND_ARRAY1		84
#define INST_APPEND_ARRAY4		85
#define INST_APPEND_ARRAY_STK		86
#define INST_APPEND_STK			87

/* Opcodes 88 to 93 */
#define INST_LAPPEND_SCALAR1		88
#define INST_LAPPEND_SCALAR4		89
#define INST_LAPPEND_ARRAY1		90
#define INST_LAPPEND_ARRAY4		91
#define INST_LAPPEND_ARRAY_STK		92
#define INST_LAPPEND_STK		93

/* TIP #22 - LINDEX operator with flat arg list */

#define INST_LIST_INDEX_MULTI		94

/*
 * TIP #33 - 'lset' command.  Code gen also required a Forth-like
 *           OVER operation.
 */

#define INST_OVER                       95
#define INST_LSET_LIST			96
#define INST_LSET_FLAT                  97

/* The last opcode */
#define LAST_INST_OPCODE        	97

/*
 * Table describing the Tcl bytecode instructions: their name (for
 * displaying code), total number of code bytes required (including
 * operand bytes), and a description of the type of each operand.
 * These operand types include signed and unsigned integers of length
 * one and four bytes. The unsigned integers are used for indexes or
 * for, e.g., the count of objects to push in a "push" instruction.
 */

#define MAX_INSTRUCTION_OPERANDS 2

typedef enum InstOperandType {
    OPERAND_NONE,
    OPERAND_INT1,		/* One byte signed integer. */
    OPERAND_INT4,		/* Four byte signed integer. */
    OPERAND_UINT1,		/* One byte unsigned integer. */
    OPERAND_UINT4		/* Four byte unsigned integer. */
} InstOperandType;

typedef struct InstructionDesc {
    char *name;			/* Name of instruction. */
    int numBytes;		/* Total number of bytes for instruction. */
    int stackEffect;            /* The worst-case balance stack effect of the 
				 * instruction, used for stack requirements 
				 * computations. The value INT_MIN signals
				 * that the instruction's worst case effect
				 * is (1-opnd1).
				 */
    int numOperands;		/* Number of operands. */
    InstOperandType opTypes[MAX_INSTRUCTION_OPERANDS];
				/* The type of each operand. */
} InstructionDesc;

extern InstructionDesc tclInstructionTable[];

/*
 * Definitions of the values of the INST_CALL_BUILTIN_FUNC instruction's
 * operand byte. Each value denotes a builtin Tcl math function. These
 * values must correspond to the entries in the tclBuiltinFuncTable array
 * below and to the values stored in the tclInt.h MathFunc structure's
 * builtinFuncIndex field.
 */

#define BUILTIN_FUNC_ACOS		0
#define BUILTIN_FUNC_ASIN		1
#define BUILTIN_FUNC_ATAN		2
#define BUILTIN_FUNC_ATAN2		3
#define BUILTIN_FUNC_CEIL		4
#define BUILTIN_FUNC_COS		5
#define BUILTIN_FUNC_COSH		6
#define BUILTIN_FUNC_EXP		7
#define BUILTIN_FUNC_FLOOR		8
#define BUILTIN_FUNC_FMOD		9
#define BUILTIN_FUNC_HYPOT		10
#define BUILTIN_FUNC_LOG		11
#define BUILTIN_FUNC_LOG10		12
#define BUILTIN_FUNC_POW		13
#define BUILTIN_FUNC_SIN		14
#define BUILTIN_FUNC_SINH		15
#define BUILTIN_FUNC_SQRT		16
#define BUILTIN_FUNC_TAN		17
#define BUILTIN_FUNC_TANH		18
#define BUILTIN_FUNC_ABS		19
#define BUILTIN_FUNC_DOUBLE		20
#define BUILTIN_FUNC_INT		21
#define BUILTIN_FUNC_RAND		22
#define BUILTIN_FUNC_ROUND		23
#define BUILTIN_FUNC_SRAND		24
#define BUILTIN_FUNC_WIDE		25

#define LAST_BUILTIN_FUNC        	25

/*
 * Table describing the built-in math functions. Entries in this table are
 * indexed by the values of the INST_CALL_BUILTIN_FUNC instruction's
 * operand byte.
 */

typedef int (CallBuiltinFuncProc) _ANSI_ARGS_((Tcl_Interp *interp,
        ExecEnv *eePtr, ClientData clientData));

typedef struct {
    char *name;			/* Name of function. */
    int numArgs;		/* Number of arguments for function. */
    Tcl_ValueType argTypes[MAX_MATH_ARGS];
				/* Acceptable types for each argument. */
    CallBuiltinFuncProc *proc;	/* Procedure implementing this function. */
    ClientData clientData;	/* Additional argument to pass to the
				 * function when invoking it. */
} BuiltinFunc;

extern BuiltinFunc tclBuiltinFuncTable[];

/*
 * Compilation of some Tcl constructs such as if commands and the logical or
 * (||) and logical and (&&) operators in expressions requires the
 * generation of forward jumps. Since the PC target of these jumps isn't
 * known when the jumps are emitted, we record the offset of each jump in an
 * array of JumpFixup structures. There is one array for each sequence of
 * jumps to one target PC. When we learn the target PC, we update the jumps
 * with the correct distance. Also, if the distance is too great (> 127
 * bytes), we replace the single-byte jump with a four byte jump
 * instruction, move the instructions after the jump down, and update the
 * code offsets for any commands between the jump and the target.
 */

typedef enum {
    TCL_UNCONDITIONAL_JUMP,
    TCL_TRUE_JUMP,
    TCL_FALSE_JUMP
} TclJumpType;

typedef struct JumpFixup {
    TclJumpType jumpType;	/* Indicates the kind of jump. */
    int codeOffset;		/* Offset of the first byte of the one-byte
				 * forward jump's code. */
    int cmdIndex;		/* Index of the first command after the one
				 * for which the jump was emitted. Used to
				 * update the code offsets for subsequent
				 * commands if the two-byte jump at jumpPc
				 * must be replaced with a five-byte one. */
    int exceptIndex;		/* Index of the first range entry in the
				 * ExceptionRange array after the current
				 * one. This field is used to adjust the
				 * code offsets in subsequent ExceptionRange
				 * records when a jump is grown from 2 bytes
				 * to 5 bytes. */
} JumpFixup;

#define JUMPFIXUP_INIT_ENTRIES    10

typedef struct JumpFixupArray {
    JumpFixup *fixup;		/* Points to start of jump fixup array. */
    int next;			/* Index of next free array entry. */
    int end;			/* Index of last usable entry in array. */
    int mallocedArray;		/* 1 if array was expanded and fixups points
				 * into the heap, else 0. */
    JumpFixup staticFixupSpace[JUMPFIXUP_INIT_ENTRIES];
				/* Initial storage for jump fixup array. */
} JumpFixupArray;

/*
 * The structure describing one variable list of a foreach command. Note
 * that only foreach commands inside procedure bodies are compiled inline so
 * a ForeachVarList structure always describes local variables. Furthermore,
 * only scalar variables are supported for inline-compiled foreach loops.
 */

typedef struct ForeachVarList {
    int numVars;		/* The number of variables in the list. */
    int varIndexes[1];		/* An array of the indexes ("slot numbers")
				 * for each variable in the procedure's
				 * array of local variables. Only scalar
				 * variables are supported. The actual
				 * size of this field will be large enough
				 * to numVars indexes. THIS MUST BE THE
				 * LAST FIELD IN THE STRUCTURE! */
} ForeachVarList;

/*
 * Structure used to hold information about a foreach command that is needed
 * during program execution. These structures are stored in CompileEnv and
 * ByteCode structures as auxiliary data.
 */

typedef struct ForeachInfo {
    int numLists;		/* The number of both the variable and value
				 * lists of the foreach command. */
    int firstValueTemp;		/* Index of the first temp var in a proc
				 * frame used to point to a value list. */
    int loopCtTemp;		/* Index of temp var in a proc frame
				 * holding the loop's iteration count. Used
				 * to determine next value list element to
				 * assign each loop var. */
    ForeachVarList *varLists[1];/* An array of pointers to ForeachVarList
				 * structures describing each var list. The
				 * actual size of this field will be large
				 * enough to numVars indexes. THIS MUST BE
				 * THE LAST FIELD IN THE STRUCTURE! */
} ForeachInfo;

extern AuxDataType		tclForeachInfoType;


/*
 *----------------------------------------------------------------
 * Procedures exported by tclBasic.c to be used within the engine.
 *----------------------------------------------------------------
 */

EXTERN int		TclEvalObjvInternal _ANSI_ARGS_((Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[], CONST char *command, int length,
			    int flags));
EXTERN int              TclInterpReady _ANSI_ARGS_((Tcl_Interp *interp));


/*
 *----------------------------------------------------------------
 * Procedures exported by the engine to be used by tclBasic.c
 *----------------------------------------------------------------
 */

#ifndef TCL_TIP280
EXTERN int		TclCompEvalObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));
#else
EXTERN int		TclCompEvalObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, CONST CmdFrame* invoker,
			    int word));
#endif

/*
 *----------------------------------------------------------------
 * Procedures shared among Tcl bytecode compilation and execution
 * modules but not used outside:
 *----------------------------------------------------------------
 */

EXTERN void		TclCleanupByteCode _ANSI_ARGS_((ByteCode *codePtr));
EXTERN int		TclCompileCmdWord _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Token *tokenPtr, int count,
			    CompileEnv *envPtr));
EXTERN int		TclCompileExpr _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *script, int numBytes,
			    CompileEnv *envPtr));
EXTERN int		TclCompileExprWords _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Token *tokenPtr, int numWords,
			    CompileEnv *envPtr));
EXTERN int		TclCompileScript _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *script, int numBytes, int nested,
			    CompileEnv *envPtr));
EXTERN int		TclCompileTokens _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Token *tokenPtr, int count,
			    CompileEnv *envPtr));
EXTERN int		TclCreateAuxData _ANSI_ARGS_((ClientData clientData,
			    AuxDataType *typePtr, CompileEnv *envPtr));
EXTERN int		TclCreateExceptRange _ANSI_ARGS_((
			    ExceptionRangeType type, CompileEnv *envPtr));
EXTERN ExecEnv *	TclCreateExecEnv _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN void		TclDeleteExecEnv _ANSI_ARGS_((ExecEnv *eePtr));
EXTERN void		TclDeleteLiteralTable _ANSI_ARGS_((
			    Tcl_Interp *interp, LiteralTable *tablePtr));
EXTERN void		TclEmitForwardJump _ANSI_ARGS_((CompileEnv *envPtr,
			    TclJumpType jumpType, JumpFixup *jumpFixupPtr));
EXTERN ExceptionRange *	TclGetExceptionRangeForPc _ANSI_ARGS_((
			    unsigned char *pc, int catchOnly,
			    ByteCode* codePtr));
EXTERN void		TclExpandJumpFixupArray _ANSI_ARGS_((
                            JumpFixupArray *fixupArrayPtr));
EXTERN void		TclFinalizeAuxDataTypeTable _ANSI_ARGS_((void));
EXTERN int		TclFindCompiledLocal _ANSI_ARGS_((CONST char *name, 
        		    int nameChars, int create, int flags,
			    Proc *procPtr));
EXTERN LiteralEntry *	TclLookupLiteralEntry _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Obj *objPtr));
EXTERN int		TclFixupForwardJump _ANSI_ARGS_((
			    CompileEnv *envPtr, JumpFixup *jumpFixupPtr,
			    int jumpDist, int distThreshold));
EXTERN void		TclFreeCompileEnv _ANSI_ARGS_((CompileEnv *envPtr));
EXTERN void		TclFreeJumpFixupArray _ANSI_ARGS_((
  			    JumpFixupArray *fixupArrayPtr));
EXTERN void		TclInitAuxDataTypeTable _ANSI_ARGS_((void));
EXTERN void		TclInitByteCodeObj _ANSI_ARGS_((Tcl_Obj *objPtr,
			    CompileEnv *envPtr));
EXTERN void		TclInitCompilation _ANSI_ARGS_((void));
#ifndef TCL_TIP280
EXTERN void		TclInitCompileEnv _ANSI_ARGS_((Tcl_Interp *interp,
			    CompileEnv *envPtr, char *string,
			    int numBytes));
#else
EXTERN void		TclInitCompileEnv _ANSI_ARGS_((Tcl_Interp *interp,
			    CompileEnv *envPtr, char *string,
			    int numBytes, CONST CmdFrame* invoker, int word));
#endif
EXTERN void		TclInitJumpFixupArray _ANSI_ARGS_((
			    JumpFixupArray *fixupArrayPtr));
EXTERN void		TclInitLiteralTable _ANSI_ARGS_((
			    LiteralTable *tablePtr));
#ifdef TCL_COMPILE_STATS
EXTERN char *		TclLiteralStats _ANSI_ARGS_((
			    LiteralTable *tablePtr));
EXTERN int		TclLog2 _ANSI_ARGS_((int value));
#endif
#ifdef TCL_COMPILE_DEBUG
EXTERN void		TclPrintByteCodeObj _ANSI_ARGS_((Tcl_Interp *interp,
		            Tcl_Obj *objPtr));
#endif
EXTERN int		TclPrintInstruction _ANSI_ARGS_((ByteCode* codePtr,
			    unsigned char *pc));
EXTERN void		TclPrintObject _ANSI_ARGS_((FILE *outFile,
			    Tcl_Obj *objPtr, int maxChars));
EXTERN void		TclPrintSource _ANSI_ARGS_((FILE *outFile,
			    CONST char *string, int maxChars));
EXTERN void		TclRegisterAuxDataType _ANSI_ARGS_((AuxDataType *typePtr));
EXTERN int		TclRegisterLiteral _ANSI_ARGS_((CompileEnv *envPtr,
			    char *bytes, int length, int onHeap));
EXTERN void		TclReleaseLiteral _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));
EXTERN void		TclSetCmdNameObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, Command *cmdPtr));
#ifdef TCL_COMPILE_DEBUG
EXTERN void		TclVerifyGlobalLiteralTable _ANSI_ARGS_((
			    Interp *iPtr));
EXTERN void		TclVerifyLocalLiteralTable _ANSI_ARGS_((
			    CompileEnv *envPtr));
#endif
EXTERN int		TclCompileVariableCmd _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Parse *parsePtr, CompileEnv *envPtr));

/*
 *----------------------------------------------------------------
 * Macros used by Tcl bytecode compilation and execution modules
 * inside the Tcl core but not used outside.
 *----------------------------------------------------------------
 */

/*
 * Form of TclRegisterLiteral with onHeap == 0.
 * In that case, it is safe to cast away CONSTness, and it
 * is cleanest to do that here, all in one place.
 */

#define TclRegisterNewLiteral(envPtr, bytes, length) \
	TclRegisterLiteral(envPtr, (char *)(bytes), length, /*onHeap*/ 0)

/*
 * Macro used to update the stack requirements.
 * It is called by the macros TclEmitOpCode, TclEmitInst1 and
 * TclEmitInst4.
 * Remark that the very last instruction of a bytecode always
 * reduces the stack level: INST_DONE or INST_POP, so that the 
 * maxStackdepth is always updated.
 */

#define TclUpdateStackReqs(op, i, envPtr) \
    {\
	int delta = tclInstructionTable[(op)].stackEffect;\
	if (delta) {\
	    if (delta < 0) {\
		if((envPtr)->maxStackDepth < (envPtr)->currStackDepth) {\
		    (envPtr)->maxStackDepth = (envPtr)->currStackDepth;\
		}\
		if (delta == INT_MIN) {\
		    delta = 1 - (i);\
		}\
	    }\
	    (envPtr)->currStackDepth += delta;\
	}\
    }

/*
 * Macro to emit an opcode byte into a CompileEnv's code array.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN void	TclEmitOpcode _ANSI_ARGS_((unsigned char op,
 *		    CompileEnv *envPtr));
 */

#define TclEmitOpcode(op, envPtr) \
    if ((envPtr)->codeNext == (envPtr)->codeEnd) \
        TclExpandCodeArray(envPtr); \
    *(envPtr)->codeNext++ = (unsigned char) (op);\
    TclUpdateStackReqs(op, 0, envPtr)

/*
 * Macro to emit an integer operand.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN void	TclEmitInt1 _ANSI_ARGS_((int i, CompileEnv *envPtr));
 */

#define TclEmitInt1(i, envPtr) \
    if ((envPtr)->codeNext == (envPtr)->codeEnd) \
        TclExpandCodeArray(envPtr); \
    *(envPtr)->codeNext++ = (unsigned char) ((unsigned int) (i))

/*
 * Macros to emit an instruction with signed or unsigned integer operands.
 * Four byte integers are stored in "big-endian" order with the high order
 * byte stored at the lowest address.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN void	TclEmitInstInt1 _ANSI_ARGS_((unsigned char op, int i, 
 *		    CompileEnv *envPtr));
 * EXTERN void	TclEmitInstInt4 _ANSI_ARGS_((unsigned char op, int i, 
 *		    CompileEnv *envPtr));
 */


#define TclEmitInstInt1(op, i, envPtr) \
    if (((envPtr)->codeNext + 2) > (envPtr)->codeEnd) { \
        TclExpandCodeArray(envPtr); \
    } \
    *(envPtr)->codeNext++ = (unsigned char) (op); \
    *(envPtr)->codeNext++ = (unsigned char) ((unsigned int) (i));\
    TclUpdateStackReqs(op, i, envPtr)

#define TclEmitInstInt4(op, i, envPtr) \
    if (((envPtr)->codeNext + 5) > (envPtr)->codeEnd) { \
        TclExpandCodeArray(envPtr); \
    } \
    *(envPtr)->codeNext++ = (unsigned char) (op); \
    *(envPtr)->codeNext++ = \
        (unsigned char) ((unsigned int) (i) >> 24); \
    *(envPtr)->codeNext++ = \
        (unsigned char) ((unsigned int) (i) >> 16); \
    *(envPtr)->codeNext++ = \
        (unsigned char) ((unsigned int) (i) >>  8); \
    *(envPtr)->codeNext++ = \
        (unsigned char) ((unsigned int) (i)      );\
    TclUpdateStackReqs(op, i, envPtr)
    
/*
 * Macro to push a Tcl object onto the Tcl evaluation stack. It emits the
 * object's one or four byte array index into the CompileEnv's code
 * array. These support, respectively, a maximum of 256 (2**8) and 2**32
 * objects in a CompileEnv. The ANSI C "prototype" for this macro is:
 *
 * EXTERN void	TclEmitPush _ANSI_ARGS_((int objIndex, CompileEnv *envPtr));
 */

#define TclEmitPush(objIndex, envPtr) \
    {\
        register int objIndexCopy = (objIndex);\
        if (objIndexCopy <= 255) { \
	    TclEmitInstInt1(INST_PUSH1, objIndexCopy, (envPtr)); \
        } else { \
	    TclEmitInstInt4(INST_PUSH4, objIndexCopy, (envPtr)); \
	}\
    }

/*
 * Macros to update a (signed or unsigned) integer starting at a pointer.
 * The two variants depend on the number of bytes. The ANSI C "prototypes"
 * for these macros are:
 *
 * EXTERN void	TclStoreInt1AtPtr _ANSI_ARGS_((int i, unsigned char *p));
 * EXTERN void	TclStoreInt4AtPtr _ANSI_ARGS_((int i, unsigned char *p));
 */
    
#define TclStoreInt1AtPtr(i, p) \
    *(p)   = (unsigned char) ((unsigned int) (i))
    
#define TclStoreInt4AtPtr(i, p) \
    *(p)   = (unsigned char) ((unsigned int) (i) >> 24); \
    *(p+1) = (unsigned char) ((unsigned int) (i) >> 16); \
    *(p+2) = (unsigned char) ((unsigned int) (i) >>  8); \
    *(p+3) = (unsigned char) ((unsigned int) (i)      )

/*
 * Macros to update instructions at a particular pc with a new op code
 * and a (signed or unsigned) int operand. The ANSI C "prototypes" for
 * these macros are:
 *
 * EXTERN void	TclUpdateInstInt1AtPc _ANSI_ARGS_((unsigned char op, int i,
 *		    unsigned char *pc));
 * EXTERN void	TclUpdateInstInt4AtPc _ANSI_ARGS_((unsigned char op, int i,
 *		    unsigned char *pc));
 */

#define TclUpdateInstInt1AtPc(op, i, pc) \
    *(pc) = (unsigned char) (op); \
    TclStoreInt1AtPtr((i), ((pc)+1))

#define TclUpdateInstInt4AtPc(op, i, pc) \
    *(pc) = (unsigned char) (op); \
    TclStoreInt4AtPtr((i), ((pc)+1))
    
/*
 * Macros to get a signed integer (GET_INT{1,2}) or an unsigned int
 * (GET_UINT{1,2}) from a pointer. There are two variants for each
 * return type that depend on the number of bytes fetched.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN int	        TclGetInt1AtPtr  _ANSI_ARGS_((unsigned char *p));
 * EXTERN int	        TclGetInt4AtPtr  _ANSI_ARGS_((unsigned char *p));
 * EXTERN unsigned int	TclGetUInt1AtPtr _ANSI_ARGS_((unsigned char *p));
 * EXTERN unsigned int	TclGetUInt4AtPtr _ANSI_ARGS_((unsigned char *p));
 */

/*
 * The TclGetInt1AtPtr macro is tricky because we want to do sign
 * extension on the 1-byte value. Unfortunately the "char" type isn't
 * signed on all platforms so sign-extension doesn't always happen
 * automatically. Sometimes we can explicitly declare the pointer to be
 * signed, but other times we have to explicitly sign-extend the value
 * in software.
 */

#ifndef __CHAR_UNSIGNED__
#   define TclGetInt1AtPtr(p) ((int) *((char *) p))
#else
#   ifdef HAVE_SIGNED_CHAR
#	define TclGetInt1AtPtr(p) ((int) *((signed char *) p))
#    else
#	define TclGetInt1AtPtr(p) (((int) *((char *) p)) \
		| ((*(p) & 0200) ? (-256) : 0))
#    endif
#endif

#define TclGetInt4AtPtr(p) (((int) TclGetInt1AtPtr(p) << 24) | \
		                  	    (*((p)+1) << 16) | \
				  	    (*((p)+2) <<  8) | \
				  	    (*((p)+3)))

#define TclGetUInt1AtPtr(p) ((unsigned int) *(p))
#define TclGetUInt4AtPtr(p) ((unsigned int) (*(p)     << 24) | \
		                            (*((p)+1) << 16) | \
				            (*((p)+2) <<  8) | \
				            (*((p)+3)))

/*
 * Macros used to compute the minimum and maximum of two integers.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN int  TclMin _ANSI_ARGS_((int i, int j));
 * EXTERN int  TclMax _ANSI_ARGS_((int i, int j));
 */

#define TclMin(i, j)   ((((int) i) < ((int) j))? (i) : (j))
#define TclMax(i, j)   ((((int) i) > ((int) j))? (i) : (j))

/*
 * DTrace probe macros (NOPs if DTrace support is not enabled).
 */

/*
 * Define the following macros to enable debug logging of the DTrace proc,
 * cmd, and inst probes. Note that this does _not_ require a platform with
 * DTrace, it simply logs all probe output to /tmp/tclDTraceDebug-[pid].log.
 *
 * If the second macro is defined, logging to file starts immediately,
 * otherwise only after the first call to [tcl::dtrace]. Note that the debug
 * probe data is always computed, even when it is not logged to file.
 * 
 * Defining the third macro enables debug logging of inst probes (disabled
 * by default due to the significant performance impact).
 */

/*
#define TCL_DTRACE_DEBUG 1
#define TCL_DTRACE_DEBUG_LOG_ENABLED 1
#define TCL_DTRACE_DEBUG_INST_PROBES 1
*/

#if !(defined(TCL_DTRACE_DEBUG) && defined(__GNUC__))

#ifdef USE_DTRACE

#include "tclDTrace.h"

#if defined(__GNUC__) && __GNUC__ > 2
/* Use gcc branch prediction hint to minimize cost of DTrace ENABLED checks. */
#define unlikely(x) (__builtin_expect((x), 0))
#else
#define unlikely(x) (x)
#endif

#define TCL_DTRACE_PROC_ENTRY_ENABLED()	    unlikely(TCL_PROC_ENTRY_ENABLED())
#define TCL_DTRACE_PROC_RETURN_ENABLED()    unlikely(TCL_PROC_RETURN_ENABLED())
#define TCL_DTRACE_PROC_RESULT_ENABLED()    unlikely(TCL_PROC_RESULT_ENABLED())
#define TCL_DTRACE_PROC_ARGS_ENABLED()	    unlikely(TCL_PROC_ARGS_ENABLED())
#define TCL_DTRACE_PROC_ENTRY(a0, a1, a2)   TCL_PROC_ENTRY(a0, a1, a2)
#define TCL_DTRACE_PROC_RETURN(a0, a1)	    TCL_PROC_RETURN(a0, a1)
#define TCL_DTRACE_PROC_RESULT(a0, a1, a2, a3) TCL_PROC_RESULT(a0, a1, a2, a3)
#define TCL_DTRACE_PROC_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	TCL_PROC_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define TCL_DTRACE_CMD_ENTRY_ENABLED()	    unlikely(TCL_CMD_ENTRY_ENABLED())
#define TCL_DTRACE_CMD_RETURN_ENABLED()	    unlikely(TCL_CMD_RETURN_ENABLED())
#define TCL_DTRACE_CMD_RESULT_ENABLED()	    unlikely(TCL_CMD_RESULT_ENABLED())
#define TCL_DTRACE_CMD_ARGS_ENABLED()	    unlikely(TCL_CMD_ARGS_ENABLED())
#define TCL_DTRACE_CMD_ENTRY(a0, a1, a2)    TCL_CMD_ENTRY(a0, a1, a2)
#define TCL_DTRACE_CMD_RETURN(a0, a1)	    TCL_CMD_RETURN(a0, a1)
#define TCL_DTRACE_CMD_RESULT(a0, a1, a2, a3) TCL_CMD_RESULT(a0, a1, a2, a3)
#define TCL_DTRACE_CMD_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	TCL_CMD_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define TCL_DTRACE_INST_START_ENABLED()	    unlikely(TCL_INST_START_ENABLED())
#define TCL_DTRACE_INST_DONE_ENABLED()	    unlikely(TCL_INST_DONE_ENABLED())
#define TCL_DTRACE_INST_START(a0, a1, a2)   TCL_INST_START(a0, a1, a2)
#define TCL_DTRACE_INST_DONE(a0, a1, a2)    TCL_INST_DONE(a0, a1, a2)

#define TCL_DTRACE_TCL_PROBE_ENABLED()	    unlikely(TCL_TCL_PROBE_ENABLED())
#define TCL_DTRACE_TCL_PROBE(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	TCL_TCL_PROBE(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define TCL_DTRACE_DEBUG_LOG()

#else /* USE_DTRACE */

#define TCL_DTRACE_PROC_ENTRY_ENABLED()	    0
#define TCL_DTRACE_PROC_RETURN_ENABLED()    0
#define TCL_DTRACE_PROC_RESULT_ENABLED()    0
#define TCL_DTRACE_PROC_ARGS_ENABLED()	    0
#define TCL_DTRACE_PROC_ENTRY(a0, a1, a2)   {}
#define TCL_DTRACE_PROC_RETURN(a0, a1)	    {}
#define TCL_DTRACE_PROC_RESULT(a0, a1, a2, a3) {}
#define TCL_DTRACE_PROC_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {}

#define TCL_DTRACE_CMD_ENTRY_ENABLED()	    0
#define TCL_DTRACE_CMD_RETURN_ENABLED()	    0
#define TCL_DTRACE_CMD_RESULT_ENABLED()	    0
#define TCL_DTRACE_CMD_ARGS_ENABLED()	    0
#define TCL_DTRACE_CMD_ENTRY(a0, a1, a2)    {}
#define TCL_DTRACE_CMD_RETURN(a0, a1)	    {}
#define TCL_DTRACE_CMD_RESULT(a0, a1, a2, a3) {}
#define TCL_DTRACE_CMD_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {}

#define TCL_DTRACE_INST_START_ENABLED()	    0
#define TCL_DTRACE_INST_DONE_ENABLED()	    0
#define TCL_DTRACE_INST_START(a0, a1, a2)   {}
#define TCL_DTRACE_INST_DONE(a0, a1, a2)    {}

#define TCL_DTRACE_TCL_PROBE_ENABLED()	    0
#define TCL_DTRACE_TCL_PROBE(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {}

#endif /* USE_DTRACE */

#else /* TCL_DTRACE_DEBUG */

#define USE_DTRACE 1

#if !defined(TCL_DTRACE_DEBUG_LOG_ENABLED) || !(TCL_DTRACE_DEBUG_LOG_ENABLED)
#undef TCL_DTRACE_DEBUG_LOG_ENABLED
#define TCL_DTRACE_DEBUG_LOG_ENABLED 0
#endif

#if !defined(TCL_DTRACE_DEBUG_INST_PROBES) || !(TCL_DTRACE_DEBUG_INST_PROBES)
#undef TCL_DTRACE_DEBUG_INST_PROBES
#define TCL_DTRACE_DEBUG_INST_PROBES 0
#endif

MODULE_SCOPE int tclDTraceDebugEnabled, tclDTraceDebugIndent;
MODULE_SCOPE FILE *tclDTraceDebugLog;
MODULE_SCOPE void TclDTraceOpenDebugLog(void);
MODULE_SCOPE void TclDTraceInfo(Tcl_Obj *info, char **args, int *argsi);

#define TCL_DTRACE_DEBUG_LOG() \
	int tclDTraceDebugEnabled = TCL_DTRACE_DEBUG_LOG_ENABLED;\
	int tclDTraceDebugIndent = 0; \
	FILE *tclDTraceDebugLog = NULL; \
	void TclDTraceOpenDebugLog(void) { char n[35]; \
	sprintf(n, "/tmp/tclDTraceDebug-%lu.log", (unsigned long) getpid()); \
	tclDTraceDebugLog = fopen(n, "a"); } \

#define TclDTraceDbgMsg(p, m, ...) do { if (tclDTraceDebugEnabled) { \
	int _l, _t = 0; if (!tclDTraceDebugLog) { TclDTraceOpenDebugLog(); } \
	fprintf(tclDTraceDebugLog, "%.12s:%.4d:%n", strrchr(__FILE__, '/') + \
		1, __LINE__, &_l); _t += _l; \
	fprintf(tclDTraceDebugLog, " %.*s():%n", (_t < 18 ? 18 - _t : 0) + \
		18, __func__, &_l); _t += _l; \
	fprintf(tclDTraceDebugLog, "%*s" p "%n", (_t < 40 ? 40 - _t : 0) + \
		2 * tclDTraceDebugIndent, "", &_l); _t += _l; \
	fprintf(tclDTraceDebugLog, "%*s" m "\n", (_t < 64 ? 64 - _t : 1), "", \
		##__VA_ARGS__); fflush(tclDTraceDebugLog); \
	} } while (0)

#define TCL_DTRACE_PROC_ENTRY_ENABLED()	    1
#define TCL_DTRACE_PROC_RETURN_ENABLED()    1
#define TCL_DTRACE_PROC_RESULT_ENABLED()    1
#define TCL_DTRACE_PROC_ARGS_ENABLED()	    1
#define TCL_DTRACE_PROC_ENTRY(a0, a1, a2) \
	tclDTraceDebugIndent++; \
	TclDTraceDbgMsg("-> proc-entry", "%s %d %p", a0, a1, a2)
#define TCL_DTRACE_PROC_RETURN(a0, a1) \
	TclDTraceDbgMsg("<- proc-return", "%s %d", a0, a1); \
	tclDTraceDebugIndent--
#define TCL_DTRACE_PROC_RESULT(a0, a1, a2, a3) \
	TclDTraceDbgMsg(" | proc-result", "%s %d %s %p", a0, a1, a2, a3)
#define TCL_DTRACE_PROC_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	TclDTraceDbgMsg(" | proc-args", "%s %s %s %s %s %s %s %s %s %s", a0, \
		a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define TCL_DTRACE_CMD_ENTRY_ENABLED()	    1
#define TCL_DTRACE_CMD_RETURN_ENABLED()	    1
#define TCL_DTRACE_CMD_RESULT_ENABLED()	    1
#define TCL_DTRACE_CMD_ARGS_ENABLED()	    1
#define TCL_DTRACE_CMD_ENTRY(a0, a1, a2) \
	tclDTraceDebugIndent++; \
	TclDTraceDbgMsg("-> cmd-entry", "%s %d %p", a0, a1, a2)
#define TCL_DTRACE_CMD_RETURN(a0, a1) \
	TclDTraceDbgMsg("<- cmd-return", "%s %d", a0, a1); \
	tclDTraceDebugIndent--
#define TCL_DTRACE_CMD_RESULT(a0, a1, a2, a3) \
	TclDTraceDbgMsg(" | cmd-result", "%s %d %s %p", a0, a1, a2, a3)
#define TCL_DTRACE_CMD_ARGS(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	TclDTraceDbgMsg(" | cmd-args", "%s %s %s %s %s %s %s %s %s %s", a0, \
		a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define TCL_DTRACE_INST_START_ENABLED()	    TCL_DTRACE_DEBUG_INST_PROBES
#define TCL_DTRACE_INST_DONE_ENABLED()	    TCL_DTRACE_DEBUG_INST_PROBES
#define TCL_DTRACE_INST_START(a0, a1, a2) \
	TclDTraceDbgMsg(" | inst-start", "%s %d %p", a0, a1, a2)
#define TCL_DTRACE_INST_DONE(a0, a1, a2) \
	TclDTraceDbgMsg(" | inst-end", "%s %d %p", a0, a1, a2)

#define TCL_DTRACE_TCL_PROBE_ENABLED()	    1
#define TCL_DTRACE_TCL_PROBE(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	tclDTraceDebugEnabled = 1; \
	TclDTraceDbgMsg(" | tcl-probe", "%s %s %s %s %s %s %s %s %s %s", a0, \
		a1, a2, a3, a4, a5, a6, a7, a8, a9)

#endif /* TCL_DTRACE_DEBUG */

# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TCLCOMPILATION */
                                                                                                                   tclInt.h                                                                                            0100644 0001750 0001750 00000322722 12526746631 034353  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclInt.h --
 *
 *	Declarations of things used internally by the Tcl interpreter.
 *
 * Copyright (c) 1987-1993 The Regents of the University of California.
 * Copyright (c) 1993-1997 Lucent Technologies.
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
 * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclInt.h,v 1.118.2.30 2007/09/13 15:28:13 das Exp $
 */

#ifndef _TCLINT
#define _TCLINT

/*
 * Common include files needed by most of the Tcl source files are
 * included here, so that system-dependent personalizations for the
 * include files only have to be made in once place.  This results
 * in a few extra includes, but greater modularity.  The order of
 * the three groups of #includes is important.	For example, stdio.h
 * is needed by tcl.h, and the _ANSI_ARGS_ declaration in tcl.h is
 * needed by stdlib.h in some configurations.
 */

#ifndef _TCL
#include "tcl.h"
#endif

#include <stdio.h>

#include <ctype.h>
#ifdef NO_LIMITS_H
#   include "../compat/limits.h"
#else
#   include <limits.h>
#endif
#ifdef NO_STDLIB_H
#   include "../compat/stdlib.h"
#else
#   include <stdlib.h>
#endif
#ifdef NO_STRING_H
#include "../compat/string.h"
#else
#include <string.h>
#endif

/*
 * Ensure WORDS_BIGENDIAN is defined correcly:
 * Needs to happen here in addition to configure to work with fat compiles on
 * Darwin (where configure runs only once for multiple architectures).
 */

#ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#    include <sys/param.h>
#endif
#ifdef BYTE_ORDER
#    ifdef BIG_ENDIAN
#        if BYTE_ORDER == BIG_ENDIAN
#            undef WORDS_BIGENDIAN
#            define WORDS_BIGENDIAN 1
#        endif
#    endif
#    ifdef LITTLE_ENDIAN
#        if BYTE_ORDER == LITTLE_ENDIAN
#            undef WORDS_BIGENDIAN
#        endif
#    endif
#endif

/*
 * Used to tag functions that are only to be visible within the module being
 * built and not outside it (where this is supported by the linker).
 */

#ifndef MODULE_SCOPE
#   ifdef __cplusplus
#	define MODULE_SCOPE extern "C"
#   else
#	define MODULE_SCOPE extern
#   endif
#endif

#undef TCL_STORAGE_CLASS
#ifdef BUILD_tcl
# define TCL_STORAGE_CLASS DLLEXPORT
#else
# ifdef USE_TCL_STUBS
#  define TCL_STORAGE_CLASS
# else
#  define TCL_STORAGE_CLASS DLLIMPORT
# endif
#endif

/*
 * The following procedures allow namespaces to be customized to
 * support special name resolution rules for commands/variables.
 * 
 */

struct Tcl_ResolvedVarInfo;

typedef Tcl_Var (Tcl_ResolveRuntimeVarProc) _ANSI_ARGS_((
    Tcl_Interp* interp, struct Tcl_ResolvedVarInfo *vinfoPtr));

typedef void (Tcl_ResolveVarDeleteProc) _ANSI_ARGS_((
    struct Tcl_ResolvedVarInfo *vinfoPtr));

/*
 * The following structure encapsulates the routines needed to resolve a
 * variable reference at runtime.  Any variable specific state will typically
 * be appended to this structure.
 */


typedef struct Tcl_ResolvedVarInfo {
    Tcl_ResolveRuntimeVarProc *fetchProc;
    Tcl_ResolveVarDeleteProc *deleteProc;
} Tcl_ResolvedVarInfo;



typedef int (Tcl_ResolveCompiledVarProc) _ANSI_ARGS_((
    Tcl_Interp* interp, CONST84 char* name, int length,
    Tcl_Namespace *context, Tcl_ResolvedVarInfo **rPtr));

typedef int (Tcl_ResolveVarProc) _ANSI_ARGS_((
    Tcl_Interp* interp, CONST84 char* name, Tcl_Namespace *context,
    int flags, Tcl_Var *rPtr));

typedef int (Tcl_ResolveCmdProc) _ANSI_ARGS_((Tcl_Interp* interp,
    CONST84 char* name, Tcl_Namespace *context, int flags,
    Tcl_Command *rPtr));
 
typedef struct Tcl_ResolverInfo {
    Tcl_ResolveCmdProc *cmdResProc;	/* Procedure handling command name
					 * resolution. */
    Tcl_ResolveVarProc *varResProc;	/* Procedure handling variable name
					 * resolution for variables that
					 * can only be handled at runtime. */
    Tcl_ResolveCompiledVarProc *compiledVarResProc;
					/* Procedure handling variable name
					 * resolution at compile time. */
} Tcl_ResolverInfo;

/*
 *----------------------------------------------------------------
 * Data structures related to namespaces.
 *----------------------------------------------------------------
 */

/*
 * The structure below defines a namespace.
 * Note: the first five fields must match exactly the fields in a
 * Tcl_Namespace structure (see tcl.h). If you change one, be sure to
 * change the other.
 */

typedef struct Namespace {
    char *name;			 /* The namespace's simple (unqualified)
				  * name. This contains no ::'s. The name of
				  * the global namespace is "" although "::"
				  * is an synonym. */
    char *fullName;		 /* The namespace's fully qualified name.
				  * This starts with ::. */
    ClientData clientData;	 /* An arbitrary value associated with this
				  * namespace. */
    Tcl_NamespaceDeleteProc *deleteProc;
				 /* Procedure invoked when deleting the
				  * namespace to, e.g., free clientData. */
    struct Namespace *parentPtr; /* Points to the namespace that contains
				  * this one. NULL if this is the global
				  * namespace. */
    Tcl_HashTable childTable;	 /* Contains any child namespaces. Indexed
				  * by strings; values have type
				  * (Namespace *). */
    long nsId;			 /* Unique id for the namespace. */
    Tcl_Interp *interp;		 /* The interpreter containing this
				  * namespace. */
    int flags;			 /* OR-ed combination of the namespace
				  * status flags NS_DYING and NS_DEAD
				  * listed below. */
    int activationCount;	 /* Number of "activations" or active call
				  * frames for this namespace that are on
				  * the Tcl call stack. The namespace won't
				  * be freed until activationCount becomes
				  * zero. */
    int refCount;		 /* Count of references by namespaceName *
				  * objects. The namespace can't be freed
				  * until refCount becomes zero. */
    Tcl_HashTable cmdTable;	 /* Contains all the commands currently
				  * registered in the namespace. Indexed by
				  * strings; values have type (Command *).
				  * Commands imported by Tcl_Import have
				  * Command structures that point (via an
				  * ImportedCmdRef structure) to the
				  * Command structure in the source
				  * namespace's command table. */
    Tcl_HashTable varTable;	 /* Contains all the (global) variables
				  * currently in this namespace. Indexed
				  * by strings; values have type (Var *). */
    char **exportArrayPtr;	 /* Points to an array of string patterns
				  * specifying which commands are exported.
				  * A pattern may include "string match"
				  * style wildcard characters to specify
				  * multiple commands; however, no namespace
				  * qualifiers are allowed. NULL if no
				  * export patterns are registered. */
    int numExportPatterns;	 /* Number of export patterns currently
				  * registered using "namespace export". */
    int maxExportPatterns;	 /* Mumber of export patterns for which
				  * space is currently allocated. */
    int cmdRefEpoch;		 /* Incremented if a newly added command
				  * shadows a command for which this
				  * namespace has already cached a Command *
				  * pointer; this causes all its cached
				  * Command* pointers to be invalidated. */
    int resolverEpoch;		 /* Incremented whenever (a) the name resolution
				  * rules change for this namespace or (b) a 
				  * newly added command shadows a command that
				  * is compiled to bytecodes.
				  * This invalidates all byte codes compiled
				  * in the namespace, causing the code to be
				  * recompiled under the new rules.*/
    Tcl_ResolveCmdProc *cmdResProc;
				 /* If non-null, this procedure overrides
				  * the usual command resolution mechanism
				  * in Tcl.  This procedure is invoked
				  * within Tcl_FindCommand to resolve all
				  * command references within the namespace. */
    Tcl_ResolveVarProc *varResProc;
				 /* If non-null, this procedure overrides
				  * the usual variable resolution mechanism
				  * in Tcl.  This procedure is invoked
				  * within Tcl_FindNamespaceVar to resolve all
				  * variable references within the namespace
				  * at runtime. */
    Tcl_ResolveCompiledVarProc *compiledVarResProc;
				 /* If non-null, this procedure overrides
				  * the usual variable resolution mechanism
				  * in Tcl.  This procedure is invoked
				  * within LookupCompiledLocal to resolve
				  * variable references within the namespace
				  * at compile time. */
} Namespace;

/*
 * Flags used to represent the status of a namespace:
 *
 * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
 *		namespace but there are still active call frames on the Tcl
 *		stack that refer to the namespace. When the last call frame
 *		referring to it has been popped, it's variables and command
 *		will be destroyed and it will be marked "dead" (NS_DEAD).
 *		The namespace can no longer be looked up by name.
 * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
 *		namespace and no call frames still refer to it. Its
 *		variables and command have already been destroyed. This bit
 *		allows the namespace resolution code to recognize that the
 *		namespace is "deleted". When the last namespaceName object
 *		in any byte code code unit that refers to the namespace has
 *		been freed (i.e., when the namespace's refCount is 0), the
 *		namespace's storage will be freed.
 * NS_KILLED    1 means that TclTeardownNamespace has already been called on
 *              this namespace and it should not be called again [Bug 1355942]
 */

#define NS_DYING	0x01
#define NS_DEAD		0x02
#define NS_KILLED       0x04

/*
 * Flag passed to TclGetNamespaceForQualName to have it create all namespace
 * components of a namespace-qualified name that cannot be found. The new
 * namespaces are created within their specified parent. Note that this
 * flag's value must not conflict with the values of the flags
 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, and FIND_ONLY_NS (defined in
 * tclNamesp.c).
 */

#define CREATE_NS_IF_UNKNOWN 0x800

/*
 *----------------------------------------------------------------
 * Data structures related to variables.   These are used primarily
 * in tclVar.c
 *----------------------------------------------------------------
 */

/*
 * The following structure defines a variable trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a variable.
 */

typedef struct VarTrace {
    Tcl_VarTraceProc *traceProc;/* Procedure to call when operations given
				 * by flags are performed on variable. */
    ClientData clientData;	/* Argument to pass to proc. */
    int flags;			/* What events the trace procedure is
				 * interested in:  OR-ed combination of
				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
    struct VarTrace *nextPtr;	/* Next in list of traces associated with
				 * a particular variable. */
} VarTrace;

/*
 * The following structure defines a command trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a command.
 */

typedef struct CommandTrace {
    Tcl_CommandTraceProc *traceProc;/* Procedure to call when operations given
				     * by flags are performed on command. */
    ClientData clientData;	    /* Argument to pass to proc. */
    int flags;			    /* What events the trace procedure is
				     * interested in:  OR-ed combination of
				     * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
    struct CommandTrace *nextPtr;   /* Next in list of traces associated with
				     * a particular command. */
    int refCount;                   /* Used to ensure this structure is
                                     * not deleted too early.  Keeps track
                                     * of how many pieces of code have
                                     * a pointer to this structure. */
} CommandTrace;

/*
 * When a command trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the command's interpreter.  The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveCommandTrace {
    struct Command *cmdPtr;	/* Command that's being traced. */
    struct ActiveCommandTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    CommandTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
    int reverseScan;		/* Boolean set true when the traces
				 * are scanning in reverse order. */
} ActiveCommandTrace;

/*
 * When a variable trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the variable's interpreter.	The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveVarTrace {
    struct Var *varPtr;		/* Variable that's being traced. */
    struct ActiveVarTrace *nextPtr;
				/* Next in list of all active variable
				 * traces for the interpreter, or NULL
				 * if no more. */
    VarTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveVarTrace;

/*
 * The following structure describes an enumerative search in progress on
 * an array variable;  this are invoked with options to the "array"
 * command.
 */

typedef struct ArraySearch {
    int id;			/* Integer id used to distinguish among
				 * multiple concurrent searches for the
				 * same array. */
    struct Var *varPtr;		/* Pointer to array variable that's being
				 * searched. */
    Tcl_HashSearch search;	/* Info kept by the hash module about
				 * progress through the array. */
    Tcl_HashEntry *nextEntry;	/* Non-null means this is the next element
				 * to be enumerated (it's leftover from
				 * the Tcl_FirstHashEntry call or from
				 * an "array anymore" command).	 NULL
				 * means must call Tcl_NextHashEntry
				 * to get value to return. */
    struct ArraySearch *nextPtr;/* Next in list of all active searches
				 * for this variable, or NULL if this is
				 * the last one. */
} ArraySearch;

/*
 * The structure below defines a variable, which associates a string name
 * with a Tcl_Obj value. These structures are kept in procedure call frames
 * (for local variables recognized by the compiler) or in the heap (for
 * global variables and any variable not known to the compiler). For each
 * Var structure in the heap, a hash table entry holds the variable name and
 * a pointer to the Var structure.
 */

typedef struct Var {
    union {
	Tcl_Obj *objPtr;	/* The variable's object value. Used for 
				 * scalar variables and array elements. */
	Tcl_HashTable *tablePtr;/* For array variables, this points to
				 * information about the hash table used
				 * to implement the associative array. 
				 * Points to malloc-ed data. */
	struct Var *linkPtr;	/* If this is a global variable being
				 * referred to in a procedure, or a variable
				 * created by "upvar", this field points to
				 * the referenced variable's Var struct. */
    } value;
    char *name;			/* NULL if the variable is in a hashtable,
				 * otherwise points to the variable's
				 * name. It is used, e.g., by TclLookupVar
				 * and "info locals". The storage for the
				 * characters of the name is not owned by
				 * the Var and must not be freed when
				 * freeing the Var. */
    Namespace *nsPtr;		/* Points to the namespace that contains
				 * this variable or NULL if the variable is
				 * a local variable in a Tcl procedure. */
    Tcl_HashEntry *hPtr;	/* If variable is in a hashtable, either the
				 * hash table entry that refers to this
				 * variable or NULL if the variable has been
				 * detached from its hash table (e.g. an
				 * array is deleted, but some of its
				 * elements are still referred to in
				 * upvars). NULL if the variable is not in a
				 * hashtable. This is used to delete an
				 * variable from its hashtable if it is no
				 * longer needed. */
    int refCount;		/* Counts number of active uses of this
				 * variable, not including its entry in the
				 * call frame or the hash table: 1 for each
				 * additional variable whose linkPtr points
				 * here, 1 for each nested trace active on
				 * variable, and 1 if the variable is a 
				 * namespace variable. This record can't be
				 * deleted until refCount becomes 0. */
    VarTrace *tracePtr;		/* First in list of all traces set for this
				 * variable. */
    ArraySearch *searchPtr;	/* First in list of all searches active
				 * for this variable, or NULL if none. */
    int flags;			/* Miscellaneous bits of information about
				 * variable. See below for definitions. */
} Var;

/*
 * Flag bits for variables. The first three (VAR_SCALAR, VAR_ARRAY, and
 * VAR_LINK) are mutually exclusive and give the "type" of the variable.
 * VAR_UNDEFINED is independent of the variable's type. 
 *
 * VAR_SCALAR -			1 means this is a scalar variable and not
 *				an array or link. The "objPtr" field points
 *				to the variable's value, a Tcl object.
 * VAR_ARRAY -			1 means this is an array variable rather
 *				than a scalar variable or link. The
 *				"tablePtr" field points to the array's
 *				hashtable for its elements.
 * VAR_LINK -			1 means this Var structure contains a
 *				pointer to another Var structure that
 *				either has the real value or is itself
 *				another VAR_LINK pointer. Variables like
 *				this come about through "upvar" and "global"
 *				commands, or through references to variables
 *				in enclosing namespaces.
 * VAR_UNDEFINED -		1 means that the variable is in the process
 *				of being deleted. An undefined variable
 *				logically does not exist and survives only
 *				while it has a trace, or if it is a global
 *				variable currently being used by some
 *				procedure.
 * VAR_IN_HASHTABLE -		1 means this variable is in a hashtable and
 *				the Var structure is malloced. 0 if it is
 *				a local variable that was assigned a slot
 *				in a procedure frame by	the compiler so the
 *				Var storage is part of the call frame.
 * VAR_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a read or write access, so
 *				new read or write accesses should not cause
 *				trace procedures to be called and the
 *				variable can't be deleted.
 * VAR_ARRAY_ELEMENT -		1 means that this variable is an array
 *				element, so it is not legal for it to be
 *				an array itself (the VAR_ARRAY flag had
 *				better not be set).
 * VAR_NAMESPACE_VAR -		1 means that this variable was declared
 *				as a namespace variable. This flag ensures
 *				it persists until its namespace is
 *				destroyed or until the variable is unset;
 *				it will persist even if it has not been
 *				initialized and is marked undefined.
 *				The variable's refCount is incremented to
 *				reflect the "reference" from its namespace.
 *
 * The following additional flags are used with the CompiledLocal type
 * defined below:
 *
 * VAR_ARGUMENT -		1 means that this variable holds a procedure
 *				argument. 
 * VAR_TEMPORARY -		1 if the local variable is an anonymous
 *				temporary variable. Temporaries have a NULL
 *				name.
 * VAR_RESOLVED -		1 if name resolution has been done for this
 *				variable.
 */

#define VAR_SCALAR		0x1
#define VAR_ARRAY		0x2
#define VAR_LINK		0x4
#define VAR_UNDEFINED		0x8
#define VAR_IN_HASHTABLE	0x10
#define VAR_TRACE_ACTIVE	0x20
#define VAR_ARRAY_ELEMENT	0x40
#define VAR_NAMESPACE_VAR	0x80

#define VAR_ARGUMENT		0x100
#define VAR_TEMPORARY		0x200
#define VAR_RESOLVED		0x400	

/*
 * Macros to ensure that various flag bits are set properly for variables.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN void	TclSetVarScalar _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarArray _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarLink _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarArrayElement _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarUndefined _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclClearVarUndefined _ANSI_ARGS_((Var *varPtr));
 */

#define TclSetVarScalar(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~(VAR_ARRAY|VAR_LINK)) | VAR_SCALAR

#define TclSetVarArray(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~(VAR_SCALAR|VAR_LINK)) | VAR_ARRAY

#define TclSetVarLink(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~(VAR_SCALAR|VAR_ARRAY)) | VAR_LINK

#define TclSetVarArrayElement(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_ARRAY_ELEMENT

#define TclSetVarUndefined(varPtr) \
    (varPtr)->flags |= VAR_UNDEFINED

#define TclClearVarUndefined(varPtr) \
    (varPtr)->flags &= ~VAR_UNDEFINED

/*
 * Macros to read various flag bits of variables.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN int	TclIsVarScalar _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarLink _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarArray _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarUndefined _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarArrayElement _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarTemporary _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarArgument _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarResolved _ANSI_ARGS_((Var *varPtr));
 */
    
#define TclIsVarScalar(varPtr) \
    ((varPtr)->flags & VAR_SCALAR)

#define TclIsVarLink(varPtr) \
    ((varPtr)->flags & VAR_LINK)

#define TclIsVarArray(varPtr) \
    ((varPtr)->flags & VAR_ARRAY)

#define TclIsVarUndefined(varPtr) \
    ((varPtr)->flags & VAR_UNDEFINED)

#define TclIsVarArrayElement(varPtr) \
    ((varPtr)->flags & VAR_ARRAY_ELEMENT)

#define TclIsVarTemporary(varPtr) \
    ((varPtr)->flags & VAR_TEMPORARY)
    
#define TclIsVarArgument(varPtr) \
    ((varPtr)->flags & VAR_ARGUMENT)
    
#define TclIsVarResolved(varPtr) \
    ((varPtr)->flags & VAR_RESOLVED)

/*
 *----------------------------------------------------------------
 * Data structures related to procedures.  These are used primarily
 * in tclProc.c, tclCompile.c, and tclExecute.c.
 *----------------------------------------------------------------
 */

/*
 * Forward declaration to prevent an error when the forward reference to
 * Command is encountered in the Proc and ImportRef types declared below.
 */

struct Command;

/*
 * The variable-length structure below describes a local variable of a
 * procedure that was recognized by the compiler. These variables have a
 * name, an element in the array of compiler-assigned local variables in the
 * procedure's call frame, and various other items of information. If the
 * local variable is a formal argument, it may also have a default value.
 * The compiler can't recognize local variables whose names are
 * expressions (these names are only known at runtime when the expressions
 * are evaluated) or local variables that are created as a result of an
 * "upvar" or "uplevel" command. These other local variables are kept
 * separately in a hash table in the call frame.
 */

typedef struct CompiledLocal {
    struct CompiledLocal *nextPtr;
				/* Next compiler-recognized local variable
				 * for this procedure, or NULL if this is
				 * the last local. */
    int nameLength;		/* The number of characters in local
				 * variable's name. Used to speed up
				 * variable lookups. */
    int frameIndex;		/* Index in the array of compiler-assigned
				 * variables in the procedure call frame. */
    int flags;			/* Flag bits for the local variable. Same as
				 * the flags for the Var structure above,
				 * although only VAR_SCALAR, VAR_ARRAY, 
				 * VAR_LINK, VAR_ARGUMENT, VAR_TEMPORARY, and
				 * VAR_RESOLVED make sense. */
    Tcl_Obj *defValuePtr;	/* Pointer to the default value of an
				 * argument, if any. NULL if not an argument
				 * or, if an argument, no default value. */
    Tcl_ResolvedVarInfo *resolveInfo;
				/* Customized variable resolution info
				 * supplied by the Tcl_ResolveCompiledVarProc
				 * associated with a namespace. Each variable
				 * is marked by a unique ClientData tag
				 * during compilation, and that same tag
				 * is used to find the variable at runtime. */
    char name[4];		/* Name of the local variable starts here.
				 * If the name is NULL, this will just be
				 * '\0'. The actual size of this field will
				 * be large enough to hold the name. MUST
				 * BE THE LAST FIELD IN THE STRUCTURE! */
} CompiledLocal;

/*
 * The structure below defines a command procedure, which consists of a
 * collection of Tcl commands plus information about arguments and other
 * local variables recognized at compile time.
 */

typedef struct Proc {
    struct Interp *iPtr;	  /* Interpreter for which this command
				   * is defined. */
    int refCount;		  /* Reference count: 1 if still present
				   * in command table plus 1 for each call
				   * to the procedure that is currently
				   * active. This structure can be freed
				   * when refCount becomes zero. */
    struct Command *cmdPtr;	  /* Points to the Command structure for
				   * this procedure. This is used to get
				   * the namespace in which to execute
				   * the procedure. */
    Tcl_Obj *bodyPtr;		  /* Points to the ByteCode object for
				   * procedure's body command. */
    int numArgs;		  /* Number of formal parameters. */
    int numCompiledLocals;	  /* Count of local variables recognized by
				   * the compiler including arguments and
				   * temporaries. */
    CompiledLocal *firstLocalPtr; /* Pointer to first of the procedure's
				   * compiler-allocated local variables, or
				   * NULL if none. The first numArgs entries
				   * in this list describe the procedure's
				   * formal arguments. */
    CompiledLocal *lastLocalPtr;  /* Pointer to the last allocated local
				   * variable or NULL if none. This has
				   * frame index (numCompiledLocals-1). */
} Proc;

/*
 * The structure below defines a command trace.	 This is used to allow Tcl
 * clients to find out whenever a command is about to be executed.
 */

typedef struct Trace {
    int level;			/* Only trace commands at nesting level
				 * less than or equal to this. */
    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
    ClientData clientData;	/* Arbitrary value to pass to proc. */
    struct Trace *nextPtr;	/* Next in list of traces for this interp. */
    int flags;			/* Flags governing the trace - see
				 * Tcl_CreateObjTrace for details */
    Tcl_CmdObjTraceDeleteProc* delProc;
				/* Procedure to call when trace is deleted */
} Trace;

/*
 * When an interpreter trace is active (i.e. its associated procedure
 * is executing), one of the following structures is linked into a list
 * associated with the interpreter.  The information in the structure
 * is needed in order for Tcl to behave reasonably if traces are
 * deleted while traces are active.
 */

typedef struct ActiveInterpTrace {
    struct ActiveInterpTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    Trace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
    int reverseScan;		/* Boolean set true when the traces
				 * are scanning in reverse order. */
} ActiveInterpTrace;

/*
 * The structure below defines an entry in the assocData hash table which
 * is associated with an interpreter. The entry contains a pointer to a
 * function to call when the interpreter is deleted, and a pointer to
 * a user-defined piece of data.
 */

typedef struct AssocData {
    Tcl_InterpDeleteProc *proc;	/* Proc to call when deleting. */
    ClientData clientData;	/* Value to pass to proc. */
} AssocData;	

/*
 * The structure below defines a call frame. A call frame defines a naming
 * context for a procedure call: its local naming scope (for local
 * variables) and its global naming scope (a namespace, perhaps the global
 * :: namespace). A call frame can also define the naming context for a
 * namespace eval or namespace inscope command: the namespace in which the
 * command's code should execute. The Tcl_CallFrame structures exist only
 * while procedures or namespace eval/inscope's are being executed, and
 * provide a kind of Tcl call stack.
 * 
 * WARNING!! The structure definition must be kept consistent with the
 * Tcl_CallFrame structure in tcl.h. If you change one, change the other.
 */

typedef struct CallFrame {
    Namespace *nsPtr;		/* Points to the namespace used to resolve
				 * commands and global variables. */
    int isProcCallFrame;	/* If nonzero, the frame was pushed to
				 * execute a Tcl procedure and may have
				 * local vars. If 0, the frame was pushed
				 * to execute a namespace command and var
				 * references are treated as references to
				 * namespace vars; varTablePtr and
				 * compiledLocals are ignored. */
    int objc;			/* This and objv below describe the
				 * arguments for this procedure call. */
    Tcl_Obj *CONST *objv;	/* Array of argument objects. */
    struct CallFrame *callerPtr;
				/* Value of interp->framePtr when this
				 * procedure was invoked (i.e. next higher
				 * in stack of all active procedures). */
    struct CallFrame *callerVarPtr;
				/* Value of interp->varFramePtr when this
				 * procedure was invoked (i.e. determines
				 * variable scoping within caller). Same
				 * as callerPtr unless an "uplevel" command
				 * or something equivalent was active in
				 * the caller). */
    int level;			/* Level of this procedure, for "uplevel"
				 * purposes (i.e. corresponds to nesting of
				 * callerVarPtr's, not callerPtr's). 1 for
				 * outermost procedure, 0 for top-level. */
    Proc *procPtr;		/* Points to the structure defining the
				 * called procedure. Used to get information
				 * such as the number of compiled local
				 * variables (local variables assigned
				 * entries ["slots"] in the compiledLocals
				 * array below). */
    Tcl_HashTable *varTablePtr;	/* Hash table containing local variables not
				 * recognized by the compiler, or created at
				 * execution time through, e.g., upvar.
				 * Initially NULL and created if needed. */
    int numCompiledLocals;	/* Count of local variables recognized by
				 * the compiler including arguments. */
    Var* compiledLocals;	/* Points to the array of local variables
				 * recognized by the compiler. The compiler
				 * emits code that refers to these variables
				 * using an index into this array. */
} CallFrame;

#ifdef TCL_TIP280
/*
 * TIP #280
 * The structure below defines a command frame. A command frame
 * provides location information for all commands executing a tcl
 * script (source, eval, uplevel, procedure bodies, ...). The runtime
 * structure essentially contains the stack trace as it would be if
 * the currently executing command were to throw an error.
 *
 * For commands where it makes sense it refers to the associated
 * CallFrame as well.
 *
 * The structures are chained in a single list, with the top of the
 * stack anchored in the Interp structure.
 *
 * Instances can be allocated on the C stack, or the heap, the former
 * making cleanup a bit simpler.
 */

typedef struct CmdFrame {
  /* General data. Always available. */

  int              type;     /* Values see below */
  int              level;    /* #Frames in stack, prevent O(n) scan of list */
  int*             line;     /* Lines the words of the command start on */
  int              nline;

  CallFrame*       framePtr; /* Procedure activation record, may be NULL */
  struct CmdFrame* nextPtr;  /* Link to calling frame */

  /* Data needed for Eval vs TEBC
   *
   * EXECUTION CONTEXTS and usage of CmdFrame
   *
   * Field      TEBC            EvalEx          EvalObjEx
   * =======    ====            ======          =========
   * level      yes             yes             yes
   * type       BC/PREBC        SRC/EVAL        EVAL_LIST
   * line0      yes             yes             yes
   * framePtr   yes             yes             yes
   * =======    ====            ======          =========
   *
   * =======    ====            ======          ========= union data
   * line1      -               yes             -
   * line3      -               yes             -
   * path       -               yes             -
   * -------    ----            ------          ---------
   * codePtr    yes             -               -
   * pc         yes             -               -
   * =======    ====            ======          =========
   *
   * =======    ====            ======          ========= | union cmd
   * listPtr    -               -               yes       |
   * -------    ----            ------          --------- |
   * cmd        yes             yes             -         |
   * cmdlen     yes             yes             -         |
   * -------    ----            ------          --------- |
   */

  union {
    struct {
      Tcl_Obj*     path;     /* Path of the sourced file the command
			      * is in. */
    } eval;
    struct {
      CONST void*  codePtr;  /* Byte code currently executed */
      CONST char*  pc;       /* and instruction pointer.     */
    } tebc;
  } data;

  union {
    struct {
      CONST char*  cmd;      /* The executed command, if possible */
      int          len;      /* And its length */
    } str;
    Tcl_Obj*       listPtr;  /* Tcl_EvalObjEx, cmd list */
  } cmd;

} CmdFrame;

/* The following macros define the allowed values for the type field
 * of the CmdFrame structure above. Some of the values occur only in
 * the extended location data referenced via the 'baseLocPtr'.
 *
 * TCL_LOCATION_EVAL      : Frame is for a script evaluated by EvalEx.
 * TCL_LOCATION_EVAL_LIST : Frame is for a script evaluated by the list
 *                          optimization path of EvalObjEx.
 * TCL_LOCATION_BC        : Frame is for bytecode. 
 * TCL_LOCATION_PREBC     : Frame is for precompiled bytecode.
 * TCL_LOCATION_SOURCE    : Frame is for a script evaluated by EvalEx,
 *                          from a sourced file.
 * TCL_LOCATION_PROC      : Frame is for bytecode of a procedure.
 *
 * A TCL_LOCATION_BC type in a frame can be overridden by _SOURCE and
 * _PROC types, per the context of the byte code in execution.
 */

#define TCL_LOCATION_EVAL      (0) /* Location in a dynamic eval script */
#define TCL_LOCATION_EVAL_LIST (1) /* Location in a dynamic eval script, list-path */
#define TCL_LOCATION_BC        (2) /* Location in byte code */
#define TCL_LOCATION_PREBC     (3) /* Location in precompiled byte code, no location */
#define TCL_LOCATION_SOURCE    (4) /* Location in a file */
#define TCL_LOCATION_PROC      (5) /* Location in a dynamic proc */

#define TCL_LOCATION_LAST      (6) /* Number of values in the enum */

typedef struct CFWord {
  CmdFrame* framePtr;  /* CmdFrame to acess */
  int       word;      /* Index of the word in the command */
  int       refCount;  /* #times the word is on the stack */
} CFWord;

typedef struct CFWordBC {
    CmdFrame* framePtr;  /* CmdFrame to acess */
    int pc;   /* Instruction pointer of a command in ExtCmdLoc.loc[.] */
    int word; /* Index of word in ExtCmdLoc.loc[cmd]->{line,literal}[.] */
    struct CFWordBC* prevPtr;
} CFWordBC;

/*
 * Structure to record the locations of invisible continuation lines in
 * literal scripts, as character offset from the beginning of the script. Both
 * compiler and direct evaluator use this information to adjust their line
 * counters when tracking through the script, because when it is invoked the
 * continuation line marker as a whole has been removed already, meaning that
 * the \n which was part of it is gone as well, breaking regular line
 * tracking.
 *
 * These structures are allocated and filled by both the function
 * EvalTokensStandard() in the file "tclBasic.c" and its caller EvalEx(), and
 * stored in the thread-global hashtable "lineCLPtr" in file "tclObj.c". They
 * are used by the functions TclSetByteCodeFromAny() and TclCompileScript(),
 * both found in the file "tclCompile.c". Their memory is released by the
 * function TclFreeObj(), in the file "tclObj.c", and also by the function
 * TclThreadFinalizeObjects(), in the same file.
 */

#define CLL_END (-1)

typedef struct ContLineLoc {
  int num;      /* Number of entries in loc, not counting the final -1
		 * marker entry */
  int loc[1];   /* Table of locations, as character offsets. The table is
		 * allocated as part of the structure, i.e. the loc array
		 * extends behind the nominal end of the structure. An entry
		 * containing the value CLL_END is put after the last
		 * location, as end-marker/sentinel. */
} ContLineLoc;

#endif /* TCL_TIP280 */

/*
 *----------------------------------------------------------------
 * Data structures and procedures related to TclHandles, which
 * are a very lightweight method of preserving enough information
 * to determine if an arbitrary malloc'd block has been deleted.
 *----------------------------------------------------------------
 */

typedef VOID **TclHandle;

/*
 *----------------------------------------------------------------
 * Data structures related to expressions.  These are used only in
 * tclExpr.c.
 *----------------------------------------------------------------
 */

/*
 * The data structure below defines a math function (e.g. sin or hypot)
 * for use in Tcl expressions.
 */

#define MAX_MATH_ARGS 5
typedef struct MathFunc {
    int builtinFuncIndex;	/* If this is a builtin math function, its
				 * index in the array of builtin functions.
				 * (tclCompilation.h lists these indices.)
				 * The value is -1 if this is a new function
				 * defined by Tcl_CreateMathFunc. The value
				 * is also -1 if a builtin function is
				 * replaced by a Tcl_CreateMathFunc call. */
    int numArgs;		/* Number of arguments for function. */
    Tcl_ValueType argTypes[MAX_MATH_ARGS];
				/* Acceptable types for each argument. */
    Tcl_MathProc *proc;		/* Procedure that implements this function.
				 * NULL if isBuiltinFunc is 1. */
    ClientData clientData;	/* Additional argument to pass to the
				 * function when invoking it. NULL if
				 * isBuiltinFunc is 1. */
} MathFunc;

/*
 * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
 * when threads are used, or an emulation if there are no threads.  These
 * are really internal and Tcl clients should use Tcl_GetThreadData.
 */

EXTERN VOID *TclThreadDataKeyGet _ANSI_ARGS_((Tcl_ThreadDataKey *keyPtr));
EXTERN void TclThreadDataKeySet _ANSI_ARGS_((Tcl_ThreadDataKey *keyPtr, VOID *data));

/*
 * This is a convenience macro used to initialize a thread local storage ptr.
 */
#define TCL_TSD_INIT(keyPtr)	(ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))


/*
 *----------------------------------------------------------------
 * Data structures related to bytecode compilation and execution.
 * These are used primarily in tclCompile.c, tclExecute.c, and
 * tclBasic.c.
 *----------------------------------------------------------------
 */

/*
 * Forward declaration to prevent errors when the forward references to
 * Tcl_Parse and CompileEnv are encountered in the procedure type
 * CompileProc declared below.
 */

struct CompileEnv;

/*
 * The type of procedures called by the Tcl bytecode compiler to compile
 * commands. Pointers to these procedures are kept in the Command structure
 * describing each command. When a CompileProc returns, the interpreter's
 * result is set to error information, if any. In addition, the CompileProc
 * returns an integer value, which is one of the following:
 *
 * TCL_OK		Compilation completed normally.
 * TCL_ERROR		Compilation failed because of an error;
 *			the interpreter's result describes what went wrong.
 * TCL_OUT_LINE_COMPILE	Compilation failed because, e.g., the command is
 *			too complex for effective inline compilation. The
 *			CompileProc believes the command is legal but 
 *			should be compiled "out of line" by emitting code
 *			to invoke its command procedure at runtime.
 */

#define TCL_OUT_LINE_COMPILE	(TCL_CONTINUE + 1)

typedef int (CompileProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Parse *parsePtr, struct CompileEnv *compEnvPtr));

/*
 * The type of procedure called from the compilation hook point in
 * SetByteCodeFromAny.
 */

typedef int (CompileHookProc) _ANSI_ARGS_((Tcl_Interp *interp,
	struct CompileEnv *compEnvPtr, ClientData clientData));

/*
 * The data structure defining the execution environment for ByteCode's.
 * There is one ExecEnv structure per Tcl interpreter. It holds the
 * evaluation stack that holds command operands and results. The stack grows
 * towards increasing addresses. The "stackTop" member is cached by
 * TclExecuteByteCode in a local variable: it must be set before calling
 * TclExecuteByteCode and will be restored by TclExecuteByteCode before it
 * returns.
 */

typedef struct ExecEnv {
    Tcl_Obj **stackPtr;		/* Points to the first item in the
				 * evaluation stack on the heap. */
    int stackTop;		/* Index of current top of stack; -1 when
				 * the stack is empty. */
    int stackEnd;		/* Index of last usable item in stack. */
    Tcl_Obj *errorInfo;
    Tcl_Obj *errorCode;
} ExecEnv;

/*
 * The definitions for the LiteralTable and LiteralEntry structures. Each
 * interpreter contains a LiteralTable. It is used to reduce the storage
 * needed for all the Tcl objects that hold the literals of scripts compiled
 * by the interpreter. A literal's object is shared by all the ByteCodes
 * that refer to the literal. Each distinct literal has one LiteralEntry
 * entry in the LiteralTable. A literal table is a specialized hash table
 * that is indexed by the literal's string representation, which may contain
 * null characters.
 *
 * Note that we reduce the space needed for literals by sharing literal
 * objects both within a ByteCode (each ByteCode contains a local
 * LiteralTable) and across all an interpreter's ByteCodes (with the
 * interpreter's global LiteralTable).
 */

typedef struct LiteralEntry {
    struct LiteralEntry *nextPtr;	/* Points to next entry in this
					 * hash bucket or NULL if end of
					 * chain. */
    Tcl_Obj *objPtr;			/* Points to Tcl object that
					 * holds the literal's bytes and
					 * length. */
    int refCount;			/* If in an interpreter's global
					 * literal table, the number of
					 * ByteCode structures that share
					 * the literal object; the literal
					 * entry can be freed when refCount
					 * drops to 0. If in a local literal
					 * table, -1. */
} LiteralEntry;

typedef struct LiteralTable {
    LiteralEntry **buckets;		/* Pointer to bucket array. Each
					 * element points to first entry in
					 * bucket's hash chain, or NULL. */
    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
					/* Bucket array used for small
					 * tables to avoid mallocs and
					 * frees. */
    int numBuckets;			/* Total number of buckets allocated
					 * at **buckets. */
    int numEntries;			/* Total number of entries present
					 * in table. */
    int rebuildSize;			/* Enlarge table when numEntries
					 * gets to be this large. */
    int mask;				/* Mask value used in hashing
					 * function. */
} LiteralTable;

/*
 * The following structure defines for each Tcl interpreter various
 * statistics-related information about the bytecode compiler and
 * interpreter's operation in that interpreter.
 */

#ifdef TCL_COMPILE_STATS
typedef struct ByteCodeStats {
    long numExecutions;		  /* Number of ByteCodes executed. */
    long numCompilations;	  /* Number of ByteCodes created. */
    long numByteCodesFreed;	  /* Number of ByteCodes destroyed. */
    long instructionCount[256];	  /* Number of times each instruction was
				   * executed. */

    double totalSrcBytes;	  /* Total source bytes ever compiled. */
    double totalByteCodeBytes;	  /* Total bytes for all ByteCodes. */
    double currentSrcBytes;	  /* Src bytes for all current ByteCodes. */
    double currentByteCodeBytes;  /* Code bytes in all current ByteCodes. */

    long srcCount[32];		  /* Source size distribution: # of srcs of
				   * size [2**(n-1)..2**n), n in [0..32). */
    long byteCodeCount[32];	  /* ByteCode size distribution. */
    long lifetimeCount[32];	  /* ByteCode lifetime distribution (ms). */
    
    double currentInstBytes;	  /* Instruction bytes-current ByteCodes. */
    double currentLitBytes;	  /* Current literal bytes. */
    double currentExceptBytes;	  /* Current exception table bytes. */
    double currentAuxBytes;	  /* Current auxiliary information bytes. */
    double currentCmdMapBytes;	  /* Current src<->code map bytes. */
    
    long numLiteralsCreated;	  /* Total literal objects ever compiled. */
    double totalLitStringBytes;	  /* Total string bytes in all literals. */
    double currentLitStringBytes; /* String bytes in current literals. */
    long literalCount[32];	  /* Distribution of literal string sizes. */
} ByteCodeStats;
#endif /* TCL_COMPILE_STATS */

/*
 *----------------------------------------------------------------
 * Data structures related to commands.
 *----------------------------------------------------------------
 */

/*
 * An imported command is created in an namespace when it imports a "real"
 * command from another namespace. An imported command has a Command
 * structure that points (via its ClientData value) to the "real" Command
 * structure in the source namespace's command table. The real command
 * records all the imported commands that refer to it in a list of ImportRef
 * structures so that they can be deleted when the real command is deleted.  */

typedef struct ImportRef {
    struct Command *importedCmdPtr;
				/* Points to the imported command created in
				 * an importing namespace; this command
				 * redirects its invocations to the "real"
				 * command. */
    struct ImportRef *nextPtr;	/* Next element on the linked list of
				 * imported commands that refer to the
				 * "real" command. The real command deletes
				 * these imported commands on this list when
				 * it is deleted. */
} ImportRef;

/*
 * Data structure used as the ClientData of imported commands: commands
 * created in an namespace when it imports a "real" command from another
 * namespace.
 */

typedef struct ImportedCmdData {
    struct Command *realCmdPtr;	/* "Real" command that this imported command
				 * refers to. */
    struct Command *selfPtr;	/* Pointer to this imported command. Needed
				 * only when deleting it in order to remove
				 * it from the real command's linked list of
				 * imported commands that refer to it. */
} ImportedCmdData;

/*
 * A Command structure exists for each command in a namespace. The
 * Tcl_Command opaque type actually refers to these structures.
 */

typedef struct Command {
    Tcl_HashEntry *hPtr;	/* Pointer to the hash table entry that
				 * refers to this command. The hash table is
				 * either a namespace's command table or an
				 * interpreter's hidden command table. This
				 * pointer is used to get a command's name
				 * from its Tcl_Command handle. NULL means
				 * that the hash table entry has been
				 * removed already (this can happen if
				 * deleteProc causes the command to be
				 * deleted or recreated). */
    Namespace *nsPtr;		/* Points to the namespace containing this
				 * command. */
    int refCount;		/* 1 if in command hashtable plus 1 for each
				 * reference from a CmdName Tcl object
				 * representing a command's name in a
				 * ByteCode instruction sequence. This
				 * structure can be freed when refCount
				 * becomes zero. */
    int cmdEpoch;		/* Incremented to invalidate any references
				 * that point to this command when it is
				 * renamed, deleted, hidden, or exposed. */
    CompileProc *compileProc;	/* Procedure called to compile command. NULL
				 * if no compile proc exists for command. */
    Tcl_ObjCmdProc *objProc;	/* Object-based command procedure. */
    ClientData objClientData;	/* Arbitrary value passed to object proc. */
    Tcl_CmdProc *proc;		/* String-based command procedure. */
    ClientData clientData;	/* Arbitrary value passed to string proc. */
    Tcl_CmdDeleteProc *deleteProc;
				/* Procedure invoked when deleting command
				 * to, e.g., free all client data. */
    ClientData deleteData;	/* Arbitrary value passed to deleteProc. */
    int flags;			/* Miscellaneous bits of information about
				 * command. See below for definitions. */
    ImportRef *importRefPtr;	/* List of each imported Command created in
				 * another namespace when this command is
				 * imported. These imported commands
				 * redirect invocations back to this
				 * command. The list is used to remove all
				 * those imported commands when deleting
				 * this "real" command. */
    CommandTrace *tracePtr;	/* First in list of all traces set for this
				 * command. */
} Command;

/*
 * Flag bits for commands. 
 *
 * CMD_IS_DELETED -		Means that the command is in the process
 *                              of being deleted (its deleteProc is
 *                              currently executing). Other attempts to
 *                              delete the command should be ignored.
 * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a rename/delete change.
 *				See the two flags below for which is
 *				currently being processed.
 * CMD_HAS_EXEC_TRACES -	1 means that this command has at least
 *                              one execution trace (as opposed to simple
 *                              delete/rename traces) in its tracePtr list.
 * TCL_TRACE_RENAME -           A rename trace is in progress. Further
 *                              recursive renames will not be traced.
 * TCL_TRACE_DELETE -           A delete trace is in progress. Further 
 *                              recursive deletes will not be traced.
 * (these last two flags are defined in tcl.h)
 */
#define CMD_IS_DELETED		0x1
#define CMD_TRACE_ACTIVE	0x2
#define CMD_HAS_EXEC_TRACES	0x4

/*
 *----------------------------------------------------------------
 * Data structures related to name resolution procedures.
 *----------------------------------------------------------------
 */

/*
 * The interpreter keeps a linked list of name resolution schemes.
 * The scheme for a namespace is consulted first, followed by the
 * list of schemes in an interpreter, followed by the default
 * name resolution in Tcl.  Schemes are added/removed from the
 * interpreter's list by calling Tcl_AddInterpResolver and
 * Tcl_RemoveInterpResolver.
 */

typedef struct ResolverScheme {
    char *name;			/* Name identifying this scheme. */
    Tcl_ResolveCmdProc *cmdResProc;
				/* Procedure handling command name
				 * resolution. */
    Tcl_ResolveVarProc *varResProc;
				/* Procedure handling variable name
				 * resolution for variables that
				 * can only be handled at runtime. */
    Tcl_ResolveCompiledVarProc *compiledVarResProc;
				/* Procedure handling variable name
				 * resolution at compile time. */

    struct ResolverScheme *nextPtr;
				/* Pointer to next record in linked list. */
} ResolverScheme;

#ifdef TCL_TIP268
/*
 * TIP #268.
 * Values for the selection mode, i.e the package require preferences.
 */

enum PkgPreferOptions {
    PKG_PREFER_LATEST, PKG_PREFER_STABLE
};
#endif

/*
 *----------------------------------------------------------------
 * This structure defines an interpreter, which is a collection of
 * commands plus other state information related to interpreting
 * commands, such as variable storage. Primary responsibility for
 * this data structure is in tclBasic.c, but almost every Tcl
 * source file uses something in here.
 *----------------------------------------------------------------
 */

typedef struct Interp {

    /*
     * Note:  the first three fields must match exactly the fields in
     * a Tcl_Interp struct (see tcl.h).	 If you change one, be sure to
     * change the other.
     *
     * The interpreter's result is held in both the string and the
     * objResultPtr fields. These fields hold, respectively, the result's
     * string or object value. The interpreter's result is always in the
     * result field if that is non-empty, otherwise it is in objResultPtr.
     * The two fields are kept consistent unless some C code sets
     * interp->result directly. Programs should not access result and
     * objResultPtr directly; instead, they should always get and set the
     * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult,
     * and Tcl_GetStringResult. See the SetResult man page for details.
     */

    char *result;		/* If the last command returned a string
				 * result, this points to it. Should not be
				 * accessed directly; see comment above. */
    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
				 * allocated. TCL_DYNAMIC means string
				 * result was allocated with ckalloc and
				 * should be freed with ckfree. Other values
				 * give address of procedure to invoke to
				 * free the string result. Tcl_Eval must
				 * free it before executing next command. */
    int errorLine;		/* When TCL_ERROR is returned, this gives
				 * the line number in the command where the
				 * error occurred (1 means first line). */
    struct TclStubs *stubTable;
				/* Pointer to the exported Tcl stub table.
				 * On previous versions of Tcl this is a
				 * pointer to the objResultPtr or a pointer
				 * to a buckets array in a hash table. We
				 * therefore have to do some careful checking
				 * before we can use this. */

    TclHandle handle;		/* Handle used to keep track of when this
				 * interp is deleted. */

    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
    Tcl_HashTable *hiddenCmdTablePtr;
				/* Hash table used by tclBasic.c to keep
				 * track of hidden commands on a per-interp
				 * basis. */
    ClientData interpInfo;	/* Information used by tclInterp.c to keep
				 * track of master/slave interps on
				 * a per-interp basis. */
    Tcl_HashTable mathFuncTable;/* Contains all the math functions currently
				 * defined for the interpreter.	 Indexed by
				 * strings (function names); values have
				 * type (MathFunc *). */



    /*
     * Information related to procedures and variables. See tclProc.c
     * and tclVar.c for usage.
     */

    int numLevels;		/* Keeps track of how many nested calls to
				 * Tcl_Eval are in progress for this
				 * interpreter.	 It's used to delay deletion
				 * of the table until all Tcl_Eval
				 * invocations are completed. */
    int maxNestingDepth;	/* If numLevels exceeds this value then Tcl
				 * assumes that infinite recursion has
				 * occurred and it generates an error. */
    CallFrame *framePtr;	/* Points to top-most in stack of all nested
				 * procedure invocations.  NULL means there
				 * are no active procedures. */
    CallFrame *varFramePtr;	/* Points to the call frame whose variables
				 * are currently in use (same as framePtr
				 * unless an "uplevel" command is
				 * executing). NULL means no procedure is
				 * active or "uplevel 0" is executing. */
    ActiveVarTrace *activeVarTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */
    int returnCode;		/* Completion code to return if current
				 * procedure exits with TCL_RETURN code. */
    char *errorInfo;		/* Value to store in errorInfo if returnCode
				 * is TCL_ERROR.  Malloc'ed, may be NULL */
    char *errorCode;		/* Value to store in errorCode if returnCode
				 * is TCL_ERROR.  Malloc'ed, may be NULL */

    /*
     * Information used by Tcl_AppendResult to keep track of partial
     * results.	 See Tcl_AppendResult code for details.
     */

    char *appendResult;		/* Storage space for results generated
				 * by Tcl_AppendResult.	 Malloc-ed.  NULL
				 * means not yet allocated. */
    int appendAvl;		/* Total amount of space available at
				 * partialResult. */
    int appendUsed;		/* Number of non-null bytes currently
				 * stored at partialResult. */

    /*
     * Information about packages.  Used only in tclPkg.c.
     */

    Tcl_HashTable packageTable;	/* Describes all of the packages loaded
				 * in or available to this interpreter.
				 * Keys are package names, values are
				 * (Package *) pointers. */
    char *packageUnknown;	/* Command to invoke during "package
				 * require" commands for packages that
				 * aren't described in packageTable. 
				 * Malloc'ed, may be NULL. */

    /*
     * Miscellaneous information:
     */

    int cmdCount;		/* Total number of times a command procedure
				 * has been called for this interpreter. */
    int evalFlags;		/* Flags to control next call to Tcl_Eval.
				 * Normally zero, but may be set before
				 * calling Tcl_Eval.  See below for valid
				 * values. */
    int termOffset;		/* Offset of character just after last one
				 * compiled or executed by Tcl_EvalObj. */
    LiteralTable literalTable;	/* Contains LiteralEntry's describing all
				 * Tcl objects holding literals of scripts
				 * compiled by the interpreter. Indexed by
				 * the string representations of literals.
				 * Used to avoid creating duplicate
				 * objects. */
    int compileEpoch;		/* Holds the current "compilation epoch"
				 * for this interpreter. This is
				 * incremented to invalidate existing
				 * ByteCodes when, e.g., a command with a
				 * compile procedure is redefined. */
    Proc *compiledProcPtr;	/* If a procedure is being compiled, a
				 * pointer to its Proc structure; otherwise,
				 * this is NULL. Set by ObjInterpProc in
				 * tclProc.c and used by tclCompile.c to
				 * process local variables appropriately. */
    ResolverScheme *resolverPtr;
				/* Linked list of name resolution schemes
				 * added to this interpreter.  Schemes
				 * are added/removed by calling
				 * Tcl_AddInterpResolvers and
				 * Tcl_RemoveInterpResolver. */
    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
				 * command active;  otherwise this points to
				 * pathPtr of the file being sourced. */
    int flags;			/* Various flag bits.  See below. */
    long randSeed;		/* Seed used for rand() function. */
    Trace *tracePtr;		/* List of traces for this interpreter. */
    Tcl_HashTable *assocData;	/* Hash table for associating data with
				 * this interpreter. Cleaned up when
				 * this interpreter is deleted. */
    struct ExecEnv *execEnvPtr;	/* Execution environment for Tcl bytecode
				 * execution. Contains a pointer to the
				 * Tcl evaluation stack. */
    Tcl_Obj *emptyObjPtr;	/* Points to an object holding an empty
				 * string. Returned by Tcl_ObjSetVar2 when
				 * variable traces change a variable in a
				 * gross way. */
    char resultSpace[TCL_RESULT_SIZE+1];
				/* Static space holding small results. */
    Tcl_Obj *objResultPtr;	/* If the last command returned an object
				 * result, this points to it. Should not be
				 * accessed directly; see comment above. */
    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter */

    ActiveCommandTrace *activeCmdTracePtr;
				/* First in list of active command traces for
				 * interp, or NULL if no active traces. */
    ActiveInterpTrace *activeInterpTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */

    int tracesForbiddingInline; /* Count of traces (in the list headed by
				 * tracePtr) that forbid inline bytecode
				 * compilation */
#ifdef TCL_TIP280
    /* TIP #280 */
    CmdFrame* cmdFramePtr;      /* Points to the command frame containing
				 * the location information for the current
				 * command. */
    CONST CmdFrame* invokeCmdFramePtr; /* Points to the command frame which is the
				  * invoking context of the bytecode compiler.
				  * NULL when the byte code compiler is not
				  * active */
    int invokeWord;             /* Index of the word in the command which
				 * is getting compiled. */
    Tcl_HashTable* linePBodyPtr;
                                /* This table remembers for each
				 * statically defined procedure the
				 * location information for its
				 * body. It is keyed by the address of
				 * the Proc structure for a procedure.
				 * The values are "struct CmdFrame*".
				 */
    Tcl_HashTable* lineBCPtr;
                                /* This table remembers for each
				 * ByteCode object the location
				 * information for its body. It is
				 * keyed by the address of the Proc
				 * structure for a procedure. The
				 * values are "struct ExtCmdLoc*" (See
				 * tclCompile.h).
				 */
    Tcl_HashTable* lineLABCPtr;
    Tcl_HashTable* lineLAPtr;
                                /* This table remembers for each
				 * argument of a command on the
				 * execution stack the index of the
				 * argument in the command, and the
				 * location data of the command. It is
				 * keyed by the address of the Tcl_Obj
				 * containing the argument. The values
				 * are "struct CFWord*" (See
				 * tclBasic.c). This allows commands
				 * like uplevel, eval, etc. to find
				 * location information for their
				 * arguments, if they are a proper
				 * literal argument to an invoking
				 * command. Alt view: An index to the
				 * CmdFrame stack keyed by command
				 * argument holders.
				 */
    ContLineLoc* scriptCLLocPtr;
                                /* This table points to the location data for
				 * invisible continuation lines in the script,
				 * if any. This pointer is set by the function
				 * TclEvalObjEx() in file "tclBasic.c", and
				 * used by function ...() in the same file.
				 * It does for the eval/direct path of script
				 * execution what CompileEnv.clLoc does for
				 * the bytecode compiler.
				 */
#endif
#ifdef TCL_TIP268
    /*
     * TIP #268.
     * The currently active selection mode,
     * i.e the package require preferences.
     */

    int packagePrefer;          /* Current package selection mode. */
#endif
    /*
     * Statistical information about the bytecode compiler and interpreter's
     * operation.
     */

#ifdef TCL_COMPILE_STATS
    ByteCodeStats stats;	/* Holds compilation and execution
				 * statistics for this interpreter. */
#endif /* TCL_COMPILE_STATS */	  
} Interp;

/*
 * EvalFlag bits for Interp structures:
 *
 * TCL_BRACKET_TERM	1 means that the current script is terminated by
 *			a close bracket rather than the end of the string.
 * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with
 *			a code other than TCL_OK or TCL_ERROR;	0 means
 *			codes other than these should be turned into errors.
 */

#define TCL_BRACKET_TERM	  1
#define TCL_ALLOW_EXCEPTIONS	  4
#ifdef TCL_TIP280
#define TCL_EVAL_FILE             2
#define TCL_EVAL_CTX              8
#endif

/*
 * Flag bits for Interp structures:
 *
 * DELETED:		Non-zero means the interpreter has been deleted:
 *			don't process any more commands for it, and destroy
 *			the structure as soon as all nested invocations of
 *			Tcl_Eval are done.
 * ERR_IN_PROGRESS:	Non-zero means an error unwind is already in
 *			progress. Zero means a command proc has been
 *			invoked since last error occured.
 * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged
 *			in $errorInfo for the current Tcl_Eval instance,
 *			so Tcl_Eval needn't log it (used to implement the
 *			"error message log" command).
 * ERROR_CODE_SET:	Non-zero means that Tcl_SetErrorCode has been
 *			called to record information for the current
 *			error.	Zero means Tcl_Eval must clear the
 *			errorCode variable if an error is returned.
 * EXPR_INITIALIZED:	Non-zero means initialization specific to
 *			expressions has	been carried out.
 * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler
 *			should not compile any commands into an inline
 *			sequence of instructions. This is set 1, for
 *			example, when command traces are requested.
 * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the
 *			interp has not be initialized.	This is set 1
 *			when we first use the rand() or srand() functions.
 * SAFE_INTERP:		Non zero means that the current interp is a
 *			safe interp (ie it has only the safe commands
 *			installed, less priviledge than a regular interp).
 * USE_EVAL_DIRECT:	Non-zero means don't use the compiler or byte-code
 *			interpreter; instead, have Tcl_EvalObj call
 *			Tcl_EvalEx. Used primarily for testing the
 *			new parser.
 * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
 *			active; so no further trace callbacks should be
 *			invoked.
 */

#define DELETED				    1
#define ERR_IN_PROGRESS			    2
#define ERR_ALREADY_LOGGED		    4
#define ERROR_CODE_SET			    8
#define EXPR_INITIALIZED		 0x10
#define DONT_COMPILE_CMDS_INLINE	 0x20
#define RAND_SEED_INITIALIZED		 0x40
#define SAFE_INTERP			 0x80
#define USE_EVAL_DIRECT			0x100
#define INTERP_TRACE_IN_PROGRESS	0x200

/*
 * Maximum number of levels of nesting permitted in Tcl commands (used
 * to catch infinite recursion).
 */

#define MAX_NESTING_DEPTH	1000

/*
 * The macro below is used to modify a "char" value (e.g. by casting
 * it to an unsigned character) so that it can be used safely with
 * macros such as isspace.
 */

#define UCHAR(c) ((unsigned char) (c))

/*
 * This macro is used to determine the offset needed to safely allocate any
 * data structure in memory. Given a starting offset or size, it "rounds up"
 * or "aligns" the offset to the next 8-byte boundary so that any data
 * structure can be placed at the resulting offset without fear of an
 * alignment error.
 *
 * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce
 * the wrong result on platforms that allocate addresses that are divisible
 * by 4 or 2. Only use it for offsets or sizes.
 */

#define TCL_ALIGN(x) (((int)(x) + 7) & ~7)

/*
 * The following enum values are used to specify the runtime platform
 * setting of the tclPlatform variable.
 */

typedef enum {
    TCL_PLATFORM_UNIX,		/* Any Unix-like OS. */
    TCL_PLATFORM_MAC,		/* MacOS. */
    TCL_PLATFORM_WINDOWS	/* Any Microsoft Windows OS. */
} TclPlatformType;

/*
 *  The following enum values are used to indicate the translation
 *  of a Tcl channel.  Declared here so that each platform can define
 *  TCL_PLATFORM_TRANSLATION to the native translation on that platform
 */

typedef enum TclEolTranslation {
    TCL_TRANSLATE_AUTO,                 /* Eol == \r, \n and \r\n. */
    TCL_TRANSLATE_CR,                   /* Eol == \r. */
    TCL_TRANSLATE_LF,                   /* Eol == \n. */
    TCL_TRANSLATE_CRLF                  /* Eol == \r\n. */
} TclEolTranslation;

/*
 * Flags for TclInvoke:
 *
 * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set,
 *				invokes an exposed command.
 * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if
 *				the command to be invoked is not found.
 *				Only has an effect if invoking an exposed
 *				command, i.e. if TCL_INVOKE_HIDDEN is not
 *				also set.
 * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if
 *				the invoked command returns an error.  Used
 *				if the caller plans on recording its own
 *				traceback information.
 */

#define	TCL_INVOKE_HIDDEN	(1<<0)
#define TCL_INVOKE_NO_UNKNOWN	(1<<1)
#define TCL_INVOKE_NO_TRACEBACK	(1<<2)

/*
 * The structure used as the internal representation of Tcl list
 * objects. This is an array of pointers to the element objects. This array
 * is grown (reallocated and copied) as necessary to hold all the list's
 * element pointers. The array might contain more slots than currently used
 * to hold all element pointers. This is done to make append operations
 * faster.
 */

typedef struct List {
    int maxElemCount;		/* Total number of element array slots. */
    int elemCount;		/* Current number of list elements. */
    Tcl_Obj **elements;		/* Array of pointers to element objects. */
} List;


/*
 * The following types are used for getting and storing platform-specific
 * file attributes in tclFCmd.c and the various platform-versions of
 * that file. This is done to have as much common code as possible
 * in the file attributes code. For more information about the callbacks,
 * see TclFileAttrsCmd in tclFCmd.c.
 */

typedef int (TclGetFileAttrProc) _ANSI_ARGS_((Tcl_Interp *interp,
	int objIndex, Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr));
typedef int (TclSetFileAttrProc) _ANSI_ARGS_((Tcl_Interp *interp,
	int objIndex, Tcl_Obj *fileName, Tcl_Obj *attrObjPtr));

typedef struct TclFileAttrProcs {
    TclGetFileAttrProc *getProc;	/* The procedure for getting attrs. */
    TclSetFileAttrProc *setProc;	/* The procedure for setting attrs. */
} TclFileAttrProcs;

/*
 * Opaque handle used in pipeline routines to encapsulate platform-dependent
 * state. 
 */

typedef struct TclFile_ *TclFile;
    
/*
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_    *TclpTime_t;
typedef struct TclpTime_t_    *CONST TclpTime_t_CONST;

/*
 * The "globParameters" argument of the function TclGlob is an
 * or'ed combination of the following values:
 */

#define TCL_GLOBMODE_NO_COMPLAIN      1
#define TCL_GLOBMODE_JOIN             2
#define TCL_GLOBMODE_DIR              4
#define TCL_GLOBMODE_TAILS            8

/*
 *----------------------------------------------------------------
 * Data structures related to obsolete filesystem hooks
 *----------------------------------------------------------------
 */

typedef int (TclStatProc_) _ANSI_ARGS_((CONST char *path, struct stat *buf));
typedef int (TclAccessProc_) _ANSI_ARGS_((CONST char *path, int mode));
typedef Tcl_Channel (TclOpenFileChannelProc_) _ANSI_ARGS_((Tcl_Interp *interp,
	CONST char *fileName, CONST char *modeString,
	int permissions));


/*
 *----------------------------------------------------------------
 * Data structures related to procedures
 *----------------------------------------------------------------
 */

typedef Tcl_CmdProc *TclCmdProcType;
typedef Tcl_ObjCmdProc *TclObjCmdProcType;

/*
 *----------------------------------------------------------------
 * Variables shared among Tcl modules but not used by the outside world.
 *----------------------------------------------------------------
 */

extern Tcl_Time			tclBlockTime;
extern int			tclBlockTimeSet;
extern char *			tclExecutableName;
extern char *			tclNativeExecutableName;
extern char *			tclDefaultEncodingDir;
extern Tcl_ChannelType		tclFileChannelType;
extern char *			tclMemDumpFileName;
extern TclPlatformType		tclPlatform;
extern Tcl_NotifierProcs	tclOriginalNotifier;

/*
 * Variables denoting the Tcl object types defined in the core.
 */

extern Tcl_ObjType	tclBooleanType;
extern Tcl_ObjType	tclByteArrayType;
extern Tcl_ObjType	tclByteCodeType;
extern Tcl_ObjType	tclDoubleType;
extern Tcl_ObjType	tclEndOffsetType;
extern Tcl_ObjType	tclIntType;
extern Tcl_ObjType	tclListType;
extern Tcl_ObjType	tclProcBodyType;
extern Tcl_ObjType	tclStringType;
extern Tcl_ObjType	tclArraySearchType;
extern Tcl_ObjType	tclIndexType;
extern Tcl_ObjType	tclNsNameType;
extern Tcl_ObjType	tclWideIntType;

/*
 * Variables denoting the hash key types defined in the core.
 */

extern Tcl_HashKeyType tclArrayHashKeyType;
extern Tcl_HashKeyType tclOneWordHashKeyType;
extern Tcl_HashKeyType tclStringHashKeyType;
extern Tcl_HashKeyType tclObjHashKeyType;

/*
 * The head of the list of free Tcl objects, and the total number of Tcl
 * objects ever allocated and freed.
 */

extern Tcl_Obj *	tclFreeObjList;

#ifdef TCL_COMPILE_STATS
extern long		tclObjsAlloced;
extern long		tclObjsFreed;
#define TCL_MAX_SHARED_OBJ_STATS 5
extern long		tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
#endif /* TCL_COMPILE_STATS */

/*
 * Pointer to a heap-allocated string of length zero that the Tcl core uses
 * as the value of an empty string representation for an object. This value
 * is shared by all new objects allocated by Tcl_NewObj.
 */

extern char *		tclEmptyStringRep;
extern char		tclEmptyString;

/*
 *----------------------------------------------------------------
 * Procedures shared among Tcl modules but not used by the outside
 * world:
 *----------------------------------------------------------------
 */

#ifdef TCL_TIP280
EXTERN void             TclAdvanceLines _ANSI_ARGS_((int* line, CONST char* start,
						     CONST char* end));
EXTERN void             TclAdvanceContinuations _ANSI_ARGS_((int* line, int** next,
						     int loc));
EXTERN ContLineLoc*     TclContinuationsEnter _ANSI_ARGS_((Tcl_Obj* objPtr, int num,
							   int* loc));
EXTERN void             TclContinuationsEnterDerived _ANSI_ARGS_((Tcl_Obj* objPtr,
								  int start, int* clNext));
EXTERN ContLineLoc*     TclContinuationsGet _ANSI_ARGS_((Tcl_Obj* objPtr));

EXTERN void         TclContinuationsCopy _ANSI_ARGS_((Tcl_Obj* objPtr, Tcl_Obj* originObjPtr));

#endif
EXTERN int		TclArraySet _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj));
EXTERN int		TclCheckBadOctal _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *value));
EXTERN void		TclDeleteNamespaceVars _ANSI_ARGS_((Namespace *nsPtr));

#ifdef TCL_TIP280
EXTERN int              TclEvalObjEx _ANSI_ARGS_((Tcl_Interp *interp,
						  register Tcl_Obj *objPtr,
						  int flags,
						  CONST CmdFrame* invoker,
						  int word));

EXTERN void TclArgumentEnter   _ANSI_ARGS_((Tcl_Interp* interp,
					    Tcl_Obj* objv[], int objc, CmdFrame* cf));
EXTERN void TclArgumentRelease _ANSI_ARGS_((Tcl_Interp* interp,
					    Tcl_Obj* objv[], int objc));
EXTERN void TclArgumentBCEnter _ANSI_ARGS_((Tcl_Interp* interp,
					    Tcl_Obj* objv[], int objc,
					    void* codePtr, CmdFrame* cfPtr, int pc));
EXTERN void TclArgumentBCRelease _ANSI_ARGS_((Tcl_Interp* interp,
					      Tcl_Obj* objv[], int objc,
					      void* codePtr, int pc));

EXTERN void TclArgumentGet     _ANSI_ARGS_((Tcl_Interp* interp, Tcl_Obj* obj,
					    CmdFrame** cfPtrPtr, int* wordPtr));
#endif

EXTERN void		TclExpandTokenArray _ANSI_ARGS_((
			    Tcl_Parse *parsePtr));
EXTERN int		TclFileAttrsCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[]));
EXTERN int		TclFileCopyCmd _ANSI_ARGS_((Tcl_Interp *interp, 
			    int objc, Tcl_Obj *CONST objv[])) ;
EXTERN int		TclFileDeleteCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[]));
EXTERN int		TclFileMakeDirsCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[])) ;
EXTERN int		TclFileRenameCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[])) ;
EXTERN void		TclCreateLateExitHandler (Tcl_ExitProc * proc,
						   ClientData clientData);
EXTERN void		TclDeleteLateExitHandler (Tcl_ExitProc * proc,
						   ClientData clientData);
EXTERN void		TclFinalizeAllocSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeAsync _ANSI_ARGS_((void));
EXTERN void		TclFinalizeCompilation _ANSI_ARGS_((void));
EXTERN void		TclFinalizeEncodingSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeEnvironment _ANSI_ARGS_((void));
EXTERN void		TclFinalizeExecution _ANSI_ARGS_((void));
EXTERN void		TclFinalizeIOSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeFilesystem _ANSI_ARGS_((void));
EXTERN void		TclResetFilesystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeLoad _ANSI_ARGS_((void));
EXTERN void		TclFinalizeLock _ANSI_ARGS_((void));
EXTERN void		TclFinalizeMemorySubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeNotifier _ANSI_ARGS_((void));
EXTERN void		TclFinalizeObjects _ANSI_ARGS_((void));
EXTERN void		TclFinalizePreserve _ANSI_ARGS_((void));
EXTERN void		TclFinalizeSynchronization _ANSI_ARGS_((void));
EXTERN void		TclFinalizeThreadAlloc _ANSI_ARGS_((void));
EXTERN void		TclFinalizeThreadData _ANSI_ARGS_((void));
EXTERN int		TclGetEncodingFromObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, Tcl_Encoding *encodingPtr));
#ifdef TCL_TIP280
EXTERN void             TclGetSrcInfoForPc _ANSI_ARGS_((CmdFrame* cfPtr));
#endif
EXTERN int		TclGlob _ANSI_ARGS_((Tcl_Interp *interp,
			    char *pattern, Tcl_Obj *unquotedPrefix, 
			    int globFlags, Tcl_GlobTypeData* types));
EXTERN void		TclInitAlloc _ANSI_ARGS_((void));
EXTERN void		TclInitDbCkalloc _ANSI_ARGS_((void));
EXTERN void		TclInitEncodingSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitIOSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitNamespaceSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitNotifier _ANSI_ARGS_((void));
EXTERN void		TclInitObjSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitSubsystems _ANSI_ARGS_((CONST char *argv0));
EXTERN int		TclIsLocalScalar _ANSI_ARGS_((CONST char *src,
			    int len));
EXTERN int              TclJoinThread _ANSI_ARGS_((Tcl_ThreadId id,
			    int* result));
EXTERN Tcl_Obj *	TclLindexList _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   Tcl_Obj* argPtr ));
EXTERN Tcl_Obj *	TclLindexFlat _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   int indexCount,
						   Tcl_Obj *CONST indexArray[]
						   ));
EXTERN Tcl_Obj *	TclLsetList _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 Tcl_Obj* indexPtr,
						 Tcl_Obj* valuePtr  
						 ));
EXTERN Tcl_Obj *	TclLsetFlat _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 int indexCount,
						 Tcl_Obj *CONST indexArray[],
						 Tcl_Obj* valuePtr
						 ));
EXTERN int              TclParseBackslash _ANSI_ARGS_((CONST char *src,
                            int numBytes, int *readPtr, char *dst));
EXTERN int		TclParseHex _ANSI_ARGS_((CONST char *src, int numBytes,
                            Tcl_UniChar *resultPtr));
EXTERN int		TclParseInteger _ANSI_ARGS_((CONST char *string,
			    int numBytes));
EXTERN int		TclParseWhiteSpace _ANSI_ARGS_((CONST char *src,
			    int numBytes, Tcl_Parse *parsePtr, char *typePtr));
#ifdef TCL_TIP280
EXTERN int              TclWordKnownAtCompileTime _ANSI_ARGS_((Tcl_Token* token));
#endif
EXTERN int		TclpObjAccess _ANSI_ARGS_((Tcl_Obj *filename,
			    int mode));
EXTERN int              TclpObjLstat _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_StatBuf *buf));
EXTERN int		TclpCheckStackSpace _ANSI_ARGS_((void));
EXTERN Tcl_Obj*         TclpTempFileName _ANSI_ARGS_((void));
EXTERN Tcl_Obj*         TclNewFSPathObj _ANSI_ARGS_((Tcl_Obj *dirPtr, 
			    CONST char *addStrRep, int len));
EXTERN int              TclpDeleteFile _ANSI_ARGS_((CONST char *path));
EXTERN void		TclpFinalizeCondition _ANSI_ARGS_((
			    Tcl_Condition *condPtr));
EXTERN void		TclpFinalizeMutex _ANSI_ARGS_((Tcl_Mutex *mutexPtr));
EXTERN void		TclpFinalizePipes _ANSI_ARGS_((void));
EXTERN void		TclpFinalizeSockets _ANSI_ARGS_((void));
EXTERN void		TclpFinalizeThreadData _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpFinalizeThreadDataKey _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN char *		TclpFindExecutable _ANSI_ARGS_((
			    CONST char *argv0));
EXTERN int		TclpFindVariable _ANSI_ARGS_((CONST char *name,
			    int *lengthPtr));
EXTERN int		TclpInitLibraryPath _ANSI_ARGS_((CONST char *argv0));
EXTERN void		TclpInitLock _ANSI_ARGS_((void));
EXTERN void		TclpInitPlatform _ANSI_ARGS_((void));
EXTERN void		TclpInitUnlock _ANSI_ARGS_((void));
EXTERN int              TclpLoadFile _ANSI_ARGS_((Tcl_Interp *interp, 
				Tcl_Obj *pathPtr,
				CONST char *sym1, CONST char *sym2, 
				Tcl_PackageInitProc **proc1Ptr,
				Tcl_PackageInitProc **proc2Ptr, 
				ClientData *clientDataPtr,
				Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN Tcl_Obj*		TclpObjListVolumes _ANSI_ARGS_((void));
EXTERN void		TclpMasterLock _ANSI_ARGS_((void));
EXTERN void		TclpMasterUnlock _ANSI_ARGS_((void));
EXTERN int		TclpMatchFiles _ANSI_ARGS_((Tcl_Interp *interp,
			    char *separators, Tcl_DString *dirPtr,
			    char *pattern, char *tail));
EXTERN int              TclpObjNormalizePath _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, int nextCheckpoint));
EXTERN int		TclpObjCreateDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN void             TclpNativeJoinPath _ANSI_ARGS_((Tcl_Obj *prefix, 
							char *joining));
EXTERN Tcl_Obj*         TclpNativeSplitPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
							 int *lenPtr));
EXTERN Tcl_PathType     TclpGetNativePathType _ANSI_ARGS_((Tcl_Obj *pathObjPtr,
			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef));
EXTERN int 		TclCrossFilesystemCopy _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *source, Tcl_Obj *target));
EXTERN int		TclpObjDeleteFile _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN int		TclpObjCopyDirectory _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
EXTERN int		TclpObjCopyFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpObjRemoveDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				int recursive, Tcl_Obj **errorPtr));
EXTERN int		TclpObjRenameFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpMatchInDirectory _ANSI_ARGS_((Tcl_Interp *interp, 
			        Tcl_Obj *resultPtr, Tcl_Obj *pathPtr, 
				CONST char *pattern, Tcl_GlobTypeData *types));
EXTERN Tcl_Obj*		TclpObjGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN Tcl_FSDupInternalRepProc TclNativeDupInternalRep;
EXTERN Tcl_Obj*		TclpObjLink _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				Tcl_Obj *toPtr, int linkType));
EXTERN int		TclpObjChdir _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN Tcl_Obj*         TclFileDirname _ANSI_ARGS_((Tcl_Interp *interp, 
						    Tcl_Obj*pathPtr));
EXTERN int		TclpObjStat _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
EXTERN Tcl_Channel	TclpOpenFileChannel _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *pathPtr, int mode,
			    int permissions));
EXTERN void		TclpPanic _ANSI_ARGS_(TCL_VARARGS(CONST char *,
			    format));
EXTERN char *		TclpReadlink _ANSI_ARGS_((CONST char *fileName,
			    Tcl_DString *linkPtr));
EXTERN void		TclpReleaseFile _ANSI_ARGS_((TclFile file));
EXTERN void		TclpSetVariables _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN void		TclpUnloadFile _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
EXTERN VOID *		TclpThreadDataKeyGet _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpThreadDataKeyInit _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpThreadDataKeySet _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr, VOID *data));
EXTERN int		TclpThreadCreate _ANSI_ARGS_((
			    Tcl_ThreadId *idPtr,
			    Tcl_ThreadCreateProc proc,
			    ClientData clientData,
			    int stackSize, int flags));
EXTERN void		TclpThreadExit _ANSI_ARGS_((int status));
EXTERN void		TclRememberCondition _ANSI_ARGS_((Tcl_Condition *mutex));
EXTERN void		TclRememberDataKey _ANSI_ARGS_((Tcl_ThreadDataKey *mutex));
EXTERN VOID             TclRememberJoinableThread _ANSI_ARGS_((Tcl_ThreadId id));
EXTERN void		TclRememberMutex _ANSI_ARGS_((Tcl_Mutex *mutex));
EXTERN VOID             TclSignalExitThread _ANSI_ARGS_((Tcl_ThreadId id,
			     int result));
EXTERN void		TclTransferResult _ANSI_ARGS_((Tcl_Interp *sourceInterp,
			    int result, Tcl_Interp *targetInterp));
EXTERN Tcl_Obj*         TclpNativeToNormalized 
                            _ANSI_ARGS_((ClientData clientData));
EXTERN Tcl_Obj*	        TclpFilesystemPathType
					_ANSI_ARGS_((Tcl_Obj* pathObjPtr));
EXTERN Tcl_PackageInitProc* TclpFindSymbol _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_LoadHandle loadHandle, CONST char *symbol));
EXTERN int              TclpDlopen _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, 
	                    Tcl_LoadHandle *loadHandle, 
		            Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN int              TclpUtime _ANSI_ARGS_((Tcl_Obj *pathPtr,
					       struct utimbuf *tval));

#ifdef TCL_LOAD_FROM_MEMORY
EXTERN void*	        TclpLoadMemoryGetBuffer _ANSI_ARGS_((
			    Tcl_Interp *interp, int size));
EXTERN int	        TclpLoadMemory _ANSI_ARGS_((Tcl_Interp *interp, 
			    void *buffer, int size, int codeSize, 
			    Tcl_LoadHandle *loadHandle, 
			    Tcl_FSUnloadFileProc **unloadProcPtr));
#endif

/*
 *----------------------------------------------------------------
 * Command procedures in the generic core:
 *----------------------------------------------------------------
 */

EXTERN int	Tcl_AfterObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_AppendObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ArrayObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BinaryObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BreakObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CaseObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CatchObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CdObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ClockObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CloseObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ConcatObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ContinueObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EncodingObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EofObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ErrorObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EvalObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ExecObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ExitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ExprObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FblockedObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FconfigureObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FcopyObjCmd _ANSI_ARGS_((ClientData dummy,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FileObjCmd _ANSI_ARGS_((ClientData dummy,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FileEventObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FlushObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ForObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ForeachObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FormatObjCmd _ANSI_ARGS_((ClientData dummy,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_GetsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_GlobalObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_GlobObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_IfObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_IncrObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_InfoObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_InterpObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_JoinObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LappendObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LindexObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LinsertObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LlengthObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ListObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LoadObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LrangeObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LreplaceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LsearchObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LsetObjCmd _ANSI_ARGS_((ClientData clientData,
                    Tcl_Interp* interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LsortObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_NamespaceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_OpenObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PackageObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PidObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PutsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PwdObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ReadObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RegexpObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RegsubObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RenameObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ReturnObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ScanObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SeekObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SetObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SplitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SocketObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SourceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_StringObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SubstObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SwitchObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_TellObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_TimeObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_TraceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UnsetObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UpdateObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UplevelObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UpvarObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_VariableObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_VwaitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_WhileObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));

/*
 *----------------------------------------------------------------
 * Command procedures found only in the Mac version of the core:
 *----------------------------------------------------------------
 */

#ifdef MAC_TCL
EXTERN int	Tcl_EchoCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, CONST84 char **argv));
EXTERN int	Tcl_LsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BeepObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_MacSourceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ResourceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
#endif

/*
 *----------------------------------------------------------------
 * Compilation procedures for commands in the generic core:
 *----------------------------------------------------------------
 */

EXTERN int	TclCompileAppendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileBreakCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileCatchCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileContinueCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileExprCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileForCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileForeachCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileIfCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileIncrCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLappendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLindexCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileListCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLlengthCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLsetCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileRegexpCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileReturnCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileSetCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileStringCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileWhileCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));

/*
 * Functions defined in generic/tclVar.c and currenttly exported only 
 * for use by the bytecode compiler and engine. Some of these could later 
 * be placed in the public interface.
 */

EXTERN Var *	TclLookupArrayElement _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *arrayName, CONST char *elName, CONST int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var *arrayPtr));	
EXTERN Var *    TclObjLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var **arrayPtrPtr));
EXTERN Tcl_Obj *TclPtrGetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST int flags));
EXTERN Tcl_Obj *TclPtrSetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    Tcl_Obj *newValuePtr, CONST int flags));
EXTERN Tcl_Obj *TclPtrIncrVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST long i, CONST int flags));

/*
 *----------------------------------------------------------------
 * Macros used by the Tcl core to create and release Tcl objects.
 * TclNewObj(objPtr) creates a new object denoting an empty string.
 * TclDecrRefCount(objPtr) decrements the object's reference count,
 * and frees the object if its reference count is zero.
 * These macros are inline versions of Tcl_NewObj() and
 * Tcl_DecrRefCount(). Notice that the names differ in not having
 * a "_" after the "Tcl". Notice also that these macros reference
 * their argument more than once, so you should avoid calling them
 * with an expression that is expensive to compute or has
 * side effects. The ANSI C "prototypes" for these macros are:
 *
 * EXTERN void	TclNewObj _ANSI_ARGS_((Tcl_Obj *objPtr));
 * EXTERN void	TclDecrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));
 *
 * These macros are defined in terms of two macros that depend on 
 * memory allocator in use: TclAllocObjStorage, TclFreeObjStorage.
 * They are defined below.
 *----------------------------------------------------------------
 */

/*
 * DTrace object allocation probe macros.
 */

#ifdef USE_DTRACE
#include "tclDTrace.h"
#define	TCL_DTRACE_OBJ_CREATE(objPtr)	TCL_OBJ_CREATE(objPtr)
#define	TCL_DTRACE_OBJ_FREE(objPtr)	TCL_OBJ_FREE(objPtr)
#else /* USE_DTRACE */
#define	TCL_DTRACE_OBJ_CREATE(objPtr)	{}
#define	TCL_DTRACE_OBJ_FREE(objPtr)	{}
#endif /* USE_DTRACE */

#ifdef TCL_COMPILE_STATS
#  define TclIncrObjsAllocated() \
    tclObjsAlloced++
#  define TclIncrObjsFreed() \
    tclObjsFreed++
#else
#  define TclIncrObjsAllocated()
#  define TclIncrObjsFreed()
#endif /* TCL_COMPILE_STATS */

#define TclNewObj(objPtr) \
    TclAllocObjStorage(objPtr); \
    TclIncrObjsAllocated(); \
    (objPtr)->refCount = 0; \
    (objPtr)->bytes    = tclEmptyStringRep; \
    (objPtr)->length   = 0; \
    (objPtr)->typePtr  = NULL; \
    TCL_DTRACE_OBJ_CREATE(objPtr)


#ifdef TCL_MEM_DEBUG
#   define TclDecrRefCount(objPtr) \
	Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
#else
#   define TclDecrRefCount(objPtr) \
    if (--(objPtr)->refCount <= 0) { \
	TCL_DTRACE_OBJ_FREE(objPtr); \
	if (((objPtr)->typePtr != NULL) \
		&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
	} \
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
        TclFreeObjStorage(objPtr); \
	TclIncrObjsFreed(); \
    }
#endif

#ifdef TCL_MEM_DEBUG
#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) \
           Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__)

#  define TclFreeObjStorage(objPtr) \
       if ((objPtr)->refCount < -1) { \
           panic("Reference count for %lx was negative: %s line %d", \
	           (objPtr), __FILE__, __LINE__); \
       } \
       ckfree((char *) (objPtr))
     
#  define TclDbNewObj(objPtr, file, line) \
       (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
       (objPtr)->refCount = 0; \
       (objPtr)->bytes    = tclEmptyStringRep; \
       (objPtr)->length   = 0; \
       (objPtr)->typePtr  = NULL; \
       TclIncrObjsAllocated(); \
       TCL_DTRACE_OBJ_CREATE(objPtr)

     
#elif defined(PURIFY)

/*
 * The PURIFY mode is like the regular mode, but instead of doing block
 * Tcl_Obj allocation and keeping a freed list for efficiency, it always
 * allocates and frees a single Tcl_Obj so that tools like Purify can
 * better track memory leaks
 */

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) Tcl_Ckalloc(sizeof(Tcl_Obj))

#  define TclFreeObjStorage(objPtr) \
       ckfree((char *) (objPtr))

#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)

/*
 * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's
 * from per-thread caches.
 */

EXTERN Tcl_Obj *TclThreadAllocObj _ANSI_ARGS_((void));
EXTERN void TclThreadFreeObj _ANSI_ARGS_((Tcl_Obj *));
EXTERN void TclFreeAllocCache _ANSI_ARGS_((void *));
EXTERN void TclpFreeAllocMutex _ANSI_ARGS_((Tcl_Mutex* mutex));
EXTERN void TclpFreeAllocCache _ANSI_ARGS_((void *));


#  define TclAllocObjStorage(objPtr) \
       (objPtr) = TclThreadAllocObj()

#  define TclFreeObjStorage(objPtr) \
       TclThreadFreeObj((objPtr))

#else /* not TCL_MEM_DEBUG */

#ifdef TCL_THREADS
/* declared in tclObj.c */
extern Tcl_Mutex tclObjMutex;
#endif

#  define TclAllocObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       if (tclFreeObjList == NULL) { \
	   TclAllocateFreeObjects(); \
       } \
       (objPtr) = tclFreeObjList; \
       tclFreeObjList = (Tcl_Obj *) \
	   tclFreeObjList->internalRep.otherValuePtr; \
       Tcl_MutexUnlock(&tclObjMutex)

#  define TclFreeObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
       tclFreeObjList = (objPtr); \
       Tcl_MutexUnlock(&tclObjMutex)

#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to set a Tcl_Obj's string representation
 * to a copy of the "len" bytes starting at "bytePtr". This code
 * works even if the byte array contains NULLs as long as the length
 * is correct. Because "len" is referenced multiple times, it should
 * be as simple an expression as possible. The ANSI C "prototype" for
 * this macro is:
 *
 * EXTERN void	TclInitStringRep _ANSI_ARGS_((Tcl_Obj *objPtr,
 *		    char *bytePtr, int len));
 *----------------------------------------------------------------
 */

#define TclInitStringRep(objPtr, bytePtr, len) \
    if ((len) == 0) { \
	(objPtr)->bytes	 = tclEmptyStringRep; \
	(objPtr)->length = 0; \
    } else { \
	(objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \
	memcpy((VOID *) (objPtr)->bytes, (VOID *) (bytePtr), \
		(unsigned) (len)); \
	(objPtr)->bytes[len] = '\0'; \
	(objPtr)->length = (len); \
    }

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to get the string representation's
 * byte array pointer from a Tcl_Obj. This is an inline version
 * of Tcl_GetString(). The macro's expression result is the string
 * rep's byte pointer which might be NULL. The bytes referenced by 
 * this pointer must not be modified by the caller.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN char *  TclGetString _ANSI_ARGS_((Tcl_Obj *objPtr));
 *----------------------------------------------------------------
 */

#define TclGetString(objPtr) \
    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString((objPtr)))

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to get a Tcl_WideInt value out of
 * a Tcl_Obj of the "wideInt" type.  Different implementation on
 * different platforms depending whether TCL_WIDE_INT_IS_LONG.
 *----------------------------------------------------------------
 */

#ifdef TCL_WIDE_INT_IS_LONG
#    define TclGetWide(resultVar, objPtr) \
	(resultVar) = (objPtr)->internalRep.longValue
#    define TclGetLongFromWide(resultVar, objPtr) \
	(resultVar) = (objPtr)->internalRep.longValue
#else
#    define TclGetWide(resultVar, objPtr) \
	(resultVar) = (objPtr)->internalRep.wideValue
#    define TclGetLongFromWide(resultVar, objPtr) \
	(resultVar) = Tcl_WideAsLong((objPtr)->internalRep.wideValue)
#endif

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core get a unicode char from a utf string.
 * It checks to see if we have a one-byte utf char before calling
 * the real Tcl_UtfToUniChar, as this will save a lot of time for
 * primarily ascii string handling. The macro's expression result
 * is 1 for the 1-byte case or the result of Tcl_UtfToUniChar.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUtfToUniChar _ANSI_ARGS_((CONST char *string,
 *					   Tcl_UniChar *ch));
 *----------------------------------------------------------------
 */

#define TclUtfToUniChar(str, chPtr) \
	((((unsigned char) *(str)) < 0xC0) ? \
	    ((*(chPtr) = (Tcl_UniChar) *(str)), 1) \
	    : Tcl_UtfToUniChar(str, chPtr))

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to compare Unicode strings.  On
 * big-endian systems we can use the more efficient memcmp, but
 * this would not be lexically correct on little-endian systems.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar *cs,
 *         CONST Tcl_UniChar *ct, unsigned long n));
 *----------------------------------------------------------------
 */
#ifdef WORDS_BIGENDIAN
#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
#else /* !WORDS_BIGENDIAN */
#   define TclUniCharNcmp Tcl_UniCharNcmp
#endif /* WORDS_BIGENDIAN */

#include "tclIntDecls.h"

# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TCLINT */

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
                                              tclIntDecls.h                                                                                       0100644 0001750 0001750 00000145102 11001731473 035302  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclIntDecls.h --
 *
 *	This file contains the declarations for all unsupported
 *	functions that are exported by the Tcl library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclIntDecls.h,v 1.49.2.9 2007/04/21 19:52:14 kennykb Exp $
 */

#ifndef _TCLINTDECLS
#define _TCLINTDECLS

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tclInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

/* Slot 0 is reserved */
/* 1 */
EXTERN int		TclAccessDeleteProc _ANSI_ARGS_((
				TclAccessProc_ * proc));
/* 2 */
EXTERN int		TclAccessInsertProc _ANSI_ARGS_((
				TclAccessProc_ * proc));
/* 3 */
EXTERN void		TclAllocateFreeObjects _ANSI_ARGS_((void));
/* Slot 4 is reserved */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 5 */
EXTERN int		TclCleanupChildren _ANSI_ARGS_((Tcl_Interp * interp, 
				int numPids, Tcl_Pid * pidPtr, 
				Tcl_Channel errorChan));
#endif /* UNIX */
#ifdef __WIN32__
/* 5 */
EXTERN int		TclCleanupChildren _ANSI_ARGS_((Tcl_Interp * interp, 
				int numPids, Tcl_Pid * pidPtr, 
				Tcl_Channel errorChan));
#endif /* __WIN32__ */
/* 6 */
EXTERN void		TclCleanupCommand _ANSI_ARGS_((Command * cmdPtr));
/* 7 */
EXTERN int		TclCopyAndCollapse _ANSI_ARGS_((int count, 
				CONST char * src, char * dst));
/* 8 */
EXTERN int		TclCopyChannel _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel inChan, Tcl_Channel outChan, 
				int toRead, Tcl_Obj * cmdPtr));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 9 */
EXTERN int		TclCreatePipeline _ANSI_ARGS_((Tcl_Interp * interp, 
				int argc, CONST char ** argv, 
				Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, 
				TclFile * outPipePtr, TclFile * errFilePtr));
#endif /* UNIX */
#ifdef __WIN32__
/* 9 */
EXTERN int		TclCreatePipeline _ANSI_ARGS_((Tcl_Interp * interp, 
				int argc, CONST char ** argv, 
				Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, 
				TclFile * outPipePtr, TclFile * errFilePtr));
#endif /* __WIN32__ */
/* 10 */
EXTERN int		TclCreateProc _ANSI_ARGS_((Tcl_Interp * interp, 
				Namespace * nsPtr, CONST char * procName, 
				Tcl_Obj * argsPtr, Tcl_Obj * bodyPtr, 
				Proc ** procPtrPtr));
/* 11 */
EXTERN void		TclDeleteCompiledLocalVars _ANSI_ARGS_((
				Interp * iPtr, CallFrame * framePtr));
/* 12 */
EXTERN void		TclDeleteVars _ANSI_ARGS_((Interp * iPtr, 
				Tcl_HashTable * tablePtr));
/* 13 */
EXTERN int		TclDoGlob _ANSI_ARGS_((Tcl_Interp * interp, 
				char * separators, Tcl_DString * headPtr, 
				char * tail, Tcl_GlobTypeData * types));
/* 14 */
EXTERN void		TclDumpMemoryInfo _ANSI_ARGS_((FILE * outFile));
/* Slot 15 is reserved */
/* 16 */
EXTERN void		TclExprFloatError _ANSI_ARGS_((Tcl_Interp * interp, 
				double value));
/* Slot 17 is reserved */
/* Slot 18 is reserved */
/* Slot 19 is reserved */
/* Slot 20 is reserved */
/* Slot 21 is reserved */
/* 22 */
EXTERN int		TclFindElement _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * listStr, int listLength, 
				CONST char ** elementPtr, 
				CONST char ** nextPtr, int * sizePtr, 
				int * bracePtr));
/* 23 */
EXTERN Proc *		TclFindProc _ANSI_ARGS_((Interp * iPtr, 
				CONST char * procName));
/* 24 */
EXTERN int		TclFormatInt _ANSI_ARGS_((char * buffer, long n));
/* 25 */
EXTERN void		TclFreePackageInfo _ANSI_ARGS_((Interp * iPtr));
/* Slot 26 is reserved */
/* 27 */
EXTERN int		TclGetDate _ANSI_ARGS_((char * p, Tcl_WideInt now, 
				long zone, Tcl_WideInt * timePtr));
/* 28 */
EXTERN Tcl_Channel	TclpGetDefaultStdChannel _ANSI_ARGS_((int type));
/* Slot 29 is reserved */
/* Slot 30 is reserved */
/* 31 */
EXTERN char *		TclGetExtension _ANSI_ARGS_((char * name));
/* 32 */
EXTERN int		TclGetFrame _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, CallFrame ** framePtrPtr));
/* 33 */
EXTERN TclCmdProcType	TclGetInterpProc _ANSI_ARGS_((void));
/* 34 */
EXTERN int		TclGetIntForIndex _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, int endValue, 
				int * indexPtr));
/* Slot 35 is reserved */
/* 36 */
EXTERN int		TclGetLong _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, long * longPtr));
/* 37 */
EXTERN int		TclGetLoadedPackages _ANSI_ARGS_((
				Tcl_Interp * interp, char * targetName));
/* 38 */
EXTERN int		TclGetNamespaceForQualName _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * qualName, 
				Namespace * cxtNsPtr, int flags, 
				Namespace ** nsPtrPtr, 
				Namespace ** altNsPtrPtr, 
				Namespace ** actualCxtPtrPtr, 
				CONST char ** simpleNamePtr));
/* 39 */
EXTERN TclObjCmdProcType TclGetObjInterpProc _ANSI_ARGS_((void));
/* 40 */
EXTERN int		TclGetOpenMode _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int * seekFlagPtr));
/* 41 */
EXTERN Tcl_Command	TclGetOriginalCommand _ANSI_ARGS_((
				Tcl_Command command));
/* 42 */
EXTERN char *		TclpGetUserHome _ANSI_ARGS_((CONST char * name, 
				Tcl_DString * bufferPtr));
/* 43 */
EXTERN int		TclGlobalInvoke _ANSI_ARGS_((Tcl_Interp * interp, 
				int argc, CONST84 char ** argv, int flags));
/* 44 */
EXTERN int		TclGuessPackageName _ANSI_ARGS_((
				CONST char * fileName, Tcl_DString * bufPtr));
/* 45 */
EXTERN int		TclHideUnsafeCommands _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 46 */
EXTERN int		TclInExit _ANSI_ARGS_((void));
/* Slot 47 is reserved */
/* Slot 48 is reserved */
/* 49 */
EXTERN Tcl_Obj *	TclIncrVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * part1Ptr, Tcl_Obj * part2Ptr, 
				long incrAmount, int part1NotParsed));
/* 50 */
EXTERN void		TclInitCompiledLocals _ANSI_ARGS_((
				Tcl_Interp * interp, CallFrame * framePtr, 
				Namespace * nsPtr));
/* 51 */
EXTERN int		TclInterpInit _ANSI_ARGS_((Tcl_Interp * interp));
/* 52 */
EXTERN int		TclInvoke _ANSI_ARGS_((Tcl_Interp * interp, int argc, 
				CONST84 char ** argv, int flags));
/* 53 */
EXTERN int		TclInvokeObjectCommand _ANSI_ARGS_((
				ClientData clientData, Tcl_Interp * interp, 
				int argc, CONST84 char ** argv));
/* 54 */
EXTERN int		TclInvokeStringCommand _ANSI_ARGS_((
				ClientData clientData, Tcl_Interp * interp, 
				int objc, Tcl_Obj *CONST objv[]));
/* 55 */
EXTERN Proc *		TclIsProc _ANSI_ARGS_((Command * cmdPtr));
/* Slot 56 is reserved */
/* Slot 57 is reserved */
/* 58 */
EXTERN Var *		TclLookupVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags, CONST char * msg, int createPart1, 
				int createPart2, Var ** arrayPtrPtr));
/* Slot 59 is reserved */
/* 60 */
EXTERN int		TclNeedSpace _ANSI_ARGS_((CONST char * start, 
				CONST char * end));
/* 61 */
EXTERN Tcl_Obj *	TclNewProcBodyObj _ANSI_ARGS_((Proc * procPtr));
/* 62 */
EXTERN int		TclObjCommandComplete _ANSI_ARGS_((Tcl_Obj * cmdPtr));
/* 63 */
EXTERN int		TclObjInterpProc _ANSI_ARGS_((ClientData clientData, 
				Tcl_Interp * interp, int objc, 
				Tcl_Obj *CONST objv[]));
/* 64 */
EXTERN int		TclObjInvoke _ANSI_ARGS_((Tcl_Interp * interp, 
				int objc, Tcl_Obj *CONST objv[], int flags));
/* 65 */
EXTERN int		TclObjInvokeGlobal _ANSI_ARGS_((Tcl_Interp * interp, 
				int objc, Tcl_Obj *CONST objv[], int flags));
/* 66 */
EXTERN int		TclOpenFileChannelDeleteProc _ANSI_ARGS_((
				TclOpenFileChannelProc_ * proc));
/* 67 */
EXTERN int		TclOpenFileChannelInsertProc _ANSI_ARGS_((
				TclOpenFileChannelProc_ * proc));
/* Slot 68 is reserved */
/* 69 */
EXTERN char *		TclpAlloc _ANSI_ARGS_((unsigned int size));
/* Slot 70 is reserved */
/* Slot 71 is reserved */
/* Slot 72 is reserved */
/* Slot 73 is reserved */
/* 74 */
EXTERN void		TclpFree _ANSI_ARGS_((char * ptr));
/* 75 */
EXTERN unsigned long	TclpGetClicks _ANSI_ARGS_((void));
/* 76 */
EXTERN unsigned long	TclpGetSeconds _ANSI_ARGS_((void));
/* 77 */
EXTERN void		TclpGetTime _ANSI_ARGS_((Tcl_Time * time));
/* 78 */
EXTERN int		TclpGetTimeZone _ANSI_ARGS_((Tcl_WideInt time));
/* Slot 79 is reserved */
/* Slot 80 is reserved */
/* 81 */
EXTERN char *		TclpRealloc _ANSI_ARGS_((char * ptr, 
				unsigned int size));
/* Slot 82 is reserved */
/* Slot 83 is reserved */
/* Slot 84 is reserved */
/* Slot 85 is reserved */
/* Slot 86 is reserved */
/* Slot 87 is reserved */
/* 88 */
EXTERN char *		TclPrecTraceProc _ANSI_ARGS_((ClientData clientData, 
				Tcl_Interp * interp, CONST char * name1, 
				CONST char * name2, int flags));
/* 89 */
EXTERN int		TclPreventAliasLoop _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Interp * cmdInterp, Tcl_Command cmd));
/* Slot 90 is reserved */
/* 91 */
EXTERN void		TclProcCleanupProc _ANSI_ARGS_((Proc * procPtr));
/* 92 */
EXTERN int		TclProcCompileProc _ANSI_ARGS_((Tcl_Interp * interp, 
				Proc * procPtr, Tcl_Obj * bodyPtr, 
				Namespace * nsPtr, CONST char * description, 
				CONST char * procName));
/* 93 */
EXTERN void		TclProcDeleteProc _ANSI_ARGS_((ClientData clientData));
/* 94 */
EXTERN int		TclProcInterpProc _ANSI_ARGS_((ClientData clientData, 
				Tcl_Interp * interp, int argc, 
				CONST84 char ** argv));
/* Slot 95 is reserved */
/* 96 */
EXTERN int		TclRenameCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				char * oldName, char * newName));
/* 97 */
EXTERN void		TclResetShadowedCmdRefs _ANSI_ARGS_((
				Tcl_Interp * interp, Command * newCmdPtr));
/* 98 */
EXTERN int		TclServiceIdle _ANSI_ARGS_((void));
/* Slot 99 is reserved */
/* Slot 100 is reserved */
/* 101 */
EXTERN char *		TclSetPreInitScript _ANSI_ARGS_((char * string));
/* 102 */
EXTERN void		TclSetupEnv _ANSI_ARGS_((Tcl_Interp * interp));
/* 103 */
EXTERN int		TclSockGetPort _ANSI_ARGS_((Tcl_Interp * interp, 
				char * str, char * proto, int * portPtr));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 104 */
EXTERN int		TclSockMinimumBuffers _ANSI_ARGS_((int sock, 
				int size));
#endif /* UNIX */
#ifdef __WIN32__
/* 104 */
EXTERN int		TclSockMinimumBuffers _ANSI_ARGS_((int sock, 
				int size));
#endif /* __WIN32__ */
/* Slot 105 is reserved */
/* 106 */
EXTERN int		TclStatDeleteProc _ANSI_ARGS_((TclStatProc_ * proc));
/* 107 */
EXTERN int		TclStatInsertProc _ANSI_ARGS_((TclStatProc_ * proc));
/* 108 */
EXTERN void		TclTeardownNamespace _ANSI_ARGS_((Namespace * nsPtr));
/* 109 */
EXTERN int		TclUpdateReturnInfo _ANSI_ARGS_((Interp * iPtr));
/* Slot 110 is reserved */
/* 111 */
EXTERN void		Tcl_AddInterpResolvers _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				Tcl_ResolveCmdProc * cmdProc, 
				Tcl_ResolveVarProc * varProc, 
				Tcl_ResolveCompiledVarProc * compiledVarProc));
/* 112 */
EXTERN int		Tcl_AppendExportList _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Namespace * nsPtr, 
				Tcl_Obj * objPtr));
/* 113 */
EXTERN Tcl_Namespace *	Tcl_CreateNamespace _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, ClientData clientData, 
				Tcl_NamespaceDeleteProc * deleteProc));
/* 114 */
EXTERN void		Tcl_DeleteNamespace _ANSI_ARGS_((
				Tcl_Namespace * nsPtr));
/* 115 */
EXTERN int		Tcl_Export _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Namespace * nsPtr, CONST char * pattern, 
				int resetListFirst));
/* 116 */
EXTERN Tcl_Command	Tcl_FindCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, 
				Tcl_Namespace * contextNsPtr, int flags));
/* 117 */
EXTERN Tcl_Namespace *	Tcl_FindNamespace _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, 
				Tcl_Namespace * contextNsPtr, int flags));
/* 118 */
EXTERN int		Tcl_GetInterpResolvers _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				Tcl_ResolverInfo * resInfo));
/* 119 */
EXTERN int		Tcl_GetNamespaceResolvers _ANSI_ARGS_((
				Tcl_Namespace * namespacePtr, 
				Tcl_ResolverInfo * resInfo));
/* 120 */
EXTERN Tcl_Var		Tcl_FindNamespaceVar _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				Tcl_Namespace * contextNsPtr, int flags));
/* 121 */
EXTERN int		Tcl_ForgetImport _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Namespace * nsPtr, CONST char * pattern));
/* 122 */
EXTERN Tcl_Command	Tcl_GetCommandFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr));
/* 123 */
EXTERN void		Tcl_GetCommandFullName _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Command command, 
				Tcl_Obj * objPtr));
/* 124 */
EXTERN Tcl_Namespace *	Tcl_GetCurrentNamespace _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 125 */
EXTERN Tcl_Namespace *	Tcl_GetGlobalNamespace _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 126 */
EXTERN void		Tcl_GetVariableFullName _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Var variable, 
				Tcl_Obj * objPtr));
/* 127 */
EXTERN int		Tcl_Import _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Namespace * nsPtr, CONST char * pattern, 
				int allowOverwrite));
/* 128 */
EXTERN void		Tcl_PopCallFrame _ANSI_ARGS_((Tcl_Interp* interp));
/* 129 */
EXTERN int		Tcl_PushCallFrame _ANSI_ARGS_((Tcl_Interp* interp, 
				Tcl_CallFrame * framePtr, 
				Tcl_Namespace * nsPtr, int isProcCallFrame));
/* 130 */
EXTERN int		Tcl_RemoveInterpResolvers _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name));
/* 131 */
EXTERN void		Tcl_SetNamespaceResolvers _ANSI_ARGS_((
				Tcl_Namespace * namespacePtr, 
				Tcl_ResolveCmdProc * cmdProc, 
				Tcl_ResolveVarProc * varProc, 
				Tcl_ResolveCompiledVarProc * compiledVarProc));
/* 132 */
EXTERN int		TclpHasSockets _ANSI_ARGS_((Tcl_Interp * interp));
/* 133 */
EXTERN struct tm *	TclpGetDate _ANSI_ARGS_((TclpTime_t time, int useGMT));
/* 134 */
EXTERN size_t		TclpStrftime _ANSI_ARGS_((char * s, size_t maxsize, 
				CONST char * format, CONST struct tm * t, 
				int useGMT));
/* 135 */
EXTERN int		TclpCheckStackSpace _ANSI_ARGS_((void));
/* Slot 136 is reserved */
/* Slot 137 is reserved */
/* 138 */
EXTERN CONST84_RETURN char * TclGetEnv _ANSI_ARGS_((CONST char * name, 
				Tcl_DString * valuePtr));
/* Slot 139 is reserved */
/* 140 */
EXTERN int		TclLooksLikeInt _ANSI_ARGS_((CONST char * bytes, 
				int length));
/* 141 */
EXTERN CONST84_RETURN char * TclpGetCwd _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_DString * cwdPtr));
/* 142 */
EXTERN int		TclSetByteCodeFromAny _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr, 
				CompileHookProc * hookProc, 
				ClientData clientData));
/* 143 */
EXTERN int		TclAddLiteralObj _ANSI_ARGS_((
				struct CompileEnv * envPtr, Tcl_Obj * objPtr, 
				LiteralEntry ** litPtrPtr));
/* 144 */
EXTERN void		TclHideLiteral _ANSI_ARGS_((Tcl_Interp * interp, 
				struct CompileEnv * envPtr, int index));
/* 145 */
EXTERN struct AuxDataType * TclGetAuxDataType _ANSI_ARGS_((char * typeName));
/* 146 */
EXTERN TclHandle	TclHandleCreate _ANSI_ARGS_((VOID * ptr));
/* 147 */
EXTERN void		TclHandleFree _ANSI_ARGS_((TclHandle handle));
/* 148 */
EXTERN TclHandle	TclHandlePreserve _ANSI_ARGS_((TclHandle handle));
/* 149 */
EXTERN void		TclHandleRelease _ANSI_ARGS_((TclHandle handle));
/* 150 */
EXTERN int		TclRegAbout _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_RegExp re));
/* 151 */
EXTERN void		TclRegExpRangeUniChar _ANSI_ARGS_((Tcl_RegExp re, 
				int index, int * startPtr, int * endPtr));
/* 152 */
EXTERN void		TclSetLibraryPath _ANSI_ARGS_((Tcl_Obj * pathPtr));
/* 153 */
EXTERN Tcl_Obj *	TclGetLibraryPath _ANSI_ARGS_((void));
/* Slot 154 is reserved */
/* Slot 155 is reserved */
/* 156 */
EXTERN void		TclRegError _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * msg, int status));
/* 157 */
EXTERN Var *		TclVarTraceExists _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName));
/* 158 */
EXTERN void		TclSetStartupScriptFileName _ANSI_ARGS_((
				CONST char * filename));
/* 159 */
EXTERN CONST84_RETURN char * TclGetStartupScriptFileName _ANSI_ARGS_((void));
/* Slot 160 is reserved */
/* 161 */
EXTERN int		TclChannelTransform _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel chan, Tcl_Obj * cmdObjPtr));
/* 162 */
EXTERN void		TclChannelEventScriptInvoker _ANSI_ARGS_((
				ClientData clientData, int flags));
/* 163 */
EXTERN void *		TclGetInstructionTable _ANSI_ARGS_((void));
/* 164 */
EXTERN void		TclExpandCodeArray _ANSI_ARGS_((void * envPtr));
/* 165 */
EXTERN void		TclpSetInitialEncodings _ANSI_ARGS_((void));
/* 166 */
EXTERN int		TclListObjSetElement _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * listPtr, 
				int index, Tcl_Obj * valuePtr));
/* 167 */
EXTERN void		TclSetStartupScriptPath _ANSI_ARGS_((
				Tcl_Obj * pathPtr));
/* 168 */
EXTERN Tcl_Obj *	TclGetStartupScriptPath _ANSI_ARGS_((void));
/* 169 */
EXTERN int		TclpUtfNcmp2 _ANSI_ARGS_((CONST char * s1, 
				CONST char * s2, unsigned long n));
/* 170 */
EXTERN int		TclCheckInterpTraces _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * command, 
				int numChars, Command * cmdPtr, int result, 
				int traceFlags, int objc, 
				Tcl_Obj *CONST objv[]));
/* 171 */
EXTERN int		TclCheckExecutionTraces _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * command, 
				int numChars, Command * cmdPtr, int result, 
				int traceFlags, int objc, 
				Tcl_Obj *CONST objv[]));
/* 172 */
EXTERN int		TclInThreadExit _ANSI_ARGS_((void));
/* 173 */
EXTERN int		TclUniCharMatch _ANSI_ARGS_((
				CONST Tcl_UniChar * string, int strLen, 
				CONST Tcl_UniChar * pattern, int ptnLen, 
				int nocase));
/* Slot 174 is reserved */
/* Slot 175 is reserved */
/* Slot 176 is reserved */
/* Slot 177 is reserved */
/* Slot 178 is reserved */
/* Slot 179 is reserved */
/* Slot 180 is reserved */
/* Slot 181 is reserved */
/* 182 */
EXTERN struct tm *	TclpLocaltime _ANSI_ARGS_((TclpTime_t_CONST clock));
/* 183 */
EXTERN struct tm *	TclpGmtime _ANSI_ARGS_((TclpTime_t_CONST clock));
/* Slot 184 is reserved */
/* Slot 185 is reserved */
/* Slot 186 is reserved */
/* Slot 187 is reserved */
/* Slot 188 is reserved */
/* Slot 189 is reserved */
/* Slot 190 is reserved */
/* Slot 191 is reserved */
/* Slot 192 is reserved */
/* Slot 193 is reserved */
/* Slot 194 is reserved */
/* Slot 195 is reserved */
/* Slot 196 is reserved */
/* Slot 197 is reserved */
/* Slot 198 is reserved */
/* 199 */
EXTERN int		TclMatchIsTrivial _ANSI_ARGS_((CONST char * pattern));

typedef struct TclIntStubs {
    int magic;
    struct TclIntStubHooks *hooks;

    void *reserved0;
    int (*tclAccessDeleteProc) _ANSI_ARGS_((TclAccessProc_ * proc)); /* 1 */
    int (*tclAccessInsertProc) _ANSI_ARGS_((TclAccessProc_ * proc)); /* 2 */
    void (*tclAllocateFreeObjects) _ANSI_ARGS_((void)); /* 3 */
    void *reserved4;
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    int (*tclCleanupChildren) _ANSI_ARGS_((Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan)); /* 5 */
#endif /* UNIX */
#ifdef __WIN32__
    int (*tclCleanupChildren) _ANSI_ARGS_((Tcl_Interp * interp, int numPids, Tcl_Pid * pidPtr, Tcl_Channel errorChan)); /* 5 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved5;
#endif /* MAC_TCL */
    void (*tclCleanupCommand) _ANSI_ARGS_((Command * cmdPtr)); /* 6 */
    int (*tclCopyAndCollapse) _ANSI_ARGS_((int count, CONST char * src, char * dst)); /* 7 */
    int (*tclCopyChannel) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj * cmdPtr)); /* 8 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    int (*tclCreatePipeline) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr)); /* 9 */
#endif /* UNIX */
#ifdef __WIN32__
    int (*tclCreatePipeline) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST char ** argv, Tcl_Pid ** pidArrayPtr, TclFile * inPipePtr, TclFile * outPipePtr, TclFile * errFilePtr)); /* 9 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved9;
#endif /* MAC_TCL */
    int (*tclCreateProc) _ANSI_ARGS_((Tcl_Interp * interp, Namespace * nsPtr, CONST char * procName, Tcl_Obj * argsPtr, Tcl_Obj * bodyPtr, Proc ** procPtrPtr)); /* 10 */
    void (*tclDeleteCompiledLocalVars) _ANSI_ARGS_((Interp * iPtr, CallFrame * framePtr)); /* 11 */
    void (*tclDeleteVars) _ANSI_ARGS_((Interp * iPtr, Tcl_HashTable * tablePtr)); /* 12 */
    int (*tclDoGlob) _ANSI_ARGS_((Tcl_Interp * interp, char * separators, Tcl_DString * headPtr, char * tail, Tcl_GlobTypeData * types)); /* 13 */
    void (*tclDumpMemoryInfo) _ANSI_ARGS_((FILE * outFile)); /* 14 */
    void *reserved15;
    void (*tclExprFloatError) _ANSI_ARGS_((Tcl_Interp * interp, double value)); /* 16 */
    void *reserved17;
    void *reserved18;
    void *reserved19;
    void *reserved20;
    void *reserved21;
    int (*tclFindElement) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * listStr, int listLength, CONST char ** elementPtr, CONST char ** nextPtr, int * sizePtr, int * bracePtr)); /* 22 */
    Proc * (*tclFindProc) _ANSI_ARGS_((Interp * iPtr, CONST char * procName)); /* 23 */
    int (*tclFormatInt) _ANSI_ARGS_((char * buffer, long n)); /* 24 */
    void (*tclFreePackageInfo) _ANSI_ARGS_((Interp * iPtr)); /* 25 */
    void *reserved26;
    int (*tclGetDate) _ANSI_ARGS_((char * p, Tcl_WideInt now, long zone, Tcl_WideInt * timePtr)); /* 27 */
    Tcl_Channel (*tclpGetDefaultStdChannel) _ANSI_ARGS_((int type)); /* 28 */
    void *reserved29;
    void *reserved30;
    char * (*tclGetExtension) _ANSI_ARGS_((char * name)); /* 31 */
    int (*tclGetFrame) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, CallFrame ** framePtrPtr)); /* 32 */
    TclCmdProcType (*tclGetInterpProc) _ANSI_ARGS_((void)); /* 33 */
    int (*tclGetIntForIndex) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, int endValue, int * indexPtr)); /* 34 */
    void *reserved35;
    int (*tclGetLong) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, long * longPtr)); /* 36 */
    int (*tclGetLoadedPackages) _ANSI_ARGS_((Tcl_Interp * interp, char * targetName)); /* 37 */
    int (*tclGetNamespaceForQualName) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * qualName, Namespace * cxtNsPtr, int flags, Namespace ** nsPtrPtr, Namespace ** altNsPtrPtr, Namespace ** actualCxtPtrPtr, CONST char ** simpleNamePtr)); /* 38 */
    TclObjCmdProcType (*tclGetObjInterpProc) _ANSI_ARGS_((void)); /* 39 */
    int (*tclGetOpenMode) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int * seekFlagPtr)); /* 40 */
    Tcl_Command (*tclGetOriginalCommand) _ANSI_ARGS_((Tcl_Command command)); /* 41 */
    char * (*tclpGetUserHome) _ANSI_ARGS_((CONST char * name, Tcl_DString * bufferPtr)); /* 42 */
    int (*tclGlobalInvoke) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST84 char ** argv, int flags)); /* 43 */
    int (*tclGuessPackageName) _ANSI_ARGS_((CONST char * fileName, Tcl_DString * bufPtr)); /* 44 */
    int (*tclHideUnsafeCommands) _ANSI_ARGS_((Tcl_Interp * interp)); /* 45 */
    int (*tclInExit) _ANSI_ARGS_((void)); /* 46 */
    void *reserved47;
    void *reserved48;
    Tcl_Obj * (*tclIncrVar2) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * part1Ptr, Tcl_Obj * part2Ptr, long incrAmount, int part1NotParsed)); /* 49 */
    void (*tclInitCompiledLocals) _ANSI_ARGS_((Tcl_Interp * interp, CallFrame * framePtr, Namespace * nsPtr)); /* 50 */
    int (*tclInterpInit) _ANSI_ARGS_((Tcl_Interp * interp)); /* 51 */
    int (*tclInvoke) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST84 char ** argv, int flags)); /* 52 */
    int (*tclInvokeObjectCommand) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int argc, CONST84 char ** argv)); /* 53 */
    int (*tclInvokeStringCommand) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 54 */
    Proc * (*tclIsProc) _ANSI_ARGS_((Command * cmdPtr)); /* 55 */
    void *reserved56;
    void *reserved57;
    Var * (*tclLookupVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags, CONST char * msg, int createPart1, int createPart2, Var ** arrayPtrPtr)); /* 58 */
    void *reserved59;
    int (*tclNeedSpace) _ANSI_ARGS_((CONST char * start, CONST char * end)); /* 60 */
    Tcl_Obj * (*tclNewProcBodyObj) _ANSI_ARGS_((Proc * procPtr)); /* 61 */
    int (*tclObjCommandComplete) _ANSI_ARGS_((Tcl_Obj * cmdPtr)); /* 62 */
    int (*tclObjInterpProc) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 63 */
    int (*tclObjInvoke) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], int flags)); /* 64 */
    int (*tclObjInvokeGlobal) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], int flags)); /* 65 */
    int (*tclOpenFileChannelDeleteProc) _ANSI_ARGS_((TclOpenFileChannelProc_ * proc)); /* 66 */
    int (*tclOpenFileChannelInsertProc) _ANSI_ARGS_((TclOpenFileChannelProc_ * proc)); /* 67 */
    void *reserved68;
    char * (*tclpAlloc) _ANSI_ARGS_((unsigned int size)); /* 69 */
    void *reserved70;
    void *reserved71;
    void *reserved72;
    void *reserved73;
    void (*tclpFree) _ANSI_ARGS_((char * ptr)); /* 74 */
    unsigned long (*tclpGetClicks) _ANSI_ARGS_((void)); /* 75 */
    unsigned long (*tclpGetSeconds) _ANSI_ARGS_((void)); /* 76 */
    void (*tclpGetTime) _ANSI_ARGS_((Tcl_Time * time)); /* 77 */
    int (*tclpGetTimeZone) _ANSI_ARGS_((Tcl_WideInt time)); /* 78 */
    void *reserved79;
    void *reserved80;
    char * (*tclpRealloc) _ANSI_ARGS_((char * ptr, unsigned int size)); /* 81 */
    void *reserved82;
    void *reserved83;
    void *reserved84;
    void *reserved85;
    void *reserved86;
    void *reserved87;
    char * (*tclPrecTraceProc) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, CONST char * name1, CONST char * name2, int flags)); /* 88 */
    int (*tclPreventAliasLoop) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Interp * cmdInterp, Tcl_Command cmd)); /* 89 */
    void *reserved90;
    void (*tclProcCleanupProc) _ANSI_ARGS_((Proc * procPtr)); /* 91 */
    int (*tclProcCompileProc) _ANSI_ARGS_((Tcl_Interp * interp, Proc * procPtr, Tcl_Obj * bodyPtr, Namespace * nsPtr, CONST char * description, CONST char * procName)); /* 92 */
    void (*tclProcDeleteProc) _ANSI_ARGS_((ClientData clientData)); /* 93 */
    int (*tclProcInterpProc) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int argc, CONST84 char ** argv)); /* 94 */
    void *reserved95;
    int (*tclRenameCommand) _ANSI_ARGS_((Tcl_Interp * interp, char * oldName, char * newName)); /* 96 */
    void (*tclResetShadowedCmdRefs) _ANSI_ARGS_((Tcl_Interp * interp, Command * newCmdPtr)); /* 97 */
    int (*tclServiceIdle) _ANSI_ARGS_((void)); /* 98 */
    void *reserved99;
    void *reserved100;
    char * (*tclSetPreInitScript) _ANSI_ARGS_((char * string)); /* 101 */
    void (*tclSetupEnv) _ANSI_ARGS_((Tcl_Interp * interp)); /* 102 */
    int (*tclSockGetPort) _ANSI_ARGS_((Tcl_Interp * interp, char * str, char * proto, int * portPtr)); /* 103 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    int (*tclSockMinimumBuffers) _ANSI_ARGS_((int sock, int size)); /* 104 */
#endif /* UNIX */
#ifdef __WIN32__
    int (*tclSockMinimumBuffers) _ANSI_ARGS_((int sock, int size)); /* 104 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved104;
#endif /* MAC_TCL */
    void *reserved105;
    int (*tclStatDeleteProc) _ANSI_ARGS_((TclStatProc_ * proc)); /* 106 */
    int (*tclStatInsertProc) _ANSI_ARGS_((TclStatProc_ * proc)); /* 107 */
    void (*tclTeardownNamespace) _ANSI_ARGS_((Namespace * nsPtr)); /* 108 */
    int (*tclUpdateReturnInfo) _ANSI_ARGS_((Interp * iPtr)); /* 109 */
    void *reserved110;
    void (*tcl_AddInterpResolvers) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_ResolveCmdProc * cmdProc, Tcl_ResolveVarProc * varProc, Tcl_ResolveCompiledVarProc * compiledVarProc)); /* 111 */
    int (*tcl_AppendExportList) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Namespace * nsPtr, Tcl_Obj * objPtr)); /* 112 */
    Tcl_Namespace * (*tcl_CreateNamespace) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, ClientData clientData, Tcl_NamespaceDeleteProc * deleteProc)); /* 113 */
    void (*tcl_DeleteNamespace) _ANSI_ARGS_((Tcl_Namespace * nsPtr)); /* 114 */
    int (*tcl_Export) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern, int resetListFirst)); /* 115 */
    Tcl_Command (*tcl_FindCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags)); /* 116 */
    Tcl_Namespace * (*tcl_FindNamespace) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags)); /* 117 */
    int (*tcl_GetInterpResolvers) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_ResolverInfo * resInfo)); /* 118 */
    int (*tcl_GetNamespaceResolvers) _ANSI_ARGS_((Tcl_Namespace * namespacePtr, Tcl_ResolverInfo * resInfo)); /* 119 */
    Tcl_Var (*tcl_FindNamespaceVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_Namespace * contextNsPtr, int flags)); /* 120 */
    int (*tcl_ForgetImport) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern)); /* 121 */
    Tcl_Command (*tcl_GetCommandFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr)); /* 122 */
    void (*tcl_GetCommandFullName) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Command command, Tcl_Obj * objPtr)); /* 123 */
    Tcl_Namespace * (*tcl_GetCurrentNamespace) _ANSI_ARGS_((Tcl_Interp * interp)); /* 124 */
    Tcl_Namespace * (*tcl_GetGlobalNamespace) _ANSI_ARGS_((Tcl_Interp * interp)); /* 125 */
    void (*tcl_GetVariableFullName) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Var variable, Tcl_Obj * objPtr)); /* 126 */
    int (*tcl_Import) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Namespace * nsPtr, CONST char * pattern, int allowOverwrite)); /* 127 */
    void (*tcl_PopCallFrame) _ANSI_ARGS_((Tcl_Interp* interp)); /* 128 */
    int (*tcl_PushCallFrame) _ANSI_ARGS_((Tcl_Interp* interp, Tcl_CallFrame * framePtr, Tcl_Namespace * nsPtr, int isProcCallFrame)); /* 129 */
    int (*tcl_RemoveInterpResolvers) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name)); /* 130 */
    void (*tcl_SetNamespaceResolvers) _ANSI_ARGS_((Tcl_Namespace * namespacePtr, Tcl_ResolveCmdProc * cmdProc, Tcl_ResolveVarProc * varProc, Tcl_ResolveCompiledVarProc * compiledVarProc)); /* 131 */
    int (*tclpHasSockets) _ANSI_ARGS_((Tcl_Interp * interp)); /* 132 */
    struct tm * (*tclpGetDate) _ANSI_ARGS_((TclpTime_t time, int useGMT)); /* 133 */
    size_t (*tclpStrftime) _ANSI_ARGS_((char * s, size_t maxsize, CONST char * format, CONST struct tm * t, int useGMT)); /* 134 */
    int (*tclpCheckStackSpace) _ANSI_ARGS_((void)); /* 135 */
    void *reserved136;
    void *reserved137;
    CONST84_RETURN char * (*tclGetEnv) _ANSI_ARGS_((CONST char * name, Tcl_DString * valuePtr)); /* 138 */
    void *reserved139;
    int (*tclLooksLikeInt) _ANSI_ARGS_((CONST char * bytes, int length)); /* 140 */
    CONST84_RETURN char * (*tclpGetCwd) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_DString * cwdPtr)); /* 141 */
    int (*tclSetByteCodeFromAny) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, CompileHookProc * hookProc, ClientData clientData)); /* 142 */
    int (*tclAddLiteralObj) _ANSI_ARGS_((struct CompileEnv * envPtr, Tcl_Obj * objPtr, LiteralEntry ** litPtrPtr)); /* 143 */
    void (*tclHideLiteral) _ANSI_ARGS_((Tcl_Interp * interp, struct CompileEnv * envPtr, int index)); /* 144 */
    struct AuxDataType * (*tclGetAuxDataType) _ANSI_ARGS_((char * typeName)); /* 145 */
    TclHandle (*tclHandleCreate) _ANSI_ARGS_((VOID * ptr)); /* 146 */
    void (*tclHandleFree) _ANSI_ARGS_((TclHandle handle)); /* 147 */
    TclHandle (*tclHandlePreserve) _ANSI_ARGS_((TclHandle handle)); /* 148 */
    void (*tclHandleRelease) _ANSI_ARGS_((TclHandle handle)); /* 149 */
    int (*tclRegAbout) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_RegExp re)); /* 150 */
    void (*tclRegExpRangeUniChar) _ANSI_ARGS_((Tcl_RegExp re, int index, int * startPtr, int * endPtr)); /* 151 */
    void (*tclSetLibraryPath) _ANSI_ARGS_((Tcl_Obj * pathPtr)); /* 152 */
    Tcl_Obj * (*tclGetLibraryPath) _ANSI_ARGS_((void)); /* 153 */
    void *reserved154;
    void *reserved155;
    void (*tclRegError) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * msg, int status)); /* 156 */
    Var * (*tclVarTraceExists) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName)); /* 157 */
    void (*tclSetStartupScriptFileName) _ANSI_ARGS_((CONST char * filename)); /* 158 */
    CONST84_RETURN char * (*tclGetStartupScriptFileName) _ANSI_ARGS_((void)); /* 159 */
    void *reserved160;
    int (*tclChannelTransform) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan, Tcl_Obj * cmdObjPtr)); /* 161 */
    void (*tclChannelEventScriptInvoker) _ANSI_ARGS_((ClientData clientData, int flags)); /* 162 */
    void * (*tclGetInstructionTable) _ANSI_ARGS_((void)); /* 163 */
    void (*tclExpandCodeArray) _ANSI_ARGS_((void * envPtr)); /* 164 */
    void (*tclpSetInitialEncodings) _ANSI_ARGS_((void)); /* 165 */
    int (*tclListObjSetElement) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, int index, Tcl_Obj * valuePtr)); /* 166 */
    void (*tclSetStartupScriptPath) _ANSI_ARGS_((Tcl_Obj * pathPtr)); /* 167 */
    Tcl_Obj * (*tclGetStartupScriptPath) _ANSI_ARGS_((void)); /* 168 */
    int (*tclpUtfNcmp2) _ANSI_ARGS_((CONST char * s1, CONST char * s2, unsigned long n)); /* 169 */
    int (*tclCheckInterpTraces) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * command, int numChars, Command * cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *CONST objv[])); /* 170 */
    int (*tclCheckExecutionTraces) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * command, int numChars, Command * cmdPtr, int result, int traceFlags, int objc, Tcl_Obj *CONST objv[])); /* 171 */
    int (*tclInThreadExit) _ANSI_ARGS_((void)); /* 172 */
    int (*tclUniCharMatch) _ANSI_ARGS_((CONST Tcl_UniChar * string, int strLen, CONST Tcl_UniChar * pattern, int ptnLen, int nocase)); /* 173 */
    void *reserved174;
    void *reserved175;
    void *reserved176;
    void *reserved177;
    void *reserved178;
    void *reserved179;
    void *reserved180;
    void *reserved181;
    struct tm * (*tclpLocaltime) _ANSI_ARGS_((TclpTime_t_CONST clock)); /* 182 */
    struct tm * (*tclpGmtime) _ANSI_ARGS_((TclpTime_t_CONST clock)); /* 183 */
    void *reserved184;
    void *reserved185;
    void *reserved186;
    void *reserved187;
    void *reserved188;
    void *reserved189;
    void *reserved190;
    void *reserved191;
    void *reserved192;
    void *reserved193;
    void *reserved194;
    void *reserved195;
    void *reserved196;
    void *reserved197;
    void *reserved198;
    int (*tclMatchIsTrivial) _ANSI_ARGS_((CONST char * pattern)); /* 199 */
} TclIntStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TclIntStubs *tclIntStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)

/*
 * Inline function declarations:
 */

/* Slot 0 is reserved */
#ifndef TclAccessDeleteProc
#define TclAccessDeleteProc \
	(tclIntStubsPtr->tclAccessDeleteProc) /* 1 */
#endif
#ifndef TclAccessInsertProc
#define TclAccessInsertProc \
	(tclIntStubsPtr->tclAccessInsertProc) /* 2 */
#endif
#ifndef TclAllocateFreeObjects
#define TclAllocateFreeObjects \
	(tclIntStubsPtr->tclAllocateFreeObjects) /* 3 */
#endif
/* Slot 4 is reserved */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
#ifndef TclCleanupChildren
#define TclCleanupChildren \
	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
#endif
#endif /* UNIX */
#ifdef __WIN32__
#ifndef TclCleanupChildren
#define TclCleanupChildren \
	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
#endif
#endif /* __WIN32__ */
#ifndef TclCleanupCommand
#define TclCleanupCommand \
	(tclIntStubsPtr->tclCleanupCommand) /* 6 */
#endif
#ifndef TclCopyAndCollapse
#define TclCopyAndCollapse \
	(tclIntStubsPtr->tclCopyAndCollapse) /* 7 */
#endif
#ifndef TclCopyChannel
#define TclCopyChannel \
	(tclIntStubsPtr->tclCopyChannel) /* 8 */
#endif
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
#ifndef TclCreatePipeline
#define TclCreatePipeline \
	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
#endif
#endif /* UNIX */
#ifdef __WIN32__
#ifndef TclCreatePipeline
#define TclCreatePipeline \
	(tclIntStubsPtr->tclCreatePipeline) /* 9 */
#endif
#endif /* __WIN32__ */
#ifndef TclCreateProc
#define TclCreateProc \
	(tclIntStubsPtr->tclCreateProc) /* 10 */
#endif
#ifndef TclDeleteCompiledLocalVars
#define TclDeleteCompiledLocalVars \
	(tclIntStubsPtr->tclDeleteCompiledLocalVars) /* 11 */
#endif
#ifndef TclDeleteVars
#define TclDeleteVars \
	(tclIntStubsPtr->tclDeleteVars) /* 12 */
#endif
#ifndef TclDoGlob
#define TclDoGlob \
	(tclIntStubsPtr->tclDoGlob) /* 13 */
#endif
#ifndef TclDumpMemoryInfo
#define TclDumpMemoryInfo \
	(tclIntStubsPtr->tclDumpMemoryInfo) /* 14 */
#endif
/* Slot 15 is reserved */
#ifndef TclExprFloatError
#define TclExprFloatError \
	(tclIntStubsPtr->tclExprFloatError) /* 16 */
#endif
/* Slot 17 is reserved */
/* Slot 18 is reserved */
/* Slot 19 is reserved */
/* Slot 20 is reserved */
/* Slot 21 is reserved */
#ifndef TclFindElement
#define TclFindElement \
	(tclIntStubsPtr->tclFindElement) /* 22 */
#endif
#ifndef TclFindProc
#define TclFindProc \
	(tclIntStubsPtr->tclFindProc) /* 23 */
#endif
#ifndef TclFormatInt
#define TclFormatInt \
	(tclIntStubsPtr->tclFormatInt) /* 24 */
#endif
#ifndef TclFreePackageInfo
#define TclFreePackageInfo \
	(tclIntStubsPtr->tclFreePackageInfo) /* 25 */
#endif
/* Slot 26 is reserved */
#ifndef TclGetDate
#define TclGetDate \
	(tclIntStubsPtr->tclGetDate) /* 27 */
#endif
#ifndef TclpGetDefaultStdChannel
#define TclpGetDefaultStdChannel \
	(tclIntStubsPtr->tclpGetDefaultStdChannel) /* 28 */
#endif
/* Slot 29 is reserved */
/* Slot 30 is reserved */
#ifndef TclGetExtension
#define TclGetExtension \
	(tclIntStubsPtr->tclGetExtension) /* 31 */
#endif
#ifndef TclGetFrame
#define TclGetFrame \
	(tclIntStubsPtr->tclGetFrame) /* 32 */
#endif
#ifndef TclGetInterpProc
#define TclGetInterpProc \
	(tclIntStubsPtr->tclGetInterpProc) /* 33 */
#endif
#ifndef TclGetIntForIndex
#define TclGetIntForIndex \
	(tclIntStubsPtr->tclGetIntForIndex) /* 34 */
#endif
/* Slot 35 is reserved */
#ifndef TclGetLong
#define TclGetLong \
	(tclIntStubsPtr->tclGetLong) /* 36 */
#endif
#ifndef TclGetLoadedPackages
#define TclGetLoadedPackages \
	(tclIntStubsPtr->tclGetLoadedPackages) /* 37 */
#endif
#ifndef TclGetNamespaceForQualName
#define TclGetNamespaceForQualName \
	(tclIntStubsPtr->tclGetNamespaceForQualName) /* 38 */
#endif
#ifndef TclGetObjInterpProc
#define TclGetObjInterpProc \
	(tclIntStubsPtr->tclGetObjInterpProc) /* 39 */
#endif
#ifndef TclGetOpenMode
#define TclGetOpenMode \
	(tclIntStubsPtr->tclGetOpenMode) /* 40 */
#endif
#ifndef TclGetOriginalCommand
#define TclGetOriginalCommand \
	(tclIntStubsPtr->tclGetOriginalCommand) /* 41 */
#endif
#ifndef TclpGetUserHome
#define TclpGetUserHome \
	(tclIntStubsPtr->tclpGetUserHome) /* 42 */
#endif
#ifndef TclGlobalInvoke
#define TclGlobalInvoke \
	(tclIntStubsPtr->tclGlobalInvoke) /* 43 */
#endif
#ifndef TclGuessPackageName
#define TclGuessPackageName \
	(tclIntStubsPtr->tclGuessPackageName) /* 44 */
#endif
#ifndef TclHideUnsafeCommands
#define TclHideUnsafeCommands \
	(tclIntStubsPtr->tclHideUnsafeCommands) /* 45 */
#endif
#ifndef TclInExit
#define TclInExit \
	(tclIntStubsPtr->tclInExit) /* 46 */
#endif
/* Slot 47 is reserved */
/* Slot 48 is reserved */
#ifndef TclIncrVar2
#define TclIncrVar2 \
	(tclIntStubsPtr->tclIncrVar2) /* 49 */
#endif
#ifndef TclInitCompiledLocals
#define TclInitCompiledLocals \
	(tclIntStubsPtr->tclInitCompiledLocals) /* 50 */
#endif
#ifndef TclInterpInit
#define TclInterpInit \
	(tclIntStubsPtr->tclInterpInit) /* 51 */
#endif
#ifndef TclInvoke
#define TclInvoke \
	(tclIntStubsPtr->tclInvoke) /* 52 */
#endif
#ifndef TclInvokeObjectCommand
#define TclInvokeObjectCommand \
	(tclIntStubsPtr->tclInvokeObjectCommand) /* 53 */
#endif
#ifndef TclInvokeStringCommand
#define TclInvokeStringCommand \
	(tclIntStubsPtr->tclInvokeStringCommand) /* 54 */
#endif
#ifndef TclIsProc
#define TclIsProc \
	(tclIntStubsPtr->tclIsProc) /* 55 */
#endif
/* Slot 56 is reserved */
/* Slot 57 is reserved */
#ifndef TclLookupVar
#define TclLookupVar \
	(tclIntStubsPtr->tclLookupVar) /* 58 */
#endif
/* Slot 59 is reserved */
#ifndef TclNeedSpace
#define TclNeedSpace \
	(tclIntStubsPtr->tclNeedSpace) /* 60 */
#endif
#ifndef TclNewProcBodyObj
#define TclNewProcBodyObj \
	(tclIntStubsPtr->tclNewProcBodyObj) /* 61 */
#endif
#ifndef TclObjCommandComplete
#define TclObjCommandComplete \
	(tclIntStubsPtr->tclObjCommandComplete) /* 62 */
#endif
#ifndef TclObjInterpProc
#define TclObjInterpProc \
	(tclIntStubsPtr->tclObjInterpProc) /* 63 */
#endif
#ifndef TclObjInvoke
#define TclObjInvoke \
	(tclIntStubsPtr->tclObjInvoke) /* 64 */
#endif
#ifndef TclObjInvokeGlobal
#define TclObjInvokeGlobal \
	(tclIntStubsPtr->tclObjInvokeGlobal) /* 65 */
#endif
#ifndef TclOpenFileChannelDeleteProc
#define TclOpenFileChannelDeleteProc \
	(tclIntStubsPtr->tclOpenFileChannelDeleteProc) /* 66 */
#endif
#ifndef TclOpenFileChannelInsertProc
#define TclOpenFileChannelInsertProc \
	(tclIntStubsPtr->tclOpenFileChannelInsertProc) /* 67 */
#endif
/* Slot 68 is reserved */
#ifndef TclpAlloc
#define TclpAlloc \
	(tclIntStubsPtr->tclpAlloc) /* 69 */
#endif
/* Slot 70 is reserved */
/* Slot 71 is reserved */
/* Slot 72 is reserved */
/* Slot 73 is reserved */
#ifndef TclpFree
#define TclpFree \
	(tclIntStubsPtr->tclpFree) /* 74 */
#endif
#ifndef TclpGetClicks
#define TclpGetClicks \
	(tclIntStubsPtr->tclpGetClicks) /* 75 */
#endif
#ifndef TclpGetSeconds
#define TclpGetSeconds \
	(tclIntStubsPtr->tclpGetSeconds) /* 76 */
#endif
#ifndef TclpGetTime
#define TclpGetTime \
	(tclIntStubsPtr->tclpGetTime) /* 77 */
#endif
#ifndef TclpGetTimeZone
#define TclpGetTimeZone \
	(tclIntStubsPtr->tclpGetTimeZone) /* 78 */
#endif
/* Slot 79 is reserved */
/* Slot 80 is reserved */
#ifndef TclpRealloc
#define TclpRealloc \
	(tclIntStubsPtr->tclpRealloc) /* 81 */
#endif
/* Slot 82 is reserved */
/* Slot 83 is reserved */
/* Slot 84 is reserved */
/* Slot 85 is reserved */
/* Slot 86 is reserved */
/* Slot 87 is reserved */
#ifndef TclPrecTraceProc
#define TclPrecTraceProc \
	(tclIntStubsPtr->tclPrecTraceProc) /* 88 */
#endif
#ifndef TclPreventAliasLoop
#define TclPreventAliasLoop \
	(tclIntStubsPtr->tclPreventAliasLoop) /* 89 */
#endif
/* Slot 90 is reserved */
#ifndef TclProcCleanupProc
#define TclProcCleanupProc \
	(tclIntStubsPtr->tclProcCleanupProc) /* 91 */
#endif
#ifndef TclProcCompileProc
#define TclProcCompileProc \
	(tclIntStubsPtr->tclProcCompileProc) /* 92 */
#endif
#ifndef TclProcDeleteProc
#define TclProcDeleteProc \
	(tclIntStubsPtr->tclProcDeleteProc) /* 93 */
#endif
#ifndef TclProcInterpProc
#define TclProcInterpProc \
	(tclIntStubsPtr->tclProcInterpProc) /* 94 */
#endif
/* Slot 95 is reserved */
#ifndef TclRenameCommand
#define TclRenameCommand \
	(tclIntStubsPtr->tclRenameCommand) /* 96 */
#endif
#ifndef TclResetShadowedCmdRefs
#define TclResetShadowedCmdRefs \
	(tclIntStubsPtr->tclResetShadowedCmdRefs) /* 97 */
#endif
#ifndef TclServiceIdle
#define TclServiceIdle \
	(tclIntStubsPtr->tclServiceIdle) /* 98 */
#endif
/* Slot 99 is reserved */
/* Slot 100 is reserved */
#ifndef TclSetPreInitScript
#define TclSetPreInitScript \
	(tclIntStubsPtr->tclSetPreInitScript) /* 101 */
#endif
#ifndef TclSetupEnv
#define TclSetupEnv \
	(tclIntStubsPtr->tclSetupEnv) /* 102 */
#endif
#ifndef TclSockGetPort
#define TclSockGetPort \
	(tclIntStubsPtr->tclSockGetPort) /* 103 */
#endif
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
#ifndef TclSockMinimumBuffers
#define TclSockMinimumBuffers \
	(tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
#endif
#endif /* UNIX */
#ifdef __WIN32__
#ifndef TclSockMinimumBuffers
#define TclSockMinimumBuffers \
	(tclIntStubsPtr->tclSockMinimumBuffers) /* 104 */
#endif
#endif /* __WIN32__ */
/* Slot 105 is reserved */
#ifndef TclStatDeleteProc
#define TclStatDeleteProc \
	(tclIntStubsPtr->tclStatDeleteProc) /* 106 */
#endif
#ifndef TclStatInsertProc
#define TclStatInsertProc \
	(tclIntStubsPtr->tclStatInsertProc) /* 107 */
#endif
#ifndef TclTeardownNamespace
#define TclTeardownNamespace \
	(tclIntStubsPtr->tclTeardownNamespace) /* 108 */
#endif
#ifndef TclUpdateReturnInfo
#define TclUpdateReturnInfo \
	(tclIntStubsPtr->tclUpdateReturnInfo) /* 109 */
#endif
/* Slot 110 is reserved */
#ifndef Tcl_AddInterpResolvers
#define Tcl_AddInterpResolvers \
	(tclIntStubsPtr->tcl_AddInterpResolvers) /* 111 */
#endif
#ifndef Tcl_AppendExportList
#define Tcl_AppendExportList \
	(tclIntStubsPtr->tcl_AppendExportList) /* 112 */
#endif
#ifndef Tcl_CreateNamespace
#define Tcl_CreateNamespace \
	(tclIntStubsPtr->tcl_CreateNamespace) /* 113 */
#endif
#ifndef Tcl_DeleteNamespace
#define Tcl_DeleteNamespace \
	(tclIntStubsPtr->tcl_DeleteNamespace) /* 114 */
#endif
#ifndef Tcl_Export
#define Tcl_Export \
	(tclIntStubsPtr->tcl_Export) /* 115 */
#endif
#ifndef Tcl_FindCommand
#define Tcl_FindCommand \
	(tclIntStubsPtr->tcl_FindCommand) /* 116 */
#endif
#ifndef Tcl_FindNamespace
#define Tcl_FindNamespace \
	(tclIntStubsPtr->tcl_FindNamespace) /* 117 */
#endif
#ifndef Tcl_GetInterpResolvers
#define Tcl_GetInterpResolvers \
	(tclIntStubsPtr->tcl_GetInterpResolvers) /* 118 */
#endif
#ifndef Tcl_GetNamespaceResolvers
#define Tcl_GetNamespaceResolvers \
	(tclIntStubsPtr->tcl_GetNamespaceResolvers) /* 119 */
#endif
#ifndef Tcl_FindNamespaceVar
#define Tcl_FindNamespaceVar \
	(tclIntStubsPtr->tcl_FindNamespaceVar) /* 120 */
#endif
#ifndef Tcl_ForgetImport
#define Tcl_ForgetImport \
	(tclIntStubsPtr->tcl_ForgetImport) /* 121 */
#endif
#ifndef Tcl_GetCommandFromObj
#define Tcl_GetCommandFromObj \
	(tclIntStubsPtr->tcl_GetCommandFromObj) /* 122 */
#endif
#ifndef Tcl_GetCommandFullName
#define Tcl_GetCommandFullName \
	(tclIntStubsPtr->tcl_GetCommandFullName) /* 123 */
#endif
#ifndef Tcl_GetCurrentNamespace
#define Tcl_GetCurrentNamespace \
	(tclIntStubsPtr->tcl_GetCurrentNamespace) /* 124 */
#endif
#ifndef Tcl_GetGlobalNamespace
#define Tcl_GetGlobalNamespace \
	(tclIntStubsPtr->tcl_GetGlobalNamespace) /* 125 */
#endif
#ifndef Tcl_GetVariableFullName
#define Tcl_GetVariableFullName \
	(tclIntStubsPtr->tcl_GetVariableFullName) /* 126 */
#endif
#ifndef Tcl_Import
#define Tcl_Import \
	(tclIntStubsPtr->tcl_Import) /* 127 */
#endif
#ifndef Tcl_PopCallFrame
#define Tcl_PopCallFrame \
	(tclIntStubsPtr->tcl_PopCallFrame) /* 128 */
#endif
#ifndef Tcl_PushCallFrame
#define Tcl_PushCallFrame \
	(tclIntStubsPtr->tcl_PushCallFrame) /* 129 */
#endif
#ifndef Tcl_RemoveInterpResolvers
#define Tcl_RemoveInterpResolvers \
	(tclIntStubsPtr->tcl_RemoveInterpResolvers) /* 130 */
#endif
#ifndef Tcl_SetNamespaceResolvers
#define Tcl_SetNamespaceResolvers \
	(tclIntStubsPtr->tcl_SetNamespaceResolvers) /* 131 */
#endif
#ifndef TclpHasSockets
#define TclpHasSockets \
	(tclIntStubsPtr->tclpHasSockets) /* 132 */
#endif
#ifndef TclpGetDate
#define TclpGetDate \
	(tclIntStubsPtr->tclpGetDate) /* 133 */
#endif
#ifndef TclpStrftime
#define TclpStrftime \
	(tclIntStubsPtr->tclpStrftime) /* 134 */
#endif
#ifndef TclpCheckStackSpace
#define TclpCheckStackSpace \
	(tclIntStubsPtr->tclpCheckStackSpace) /* 135 */
#endif
/* Slot 136 is reserved */
/* Slot 137 is reserved */
#ifndef TclGetEnv
#define TclGetEnv \
	(tclIntStubsPtr->tclGetEnv) /* 138 */
#endif
/* Slot 139 is reserved */
#ifndef TclLooksLikeInt
#define TclLooksLikeInt \
	(tclIntStubsPtr->tclLooksLikeInt) /* 140 */
#endif
#ifndef TclpGetCwd
#define TclpGetCwd \
	(tclIntStubsPtr->tclpGetCwd) /* 141 */
#endif
#ifndef TclSetByteCodeFromAny
#define TclSetByteCodeFromAny \
	(tclIntStubsPtr->tclSetByteCodeFromAny) /* 142 */
#endif
#ifndef TclAddLiteralObj
#define TclAddLiteralObj \
	(tclIntStubsPtr->tclAddLiteralObj) /* 143 */
#endif
#ifndef TclHideLiteral
#define TclHideLiteral \
	(tclIntStubsPtr->tclHideLiteral) /* 144 */
#endif
#ifndef TclGetAuxDataType
#define TclGetAuxDataType \
	(tclIntStubsPtr->tclGetAuxDataType) /* 145 */
#endif
#ifndef TclHandleCreate
#define TclHandleCreate \
	(tclIntStubsPtr->tclHandleCreate) /* 146 */
#endif
#ifndef TclHandleFree
#define TclHandleFree \
	(tclIntStubsPtr->tclHandleFree) /* 147 */
#endif
#ifndef TclHandlePreserve
#define TclHandlePreserve \
	(tclIntStubsPtr->tclHandlePreserve) /* 148 */
#endif
#ifndef TclHandleRelease
#define TclHandleRelease \
	(tclIntStubsPtr->tclHandleRelease) /* 149 */
#endif
#ifndef TclRegAbout
#define TclRegAbout \
	(tclIntStubsPtr->tclRegAbout) /* 150 */
#endif
#ifndef TclRegExpRangeUniChar
#define TclRegExpRangeUniChar \
	(tclIntStubsPtr->tclRegExpRangeUniChar) /* 151 */
#endif
#ifndef TclSetLibraryPath
#define TclSetLibraryPath \
	(tclIntStubsPtr->tclSetLibraryPath) /* 152 */
#endif
#ifndef TclGetLibraryPath
#define TclGetLibraryPath \
	(tclIntStubsPtr->tclGetLibraryPath) /* 153 */
#endif
/* Slot 154 is reserved */
/* Slot 155 is reserved */
#ifndef TclRegError
#define TclRegError \
	(tclIntStubsPtr->tclRegError) /* 156 */
#endif
#ifndef TclVarTraceExists
#define TclVarTraceExists \
	(tclIntStubsPtr->tclVarTraceExists) /* 157 */
#endif
#ifndef TclSetStartupScriptFileName
#define TclSetStartupScriptFileName \
	(tclIntStubsPtr->tclSetStartupScriptFileName) /* 158 */
#endif
#ifndef TclGetStartupScriptFileName
#define TclGetStartupScriptFileName \
	(tclIntStubsPtr->tclGetStartupScriptFileName) /* 159 */
#endif
/* Slot 160 is reserved */
#ifndef TclChannelTransform
#define TclChannelTransform \
	(tclIntStubsPtr->tclChannelTransform) /* 161 */
#endif
#ifndef TclChannelEventScriptInvoker
#define TclChannelEventScriptInvoker \
	(tclIntStubsPtr->tclChannelEventScriptInvoker) /* 162 */
#endif
#ifndef TclGetInstructionTable
#define TclGetInstructionTable \
	(tclIntStubsPtr->tclGetInstructionTable) /* 163 */
#endif
#ifndef TclExpandCodeArray
#define TclExpandCodeArray \
	(tclIntStubsPtr->tclExpandCodeArray) /* 164 */
#endif
#ifndef TclpSetInitialEncodings
#define TclpSetInitialEncodings \
	(tclIntStubsPtr->tclpSetInitialEncodings) /* 165 */
#endif
#ifndef TclListObjSetElement
#define TclListObjSetElement \
	(tclIntStubsPtr->tclListObjSetElement) /* 166 */
#endif
#ifndef TclSetStartupScriptPath
#define TclSetStartupScriptPath \
	(tclIntStubsPtr->tclSetStartupScriptPath) /* 167 */
#endif
#ifndef TclGetStartupScriptPath
#define TclGetStartupScriptPath \
	(tclIntStubsPtr->tclGetStartupScriptPath) /* 168 */
#endif
#ifndef TclpUtfNcmp2
#define TclpUtfNcmp2 \
	(tclIntStubsPtr->tclpUtfNcmp2) /* 169 */
#endif
#ifndef TclCheckInterpTraces
#define TclCheckInterpTraces \
	(tclIntStubsPtr->tclCheckInterpTraces) /* 170 */
#endif
#ifndef TclCheckExecutionTraces
#define TclCheckExecutionTraces \
	(tclIntStubsPtr->tclCheckExecutionTraces) /* 171 */
#endif
#ifndef TclInThreadExit
#define TclInThreadExit \
	(tclIntStubsPtr->tclInThreadExit) /* 172 */
#endif
#ifndef TclUniCharMatch
#define TclUniCharMatch \
	(tclIntStubsPtr->tclUniCharMatch) /* 173 */
#endif
/* Slot 174 is reserved */
/* Slot 175 is reserved */
/* Slot 176 is reserved */
/* Slot 177 is reserved */
/* Slot 178 is reserved */
/* Slot 179 is reserved */
/* Slot 180 is reserved */
/* Slot 181 is reserved */
#ifndef TclpLocaltime
#define TclpLocaltime \
	(tclIntStubsPtr->tclpLocaltime) /* 182 */
#endif
#ifndef TclpGmtime
#define TclpGmtime \
	(tclIntStubsPtr->tclpGmtime) /* 183 */
#endif
/* Slot 184 is reserved */
/* Slot 185 is reserved */
/* Slot 186 is reserved */
/* Slot 187 is reserved */
/* Slot 188 is reserved */
/* Slot 189 is reserved */
/* Slot 190 is reserved */
/* Slot 191 is reserved */
/* Slot 192 is reserved */
/* Slot 193 is reserved */
/* Slot 194 is reserved */
/* Slot 195 is reserved */
/* Slot 196 is reserved */
/* Slot 197 is reserved */
/* Slot 198 is reserved */
#ifndef TclMatchIsTrivial
#define TclMatchIsTrivial \
	(tclIntStubsPtr->tclMatchIsTrivial) /* 199 */
#endif

#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#endif /* _TCLINTDECLS */
                                                                                                                                                                                                                                                                                                                                                                                                                                                              tclIntPlatDecls.h                                                                                   0100644 0001750 0001750 00000050740 11001731473 036126  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclIntPlatDecls.h --
 *
 *	This file contains the declarations for all platform dependent
 *	unsupported functions that are exported by the Tcl library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @(#) $Id: tclIntPlatDecls.h,v 1.19.2.7 2007/04/21 19:52:14 kennykb Exp $
 */

#ifndef _TCLINTPLATDECLS
#define _TCLINTPLATDECLS

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tclInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 0 */
EXTERN void		TclGetAndDetachPids _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel chan));
/* 1 */
EXTERN int		TclpCloseFile _ANSI_ARGS_((TclFile file));
/* 2 */
EXTERN Tcl_Channel	TclpCreateCommandChannel _ANSI_ARGS_((
				TclFile readFile, TclFile writeFile, 
				TclFile errorFile, int numPids, 
				Tcl_Pid * pidPtr));
/* 3 */
EXTERN int		TclpCreatePipe _ANSI_ARGS_((TclFile * readPipe, 
				TclFile * writePipe));
/* 4 */
EXTERN int		TclpCreateProcess _ANSI_ARGS_((Tcl_Interp * interp, 
				int argc, CONST char ** argv, 
				TclFile inputFile, TclFile outputFile, 
				TclFile errorFile, Tcl_Pid * pidPtr));
/* Slot 5 is reserved */
/* 6 */
EXTERN TclFile		TclpMakeFile _ANSI_ARGS_((Tcl_Channel channel, 
				int direction));
/* 7 */
EXTERN TclFile		TclpOpenFile _ANSI_ARGS_((CONST char * fname, 
				int mode));
/* 8 */
EXTERN int		TclUnixWaitForFile _ANSI_ARGS_((int fd, int mask, 
				int timeout));
/* 9 */
EXTERN TclFile		TclpCreateTempFile _ANSI_ARGS_((
				CONST char * contents));
/* 10 */
EXTERN Tcl_DirEntry *	TclpReaddir _ANSI_ARGS_((DIR * dir));
/* 11 */
EXTERN struct tm *	TclpLocaltime_unix _ANSI_ARGS_((
				TclpTime_t_CONST clock));
/* 12 */
EXTERN struct tm *	TclpGmtime_unix _ANSI_ARGS_((TclpTime_t_CONST clock));
/* 13 */
EXTERN char *		TclpInetNtoa _ANSI_ARGS_((struct in_addr addr));
#endif /* UNIX */
#ifdef __WIN32__
/* 0 */
EXTERN void		TclWinConvertError _ANSI_ARGS_((DWORD errCode));
/* 1 */
EXTERN void		TclWinConvertWSAError _ANSI_ARGS_((DWORD errCode));
/* 2 */
EXTERN struct servent *	 TclWinGetServByName _ANSI_ARGS_((CONST char * nm, 
				CONST char * proto));
/* 3 */
EXTERN int		TclWinGetSockOpt _ANSI_ARGS_((SOCKET s, int level, 
				int optname, char FAR * optval, 
				int FAR * optlen));
/* 4 */
EXTERN HINSTANCE	TclWinGetTclInstance _ANSI_ARGS_((void));
/* Slot 5 is reserved */
/* 6 */
EXTERN u_short		TclWinNToHS _ANSI_ARGS_((u_short ns));
/* 7 */
EXTERN int		TclWinSetSockOpt _ANSI_ARGS_((SOCKET s, int level, 
				int optname, CONST char FAR * optval, 
				int optlen));
/* 8 */
EXTERN unsigned long	TclpGetPid _ANSI_ARGS_((Tcl_Pid pid));
/* 9 */
EXTERN int		TclWinGetPlatformId _ANSI_ARGS_((void));
/* Slot 10 is reserved */
/* 11 */
EXTERN void		TclGetAndDetachPids _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel chan));
/* 12 */
EXTERN int		TclpCloseFile _ANSI_ARGS_((TclFile file));
/* 13 */
EXTERN Tcl_Channel	TclpCreateCommandChannel _ANSI_ARGS_((
				TclFile readFile, TclFile writeFile, 
				TclFile errorFile, int numPids, 
				Tcl_Pid * pidPtr));
/* 14 */
EXTERN int		TclpCreatePipe _ANSI_ARGS_((TclFile * readPipe, 
				TclFile * writePipe));
/* 15 */
EXTERN int		TclpCreateProcess _ANSI_ARGS_((Tcl_Interp * interp, 
				int argc, CONST char ** argv, 
				TclFile inputFile, TclFile outputFile, 
				TclFile errorFile, Tcl_Pid * pidPtr));
/* Slot 16 is reserved */
/* Slot 17 is reserved */
/* 18 */
EXTERN TclFile		TclpMakeFile _ANSI_ARGS_((Tcl_Channel channel, 
				int direction));
/* 19 */
EXTERN TclFile		TclpOpenFile _ANSI_ARGS_((CONST char * fname, 
				int mode));
/* 20 */
EXTERN void		TclWinAddProcess _ANSI_ARGS_((HANDLE hProcess, 
				DWORD id));
/* Slot 21 is reserved */
/* 22 */
EXTERN TclFile		TclpCreateTempFile _ANSI_ARGS_((
				CONST char * contents));
/* 23 */
EXTERN char *		TclpGetTZName _ANSI_ARGS_((int isdst));
/* 24 */
EXTERN char *		TclWinNoBackslash _ANSI_ARGS_((char * path));
/* 25 */
EXTERN TclPlatformType * TclWinGetPlatform _ANSI_ARGS_((void));
/* 26 */
EXTERN void		TclWinSetInterfaces _ANSI_ARGS_((int wide));
/* 27 */
EXTERN void		TclWinFlushDirtyChannels _ANSI_ARGS_((void));
/* 28 */
EXTERN void		TclWinResetInterfaces _ANSI_ARGS_((void));
/* 29 */
EXTERN int		TclWinCPUID _ANSI_ARGS_((unsigned int index, 
				unsigned int * regs));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 0 */
EXTERN VOID *		TclpSysAlloc _ANSI_ARGS_((long size, int isBin));
/* 1 */
EXTERN void		TclpSysFree _ANSI_ARGS_((VOID * ptr));
/* 2 */
EXTERN VOID *		TclpSysRealloc _ANSI_ARGS_((VOID * cp, 
				unsigned int size));
/* 3 */
EXTERN void		TclpExit _ANSI_ARGS_((int status));
/* 4 */
EXTERN int		FSpGetDefaultDir _ANSI_ARGS_((FSSpecPtr theSpec));
/* 5 */
EXTERN int		FSpSetDefaultDir _ANSI_ARGS_((FSSpecPtr theSpec));
/* 6 */
EXTERN OSErr		FSpFindFolder _ANSI_ARGS_((short vRefNum, 
				OSType folderType, Boolean createFolder, 
				FSSpec * spec));
/* 7 */
EXTERN void		GetGlobalMouseTcl _ANSI_ARGS_((Point * mouse));
/* 8 */
EXTERN pascal OSErr	FSpGetDirectoryIDTcl _ANSI_ARGS_((
				CONST FSSpec * spec, long * theDirID, 
				Boolean * isDirectory));
/* 9 */
EXTERN pascal short	FSpOpenResFileCompatTcl _ANSI_ARGS_((
				CONST FSSpec * spec, SignedByte permission));
/* 10 */
EXTERN pascal void	FSpCreateResFileCompatTcl _ANSI_ARGS_((
				CONST FSSpec * spec, OSType creator, 
				OSType fileType, ScriptCode scriptTag));
/* 11 */
EXTERN int		FSpLocationFromPath _ANSI_ARGS_((int length, 
				CONST char * path, FSSpecPtr theSpec));
/* 12 */
EXTERN OSErr		FSpPathFromLocation _ANSI_ARGS_((FSSpecPtr theSpec, 
				int * length, Handle * fullPath));
/* 13 */
EXTERN void		TclMacExitHandler _ANSI_ARGS_((void));
/* 14 */
EXTERN void		TclMacInitExitToShell _ANSI_ARGS_((int usePatch));
/* 15 */
EXTERN OSErr		TclMacInstallExitToShellPatch _ANSI_ARGS_((
				ExitToShellProcPtr newProc));
/* 16 */
EXTERN int		TclMacOSErrorToPosixError _ANSI_ARGS_((int error));
/* 17 */
EXTERN void		TclMacRemoveTimer _ANSI_ARGS_((void * timerToken));
/* 18 */
EXTERN void *		TclMacStartTimer _ANSI_ARGS_((long ms));
/* 19 */
EXTERN int		TclMacTimerExpired _ANSI_ARGS_((void * timerToken));
/* 20 */
EXTERN int		TclMacRegisterResourceFork _ANSI_ARGS_((
				short fileRef, Tcl_Obj * tokenPtr, 
				int insert));
/* 21 */
EXTERN short		TclMacUnRegisterResourceFork _ANSI_ARGS_((
				char * tokenPtr, Tcl_Obj * resultPtr));
/* 22 */
EXTERN int		TclMacCreateEnv _ANSI_ARGS_((void));
/* 23 */
EXTERN FILE *		TclMacFOpenHack _ANSI_ARGS_((CONST char * path, 
				CONST char * mode));
/* 24 */
EXTERN char *		TclpGetTZName _ANSI_ARGS_((int isdst));
/* 25 */
EXTERN int		TclMacChmod _ANSI_ARGS_((CONST char * path, int mode));
/* 26 */
EXTERN int		FSpLLocationFromPath _ANSI_ARGS_((int length, 
				CONST char * path, FSSpecPtr theSpec));
#endif /* MAC_TCL */

typedef struct TclIntPlatStubs {
    int magic;
    struct TclIntPlatStubHooks *hooks;

#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void (*tclGetAndDetachPids) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan)); /* 0 */
    int (*tclpCloseFile) _ANSI_ARGS_((TclFile file)); /* 1 */
    Tcl_Channel (*tclpCreateCommandChannel) _ANSI_ARGS_((TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr)); /* 2 */
    int (*tclpCreatePipe) _ANSI_ARGS_((TclFile * readPipe, TclFile * writePipe)); /* 3 */
    int (*tclpCreateProcess) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr)); /* 4 */
    void *reserved5;
    TclFile (*tclpMakeFile) _ANSI_ARGS_((Tcl_Channel channel, int direction)); /* 6 */
    TclFile (*tclpOpenFile) _ANSI_ARGS_((CONST char * fname, int mode)); /* 7 */
    int (*tclUnixWaitForFile) _ANSI_ARGS_((int fd, int mask, int timeout)); /* 8 */
    TclFile (*tclpCreateTempFile) _ANSI_ARGS_((CONST char * contents)); /* 9 */
    Tcl_DirEntry * (*tclpReaddir) _ANSI_ARGS_((DIR * dir)); /* 10 */
    struct tm * (*tclpLocaltime_unix) _ANSI_ARGS_((TclpTime_t_CONST clock)); /* 11 */
    struct tm * (*tclpGmtime_unix) _ANSI_ARGS_((TclpTime_t_CONST clock)); /* 12 */
    char * (*tclpInetNtoa) _ANSI_ARGS_((struct in_addr addr)); /* 13 */
#endif /* UNIX */
#ifdef __WIN32__
    void (*tclWinConvertError) _ANSI_ARGS_((DWORD errCode)); /* 0 */
    void (*tclWinConvertWSAError) _ANSI_ARGS_((DWORD errCode)); /* 1 */
    struct servent * (*tclWinGetServByName) _ANSI_ARGS_((CONST char * nm, CONST char * proto)); /* 2 */
    int (*tclWinGetSockOpt) _ANSI_ARGS_((SOCKET s, int level, int optname, char FAR * optval, int FAR * optlen)); /* 3 */
    HINSTANCE (*tclWinGetTclInstance) _ANSI_ARGS_((void)); /* 4 */
    void *reserved5;
    u_short (*tclWinNToHS) _ANSI_ARGS_((u_short ns)); /* 6 */
    int (*tclWinSetSockOpt) _ANSI_ARGS_((SOCKET s, int level, int optname, CONST char FAR * optval, int optlen)); /* 7 */
    unsigned long (*tclpGetPid) _ANSI_ARGS_((Tcl_Pid pid)); /* 8 */
    int (*tclWinGetPlatformId) _ANSI_ARGS_((void)); /* 9 */
    void *reserved10;
    void (*tclGetAndDetachPids) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan)); /* 11 */
    int (*tclpCloseFile) _ANSI_ARGS_((TclFile file)); /* 12 */
    Tcl_Channel (*tclpCreateCommandChannel) _ANSI_ARGS_((TclFile readFile, TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid * pidPtr)); /* 13 */
    int (*tclpCreatePipe) _ANSI_ARGS_((TclFile * readPipe, TclFile * writePipe)); /* 14 */
    int (*tclpCreateProcess) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST char ** argv, TclFile inputFile, TclFile outputFile, TclFile errorFile, Tcl_Pid * pidPtr)); /* 15 */
    void *reserved16;
    void *reserved17;
    TclFile (*tclpMakeFile) _ANSI_ARGS_((Tcl_Channel channel, int direction)); /* 18 */
    TclFile (*tclpOpenFile) _ANSI_ARGS_((CONST char * fname, int mode)); /* 19 */
    void (*tclWinAddProcess) _ANSI_ARGS_((HANDLE hProcess, DWORD id)); /* 20 */
    void *reserved21;
    TclFile (*tclpCreateTempFile) _ANSI_ARGS_((CONST char * contents)); /* 22 */
    char * (*tclpGetTZName) _ANSI_ARGS_((int isdst)); /* 23 */
    char * (*tclWinNoBackslash) _ANSI_ARGS_((char * path)); /* 24 */
    TclPlatformType * (*tclWinGetPlatform) _ANSI_ARGS_((void)); /* 25 */
    void (*tclWinSetInterfaces) _ANSI_ARGS_((int wide)); /* 26 */
    void (*tclWinFlushDirtyChannels) _ANSI_ARGS_((void)); /* 27 */
    void (*tclWinResetInterfaces) _ANSI_ARGS_((void)); /* 28 */
    int (*tclWinCPUID) _ANSI_ARGS_((unsigned int index, unsigned int * regs)); /* 29 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    VOID * (*tclpSysAlloc) _ANSI_ARGS_((long size, int isBin)); /* 0 */
    void (*tclpSysFree) _ANSI_ARGS_((VOID * ptr)); /* 1 */
    VOID * (*tclpSysRealloc) _ANSI_ARGS_((VOID * cp, unsigned int size)); /* 2 */
    void (*tclpExit) _ANSI_ARGS_((int status)); /* 3 */
    int (*fSpGetDefaultDir) _ANSI_ARGS_((FSSpecPtr theSpec)); /* 4 */
    int (*fSpSetDefaultDir) _ANSI_ARGS_((FSSpecPtr theSpec)); /* 5 */
    OSErr (*fSpFindFolder) _ANSI_ARGS_((short vRefNum, OSType folderType, Boolean createFolder, FSSpec * spec)); /* 6 */
    void (*getGlobalMouseTcl) _ANSI_ARGS_((Point * mouse)); /* 7 */
    pascal OSErr (*fSpGetDirectoryIDTcl) _ANSI_ARGS_((CONST FSSpec * spec, long * theDirID, Boolean * isDirectory)); /* 8 */
    pascal short (*fSpOpenResFileCompatTcl) _ANSI_ARGS_((CONST FSSpec * spec, SignedByte permission)); /* 9 */
    pascal void (*fSpCreateResFileCompatTcl) _ANSI_ARGS_((CONST FSSpec * spec, OSType creator, OSType fileType, ScriptCode scriptTag)); /* 10 */
    int (*fSpLocationFromPath) _ANSI_ARGS_((int length, CONST char * path, FSSpecPtr theSpec)); /* 11 */
    OSErr (*fSpPathFromLocation) _ANSI_ARGS_((FSSpecPtr theSpec, int * length, Handle * fullPath)); /* 12 */
    void (*tclMacExitHandler) _ANSI_ARGS_((void)); /* 13 */
    void (*tclMacInitExitToShell) _ANSI_ARGS_((int usePatch)); /* 14 */
    OSErr (*tclMacInstallExitToShellPatch) _ANSI_ARGS_((ExitToShellProcPtr newProc)); /* 15 */
    int (*tclMacOSErrorToPosixError) _ANSI_ARGS_((int error)); /* 16 */
    void (*tclMacRemoveTimer) _ANSI_ARGS_((void * timerToken)); /* 17 */
    void * (*tclMacStartTimer) _ANSI_ARGS_((long ms)); /* 18 */
    int (*tclMacTimerExpired) _ANSI_ARGS_((void * timerToken)); /* 19 */
    int (*tclMacRegisterResourceFork) _ANSI_ARGS_((short fileRef, Tcl_Obj * tokenPtr, int insert)); /* 20 */
    short (*tclMacUnRegisterResourceFork) _ANSI_ARGS_((char * tokenPtr, Tcl_Obj * resultPtr)); /* 21 */
    int (*tclMacCreateEnv) _ANSI_ARGS_((void)); /* 22 */
    FILE * (*tclMacFOpenHack) _ANSI_ARGS_((CONST char * path, CONST char * mode)); /* 23 */
    char * (*tclpGetTZName) _ANSI_ARGS_((int isdst)); /* 24 */
    int (*tclMacChmod) _ANSI_ARGS_((CONST char * path, int mode)); /* 25 */
    int (*fSpLLocationFromPath) _ANSI_ARGS_((int length, CONST char * path, FSSpecPtr theSpec)); /* 26 */
#endif /* MAC_TCL */
} TclIntPlatStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TclIntPlatStubs *tclIntPlatStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS)

/*
 * Inline function declarations:
 */

#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
#ifndef TclGetAndDetachPids
#define TclGetAndDetachPids \
	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 0 */
#endif
#ifndef TclpCloseFile
#define TclpCloseFile \
	(tclIntPlatStubsPtr->tclpCloseFile) /* 1 */
#endif
#ifndef TclpCreateCommandChannel
#define TclpCreateCommandChannel \
	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 2 */
#endif
#ifndef TclpCreatePipe
#define TclpCreatePipe \
	(tclIntPlatStubsPtr->tclpCreatePipe) /* 3 */
#endif
#ifndef TclpCreateProcess
#define TclpCreateProcess \
	(tclIntPlatStubsPtr->tclpCreateProcess) /* 4 */
#endif
/* Slot 5 is reserved */
#ifndef TclpMakeFile
#define TclpMakeFile \
	(tclIntPlatStubsPtr->tclpMakeFile) /* 6 */
#endif
#ifndef TclpOpenFile
#define TclpOpenFile \
	(tclIntPlatStubsPtr->tclpOpenFile) /* 7 */
#endif
#ifndef TclUnixWaitForFile
#define TclUnixWaitForFile \
	(tclIntPlatStubsPtr->tclUnixWaitForFile) /* 8 */
#endif
#ifndef TclpCreateTempFile
#define TclpCreateTempFile \
	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 9 */
#endif
#ifndef TclpReaddir
#define TclpReaddir \
	(tclIntPlatStubsPtr->tclpReaddir) /* 10 */
#endif
#ifndef TclpLocaltime_unix
#define TclpLocaltime_unix \
	(tclIntPlatStubsPtr->tclpLocaltime_unix) /* 11 */
#endif
#ifndef TclpGmtime_unix
#define TclpGmtime_unix \
	(tclIntPlatStubsPtr->tclpGmtime_unix) /* 12 */
#endif
#ifndef TclpInetNtoa
#define TclpInetNtoa \
	(tclIntPlatStubsPtr->tclpInetNtoa) /* 13 */
#endif
#endif /* UNIX */
#ifdef __WIN32__
#ifndef TclWinConvertError
#define TclWinConvertError \
	(tclIntPlatStubsPtr->tclWinConvertError) /* 0 */
#endif
#ifndef TclWinConvertWSAError
#define TclWinConvertWSAError \
	(tclIntPlatStubsPtr->tclWinConvertWSAError) /* 1 */
#endif
#ifndef TclWinGetServByName
#define TclWinGetServByName \
	(tclIntPlatStubsPtr->tclWinGetServByName) /* 2 */
#endif
#ifndef TclWinGetSockOpt
#define TclWinGetSockOpt \
	(tclIntPlatStubsPtr->tclWinGetSockOpt) /* 3 */
#endif
#ifndef TclWinGetTclInstance
#define TclWinGetTclInstance \
	(tclIntPlatStubsPtr->tclWinGetTclInstance) /* 4 */
#endif
/* Slot 5 is reserved */
#ifndef TclWinNToHS
#define TclWinNToHS \
	(tclIntPlatStubsPtr->tclWinNToHS) /* 6 */
#endif
#ifndef TclWinSetSockOpt
#define TclWinSetSockOpt \
	(tclIntPlatStubsPtr->tclWinSetSockOpt) /* 7 */
#endif
#ifndef TclpGetPid
#define TclpGetPid \
	(tclIntPlatStubsPtr->tclpGetPid) /* 8 */
#endif
#ifndef TclWinGetPlatformId
#define TclWinGetPlatformId \
	(tclIntPlatStubsPtr->tclWinGetPlatformId) /* 9 */
#endif
/* Slot 10 is reserved */
#ifndef TclGetAndDetachPids
#define TclGetAndDetachPids \
	(tclIntPlatStubsPtr->tclGetAndDetachPids) /* 11 */
#endif
#ifndef TclpCloseFile
#define TclpCloseFile \
	(tclIntPlatStubsPtr->tclpCloseFile) /* 12 */
#endif
#ifndef TclpCreateCommandChannel
#define TclpCreateCommandChannel \
	(tclIntPlatStubsPtr->tclpCreateCommandChannel) /* 13 */
#endif
#ifndef TclpCreatePipe
#define TclpCreatePipe \
	(tclIntPlatStubsPtr->tclpCreatePipe) /* 14 */
#endif
#ifndef TclpCreateProcess
#define TclpCreateProcess \
	(tclIntPlatStubsPtr->tclpCreateProcess) /* 15 */
#endif
/* Slot 16 is reserved */
/* Slot 17 is reserved */
#ifndef TclpMakeFile
#define TclpMakeFile \
	(tclIntPlatStubsPtr->tclpMakeFile) /* 18 */
#endif
#ifndef TclpOpenFile
#define TclpOpenFile \
	(tclIntPlatStubsPtr->tclpOpenFile) /* 19 */
#endif
#ifndef TclWinAddProcess
#define TclWinAddProcess \
	(tclIntPlatStubsPtr->tclWinAddProcess) /* 20 */
#endif
/* Slot 21 is reserved */
#ifndef TclpCreateTempFile
#define TclpCreateTempFile \
	(tclIntPlatStubsPtr->tclpCreateTempFile) /* 22 */
#endif
#ifndef TclpGetTZName
#define TclpGetTZName \
	(tclIntPlatStubsPtr->tclpGetTZName) /* 23 */
#endif
#ifndef TclWinNoBackslash
#define TclWinNoBackslash \
	(tclIntPlatStubsPtr->tclWinNoBackslash) /* 24 */
#endif
#ifndef TclWinGetPlatform
#define TclWinGetPlatform \
	(tclIntPlatStubsPtr->tclWinGetPlatform) /* 25 */
#endif
#ifndef TclWinSetInterfaces
#define TclWinSetInterfaces \
	(tclIntPlatStubsPtr->tclWinSetInterfaces) /* 26 */
#endif
#ifndef TclWinFlushDirtyChannels
#define TclWinFlushDirtyChannels \
	(tclIntPlatStubsPtr->tclWinFlushDirtyChannels) /* 27 */
#endif
#ifndef TclWinResetInterfaces
#define TclWinResetInterfaces \
	(tclIntPlatStubsPtr->tclWinResetInterfaces) /* 28 */
#endif
#ifndef TclWinCPUID
#define TclWinCPUID \
	(tclIntPlatStubsPtr->tclWinCPUID) /* 29 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TclpSysAlloc
#define TclpSysAlloc \
	(tclIntPlatStubsPtr->tclpSysAlloc) /* 0 */
#endif
#ifndef TclpSysFree
#define TclpSysFree \
	(tclIntPlatStubsPtr->tclpSysFree) /* 1 */
#endif
#ifndef TclpSysRealloc
#define TclpSysRealloc \
	(tclIntPlatStubsPtr->tclpSysRealloc) /* 2 */
#endif
#ifndef TclpExit
#define TclpExit \
	(tclIntPlatStubsPtr->tclpExit) /* 3 */
#endif
#ifndef FSpGetDefaultDir
#define FSpGetDefaultDir \
	(tclIntPlatStubsPtr->fSpGetDefaultDir) /* 4 */
#endif
#ifndef FSpSetDefaultDir
#define FSpSetDefaultDir \
	(tclIntPlatStubsPtr->fSpSetDefaultDir) /* 5 */
#endif
#ifndef FSpFindFolder
#define FSpFindFolder \
	(tclIntPlatStubsPtr->fSpFindFolder) /* 6 */
#endif
#ifndef GetGlobalMouseTcl
#define GetGlobalMouseTcl \
	(tclIntPlatStubsPtr->getGlobalMouseTcl) /* 7 */
#endif
#ifndef FSpGetDirectoryIDTcl
#define FSpGetDirectoryIDTcl \
	(tclIntPlatStubsPtr->fSpGetDirectoryIDTcl) /* 8 */
#endif
#ifndef FSpOpenResFileCompatTcl
#define FSpOpenResFileCompatTcl \
	(tclIntPlatStubsPtr->fSpOpenResFileCompatTcl) /* 9 */
#endif
#ifndef FSpCreateResFileCompatTcl
#define FSpCreateResFileCompatTcl \
	(tclIntPlatStubsPtr->fSpCreateResFileCompatTcl) /* 10 */
#endif
#ifndef FSpLocationFromPath
#define FSpLocationFromPath \
	(tclIntPlatStubsPtr->fSpLocationFromPath) /* 11 */
#endif
#ifndef FSpPathFromLocation
#define FSpPathFromLocation \
	(tclIntPlatStubsPtr->fSpPathFromLocation) /* 12 */
#endif
#ifndef TclMacExitHandler
#define TclMacExitHandler \
	(tclIntPlatStubsPtr->tclMacExitHandler) /* 13 */
#endif
#ifndef TclMacInitExitToShell
#define TclMacInitExitToShell \
	(tclIntPlatStubsPtr->tclMacInitExitToShell) /* 14 */
#endif
#ifndef TclMacInstallExitToShellPatch
#define TclMacInstallExitToShellPatch \
	(tclIntPlatStubsPtr->tclMacInstallExitToShellPatch) /* 15 */
#endif
#ifndef TclMacOSErrorToPosixError
#define TclMacOSErrorToPosixError \
	(tclIntPlatStubsPtr->tclMacOSErrorToPosixError) /* 16 */
#endif
#ifndef TclMacRemoveTimer
#define TclMacRemoveTimer \
	(tclIntPlatStubsPtr->tclMacRemoveTimer) /* 17 */
#endif
#ifndef TclMacStartTimer
#define TclMacStartTimer \
	(tclIntPlatStubsPtr->tclMacStartTimer) /* 18 */
#endif
#ifndef TclMacTimerExpired
#define TclMacTimerExpired \
	(tclIntPlatStubsPtr->tclMacTimerExpired) /* 19 */
#endif
#ifndef TclMacRegisterResourceFork
#define TclMacRegisterResourceFork \
	(tclIntPlatStubsPtr->tclMacRegisterResourceFork) /* 20 */
#endif
#ifndef TclMacUnRegisterResourceFork
#define TclMacUnRegisterResourceFork \
	(tclIntPlatStubsPtr->tclMacUnRegisterResourceFork) /* 21 */
#endif
#ifndef TclMacCreateEnv
#define TclMacCreateEnv \
	(tclIntPlatStubsPtr->tclMacCreateEnv) /* 22 */
#endif
#ifndef TclMacFOpenHack
#define TclMacFOpenHack \
	(tclIntPlatStubsPtr->tclMacFOpenHack) /* 23 */
#endif
#ifndef TclpGetTZName
#define TclpGetTZName \
	(tclIntPlatStubsPtr->tclpGetTZName) /* 24 */
#endif
#ifndef TclMacChmod
#define TclMacChmod \
	(tclIntPlatStubsPtr->tclMacChmod) /* 25 */
#endif
#ifndef FSpLLocationFromPath
#define FSpLLocationFromPath \
	(tclIntPlatStubsPtr->fSpLLocationFromPath) /* 26 */
#endif
#endif /* MAC_TCL */

#endif /* defined(USE_TCL_STUBS) && !defined(USE_TCL_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#endif /* _TCLINTPLATDECLS */
                                tclMath.h                                                                                           0100644 0001750 0001750 00000001363 06577261401 034501  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclMath.h --
 *
 *	This file is necessary because of Metrowerks CodeWarrior Pro 1
 *	on the Macintosh. With 8-byte doubles turned on, the definitions of
 *	sin, cos, acos, etc., are screwed up.  They are fine as long as
 *	they are used as function calls, but if the function pointers
 *	are passed around and used, they will crash hard on the 68K.
 *
 * Copyright (c) 1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclMath.h,v 1.2 1998/09/14 18:40:01 stanton Exp $
 */

#ifndef _TCLMATH
#define _TCLMATH

#if defined(MAC_TCL)
#   include "tclMacMath.h"
#else
#   include <math.h>
#endif

#endif /* _TCLMATH */
                                                                                                                                                                                                                                                                             tclPort.h                                                                                           0100644 0001750 0001750 00000002175 12566232222 034530  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclPort.h --
 *
 *	This header file handles porting issues that occur because
 *	of differences between systems.  It reads in platform specific
 *	portability files.
 *
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclPort.h,v 1.6.2.1 2003/04/16 23:31:46 dgp Exp $
 */

#ifndef _TCLPORT
#define _TCLPORT

#include "tcl.h"

#if defined(__WIN32__)
#   include "tclWinPort.h"
#else
#   if defined(MAC_TCL)
#      include "tclMacPort.h"
#   else
#      include "tclUnixPort.h"
#   endif
#endif

#if !defined(LLONG_MIN)
#   ifdef TCL_WIDE_INT_IS_LONG
#      define LLONG_MIN LONG_MIN
#   else
#      ifdef LLONG_BIT
#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<(LLONG_BIT-1)))
#      else
/* Assume we're on a system with a 64-bit 'long long' type */
#         define LLONG_MIN ((Tcl_WideInt)(Tcl_LongAsWide(1)<<63))
#      endif
#   endif
/* Assume that if LLONG_MIN is undefined, then so is LLONG_MAX */
#   define LLONG_MAX (~LLONG_MIN)
#endif


#endif /* _TCLPORT */
                                                                                                                                                                                                                                                                                                                                                                                                   tclUnixPort.h                                                                                       0100644 0001750 0001750 00000043572 12526746631 035414  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers/tcl-private                                                           /*
 * tclUnixPort.h --
 *
 *	This header file handles porting issues that occur because
 *	of differences between systems.  It reads in UNIX-related
 *	header files and sets up UNIX-related macros for Tcl's UNIX
 *	core.  It should be the only file that contains #ifdefs to
 *	handle different flavors of UNIX.  This file sets up the
 *	union of all UNIX-related things needed by any of the Tcl
 *	core files.  This file depends on configuration #defines such
 *	as NO_DIRENT_H that are set up by the "configure" script.
 *
 *	Much of the material in this file was originally contributed
 *	by Karl Lehenbauer, Mark Diekhans and Peter da Silva.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclUnixPort.h,v 1.27.2.19 2007/08/07 05:04:48 das Exp $
 */

#ifndef _TCLUNIXPORT
#define _TCLUNIXPORT

#ifndef _TCLINT
#   include "tclInt.h"
#endif

/*
 *---------------------------------------------------------------------------
 * The following sets of #includes and #ifdefs are required to get Tcl to
 * compile under the various flavors of unix.
 *---------------------------------------------------------------------------
 */

#include <errno.h>
#include <fcntl.h>
#ifdef HAVE_NET_ERRNO_H
#   include <net/errno.h>
#endif
#include <pwd.h>
#include <signal.h>
#ifdef HAVE_SYS_PARAM_H
#   include <sys/param.h>
#endif
#include <sys/types.h>
#ifdef USE_DIRENT2_H
#   include "../compat/dirent2.h"
#else
#ifdef NO_DIRENT_H
#   include "../compat/dirent.h"
#else
#   include <dirent.h>
#endif
#endif

#ifdef HAVE_STRUCT_DIRENT64
typedef struct dirent64	Tcl_DirEntry;
#   define TclOSreaddir		readdir64
#else
typedef struct dirent	Tcl_DirEntry;
#   define TclOSreaddir		readdir
#endif

#ifdef HAVE_TYPE_OFF64_T
typedef off64_t		Tcl_SeekOffset;
#   define TclOSseek		lseek64
#   define TclOSopen		open64
#else
typedef off_t		Tcl_SeekOffset;
#   define TclOSseek		lseek
#   define TclOSopen		open
#endif

#ifdef HAVE_STRUCT_STAT64
#   define TclOSstat		stat64
#   define TclOSlstat		lstat64
#else
#   define TclOSstat		stat
#   define TclOSlstat		lstat
#endif

#if !HAVE_STRTOLL && defined(TCL_WIDE_INT_TYPE) && !TCL_WIDE_INT_IS_LONG
EXTERN Tcl_WideInt	strtoll _ANSI_ARGS_((CONST char *string,
					     char **endPtr, int base));
EXTERN Tcl_WideUInt	strtoull _ANSI_ARGS_((CONST char *string,
					      char **endPtr, int base));
#endif

#include <sys/file.h>
#ifdef HAVE_SYS_SELECT_H
#   include <sys/select.h>
#endif
#include <sys/stat.h>

#ifdef __CYGWIN__
#   define timezone _timezone
    typedef long TIMEZONE_t;
#else	/* !__CYGWIN__ */
    typedef int TIMEZONE_t;
#endif	/* !__CYGWIN__ */

#if TIME_WITH_SYS_TIME
#   include <sys/time.h>
#   include <time.h>
#else
#if HAVE_SYS_TIME_H
#   include <sys/time.h>
#else
#   include <time.h>
#endif
#endif
#ifndef NO_SYS_WAIT_H
#   include <sys/wait.h>
#endif
#ifdef HAVE_UNISTD_H
#   include <unistd.h>
#else
#   include "../compat/unistd.h"
#endif
#ifdef	USE_FIONBIO
    /*
     * Not using the Posix fcntl(...,O_NONBLOCK,...) interface, instead
     * we are using ioctl(..,FIONBIO,..).
     */

#   ifdef HAVE_SYS_FILIO_H
#	include	<sys/filio.h>	/* For FIONBIO. */
#   endif

#   ifdef HAVE_SYS_IOCTL_H
#	include	<sys/ioctl.h>	/* For FIONBIO. */
#   endif
#endif	/* USE_FIONBIO */
#include <utime.h>

/*
 * Socket support stuff: This likely needs more work to parameterize for
 * each system.
 */

#include <sys/socket.h>		/* struct sockaddr, SOCK_STREAM, ... */
#ifndef NO_UNAME
#   include <sys/utsname.h>	/* uname system call. */
#endif
#include <netinet/in.h>		/* struct in_addr, struct sockaddr_in */
#include <arpa/inet.h>		/* inet_ntoa() */
#include <netdb.h>		/* gethostbyname() */

/*
 * Some platforms (e.g. SunOS) don't define FLT_MAX and FLT_MIN, so we
 * look for an alternative definition.  If no other alternative is available
 * we use a reasonable guess.
 */

#ifndef NO_FLOAT_H
#   include <float.h>
#else
#ifndef NO_VALUES_H
#   include <values.h>
#endif
#endif

#ifndef FLT_MAX
#   ifdef MAXFLOAT
#	define FLT_MAX MAXFLOAT
#   else
#	define FLT_MAX 3.402823466E+38F
#   endif
#endif
#ifndef FLT_MIN
#   ifdef MINFLOAT
#	define FLT_MIN MINFLOAT
#   else
#	define FLT_MIN 1.175494351E-38F
#   endif
#endif

/*
 * NeXT doesn't define O_NONBLOCK, so #define it here if necessary.
 */

#ifndef O_NONBLOCK
#   define O_NONBLOCK 0x80
#endif

/*
 * HPUX needs the flag O_NONBLOCK to get the right non-blocking I/O
 * semantics, while most other systems need O_NDELAY.  Define the
 * constant NBIO_FLAG to be one of these
 */

#ifdef HPUX
#  define NBIO_FLAG O_NONBLOCK
#else
#  define NBIO_FLAG O_NDELAY
#endif

/*
 * The type of the status returned by wait varies from UNIX system
 * to UNIX system.  The macro below defines it:
 */

#ifdef _AIX
#   define WAIT_STATUS_TYPE pid_t
#else
#ifndef NO_UNION_WAIT
#   define WAIT_STATUS_TYPE union wait
#else
#   define WAIT_STATUS_TYPE int
#endif
#endif

/*
 * Supply definitions for macros to query wait status, if not already
 * defined in header files above.
 */

#ifndef WIFEXITED
#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xff) == 0)
#endif

#ifndef WEXITSTATUS
#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#ifndef WIFSIGNALED
#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
#endif

#ifndef WTERMSIG
#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
#endif

#ifndef WIFSTOPPED
#   define WIFSTOPPED(stat)  (((*((int *) &(stat))) & 0xff) == 0177)
#endif

#ifndef WSTOPSIG
#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
#endif

/*
 * Define constants for waitpid() system call if they aren't defined
 * by a system header file.
 */

#ifndef WNOHANG
#   define WNOHANG 1
#endif
#ifndef WUNTRACED
#   define WUNTRACED 2
#endif

/*
 * Supply macros for seek offsets, if they're not already provided by
 * an include file.
 */

#ifndef SEEK_SET
#   define SEEK_SET 0
#endif
#ifndef SEEK_CUR
#   define SEEK_CUR 1
#endif
#ifndef SEEK_END
#   define SEEK_END 2
#endif

/*
 * The stuff below is needed by the "time" command.  If this system has no
 * gettimeofday call, then must use times and the CLK_TCK #define (from
 * sys/param.h) to compute elapsed time.  Unfortunately, some systems only
 * have HZ and no CLK_TCK, and some might not even have HZ.
 */

#ifdef NO_GETTOD
#   include <sys/times.h>
#   include <sys/param.h>
#   ifndef CLK_TCK
#       ifdef HZ
#           define CLK_TCK HZ
#       else
#           define CLK_TCK 60
#       endif
#   endif
#else
#   ifdef HAVE_BSDGETTIMEOFDAY
#	define gettimeofday BSDgettimeofday
#   endif
#endif

#ifdef GETTOD_NOT_DECLARED
EXTERN int		gettimeofday _ANSI_ARGS_((struct timeval *tp,
			    struct timezone *tzp));
#endif

/*
 * Define access mode constants if they aren't already defined.
 */

#ifndef F_OK
#    define F_OK 00
#endif
#ifndef X_OK
#    define X_OK 01
#endif
#ifndef W_OK
#    define W_OK 02
#endif
#ifndef R_OK
#    define R_OK 04
#endif

/*
 * Define FD_CLOEEXEC (the close-on-exec flag bit) if it isn't
 * already defined.
 */

#ifndef FD_CLOEXEC
#   define FD_CLOEXEC 1
#endif

/*
 * On systems without symbolic links (i.e. S_IFLNK isn't defined)
 * define "lstat" to use "stat" instead.
 */

#ifndef S_IFLNK
#   undef TclOSlstat
#   define lstat	stat
#   define lstat64	stat64
#   define TclOSlstat	TclOSstat
#endif

/*
 * Define macros to query file type bits, if they're not already
 * defined.
 */

#ifndef S_ISREG
#   ifdef S_IFREG
#       define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#   else
#       define S_ISREG(m) 0
#   endif
#endif /* !S_ISREG */
#ifndef S_ISDIR
#   ifdef S_IFDIR
#       define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#   else
#       define S_ISDIR(m) 0
#   endif
#endif /* !S_ISDIR */
#ifndef S_ISCHR
#   ifdef S_IFCHR
#       define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#   else
#       define S_ISCHR(m) 0
#   endif
#endif /* !S_ISCHR */
#ifndef S_ISBLK
#   ifdef S_IFBLK
#       define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#   else
#       define S_ISBLK(m) 0
#   endif
#endif /* !S_ISBLK */
#ifndef S_ISFIFO
#   ifdef S_IFIFO
#       define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#   else
#       define S_ISFIFO(m) 0
#   endif
#endif /* !S_ISFIFO */
#ifndef S_ISLNK
#   ifdef S_IFLNK
#       define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#   else
#       define S_ISLNK(m) 0
#   endif
#endif /* !S_ISLNK */
#ifndef S_ISSOCK
#   ifdef S_IFSOCK
#       define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#   else
#       define S_ISSOCK(m) 0
#   endif
#endif /* !S_ISSOCK */

/*
 * Make sure that MAXPATHLEN and MAXNAMLEN are defined.
 */

#ifndef MAXPATHLEN
#   ifdef PATH_MAX
#       define MAXPATHLEN PATH_MAX
#   else
#       define MAXPATHLEN 2048
#   endif
#endif

#ifndef MAXNAMLEN
#   ifdef NAME_MAX
#	define MAXNAMLEN NAME_MAX
#   else
#	define MAXNAMLEN 255
#   endif
#endif

/*
 * Make sure that L_tmpnam is defined.
 */

#ifndef L_tmpnam
#   define L_tmpnam 100
#endif

/*
 * The following macro defines the type of the mask arguments to
 * select:
 */

#ifndef NO_FD_SET
#   define SELECT_MASK fd_set
#else /* NO_FD_SET */
#   ifndef _AIX
	typedef long fd_mask;
#   endif /* !AIX */
#   if defined(_IBMR2)
#	define SELECT_MASK void
#   else /* !defined(_IBMR2) */
#	define SELECT_MASK int
#   endif /* defined(_IBMR2) */
#endif /* !NO_FD_SET */

/*
 * Define "NBBY" (number of bits per byte) if it's not already defined.
 */

#ifndef NBBY
#   define NBBY 8
#endif

/*
 * The following macro defines the number of fd_masks in an fd_set:
 */

#ifndef FD_SETSIZE
#   ifdef OPEN_MAX
#	define FD_SETSIZE OPEN_MAX
#   else
#	define FD_SETSIZE 256
#   endif
#endif /* FD_SETSIZE */
#if !defined(howmany)
#   define howmany(x, y) (((x)+((y)-1))/(y))
#endif /* !defined(howmany) */
#ifndef NFDBITS
#   define NFDBITS NBBY*sizeof(fd_mask)
#endif /* NFDBITS */
#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)

/*
 * Not all systems declare the errno variable in errno.h. so this
 * file does it explicitly.  The list of system error messages also
 * isn't generally declared in a header file anywhere.
 */

#ifdef NO_ERRNO
extern int errno;
#endif

/*
 * Not all systems declare all the errors that Tcl uses!  Provide some
 * work-arounds...
 */

#ifndef EOVERFLOW
#   ifdef EFBIG
#	define EOVERFLOW EFBIG
#   else /* !EFBIG */
#	define EOVERFLOW EINVAL
#   endif /* EFBIG */
#endif /* EOVERFLOW */

/*
 * Variables provided by the C library:
 */

#if defined(__APPLE__) && defined(__DYNAMIC__)
#   include <crt_externs.h>
#   define environ (*_NSGetEnviron())
#   define USE_PUTENV 1
#else
#   if defined(_sgi) || defined(__sgi)
#       define environ _environ
#   endif
extern char **environ;
#endif

/*
 * At present (12/91) not all stdlib.h implementations declare strtod.
 * The declaration below is here to ensure that it's declared, so that
 * the compiler won't take the default approach of assuming it returns
 * an int.  There's no ANSI prototype for it because there would end
 * up being too many conflicts with slightly-different prototypes.
 */

extern double strtod();

/*
 * There is no platform-specific panic routine for Unix in the Tcl internals.
 */

#define TclpPanic ((Tcl_PanicProc *) NULL)

/*
 * Darwin specifc configure overrides.
 */

#ifdef __APPLE__
/*
 * Support for fat compiles: configure runs only once for multiple architectures
 */
#   if defined(__LP64__) && defined (NO_COREFOUNDATION_64)
#       undef HAVE_COREFOUNDATION
#    endif /* __LP64__ && NO_COREFOUNDATION_64 */
#   include <sys/cdefs.h>
#   ifdef __DARWIN_UNIX03
#       if __DARWIN_UNIX03
#           undef HAVE_PUTENV_THAT_COPIES
#       else
#           define HAVE_PUTENV_THAT_COPIES 1
#       endif
#   endif /* __DARWIN_UNIX03 */
/*
 * The termios configure test program relies on the configure script being run
 * from a terminal, which is not the case e.g. when configuring from Xcode.
 * Since termios is known to be present on all Mac OS X releases since 10.0,
 * override the configure defines for serial API here. [Bug 497147]
 */
#   define USE_TERMIOS 1
#   undef  USE_TERMIO
#   undef  USE_SGTTY
/*
 * Include AvailabilityMacros.h here (when available) to ensure any symbolic
 * MAC_OS_X_VERSION_* constants passed on the command line are translated.
 */
#   ifdef HAVE_AVAILABILITYMACROS_H
#       include <AvailabilityMacros.h>
#   endif
/*
 * Support for weak import.
 */
#   ifdef HAVE_WEAK_IMPORT
#       if !defined(HAVE_AVAILABILITYMACROS_H) || !defined(MAC_OS_X_VERSION_MIN_REQUIRED)
#           undef HAVE_WEAK_IMPORT
#       else
#           ifndef WEAK_IMPORT_ATTRIBUTE
#               define WEAK_IMPORT_ATTRIBUTE __attribute__((weak_import))
#           endif
#       endif
#   endif /* HAVE_WEAK_IMPORT */
/*
 * Support for MAC_OS_X_VERSION_MAX_ALLOWED define from AvailabilityMacros.h:
 * only use API available in the indicated OS version or earlier.
 */
#   ifdef MAC_OS_X_VERSION_MAX_ALLOWED
#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1050 && defined(__LP64__)
#           undef HAVE_COREFOUNDATION
#       endif
#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1040
#           undef HAVE_OSSPINLOCKLOCK
#           undef HAVE_PTHREAD_ATFORK
#           undef HAVE_COPYFILE
#       endif
#       if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
#           ifdef TCL_THREADS
		/* prior to 10.3, realpath is not threadsafe, c.f. bug 711232 */
#               define NO_REALPATH 1
#           endif
#           undef HAVE_LANGINFO
#       endif
#   endif /* MAC_OS_X_VERSION_MAX_ALLOWED */
#   if defined(HAVE_COREFOUNDATION) && defined(__LP64__) && \
	    defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
#       warning "Weak import of 64-bit CoreFoundation is not supported, will not run on Mac OS X < 10.5."
#   endif
/*
 * At present, using vfork() instead of fork() causes execve() to fail
 * intermittently on Darwin x86_64. rdar://4685553
 */
#   if defined(__x86_64__) && !defined(FIXED_RDAR_4685553)
#       undef USE_VFORK
#   endif /* __x86_64__ */
/* Workaround problems with vfork() when building with llvm-gcc-4.2 */
#   if defined (__llvm__) && \
	    (__GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
	    (__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ > 0))))
#       undef USE_VFORK
#   endif /* __llvm__ */
#endif /* __APPLE__ */

/*
 * Darwin 8 copyfile API.
 */

#ifdef HAVE_COPYFILE
#ifdef HAVE_COPYFILE_H
#include <copyfile.h>
#if defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1040
/* Support for weakly importing copyfile. */
#define WEAK_IMPORT_COPYFILE
extern int copyfile(const char *from, const char *to, copyfile_state_t state,
		    copyfile_flags_t flags) WEAK_IMPORT_ATTRIBUTE;
#endif /* HAVE_WEAK_IMPORT */
#else /* HAVE_COPYFILE_H */
int copyfile(const char *from, const char *to, void *state, uint32_t flags);
#define COPYFILE_ACL            (1<<0)
#define COPYFILE_XATTR          (1<<2)
#define COPYFILE_NOFOLLOW_SRC   (1<<18)
#if defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1040
/* Support for weakly importing copyfile. */
#define WEAK_IMPORT_COPYFILE
extern int copyfile(const char *from, const char *to, void *state,
                    uint32_t flags) WEAK_IMPORT_ATTRIBUTE;
#endif /* HAVE_WEAK_IMPORT */
#endif /* HAVE_COPYFILE_H */
#endif /* HAVE_COPYFILE */

/*
 *---------------------------------------------------------------------------
 * The following macros and declarations represent the interface between 
 * generic and unix-specific parts of Tcl.  Some of the macros may override 
 * functions declared in tclInt.h.
 *---------------------------------------------------------------------------
 */

/*
 * The default platform eol translation on Unix is TCL_TRANSLATE_LF.
 */

#ifdef DJGPP
#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_CRLF
#else
#define	TCL_PLATFORM_TRANSLATION	TCL_TRANSLATE_LF
#endif

/*
 * The following macros have trivial definitions, allowing generic code to 
 * address platform-specific issues.
 */

#define TclpGetPid(pid)		((unsigned long) (pid))
#define TclpReleaseFile(file)	/* Nothing. */

/*
 * The following defines wrap the system memory allocation routines for
 * use by tclAlloc.c.  By default off unused on Unix.
 */

#if USE_TCLALLOC
#   define TclpSysAlloc(size, isBin)	malloc((size_t)size)
#   define TclpSysFree(ptr)		free((char*)ptr)
#   define TclpSysRealloc(ptr, size)	realloc((char*)ptr, (size_t)size)
#endif

/*
 * The following macros and declaration wrap the C runtime library
 * functions.
 */

#define TclpExit		exit

/*
 * Platform specific mutex definition used by memory allocators.
 * These mutexes are statically allocated and explicitly initialized.
 * Most modules do not use this, but instead use Tcl_Mutex types and
 * Tcl_MutexLock and Tcl_MutexUnlock that are self-initializing.
 */

#ifdef TCL_THREADS
#include <pthread.h>
typedef pthread_mutex_t TclpMutex;
EXTERN void	TclpMutexInit _ANSI_ARGS_((TclpMutex *mPtr));
EXTERN void	TclpMutexLock _ANSI_ARGS_((TclpMutex *mPtr));
EXTERN void	TclpMutexUnlock _ANSI_ARGS_((TclpMutex *mPtr));
EXTERN Tcl_DirEntry * 	TclpReaddir(DIR *);
#ifndef TclpLocaltime
EXTERN struct tm *     	TclpLocaltime(TclpTime_t_CONST);
#endif
#ifndef TclpGmtime
EXTERN struct tm *     	TclpGmtime(TclpTime_t_CONST);
#endif
EXTERN char *          	TclpInetNtoa(struct in_addr);
#define inet_ntoa(x)	TclpInetNtoa(x)
#else
typedef int TclpMutex;
#define	TclpMutexInit(a)
#define	TclpMutexLock(a)
#define	TclpMutexUnlock(a)
#endif /* TCL_THREADS */


/*
 * Set of MT-safe implementations of some
 * known-to-be-MT-unsafe library calls.
 * Instead of returning pointers to the
 * static storage, those return pointers
 * to the TSD data. 
 */

#include <pwd.h>
#include <grp.h>

EXTERN struct passwd*  TclpGetPwNam(const char *name);
EXTERN struct group*   TclpGetGrNam(const char *name);
EXTERN struct passwd*  TclpGetPwUid(uid_t uid);
EXTERN struct group*   TclpGetGrGid(gid_t gid);
EXTERN struct hostent* TclpGetHostByName(const char *name);
EXTERN struct hostent* TclpGetHostByAddr(const char *addr, int length, int type);

#include "tclPlatDecls.h"
#include "tclIntPlatDecls.h"

#endif /* _TCLUNIXPORT */
                                                                                                                                      tcl.h                                                                                               0100644 0001750 0001750 00000246651 12526746631 031454  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers                                                                       /*
 * tcl.h --
 *
 *	This header file describes the externally-visible facilities
 *	of the Tcl interpreter.
 *
 * Copyright (c) 1987-1994 The Regents of the University of California.
 * Copyright (c) 1993-1996 Lucent Technologies.
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-2000 by Scriptics Corporation.
 * Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tcl.h,v 1.153.2.35 2008/04/11 16:57:38 dgp Exp $
 */

#ifndef _TCL
#define _TCL

/*
 * For C++ compilers, use extern "C"
 */

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The following defines are used to indicate the various release levels.
 */

#define TCL_ALPHA_RELEASE	0
#define TCL_BETA_RELEASE	1
#define TCL_FINAL_RELEASE	2

/*
 * When version numbers change here, must also go into the following files
 * and update the version numbers:
 *
 * library/init.tcl	(only if Major.minor changes, not patchlevel) 1 LOC
 * unix/configure.in	(2 LOC Major, 2 LOC minor, 1 LOC patch)
 * win/configure.in	(as above)
 * win/tcl.m4		(not patchlevel)
 * win/makefile.vc	(not patchlevel) 2 LOC
 * README		(sections 0 and 2)
 * mac/README		(2 LOC, not patchlevel)
 * macosx/Tcl.pbproj/project.pbxproj (not patchlevel) 1 LOC
 * macosx/Tcl.pbproj/default.pbxuser (not patchlevel) 1 LOC
 * win/README.binary	(sections 0-4)
 * win/README		(not patchlevel) (sections 0 and 2)
 * unix/tcl.spec	(2 LOC Major/Minor, 1 LOC patch)
 * tests/basic.test	(1 LOC M/M, not patchlevel)
 * tools/tcl.hpj.in	(not patchlevel, for windows installer)
 * tools/tcl.wse.in	(for windows installer)
 * tools/tclSplash.bmp	(not patchlevel)
 */
#define TCL_MAJOR_VERSION   8
#define TCL_MINOR_VERSION   4
#define TCL_RELEASE_LEVEL   TCL_FINAL_RELEASE
#define TCL_RELEASE_SERIAL  19

#define TCL_VERSION	    "8.4"
#define TCL_PATCH_LEVEL	    "8.4.19"

/*
 * The following definitions set up the proper options for Windows
 * compilers.  We use this method because there is no autoconf equivalent.
 */

#ifndef __WIN32__
#   if defined(_WIN32) || defined(WIN32) || defined(__MINGW32__) || defined(__BORLANDC__) || (defined(__WATCOMC__) && defined(__WINDOWS_386__))
#	define __WIN32__
#	ifndef WIN32
#	    define WIN32
#	endif
#	ifndef _WIN32
#	    define _WIN32
#	endif
#   endif
#endif

/*
 * STRICT: See MSDN Article Q83456
 */
#ifdef __WIN32__
#   ifndef STRICT
#	define STRICT
#   endif
#endif /* __WIN32__ */

/*
 * The following definitions set up the proper options for Macintosh
 * compilers.  We use this method because there is no autoconf equivalent.
 */

#ifdef MAC_TCL
#include <ConditionalMacros.h>
#   ifndef USE_TCLALLOC
#	define USE_TCLALLOC 1
#   endif
#   ifndef NO_STRERROR
#	define NO_STRERROR 1
#   endif
#   define INLINE 
#endif


/*
 * Utility macros: STRINGIFY takes an argument and wraps it in "" (double
 * quotation marks), JOIN joins two arguments.
 */
#ifndef STRINGIFY
#  define STRINGIFY(x) STRINGIFY1(x)
#  define STRINGIFY1(x) #x
#endif
#ifndef JOIN
#  define JOIN(a,b) JOIN1(a,b)
#  define JOIN1(a,b) a##b
#endif

/* 
 * A special definition used to allow this header file to be included
 * from windows or mac resource files so that they can obtain version
 * information.  RC_INVOKED is defined by default by the windows RC tool
 * and manually set for macintosh.
 *
 * Resource compilers don't like all the C stuff, like typedefs and
 * procedure declarations, that occur below, so block them out.
 */

#ifndef RC_INVOKED

/*
 * Special macro to define mutexes, that doesn't do anything
 * if we are not using threads.
 */

#ifdef TCL_THREADS
#define TCL_DECLARE_MUTEX(name) static Tcl_Mutex name;
#else
#define TCL_DECLARE_MUTEX(name)
#endif

/*
 * Macros that eliminate the overhead of the thread synchronization
 * functions when compiling without thread support.
 */

#ifndef TCL_THREADS
#define Tcl_MutexLock(mutexPtr)
#define Tcl_MutexUnlock(mutexPtr)
#define Tcl_MutexFinalize(mutexPtr)
#define Tcl_ConditionNotify(condPtr)
#define Tcl_ConditionWait(condPtr, mutexPtr, timePtr)
#define Tcl_ConditionFinalize(condPtr)
#endif /* TCL_THREADS */


#ifndef BUFSIZ
#   include <stdio.h>
#endif


/*
 * Definitions that allow Tcl functions with variable numbers of
 * arguments to be used with either varargs.h or stdarg.h.  TCL_VARARGS
 * is used in procedure prototypes.  TCL_VARARGS_DEF is used to declare
 * the arguments in a function definiton: it takes the type and name of
 * the first argument and supplies the appropriate argument declaration
 * string for use in the function definition.  TCL_VARARGS_START
 * initializes the va_list data structure and returns the first argument.
 */
#if !defined(NO_STDARG)
#   include <stdarg.h>
#   define TCL_VARARGS(type, name) (type name, ...)
#   define TCL_VARARGS_DEF(type, name) (type name, ...)
#   define TCL_VARARGS_START(type, name, list) (va_start(list, name), name)
#else
#   include <varargs.h>
#      define TCL_VARARGS(type, name) ()
#      define TCL_VARARGS_DEF(type, name) (va_alist)
#   define TCL_VARARGS_START(type, name, list) \
	(va_start(list), va_arg(list, type))
#endif

/*
 * Macros used to declare a function to be exported by a DLL.
 * Used by Windows, maps to no-op declarations on non-Windows systems.
 * The default build on windows is for a DLL, which causes the DLLIMPORT
 * and DLLEXPORT macros to be nonempty. To build a static library, the
 * macro STATIC_BUILD should be defined.
 */

#if (defined(__WIN32__) && (defined(_MSC_VER) || (__BORLANDC__ >= 0x0550) || defined(__LCC__) || defined(__WATCOMC__) || (defined(__GNUC__) && defined(__declspec))))
#   ifdef STATIC_BUILD
#       define DLLIMPORT
#       define DLLEXPORT
#   else
#       define DLLIMPORT __declspec(dllimport)
#       define DLLEXPORT __declspec(dllexport)
#   endif
#else
#   define DLLIMPORT
#   if defined(__GNUC__) && __GNUC__ > 3
#       define DLLEXPORT __attribute__ ((visibility("default")))
#   else
#       define DLLEXPORT
#   endif
#endif

/*
 * These macros are used to control whether functions are being declared for
 * import or export.  If a function is being declared while it is being built
 * to be included in a shared library, then it should have the DLLEXPORT
 * storage class.  If is being declared for use by a module that is going to
 * link against the shared library, then it should have the DLLIMPORT storage
 * class.  If the symbol is beind declared for a static build or for use from a
 * stub library, then the storage class should be empty.
 *
 * The convention is that a macro called BUILD_xxxx, where xxxx is the
 * name of a library we are building, is set on the compile line for sources
 * that are to be placed in the library.  When this macro is set, the
 * storage class will be set to DLLEXPORT.  At the end of the header file, the
 * storage class will be reset to DLLIMPORT.
 */
#undef TCL_STORAGE_CLASS
#ifdef BUILD_tcl
#   define TCL_STORAGE_CLASS DLLEXPORT
#else
#   ifdef USE_TCL_STUBS
#      define TCL_STORAGE_CLASS
#   else
#      define TCL_STORAGE_CLASS DLLIMPORT
#   endif
#endif


/*
 * Definitions that allow this header file to be used either with or
 * without ANSI C features like function prototypes.
 */
#undef _ANSI_ARGS_
#undef CONST
#ifndef INLINE
#   define INLINE
#endif

#ifndef NO_CONST
#   define CONST const
#else
#   define CONST
#endif

#ifndef NO_PROTOTYPES
#   define _ANSI_ARGS_(x)	x
#else
#   define _ANSI_ARGS_(x)	()
#endif

#ifdef USE_NON_CONST
#   ifdef USE_COMPAT_CONST
#      error define at most one of USE_NON_CONST and USE_COMPAT_CONST
#   endif
#   define CONST84
#   define CONST84_RETURN
#else
#   ifdef USE_COMPAT_CONST
#      define CONST84 
#      define CONST84_RETURN CONST
#   else
#      define CONST84 CONST
#      define CONST84_RETURN CONST
#   endif
#endif


/*
 * Make sure EXTERN isn't defined elsewhere
 */
#ifdef EXTERN
#   undef EXTERN
#endif /* EXTERN */

#ifdef __cplusplus
#   define EXTERN extern "C" TCL_STORAGE_CLASS
#else
#   define EXTERN extern TCL_STORAGE_CLASS
#endif


/*
 * The following code is copied from winnt.h.
 * If we don't replicate it here, then <windows.h> can't be included 
 * after tcl.h, since tcl.h also defines VOID.
 * This block is skipped under Cygwin and Mingw.
 * 
 * 
 */
#if defined(__WIN32__) && !defined(HAVE_WINNT_IGNORE_VOID)
#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif
#endif /* __WIN32__ && !HAVE_WINNT_IGNORE_VOID */

/*
 * Macro to use instead of "void" for arguments that must have
 * type "void *" in ANSI C;  maps them to type "char *" in
 * non-ANSI systems.
 */

#ifndef NO_VOID
#         define VOID void
#else
#         define VOID char
#endif

/*
 * Miscellaneous declarations.
 */

#ifndef _CLIENTDATA
#   ifndef NO_VOID
	typedef void *ClientData;
#   else
	typedef int *ClientData;
#   endif
#   define _CLIENTDATA
#endif

/*
 * Darwin specific configure overrides (to support fat compiles, where
 * configure runs only once for multiple architectures):
 */

#ifdef __APPLE__
#   ifdef __LP64__
#	undef TCL_WIDE_INT_TYPE
#	define TCL_WIDE_INT_IS_LONG 1
#    else /* !__LP64__ */
#	define TCL_WIDE_INT_TYPE long long
#	undef TCL_WIDE_INT_IS_LONG
#    endif /* __LP64__ */
#    undef HAVE_STRUCT_STAT64
#    include <mach/mach.h>
#endif /* __APPLE__ */

/*
 * Define Tcl_WideInt to be a type that is (at least) 64-bits wide,
 * and define Tcl_WideUInt to be the unsigned variant of that type
 * (assuming that where we have one, we can have the other.)
 *
 * Also defines the following macros:
 * TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on
 *	a real 64-bit system.)
 * Tcl_WideAsLong - forgetful converter from wideInt to long.
 * Tcl_LongAsWide - sign-extending converter from long to wideInt.
 * Tcl_WideAsDouble - converter from wideInt to double.
 * Tcl_DoubleAsWide - converter from double to wideInt.
 *
 * The following invariant should hold for any long value 'longVal':
 *	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
 *
 * Note on converting between Tcl_WideInt and strings.  This
 * implementation (in tclObj.c) depends on the functions strtoull()
 * and sprintf(...,"%" TCL_LL_MODIFIER "d",...).  TCL_LL_MODIFIER_SIZE
 * is the length of the modifier string, which is "ll" on most 32-bit
 * Unix systems.  It has to be split up like this to allow for the more
 * complex formats sometimes needed (e.g. in the format(n) command.)
 */

#if !defined(TCL_WIDE_INT_TYPE)&&!defined(TCL_WIDE_INT_IS_LONG)
#   if defined(__GNUC__)
#      define TCL_WIDE_INT_TYPE long long
#      if defined(__WIN32__) && !defined(__CYGWIN__)
#         define TCL_LL_MODIFIER        "I64"
#         define TCL_LL_MODIFIER_SIZE   3
#      else
#      define TCL_LL_MODIFIER	"ll"
#      define TCL_LL_MODIFIER_SIZE	2
#      endif
typedef struct stat	Tcl_StatBuf;
#   elif defined(__WIN32__)
#      define TCL_WIDE_INT_TYPE __int64
#      ifdef __BORLANDC__
typedef struct stati64 Tcl_StatBuf;
#         define TCL_LL_MODIFIER	"L"
#         define TCL_LL_MODIFIER_SIZE	1
#      else /* __BORLANDC__ */
#         if _MSC_VER < 1400 || !defined(_M_IX86)
typedef struct _stati64	Tcl_StatBuf;
#         else
typedef struct _stat64 Tcl_StatBuf;
#         endif /* _MSC_VER < 1400 */
#         define TCL_LL_MODIFIER	"I64"
#         define TCL_LL_MODIFIER_SIZE	3
#      endif /* __BORLANDC__ */
#   else /* __WIN32__ */
/*
 * Don't know what platform it is and configure hasn't discovered what
 * is going on for us.  Try to guess...
 */
#      ifdef NO_LIMITS_H
#	  error please define either TCL_WIDE_INT_TYPE or TCL_WIDE_INT_IS_LONG
#      else /* !NO_LIMITS_H */
#	  include <limits.h>
#	  if (INT_MAX < LONG_MAX)
#	     define TCL_WIDE_INT_IS_LONG	1
#	  else
#	     define TCL_WIDE_INT_TYPE long long
#         endif
#      endif /* NO_LIMITS_H */
#   endif /* __WIN32__ */
#endif /* !TCL_WIDE_INT_TYPE & !TCL_WIDE_INT_IS_LONG */
#ifdef TCL_WIDE_INT_IS_LONG
#   undef TCL_WIDE_INT_TYPE
#   define TCL_WIDE_INT_TYPE	long
#endif /* TCL_WIDE_INT_IS_LONG */

typedef TCL_WIDE_INT_TYPE		Tcl_WideInt;
typedef unsigned TCL_WIDE_INT_TYPE	Tcl_WideUInt;

#ifdef TCL_WIDE_INT_IS_LONG
typedef struct stat	Tcl_StatBuf;
#   define Tcl_WideAsLong(val)		((long)(val))
#   define Tcl_LongAsWide(val)		((long)(val))
#   define Tcl_WideAsDouble(val)	((double)((long)(val)))
#   define Tcl_DoubleAsWide(val)	((long)((double)(val)))
#   ifndef TCL_LL_MODIFIER
#      define TCL_LL_MODIFIER		"l"
#      define TCL_LL_MODIFIER_SIZE	1
#   endif /* !TCL_LL_MODIFIER */
#else /* TCL_WIDE_INT_IS_LONG */
/*
 * The next short section of defines are only done when not running on
 * Windows or some other strange platform.
 */
#   ifndef TCL_LL_MODIFIER
#      ifdef HAVE_STRUCT_STAT64
typedef struct stat64	Tcl_StatBuf;
#      else
typedef struct stat	Tcl_StatBuf;
#      endif /* HAVE_STRUCT_STAT64 */
#      define TCL_LL_MODIFIER		"ll"
#      define TCL_LL_MODIFIER_SIZE	2
#   endif /* !TCL_LL_MODIFIER */
#   define Tcl_WideAsLong(val)		((long)((Tcl_WideInt)(val)))
#   define Tcl_LongAsWide(val)		((Tcl_WideInt)((long)(val)))
#   define Tcl_WideAsDouble(val)	((double)((Tcl_WideInt)(val)))
#   define Tcl_DoubleAsWide(val)	((Tcl_WideInt)((double)(val)))
#endif /* TCL_WIDE_INT_IS_LONG */


/*
 * This flag controls whether binary compatability is maintained with
 * extensions built against a previous version of Tcl. This is true
 * by default.
 */
#ifndef TCL_PRESERVE_BINARY_COMPATABILITY
#   define TCL_PRESERVE_BINARY_COMPATABILITY 1
#endif


/*
 * Data structures defined opaquely in this module. The definitions below
 * just provide dummy types. A few fields are made visible in Tcl_Interp
 * structures, namely those used for returning a string result from
 * commands. Direct access to the result field is discouraged in Tcl 8.0.
 * The interpreter result is either an object or a string, and the two
 * values are kept consistent unless some C code sets interp->result
 * directly. Programmers should use either the procedure Tcl_GetObjResult()
 * or Tcl_GetStringResult() to read the interpreter's result. See the
 * SetResult man page for details.
 * 
 * Note: any change to the Tcl_Interp definition below must be mirrored
 * in the "real" definition in tclInt.h.
 *
 * Note: Tcl_ObjCmdProc procedures do not directly set result and freeProc.
 * Instead, they set a Tcl_Obj member in the "real" structure that can be
 * accessed with Tcl_GetObjResult() and Tcl_SetObjResult().
 */

typedef struct Tcl_Interp {
    char *result;		/* If the last command returned a string
				 * result, this points to it. */
    void (*freeProc) _ANSI_ARGS_((char *blockPtr));
				/* Zero means the string result is
				 * statically allocated. TCL_DYNAMIC means
				 * it was allocated with ckalloc and should
				 * be freed with ckfree. Other values give
				 * the address of procedure to invoke to
				 * free the result. Tcl_Eval must free it
				 * before executing next command. */
    int errorLine;              /* When TCL_ERROR is returned, this gives
                                 * the line number within the command where
                                 * the error occurred (1 if first line). */
} Tcl_Interp;

typedef struct Tcl_AsyncHandler_ *Tcl_AsyncHandler;
typedef struct Tcl_Channel_ *Tcl_Channel;
typedef struct Tcl_Command_ *Tcl_Command;
typedef struct Tcl_Condition_ *Tcl_Condition;
typedef struct Tcl_EncodingState_ *Tcl_EncodingState;
typedef struct Tcl_Encoding_ *Tcl_Encoding;
typedef struct Tcl_Event Tcl_Event;
typedef struct Tcl_Mutex_ *Tcl_Mutex;
typedef struct Tcl_Pid_ *Tcl_Pid;
typedef struct Tcl_RegExp_ *Tcl_RegExp;
typedef struct Tcl_ThreadDataKey_ *Tcl_ThreadDataKey;
typedef struct Tcl_ThreadId_ *Tcl_ThreadId;
typedef struct Tcl_TimerToken_ *Tcl_TimerToken;
typedef struct Tcl_Trace_ *Tcl_Trace;
typedef struct Tcl_Var_ *Tcl_Var;
typedef struct Tcl_ChannelTypeVersion_ *Tcl_ChannelTypeVersion;
typedef struct Tcl_LoadHandle_ *Tcl_LoadHandle;

/*
 * Definition of the interface to procedures implementing threads.
 * A procedure following this definition is given to each call of
 * 'Tcl_CreateThread' and will be called as the main fuction of
 * the new thread created by that call.
 */
#ifdef MAC_TCL
typedef pascal void *(Tcl_ThreadCreateProc) _ANSI_ARGS_((ClientData clientData));
#elif defined __WIN32__
typedef unsigned (__stdcall Tcl_ThreadCreateProc) _ANSI_ARGS_((ClientData clientData));
#else
typedef void (Tcl_ThreadCreateProc) _ANSI_ARGS_((ClientData clientData));
#endif


/*
 * Threading function return types used for abstracting away platform
 * differences when writing a Tcl_ThreadCreateProc.  See the NewThread
 * function in generic/tclThreadTest.c for it's usage.
 */
#ifdef MAC_TCL
#   define Tcl_ThreadCreateType		pascal void *
#   define TCL_THREAD_CREATE_RETURN	return NULL
#elif defined __WIN32__
#   define Tcl_ThreadCreateType		unsigned __stdcall
#   define TCL_THREAD_CREATE_RETURN	return 0
#else
#   define Tcl_ThreadCreateType		void
#   define TCL_THREAD_CREATE_RETURN	
#endif


/*
 * Definition of values for default stacksize and the possible flags to be
 * given to Tcl_CreateThread.
 */
#define TCL_THREAD_STACK_DEFAULT (0)    /* Use default size for stack */
#define TCL_THREAD_NOFLAGS       (0000) /* Standard flags, default behaviour */
#define TCL_THREAD_JOINABLE      (0001) /* Mark the thread as joinable */

/*
 * Flag values passed to Tcl_GetRegExpFromObj.
 */
#define	TCL_REG_BASIC		000000	/* BREs (convenience) */
#define	TCL_REG_EXTENDED	000001	/* EREs */
#define	TCL_REG_ADVF		000002	/* advanced features in EREs */
#define	TCL_REG_ADVANCED	000003	/* AREs (which are also EREs) */
#define	TCL_REG_QUOTE		000004	/* no special characters, none */
#define	TCL_REG_NOCASE		000010	/* ignore case */
#define	TCL_REG_NOSUB		000020	/* don't care about subexpressions */
#define	TCL_REG_EXPANDED	000040	/* expanded format, white space &
					 * comments */
#define	TCL_REG_NLSTOP		000100  /* \n doesn't match . or [^ ] */
#define	TCL_REG_NLANCH		000200  /* ^ matches after \n, $ before */
#define	TCL_REG_NEWLINE		000300  /* newlines are line terminators */
#define	TCL_REG_CANMATCH	001000  /* report details on partial/limited
					 * matches */

/*
 * The following flag is experimental and only intended for use by Expect.  It
 * will probably go away in a later release.
 */
#define TCL_REG_BOSONLY		002000	/* prepend \A to pattern so it only
					 * matches at the beginning of the
					 * string. */

/*
 * Flags values passed to Tcl_RegExpExecObj.
 */
#define	TCL_REG_NOTBOL	0001	/* Beginning of string does not match ^.  */
#define	TCL_REG_NOTEOL	0002	/* End of string does not match $. */

/*
 * Structures filled in by Tcl_RegExpInfo.  Note that all offset values are
 * relative to the start of the match string, not the beginning of the
 * entire string.
 */
typedef struct Tcl_RegExpIndices {
    long start;		/* character offset of first character in match */
    long end;		/* character offset of first character after the
			 * match. */
} Tcl_RegExpIndices;

typedef struct Tcl_RegExpInfo {
    int nsubs;			/* number of subexpressions in the
				 * compiled expression */
    Tcl_RegExpIndices *matches;	/* array of nsubs match offset
				 * pairs */
    long extendStart;		/* The offset at which a subsequent
				 * match might begin. */
    long reserved;		/* Reserved for later use. */
} Tcl_RegExpInfo;

/*
 * Picky compilers complain if this typdef doesn't appear before the
 * struct's reference in tclDecls.h.
 */
typedef Tcl_StatBuf *Tcl_Stat_;
typedef struct stat *Tcl_OldStat_;

/*
 * When a TCL command returns, the interpreter contains a result from the
 * command. Programmers are strongly encouraged to use one of the
 * procedures Tcl_GetObjResult() or Tcl_GetStringResult() to read the
 * interpreter's result. See the SetResult man page for details. Besides
 * this result, the command procedure returns an integer code, which is 
 * one of the following:
 *
 * TCL_OK		Command completed normally; the interpreter's
 *			result contains	the command's result.
 * TCL_ERROR		The command couldn't be completed successfully;
 *			the interpreter's result describes what went wrong.
 * TCL_RETURN		The command requests that the current procedure
 *			return; the interpreter's result contains the
 *			procedure's return value.
 * TCL_BREAK		The command requests that the innermost loop
 *			be exited; the interpreter's result is meaningless.
 * TCL_CONTINUE		Go on to the next iteration of the current loop;
 *			the interpreter's result is meaningless.
 */
#define TCL_OK		0
#define TCL_ERROR	1
#define TCL_RETURN	2
#define TCL_BREAK	3
#define TCL_CONTINUE	4

#define TCL_RESULT_SIZE 200

/*
 * Flags to control what substitutions are performed by Tcl_SubstObj():
 */
#define TCL_SUBST_COMMANDS	001
#define TCL_SUBST_VARIABLES	002
#define TCL_SUBST_BACKSLASHES	004
#define TCL_SUBST_ALL		007


/*
 * Argument descriptors for math function callbacks in expressions:
 */
typedef enum {
    TCL_INT, TCL_DOUBLE, TCL_EITHER, TCL_WIDE_INT
} Tcl_ValueType;
typedef struct Tcl_Value {
    Tcl_ValueType type;		/* Indicates intValue or doubleValue is
				 * valid, or both. */
    long intValue;		/* Integer value. */
    double doubleValue;		/* Double-precision floating value. */
    Tcl_WideInt wideValue;	/* Wide (min. 64-bit) integer value. */
} Tcl_Value;

/*
 * Forward declaration of Tcl_Obj to prevent an error when the forward
 * reference to Tcl_Obj is encountered in the procedure types declared 
 * below.
 */
struct Tcl_Obj;


/*
 * Procedure types defined by Tcl:
 */

typedef int (Tcl_AppInitProc) _ANSI_ARGS_((Tcl_Interp *interp));
typedef int (Tcl_AsyncProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int code));
typedef void (Tcl_ChannelProc) _ANSI_ARGS_((ClientData clientData, int mask));
typedef void (Tcl_CloseProc) _ANSI_ARGS_((ClientData data));
typedef void (Tcl_CmdDeleteProc) _ANSI_ARGS_((ClientData clientData));
typedef int (Tcl_CmdProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int argc, CONST84 char *argv[]));
typedef void (Tcl_CmdTraceProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int level, char *command, Tcl_CmdProc *proc,
	ClientData cmdClientData, int argc, CONST84 char *argv[]));
typedef int (Tcl_CmdObjTraceProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int level, CONST char *command,
	Tcl_Command commandInfo, int objc, struct Tcl_Obj * CONST * objv));
typedef void (Tcl_CmdObjTraceDeleteProc) _ANSI_ARGS_((ClientData clientData));
typedef void (Tcl_DupInternalRepProc) _ANSI_ARGS_((struct Tcl_Obj *srcPtr, 
        struct Tcl_Obj *dupPtr));
typedef int (Tcl_EncodingConvertProc)_ANSI_ARGS_((ClientData clientData,
	CONST char *src, int srcLen, int flags, Tcl_EncodingState *statePtr,
	char *dst, int dstLen, int *srcReadPtr, int *dstWrotePtr,
	int *dstCharsPtr));
typedef void (Tcl_EncodingFreeProc)_ANSI_ARGS_((ClientData clientData));
typedef int (Tcl_EventProc) _ANSI_ARGS_((Tcl_Event *evPtr, int flags));
typedef void (Tcl_EventCheckProc) _ANSI_ARGS_((ClientData clientData,
	int flags));
typedef int (Tcl_EventDeleteProc) _ANSI_ARGS_((Tcl_Event *evPtr,
        ClientData clientData));
typedef void (Tcl_EventSetupProc) _ANSI_ARGS_((ClientData clientData,
	int flags));
typedef void (Tcl_ExitProc) _ANSI_ARGS_((ClientData clientData));
typedef void (Tcl_FileProc) _ANSI_ARGS_((ClientData clientData, int mask));
typedef void (Tcl_FileFreeProc) _ANSI_ARGS_((ClientData clientData));
typedef void (Tcl_FreeInternalRepProc) _ANSI_ARGS_((struct Tcl_Obj *objPtr));
typedef void (Tcl_FreeProc) _ANSI_ARGS_((char *blockPtr));
typedef void (Tcl_IdleProc) _ANSI_ARGS_((ClientData clientData));
typedef void (Tcl_InterpDeleteProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp));
typedef int (Tcl_MathProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tcl_Value *args, Tcl_Value *resultPtr));
typedef void (Tcl_NamespaceDeleteProc) _ANSI_ARGS_((ClientData clientData));
typedef int (Tcl_ObjCmdProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int objc, struct Tcl_Obj * CONST * objv));
typedef int (Tcl_PackageInitProc) _ANSI_ARGS_((Tcl_Interp *interp));
typedef void (Tcl_PanicProc) _ANSI_ARGS_(TCL_VARARGS(CONST char *, format));
typedef void (Tcl_TcpAcceptProc) _ANSI_ARGS_((ClientData callbackData,
        Tcl_Channel chan, char *address, int port));
typedef void (Tcl_TimerProc) _ANSI_ARGS_((ClientData clientData));
typedef int (Tcl_SetFromAnyProc) _ANSI_ARGS_((Tcl_Interp *interp,
	struct Tcl_Obj *objPtr));
typedef void (Tcl_UpdateStringProc) _ANSI_ARGS_((struct Tcl_Obj *objPtr));
typedef char *(Tcl_VarTraceProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, CONST84 char *part1, CONST84 char *part2, int flags));
typedef void (Tcl_CommandTraceProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, CONST char *oldName, CONST char *newName,
	int flags));
typedef void (Tcl_CreateFileHandlerProc) _ANSI_ARGS_((int fd, int mask,
	Tcl_FileProc *proc, ClientData clientData));
typedef void (Tcl_DeleteFileHandlerProc) _ANSI_ARGS_((int fd));
typedef void (Tcl_AlertNotifierProc) _ANSI_ARGS_((ClientData clientData));
typedef void (Tcl_ServiceModeHookProc) _ANSI_ARGS_((int mode));
typedef ClientData (Tcl_InitNotifierProc) _ANSI_ARGS_((VOID));
typedef void (Tcl_FinalizeNotifierProc) _ANSI_ARGS_((ClientData clientData));
typedef void (Tcl_MainLoopProc) _ANSI_ARGS_((void));

/*
 * The following structure represents a type of object, which is a
 * particular internal representation for an object plus a set of
 * procedures that provide standard operations on objects of that type.
 */

typedef struct Tcl_ObjType {
    char *name;			/* Name of the type, e.g. "int". */
    Tcl_FreeInternalRepProc *freeIntRepProc;
				/* Called to free any storage for the type's
				 * internal rep. NULL if the internal rep
				 * does not need freeing. */
    Tcl_DupInternalRepProc *dupIntRepProc;
    				/* Called to create a new object as a copy
				 * of an existing object. */
    Tcl_UpdateStringProc *updateStringProc;
    				/* Called to update the string rep from the
				 * type's internal representation. */
    Tcl_SetFromAnyProc *setFromAnyProc;
    				/* Called to convert the object's internal
				 * rep to this type. Frees the internal rep
				 * of the old type. Returns TCL_ERROR on
				 * failure. */
} Tcl_ObjType;


/*
 * One of the following structures exists for each object in the Tcl
 * system. An object stores a value as either a string, some internal
 * representation, or both.
 */

typedef struct Tcl_Obj {
    int refCount;		/* When 0 the object will be freed. */
    char *bytes;		/* This points to the first byte of the
				 * object's string representation. The array
				 * must be followed by a null byte (i.e., at
				 * offset length) but may also contain
				 * embedded null characters. The array's
				 * storage is allocated by ckalloc. NULL
				 * means the string rep is invalid and must
				 * be regenerated from the internal rep.
				 * Clients should use Tcl_GetStringFromObj
				 * or Tcl_GetString to get a pointer to the
				 * byte array as a readonly value. */
    int length;			/* The number of bytes at *bytes, not
				 * including the terminating null. */
    Tcl_ObjType *typePtr;	/* Denotes the object's type. Always
				 * corresponds to the type of the object's
				 * internal rep. NULL indicates the object
				 * has no internal rep (has no type). */
    union {			/* The internal representation: */
	long longValue;		/*   - an long integer value */
	double doubleValue;	/*   - a double-precision floating value */
	VOID *otherValuePtr;	/*   - another, type-specific value */
	Tcl_WideInt wideValue;	/*   - a long long value */
	struct {		/*   - internal rep as two pointers */
	    VOID *ptr1;
	    VOID *ptr2;
	} twoPtrValue;
    } internalRep;
} Tcl_Obj;


/*
 * Macros to increment and decrement a Tcl_Obj's reference count, and to
 * test whether an object is shared (i.e. has reference count > 1).
 * Note: clients should use Tcl_DecrRefCount() when they are finished using
 * an object, and should never call TclFreeObj() directly. TclFreeObj() is
 * only defined and made public in tcl.h to support Tcl_DecrRefCount's macro
 * definition. Note also that Tcl_DecrRefCount() refers to the parameter
 * "obj" twice. This means that you should avoid calling it with an
 * expression that is expensive to compute or has side effects.
 */
void		Tcl_IncrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));
void		Tcl_DecrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));
int		Tcl_IsShared _ANSI_ARGS_((Tcl_Obj *objPtr));

#ifdef TCL_MEM_DEBUG
#   define Tcl_IncrRefCount(objPtr) \
	Tcl_DbIncrRefCount(objPtr, __FILE__, __LINE__)
#   define Tcl_DecrRefCount(objPtr) \
	Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
#   define Tcl_IsShared(objPtr) \
	Tcl_DbIsShared(objPtr, __FILE__, __LINE__)
#else
#   define Tcl_IncrRefCount(objPtr) \
	++(objPtr)->refCount
    /*
     * Use do/while0 idiom for optimum correctness without compiler warnings
     * http://c2.com/cgi/wiki?TrivialDoWhileLoop
     */
#   define Tcl_DecrRefCount(objPtr) \
	do { if (--(objPtr)->refCount <= 0) TclFreeObj(objPtr); } while(0)
#   define Tcl_IsShared(objPtr) \
	((objPtr)->refCount > 1)
#endif

/*
 * Macros and definitions that help to debug the use of Tcl objects.
 * When TCL_MEM_DEBUG is defined, the Tcl_New declarations are 
 * overridden to call debugging versions of the object creation procedures.
 */

#ifdef TCL_MEM_DEBUG
#  define Tcl_NewBooleanObj(val) \
     Tcl_DbNewBooleanObj(val, __FILE__, __LINE__)
#  define Tcl_NewByteArrayObj(bytes, len) \
     Tcl_DbNewByteArrayObj(bytes, len, __FILE__, __LINE__)
#  define Tcl_NewDoubleObj(val) \
     Tcl_DbNewDoubleObj(val, __FILE__, __LINE__)
#  define Tcl_NewIntObj(val) \
     Tcl_DbNewLongObj(val, __FILE__, __LINE__)
#  define Tcl_NewListObj(objc, objv) \
     Tcl_DbNewListObj(objc, objv, __FILE__, __LINE__)
#  define Tcl_NewLongObj(val) \
     Tcl_DbNewLongObj(val, __FILE__, __LINE__)
#  define Tcl_NewObj() \
     Tcl_DbNewObj(__FILE__, __LINE__)
#  define Tcl_NewStringObj(bytes, len) \
     Tcl_DbNewStringObj(bytes, len, __FILE__, __LINE__)
#  define Tcl_NewWideIntObj(val) \
     Tcl_DbNewWideIntObj(val, __FILE__, __LINE__)
#endif /* TCL_MEM_DEBUG */


/*
 * The following structure contains the state needed by
 * Tcl_SaveResult.  No-one outside of Tcl should access any of these
 * fields.  This structure is typically allocated on the stack.
 */
typedef struct Tcl_SavedResult {
    char *result;
    Tcl_FreeProc *freeProc;
    Tcl_Obj *objResultPtr;
    char *appendResult;
    int appendAvl;
    int appendUsed;
    char resultSpace[TCL_RESULT_SIZE+1];
} Tcl_SavedResult;


/*
 * The following definitions support Tcl's namespace facility.
 * Note: the first five fields must match exactly the fields in a
 * Namespace structure (see tclInt.h). 
 */

typedef struct Tcl_Namespace {
    char *name;                 /* The namespace's name within its parent
				 * namespace. This contains no ::'s. The
				 * name of the global namespace is ""
				 * although "::" is an synonym. */
    char *fullName;             /* The namespace's fully qualified name.
				 * This starts with ::. */
    ClientData clientData;      /* Arbitrary value associated with this
				 * namespace. */
    Tcl_NamespaceDeleteProc* deleteProc;
                                /* Procedure invoked when deleting the
				 * namespace to, e.g., free clientData. */
    struct Tcl_Namespace* parentPtr;
                                /* Points to the namespace that contains
				 * this one. NULL if this is the global
				 * namespace. */
} Tcl_Namespace;


/*
 * The following structure represents a call frame, or activation record.
 * A call frame defines a naming context for a procedure call: its local
 * scope (for local variables) and its namespace scope (used for non-local
 * variables; often the global :: namespace). A call frame can also define
 * the naming context for a namespace eval or namespace inscope command:
 * the namespace in which the command's code should execute. The
 * Tcl_CallFrame structures exist only while procedures or namespace
 * eval/inscope's are being executed, and provide a Tcl call stack.
 * 
 * A call frame is initialized and pushed using Tcl_PushCallFrame and
 * popped using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be
 * provided by the Tcl_PushCallFrame caller, and callers typically allocate
 * them on the C call stack for efficiency. For this reason, Tcl_CallFrame
 * is defined as a structure and not as an opaque token. However, most
 * Tcl_CallFrame fields are hidden since applications should not access
 * them directly; others are declared as "dummyX".
 *
 * WARNING!! The structure definition must be kept consistent with the
 * CallFrame structure in tclInt.h. If you change one, change the other.
 */

typedef struct Tcl_CallFrame {
    Tcl_Namespace *nsPtr;
    int dummy1;
    int dummy2;
    VOID *dummy3;
    VOID *dummy4;
    VOID *dummy5;
    int dummy6;
    VOID *dummy7;
    VOID *dummy8;
    int dummy9;
    VOID *dummy10;
    VOID *dummy11;
    VOID *dummy12;
    VOID *dummy13;
} Tcl_CallFrame;


/*
 * Information about commands that is returned by Tcl_GetCommandInfo and
 * passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based
 * command procedure while proc is a traditional Tcl argc/argv
 * string-based procedure. Tcl_CreateObjCommand and Tcl_CreateCommand
 * ensure that both objProc and proc are non-NULL and can be called to
 * execute the command. However, it may be faster to call one instead of
 * the other. The member isNativeObjectProc is set to 1 if an
 * object-based procedure was registered by Tcl_CreateObjCommand, and to
 * 0 if a string-based procedure was registered by Tcl_CreateCommand.
 * The other procedure is typically set to a compatibility wrapper that
 * does string-to-object or object-to-string argument conversions then
 * calls the other procedure.
 */

typedef struct Tcl_CmdInfo {
    int isNativeObjectProc;	 /* 1 if objProc was registered by a call to
				  * Tcl_CreateObjCommand; 0 otherwise.
				  * Tcl_SetCmdInfo does not modify this
				  * field. */
    Tcl_ObjCmdProc *objProc;	 /* Command's object-based procedure. */
    ClientData objClientData;	 /* ClientData for object proc. */
    Tcl_CmdProc *proc;		 /* Command's string-based procedure. */
    ClientData clientData;	 /* ClientData for string proc. */
    Tcl_CmdDeleteProc *deleteProc;
                                 /* Procedure to call when command is
                                  * deleted. */
    ClientData deleteData;	 /* Value to pass to deleteProc (usually
				  * the same as clientData). */
    Tcl_Namespace *namespacePtr; /* Points to the namespace that contains
				  * this command. Note that Tcl_SetCmdInfo
				  * will not change a command's namespace;
				  * use Tcl_RenameCommand to do that. */

} Tcl_CmdInfo;

/*
 * The structure defined below is used to hold dynamic strings.  The only
 * field that clients should use is the string field, accessible via the
 * macro Tcl_DStringValue.  
 */
#define TCL_DSTRING_STATIC_SIZE 200
typedef struct Tcl_DString {
    char *string;		/* Points to beginning of string:  either
				 * staticSpace below or a malloced array. */
    int length;			/* Number of non-NULL characters in the
				 * string. */
    int spaceAvl;		/* Total number of bytes available for the
				 * string and its terminating NULL char. */
    char staticSpace[TCL_DSTRING_STATIC_SIZE];
				/* Space to use in common case where string
				 * is small. */
} Tcl_DString;

#define Tcl_DStringLength(dsPtr) ((dsPtr)->length)
#define Tcl_DStringValue(dsPtr) ((dsPtr)->string)
#define Tcl_DStringTrunc Tcl_DStringSetLength

/*
 * Definitions for the maximum number of digits of precision that may
 * be specified in the "tcl_precision" variable, and the number of
 * bytes of buffer space required by Tcl_PrintDouble.
 */
#define TCL_MAX_PREC 17
#define TCL_DOUBLE_SPACE (TCL_MAX_PREC+10)

/*
 * Definition for a number of bytes of buffer space sufficient to hold the
 * string representation of an integer in base 10 (assuming the existence
 * of 64-bit integers).
 */
#define TCL_INTEGER_SPACE	24

/*
 * Flag that may be passed to Tcl_ConvertElement to force it not to
 * output braces (careful!  if you change this flag be sure to change
 * the definitions at the front of tclUtil.c).
 */
#define TCL_DONT_USE_BRACES	1

/*
 * Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
 * abbreviated strings.
 */
#define TCL_EXACT	1

/*
 * Flag values passed to Tcl_RecordAndEval and/or Tcl_EvalObj.
 * WARNING: these bit choices must not conflict with the bit choices
 * for evalFlag bits in tclInt.h!!
 */
#define TCL_NO_EVAL		0x10000
#define TCL_EVAL_GLOBAL		0x20000
#define TCL_EVAL_DIRECT		0x40000
#define TCL_EVAL_INVOKE	        0x80000

/*
 * Special freeProc values that may be passed to Tcl_SetResult (see
 * the man page for details):
 */
#define TCL_VOLATILE	((Tcl_FreeProc *) 1)
#define TCL_STATIC	((Tcl_FreeProc *) 0)
#define TCL_DYNAMIC	((Tcl_FreeProc *) 3)

/*
 * Flag values passed to variable-related procedures.
 */
#define TCL_GLOBAL_ONLY		 1
#define TCL_NAMESPACE_ONLY	 2
#define TCL_APPEND_VALUE	 4
#define TCL_LIST_ELEMENT	 8
#define TCL_TRACE_READS		 0x10
#define TCL_TRACE_WRITES	 0x20
#define TCL_TRACE_UNSETS	 0x40
#define TCL_TRACE_DESTROYED	 0x80
#define TCL_INTERP_DESTROYED	 0x100
#define TCL_LEAVE_ERR_MSG	 0x200
#define TCL_TRACE_ARRAY		 0x800
#ifndef TCL_REMOVE_OBSOLETE_TRACES
/* Required to support old variable/vdelete/vinfo traces */
#define TCL_TRACE_OLD_STYLE	 0x1000
#endif
/* Indicate the semantics of the result of a trace */
#define TCL_TRACE_RESULT_DYNAMIC 0x8000
#define TCL_TRACE_RESULT_OBJECT  0x10000

/*
 * Flag values passed to command-related procedures.
 */

#define TCL_TRACE_RENAME 0x2000
#define TCL_TRACE_DELETE 0x4000

#define TCL_ALLOW_INLINE_COMPILATION 0x20000

/*
 * Flag values passed to Tcl_CreateObjTrace, and used internally
 * by command execution traces.  Slots 4,8,16 and 32 are
 * used internally by execution traces (see tclCmdMZ.c)
 */
#define TCL_TRACE_ENTER_EXEC		1
#define TCL_TRACE_LEAVE_EXEC		2

/*
 * The TCL_PARSE_PART1 flag is deprecated and has no effect. 
 * The part1 is now always parsed whenever the part2 is NULL.
 * (This is to avoid a common error when converting code to
 *  use the new object based APIs and forgetting to give the
 *  flag)
 */
#ifndef TCL_NO_DEPRECATED
#   define TCL_PARSE_PART1      0x400
#endif


/*
 * Types for linked variables:
 */
#define TCL_LINK_INT		1
#define TCL_LINK_DOUBLE		2
#define TCL_LINK_BOOLEAN	3
#define TCL_LINK_STRING		4
#define TCL_LINK_WIDE_INT	5
#define TCL_LINK_READ_ONLY	0x80


/*
 * Forward declarations of Tcl_HashTable and related types.
 */
typedef struct Tcl_HashKeyType Tcl_HashKeyType;
typedef struct Tcl_HashTable Tcl_HashTable;
typedef struct Tcl_HashEntry Tcl_HashEntry;

typedef unsigned int (Tcl_HashKeyProc) _ANSI_ARGS_((Tcl_HashTable *tablePtr,
	VOID *keyPtr));
typedef int (Tcl_CompareHashKeysProc) _ANSI_ARGS_((VOID *keyPtr,
	Tcl_HashEntry *hPtr));
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) _ANSI_ARGS_((
	Tcl_HashTable *tablePtr, VOID *keyPtr));
typedef void (Tcl_FreeHashEntryProc) _ANSI_ARGS_((Tcl_HashEntry *hPtr));

/*
 * This flag controls whether the hash table stores the hash of a key, or
 * recalculates it. There should be no reason for turning this flag off
 * as it is completely binary and source compatible unless you directly
 * access the bucketPtr member of the Tcl_HashTableEntry structure. This
 * member has been removed and the space used to store the hash value.
 */
#ifndef TCL_HASH_KEY_STORE_HASH
#   define TCL_HASH_KEY_STORE_HASH 1
#endif

/*
 * Structure definition for an entry in a hash table.  No-one outside
 * Tcl should access any of these fields directly;  use the macros
 * defined below.
 */

struct Tcl_HashEntry {
    Tcl_HashEntry *nextPtr;		/* Pointer to next entry in this
					 * hash bucket, or NULL for end of
					 * chain. */
    Tcl_HashTable *tablePtr;		/* Pointer to table containing entry. */
#if TCL_HASH_KEY_STORE_HASH
#   if TCL_PRESERVE_BINARY_COMPATABILITY
    VOID *hash;				/* Hash value, stored as pointer to
					 * ensure that the offsets of the
					 * fields in this structure are not
					 * changed. */
#   else
    unsigned int hash;			/* Hash value. */
#   endif
#else
    Tcl_HashEntry **bucketPtr;		/* Pointer to bucket that points to
					 * first entry in this entry's chain:
					 * used for deleting the entry. */
#endif
    ClientData clientData;		/* Application stores something here
					 * with Tcl_SetHashValue. */
    union {				/* Key has one of these forms: */
	char *oneWordValue;		/* One-word value for key. */
        Tcl_Obj *objPtr;		/* Tcl_Obj * key value. */
	int words[1];			/* Multiple integer words for key.
					 * The actual size will be as large
					 * as necessary for this table's
					 * keys. */
	char string[4];			/* String for key.  The actual size
					 * will be as large as needed to hold
					 * the key. */
    } key;				/* MUST BE LAST FIELD IN RECORD!! */
};

/*
 * Flags used in Tcl_HashKeyType.
 *
 * TCL_HASH_KEY_RANDOMIZE_HASH:
 *				There are some things, pointers for example
 *				which don't hash well because they do not use
 *				the lower bits. If this flag is set then the
 *				hash table will attempt to rectify this by
 *				randomising the bits and then using the upper
 *				N bits as the index into the table.
 */
#define TCL_HASH_KEY_RANDOMIZE_HASH 0x1

/*
 * Structure definition for the methods associated with a hash table
 * key type.
 */
#define TCL_HASH_KEY_TYPE_VERSION 1
struct Tcl_HashKeyType {
    int version;		/* Version of the table. If this structure is
				 * extended in future then the version can be
				 * used to distinguish between different
				 * structures. 
				 */

    int flags;			/* Flags, see above for details. */

    /* Calculates a hash value for the key. If this is NULL then the pointer
     * itself is used as a hash value.
     */
    Tcl_HashKeyProc *hashKeyProc;

    /* Compares two keys and returns zero if they do not match, and non-zero
     * if they do. If this is NULL then the pointers are compared.
     */
    Tcl_CompareHashKeysProc *compareKeysProc;

    /* Called to allocate memory for a new entry, i.e. if the key is a
     * string then this could allocate a single block which contains enough
     * space for both the entry and the string. Only the key field of the
     * allocated Tcl_HashEntry structure needs to be filled in. If something
     * else needs to be done to the key, i.e. incrementing a reference count
     * then that should be done by this function. If this is NULL then Tcl_Alloc
     * is used to allocate enough space for a Tcl_HashEntry and the key pointer
     * is assigned to key.oneWordValue.
     */
    Tcl_AllocHashEntryProc *allocEntryProc;

    /* Called to free memory associated with an entry. If something else needs
     * to be done to the key, i.e. decrementing a reference count then that
     * should be done by this function. If this is NULL then Tcl_Free is used
     * to free the Tcl_HashEntry.
     */
    Tcl_FreeHashEntryProc *freeEntryProc;
};

/*
 * Structure definition for a hash table.  Must be in tcl.h so clients
 * can allocate space for these structures, but clients should never
 * access any fields in this structure.
 */

#define TCL_SMALL_HASH_TABLE 4
struct Tcl_HashTable {
    Tcl_HashEntry **buckets;		/* Pointer to bucket array.  Each
					 * element points to first entry in
					 * bucket's hash chain, or NULL. */
    Tcl_HashEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
					/* Bucket array used for small tables
					 * (to avoid mallocs and frees). */
    int numBuckets;			/* Total number of buckets allocated
					 * at **bucketPtr. */
    int numEntries;			/* Total number of entries present
					 * in table. */
    int rebuildSize;			/* Enlarge table when numEntries gets
					 * to be this large. */
    int downShift;			/* Shift count used in hashing
					 * function.  Designed to use high-
					 * order bits of randomized keys. */
    int mask;				/* Mask value used in hashing
					 * function. */
    int keyType;			/* Type of keys used in this table. 
					 * It's either TCL_CUSTOM_KEYS,
					 * TCL_STRING_KEYS, TCL_ONE_WORD_KEYS,
					 * or an integer giving the number of
					 * ints that is the size of the key.
					 */
#if TCL_PRESERVE_BINARY_COMPATABILITY
    Tcl_HashEntry *(*findProc) _ANSI_ARGS_((Tcl_HashTable *tablePtr,
	    CONST char *key));
    Tcl_HashEntry *(*createProc) _ANSI_ARGS_((Tcl_HashTable *tablePtr,
	    CONST char *key, int *newPtr));
#endif
    Tcl_HashKeyType *typePtr;		/* Type of the keys used in the
					 * Tcl_HashTable. */
};

/*
 * Structure definition for information used to keep track of searches
 * through hash tables:
 */

typedef struct Tcl_HashSearch {
    Tcl_HashTable *tablePtr;		/* Table being searched. */
    int nextIndex;			/* Index of next bucket to be
					 * enumerated after present one. */
    Tcl_HashEntry *nextEntryPtr;	/* Next entry to be enumerated in the
					 * the current bucket. */
} Tcl_HashSearch;

/*
 * Acceptable key types for hash tables:
 *
 * TCL_STRING_KEYS:		The keys are strings, they are copied into
 *				the entry.
 * TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
 *				in the entry.
 * TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
 *				into the entry.
 * TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
 *				pointer is stored in the entry.
 *
 * While maintaining binary compatability the above have to be distinct
 * values as they are used to differentiate between old versions of the
 * hash table which don't have a typePtr and new ones which do. Once binary
 * compatability is discarded in favour of making more wide spread changes
 * TCL_STRING_KEYS can be the same as TCL_CUSTOM_TYPE_KEYS, and
 * TCL_ONE_WORD_KEYS can be the same as TCL_CUSTOM_PTR_KEYS because they
 * simply determine how the key is accessed from the entry and not the
 * behaviour.
 */

#define TCL_STRING_KEYS		0
#define TCL_ONE_WORD_KEYS	1

#if TCL_PRESERVE_BINARY_COMPATABILITY
#   define TCL_CUSTOM_TYPE_KEYS		-2
#   define TCL_CUSTOM_PTR_KEYS		-1
#else
#   define TCL_CUSTOM_TYPE_KEYS		TCL_STRING_KEYS
#   define TCL_CUSTOM_PTR_KEYS		TCL_ONE_WORD_KEYS
#endif

/*
 * Macros for clients to use to access fields of hash entries:
 */

#define Tcl_GetHashValue(h) ((h)->clientData)
#define Tcl_SetHashValue(h, value) ((h)->clientData = (ClientData) (value))
#if TCL_PRESERVE_BINARY_COMPATABILITY
#   define Tcl_GetHashKey(tablePtr, h) \
	((char *) (((tablePtr)->keyType == TCL_ONE_WORD_KEYS || \
		    (tablePtr)->keyType == TCL_CUSTOM_PTR_KEYS) \
		   ? (h)->key.oneWordValue \
		   : (h)->key.string))
#else
#   define Tcl_GetHashKey(tablePtr, h) \
	((char *) (((tablePtr)->keyType == TCL_ONE_WORD_KEYS) \
		   ? (h)->key.oneWordValue \
		   : (h)->key.string))
#endif

/*
 * Macros to use for clients to use to invoke find and create procedures
 * for hash tables:
 */

#if TCL_PRESERVE_BINARY_COMPATABILITY
#   define Tcl_FindHashEntry(tablePtr, key) \
	(*((tablePtr)->findProc))(tablePtr, key)
#   define Tcl_CreateHashEntry(tablePtr, key, newPtr) \
	(*((tablePtr)->createProc))(tablePtr, key, newPtr)
#else /* !TCL_PRESERVE_BINARY_COMPATABILITY */
/*
 * Macro to use new extended version of Tcl_InitHashTable.
 */
#   define Tcl_InitHashTable(tablePtr, keyType) \
	Tcl_InitHashTableEx(tablePtr, keyType, NULL)
#endif /* TCL_PRESERVE_BINARY_COMPATABILITY */


/*
 * Flag values to pass to Tcl_DoOneEvent to disable searches
 * for some kinds of events:
 */
#define TCL_DONT_WAIT		(1<<1)
#define TCL_WINDOW_EVENTS	(1<<2)
#define TCL_FILE_EVENTS		(1<<3)
#define TCL_TIMER_EVENTS	(1<<4)
#define TCL_IDLE_EVENTS		(1<<5)	/* WAS 0x10 ???? */
#define TCL_ALL_EVENTS		(~TCL_DONT_WAIT)

/*
 * The following structure defines a generic event for the Tcl event
 * system.  These are the things that are queued in calls to Tcl_QueueEvent
 * and serviced later by Tcl_DoOneEvent.  There can be many different
 * kinds of events with different fields, corresponding to window events,
 * timer events, etc.  The structure for a particular event consists of
 * a Tcl_Event header followed by additional information specific to that
 * event.
 */
struct Tcl_Event {
    Tcl_EventProc *proc;	/* Procedure to call to service this event. */
    struct Tcl_Event *nextPtr;	/* Next in list of pending events, or NULL. */
};

/*
 * Positions to pass to Tcl_QueueEvent:
 */
typedef enum {
    TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, TCL_QUEUE_MARK
} Tcl_QueuePosition;

/*
 * Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
 * event routines.
 */
#define TCL_SERVICE_NONE 0
#define TCL_SERVICE_ALL 1


/*
 * The following structure keeps is used to hold a time value, either as
 * an absolute time (the number of seconds from the epoch) or as an
 * elapsed time. On Unix systems the epoch is Midnight Jan 1, 1970 GMT.
 * On Macintosh systems the epoch is Midnight Jan 1, 1904 GMT.
 */
typedef struct Tcl_Time {
    long sec;			/* Seconds. */
    long usec;			/* Microseconds. */
} Tcl_Time;

typedef void (Tcl_SetTimerProc) _ANSI_ARGS_((Tcl_Time *timePtr));
typedef int (Tcl_WaitForEventProc) _ANSI_ARGS_((Tcl_Time *timePtr));


/*
 * Bits to pass to Tcl_CreateFileHandler and Tcl_CreateChannelHandler
 * to indicate what sorts of events are of interest:
 */
#define TCL_READABLE	(1<<1)
#define TCL_WRITABLE	(1<<2)
#define TCL_EXCEPTION	(1<<3)

/*
 * Flag values to pass to Tcl_OpenCommandChannel to indicate the
 * disposition of the stdio handles.  TCL_STDIN, TCL_STDOUT, TCL_STDERR,
 * are also used in Tcl_GetStdChannel.
 */
#define TCL_STDIN		(1<<1)	
#define TCL_STDOUT		(1<<2)
#define TCL_STDERR		(1<<3)
#define TCL_ENFORCE_MODE	(1<<4)

/*
 * Bits passed to Tcl_DriverClose2Proc to indicate which side of a channel
 * should be closed.
 */
#define TCL_CLOSE_READ	(1<<1)
#define TCL_CLOSE_WRITE	(1<<2)

/*
 * Value to use as the closeProc for a channel that supports the
 * close2Proc interface.
 */
#define TCL_CLOSE2PROC	((Tcl_DriverCloseProc *)1)

/*
 * Channel version tag.  This was introduced in 8.3.2/8.4.
 */
#define TCL_CHANNEL_VERSION_1	((Tcl_ChannelTypeVersion) 0x1)
#define TCL_CHANNEL_VERSION_2	((Tcl_ChannelTypeVersion) 0x2)
#define TCL_CHANNEL_VERSION_3	((Tcl_ChannelTypeVersion) 0x3)
#define TCL_CHANNEL_VERSION_4	((Tcl_ChannelTypeVersion) 0x4)

/*
 * TIP #218: Channel Actions, Ids for Tcl_DriverThreadActionProc
 */

#define TCL_CHANNEL_THREAD_INSERT (0)
#define TCL_CHANNEL_THREAD_REMOVE (1)

/*
 * Typedefs for the various operations in a channel type:
 */
typedef int	(Tcl_DriverBlockModeProc) _ANSI_ARGS_((
		    ClientData instanceData, int mode));
typedef int	(Tcl_DriverCloseProc) _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp));
typedef int	(Tcl_DriverClose2Proc) _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp, int flags));
typedef int	(Tcl_DriverInputProc) _ANSI_ARGS_((ClientData instanceData,
		    char *buf, int toRead, int *errorCodePtr));
typedef int	(Tcl_DriverOutputProc) _ANSI_ARGS_((ClientData instanceData,
		    CONST84 char *buf, int toWrite, int *errorCodePtr));
typedef int	(Tcl_DriverSeekProc) _ANSI_ARGS_((ClientData instanceData,
		    long offset, int mode, int *errorCodePtr));
typedef int	(Tcl_DriverSetOptionProc) _ANSI_ARGS_((
		    ClientData instanceData, Tcl_Interp *interp,
	            CONST char *optionName, CONST char *value));
typedef int	(Tcl_DriverGetOptionProc) _ANSI_ARGS_((
		    ClientData instanceData, Tcl_Interp *interp,
		    CONST84 char *optionName, Tcl_DString *dsPtr));
typedef void	(Tcl_DriverWatchProc) _ANSI_ARGS_((
		    ClientData instanceData, int mask));
typedef int	(Tcl_DriverGetHandleProc) _ANSI_ARGS_((
		    ClientData instanceData, int direction,
		    ClientData *handlePtr));
typedef int	(Tcl_DriverFlushProc) _ANSI_ARGS_((
		    ClientData instanceData));
typedef int	(Tcl_DriverHandlerProc) _ANSI_ARGS_((
		    ClientData instanceData, int interestMask));
typedef Tcl_WideInt (Tcl_DriverWideSeekProc) _ANSI_ARGS_((
		    ClientData instanceData, Tcl_WideInt offset,
		    int mode, int *errorCodePtr));

  /* TIP #218, Channel Thread Actions */
typedef void     (Tcl_DriverThreadActionProc) _ANSI_ARGS_ ((
		    ClientData instanceData, int action));

/*
 * The following declarations either map ckalloc and ckfree to
 * malloc and free, or they map them to procedures with all sorts
 * of debugging hooks defined in tclCkalloc.c.
 */
#ifdef TCL_MEM_DEBUG

#   define ckalloc(x) Tcl_DbCkalloc(x, __FILE__, __LINE__)
#   define ckfree(x)  Tcl_DbCkfree(x, __FILE__, __LINE__)
#   define ckrealloc(x,y) Tcl_DbCkrealloc((x), (y),__FILE__, __LINE__)
#   define attemptckalloc(x) Tcl_AttemptDbCkalloc(x, __FILE__, __LINE__)
#   define attemptckrealloc(x,y) Tcl_AttemptDbCkrealloc((x), (y), __FILE__, __LINE__)
#else /* !TCL_MEM_DEBUG */

/*
 * If we are not using the debugging allocator, we should call the 
 * Tcl_Alloc, et al. routines in order to guarantee that every module
 * is using the same memory allocator both inside and outside of the
 * Tcl library.
 */
#   define ckalloc(x) Tcl_Alloc(x)
#   define ckfree(x) Tcl_Free(x)
#   define ckrealloc(x,y) Tcl_Realloc(x,y)
#   define attemptckalloc(x) Tcl_AttemptAlloc(x)
#   define attemptckrealloc(x,y) Tcl_AttemptRealloc(x,y)
#   define Tcl_InitMemory(x)
#   define Tcl_DumpActiveMemory(x)
#   define Tcl_ValidateAllMemory(x,y)

#endif /* !TCL_MEM_DEBUG */

/*
 * struct Tcl_ChannelType:
 *
 * One such structure exists for each type (kind) of channel.
 * It collects together in one place all the functions that are
 * part of the specific channel type.
 *
 * It is recommend that the Tcl_Channel* functions are used to access
 * elements of this structure, instead of direct accessing.
 */
typedef struct Tcl_ChannelType {
    char *typeName;			/* The name of the channel type in Tcl
                                         * commands. This storage is owned by
                                         * channel type. */
    Tcl_ChannelTypeVersion version;	/* Version of the channel type. */
    Tcl_DriverCloseProc *closeProc;	/* Procedure to call to close the
					 * channel, or TCL_CLOSE2PROC if the
					 * close2Proc should be used
					 * instead. */
    Tcl_DriverInputProc *inputProc;	/* Procedure to call for input
					 * on channel. */
    Tcl_DriverOutputProc *outputProc;	/* Procedure to call for output
					 * on channel. */
    Tcl_DriverSeekProc *seekProc;	/* Procedure to call to seek
					 * on the channel. May be NULL. */
    Tcl_DriverSetOptionProc *setOptionProc;
					/* Set an option on a channel. */
    Tcl_DriverGetOptionProc *getOptionProc;
					/* Get an option from a channel. */
    Tcl_DriverWatchProc *watchProc;	/* Set up the notifier to watch
					 * for events on this channel. */
    Tcl_DriverGetHandleProc *getHandleProc;
					/* Get an OS handle from the channel
					 * or NULL if not supported. */
    Tcl_DriverClose2Proc *close2Proc;	/* Procedure to call to close the
					 * channel if the device supports
					 * closing the read & write sides
					 * independently. */
    Tcl_DriverBlockModeProc *blockModeProc;
					/* Set blocking mode for the
					 * raw channel. May be NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_2 channels or later
     */
    Tcl_DriverFlushProc *flushProc;	/* Procedure to call to flush a
					 * channel. May be NULL. */
    Tcl_DriverHandlerProc *handlerProc;	/* Procedure to call to handle a
					 * channel event.  This will be passed
					 * up the stacked channel chain. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_3 channels or later
     */
    Tcl_DriverWideSeekProc *wideSeekProc;
					/* Procedure to call to seek
					 * on the channel which can
					 * handle 64-bit offsets. May be
					 * NULL, and must be NULL if
					 * seekProc is NULL. */

     /*
      * Only valid in TCL_CHANNEL_VERSION_4 channels or later
      * TIP #218, Channel Thread Actions
      */
     Tcl_DriverThreadActionProc *threadActionProc;
 					/* Procedure to call to notify
 					 * the driver of thread specific
 					 * activity for a channel.
					 * May be NULL. */
} Tcl_ChannelType;

/*
 * The following flags determine whether the blockModeProc above should
 * set the channel into blocking or nonblocking mode. They are passed
 * as arguments to the blockModeProc procedure in the above structure.
 */
#define TCL_MODE_BLOCKING	0	/* Put channel into blocking mode. */
#define TCL_MODE_NONBLOCKING	1	/* Put channel into nonblocking
					 * mode. */

/*
 * Enum for different types of file paths.
 */
typedef enum Tcl_PathType {
    TCL_PATH_ABSOLUTE,
    TCL_PATH_RELATIVE,
    TCL_PATH_VOLUME_RELATIVE
} Tcl_PathType;


/* 
 * The following structure is used to pass glob type data amongst
 * the various glob routines and Tcl_FSMatchInDirectory.
 */
typedef struct Tcl_GlobTypeData {
    /* Corresponds to bcdpfls as in 'find -t' */
    int type;
    /* Corresponds to file permissions */
    int perm;
    /* Acceptable mac type */
    Tcl_Obj* macType;
    /* Acceptable mac creator */
    Tcl_Obj* macCreator;
} Tcl_GlobTypeData;

/*
 * type and permission definitions for glob command
 */
#define TCL_GLOB_TYPE_BLOCK		(1<<0)
#define TCL_GLOB_TYPE_CHAR		(1<<1)
#define TCL_GLOB_TYPE_DIR		(1<<2)
#define TCL_GLOB_TYPE_PIPE		(1<<3)
#define TCL_GLOB_TYPE_FILE		(1<<4)
#define TCL_GLOB_TYPE_LINK		(1<<5)
#define TCL_GLOB_TYPE_SOCK		(1<<6)
#define TCL_GLOB_TYPE_MOUNT		(1<<7)

#define TCL_GLOB_PERM_RONLY		(1<<0)
#define TCL_GLOB_PERM_HIDDEN		(1<<1)
#define TCL_GLOB_PERM_R			(1<<2)
#define TCL_GLOB_PERM_W			(1<<3)
#define TCL_GLOB_PERM_X			(1<<4)


/*
 * Typedefs for the various filesystem operations:
 */
typedef int (Tcl_FSStatProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
typedef int (Tcl_FSAccessProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, int mode));
typedef Tcl_Channel (Tcl_FSOpenFileChannelProc) 
	_ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *pathPtr, 
	int mode, int permissions));
typedef int (Tcl_FSMatchInDirectoryProc) _ANSI_ARGS_((Tcl_Interp* interp, 
	Tcl_Obj *result, Tcl_Obj *pathPtr, CONST char *pattern, 
	Tcl_GlobTypeData * types));
typedef Tcl_Obj* (Tcl_FSGetCwdProc) _ANSI_ARGS_((Tcl_Interp *interp));
typedef int (Tcl_FSChdirProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));
typedef int (Tcl_FSLstatProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, 
					   Tcl_StatBuf *buf));
typedef int (Tcl_FSCreateDirectoryProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));
typedef int (Tcl_FSDeleteFileProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));
typedef int (Tcl_FSCopyDirectoryProc) _ANSI_ARGS_((Tcl_Obj *srcPathPtr,
	   Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
typedef int (Tcl_FSCopyFileProc) _ANSI_ARGS_((Tcl_Obj *srcPathPtr,
			    Tcl_Obj *destPathPtr));
typedef int (Tcl_FSRemoveDirectoryProc) _ANSI_ARGS_((Tcl_Obj *pathPtr,
			    int recursive, Tcl_Obj **errorPtr));
typedef int (Tcl_FSRenameFileProc) _ANSI_ARGS_((Tcl_Obj *srcPathPtr,
			    Tcl_Obj *destPathPtr));
typedef void (Tcl_FSUnloadFileProc) _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
typedef Tcl_Obj* (Tcl_FSListVolumesProc) _ANSI_ARGS_((void));
/* We have to declare the utime structure here. */
struct utimbuf;
typedef int (Tcl_FSUtimeProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, 
					   struct utimbuf *tval));
typedef int (Tcl_FSNormalizePathProc) _ANSI_ARGS_((Tcl_Interp *interp, 
			 Tcl_Obj *pathPtr, int nextCheckpoint));
typedef int (Tcl_FSFileAttrsGetProc) _ANSI_ARGS_((Tcl_Interp *interp,
			    int index, Tcl_Obj *pathPtr,
			    Tcl_Obj **objPtrRef));
typedef CONST char** (Tcl_FSFileAttrStringsProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_Obj** objPtrRef));
typedef int (Tcl_FSFileAttrsSetProc) _ANSI_ARGS_((Tcl_Interp *interp,
			    int index, Tcl_Obj *pathPtr,
			    Tcl_Obj *objPtr));
typedef Tcl_Obj* (Tcl_FSLinkProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, 
					       Tcl_Obj *toPtr, int linkType));
typedef int (Tcl_FSLoadFileProc) _ANSI_ARGS_((Tcl_Interp * interp, 
			    Tcl_Obj *pathPtr,
			    Tcl_LoadHandle *handlePtr,
			    Tcl_FSUnloadFileProc **unloadProcPtr));
typedef int (Tcl_FSPathInFilesystemProc) _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    ClientData *clientDataPtr));
typedef Tcl_Obj* (Tcl_FSFilesystemPathTypeProc) 
			    _ANSI_ARGS_((Tcl_Obj *pathPtr));
typedef Tcl_Obj* (Tcl_FSFilesystemSeparatorProc) 
			    _ANSI_ARGS_((Tcl_Obj *pathPtr));
typedef void (Tcl_FSFreeInternalRepProc) _ANSI_ARGS_((ClientData clientData));
typedef ClientData (Tcl_FSDupInternalRepProc) 
			    _ANSI_ARGS_((ClientData clientData));
typedef Tcl_Obj* (Tcl_FSInternalToNormalizedProc) 
			    _ANSI_ARGS_((ClientData clientData));
typedef ClientData (Tcl_FSCreateInternalRepProc) _ANSI_ARGS_((Tcl_Obj *pathPtr));

typedef struct Tcl_FSVersion_ *Tcl_FSVersion;

/*
 *----------------------------------------------------------------
 * Data structures related to hooking into the filesystem
 *----------------------------------------------------------------
 */

/*
 * Filesystem version tag.  This was introduced in 8.4.
 */
#define TCL_FILESYSTEM_VERSION_1	((Tcl_FSVersion) 0x1)

/*
 * struct Tcl_Filesystem:
 *
 * One such structure exists for each type (kind) of filesystem.
 * It collects together in one place all the functions that are
 * part of the specific filesystem.  Tcl always accesses the
 * filesystem through one of these structures.
 * 
 * Not all entries need be non-NULL; any which are NULL are simply
 * ignored.  However, a complete filesystem should provide all of
 * these functions.  The explanations in the structure show
 * the importance of each function.
 */

typedef struct Tcl_Filesystem {
    CONST char *typeName;   /* The name of the filesystem. */
    int structureLength;    /* Length of this structure, so future
			     * binary compatibility can be assured. */
    Tcl_FSVersion version;  
			    /* Version of the filesystem type. */
    Tcl_FSPathInFilesystemProc *pathInFilesystemProc;
			    /* Function to check whether a path is in 
			     * this filesystem.  This is the most
			     * important filesystem procedure. */
    Tcl_FSDupInternalRepProc *dupInternalRepProc;
			    /* Function to duplicate internal fs rep.  May
			     * be NULL (but then fs is less efficient). */ 
    Tcl_FSFreeInternalRepProc *freeInternalRepProc;
			    /* Function to free internal fs rep.  Must
			     * be implemented, if internal representations
			     * need freeing, otherwise it can be NULL. */ 
    Tcl_FSInternalToNormalizedProc *internalToNormalizedProc;
			    /* Function to convert internal representation
			     * to a normalized path.  Only required if
			     * the fs creates pure path objects with no
			     * string/path representation. */
    Tcl_FSCreateInternalRepProc *createInternalRepProc;
			    /* Function to create a filesystem-specific
			     * internal representation.  May be NULL
			     * if paths have no internal representation, 
			     * or if the Tcl_FSPathInFilesystemProc
			     * for this filesystem always immediately 
			     * creates an internal representation for 
			     * paths it accepts. */
    Tcl_FSNormalizePathProc *normalizePathProc;       
			    /* Function to normalize a path.  Should
			     * be implemented for all filesystems
			     * which can have multiple string 
			     * representations for the same path 
			     * object. */
    Tcl_FSFilesystemPathTypeProc *filesystemPathTypeProc;
			    /* Function to determine the type of a 
			     * path in this filesystem.  May be NULL. */
    Tcl_FSFilesystemSeparatorProc *filesystemSeparatorProc;
			    /* Function to return the separator 
			     * character(s) for this filesystem.  Must
			     * be implemented. */
    Tcl_FSStatProc *statProc; 
			    /* 
			     * Function to process a 'Tcl_FSStat()'
			     * call.  Must be implemented for any
			     * reasonable filesystem.
			     */
    Tcl_FSAccessProc *accessProc;	    
			    /* 
			     * Function to process a 'Tcl_FSAccess()'
			     * call.  Must be implemented for any
			     * reasonable filesystem.
			     */
    Tcl_FSOpenFileChannelProc *openFileChannelProc; 
			    /* 
			     * Function to process a
			     * 'Tcl_FSOpenFileChannel()' call.  Must be
			     * implemented for any reasonable
			     * filesystem.
			     */
    Tcl_FSMatchInDirectoryProc *matchInDirectoryProc;  
			    /* Function to process a 
			     * 'Tcl_FSMatchInDirectory()'.  If not
			     * implemented, then glob and recursive
			     * copy functionality will be lacking in
			     * the filesystem. */
    Tcl_FSUtimeProc *utimeProc;       
			    /* Function to process a 
			     * 'Tcl_FSUtime()' call.  Required to
			     * allow setting (not reading) of times 
			     * with 'file mtime', 'file atime' and
			     * the open-r/open-w/fcopy implementation
			     * of 'file copy'. */
    Tcl_FSLinkProc *linkProc; 
			    /* Function to process a 
			     * 'Tcl_FSLink()' call.  Should be
			     * implemented only if the filesystem supports
			     * links (reading or creating). */
    Tcl_FSListVolumesProc *listVolumesProc;	    
			    /* Function to list any filesystem volumes 
			     * added by this filesystem.  Should be
			     * implemented only if the filesystem adds
			     * volumes at the head of the filesystem. */
    Tcl_FSFileAttrStringsProc *fileAttrStringsProc;
			    /* Function to list all attributes strings 
			     * which are valid for this filesystem.  
			     * If not implemented the filesystem will
			     * not support the 'file attributes' command.
			     * This allows arbitrary additional information
			     * to be attached to files in the filesystem. */
    Tcl_FSFileAttrsGetProc *fileAttrsGetProc;
			    /* Function to process a 
			     * 'Tcl_FSFileAttrsGet()' call, used by
			     * 'file attributes'. */
    Tcl_FSFileAttrsSetProc *fileAttrsSetProc;
			    /* Function to process a 
			     * 'Tcl_FSFileAttrsSet()' call, used by
			     * 'file attributes'.  */
    Tcl_FSCreateDirectoryProc *createDirectoryProc;	    
			    /* Function to process a 
			     * 'Tcl_FSCreateDirectory()' call. Should
			     * be implemented unless the FS is
			     * read-only. */
    Tcl_FSRemoveDirectoryProc *removeDirectoryProc;	    
			    /* Function to process a 
			     * 'Tcl_FSRemoveDirectory()' call. Should
			     * be implemented unless the FS is
			     * read-only. */
    Tcl_FSDeleteFileProc *deleteFileProc;	    
			    /* Function to process a 
			     * 'Tcl_FSDeleteFile()' call.  Should
			     * be implemented unless the FS is
			     * read-only. */
    Tcl_FSCopyFileProc *copyFileProc; 
			    /* Function to process a 
			     * 'Tcl_FSCopyFile()' call.  If not
			     * implemented Tcl will fall back
			     * on open-r, open-w and fcopy as
			     * a copying mechanism, for copying
			     * actions initiated in Tcl (not C). */
    Tcl_FSRenameFileProc *renameFileProc;	    
			    /* Function to process a 
			     * 'Tcl_FSRenameFile()' call.  If not
			     * implemented, Tcl will fall back on
			     * a copy and delete mechanism, for 
			     * rename actions initiated in Tcl (not C). */
    Tcl_FSCopyDirectoryProc *copyDirectoryProc;	    
			    /* Function to process a 
			     * 'Tcl_FSCopyDirectory()' call.  If
			     * not implemented, Tcl will fall back
			     * on a recursive create-dir, file copy
			     * mechanism, for copying actions
			     * initiated in Tcl (not C). */
    Tcl_FSLstatProc *lstatProc;	    
			    /* Function to process a 
			     * 'Tcl_FSLstat()' call.  If not implemented,
			     * Tcl will attempt to use the 'statProc'
			     * defined above instead. */
    Tcl_FSLoadFileProc *loadFileProc; 
			    /* Function to process a 
			     * 'Tcl_FSLoadFile()' call.  If not
			     * implemented, Tcl will fall back on
			     * a copy to native-temp followed by a 
			     * Tcl_FSLoadFile on that temporary copy. */
    Tcl_FSGetCwdProc *getCwdProc;     
			    /* 
			     * Function to process a 'Tcl_FSGetCwd()'
			     * call.  Most filesystems need not
			     * implement this.  It will usually only be
			     * called once, if 'getcwd' is called
			     * before 'chdir'.  May be NULL.
			     */
    Tcl_FSChdirProc *chdirProc;	    
			    /* 
			     * Function to process a 'Tcl_FSChdir()'
			     * call.  If filesystems do not implement
			     * this, it will be emulated by a series of
			     * directory access checks.  Otherwise,
			     * virtual filesystems which do implement
			     * it need only respond with a positive
			     * return result if the dirName is a valid
			     * directory in their filesystem.  They
			     * need not remember the result, since that
			     * will be automatically remembered for use
			     * by GetCwd.  Real filesystems should
			     * carry out the correct action (i.e. call
			     * the correct system 'chdir' api).  If not
			     * implemented, then 'cd' and 'pwd' will
			     * fail inside the filesystem.
			     */
} Tcl_Filesystem;

/*
 * The following definitions are used as values for the 'linkAction' flag
 * to Tcl_FSLink, or the linkProc of any filesystem.  Any combination
 * of flags can be given.  For link creation, the linkProc should create
 * a link which matches any of the types given.
 * 
 * TCL_CREATE_SYMBOLIC_LINK:  Create a symbolic or soft link.
 * TCL_CREATE_HARD_LINK:      Create a hard link.
 */
#define TCL_CREATE_SYMBOLIC_LINK   0x01
#define TCL_CREATE_HARD_LINK       0x02

/*
 * The following structure represents the Notifier functions that
 * you can override with the Tcl_SetNotifier call.
 */
typedef struct Tcl_NotifierProcs {
    Tcl_SetTimerProc *setTimerProc;
    Tcl_WaitForEventProc *waitForEventProc;
    Tcl_CreateFileHandlerProc *createFileHandlerProc;
    Tcl_DeleteFileHandlerProc *deleteFileHandlerProc;
    Tcl_InitNotifierProc *initNotifierProc;
    Tcl_FinalizeNotifierProc *finalizeNotifierProc;
    Tcl_AlertNotifierProc *alertNotifierProc;
    Tcl_ServiceModeHookProc *serviceModeHookProc;
} Tcl_NotifierProcs;


/*
 * The following structure represents a user-defined encoding.  It collects
 * together all the functions that are used by the specific encoding.
 */
typedef struct Tcl_EncodingType {
    CONST char *encodingName;	/* The name of the encoding, e.g.  "euc-jp".
				 * This name is the unique key for this
				 * encoding type. */
    Tcl_EncodingConvertProc *toUtfProc;
				/* Procedure to convert from external
				 * encoding into UTF-8. */
    Tcl_EncodingConvertProc *fromUtfProc;
				/* Procedure to convert from UTF-8 into
				 * external encoding. */
    Tcl_EncodingFreeProc *freeProc;
				/* If non-NULL, procedure to call when this
				 * encoding is deleted. */
    ClientData clientData;	/* Arbitrary value associated with encoding
				 * type.  Passed to conversion procedures. */
    int nullSize;		/* Number of zero bytes that signify
				 * end-of-string in this encoding.  This
				 * number is used to determine the source
				 * string length when the srcLen argument is
				 * negative.  Must be 1 or 2. */
} Tcl_EncodingType;    

/*
 * The following definitions are used as values for the conversion control
 * flags argument when converting text from one character set to another:
 *
 * TCL_ENCODING_START:	     	Signifies that the source buffer is the first
 *				block in a (potentially multi-block) input
 *				stream.  Tells the conversion procedure to
 *				reset to an initial state and perform any
 *				initialization that needs to occur before the
 *				first byte is converted.  If the source
 *				buffer contains the entire input stream to be
 *				converted, this flag should be set.
 *
 * TCL_ENCODING_END:		Signifies that the source buffer is the last
 *				block in a (potentially multi-block) input
 *				stream.  Tells the conversion routine to
 *				perform any finalization that needs to occur
 *				after the last byte is converted and then to
 *				reset to an initial state.  If the source
 *				buffer contains the entire input stream to be
 *				converted, this flag should be set.
 *				
 * TCL_ENCODING_STOPONERROR:	If set, then the converter will return
 *				immediately upon encountering an invalid
 *				byte sequence or a source character that has
 *				no mapping in the target encoding.  If clear,
 *				then the converter will skip the problem,
 *				substituting one or more "close" characters
 *				in the destination buffer and then continue
 *				to sonvert the source.
 */
#define TCL_ENCODING_START		0x01
#define TCL_ENCODING_END		0x02
#define TCL_ENCODING_STOPONERROR	0x04


/*
 * The following data structures and declarations are for the new Tcl
 * parser.
 */

/*
 * For each word of a command, and for each piece of a word such as a
 * variable reference, one of the following structures is created to
 * describe the token.
 */
typedef struct Tcl_Token {
    int type;			/* Type of token, such as TCL_TOKEN_WORD;
				 * see below for valid types. */
    CONST char *start;		/* First character in token. */
    int size;			/* Number of bytes in token. */
    int numComponents;		/* If this token is composed of other
				 * tokens, this field tells how many of
				 * them there are (including components of
				 * components, etc.).  The component tokens
				 * immediately follow this one. */
} Tcl_Token;

/*
 * Type values defined for Tcl_Token structures.  These values are
 * defined as mask bits so that it's easy to check for collections of
 * types.
 *
 * TCL_TOKEN_WORD -		The token describes one word of a command,
 *				from the first non-blank character of
 *				the word (which may be " or {) up to but
 *				not including the space, semicolon, or
 *				bracket that terminates the word. 
 *				NumComponents counts the total number of
 *				sub-tokens that make up the word.  This
 *				includes, for example, sub-tokens of
 *				TCL_TOKEN_VARIABLE tokens.
 * TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD
 *				except that the word is guaranteed to
 *				consist of a single TCL_TOKEN_TEXT
 *				sub-token.
 * TCL_TOKEN_TEXT -		The token describes a range of literal
 *				text that is part of a word. 
 *				NumComponents is always 0.
 * TCL_TOKEN_BS -		The token describes a backslash sequence
 *				that must be collapsed.	 NumComponents
 *				is always 0.
 * TCL_TOKEN_COMMAND -		The token describes a command whose result
 *				must be substituted into the word.  The
 *				token includes the enclosing brackets. 
 *				NumComponents is always 0.
 * TCL_TOKEN_VARIABLE -		The token describes a variable
 *				substitution, including the dollar sign,
 *				variable name, and array index (if there
 *				is one) up through the right
 *				parentheses.  NumComponents tells how
 *				many additional tokens follow to
 *				represent the variable name.  The first
 *				token will be a TCL_TOKEN_TEXT token
 *				that describes the variable name.  If
 *				the variable is an array reference then
 *				there will be one or more additional
 *				tokens, of type TCL_TOKEN_TEXT,
 *				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
 *				TCL_TOKEN_VARIABLE, that describe the
 *				array index; numComponents counts the
 *				total number of nested tokens that make
 *				up the variable reference, including
 *				sub-tokens of TCL_TOKEN_VARIABLE tokens.
 * TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of a
 *				expression, from the first non-blank
 *				character of the subexpression up to but not
 *				including the space, brace, or bracket
 *				that terminates the subexpression. 
 *				NumComponents counts the total number of
 *				following subtokens that make up the
 *				subexpression; this includes all subtokens
 *				for any nested TCL_TOKEN_SUB_EXPR tokens.
 *				For example, a numeric value used as a
 *				primitive operand is described by a
 *				TCL_TOKEN_SUB_EXPR token followed by a
 *				TCL_TOKEN_TEXT token. A binary subexpression
 *				is described by a TCL_TOKEN_SUB_EXPR token
 *				followed by the	TCL_TOKEN_OPERATOR token
 *				for the operator, then TCL_TOKEN_SUB_EXPR
 *				tokens for the left then the right operands.
 * TCL_TOKEN_OPERATOR -		The token describes one expression operator.
 *				An operator might be the name of a math
 *				function such as "abs". A TCL_TOKEN_OPERATOR
 *				token is always preceeded by one
 *				TCL_TOKEN_SUB_EXPR token for the operator's
 *				subexpression, and is followed by zero or
 *				more TCL_TOKEN_SUB_EXPR tokens for the
 *				operator's operands. NumComponents is
 *				always 0.
 */
#define TCL_TOKEN_WORD		1
#define TCL_TOKEN_SIMPLE_WORD	2
#define TCL_TOKEN_TEXT		4
#define TCL_TOKEN_BS		8
#define TCL_TOKEN_COMMAND	16
#define TCL_TOKEN_VARIABLE	32
#define TCL_TOKEN_SUB_EXPR	64
#define TCL_TOKEN_OPERATOR	128

/*
 * Parsing error types.  On any parsing error, one of these values
 * will be stored in the error field of the Tcl_Parse structure
 * defined below.
 */
#define TCL_PARSE_SUCCESS		0
#define TCL_PARSE_QUOTE_EXTRA		1
#define TCL_PARSE_BRACE_EXTRA		2
#define TCL_PARSE_MISSING_BRACE		3
#define TCL_PARSE_MISSING_BRACKET	4
#define TCL_PARSE_MISSING_PAREN		5
#define TCL_PARSE_MISSING_QUOTE		6
#define TCL_PARSE_MISSING_VAR_BRACE	7
#define TCL_PARSE_SYNTAX		8
#define TCL_PARSE_BAD_NUMBER		9

/*
 * A structure of the following type is filled in by Tcl_ParseCommand.
 * It describes a single command parsed from an input string.
 */
#define NUM_STATIC_TOKENS 20

typedef struct Tcl_Parse {
    CONST char *commentStart;	/* Pointer to # that begins the first of
				 * one or more comments preceding the
				 * command. */
    int commentSize;		/* Number of bytes in comments (up through
				 * newline character that terminates the
				 * last comment).  If there were no
				 * comments, this field is 0. */
    CONST char *commandStart;	/* First character in first word of command. */
    int commandSize;		/* Number of bytes in command, including
				 * first character of first word, up
				 * through the terminating newline,
				 * close bracket, or semicolon. */
    int numWords;		/* Total number of words in command.  May
				 * be 0. */
    Tcl_Token *tokenPtr;	/* Pointer to first token representing
				 * the words of the command.  Initially
				 * points to staticTokens, but may change
				 * to point to malloc-ed space if command
				 * exceeds space in staticTokens. */
    int numTokens;		/* Total number of tokens in command. */
    int tokensAvailable;	/* Total number of tokens available at
				 * *tokenPtr. */
    int errorType;		/* One of the parsing error types defined
				 * above. */

    /*
     * The fields below are intended only for the private use of the
     * parser.	They should not be used by procedures that invoke
     * Tcl_ParseCommand.
     */

    CONST char *string;		/* The original command string passed to
				 * Tcl_ParseCommand. */
    CONST char *end;		/* Points to the character just after the
				 * last one in the command string. */
    Tcl_Interp *interp;		/* Interpreter to use for error reporting,
				 * or NULL. */
    CONST char *term;		/* Points to character in string that
				 * terminated most recent token.  Filled in
				 * by ParseTokens.  If an error occurs,
				 * points to beginning of region where the
				 * error occurred (e.g. the open brace if
				 * the close brace is missing). */
    int incomplete;		/* This field is set to 1 by Tcl_ParseCommand
				 * if the command appears to be incomplete.
				 * This information is used by
				 * Tcl_CommandComplete. */
    Tcl_Token staticTokens[NUM_STATIC_TOKENS];
				/* Initial space for tokens for command.
				 * This space should be large enough to
				 * accommodate most commands; dynamic
				 * space is allocated for very large
				 * commands that don't fit here. */
} Tcl_Parse;

/*
 * The following definitions are the error codes returned by the conversion
 * routines:
 *
 * TCL_OK:			All characters were converted.
 *
 * TCL_CONVERT_NOSPACE:		The output buffer would not have been large
 *				enough for all of the converted data; as many
 *				characters as could fit were converted though.
 *
 * TCL_CONVERT_MULTIBYTE:	The last few bytes in the source string were
 *				the beginning of a multibyte sequence, but
 *				more bytes were needed to complete this
 *				sequence.  A subsequent call to the conversion
 *				routine should pass the beginning of this
 *				unconverted sequence plus additional bytes
 *				from the source stream to properly convert
 *				the formerly split-up multibyte sequence.
 *
 * TCL_CONVERT_SYNTAX:		The source stream contained an invalid
 *				character sequence.  This may occur if the
 *				input stream has been damaged or if the input
 *				encoding method was misidentified.  This error
 *				is reported only if TCL_ENCODING_STOPONERROR
 *				was specified.
 * 
 * TCL_CONVERT_UNKNOWN:		The source string contained a character
 *				that could not be represented in the target
 *				encoding.  This error is reported only if
 *				TCL_ENCODING_STOPONERROR was specified.
 */
#define TCL_CONVERT_MULTIBYTE		-1
#define TCL_CONVERT_SYNTAX		-2
#define TCL_CONVERT_UNKNOWN		-3
#define TCL_CONVERT_NOSPACE		-4

/*
 * The maximum number of bytes that are necessary to represent a single
 * Unicode character in UTF-8.  The valid values should be 3 or 6 (or
 * perhaps 1 if we want to support a non-unicode enabled core).
 * If 3, then Tcl_UniChar must be 2-bytes in size (UCS-2). (default)
 * If 6, then Tcl_UniChar must be 4-bytes in size (UCS-4).
 * At this time UCS-2 mode is the default and recommended mode.
 * UCS-4 is experimental and not recommended.  It works for the core,
 * but most extensions expect UCS-2.
 */
#ifndef TCL_UTF_MAX
#define TCL_UTF_MAX		3
#endif

/*
 * This represents a Unicode character.  Any changes to this should
 * also be reflected in regcustom.h.
 */
#if TCL_UTF_MAX > 3
    /*
     * unsigned int isn't 100% accurate as it should be a strict 4-byte
     * value (perhaps wchar_t).  64-bit systems may have troubles.  The
     * size of this value must be reflected correctly in regcustom.h and
     * in tclEncoding.c.
     * XXX: Tcl is currently UCS-2 and planning UTF-16 for the Unicode
     * XXX: string rep that Tcl_UniChar represents.  Changing the size
     * XXX: of Tcl_UniChar is /not/ supported.
     */
typedef unsigned int Tcl_UniChar;
#else
typedef unsigned short Tcl_UniChar;
#endif


/*
 * Deprecated Tcl procedures:
 */
#ifndef TCL_NO_DEPRECATED
#   define Tcl_EvalObj(interp,objPtr) \
	Tcl_EvalObjEx((interp),(objPtr),0)
#   define Tcl_GlobalEvalObj(interp,objPtr) \
	Tcl_EvalObjEx((interp),(objPtr),TCL_EVAL_GLOBAL)
#endif


/*
 * These function have been renamed. The old names are deprecated, but we
 * define these macros for backwards compatibilty.
 */
#define Tcl_Ckalloc Tcl_Alloc
#define Tcl_Ckfree Tcl_Free
#define Tcl_Ckrealloc Tcl_Realloc
#define Tcl_Return Tcl_SetResult
#define Tcl_TildeSubst Tcl_TranslateFileName
#define panic Tcl_Panic
#define panicVA Tcl_PanicVA


/*
 * The following constant is used to test for older versions of Tcl
 * in the stubs tables.
 *
 * Jan Nijtman's plus patch uses 0xFCA1BACF, so we need to pick a different
 * value since the stubs tables don't match.
 */

#define TCL_STUB_MAGIC ((int)0xFCA3BACF)

/*
 * The following function is required to be defined in all stubs aware
 * extensions.  The function is actually implemented in the stub
 * library, not the main Tcl library, although there is a trivial
 * implementation in the main library in case an extension is statically
 * linked into an application.
 */

EXTERN CONST char *	Tcl_InitStubs _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *version, int exact));

#ifndef USE_TCL_STUBS

/*
 * When not using stubs, make it a macro.
 */

#define Tcl_InitStubs(interp, version, exact) \
    Tcl_PkgRequire(interp, "Tcl", version, exact)

#endif


/*
 * Include the public function declarations that are accessible via
 * the stubs table.
 */

#include "tclDecls.h"

/*
 * Include platform specific public function declarations that are
 * accessible via the stubs table.
 */

/*
 * tclPlatDecls.h can't be included here on the Mac, as we need
 * Mac specific headers to define the Mac types used in this file,
 * but these Mac haders conflict with a number of tk types
 * and thus can't be included in the globally read tcl.h
 * This header was originally added here as a fix for bug 5241
 * (stub link error for symbols in TclPlatStubs table), as a work-
 * around for the bug on the mac, tclMac.h is included immediately 
 * after tcl.h in the tcl precompiled header (with DLLEXPORT set).
 */

#if !defined(MAC_TCL)
#include "tclPlatDecls.h"
#endif

/*
 * Public functions that are not accessible via the stubs table.
 */

EXTERN void Tcl_Main _ANSI_ARGS_((int argc, char **argv,
	Tcl_AppInitProc *appInitProc));

/*
 * Convenience declaration of Tcl_AppInit for backwards compatibility.
 * This function is not *implemented* by the tcl library, so the storage
 * class is neither DLLEXPORT nor DLLIMPORT
 */
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS

EXTERN int		Tcl_AppInit _ANSI_ARGS_((Tcl_Interp *interp));

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* RC_INVOKED */

/*
 * end block for C++
 */
#ifdef __cplusplus
}
#endif

#endif /* _TCL */
                                                                                       tclDecls.h                                                                                          0100644 0001750 0001750 00000503146 11001731473 032403  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tcl.framework/Versions/8.4/Headers                                                                       /*
 * tclDecls.h --
 *
 *	Declarations of functions in the platform independent public Tcl API.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tclDecls.h,v 1.93.2.7 2006/09/22 01:26:23 andreas_kupries Exp $
 */

#ifndef _TCLDECLS
#define _TCLDECLS

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tcl.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

/* 0 */
EXTERN int		Tcl_PkgProvideEx _ANSI_ARGS_((Tcl_Interp* interp, 
				CONST char* name, CONST char* version, 
				ClientData clientData));
/* 1 */
EXTERN CONST84_RETURN char * Tcl_PkgRequireEx _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				CONST char * version, int exact, 
				ClientData * clientDataPtr));
/* 2 */
EXTERN void		Tcl_Panic _ANSI_ARGS_(TCL_VARARGS(CONST char *,format));
/* 3 */
EXTERN char *		Tcl_Alloc _ANSI_ARGS_((unsigned int size));
/* 4 */
EXTERN void		Tcl_Free _ANSI_ARGS_((char * ptr));
/* 5 */
EXTERN char *		Tcl_Realloc _ANSI_ARGS_((char * ptr, 
				unsigned int size));
/* 6 */
EXTERN char *		Tcl_DbCkalloc _ANSI_ARGS_((unsigned int size, 
				CONST char * file, int line));
/* 7 */
EXTERN int		Tcl_DbCkfree _ANSI_ARGS_((char * ptr, 
				CONST char * file, int line));
/* 8 */
EXTERN char *		Tcl_DbCkrealloc _ANSI_ARGS_((char * ptr, 
				unsigned int size, CONST char * file, 
				int line));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 9 */
EXTERN void		Tcl_CreateFileHandler _ANSI_ARGS_((int fd, int mask, 
				Tcl_FileProc * proc, ClientData clientData));
#endif /* UNIX */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 10 */
EXTERN void		Tcl_DeleteFileHandler _ANSI_ARGS_((int fd));
#endif /* UNIX */
/* 11 */
EXTERN void		Tcl_SetTimer _ANSI_ARGS_((Tcl_Time * timePtr));
/* 12 */
EXTERN void		Tcl_Sleep _ANSI_ARGS_((int ms));
/* 13 */
EXTERN int		Tcl_WaitForEvent _ANSI_ARGS_((Tcl_Time * timePtr));
/* 14 */
EXTERN int		Tcl_AppendAllObjTypes _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr));
/* 15 */
EXTERN void		Tcl_AppendStringsToObj _ANSI_ARGS_(TCL_VARARGS(Tcl_Obj *,objPtr));
/* 16 */
EXTERN void		Tcl_AppendToObj _ANSI_ARGS_((Tcl_Obj* objPtr, 
				CONST char* bytes, int length));
/* 17 */
EXTERN Tcl_Obj *	Tcl_ConcatObj _ANSI_ARGS_((int objc, 
				Tcl_Obj *CONST objv[]));
/* 18 */
EXTERN int		Tcl_ConvertToType _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, Tcl_ObjType * typePtr));
/* 19 */
EXTERN void		Tcl_DbDecrRefCount _ANSI_ARGS_((Tcl_Obj * objPtr, 
				CONST char * file, int line));
/* 20 */
EXTERN void		Tcl_DbIncrRefCount _ANSI_ARGS_((Tcl_Obj * objPtr, 
				CONST char * file, int line));
/* 21 */
EXTERN int		Tcl_DbIsShared _ANSI_ARGS_((Tcl_Obj * objPtr, 
				CONST char * file, int line));
/* 22 */
EXTERN Tcl_Obj *	Tcl_DbNewBooleanObj _ANSI_ARGS_((int boolValue, 
				CONST char * file, int line));
/* 23 */
EXTERN Tcl_Obj *	Tcl_DbNewByteArrayObj _ANSI_ARGS_((
				CONST unsigned char * bytes, int length, 
				CONST char * file, int line));
/* 24 */
EXTERN Tcl_Obj *	Tcl_DbNewDoubleObj _ANSI_ARGS_((double doubleValue, 
				CONST char * file, int line));
/* 25 */
EXTERN Tcl_Obj *	Tcl_DbNewListObj _ANSI_ARGS_((int objc, 
				Tcl_Obj *CONST * objv, CONST char * file, 
				int line));
/* 26 */
EXTERN Tcl_Obj *	Tcl_DbNewLongObj _ANSI_ARGS_((long longValue, 
				CONST char * file, int line));
/* 27 */
EXTERN Tcl_Obj *	Tcl_DbNewObj _ANSI_ARGS_((CONST char * file, 
				int line));
/* 28 */
EXTERN Tcl_Obj *	Tcl_DbNewStringObj _ANSI_ARGS_((CONST char * bytes, 
				int length, CONST char * file, int line));
/* 29 */
EXTERN Tcl_Obj *	Tcl_DuplicateObj _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 30 */
EXTERN void		TclFreeObj _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 31 */
EXTERN int		Tcl_GetBoolean _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int * boolPtr));
/* 32 */
EXTERN int		Tcl_GetBooleanFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr, 
				int * boolPtr));
/* 33 */
EXTERN unsigned char *	Tcl_GetByteArrayFromObj _ANSI_ARGS_((
				Tcl_Obj * objPtr, int * lengthPtr));
/* 34 */
EXTERN int		Tcl_GetDouble _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, double * doublePtr));
/* 35 */
EXTERN int		Tcl_GetDoubleFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr, 
				double * doublePtr));
/* 36 */
EXTERN int		Tcl_GetIndexFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, CONST84 char ** tablePtr, 
				CONST char * msg, int flags, int * indexPtr));
/* 37 */
EXTERN int		Tcl_GetInt _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int * intPtr));
/* 38 */
EXTERN int		Tcl_GetIntFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, int * intPtr));
/* 39 */
EXTERN int		Tcl_GetLongFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, long * longPtr));
/* 40 */
EXTERN Tcl_ObjType *	Tcl_GetObjType _ANSI_ARGS_((CONST char * typeName));
/* 41 */
EXTERN char *		Tcl_GetStringFromObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int * lengthPtr));
/* 42 */
EXTERN void		Tcl_InvalidateStringRep _ANSI_ARGS_((
				Tcl_Obj * objPtr));
/* 43 */
EXTERN int		Tcl_ListObjAppendList _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * listPtr, 
				Tcl_Obj * elemListPtr));
/* 44 */
EXTERN int		Tcl_ListObjAppendElement _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * listPtr, 
				Tcl_Obj * objPtr));
/* 45 */
EXTERN int		Tcl_ListObjGetElements _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * listPtr, 
				int * objcPtr, Tcl_Obj *** objvPtr));
/* 46 */
EXTERN int		Tcl_ListObjIndex _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * listPtr, int index, 
				Tcl_Obj ** objPtrPtr));
/* 47 */
EXTERN int		Tcl_ListObjLength _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * listPtr, int * lengthPtr));
/* 48 */
EXTERN int		Tcl_ListObjReplace _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * listPtr, int first, int count, 
				int objc, Tcl_Obj *CONST objv[]));
/* 49 */
EXTERN Tcl_Obj *	Tcl_NewBooleanObj _ANSI_ARGS_((int boolValue));
/* 50 */
EXTERN Tcl_Obj *	Tcl_NewByteArrayObj _ANSI_ARGS_((
				CONST unsigned char* bytes, int length));
/* 51 */
EXTERN Tcl_Obj *	Tcl_NewDoubleObj _ANSI_ARGS_((double doubleValue));
/* 52 */
EXTERN Tcl_Obj *	Tcl_NewIntObj _ANSI_ARGS_((int intValue));
/* 53 */
EXTERN Tcl_Obj *	Tcl_NewListObj _ANSI_ARGS_((int objc, 
				Tcl_Obj *CONST objv[]));
/* 54 */
EXTERN Tcl_Obj *	Tcl_NewLongObj _ANSI_ARGS_((long longValue));
/* 55 */
EXTERN Tcl_Obj *	Tcl_NewObj _ANSI_ARGS_((void));
/* 56 */
EXTERN Tcl_Obj *	Tcl_NewStringObj _ANSI_ARGS_((CONST char * bytes, 
				int length));
/* 57 */
EXTERN void		Tcl_SetBooleanObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int boolValue));
/* 58 */
EXTERN unsigned char *	Tcl_SetByteArrayLength _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int length));
/* 59 */
EXTERN void		Tcl_SetByteArrayObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				CONST unsigned char * bytes, int length));
/* 60 */
EXTERN void		Tcl_SetDoubleObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				double doubleValue));
/* 61 */
EXTERN void		Tcl_SetIntObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int intValue));
/* 62 */
EXTERN void		Tcl_SetListObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int objc, Tcl_Obj *CONST objv[]));
/* 63 */
EXTERN void		Tcl_SetLongObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				long longValue));
/* 64 */
EXTERN void		Tcl_SetObjLength _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int length));
/* 65 */
EXTERN void		Tcl_SetStringObj _ANSI_ARGS_((Tcl_Obj* objPtr, 
				CONST char* bytes, int length));
/* 66 */
EXTERN void		Tcl_AddErrorInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * message));
/* 67 */
EXTERN void		Tcl_AddObjErrorInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * message, int length));
/* 68 */
EXTERN void		Tcl_AllowExceptions _ANSI_ARGS_((Tcl_Interp * interp));
/* 69 */
EXTERN void		Tcl_AppendElement _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string));
/* 70 */
EXTERN void		Tcl_AppendResult _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp));
/* 71 */
EXTERN Tcl_AsyncHandler	 Tcl_AsyncCreate _ANSI_ARGS_((Tcl_AsyncProc * proc, 
				ClientData clientData));
/* 72 */
EXTERN void		Tcl_AsyncDelete _ANSI_ARGS_((Tcl_AsyncHandler async));
/* 73 */
EXTERN int		Tcl_AsyncInvoke _ANSI_ARGS_((Tcl_Interp * interp, 
				int code));
/* 74 */
EXTERN void		Tcl_AsyncMark _ANSI_ARGS_((Tcl_AsyncHandler async));
/* 75 */
EXTERN int		Tcl_AsyncReady _ANSI_ARGS_((void));
/* 76 */
EXTERN void		Tcl_BackgroundError _ANSI_ARGS_((Tcl_Interp * interp));
/* 77 */
EXTERN char		Tcl_Backslash _ANSI_ARGS_((CONST char * src, 
				int * readPtr));
/* 78 */
EXTERN int		Tcl_BadChannelOption _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * optionName, 
				CONST char * optionList));
/* 79 */
EXTERN void		Tcl_CallWhenDeleted _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_InterpDeleteProc * proc, 
				ClientData clientData));
/* 80 */
EXTERN void		Tcl_CancelIdleCall _ANSI_ARGS_((
				Tcl_IdleProc * idleProc, 
				ClientData clientData));
/* 81 */
EXTERN int		Tcl_Close _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel chan));
/* 82 */
EXTERN int		Tcl_CommandComplete _ANSI_ARGS_((CONST char * cmd));
/* 83 */
EXTERN char *		Tcl_Concat _ANSI_ARGS_((int argc, 
				CONST84 char * CONST * argv));
/* 84 */
EXTERN int		Tcl_ConvertElement _ANSI_ARGS_((CONST char * src, 
				char * dst, int flags));
/* 85 */
EXTERN int		Tcl_ConvertCountedElement _ANSI_ARGS_((
				CONST char * src, int length, char * dst, 
				int flags));
/* 86 */
EXTERN int		Tcl_CreateAlias _ANSI_ARGS_((Tcl_Interp * slave, 
				CONST char * slaveCmd, Tcl_Interp * target, 
				CONST char * targetCmd, int argc, 
				CONST84 char * CONST * argv));
/* 87 */
EXTERN int		Tcl_CreateAliasObj _ANSI_ARGS_((Tcl_Interp * slave, 
				CONST char * slaveCmd, Tcl_Interp * target, 
				CONST char * targetCmd, int objc, 
				Tcl_Obj *CONST objv[]));
/* 88 */
EXTERN Tcl_Channel	Tcl_CreateChannel _ANSI_ARGS_((
				Tcl_ChannelType * typePtr, 
				CONST char * chanName, 
				ClientData instanceData, int mask));
/* 89 */
EXTERN void		Tcl_CreateChannelHandler _ANSI_ARGS_((
				Tcl_Channel chan, int mask, 
				Tcl_ChannelProc * proc, 
				ClientData clientData));
/* 90 */
EXTERN void		Tcl_CreateCloseHandler _ANSI_ARGS_((Tcl_Channel chan, 
				Tcl_CloseProc * proc, ClientData clientData));
/* 91 */
EXTERN Tcl_Command	Tcl_CreateCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * cmdName, Tcl_CmdProc * proc, 
				ClientData clientData, 
				Tcl_CmdDeleteProc * deleteProc));
/* 92 */
EXTERN void		Tcl_CreateEventSource _ANSI_ARGS_((
				Tcl_EventSetupProc * setupProc, 
				Tcl_EventCheckProc * checkProc, 
				ClientData clientData));
/* 93 */
EXTERN void		Tcl_CreateExitHandler _ANSI_ARGS_((
				Tcl_ExitProc * proc, ClientData clientData));
/* 94 */
EXTERN Tcl_Interp *	Tcl_CreateInterp _ANSI_ARGS_((void));
/* 95 */
EXTERN void		Tcl_CreateMathFunc _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, int numArgs, 
				Tcl_ValueType * argTypes, 
				Tcl_MathProc * proc, ClientData clientData));
/* 96 */
EXTERN Tcl_Command	Tcl_CreateObjCommand _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * cmdName, 
				Tcl_ObjCmdProc * proc, ClientData clientData, 
				Tcl_CmdDeleteProc * deleteProc));
/* 97 */
EXTERN Tcl_Interp *	Tcl_CreateSlave _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * slaveName, int isSafe));
/* 98 */
EXTERN Tcl_TimerToken	Tcl_CreateTimerHandler _ANSI_ARGS_((int milliseconds, 
				Tcl_TimerProc * proc, ClientData clientData));
/* 99 */
EXTERN Tcl_Trace	Tcl_CreateTrace _ANSI_ARGS_((Tcl_Interp * interp, 
				int level, Tcl_CmdTraceProc * proc, 
				ClientData clientData));
/* 100 */
EXTERN void		Tcl_DeleteAssocData _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name));
/* 101 */
EXTERN void		Tcl_DeleteChannelHandler _ANSI_ARGS_((
				Tcl_Channel chan, Tcl_ChannelProc * proc, 
				ClientData clientData));
/* 102 */
EXTERN void		Tcl_DeleteCloseHandler _ANSI_ARGS_((Tcl_Channel chan, 
				Tcl_CloseProc * proc, ClientData clientData));
/* 103 */
EXTERN int		Tcl_DeleteCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * cmdName));
/* 104 */
EXTERN int		Tcl_DeleteCommandFromToken _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Command command));
/* 105 */
EXTERN void		Tcl_DeleteEvents _ANSI_ARGS_((
				Tcl_EventDeleteProc * proc, 
				ClientData clientData));
/* 106 */
EXTERN void		Tcl_DeleteEventSource _ANSI_ARGS_((
				Tcl_EventSetupProc * setupProc, 
				Tcl_EventCheckProc * checkProc, 
				ClientData clientData));
/* 107 */
EXTERN void		Tcl_DeleteExitHandler _ANSI_ARGS_((
				Tcl_ExitProc * proc, ClientData clientData));
/* 108 */
EXTERN void		Tcl_DeleteHashEntry _ANSI_ARGS_((
				Tcl_HashEntry * entryPtr));
/* 109 */
EXTERN void		Tcl_DeleteHashTable _ANSI_ARGS_((
				Tcl_HashTable * tablePtr));
/* 110 */
EXTERN void		Tcl_DeleteInterp _ANSI_ARGS_((Tcl_Interp * interp));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 111 */
EXTERN void		Tcl_DetachPids _ANSI_ARGS_((int numPids, 
				Tcl_Pid * pidPtr));
#endif /* UNIX */
#ifdef __WIN32__
/* 111 */
EXTERN void		Tcl_DetachPids _ANSI_ARGS_((int numPids, 
				Tcl_Pid * pidPtr));
#endif /* __WIN32__ */
/* 112 */
EXTERN void		Tcl_DeleteTimerHandler _ANSI_ARGS_((
				Tcl_TimerToken token));
/* 113 */
EXTERN void		Tcl_DeleteTrace _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Trace trace));
/* 114 */
EXTERN void		Tcl_DontCallWhenDeleted _ANSI_ARGS_((
				Tcl_Interp * interp, 
				Tcl_InterpDeleteProc * proc, 
				ClientData clientData));
/* 115 */
EXTERN int		Tcl_DoOneEvent _ANSI_ARGS_((int flags));
/* 116 */
EXTERN void		Tcl_DoWhenIdle _ANSI_ARGS_((Tcl_IdleProc * proc, 
				ClientData clientData));
/* 117 */
EXTERN char *		Tcl_DStringAppend _ANSI_ARGS_((Tcl_DString * dsPtr, 
				CONST char * str, int length));
/* 118 */
EXTERN char *		Tcl_DStringAppendElement _ANSI_ARGS_((
				Tcl_DString * dsPtr, CONST char * string));
/* 119 */
EXTERN void		Tcl_DStringEndSublist _ANSI_ARGS_((
				Tcl_DString * dsPtr));
/* 120 */
EXTERN void		Tcl_DStringFree _ANSI_ARGS_((Tcl_DString * dsPtr));
/* 121 */
EXTERN void		Tcl_DStringGetResult _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_DString * dsPtr));
/* 122 */
EXTERN void		Tcl_DStringInit _ANSI_ARGS_((Tcl_DString * dsPtr));
/* 123 */
EXTERN void		Tcl_DStringResult _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_DString * dsPtr));
/* 124 */
EXTERN void		Tcl_DStringSetLength _ANSI_ARGS_((
				Tcl_DString * dsPtr, int length));
/* 125 */
EXTERN void		Tcl_DStringStartSublist _ANSI_ARGS_((
				Tcl_DString * dsPtr));
/* 126 */
EXTERN int		Tcl_Eof _ANSI_ARGS_((Tcl_Channel chan));
/* 127 */
EXTERN CONST84_RETURN char * Tcl_ErrnoId _ANSI_ARGS_((void));
/* 128 */
EXTERN CONST84_RETURN char * Tcl_ErrnoMsg _ANSI_ARGS_((int err));
/* 129 */
EXTERN int		Tcl_Eval _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string));
/* 130 */
EXTERN int		Tcl_EvalFile _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * fileName));
/* 131 */
EXTERN int		Tcl_EvalObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr));
/* 132 */
EXTERN void		Tcl_EventuallyFree _ANSI_ARGS_((
				ClientData clientData, 
				Tcl_FreeProc * freeProc));
/* 133 */
EXTERN void		Tcl_Exit _ANSI_ARGS_((int status));
/* 134 */
EXTERN int		Tcl_ExposeCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * hiddenCmdToken, 
				CONST char * cmdName));
/* 135 */
EXTERN int		Tcl_ExprBoolean _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int * ptr));
/* 136 */
EXTERN int		Tcl_ExprBooleanObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, int * ptr));
/* 137 */
EXTERN int		Tcl_ExprDouble _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, double * ptr));
/* 138 */
EXTERN int		Tcl_ExprDoubleObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, double * ptr));
/* 139 */
EXTERN int		Tcl_ExprLong _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, long * ptr));
/* 140 */
EXTERN int		Tcl_ExprLongObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, long * ptr));
/* 141 */
EXTERN int		Tcl_ExprObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, Tcl_Obj ** resultPtrPtr));
/* 142 */
EXTERN int		Tcl_ExprString _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string));
/* 143 */
EXTERN void		Tcl_Finalize _ANSI_ARGS_((void));
/* 144 */
EXTERN void		Tcl_FindExecutable _ANSI_ARGS_((CONST char * argv0));
/* 145 */
EXTERN Tcl_HashEntry *	Tcl_FirstHashEntry _ANSI_ARGS_((
				Tcl_HashTable * tablePtr, 
				Tcl_HashSearch * searchPtr));
/* 146 */
EXTERN int		Tcl_Flush _ANSI_ARGS_((Tcl_Channel chan));
/* 147 */
EXTERN void		Tcl_FreeResult _ANSI_ARGS_((Tcl_Interp * interp));
/* 148 */
EXTERN int		Tcl_GetAlias _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * slaveCmd, 
				Tcl_Interp ** targetInterpPtr, 
				CONST84 char ** targetCmdPtr, int * argcPtr, 
				CONST84 char *** argvPtr));
/* 149 */
EXTERN int		Tcl_GetAliasObj _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * slaveCmd, 
				Tcl_Interp ** targetInterpPtr, 
				CONST84 char ** targetCmdPtr, int * objcPtr, 
				Tcl_Obj *** objv));
/* 150 */
EXTERN ClientData	Tcl_GetAssocData _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, 
				Tcl_InterpDeleteProc ** procPtr));
/* 151 */
EXTERN Tcl_Channel	Tcl_GetChannel _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * chanName, int * modePtr));
/* 152 */
EXTERN int		Tcl_GetChannelBufferSize _ANSI_ARGS_((
				Tcl_Channel chan));
/* 153 */
EXTERN int		Tcl_GetChannelHandle _ANSI_ARGS_((Tcl_Channel chan, 
				int direction, ClientData * handlePtr));
/* 154 */
EXTERN ClientData	Tcl_GetChannelInstanceData _ANSI_ARGS_((
				Tcl_Channel chan));
/* 155 */
EXTERN int		Tcl_GetChannelMode _ANSI_ARGS_((Tcl_Channel chan));
/* 156 */
EXTERN CONST84_RETURN char * Tcl_GetChannelName _ANSI_ARGS_((
				Tcl_Channel chan));
/* 157 */
EXTERN int		Tcl_GetChannelOption _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Channel chan, 
				CONST char * optionName, Tcl_DString * dsPtr));
/* 158 */
EXTERN Tcl_ChannelType * Tcl_GetChannelType _ANSI_ARGS_((Tcl_Channel chan));
/* 159 */
EXTERN int		Tcl_GetCommandInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * cmdName, Tcl_CmdInfo * infoPtr));
/* 160 */
EXTERN CONST84_RETURN char * Tcl_GetCommandName _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Command command));
/* 161 */
EXTERN int		Tcl_GetErrno _ANSI_ARGS_((void));
/* 162 */
EXTERN CONST84_RETURN char * Tcl_GetHostName _ANSI_ARGS_((void));
/* 163 */
EXTERN int		Tcl_GetInterpPath _ANSI_ARGS_((
				Tcl_Interp * askInterp, 
				Tcl_Interp * slaveInterp));
/* 164 */
EXTERN Tcl_Interp *	Tcl_GetMaster _ANSI_ARGS_((Tcl_Interp * interp));
/* 165 */
EXTERN CONST char *	Tcl_GetNameOfExecutable _ANSI_ARGS_((void));
/* 166 */
EXTERN Tcl_Obj *	Tcl_GetObjResult _ANSI_ARGS_((Tcl_Interp * interp));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 167 */
EXTERN int		Tcl_GetOpenFile _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int forWriting, 
				int checkUsage, ClientData * filePtr));
#endif /* UNIX */
/* 168 */
EXTERN Tcl_PathType	Tcl_GetPathType _ANSI_ARGS_((CONST char * path));
/* 169 */
EXTERN int		Tcl_Gets _ANSI_ARGS_((Tcl_Channel chan, 
				Tcl_DString * dsPtr));
/* 170 */
EXTERN int		Tcl_GetsObj _ANSI_ARGS_((Tcl_Channel chan, 
				Tcl_Obj * objPtr));
/* 171 */
EXTERN int		Tcl_GetServiceMode _ANSI_ARGS_((void));
/* 172 */
EXTERN Tcl_Interp *	Tcl_GetSlave _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * slaveName));
/* 173 */
EXTERN Tcl_Channel	Tcl_GetStdChannel _ANSI_ARGS_((int type));
/* 174 */
EXTERN CONST84_RETURN char * Tcl_GetStringResult _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 175 */
EXTERN CONST84_RETURN char * Tcl_GetVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags));
/* 176 */
EXTERN CONST84_RETURN char * Tcl_GetVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags));
/* 177 */
EXTERN int		Tcl_GlobalEval _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * command));
/* 178 */
EXTERN int		Tcl_GlobalEvalObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr));
/* 179 */
EXTERN int		Tcl_HideCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * cmdName, 
				CONST char * hiddenCmdToken));
/* 180 */
EXTERN int		Tcl_Init _ANSI_ARGS_((Tcl_Interp * interp));
/* 181 */
EXTERN void		Tcl_InitHashTable _ANSI_ARGS_((
				Tcl_HashTable * tablePtr, int keyType));
/* 182 */
EXTERN int		Tcl_InputBlocked _ANSI_ARGS_((Tcl_Channel chan));
/* 183 */
EXTERN int		Tcl_InputBuffered _ANSI_ARGS_((Tcl_Channel chan));
/* 184 */
EXTERN int		Tcl_InterpDeleted _ANSI_ARGS_((Tcl_Interp * interp));
/* 185 */
EXTERN int		Tcl_IsSafe _ANSI_ARGS_((Tcl_Interp * interp));
/* 186 */
EXTERN char *		Tcl_JoinPath _ANSI_ARGS_((int argc, 
				CONST84 char * CONST * argv, 
				Tcl_DString * resultPtr));
/* 187 */
EXTERN int		Tcl_LinkVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, char * addr, int type));
/* Slot 188 is reserved */
/* 189 */
EXTERN Tcl_Channel	Tcl_MakeFileChannel _ANSI_ARGS_((ClientData handle, 
				int mode));
/* 190 */
EXTERN int		Tcl_MakeSafe _ANSI_ARGS_((Tcl_Interp * interp));
/* 191 */
EXTERN Tcl_Channel	Tcl_MakeTcpClientChannel _ANSI_ARGS_((
				ClientData tcpSocket));
/* 192 */
EXTERN char *		Tcl_Merge _ANSI_ARGS_((int argc, 
				CONST84 char * CONST * argv));
/* 193 */
EXTERN Tcl_HashEntry *	Tcl_NextHashEntry _ANSI_ARGS_((
				Tcl_HashSearch * searchPtr));
/* 194 */
EXTERN void		Tcl_NotifyChannel _ANSI_ARGS_((Tcl_Channel channel, 
				int mask));
/* 195 */
EXTERN Tcl_Obj *	Tcl_ObjGetVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * part1Ptr, Tcl_Obj * part2Ptr, 
				int flags));
/* 196 */
EXTERN Tcl_Obj *	Tcl_ObjSetVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * part1Ptr, Tcl_Obj * part2Ptr, 
				Tcl_Obj * newValuePtr, int flags));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 197 */
EXTERN Tcl_Channel	Tcl_OpenCommandChannel _ANSI_ARGS_((
				Tcl_Interp * interp, int argc, 
				CONST84 char ** argv, int flags));
#endif /* UNIX */
#ifdef __WIN32__
/* 197 */
EXTERN Tcl_Channel	Tcl_OpenCommandChannel _ANSI_ARGS_((
				Tcl_Interp * interp, int argc, 
				CONST84 char ** argv, int flags));
#endif /* __WIN32__ */
/* 198 */
EXTERN Tcl_Channel	Tcl_OpenFileChannel _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * fileName, 
				CONST char * modeString, int permissions));
/* 199 */
EXTERN Tcl_Channel	Tcl_OpenTcpClient _ANSI_ARGS_((Tcl_Interp * interp, 
				int port, CONST char * address, 
				CONST char * myaddr, int myport, int async));
/* 200 */
EXTERN Tcl_Channel	Tcl_OpenTcpServer _ANSI_ARGS_((Tcl_Interp * interp, 
				int port, CONST char * host, 
				Tcl_TcpAcceptProc * acceptProc, 
				ClientData callbackData));
/* 201 */
EXTERN void		Tcl_Preserve _ANSI_ARGS_((ClientData data));
/* 202 */
EXTERN void		Tcl_PrintDouble _ANSI_ARGS_((Tcl_Interp * interp, 
				double value, char * dst));
/* 203 */
EXTERN int		Tcl_PutEnv _ANSI_ARGS_((CONST char * string));
/* 204 */
EXTERN CONST84_RETURN char * Tcl_PosixError _ANSI_ARGS_((Tcl_Interp * interp));
/* 205 */
EXTERN void		Tcl_QueueEvent _ANSI_ARGS_((Tcl_Event * evPtr, 
				Tcl_QueuePosition position));
/* 206 */
EXTERN int		Tcl_Read _ANSI_ARGS_((Tcl_Channel chan, 
				char * bufPtr, int toRead));
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
/* 207 */
EXTERN void		Tcl_ReapDetachedProcs _ANSI_ARGS_((void));
#endif /* UNIX */
#ifdef __WIN32__
/* 207 */
EXTERN void		Tcl_ReapDetachedProcs _ANSI_ARGS_((void));
#endif /* __WIN32__ */
/* 208 */
EXTERN int		Tcl_RecordAndEval _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * cmd, int flags));
/* 209 */
EXTERN int		Tcl_RecordAndEvalObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * cmdPtr, 
				int flags));
/* 210 */
EXTERN void		Tcl_RegisterChannel _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel chan));
/* 211 */
EXTERN void		Tcl_RegisterObjType _ANSI_ARGS_((
				Tcl_ObjType * typePtr));
/* 212 */
EXTERN Tcl_RegExp	Tcl_RegExpCompile _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string));
/* 213 */
EXTERN int		Tcl_RegExpExec _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_RegExp regexp, CONST char * str, 
				CONST char * start));
/* 214 */
EXTERN int		Tcl_RegExpMatch _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, CONST char * pattern));
/* 215 */
EXTERN void		Tcl_RegExpRange _ANSI_ARGS_((Tcl_RegExp regexp, 
				int index, CONST84 char ** startPtr, 
				CONST84 char ** endPtr));
/* 216 */
EXTERN void		Tcl_Release _ANSI_ARGS_((ClientData clientData));
/* 217 */
EXTERN void		Tcl_ResetResult _ANSI_ARGS_((Tcl_Interp * interp));
/* 218 */
EXTERN int		Tcl_ScanElement _ANSI_ARGS_((CONST char * str, 
				int * flagPtr));
/* 219 */
EXTERN int		Tcl_ScanCountedElement _ANSI_ARGS_((CONST char * str, 
				int length, int * flagPtr));
/* 220 */
EXTERN int		Tcl_SeekOld _ANSI_ARGS_((Tcl_Channel chan, 
				int offset, int mode));
/* 221 */
EXTERN int		Tcl_ServiceAll _ANSI_ARGS_((void));
/* 222 */
EXTERN int		Tcl_ServiceEvent _ANSI_ARGS_((int flags));
/* 223 */
EXTERN void		Tcl_SetAssocData _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, 
				Tcl_InterpDeleteProc * proc, 
				ClientData clientData));
/* 224 */
EXTERN void		Tcl_SetChannelBufferSize _ANSI_ARGS_((
				Tcl_Channel chan, int sz));
/* 225 */
EXTERN int		Tcl_SetChannelOption _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Channel chan, 
				CONST char * optionName, 
				CONST char * newValue));
/* 226 */
EXTERN int		Tcl_SetCommandInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * cmdName, 
				CONST Tcl_CmdInfo * infoPtr));
/* 227 */
EXTERN void		Tcl_SetErrno _ANSI_ARGS_((int err));
/* 228 */
EXTERN void		Tcl_SetErrorCode _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp));
/* 229 */
EXTERN void		Tcl_SetMaxBlockTime _ANSI_ARGS_((Tcl_Time * timePtr));
/* 230 */
EXTERN void		Tcl_SetPanicProc _ANSI_ARGS_((
				Tcl_PanicProc * panicProc));
/* 231 */
EXTERN int		Tcl_SetRecursionLimit _ANSI_ARGS_((
				Tcl_Interp * interp, int depth));
/* 232 */
EXTERN void		Tcl_SetResult _ANSI_ARGS_((Tcl_Interp * interp, 
				char * str, Tcl_FreeProc * freeProc));
/* 233 */
EXTERN int		Tcl_SetServiceMode _ANSI_ARGS_((int mode));
/* 234 */
EXTERN void		Tcl_SetObjErrorCode _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * errorObjPtr));
/* 235 */
EXTERN void		Tcl_SetObjResult _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * resultObjPtr));
/* 236 */
EXTERN void		Tcl_SetStdChannel _ANSI_ARGS_((Tcl_Channel channel, 
				int type));
/* 237 */
EXTERN CONST84_RETURN char * Tcl_SetVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, CONST char * newValue, 
				int flags));
/* 238 */
EXTERN CONST84_RETURN char * Tcl_SetVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				CONST char * newValue, int flags));
/* 239 */
EXTERN CONST84_RETURN char * Tcl_SignalId _ANSI_ARGS_((int sig));
/* 240 */
EXTERN CONST84_RETURN char * Tcl_SignalMsg _ANSI_ARGS_((int sig));
/* 241 */
EXTERN void		Tcl_SourceRCFile _ANSI_ARGS_((Tcl_Interp * interp));
/* 242 */
EXTERN int		Tcl_SplitList _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * listStr, int * argcPtr, 
				CONST84 char *** argvPtr));
/* 243 */
EXTERN void		Tcl_SplitPath _ANSI_ARGS_((CONST char * path, 
				int * argcPtr, CONST84 char *** argvPtr));
/* 244 */
EXTERN void		Tcl_StaticPackage _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * pkgName, 
				Tcl_PackageInitProc * initProc, 
				Tcl_PackageInitProc * safeInitProc));
/* 245 */
EXTERN int		Tcl_StringMatch _ANSI_ARGS_((CONST char * str, 
				CONST char * pattern));
/* 246 */
EXTERN int		Tcl_TellOld _ANSI_ARGS_((Tcl_Channel chan));
/* 247 */
EXTERN int		Tcl_TraceVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags, 
				Tcl_VarTraceProc * proc, 
				ClientData clientData));
/* 248 */
EXTERN int		Tcl_TraceVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags, Tcl_VarTraceProc * proc, 
				ClientData clientData));
/* 249 */
EXTERN char *		Tcl_TranslateFileName _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				Tcl_DString * bufferPtr));
/* 250 */
EXTERN int		Tcl_Ungets _ANSI_ARGS_((Tcl_Channel chan, 
				CONST char * str, int len, int atHead));
/* 251 */
EXTERN void		Tcl_UnlinkVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName));
/* 252 */
EXTERN int		Tcl_UnregisterChannel _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Channel chan));
/* 253 */
EXTERN int		Tcl_UnsetVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags));
/* 254 */
EXTERN int		Tcl_UnsetVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags));
/* 255 */
EXTERN void		Tcl_UntraceVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags, 
				Tcl_VarTraceProc * proc, 
				ClientData clientData));
/* 256 */
EXTERN void		Tcl_UntraceVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags, Tcl_VarTraceProc * proc, 
				ClientData clientData));
/* 257 */
EXTERN void		Tcl_UpdateLinkedVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName));
/* 258 */
EXTERN int		Tcl_UpVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * frameName, CONST char * varName, 
				CONST char * localName, int flags));
/* 259 */
EXTERN int		Tcl_UpVar2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * frameName, CONST char * part1, 
				CONST char * part2, CONST char * localName, 
				int flags));
/* 260 */
EXTERN int		Tcl_VarEval _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp));
/* 261 */
EXTERN ClientData	Tcl_VarTraceInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags, 
				Tcl_VarTraceProc * procPtr, 
				ClientData prevClientData));
/* 262 */
EXTERN ClientData	Tcl_VarTraceInfo2 _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags, Tcl_VarTraceProc * procPtr, 
				ClientData prevClientData));
/* 263 */
EXTERN int		Tcl_Write _ANSI_ARGS_((Tcl_Channel chan, 
				CONST char * s, int slen));
/* 264 */
EXTERN void		Tcl_WrongNumArgs _ANSI_ARGS_((Tcl_Interp * interp, 
				int objc, Tcl_Obj *CONST objv[], 
				CONST char * message));
/* 265 */
EXTERN int		Tcl_DumpActiveMemory _ANSI_ARGS_((
				CONST char * fileName));
/* 266 */
EXTERN void		Tcl_ValidateAllMemory _ANSI_ARGS_((CONST char * file, 
				int line));
/* 267 */
EXTERN void		Tcl_AppendResultVA _ANSI_ARGS_((Tcl_Interp * interp, 
				va_list argList));
/* 268 */
EXTERN void		Tcl_AppendStringsToObjVA _ANSI_ARGS_((
				Tcl_Obj * objPtr, va_list argList));
/* 269 */
EXTERN CONST84_RETURN char * Tcl_HashStats _ANSI_ARGS_((
				Tcl_HashTable * tablePtr));
/* 270 */
EXTERN CONST84_RETURN char * Tcl_ParseVar _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, CONST84 char ** termPtr));
/* 271 */
EXTERN CONST84_RETURN char * Tcl_PkgPresent _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, CONST char * version, 
				int exact));
/* 272 */
EXTERN CONST84_RETURN char * Tcl_PkgPresentEx _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				CONST char * version, int exact, 
				ClientData * clientDataPtr));
/* 273 */
EXTERN int		Tcl_PkgProvide _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, CONST char * version));
/* 274 */
EXTERN CONST84_RETURN char * Tcl_PkgRequire _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, CONST char * version, 
				int exact));
/* 275 */
EXTERN void		Tcl_SetErrorCodeVA _ANSI_ARGS_((Tcl_Interp * interp, 
				va_list argList));
/* 276 */
EXTERN int		Tcl_VarEvalVA _ANSI_ARGS_((Tcl_Interp * interp, 
				va_list argList));
/* 277 */
EXTERN Tcl_Pid		Tcl_WaitPid _ANSI_ARGS_((Tcl_Pid pid, int * statPtr, 
				int options));
/* 278 */
EXTERN void		Tcl_PanicVA _ANSI_ARGS_((CONST char * format, 
				va_list argList));
/* 279 */
EXTERN void		Tcl_GetVersion _ANSI_ARGS_((int * major, int * minor, 
				int * patchLevel, int * type));
/* 280 */
EXTERN void		Tcl_InitMemory _ANSI_ARGS_((Tcl_Interp * interp));
/* 281 */
EXTERN Tcl_Channel	Tcl_StackChannel _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_ChannelType * typePtr, 
				ClientData instanceData, int mask, 
				Tcl_Channel prevChan));
/* 282 */
EXTERN int		Tcl_UnstackChannel _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Channel chan));
/* 283 */
EXTERN Tcl_Channel	Tcl_GetStackedChannel _ANSI_ARGS_((Tcl_Channel chan));
/* 284 */
EXTERN void		Tcl_SetMainLoop _ANSI_ARGS_((Tcl_MainLoopProc * proc));
/* Slot 285 is reserved */
/* 286 */
EXTERN void		Tcl_AppendObjToObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				Tcl_Obj * appendObjPtr));
/* 287 */
EXTERN Tcl_Encoding	Tcl_CreateEncoding _ANSI_ARGS_((
				Tcl_EncodingType * typePtr));
/* 288 */
EXTERN void		Tcl_CreateThreadExitHandler _ANSI_ARGS_((
				Tcl_ExitProc * proc, ClientData clientData));
/* 289 */
EXTERN void		Tcl_DeleteThreadExitHandler _ANSI_ARGS_((
				Tcl_ExitProc * proc, ClientData clientData));
/* 290 */
EXTERN void		Tcl_DiscardResult _ANSI_ARGS_((
				Tcl_SavedResult * statePtr));
/* 291 */
EXTERN int		Tcl_EvalEx _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * script, int numBytes, int flags));
/* 292 */
EXTERN int		Tcl_EvalObjv _ANSI_ARGS_((Tcl_Interp * interp, 
				int objc, Tcl_Obj *CONST objv[], int flags));
/* 293 */
EXTERN int		Tcl_EvalObjEx _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, int flags));
/* 294 */
EXTERN void		Tcl_ExitThread _ANSI_ARGS_((int status));
/* 295 */
EXTERN int		Tcl_ExternalToUtf _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Encoding encoding, CONST char * src, 
				int srcLen, int flags, 
				Tcl_EncodingState * statePtr, char * dst, 
				int dstLen, int * srcReadPtr, 
				int * dstWrotePtr, int * dstCharsPtr));
/* 296 */
EXTERN char *		Tcl_ExternalToUtfDString _ANSI_ARGS_((
				Tcl_Encoding encoding, CONST char * src, 
				int srcLen, Tcl_DString * dsPtr));
/* 297 */
EXTERN void		Tcl_FinalizeThread _ANSI_ARGS_((void));
/* 298 */
EXTERN void		Tcl_FinalizeNotifier _ANSI_ARGS_((
				ClientData clientData));
/* 299 */
EXTERN void		Tcl_FreeEncoding _ANSI_ARGS_((Tcl_Encoding encoding));
/* 300 */
EXTERN Tcl_ThreadId	Tcl_GetCurrentThread _ANSI_ARGS_((void));
/* 301 */
EXTERN Tcl_Encoding	Tcl_GetEncoding _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name));
/* 302 */
EXTERN CONST84_RETURN char * Tcl_GetEncodingName _ANSI_ARGS_((
				Tcl_Encoding encoding));
/* 303 */
EXTERN void		Tcl_GetEncodingNames _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 304 */
EXTERN int		Tcl_GetIndexFromObjStruct _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr, 
				CONST VOID * tablePtr, int offset, 
				CONST char * msg, int flags, int * indexPtr));
/* 305 */
EXTERN VOID *		Tcl_GetThreadData _ANSI_ARGS_((
				Tcl_ThreadDataKey * keyPtr, int size));
/* 306 */
EXTERN Tcl_Obj *	Tcl_GetVar2Ex _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				int flags));
/* 307 */
EXTERN ClientData	Tcl_InitNotifier _ANSI_ARGS_((void));
/* 308 */
EXTERN void		Tcl_MutexLock _ANSI_ARGS_((Tcl_Mutex * mutexPtr));
/* 309 */
EXTERN void		Tcl_MutexUnlock _ANSI_ARGS_((Tcl_Mutex * mutexPtr));
/* 310 */
EXTERN void		Tcl_ConditionNotify _ANSI_ARGS_((
				Tcl_Condition * condPtr));
/* 311 */
EXTERN void		Tcl_ConditionWait _ANSI_ARGS_((
				Tcl_Condition * condPtr, 
				Tcl_Mutex * mutexPtr, Tcl_Time * timePtr));
/* 312 */
EXTERN int		Tcl_NumUtfChars _ANSI_ARGS_((CONST char * src, 
				int len));
/* 313 */
EXTERN int		Tcl_ReadChars _ANSI_ARGS_((Tcl_Channel channel, 
				Tcl_Obj * objPtr, int charsToRead, 
				int appendFlag));
/* 314 */
EXTERN void		Tcl_RestoreResult _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_SavedResult * statePtr));
/* 315 */
EXTERN void		Tcl_SaveResult _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_SavedResult * statePtr));
/* 316 */
EXTERN int		Tcl_SetSystemEncoding _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name));
/* 317 */
EXTERN Tcl_Obj *	Tcl_SetVar2Ex _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * part1, CONST char * part2, 
				Tcl_Obj * newValuePtr, int flags));
/* 318 */
EXTERN void		Tcl_ThreadAlert _ANSI_ARGS_((Tcl_ThreadId threadId));
/* 319 */
EXTERN void		Tcl_ThreadQueueEvent _ANSI_ARGS_((
				Tcl_ThreadId threadId, Tcl_Event* evPtr, 
				Tcl_QueuePosition position));
/* 320 */
EXTERN Tcl_UniChar	Tcl_UniCharAtIndex _ANSI_ARGS_((CONST char * src, 
				int index));
/* 321 */
EXTERN Tcl_UniChar	Tcl_UniCharToLower _ANSI_ARGS_((int ch));
/* 322 */
EXTERN Tcl_UniChar	Tcl_UniCharToTitle _ANSI_ARGS_((int ch));
/* 323 */
EXTERN Tcl_UniChar	Tcl_UniCharToUpper _ANSI_ARGS_((int ch));
/* 324 */
EXTERN int		Tcl_UniCharToUtf _ANSI_ARGS_((int ch, char * buf));
/* 325 */
EXTERN CONST84_RETURN char * Tcl_UtfAtIndex _ANSI_ARGS_((CONST char * src, 
				int index));
/* 326 */
EXTERN int		Tcl_UtfCharComplete _ANSI_ARGS_((CONST char * src, 
				int len));
/* 327 */
EXTERN int		Tcl_UtfBackslash _ANSI_ARGS_((CONST char * src, 
				int * readPtr, char * dst));
/* 328 */
EXTERN CONST84_RETURN char * Tcl_UtfFindFirst _ANSI_ARGS_((CONST char * src, 
				int ch));
/* 329 */
EXTERN CONST84_RETURN char * Tcl_UtfFindLast _ANSI_ARGS_((CONST char * src, 
				int ch));
/* 330 */
EXTERN CONST84_RETURN char * Tcl_UtfNext _ANSI_ARGS_((CONST char * src));
/* 331 */
EXTERN CONST84_RETURN char * Tcl_UtfPrev _ANSI_ARGS_((CONST char * src, 
				CONST char * start));
/* 332 */
EXTERN int		Tcl_UtfToExternal _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Encoding encoding, CONST char * src, 
				int srcLen, int flags, 
				Tcl_EncodingState * statePtr, char * dst, 
				int dstLen, int * srcReadPtr, 
				int * dstWrotePtr, int * dstCharsPtr));
/* 333 */
EXTERN char *		Tcl_UtfToExternalDString _ANSI_ARGS_((
				Tcl_Encoding encoding, CONST char * src, 
				int srcLen, Tcl_DString * dsPtr));
/* 334 */
EXTERN int		Tcl_UtfToLower _ANSI_ARGS_((char * src));
/* 335 */
EXTERN int		Tcl_UtfToTitle _ANSI_ARGS_((char * src));
/* 336 */
EXTERN int		Tcl_UtfToUniChar _ANSI_ARGS_((CONST char * src, 
				Tcl_UniChar * chPtr));
/* 337 */
EXTERN int		Tcl_UtfToUpper _ANSI_ARGS_((char * src));
/* 338 */
EXTERN int		Tcl_WriteChars _ANSI_ARGS_((Tcl_Channel chan, 
				CONST char * src, int srcLen));
/* 339 */
EXTERN int		Tcl_WriteObj _ANSI_ARGS_((Tcl_Channel chan, 
				Tcl_Obj * objPtr));
/* 340 */
EXTERN char *		Tcl_GetString _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 341 */
EXTERN CONST84_RETURN char * Tcl_GetDefaultEncodingDir _ANSI_ARGS_((void));
/* 342 */
EXTERN void		Tcl_SetDefaultEncodingDir _ANSI_ARGS_((
				CONST char * path));
/* 343 */
EXTERN void		Tcl_AlertNotifier _ANSI_ARGS_((ClientData clientData));
/* 344 */
EXTERN void		Tcl_ServiceModeHook _ANSI_ARGS_((int mode));
/* 345 */
EXTERN int		Tcl_UniCharIsAlnum _ANSI_ARGS_((int ch));
/* 346 */
EXTERN int		Tcl_UniCharIsAlpha _ANSI_ARGS_((int ch));
/* 347 */
EXTERN int		Tcl_UniCharIsDigit _ANSI_ARGS_((int ch));
/* 348 */
EXTERN int		Tcl_UniCharIsLower _ANSI_ARGS_((int ch));
/* 349 */
EXTERN int		Tcl_UniCharIsSpace _ANSI_ARGS_((int ch));
/* 350 */
EXTERN int		Tcl_UniCharIsUpper _ANSI_ARGS_((int ch));
/* 351 */
EXTERN int		Tcl_UniCharIsWordChar _ANSI_ARGS_((int ch));
/* 352 */
EXTERN int		Tcl_UniCharLen _ANSI_ARGS_((CONST Tcl_UniChar * str));
/* 353 */
EXTERN int		Tcl_UniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar * cs, 
				CONST Tcl_UniChar * ct, unsigned long n));
/* 354 */
EXTERN char *		Tcl_UniCharToUtfDString _ANSI_ARGS_((
				CONST Tcl_UniChar * string, int numChars, 
				Tcl_DString * dsPtr));
/* 355 */
EXTERN Tcl_UniChar *	Tcl_UtfToUniCharDString _ANSI_ARGS_((
				CONST char * string, int length, 
				Tcl_DString * dsPtr));
/* 356 */
EXTERN Tcl_RegExp	Tcl_GetRegExpFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * patObj, 
				int flags));
/* 357 */
EXTERN Tcl_Obj *	Tcl_EvalTokens _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Token * tokenPtr, int count));
/* 358 */
EXTERN void		Tcl_FreeParse _ANSI_ARGS_((Tcl_Parse * parsePtr));
/* 359 */
EXTERN void		Tcl_LogCommandInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * script, CONST char * command, 
				int length));
/* 360 */
EXTERN int		Tcl_ParseBraces _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string, int numBytes, 
				Tcl_Parse * parsePtr, int append, 
				CONST84 char ** termPtr));
/* 361 */
EXTERN int		Tcl_ParseCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string, int numBytes, 
				int nested, Tcl_Parse * parsePtr));
/* 362 */
EXTERN int		Tcl_ParseExpr _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string, int numBytes, 
				Tcl_Parse * parsePtr));
/* 363 */
EXTERN int		Tcl_ParseQuotedString _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * string, 
				int numBytes, Tcl_Parse * parsePtr, 
				int append, CONST84 char ** termPtr));
/* 364 */
EXTERN int		Tcl_ParseVarName _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string, int numBytes, 
				Tcl_Parse * parsePtr, int append));
/* 365 */
EXTERN char *		Tcl_GetCwd _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_DString * cwdPtr));
/* 366 */
EXTERN int		Tcl_Chdir _ANSI_ARGS_((CONST char * dirName));
/* 367 */
EXTERN int		Tcl_Access _ANSI_ARGS_((CONST char * path, int mode));
/* 368 */
EXTERN int		Tcl_Stat _ANSI_ARGS_((CONST char * path, 
				struct stat * bufPtr));
/* 369 */
EXTERN int		Tcl_UtfNcmp _ANSI_ARGS_((CONST char * s1, 
				CONST char * s2, unsigned long n));
/* 370 */
EXTERN int		Tcl_UtfNcasecmp _ANSI_ARGS_((CONST char * s1, 
				CONST char * s2, unsigned long n));
/* 371 */
EXTERN int		Tcl_StringCaseMatch _ANSI_ARGS_((CONST char * str, 
				CONST char * pattern, int nocase));
/* 372 */
EXTERN int		Tcl_UniCharIsControl _ANSI_ARGS_((int ch));
/* 373 */
EXTERN int		Tcl_UniCharIsGraph _ANSI_ARGS_((int ch));
/* 374 */
EXTERN int		Tcl_UniCharIsPrint _ANSI_ARGS_((int ch));
/* 375 */
EXTERN int		Tcl_UniCharIsPunct _ANSI_ARGS_((int ch));
/* 376 */
EXTERN int		Tcl_RegExpExecObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_RegExp regexp, Tcl_Obj * objPtr, 
				int offset, int nmatches, int flags));
/* 377 */
EXTERN void		Tcl_RegExpGetInfo _ANSI_ARGS_((Tcl_RegExp regexp, 
				Tcl_RegExpInfo * infoPtr));
/* 378 */
EXTERN Tcl_Obj *	Tcl_NewUnicodeObj _ANSI_ARGS_((
				CONST Tcl_UniChar * unicode, int numChars));
/* 379 */
EXTERN void		Tcl_SetUnicodeObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				CONST Tcl_UniChar * unicode, int numChars));
/* 380 */
EXTERN int		Tcl_GetCharLength _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 381 */
EXTERN Tcl_UniChar	Tcl_GetUniChar _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int index));
/* 382 */
EXTERN Tcl_UniChar *	Tcl_GetUnicode _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 383 */
EXTERN Tcl_Obj *	Tcl_GetRange _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int first, int last));
/* 384 */
EXTERN void		Tcl_AppendUnicodeToObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				CONST Tcl_UniChar * unicode, int length));
/* 385 */
EXTERN int		Tcl_RegExpMatchObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * stringObj, Tcl_Obj * patternObj));
/* 386 */
EXTERN void		Tcl_SetNotifier _ANSI_ARGS_((
				Tcl_NotifierProcs * notifierProcPtr));
/* 387 */
EXTERN Tcl_Mutex *	Tcl_GetAllocMutex _ANSI_ARGS_((void));
/* 388 */
EXTERN int		Tcl_GetChannelNames _ANSI_ARGS_((Tcl_Interp * interp));
/* 389 */
EXTERN int		Tcl_GetChannelNamesEx _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * pattern));
/* 390 */
EXTERN int		Tcl_ProcObjCmd _ANSI_ARGS_((ClientData clientData, 
				Tcl_Interp * interp, int objc, 
				Tcl_Obj *CONST objv[]));
/* 391 */
EXTERN void		Tcl_ConditionFinalize _ANSI_ARGS_((
				Tcl_Condition * condPtr));
/* 392 */
EXTERN void		Tcl_MutexFinalize _ANSI_ARGS_((Tcl_Mutex * mutex));
/* 393 */
EXTERN int		Tcl_CreateThread _ANSI_ARGS_((Tcl_ThreadId * idPtr, 
				Tcl_ThreadCreateProc proc, 
				ClientData clientData, int stackSize, 
				int flags));
/* 394 */
EXTERN int		Tcl_ReadRaw _ANSI_ARGS_((Tcl_Channel chan, 
				char * dst, int bytesToRead));
/* 395 */
EXTERN int		Tcl_WriteRaw _ANSI_ARGS_((Tcl_Channel chan, 
				CONST char * src, int srcLen));
/* 396 */
EXTERN Tcl_Channel	Tcl_GetTopChannel _ANSI_ARGS_((Tcl_Channel chan));
/* 397 */
EXTERN int		Tcl_ChannelBuffered _ANSI_ARGS_((Tcl_Channel chan));
/* 398 */
EXTERN CONST84_RETURN char * Tcl_ChannelName _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 399 */
EXTERN Tcl_ChannelTypeVersion Tcl_ChannelVersion _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 400 */
EXTERN Tcl_DriverBlockModeProc * Tcl_ChannelBlockModeProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 401 */
EXTERN Tcl_DriverCloseProc * Tcl_ChannelCloseProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 402 */
EXTERN Tcl_DriverClose2Proc * Tcl_ChannelClose2Proc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 403 */
EXTERN Tcl_DriverInputProc * Tcl_ChannelInputProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 404 */
EXTERN Tcl_DriverOutputProc * Tcl_ChannelOutputProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 405 */
EXTERN Tcl_DriverSeekProc * Tcl_ChannelSeekProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 406 */
EXTERN Tcl_DriverSetOptionProc * Tcl_ChannelSetOptionProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 407 */
EXTERN Tcl_DriverGetOptionProc * Tcl_ChannelGetOptionProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 408 */
EXTERN Tcl_DriverWatchProc * Tcl_ChannelWatchProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 409 */
EXTERN Tcl_DriverGetHandleProc * Tcl_ChannelGetHandleProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 410 */
EXTERN Tcl_DriverFlushProc * Tcl_ChannelFlushProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 411 */
EXTERN Tcl_DriverHandlerProc * Tcl_ChannelHandlerProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* 412 */
EXTERN int		Tcl_JoinThread _ANSI_ARGS_((Tcl_ThreadId threadId, 
				int* result));
/* 413 */
EXTERN int		Tcl_IsChannelShared _ANSI_ARGS_((Tcl_Channel channel));
/* 414 */
EXTERN int		Tcl_IsChannelRegistered _ANSI_ARGS_((
				Tcl_Interp* interp, Tcl_Channel channel));
/* 415 */
EXTERN void		Tcl_CutChannel _ANSI_ARGS_((Tcl_Channel channel));
/* 416 */
EXTERN void		Tcl_SpliceChannel _ANSI_ARGS_((Tcl_Channel channel));
/* 417 */
EXTERN void		Tcl_ClearChannelHandlers _ANSI_ARGS_((
				Tcl_Channel channel));
/* 418 */
EXTERN int		Tcl_IsChannelExisting _ANSI_ARGS_((
				CONST char* channelName));
/* 419 */
EXTERN int		Tcl_UniCharNcasecmp _ANSI_ARGS_((
				CONST Tcl_UniChar * cs, 
				CONST Tcl_UniChar * ct, unsigned long n));
/* 420 */
EXTERN int		Tcl_UniCharCaseMatch _ANSI_ARGS_((
				CONST Tcl_UniChar * ustr, 
				CONST Tcl_UniChar * pattern, int nocase));
/* 421 */
EXTERN Tcl_HashEntry *	Tcl_FindHashEntry _ANSI_ARGS_((
				Tcl_HashTable * tablePtr, CONST char * key));
/* 422 */
EXTERN Tcl_HashEntry *	Tcl_CreateHashEntry _ANSI_ARGS_((
				Tcl_HashTable * tablePtr, CONST char * key, 
				int * newPtr));
/* 423 */
EXTERN void		Tcl_InitCustomHashTable _ANSI_ARGS_((
				Tcl_HashTable * tablePtr, int keyType, 
				Tcl_HashKeyType * typePtr));
/* 424 */
EXTERN void		Tcl_InitObjHashTable _ANSI_ARGS_((
				Tcl_HashTable * tablePtr));
/* 425 */
EXTERN ClientData	Tcl_CommandTraceInfo _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * varName, 
				int flags, Tcl_CommandTraceProc * procPtr, 
				ClientData prevClientData));
/* 426 */
EXTERN int		Tcl_TraceCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags, 
				Tcl_CommandTraceProc * proc, 
				ClientData clientData));
/* 427 */
EXTERN void		Tcl_UntraceCommand _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * varName, int flags, 
				Tcl_CommandTraceProc * proc, 
				ClientData clientData));
/* 428 */
EXTERN char *		Tcl_AttemptAlloc _ANSI_ARGS_((unsigned int size));
/* 429 */
EXTERN char *		Tcl_AttemptDbCkalloc _ANSI_ARGS_((unsigned int size, 
				CONST char * file, int line));
/* 430 */
EXTERN char *		Tcl_AttemptRealloc _ANSI_ARGS_((char * ptr, 
				unsigned int size));
/* 431 */
EXTERN char *		Tcl_AttemptDbCkrealloc _ANSI_ARGS_((char * ptr, 
				unsigned int size, CONST char * file, 
				int line));
/* 432 */
EXTERN int		Tcl_AttemptSetObjLength _ANSI_ARGS_((
				Tcl_Obj * objPtr, int length));
/* 433 */
EXTERN Tcl_ThreadId	Tcl_GetChannelThread _ANSI_ARGS_((
				Tcl_Channel channel));
/* 434 */
EXTERN Tcl_UniChar *	Tcl_GetUnicodeFromObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				int * lengthPtr));
/* 435 */
EXTERN int		Tcl_GetMathFuncInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, int * numArgsPtr, 
				Tcl_ValueType ** argTypesPtr, 
				Tcl_MathProc ** procPtr, 
				ClientData * clientDataPtr));
/* 436 */
EXTERN Tcl_Obj *	Tcl_ListMathFuncs _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * pattern));
/* 437 */
EXTERN Tcl_Obj *	Tcl_SubstObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, int flags));
/* 438 */
EXTERN int		Tcl_DetachChannel _ANSI_ARGS_((Tcl_Interp* interp, 
				Tcl_Channel channel));
/* 439 */
EXTERN int		Tcl_IsStandardChannel _ANSI_ARGS_((
				Tcl_Channel channel));
/* 440 */
EXTERN int		Tcl_FSCopyFile _ANSI_ARGS_((Tcl_Obj * srcPathPtr, 
				Tcl_Obj * destPathPtr));
/* 441 */
EXTERN int		Tcl_FSCopyDirectory _ANSI_ARGS_((
				Tcl_Obj * srcPathPtr, Tcl_Obj * destPathPtr, 
				Tcl_Obj ** errorPtr));
/* 442 */
EXTERN int		Tcl_FSCreateDirectory _ANSI_ARGS_((Tcl_Obj * pathPtr));
/* 443 */
EXTERN int		Tcl_FSDeleteFile _ANSI_ARGS_((Tcl_Obj * pathPtr));
/* 444 */
EXTERN int		Tcl_FSLoadFile _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * pathPtr, CONST char * sym1, 
				CONST char * sym2, 
				Tcl_PackageInitProc ** proc1Ptr, 
				Tcl_PackageInitProc ** proc2Ptr, 
				Tcl_LoadHandle * handlePtr, 
				Tcl_FSUnloadFileProc ** unloadProcPtr));
/* 445 */
EXTERN int		Tcl_FSMatchInDirectory _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * result, 
				Tcl_Obj * pathPtr, CONST char * pattern, 
				Tcl_GlobTypeData * types));
/* 446 */
EXTERN Tcl_Obj *	Tcl_FSLink _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				Tcl_Obj * toPtr, int linkAction));
/* 447 */
EXTERN int		Tcl_FSRemoveDirectory _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				int recursive, Tcl_Obj ** errorPtr));
/* 448 */
EXTERN int		Tcl_FSRenameFile _ANSI_ARGS_((Tcl_Obj * srcPathPtr, 
				Tcl_Obj * destPathPtr));
/* 449 */
EXTERN int		Tcl_FSLstat _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				Tcl_StatBuf * buf));
/* 450 */
EXTERN int		Tcl_FSUtime _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				struct utimbuf * tval));
/* 451 */
EXTERN int		Tcl_FSFileAttrsGet _ANSI_ARGS_((Tcl_Interp * interp, 
				int index, Tcl_Obj * pathPtr, 
				Tcl_Obj ** objPtrRef));
/* 452 */
EXTERN int		Tcl_FSFileAttrsSet _ANSI_ARGS_((Tcl_Interp * interp, 
				int index, Tcl_Obj * pathPtr, 
				Tcl_Obj * objPtr));
/* 453 */
EXTERN CONST char **	Tcl_FSFileAttrStrings _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				Tcl_Obj ** objPtrRef));
/* 454 */
EXTERN int		Tcl_FSStat _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				Tcl_StatBuf * buf));
/* 455 */
EXTERN int		Tcl_FSAccess _ANSI_ARGS_((Tcl_Obj * pathPtr, 
				int mode));
/* 456 */
EXTERN Tcl_Channel	Tcl_FSOpenFileChannel _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * pathPtr, 
				CONST char * modeString, int permissions));
/* 457 */
EXTERN Tcl_Obj*		Tcl_FSGetCwd _ANSI_ARGS_((Tcl_Interp * interp));
/* 458 */
EXTERN int		Tcl_FSChdir _ANSI_ARGS_((Tcl_Obj * pathPtr));
/* 459 */
EXTERN int		Tcl_FSConvertToPathType _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * pathPtr));
/* 460 */
EXTERN Tcl_Obj*		Tcl_FSJoinPath _ANSI_ARGS_((Tcl_Obj * listObj, 
				int elements));
/* 461 */
EXTERN Tcl_Obj*		Tcl_FSSplitPath _ANSI_ARGS_((Tcl_Obj* pathPtr, 
				int * lenPtr));
/* 462 */
EXTERN int		Tcl_FSEqualPaths _ANSI_ARGS_((Tcl_Obj* firstPtr, 
				Tcl_Obj* secondPtr));
/* 463 */
EXTERN Tcl_Obj*		Tcl_FSGetNormalizedPath _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj* pathObjPtr));
/* 464 */
EXTERN Tcl_Obj*		Tcl_FSJoinToPath _ANSI_ARGS_((Tcl_Obj * basePtr, 
				int objc, Tcl_Obj *CONST objv[]));
/* 465 */
EXTERN ClientData	Tcl_FSGetInternalRep _ANSI_ARGS_((
				Tcl_Obj* pathObjPtr, Tcl_Filesystem * fsPtr));
/* 466 */
EXTERN Tcl_Obj*		Tcl_FSGetTranslatedPath _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj* pathPtr));
/* 467 */
EXTERN int		Tcl_FSEvalFile _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * fileName));
/* 468 */
EXTERN Tcl_Obj*		Tcl_FSNewNativePath _ANSI_ARGS_((
				Tcl_Filesystem* fromFilesystem, 
				ClientData clientData));
/* 469 */
EXTERN CONST char*	Tcl_FSGetNativePath _ANSI_ARGS_((Tcl_Obj* pathObjPtr));
/* 470 */
EXTERN Tcl_Obj*		Tcl_FSFileSystemInfo _ANSI_ARGS_((
				Tcl_Obj* pathObjPtr));
/* 471 */
EXTERN Tcl_Obj*		Tcl_FSPathSeparator _ANSI_ARGS_((Tcl_Obj* pathObjPtr));
/* 472 */
EXTERN Tcl_Obj*		Tcl_FSListVolumes _ANSI_ARGS_((void));
/* 473 */
EXTERN int		Tcl_FSRegister _ANSI_ARGS_((ClientData clientData, 
				Tcl_Filesystem * fsPtr));
/* 474 */
EXTERN int		Tcl_FSUnregister _ANSI_ARGS_((Tcl_Filesystem * fsPtr));
/* 475 */
EXTERN ClientData	Tcl_FSData _ANSI_ARGS_((Tcl_Filesystem * fsPtr));
/* 476 */
EXTERN CONST char*	Tcl_FSGetTranslatedStringPath _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj* pathPtr));
/* 477 */
EXTERN Tcl_Filesystem*	Tcl_FSGetFileSystemForPath _ANSI_ARGS_((
				Tcl_Obj* pathObjPtr));
/* 478 */
EXTERN Tcl_PathType	Tcl_FSGetPathType _ANSI_ARGS_((Tcl_Obj * pathObjPtr));
/* 479 */
EXTERN int		Tcl_OutputBuffered _ANSI_ARGS_((Tcl_Channel chan));
/* 480 */
EXTERN void		Tcl_FSMountsChanged _ANSI_ARGS_((
				Tcl_Filesystem * fsPtr));
/* 481 */
EXTERN int		Tcl_EvalTokensStandard _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Token * tokenPtr, 
				int count));
/* 482 */
EXTERN void		Tcl_GetTime _ANSI_ARGS_((Tcl_Time* timeBuf));
/* 483 */
EXTERN Tcl_Trace	Tcl_CreateObjTrace _ANSI_ARGS_((Tcl_Interp* interp, 
				int level, int flags, 
				Tcl_CmdObjTraceProc* objProc, 
				ClientData clientData, 
				Tcl_CmdObjTraceDeleteProc* delProc));
/* 484 */
EXTERN int		Tcl_GetCommandInfoFromToken _ANSI_ARGS_((
				Tcl_Command token, Tcl_CmdInfo* infoPtr));
/* 485 */
EXTERN int		Tcl_SetCommandInfoFromToken _ANSI_ARGS_((
				Tcl_Command token, 
				CONST Tcl_CmdInfo* infoPtr));
/* 486 */
EXTERN Tcl_Obj *	Tcl_DbNewWideIntObj _ANSI_ARGS_((
				Tcl_WideInt wideValue, CONST char * file, 
				int line));
/* 487 */
EXTERN int		Tcl_GetWideIntFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr, 
				Tcl_WideInt * widePtr));
/* 488 */
EXTERN Tcl_Obj *	Tcl_NewWideIntObj _ANSI_ARGS_((Tcl_WideInt wideValue));
/* 489 */
EXTERN void		Tcl_SetWideIntObj _ANSI_ARGS_((Tcl_Obj * objPtr, 
				Tcl_WideInt wideValue));
/* 490 */
EXTERN Tcl_StatBuf *	Tcl_AllocStatBuf _ANSI_ARGS_((void));
/* 491 */
EXTERN Tcl_WideInt	Tcl_Seek _ANSI_ARGS_((Tcl_Channel chan, 
				Tcl_WideInt offset, int mode));
/* 492 */
EXTERN Tcl_WideInt	Tcl_Tell _ANSI_ARGS_((Tcl_Channel chan));
/* 493 */
EXTERN Tcl_DriverWideSeekProc * Tcl_ChannelWideSeekProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* Slot 494 is reserved */
/* Slot 495 is reserved */
/* Slot 496 is reserved */
/* Slot 497 is reserved */
/* Slot 498 is reserved */
/* Slot 499 is reserved */
/* Slot 500 is reserved */
/* Slot 501 is reserved */
/* Slot 502 is reserved */
/* Slot 503 is reserved */
/* Slot 504 is reserved */
/* Slot 505 is reserved */
/* Slot 506 is reserved */
/* Slot 507 is reserved */
/* Slot 508 is reserved */
/* Slot 509 is reserved */
/* Slot 510 is reserved */
/* Slot 511 is reserved */
/* Slot 512 is reserved */
/* Slot 513 is reserved */
/* Slot 514 is reserved */
/* Slot 515 is reserved */
/* Slot 516 is reserved */
/* Slot 517 is reserved */
/* Slot 518 is reserved */
/* Slot 519 is reserved */
/* Slot 520 is reserved */
/* Slot 521 is reserved */
/* Slot 522 is reserved */
/* Slot 523 is reserved */
/* Slot 524 is reserved */
/* Slot 525 is reserved */
/* Slot 526 is reserved */
/* Slot 527 is reserved */
/* Slot 528 is reserved */
/* Slot 529 is reserved */
/* Slot 530 is reserved */
/* Slot 531 is reserved */
/* Slot 532 is reserved */
/* Slot 533 is reserved */
/* Slot 534 is reserved */
/* Slot 535 is reserved */
/* Slot 536 is reserved */
/* Slot 537 is reserved */
/* Slot 538 is reserved */
/* Slot 539 is reserved */
/* Slot 540 is reserved */
/* Slot 541 is reserved */
/* Slot 542 is reserved */
/* Slot 543 is reserved */
/* Slot 544 is reserved */
/* Slot 545 is reserved */
/* Slot 546 is reserved */
/* Slot 547 is reserved */
/* Slot 548 is reserved */
/* Slot 549 is reserved */
/* Slot 550 is reserved */
/* Slot 551 is reserved */
/* Slot 552 is reserved */
/* Slot 553 is reserved */
/* 554 */
EXTERN Tcl_DriverThreadActionProc * Tcl_ChannelThreadActionProc _ANSI_ARGS_((
				Tcl_ChannelType * chanTypePtr));
/* Slot 555 is reserved */
/* Slot 556 is reserved */
/* Slot 557 is reserved */
/* Slot 558 is reserved */
/* Slot 559 is reserved */
/* Slot 560 is reserved */
/* Slot 561 is reserved */
/* Slot 562 is reserved */
/* Slot 563 is reserved */
/* Slot 564 is reserved */
/* Slot 565 is reserved */
/* Slot 566 is reserved */
/* Slot 567 is reserved */
/* Slot 568 is reserved */
/* Slot 569 is reserved */
/* Slot 570 is reserved */
/* Slot 571 is reserved */
/* Slot 572 is reserved */
/* 573 */
EXTERN int		Tcl_PkgRequireProc _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, int objc, 
				Tcl_Obj *CONST objv[], 
				ClientData * clientDataPtr));

typedef struct TclStubHooks {
    struct TclPlatStubs *tclPlatStubs;
    struct TclIntStubs *tclIntStubs;
    struct TclIntPlatStubs *tclIntPlatStubs;
} TclStubHooks;

typedef struct TclStubs {
    int magic;
    struct TclStubHooks *hooks;

    int (*tcl_PkgProvideEx) _ANSI_ARGS_((Tcl_Interp* interp, CONST char* name, CONST char* version, ClientData clientData)); /* 0 */
    CONST84_RETURN char * (*tcl_PkgRequireEx) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, CONST char * version, int exact, ClientData * clientDataPtr)); /* 1 */
    void (*tcl_Panic) _ANSI_ARGS_(TCL_VARARGS(CONST char *,format)); /* 2 */
    char * (*tcl_Alloc) _ANSI_ARGS_((unsigned int size)); /* 3 */
    void (*tcl_Free) _ANSI_ARGS_((char * ptr)); /* 4 */
    char * (*tcl_Realloc) _ANSI_ARGS_((char * ptr, unsigned int size)); /* 5 */
    char * (*tcl_DbCkalloc) _ANSI_ARGS_((unsigned int size, CONST char * file, int line)); /* 6 */
    int (*tcl_DbCkfree) _ANSI_ARGS_((char * ptr, CONST char * file, int line)); /* 7 */
    char * (*tcl_DbCkrealloc) _ANSI_ARGS_((char * ptr, unsigned int size, CONST char * file, int line)); /* 8 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void (*tcl_CreateFileHandler) _ANSI_ARGS_((int fd, int mask, Tcl_FileProc * proc, ClientData clientData)); /* 9 */
#endif /* UNIX */
#ifdef __WIN32__
    void *reserved9;
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved9;
#endif /* MAC_TCL */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void (*tcl_DeleteFileHandler) _ANSI_ARGS_((int fd)); /* 10 */
#endif /* UNIX */
#ifdef __WIN32__
    void *reserved10;
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved10;
#endif /* MAC_TCL */
    void (*tcl_SetTimer) _ANSI_ARGS_((Tcl_Time * timePtr)); /* 11 */
    void (*tcl_Sleep) _ANSI_ARGS_((int ms)); /* 12 */
    int (*tcl_WaitForEvent) _ANSI_ARGS_((Tcl_Time * timePtr)); /* 13 */
    int (*tcl_AppendAllObjTypes) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr)); /* 14 */
    void (*tcl_AppendStringsToObj) _ANSI_ARGS_(TCL_VARARGS(Tcl_Obj *,objPtr)); /* 15 */
    void (*tcl_AppendToObj) _ANSI_ARGS_((Tcl_Obj* objPtr, CONST char* bytes, int length)); /* 16 */
    Tcl_Obj * (*tcl_ConcatObj) _ANSI_ARGS_((int objc, Tcl_Obj *CONST objv[])); /* 17 */
    int (*tcl_ConvertToType) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, Tcl_ObjType * typePtr)); /* 18 */
    void (*tcl_DbDecrRefCount) _ANSI_ARGS_((Tcl_Obj * objPtr, CONST char * file, int line)); /* 19 */
    void (*tcl_DbIncrRefCount) _ANSI_ARGS_((Tcl_Obj * objPtr, CONST char * file, int line)); /* 20 */
    int (*tcl_DbIsShared) _ANSI_ARGS_((Tcl_Obj * objPtr, CONST char * file, int line)); /* 21 */
    Tcl_Obj * (*tcl_DbNewBooleanObj) _ANSI_ARGS_((int boolValue, CONST char * file, int line)); /* 22 */
    Tcl_Obj * (*tcl_DbNewByteArrayObj) _ANSI_ARGS_((CONST unsigned char * bytes, int length, CONST char * file, int line)); /* 23 */
    Tcl_Obj * (*tcl_DbNewDoubleObj) _ANSI_ARGS_((double doubleValue, CONST char * file, int line)); /* 24 */
    Tcl_Obj * (*tcl_DbNewListObj) _ANSI_ARGS_((int objc, Tcl_Obj *CONST * objv, CONST char * file, int line)); /* 25 */
    Tcl_Obj * (*tcl_DbNewLongObj) _ANSI_ARGS_((long longValue, CONST char * file, int line)); /* 26 */
    Tcl_Obj * (*tcl_DbNewObj) _ANSI_ARGS_((CONST char * file, int line)); /* 27 */
    Tcl_Obj * (*tcl_DbNewStringObj) _ANSI_ARGS_((CONST char * bytes, int length, CONST char * file, int line)); /* 28 */
    Tcl_Obj * (*tcl_DuplicateObj) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 29 */
    void (*tclFreeObj) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 30 */
    int (*tcl_GetBoolean) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int * boolPtr)); /* 31 */
    int (*tcl_GetBooleanFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, int * boolPtr)); /* 32 */
    unsigned char * (*tcl_GetByteArrayFromObj) _ANSI_ARGS_((Tcl_Obj * objPtr, int * lengthPtr)); /* 33 */
    int (*tcl_GetDouble) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, double * doublePtr)); /* 34 */
    int (*tcl_GetDoubleFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, double * doublePtr)); /* 35 */
    int (*tcl_GetIndexFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, CONST84 char ** tablePtr, CONST char * msg, int flags, int * indexPtr)); /* 36 */
    int (*tcl_GetInt) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int * intPtr)); /* 37 */
    int (*tcl_GetIntFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, int * intPtr)); /* 38 */
    int (*tcl_GetLongFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, long * longPtr)); /* 39 */
    Tcl_ObjType * (*tcl_GetObjType) _ANSI_ARGS_((CONST char * typeName)); /* 40 */
    char * (*tcl_GetStringFromObj) _ANSI_ARGS_((Tcl_Obj * objPtr, int * lengthPtr)); /* 41 */
    void (*tcl_InvalidateStringRep) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 42 */
    int (*tcl_ListObjAppendList) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, Tcl_Obj * elemListPtr)); /* 43 */
    int (*tcl_ListObjAppendElement) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, Tcl_Obj * objPtr)); /* 44 */
    int (*tcl_ListObjGetElements) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, int * objcPtr, Tcl_Obj *** objvPtr)); /* 45 */
    int (*tcl_ListObjIndex) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, int index, Tcl_Obj ** objPtrPtr)); /* 46 */
    int (*tcl_ListObjLength) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, int * lengthPtr)); /* 47 */
    int (*tcl_ListObjReplace) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * listPtr, int first, int count, int objc, Tcl_Obj *CONST objv[])); /* 48 */
    Tcl_Obj * (*tcl_NewBooleanObj) _ANSI_ARGS_((int boolValue)); /* 49 */
    Tcl_Obj * (*tcl_NewByteArrayObj) _ANSI_ARGS_((CONST unsigned char* bytes, int length)); /* 50 */
    Tcl_Obj * (*tcl_NewDoubleObj) _ANSI_ARGS_((double doubleValue)); /* 51 */
    Tcl_Obj * (*tcl_NewIntObj) _ANSI_ARGS_((int intValue)); /* 52 */
    Tcl_Obj * (*tcl_NewListObj) _ANSI_ARGS_((int objc, Tcl_Obj *CONST objv[])); /* 53 */
    Tcl_Obj * (*tcl_NewLongObj) _ANSI_ARGS_((long longValue)); /* 54 */
    Tcl_Obj * (*tcl_NewObj) _ANSI_ARGS_((void)); /* 55 */
    Tcl_Obj * (*tcl_NewStringObj) _ANSI_ARGS_((CONST char * bytes, int length)); /* 56 */
    void (*tcl_SetBooleanObj) _ANSI_ARGS_((Tcl_Obj * objPtr, int boolValue)); /* 57 */
    unsigned char * (*tcl_SetByteArrayLength) _ANSI_ARGS_((Tcl_Obj * objPtr, int length)); /* 58 */
    void (*tcl_SetByteArrayObj) _ANSI_ARGS_((Tcl_Obj * objPtr, CONST unsigned char * bytes, int length)); /* 59 */
    void (*tcl_SetDoubleObj) _ANSI_ARGS_((Tcl_Obj * objPtr, double doubleValue)); /* 60 */
    void (*tcl_SetIntObj) _ANSI_ARGS_((Tcl_Obj * objPtr, int intValue)); /* 61 */
    void (*tcl_SetListObj) _ANSI_ARGS_((Tcl_Obj * objPtr, int objc, Tcl_Obj *CONST objv[])); /* 62 */
    void (*tcl_SetLongObj) _ANSI_ARGS_((Tcl_Obj * objPtr, long longValue)); /* 63 */
    void (*tcl_SetObjLength) _ANSI_ARGS_((Tcl_Obj * objPtr, int length)); /* 64 */
    void (*tcl_SetStringObj) _ANSI_ARGS_((Tcl_Obj* objPtr, CONST char* bytes, int length)); /* 65 */
    void (*tcl_AddErrorInfo) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * message)); /* 66 */
    void (*tcl_AddObjErrorInfo) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * message, int length)); /* 67 */
    void (*tcl_AllowExceptions) _ANSI_ARGS_((Tcl_Interp * interp)); /* 68 */
    void (*tcl_AppendElement) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string)); /* 69 */
    void (*tcl_AppendResult) _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp)); /* 70 */
    Tcl_AsyncHandler (*tcl_AsyncCreate) _ANSI_ARGS_((Tcl_AsyncProc * proc, ClientData clientData)); /* 71 */
    void (*tcl_AsyncDelete) _ANSI_ARGS_((Tcl_AsyncHandler async)); /* 72 */
    int (*tcl_AsyncInvoke) _ANSI_ARGS_((Tcl_Interp * interp, int code)); /* 73 */
    void (*tcl_AsyncMark) _ANSI_ARGS_((Tcl_AsyncHandler async)); /* 74 */
    int (*tcl_AsyncReady) _ANSI_ARGS_((void)); /* 75 */
    void (*tcl_BackgroundError) _ANSI_ARGS_((Tcl_Interp * interp)); /* 76 */
    char (*tcl_Backslash) _ANSI_ARGS_((CONST char * src, int * readPtr)); /* 77 */
    int (*tcl_BadChannelOption) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * optionName, CONST char * optionList)); /* 78 */
    void (*tcl_CallWhenDeleted) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_InterpDeleteProc * proc, ClientData clientData)); /* 79 */
    void (*tcl_CancelIdleCall) _ANSI_ARGS_((Tcl_IdleProc * idleProc, ClientData clientData)); /* 80 */
    int (*tcl_Close) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan)); /* 81 */
    int (*tcl_CommandComplete) _ANSI_ARGS_((CONST char * cmd)); /* 82 */
    char * (*tcl_Concat) _ANSI_ARGS_((int argc, CONST84 char * CONST * argv)); /* 83 */
    int (*tcl_ConvertElement) _ANSI_ARGS_((CONST char * src, char * dst, int flags)); /* 84 */
    int (*tcl_ConvertCountedElement) _ANSI_ARGS_((CONST char * src, int length, char * dst, int flags)); /* 85 */
    int (*tcl_CreateAlias) _ANSI_ARGS_((Tcl_Interp * slave, CONST char * slaveCmd, Tcl_Interp * target, CONST char * targetCmd, int argc, CONST84 char * CONST * argv)); /* 86 */
    int (*tcl_CreateAliasObj) _ANSI_ARGS_((Tcl_Interp * slave, CONST char * slaveCmd, Tcl_Interp * target, CONST char * targetCmd, int objc, Tcl_Obj *CONST objv[])); /* 87 */
    Tcl_Channel (*tcl_CreateChannel) _ANSI_ARGS_((Tcl_ChannelType * typePtr, CONST char * chanName, ClientData instanceData, int mask)); /* 88 */
    void (*tcl_CreateChannelHandler) _ANSI_ARGS_((Tcl_Channel chan, int mask, Tcl_ChannelProc * proc, ClientData clientData)); /* 89 */
    void (*tcl_CreateCloseHandler) _ANSI_ARGS_((Tcl_Channel chan, Tcl_CloseProc * proc, ClientData clientData)); /* 90 */
    Tcl_Command (*tcl_CreateCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName, Tcl_CmdProc * proc, ClientData clientData, Tcl_CmdDeleteProc * deleteProc)); /* 91 */
    void (*tcl_CreateEventSource) _ANSI_ARGS_((Tcl_EventSetupProc * setupProc, Tcl_EventCheckProc * checkProc, ClientData clientData)); /* 92 */
    void (*tcl_CreateExitHandler) _ANSI_ARGS_((Tcl_ExitProc * proc, ClientData clientData)); /* 93 */
    Tcl_Interp * (*tcl_CreateInterp) _ANSI_ARGS_((void)); /* 94 */
    void (*tcl_CreateMathFunc) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, int numArgs, Tcl_ValueType * argTypes, Tcl_MathProc * proc, ClientData clientData)); /* 95 */
    Tcl_Command (*tcl_CreateObjCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName, Tcl_ObjCmdProc * proc, ClientData clientData, Tcl_CmdDeleteProc * deleteProc)); /* 96 */
    Tcl_Interp * (*tcl_CreateSlave) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * slaveName, int isSafe)); /* 97 */
    Tcl_TimerToken (*tcl_CreateTimerHandler) _ANSI_ARGS_((int milliseconds, Tcl_TimerProc * proc, ClientData clientData)); /* 98 */
    Tcl_Trace (*tcl_CreateTrace) _ANSI_ARGS_((Tcl_Interp * interp, int level, Tcl_CmdTraceProc * proc, ClientData clientData)); /* 99 */
    void (*tcl_DeleteAssocData) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name)); /* 100 */
    void (*tcl_DeleteChannelHandler) _ANSI_ARGS_((Tcl_Channel chan, Tcl_ChannelProc * proc, ClientData clientData)); /* 101 */
    void (*tcl_DeleteCloseHandler) _ANSI_ARGS_((Tcl_Channel chan, Tcl_CloseProc * proc, ClientData clientData)); /* 102 */
    int (*tcl_DeleteCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName)); /* 103 */
    int (*tcl_DeleteCommandFromToken) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Command command)); /* 104 */
    void (*tcl_DeleteEvents) _ANSI_ARGS_((Tcl_EventDeleteProc * proc, ClientData clientData)); /* 105 */
    void (*tcl_DeleteEventSource) _ANSI_ARGS_((Tcl_EventSetupProc * setupProc, Tcl_EventCheckProc * checkProc, ClientData clientData)); /* 106 */
    void (*tcl_DeleteExitHandler) _ANSI_ARGS_((Tcl_ExitProc * proc, ClientData clientData)); /* 107 */
    void (*tcl_DeleteHashEntry) _ANSI_ARGS_((Tcl_HashEntry * entryPtr)); /* 108 */
    void (*tcl_DeleteHashTable) _ANSI_ARGS_((Tcl_HashTable * tablePtr)); /* 109 */
    void (*tcl_DeleteInterp) _ANSI_ARGS_((Tcl_Interp * interp)); /* 110 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void (*tcl_DetachPids) _ANSI_ARGS_((int numPids, Tcl_Pid * pidPtr)); /* 111 */
#endif /* UNIX */
#ifdef __WIN32__
    void (*tcl_DetachPids) _ANSI_ARGS_((int numPids, Tcl_Pid * pidPtr)); /* 111 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved111;
#endif /* MAC_TCL */
    void (*tcl_DeleteTimerHandler) _ANSI_ARGS_((Tcl_TimerToken token)); /* 112 */
    void (*tcl_DeleteTrace) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Trace trace)); /* 113 */
    void (*tcl_DontCallWhenDeleted) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_InterpDeleteProc * proc, ClientData clientData)); /* 114 */
    int (*tcl_DoOneEvent) _ANSI_ARGS_((int flags)); /* 115 */
    void (*tcl_DoWhenIdle) _ANSI_ARGS_((Tcl_IdleProc * proc, ClientData clientData)); /* 116 */
    char * (*tcl_DStringAppend) _ANSI_ARGS_((Tcl_DString * dsPtr, CONST char * str, int length)); /* 117 */
    char * (*tcl_DStringAppendElement) _ANSI_ARGS_((Tcl_DString * dsPtr, CONST char * string)); /* 118 */
    void (*tcl_DStringEndSublist) _ANSI_ARGS_((Tcl_DString * dsPtr)); /* 119 */
    void (*tcl_DStringFree) _ANSI_ARGS_((Tcl_DString * dsPtr)); /* 120 */
    void (*tcl_DStringGetResult) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_DString * dsPtr)); /* 121 */
    void (*tcl_DStringInit) _ANSI_ARGS_((Tcl_DString * dsPtr)); /* 122 */
    void (*tcl_DStringResult) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_DString * dsPtr)); /* 123 */
    void (*tcl_DStringSetLength) _ANSI_ARGS_((Tcl_DString * dsPtr, int length)); /* 124 */
    void (*tcl_DStringStartSublist) _ANSI_ARGS_((Tcl_DString * dsPtr)); /* 125 */
    int (*tcl_Eof) _ANSI_ARGS_((Tcl_Channel chan)); /* 126 */
    CONST84_RETURN char * (*tcl_ErrnoId) _ANSI_ARGS_((void)); /* 127 */
    CONST84_RETURN char * (*tcl_ErrnoMsg) _ANSI_ARGS_((int err)); /* 128 */
    int (*tcl_Eval) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string)); /* 129 */
    int (*tcl_EvalFile) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * fileName)); /* 130 */
    int (*tcl_EvalObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr)); /* 131 */
    void (*tcl_EventuallyFree) _ANSI_ARGS_((ClientData clientData, Tcl_FreeProc * freeProc)); /* 132 */
    void (*tcl_Exit) _ANSI_ARGS_((int status)); /* 133 */
    int (*tcl_ExposeCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * hiddenCmdToken, CONST char * cmdName)); /* 134 */
    int (*tcl_ExprBoolean) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int * ptr)); /* 135 */
    int (*tcl_ExprBooleanObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, int * ptr)); /* 136 */
    int (*tcl_ExprDouble) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, double * ptr)); /* 137 */
    int (*tcl_ExprDoubleObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, double * ptr)); /* 138 */
    int (*tcl_ExprLong) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, long * ptr)); /* 139 */
    int (*tcl_ExprLongObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, long * ptr)); /* 140 */
    int (*tcl_ExprObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, Tcl_Obj ** resultPtrPtr)); /* 141 */
    int (*tcl_ExprString) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string)); /* 142 */
    void (*tcl_Finalize) _ANSI_ARGS_((void)); /* 143 */
    void (*tcl_FindExecutable) _ANSI_ARGS_((CONST char * argv0)); /* 144 */
    Tcl_HashEntry * (*tcl_FirstHashEntry) _ANSI_ARGS_((Tcl_HashTable * tablePtr, Tcl_HashSearch * searchPtr)); /* 145 */
    int (*tcl_Flush) _ANSI_ARGS_((Tcl_Channel chan)); /* 146 */
    void (*tcl_FreeResult) _ANSI_ARGS_((Tcl_Interp * interp)); /* 147 */
    int (*tcl_GetAlias) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * slaveCmd, Tcl_Interp ** targetInterpPtr, CONST84 char ** targetCmdPtr, int * argcPtr, CONST84 char *** argvPtr)); /* 148 */
    int (*tcl_GetAliasObj) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * slaveCmd, Tcl_Interp ** targetInterpPtr, CONST84 char ** targetCmdPtr, int * objcPtr, Tcl_Obj *** objv)); /* 149 */
    ClientData (*tcl_GetAssocData) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_InterpDeleteProc ** procPtr)); /* 150 */
    Tcl_Channel (*tcl_GetChannel) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * chanName, int * modePtr)); /* 151 */
    int (*tcl_GetChannelBufferSize) _ANSI_ARGS_((Tcl_Channel chan)); /* 152 */
    int (*tcl_GetChannelHandle) _ANSI_ARGS_((Tcl_Channel chan, int direction, ClientData * handlePtr)); /* 153 */
    ClientData (*tcl_GetChannelInstanceData) _ANSI_ARGS_((Tcl_Channel chan)); /* 154 */
    int (*tcl_GetChannelMode) _ANSI_ARGS_((Tcl_Channel chan)); /* 155 */
    CONST84_RETURN char * (*tcl_GetChannelName) _ANSI_ARGS_((Tcl_Channel chan)); /* 156 */
    int (*tcl_GetChannelOption) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan, CONST char * optionName, Tcl_DString * dsPtr)); /* 157 */
    Tcl_ChannelType * (*tcl_GetChannelType) _ANSI_ARGS_((Tcl_Channel chan)); /* 158 */
    int (*tcl_GetCommandInfo) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName, Tcl_CmdInfo * infoPtr)); /* 159 */
    CONST84_RETURN char * (*tcl_GetCommandName) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Command command)); /* 160 */
    int (*tcl_GetErrno) _ANSI_ARGS_((void)); /* 161 */
    CONST84_RETURN char * (*tcl_GetHostName) _ANSI_ARGS_((void)); /* 162 */
    int (*tcl_GetInterpPath) _ANSI_ARGS_((Tcl_Interp * askInterp, Tcl_Interp * slaveInterp)); /* 163 */
    Tcl_Interp * (*tcl_GetMaster) _ANSI_ARGS_((Tcl_Interp * interp)); /* 164 */
    CONST char * (*tcl_GetNameOfExecutable) _ANSI_ARGS_((void)); /* 165 */
    Tcl_Obj * (*tcl_GetObjResult) _ANSI_ARGS_((Tcl_Interp * interp)); /* 166 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    int (*tcl_GetOpenFile) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int forWriting, int checkUsage, ClientData * filePtr)); /* 167 */
#endif /* UNIX */
#ifdef __WIN32__
    void *reserved167;
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved167;
#endif /* MAC_TCL */
    Tcl_PathType (*tcl_GetPathType) _ANSI_ARGS_((CONST char * path)); /* 168 */
    int (*tcl_Gets) _ANSI_ARGS_((Tcl_Channel chan, Tcl_DString * dsPtr)); /* 169 */
    int (*tcl_GetsObj) _ANSI_ARGS_((Tcl_Channel chan, Tcl_Obj * objPtr)); /* 170 */
    int (*tcl_GetServiceMode) _ANSI_ARGS_((void)); /* 171 */
    Tcl_Interp * (*tcl_GetSlave) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * slaveName)); /* 172 */
    Tcl_Channel (*tcl_GetStdChannel) _ANSI_ARGS_((int type)); /* 173 */
    CONST84_RETURN char * (*tcl_GetStringResult) _ANSI_ARGS_((Tcl_Interp * interp)); /* 174 */
    CONST84_RETURN char * (*tcl_GetVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, int flags)); /* 175 */
    CONST84_RETURN char * (*tcl_GetVar2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags)); /* 176 */
    int (*tcl_GlobalEval) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * command)); /* 177 */
    int (*tcl_GlobalEvalObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr)); /* 178 */
    int (*tcl_HideCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName, CONST char * hiddenCmdToken)); /* 179 */
    int (*tcl_Init) _ANSI_ARGS_((Tcl_Interp * interp)); /* 180 */
    void (*tcl_InitHashTable) _ANSI_ARGS_((Tcl_HashTable * tablePtr, int keyType)); /* 181 */
    int (*tcl_InputBlocked) _ANSI_ARGS_((Tcl_Channel chan)); /* 182 */
    int (*tcl_InputBuffered) _ANSI_ARGS_((Tcl_Channel chan)); /* 183 */
    int (*tcl_InterpDeleted) _ANSI_ARGS_((Tcl_Interp * interp)); /* 184 */
    int (*tcl_IsSafe) _ANSI_ARGS_((Tcl_Interp * interp)); /* 185 */
    char * (*tcl_JoinPath) _ANSI_ARGS_((int argc, CONST84 char * CONST * argv, Tcl_DString * resultPtr)); /* 186 */
    int (*tcl_LinkVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, char * addr, int type)); /* 187 */
    void *reserved188;
    Tcl_Channel (*tcl_MakeFileChannel) _ANSI_ARGS_((ClientData handle, int mode)); /* 189 */
    int (*tcl_MakeSafe) _ANSI_ARGS_((Tcl_Interp * interp)); /* 190 */
    Tcl_Channel (*tcl_MakeTcpClientChannel) _ANSI_ARGS_((ClientData tcpSocket)); /* 191 */
    char * (*tcl_Merge) _ANSI_ARGS_((int argc, CONST84 char * CONST * argv)); /* 192 */
    Tcl_HashEntry * (*tcl_NextHashEntry) _ANSI_ARGS_((Tcl_HashSearch * searchPtr)); /* 193 */
    void (*tcl_NotifyChannel) _ANSI_ARGS_((Tcl_Channel channel, int mask)); /* 194 */
    Tcl_Obj * (*tcl_ObjGetVar2) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * part1Ptr, Tcl_Obj * part2Ptr, int flags)); /* 195 */
    Tcl_Obj * (*tcl_ObjSetVar2) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * part1Ptr, Tcl_Obj * part2Ptr, Tcl_Obj * newValuePtr, int flags)); /* 196 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    Tcl_Channel (*tcl_OpenCommandChannel) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST84 char ** argv, int flags)); /* 197 */
#endif /* UNIX */
#ifdef __WIN32__
    Tcl_Channel (*tcl_OpenCommandChannel) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST84 char ** argv, int flags)); /* 197 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved197;
#endif /* MAC_TCL */
    Tcl_Channel (*tcl_OpenFileChannel) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * fileName, CONST char * modeString, int permissions)); /* 198 */
    Tcl_Channel (*tcl_OpenTcpClient) _ANSI_ARGS_((Tcl_Interp * interp, int port, CONST char * address, CONST char * myaddr, int myport, int async)); /* 199 */
    Tcl_Channel (*tcl_OpenTcpServer) _ANSI_ARGS_((Tcl_Interp * interp, int port, CONST char * host, Tcl_TcpAcceptProc * acceptProc, ClientData callbackData)); /* 200 */
    void (*tcl_Preserve) _ANSI_ARGS_((ClientData data)); /* 201 */
    void (*tcl_PrintDouble) _ANSI_ARGS_((Tcl_Interp * interp, double value, char * dst)); /* 202 */
    int (*tcl_PutEnv) _ANSI_ARGS_((CONST char * string)); /* 203 */
    CONST84_RETURN char * (*tcl_PosixError) _ANSI_ARGS_((Tcl_Interp * interp)); /* 204 */
    void (*tcl_QueueEvent) _ANSI_ARGS_((Tcl_Event * evPtr, Tcl_QueuePosition position)); /* 205 */
    int (*tcl_Read) _ANSI_ARGS_((Tcl_Channel chan, char * bufPtr, int toRead)); /* 206 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void (*tcl_ReapDetachedProcs) _ANSI_ARGS_((void)); /* 207 */
#endif /* UNIX */
#ifdef __WIN32__
    void (*tcl_ReapDetachedProcs) _ANSI_ARGS_((void)); /* 207 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void *reserved207;
#endif /* MAC_TCL */
    int (*tcl_RecordAndEval) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmd, int flags)); /* 208 */
    int (*tcl_RecordAndEvalObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * cmdPtr, int flags)); /* 209 */
    void (*tcl_RegisterChannel) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan)); /* 210 */
    void (*tcl_RegisterObjType) _ANSI_ARGS_((Tcl_ObjType * typePtr)); /* 211 */
    Tcl_RegExp (*tcl_RegExpCompile) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string)); /* 212 */
    int (*tcl_RegExpExec) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_RegExp regexp, CONST char * str, CONST char * start)); /* 213 */
    int (*tcl_RegExpMatch) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, CONST char * pattern)); /* 214 */
    void (*tcl_RegExpRange) _ANSI_ARGS_((Tcl_RegExp regexp, int index, CONST84 char ** startPtr, CONST84 char ** endPtr)); /* 215 */
    void (*tcl_Release) _ANSI_ARGS_((ClientData clientData)); /* 216 */
    void (*tcl_ResetResult) _ANSI_ARGS_((Tcl_Interp * interp)); /* 217 */
    int (*tcl_ScanElement) _ANSI_ARGS_((CONST char * str, int * flagPtr)); /* 218 */
    int (*tcl_ScanCountedElement) _ANSI_ARGS_((CONST char * str, int length, int * flagPtr)); /* 219 */
    int (*tcl_SeekOld) _ANSI_ARGS_((Tcl_Channel chan, int offset, int mode)); /* 220 */
    int (*tcl_ServiceAll) _ANSI_ARGS_((void)); /* 221 */
    int (*tcl_ServiceEvent) _ANSI_ARGS_((int flags)); /* 222 */
    void (*tcl_SetAssocData) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_InterpDeleteProc * proc, ClientData clientData)); /* 223 */
    void (*tcl_SetChannelBufferSize) _ANSI_ARGS_((Tcl_Channel chan, int sz)); /* 224 */
    int (*tcl_SetChannelOption) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan, CONST char * optionName, CONST char * newValue)); /* 225 */
    int (*tcl_SetCommandInfo) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName, CONST Tcl_CmdInfo * infoPtr)); /* 226 */
    void (*tcl_SetErrno) _ANSI_ARGS_((int err)); /* 227 */
    void (*tcl_SetErrorCode) _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp)); /* 228 */
    void (*tcl_SetMaxBlockTime) _ANSI_ARGS_((Tcl_Time * timePtr)); /* 229 */
    void (*tcl_SetPanicProc) _ANSI_ARGS_((Tcl_PanicProc * panicProc)); /* 230 */
    int (*tcl_SetRecursionLimit) _ANSI_ARGS_((Tcl_Interp * interp, int depth)); /* 231 */
    void (*tcl_SetResult) _ANSI_ARGS_((Tcl_Interp * interp, char * str, Tcl_FreeProc * freeProc)); /* 232 */
    int (*tcl_SetServiceMode) _ANSI_ARGS_((int mode)); /* 233 */
    void (*tcl_SetObjErrorCode) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * errorObjPtr)); /* 234 */
    void (*tcl_SetObjResult) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * resultObjPtr)); /* 235 */
    void (*tcl_SetStdChannel) _ANSI_ARGS_((Tcl_Channel channel, int type)); /* 236 */
    CONST84_RETURN char * (*tcl_SetVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, CONST char * newValue, int flags)); /* 237 */
    CONST84_RETURN char * (*tcl_SetVar2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, CONST char * newValue, int flags)); /* 238 */
    CONST84_RETURN char * (*tcl_SignalId) _ANSI_ARGS_((int sig)); /* 239 */
    CONST84_RETURN char * (*tcl_SignalMsg) _ANSI_ARGS_((int sig)); /* 240 */
    void (*tcl_SourceRCFile) _ANSI_ARGS_((Tcl_Interp * interp)); /* 241 */
    int (*tcl_SplitList) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * listStr, int * argcPtr, CONST84 char *** argvPtr)); /* 242 */
    void (*tcl_SplitPath) _ANSI_ARGS_((CONST char * path, int * argcPtr, CONST84 char *** argvPtr)); /* 243 */
    void (*tcl_StaticPackage) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * pkgName, Tcl_PackageInitProc * initProc, Tcl_PackageInitProc * safeInitProc)); /* 244 */
    int (*tcl_StringMatch) _ANSI_ARGS_((CONST char * str, CONST char * pattern)); /* 245 */
    int (*tcl_TellOld) _ANSI_ARGS_((Tcl_Channel chan)); /* 246 */
    int (*tcl_TraceVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, int flags, Tcl_VarTraceProc * proc, ClientData clientData)); /* 247 */
    int (*tcl_TraceVar2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags, Tcl_VarTraceProc * proc, ClientData clientData)); /* 248 */
    char * (*tcl_TranslateFileName) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tcl_DString * bufferPtr)); /* 249 */
    int (*tcl_Ungets) _ANSI_ARGS_((Tcl_Channel chan, CONST char * str, int len, int atHead)); /* 250 */
    void (*tcl_UnlinkVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName)); /* 251 */
    int (*tcl_UnregisterChannel) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan)); /* 252 */
    int (*tcl_UnsetVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, int flags)); /* 253 */
    int (*tcl_UnsetVar2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags)); /* 254 */
    void (*tcl_UntraceVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, int flags, Tcl_VarTraceProc * proc, ClientData clientData)); /* 255 */
    void (*tcl_UntraceVar2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags, Tcl_VarTraceProc * proc, ClientData clientData)); /* 256 */
    void (*tcl_UpdateLinkedVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName)); /* 257 */
    int (*tcl_UpVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * frameName, CONST char * varName, CONST char * localName, int flags)); /* 258 */
    int (*tcl_UpVar2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * frameName, CONST char * part1, CONST char * part2, CONST char * localName, int flags)); /* 259 */
    int (*tcl_VarEval) _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp)); /* 260 */
    ClientData (*tcl_VarTraceInfo) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * varName, int flags, Tcl_VarTraceProc * procPtr, ClientData prevClientData)); /* 261 */
    ClientData (*tcl_VarTraceInfo2) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags, Tcl_VarTraceProc * procPtr, ClientData prevClientData)); /* 262 */
    int (*tcl_Write) _ANSI_ARGS_((Tcl_Channel chan, CONST char * s, int slen)); /* 263 */
    void (*tcl_WrongNumArgs) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], CONST char * message)); /* 264 */
    int (*tcl_DumpActiveMemory) _ANSI_ARGS_((CONST char * fileName)); /* 265 */
    void (*tcl_ValidateAllMemory) _ANSI_ARGS_((CONST char * file, int line)); /* 266 */
    void (*tcl_AppendResultVA) _ANSI_ARGS_((Tcl_Interp * interp, va_list argList)); /* 267 */
    void (*tcl_AppendStringsToObjVA) _ANSI_ARGS_((Tcl_Obj * objPtr, va_list argList)); /* 268 */
    CONST84_RETURN char * (*tcl_HashStats) _ANSI_ARGS_((Tcl_HashTable * tablePtr)); /* 269 */
    CONST84_RETURN char * (*tcl_ParseVar) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, CONST84 char ** termPtr)); /* 270 */
    CONST84_RETURN char * (*tcl_PkgPresent) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, CONST char * version, int exact)); /* 271 */
    CONST84_RETURN char * (*tcl_PkgPresentEx) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, CONST char * version, int exact, ClientData * clientDataPtr)); /* 272 */
    int (*tcl_PkgProvide) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, CONST char * version)); /* 273 */
    CONST84_RETURN char * (*tcl_PkgRequire) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, CONST char * version, int exact)); /* 274 */
    void (*tcl_SetErrorCodeVA) _ANSI_ARGS_((Tcl_Interp * interp, va_list argList)); /* 275 */
    int (*tcl_VarEvalVA) _ANSI_ARGS_((Tcl_Interp * interp, va_list argList)); /* 276 */
    Tcl_Pid (*tcl_WaitPid) _ANSI_ARGS_((Tcl_Pid pid, int * statPtr, int options)); /* 277 */
    void (*tcl_PanicVA) _ANSI_ARGS_((CONST char * format, va_list argList)); /* 278 */
    void (*tcl_GetVersion) _ANSI_ARGS_((int * major, int * minor, int * patchLevel, int * type)); /* 279 */
    void (*tcl_InitMemory) _ANSI_ARGS_((Tcl_Interp * interp)); /* 280 */
    Tcl_Channel (*tcl_StackChannel) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_ChannelType * typePtr, ClientData instanceData, int mask, Tcl_Channel prevChan)); /* 281 */
    int (*tcl_UnstackChannel) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Channel chan)); /* 282 */
    Tcl_Channel (*tcl_GetStackedChannel) _ANSI_ARGS_((Tcl_Channel chan)); /* 283 */
    void (*tcl_SetMainLoop) _ANSI_ARGS_((Tcl_MainLoopProc * proc)); /* 284 */
    void *reserved285;
    void (*tcl_AppendObjToObj) _ANSI_ARGS_((Tcl_Obj * objPtr, Tcl_Obj * appendObjPtr)); /* 286 */
    Tcl_Encoding (*tcl_CreateEncoding) _ANSI_ARGS_((Tcl_EncodingType * typePtr)); /* 287 */
    void (*tcl_CreateThreadExitHandler) _ANSI_ARGS_((Tcl_ExitProc * proc, ClientData clientData)); /* 288 */
    void (*tcl_DeleteThreadExitHandler) _ANSI_ARGS_((Tcl_ExitProc * proc, ClientData clientData)); /* 289 */
    void (*tcl_DiscardResult) _ANSI_ARGS_((Tcl_SavedResult * statePtr)); /* 290 */
    int (*tcl_EvalEx) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * script, int numBytes, int flags)); /* 291 */
    int (*tcl_EvalObjv) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], int flags)); /* 292 */
    int (*tcl_EvalObjEx) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, int flags)); /* 293 */
    void (*tcl_ExitThread) _ANSI_ARGS_((int status)); /* 294 */
    int (*tcl_ExternalToUtf) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Encoding encoding, CONST char * src, int srcLen, int flags, Tcl_EncodingState * statePtr, char * dst, int dstLen, int * srcReadPtr, int * dstWrotePtr, int * dstCharsPtr)); /* 295 */
    char * (*tcl_ExternalToUtfDString) _ANSI_ARGS_((Tcl_Encoding encoding, CONST char * src, int srcLen, Tcl_DString * dsPtr)); /* 296 */
    void (*tcl_FinalizeThread) _ANSI_ARGS_((void)); /* 297 */
    void (*tcl_FinalizeNotifier) _ANSI_ARGS_((ClientData clientData)); /* 298 */
    void (*tcl_FreeEncoding) _ANSI_ARGS_((Tcl_Encoding encoding)); /* 299 */
    Tcl_ThreadId (*tcl_GetCurrentThread) _ANSI_ARGS_((void)); /* 300 */
    Tcl_Encoding (*tcl_GetEncoding) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name)); /* 301 */
    CONST84_RETURN char * (*tcl_GetEncodingName) _ANSI_ARGS_((Tcl_Encoding encoding)); /* 302 */
    void (*tcl_GetEncodingNames) _ANSI_ARGS_((Tcl_Interp * interp)); /* 303 */
    int (*tcl_GetIndexFromObjStruct) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, CONST VOID * tablePtr, int offset, CONST char * msg, int flags, int * indexPtr)); /* 304 */
    VOID * (*tcl_GetThreadData) _ANSI_ARGS_((Tcl_ThreadDataKey * keyPtr, int size)); /* 305 */
    Tcl_Obj * (*tcl_GetVar2Ex) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, int flags)); /* 306 */
    ClientData (*tcl_InitNotifier) _ANSI_ARGS_((void)); /* 307 */
    void (*tcl_MutexLock) _ANSI_ARGS_((Tcl_Mutex * mutexPtr)); /* 308 */
    void (*tcl_MutexUnlock) _ANSI_ARGS_((Tcl_Mutex * mutexPtr)); /* 309 */
    void (*tcl_ConditionNotify) _ANSI_ARGS_((Tcl_Condition * condPtr)); /* 310 */
    void (*tcl_ConditionWait) _ANSI_ARGS_((Tcl_Condition * condPtr, Tcl_Mutex * mutexPtr, Tcl_Time * timePtr)); /* 311 */
    int (*tcl_NumUtfChars) _ANSI_ARGS_((CONST char * src, int len)); /* 312 */
    int (*tcl_ReadChars) _ANSI_ARGS_((Tcl_Channel channel, Tcl_Obj * objPtr, int charsToRead, int appendFlag)); /* 313 */
    void (*tcl_RestoreResult) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_SavedResult * statePtr)); /* 314 */
    void (*tcl_SaveResult) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_SavedResult * statePtr)); /* 315 */
    int (*tcl_SetSystemEncoding) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name)); /* 316 */
    Tcl_Obj * (*tcl_SetVar2Ex) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * part1, CONST char * part2, Tcl_Obj * newValuePtr, int flags)); /* 317 */
    void (*tcl_ThreadAlert) _ANSI_ARGS_((Tcl_ThreadId threadId)); /* 318 */
    void (*tcl_ThreadQueueEvent) _ANSI_ARGS_((Tcl_ThreadId threadId, Tcl_Event* evPtr, Tcl_QueuePosition position)); /* 319 */
    Tcl_UniChar (*tcl_UniCharAtIndex) _ANSI_ARGS_((CONST char * src, int index)); /* 320 */
    Tcl_UniChar (*tcl_UniCharToLower) _ANSI_ARGS_((int ch)); /* 321 */
    Tcl_UniChar (*tcl_UniCharToTitle) _ANSI_ARGS_((int ch)); /* 322 */
    Tcl_UniChar (*tcl_UniCharToUpper) _ANSI_ARGS_((int ch)); /* 323 */
    int (*tcl_UniCharToUtf) _ANSI_ARGS_((int ch, char * buf)); /* 324 */
    CONST84_RETURN char * (*tcl_UtfAtIndex) _ANSI_ARGS_((CONST char * src, int index)); /* 325 */
    int (*tcl_UtfCharComplete) _ANSI_ARGS_((CONST char * src, int len)); /* 326 */
    int (*tcl_UtfBackslash) _ANSI_ARGS_((CONST char * src, int * readPtr, char * dst)); /* 327 */
    CONST84_RETURN char * (*tcl_UtfFindFirst) _ANSI_ARGS_((CONST char * src, int ch)); /* 328 */
    CONST84_RETURN char * (*tcl_UtfFindLast) _ANSI_ARGS_((CONST char * src, int ch)); /* 329 */
    CONST84_RETURN char * (*tcl_UtfNext) _ANSI_ARGS_((CONST char * src)); /* 330 */
    CONST84_RETURN char * (*tcl_UtfPrev) _ANSI_ARGS_((CONST char * src, CONST char * start)); /* 331 */
    int (*tcl_UtfToExternal) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Encoding encoding, CONST char * src, int srcLen, int flags, Tcl_EncodingState * statePtr, char * dst, int dstLen, int * srcReadPtr, int * dstWrotePtr, int * dstCharsPtr)); /* 332 */
    char * (*tcl_UtfToExternalDString) _ANSI_ARGS_((Tcl_Encoding encoding, CONST char * src, int srcLen, Tcl_DString * dsPtr)); /* 333 */
    int (*tcl_UtfToLower) _ANSI_ARGS_((char * src)); /* 334 */
    int (*tcl_UtfToTitle) _ANSI_ARGS_((char * src)); /* 335 */
    int (*tcl_UtfToUniChar) _ANSI_ARGS_((CONST char * src, Tcl_UniChar * chPtr)); /* 336 */
    int (*tcl_UtfToUpper) _ANSI_ARGS_((char * src)); /* 337 */
    int (*tcl_WriteChars) _ANSI_ARGS_((Tcl_Channel chan, CONST char * src, int srcLen)); /* 338 */
    int (*tcl_WriteObj) _ANSI_ARGS_((Tcl_Channel chan, Tcl_Obj * objPtr)); /* 339 */
    char * (*tcl_GetString) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 340 */
    CONST84_RETURN char * (*tcl_GetDefaultEncodingDir) _ANSI_ARGS_((void)); /* 341 */
    void (*tcl_SetDefaultEncodingDir) _ANSI_ARGS_((CONST char * path)); /* 342 */
    void (*tcl_AlertNotifier) _ANSI_ARGS_((ClientData clientData)); /* 343 */
    void (*tcl_ServiceModeHook) _ANSI_ARGS_((int mode)); /* 344 */
    int (*tcl_UniCharIsAlnum) _ANSI_ARGS_((int ch)); /* 345 */
    int (*tcl_UniCharIsAlpha) _ANSI_ARGS_((int ch)); /* 346 */
    int (*tcl_UniCharIsDigit) _ANSI_ARGS_((int ch)); /* 347 */
    int (*tcl_UniCharIsLower) _ANSI_ARGS_((int ch)); /* 348 */
    int (*tcl_UniCharIsSpace) _ANSI_ARGS_((int ch)); /* 349 */
    int (*tcl_UniCharIsUpper) _ANSI_ARGS_((int ch)); /* 350 */
    int (*tcl_UniCharIsWordChar) _ANSI_ARGS_((int ch)); /* 351 */
    int (*tcl_UniCharLen) _ANSI_ARGS_((CONST Tcl_UniChar * str)); /* 352 */
    int (*tcl_UniCharNcmp) _ANSI_ARGS_((CONST Tcl_UniChar * cs, CONST Tcl_UniChar * ct, unsigned long n)); /* 353 */
    char * (*tcl_UniCharToUtfDString) _ANSI_ARGS_((CONST Tcl_UniChar * string, int numChars, Tcl_DString * dsPtr)); /* 354 */
    Tcl_UniChar * (*tcl_UtfToUniCharDString) _ANSI_ARGS_((CONST char * string, int length, Tcl_DString * dsPtr)); /* 355 */
    Tcl_RegExp (*tcl_GetRegExpFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * patObj, int flags)); /* 356 */
    Tcl_Obj * (*tcl_EvalTokens) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Token * tokenPtr, int count)); /* 357 */
    void (*tcl_FreeParse) _ANSI_ARGS_((Tcl_Parse * parsePtr)); /* 358 */
    void (*tcl_LogCommandInfo) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * script, CONST char * command, int length)); /* 359 */
    int (*tcl_ParseBraces) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, int numBytes, Tcl_Parse * parsePtr, int append, CONST84 char ** termPtr)); /* 360 */
    int (*tcl_ParseCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, int numBytes, int nested, Tcl_Parse * parsePtr)); /* 361 */
    int (*tcl_ParseExpr) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, int numBytes, Tcl_Parse * parsePtr)); /* 362 */
    int (*tcl_ParseQuotedString) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, int numBytes, Tcl_Parse * parsePtr, int append, CONST84 char ** termPtr)); /* 363 */
    int (*tcl_ParseVarName) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, int numBytes, Tcl_Parse * parsePtr, int append)); /* 364 */
    char * (*tcl_GetCwd) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_DString * cwdPtr)); /* 365 */
    int (*tcl_Chdir) _ANSI_ARGS_((CONST char * dirName)); /* 366 */
    int (*tcl_Access) _ANSI_ARGS_((CONST char * path, int mode)); /* 367 */
    int (*tcl_Stat) _ANSI_ARGS_((CONST char * path, struct stat * bufPtr)); /* 368 */
    int (*tcl_UtfNcmp) _ANSI_ARGS_((CONST char * s1, CONST char * s2, unsigned long n)); /* 369 */
    int (*tcl_UtfNcasecmp) _ANSI_ARGS_((CONST char * s1, CONST char * s2, unsigned long n)); /* 370 */
    int (*tcl_StringCaseMatch) _ANSI_ARGS_((CONST char * str, CONST char * pattern, int nocase)); /* 371 */
    int (*tcl_UniCharIsControl) _ANSI_ARGS_((int ch)); /* 372 */
    int (*tcl_UniCharIsGraph) _ANSI_ARGS_((int ch)); /* 373 */
    int (*tcl_UniCharIsPrint) _ANSI_ARGS_((int ch)); /* 374 */
    int (*tcl_UniCharIsPunct) _ANSI_ARGS_((int ch)); /* 375 */
    int (*tcl_RegExpExecObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_RegExp regexp, Tcl_Obj * objPtr, int offset, int nmatches, int flags)); /* 376 */
    void (*tcl_RegExpGetInfo) _ANSI_ARGS_((Tcl_RegExp regexp, Tcl_RegExpInfo * infoPtr)); /* 377 */
    Tcl_Obj * (*tcl_NewUnicodeObj) _ANSI_ARGS_((CONST Tcl_UniChar * unicode, int numChars)); /* 378 */
    void (*tcl_SetUnicodeObj) _ANSI_ARGS_((Tcl_Obj * objPtr, CONST Tcl_UniChar * unicode, int numChars)); /* 379 */
    int (*tcl_GetCharLength) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 380 */
    Tcl_UniChar (*tcl_GetUniChar) _ANSI_ARGS_((Tcl_Obj * objPtr, int index)); /* 381 */
    Tcl_UniChar * (*tcl_GetUnicode) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 382 */
    Tcl_Obj * (*tcl_GetRange) _ANSI_ARGS_((Tcl_Obj * objPtr, int first, int last)); /* 383 */
    void (*tcl_AppendUnicodeToObj) _ANSI_ARGS_((Tcl_Obj * objPtr, CONST Tcl_UniChar * unicode, int length)); /* 384 */
    int (*tcl_RegExpMatchObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * stringObj, Tcl_Obj * patternObj)); /* 385 */
    void (*tcl_SetNotifier) _ANSI_ARGS_((Tcl_NotifierProcs * notifierProcPtr)); /* 386 */
    Tcl_Mutex * (*tcl_GetAllocMutex) _ANSI_ARGS_((void)); /* 387 */
    int (*tcl_GetChannelNames) _ANSI_ARGS_((Tcl_Interp * interp)); /* 388 */
    int (*tcl_GetChannelNamesEx) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * pattern)); /* 389 */
    int (*tcl_ProcObjCmd) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[])); /* 390 */
    void (*tcl_ConditionFinalize) _ANSI_ARGS_((Tcl_Condition * condPtr)); /* 391 */
    void (*tcl_MutexFinalize) _ANSI_ARGS_((Tcl_Mutex * mutex)); /* 392 */
    int (*tcl_CreateThread) _ANSI_ARGS_((Tcl_ThreadId * idPtr, Tcl_ThreadCreateProc proc, ClientData clientData, int stackSize, int flags)); /* 393 */
    int (*tcl_ReadRaw) _ANSI_ARGS_((Tcl_Channel chan, char * dst, int bytesToRead)); /* 394 */
    int (*tcl_WriteRaw) _ANSI_ARGS_((Tcl_Channel chan, CONST char * src, int srcLen)); /* 395 */
    Tcl_Channel (*tcl_GetTopChannel) _ANSI_ARGS_((Tcl_Channel chan)); /* 396 */
    int (*tcl_ChannelBuffered) _ANSI_ARGS_((Tcl_Channel chan)); /* 397 */
    CONST84_RETURN char * (*tcl_ChannelName) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 398 */
    Tcl_ChannelTypeVersion (*tcl_ChannelVersion) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 399 */
    Tcl_DriverBlockModeProc * (*tcl_ChannelBlockModeProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 400 */
    Tcl_DriverCloseProc * (*tcl_ChannelCloseProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 401 */
    Tcl_DriverClose2Proc * (*tcl_ChannelClose2Proc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 402 */
    Tcl_DriverInputProc * (*tcl_ChannelInputProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 403 */
    Tcl_DriverOutputProc * (*tcl_ChannelOutputProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 404 */
    Tcl_DriverSeekProc * (*tcl_ChannelSeekProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 405 */
    Tcl_DriverSetOptionProc * (*tcl_ChannelSetOptionProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 406 */
    Tcl_DriverGetOptionProc * (*tcl_ChannelGetOptionProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 407 */
    Tcl_DriverWatchProc * (*tcl_ChannelWatchProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 408 */
    Tcl_DriverGetHandleProc * (*tcl_ChannelGetHandleProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 409 */
    Tcl_DriverFlushProc * (*tcl_ChannelFlushProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 410 */
    Tcl_DriverHandlerProc * (*tcl_ChannelHandlerProc) _ANSI_ARGS_((Tcl_ChannelType * chanTypePtr)); /* 411 */
    int (*tcl_JoinThread) _ANSI_ARGS_((Tcl_ThreadId threadId, int* result)); /* 412 */
    int (*tcl_IsChannelShared) _ANSI_ARGS_((Tcl_Channel channel)); /* 413 */
    int (*tcl_IsChannelRegistered) _ANSI_ARGS_((Tcl_Interp* interp, Tcl_Channel channel)); /* 414 */
    void (*tcl_CutChannel) _ANSI_ARGS_((Tcl_Channel channel)); /* 415 */
    void (*tcl_SpliceChannel) _ANSI_ARGS_((Tcl_Channel channel)); /* 416 */
    void (*tcl_ClearChannelHandlers) _ANSI_ARGS_((Tcl_Channel channel)); /* 417 */
    int (*tcl_IsChannelExisting) _ANSI_ARGS_((CONST char* channelName)); /* 418 */
    int (*tcl_UniCh