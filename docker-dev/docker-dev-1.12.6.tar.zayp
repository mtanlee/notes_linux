      if isinstance(dt, datetime) or dt is None:
            return self._offset
        raise TypeError("utcoffset() argument must be a datetime instance"
                        " or None")

    def tzname(self, dt):
        if isinstance(dt, datetime) or dt is None:
            if self._name is None:
                return self._name_from_offset(self._offset)
            return self._name
        raise TypeError("tzname() argument must be a datetime instance"
                        " or None")

    def dst(self, dt):
        if isinstance(dt, datetime) or dt is None:
            return None
        raise TypeError("dst() argument must be a datetime instance"
                        " or None")

    def fromutc(self, dt):
        if isinstance(dt, datetime):
            if dt.tzinfo is not self:
                raise ValueError("fromutc: dt.tzinfo "
                                 "is not self")
            return dt + self._offset
        raise TypeError("fromutc() argument must be a datetime instance"
                        " or None")

    _maxoffset = timedelta(hours=23, minutes=59)
    _minoffset = -_maxoffset

    @staticmethod
    def _name_from_offset(delta):
        if delta < timedelta(0):
            sign = '-'
            delta = -delta
        else:
            sign = '+'
        hours, rest = divmod(delta, timedelta(hours=1))
        minutes = rest // timedelta(minutes=1)
        return 'UTC{}{:02d}:{:02d}'.format(sign, hours, minutes)

timezone.utc = timezone._create(timedelta(0))
timezone.min = timezone._create(timezone._minoffset)
timezone.max = timezone._create(timezone._maxoffset)
_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)

# Some time zone algebra.  For a datetime x, let
#     x.n = x stripped of its timezone -- its naive time.
#     x.o = x.utcoffset(), and assuming that doesn't raise an exception or
#           return None
#     x.d = x.dst(), and assuming that doesn't raise an exception or
#           return None
#     x.s = x's standard offset, x.o - x.d
#
# Now some derived rules, where k is a duration (timedelta).
#
# 1. x.o = x.s + x.d
#    This follows from the definition of x.s.
#
# 2. If x and y have the same tzinfo member, x.s = y.s.
#    This is actually a requirement, an assumption we need to make about
#    sane tzinfo classes.
#
# 3. The naive UTC time corresponding to x is x.n - x.o.
#    This is again a requirement for a sane tzinfo class.
#
# 4. (x+k).s = x.s
#    This follows from #2, and that datimetimetz+timedelta preserves tzinfo.
#
# 5. (x+k).n = x.n + k
#    Again follows from how arithmetic is defined.
#
# Now we can explain tz.fromutc(x).  Let's assume it's an interesting case
# (meaning that the various tzinfo methods exist, and don't blow up or return
# None when called).
#
# The function wants to return a datetime y with timezone tz, equivalent to x.
# x is already in UTC.
#
# By #3, we want
#
#     y.n - y.o = x.n                             [1]
#
# The algorithm starts by attaching tz to x.n, and calling that y.  So
# x.n = y.n at the start.  Then it wants to add a duration k to y, so that [1]
# becomes true; in effect, we want to solve [2] for k:
#
#    (y+k).n - (y+k).o = x.n                      [2]
#
# By #1, this is the same as
#
#    (y+k).n - ((y+k).s + (y+k).d) = x.n          [3]
#
# By #5, (y+k).n = y.n + k, which equals x.n + k because x.n=y.n at the start.
# Substituting that into [3],
#
#    x.n + k - (y+k).s - (y+k).d = x.n; the x.n terms cancel, leaving
#    k - (y+k).s - (y+k).d = 0; rearranging,
#    k = (y+k).s - (y+k).d; by #4, (y+k).s == y.s, so
#    k = y.s - (y+k).d
#
# On the RHS, (y+k).d can't be computed directly, but y.s can be, and we
# approximate k by ignoring the (y+k).d term at first.  Note that k can't be
# very large, since all offset-returning methods return a duration of magnitude
# less than 24 hours.  For that reason, if y is firmly in std time, (y+k).d must
# be 0, so ignoring it has no consequence then.
#
# In any case, the new value is
#
#     z = y + y.s                                 [4]
#
# It's helpful to step back at look at [4] from a higher level:  it's simply
# mapping from UTC to tz's standard time.
#
# At this point, if
#
#     z.n - z.o = x.n                             [5]
#
# we have an equivalent time, and are almost done.  The insecurity here is
# at the start of daylight time.  Picture US Eastern for concreteness.  The wall
# time jumps from 1:59 to 3:00, and wall hours of the form 2:MM don't make good
# sense then.  The docs ask that an Eastern tzinfo class consider such a time to
# be EDT (because it's "after 2"), which is a redundant spelling of 1:MM EST
# on the day DST starts.  We want to return the 1:MM EST spelling because that's
# the only spelling that makes sense on the local wall clock.
#
# In fact, if [5] holds at this point, we do have the standard-time spelling,
# but that takes a bit of proof.  We first prove a stronger result.  What's the
# difference between the LHS and RHS of [5]?  Let
#
#     diff = x.n - (z.n - z.o)                    [6]
#
# Now
#     z.n =                       by [4]
#     (y + y.s).n =               by #5
#     y.n + y.s =                 since y.n = x.n
#     x.n + y.s =                 since z and y are have the same tzinfo member,
#                                     y.s = z.s by #2
#     x.n + z.s
#
# Plugging that back into [6] gives
#
#     diff =
#     x.n - ((x.n + z.s) - z.o) =     expanding
#     x.n - x.n - z.s + z.o =         cancelling
#     - z.s + z.o =                   by #2
#     z.d
#
# So diff = z.d.
#
# If [5] is true now, diff = 0, so z.d = 0 too, and we have the standard-time
# spelling we wanted in the endcase described above.  We're done.  Contrarily,
# if z.d = 0, then we have a UTC equivalent, and are also done.
#
# If [5] is not true now, diff = z.d != 0, and z.d is the offset we need to
# add to z (in effect, z is in tz's standard time, and we need to shift the
# local clock into tz's daylight time).
#
# Let
#
#     z' = z + z.d = z + diff                     [7]
#
# and we can again ask whether
#
#     z'.n - z'.o = x.n                           [8]
#
# If so, we're done.  If not, the tzinfo class is insane, according to the
# assumptions we've made.  This also requires a bit of proof.  As before, let's
# compute the difference between the LHS and RHS of [8] (and skipping some of
# the justifications for the kinds of substitutions we've done several times
# already):
#
#     diff' = x.n - (z'.n - z'.o) =           replacing z'.n via [7]
#             x.n  - (z.n + diff - z'.o) =    replacing diff via [6]
#             x.n - (z.n + x.n - (z.n - z.o) - z'.o) =
#             x.n - z.n - x.n + z.n - z.o + z'.o =    cancel x.n
#             - z.n + z.n - z.o + z'.o =              cancel z.n
#             - z.o + z'.o =                      #1 twice
#             -z.s - z.d + z'.s + z'.d =          z and z' have same tzinfo
#             z'.d - z.d
#
# So z' is UTC-equivalent to x iff z'.d = z.d at this point.  If they are equal,
# we've found the UTC-equivalent so are done.  In fact, we stop with [7] and
# return z', not bothering to compute z'.d.
#
# How could z.d and z'd differ?  z' = z + z.d [7], so merely moving z' by
# a dst() offset, and starting *from* a time already in DST (we know z.d != 0),
# would have to change the result dst() returns:  we start in DST, and moving
# a little further into it takes us out of DST.
#
# There isn't a sane case where this can happen.  The closest it gets is at
# the end of DST, where there's an hour in UTC with no spelling in a hybrid
# tzinfo class.  In US Eastern, that's 5:MM UTC = 0:MM EST = 1:MM EDT.  During
# that hour, on an Eastern clock 1:MM is taken as being in standard time (6:MM
# UTC) because the docs insist on that, but 0:MM is taken as being in daylight
# time (4:MM UTC).  There is no local time mapping to 5:MM UTC.  The local
# clock jumps from 1:59 back to 1:00 again, and repeats the 1:MM hour in
# standard time.  Since that's what the local clock *does*, we want to map both
# UTC hours 5:MM and 6:MM to 1:MM Eastern.  The result is ambiguous
# in local time, but so it goes -- it's the way the local clock works.
#
# When x = 5:MM UTC is the input to this algorithm, x.o=0, y.o=-5 and y.d=0,
# so z=0:MM.  z.d=60 (minutes) then, so [5] doesn't hold and we keep going.
# z' = z + z.d = 1:MM then, and z'.d=0, and z'.d - z.d = -60 != 0 so [8]
# (correctly) concludes that z' is not UTC-equivalent to x.
#
# Because we know z.d said z was in daylight time (else [5] would have held and
# we would have stopped then), and we know z.d != z'.d (else [8] would have held
# and we have stopped then), and there are only 2 possible values dst() can
# return in Eastern, it follows that z'.d must be 0 (which it is in the example,
# but the reasoning doesn't depend on the example -- it depends on there being
# two possible dst() outcomes, one zero and the other non-zero).  Therefore
# z' must be in standard time, and is the spelling we want in this case.
#
# Note again that z' is not UTC-equivalent as far as the hybrid tzinfo class is
# concerned (because it takes z' as being in standard time rather than the
# daylight time we intend here), but returning it gives the real-life "local
# clock repeats an hour" behavior when mapping the "unspellable" UTC hour into
# tz.
#
# When the input is 6:MM, z=1:MM and z.d=0, and we stop at once, again with
# the 1:MM standard time spelling we want.
#
# So how can this break?  One of the assumptions must be violated.  Two
# possibilities:
#
# 1) [2] effectively says that y.s is invariant across all y belong to a given
#    time zone.  This isn't true if, for political reasons or continental drift,
#    a region decides to change its base offset from UTC.
#
# 2) There may be versions of "double daylight" time where the tail end of
#    the analysis gives up a step too early.  I haven't thought about that
#    enough to say.
#
# In any case, it's clear that the default fromutc() is strong enough to handle
# "almost all" time zones:  so long as the standard offset is invariant, it
# doesn't matter if daylight time transition points change from year to year, or
# if daylight time is skipped in some years; it doesn't matter how large or
# small dst() may get within its bounds; and it doesn't even matter if some
# perverse time zone returns a negative dst()).  So a breaking case must be
# pretty bizarre, and a tzinfo subclass can override fromutc() if it is.

try:
    from _datetime import *
except ImportError:
    pass
else:
    # Clean up unused names
    del (_DAYNAMES, _DAYS_BEFORE_MONTH, _DAYS_IN_MONTH,
         _DI100Y, _DI400Y, _DI4Y, _MAXORDINAL, _MONTHNAMES,
         _build_struct_time, _call_tzinfo_method, _check_date_fields,
         _check_time_fields, _check_tzinfo_arg, _check_tzname,
         _check_utc_offset, _cmp, _cmperror, _date_class, _days_before_month,
         _days_before_year, _days_in_month, _format_time, _is_leap,
         _isoweek1monday, _math, _ord2ymd, _time, _time_class, _tzinfo_class,
         _wrap_strftime, _ymd2ord)
    # XXX Since import * above excludes names that start with _,
    # docstring does not get overwritten. In the future, it may be
    # appropriate to maintain a single module level docstring and
    # remove the following line.
    from _datetime import __doc__
                                                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python3.4/dbm/                                                                              0040755 0000000 0000000 00000000000 13077704335 013150  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/dbm/__init__.py                                                                   0100644 0000000 0000000 00000013221 12415221640 015241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Generic interface to all dbm clones.

Use

        import dbm
        d = dbm.open(file, 'w', 0o666)

The returned object is a dbm.gnu, dbm.ndbm or dbm.dumb object, dependent on the
type of database being opened (determined by the whichdb function) in the case
of an existing dbm. If the dbm does not exist and the create or new flag ('c'
or 'n') was specified, the dbm type will be determined by the availability of
the modules (tested in the above order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
"""

__all__ = ['open', 'whichdb', 'error']

import io
import os
import struct
import sys


class error(Exception):
    pass

_names = ['dbm.gnu', 'dbm.ndbm', 'dbm.dumb']
_defaultmod = None
_modules = {}

error = (error, OSError)

try:
    from dbm import ndbm
except ImportError:
    ndbm = None


def open(file, flag='r', mode=0o666):
    """Open or create database at path given by *file*.

    Optional argument *flag* can be 'r' (default) for read-only access, 'w'
    for read-write access of an existing database, 'c' for read-write access
    to a new or existing database, and 'n' for read-write access to a new
    database.

    Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
    only if it doesn't exist; and 'n' always creates a new database.
    """
    global _defaultmod
    if _defaultmod is None:
        for name in _names:
            try:
                mod = __import__(name, fromlist=['open'])
            except ImportError:
                continue
            if not _defaultmod:
                _defaultmod = mod
            _modules[name] = mod
        if not _defaultmod:
            raise ImportError("no dbm clone found; tried %s" % _names)

    # guess the type of an existing database, if not creating a new one
    result = whichdb(file) if 'n' not in flag else None
    if result is None:
        # db doesn't exist or 'n' flag was specified to create a new db
        if 'c' in flag or 'n' in flag:
            # file doesn't exist and the new flag was used so use default type
            mod = _defaultmod
        else:
            raise error[0]("need 'c' or 'n' flag to open new db")
    elif result == "":
        # db type cannot be determined
        raise error[0]("db type could not be determined")
    elif result not in _modules:
        raise error[0]("db type is {0}, but the module is not "
                       "available".format(result))
    else:
        mod = _modules[result]
    return mod.open(file, flag, mode)


def whichdb(filename):
    """Guess which db package to use to open a db file.

    Return values:

    - None if the database file can't be read;
    - empty string if the file can be read but can't be recognized
    - the name of the dbm submodule (e.g. "ndbm" or "gnu") if recognized.

    Importing the given module may still fail, and opening the
    database using that module may still fail.
    """

    # Check for ndbm first -- this has a .pag and a .dir file
    try:
        f = io.open(filename + ".pag", "rb")
        f.close()
        f = io.open(filename + ".dir", "rb")
        f.close()
        return "dbm.ndbm"
    except OSError:
        # some dbm emulations based on Berkeley DB generate a .db file
        # some do not, but they should be caught by the bsd checks
        try:
            f = io.open(filename + ".db", "rb")
            f.close()
            # guarantee we can actually open the file using dbm
            # kind of overkill, but since we are dealing with emulations
            # it seems like a prudent step
            if ndbm is not None:
                d = ndbm.open(filename)
                d.close()
                return "dbm.ndbm"
        except OSError:
            pass

    # Check for dumbdbm next -- this has a .dir and a .dat file
    try:
        # First check for presence of files
        os.stat(filename + ".dat")
        size = os.stat(filename + ".dir").st_size
        # dumbdbm files with no keys are empty
        if size == 0:
            return "dbm.dumb"
        f = io.open(filename + ".dir", "rb")
        try:
            if f.read(1) in (b"'", b'"'):
                return "dbm.dumb"
        finally:
            f.close()
    except OSError:
        pass

    # See if the file exists, return None if not
    try:
        f = io.open(filename, "rb")
    except OSError:
        return None

    # Read the start of the file -- the magic number
    s16 = f.read(16)
    f.close()
    s = s16[0:4]

    # Return "" if not at least 4 bytes
    if len(s) != 4:
        return ""

    # Convert to 4-byte int in native byte order -- return "" if impossible
    try:
        (magic,) = struct.unpack("=l", s)
    except struct.error:
        return ""

    # Check for GNU dbm
    if magic in (0x13579ace, 0x13579acd, 0x13579acf):
        return "dbm.gnu"

    # Later versions of Berkeley db hash file have a 12-byte pad in
    # front of the file type
    try:
        (magic,) = struct.unpack("=l", s16[-4:])
    except struct.error:
        return ""

    # Unknown
    return ""


if __name__ == "__main__":
    for filename in sys.argv[1:]:
        print(whichdb(filename) or "UNKNOWN", filename)
                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python3.4/dbm/__pycache__/                                                                  0040755 0000000 0000000 00000000000 13077704335 015360  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/dbm/__pycache__/__init__.cpython-34.pyc                                           0100644 0000000 0000000 00000010515 13077704335 021542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Të  „               @   s  d  Z  d d d g Z d d l Z d d l Z d d l Z d d l Z Gd d Ñ  d e É Z d d d	 g Z d a	 i  Z
 e e f Z y d d
 l m Z Wn e k
 r∞ d Z Yn Xd d d d Ñ Z d d Ñ  Z e d k rx7 e j d d Ö D] Z e e e É pd e É qÔ Wn  d S)aN  Generic interface to all dbm clones.

Use

        import dbm
        d = dbm.open(file, 'w', 0o666)

The returned object is a dbm.gnu, dbm.ndbm or dbm.dumb object, dependent on the
type of database being opened (determined by the whichdb function) in the case
of an existing dbm. If the dbm does not exist and the create or new flag ('c'
or 'n') was specified, the dbm type will be determined by the availability of
the modules (tested in the above order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
⁄open⁄whichdb⁄errorÈ    Nc               @   s   e  Z d  Z d S)r   N)⁄__name__⁄
__module__⁄__qualname__© r   r   ˙"/usr/lib/python3.4/dbm/__init__.pyr   &   s   zdbm.gnuzdbm.ndbmzdbm.dumb)⁄ndbm⁄ri∂  c             C   sE  t  d k rÉ xX t D]P } y t | d d g É} Wn t k
 rI w Yn Xt  sY | a  n  | t | <q Wt  sÉ t d t É Ç qÉ n  d | k rõ t |  É n d } | d k r· d | k s≈ d | k rŒ t  } q2t d d É Ç nQ | d	 k r t d d
 É Ç n2 | t k r(t d d j | É É Ç n
 t | } | j |  | | É S)a∂  Open or create database at path given by *file*.

    Optional argument *flag* can be 'r' (default) for read-only access, 'w'
    for read-write access of an existing database, 'c' for read-write access
    to a new or existing database, and 'n' for read-write access to a new
    database.

    Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
    only if it doesn't exist; and 'n' always creates a new database.
    N⁄fromlistr   zno dbm clone found; tried %s⁄n⁄cr   z#need 'c' or 'n' flag to open new db⁄ zdb type could not be determinedz/db type is {0}, but the module is not available)	⁄_defaultmod⁄_names⁄
__import__⁄ImportError⁄_modulesr   r   ⁄formatr   )⁄fileZflag⁄mode⁄name⁄mod⁄resultr   r   r	   r   5   s.    		
c          7   C   sF  yH t  j |  d d É } | j É  t  j |  d d É } | j É  d SWnt t k
 ræ yM t  j |  d d É } | j É  t d k	 r§ t j |  É } | j É  d SWn t k
 rπ Yn XYn Xy| t j |  d É t j |  d É j } | d k r˘ d	 St  j |  d d É } z | j d
 É d k r+d	 SWd | j É  XWn t k
 rOYn Xy t  j |  d É } Wn t k
 r~d SYn X| j d É } | j É  | d d Ö } t	 | É d k ræd Sy t
 j d | É \ } Wn t
 j k
 rÚd SYn X| d k rd Sy# t
 j d | d d Ö É \ } Wn t
 j k
 rAd SYn Xd S)au  Guess which db package to use to open a db file.

    Return values:

    - None if the database file can't be read;
    - empty string if the file can be read but can't be recognized
    - the name of the dbm submodule (e.g. "ndbm" or "gnu") if recognized.

    Importing the given module may still fail, and opening the
    database using that module may still fail.
    z.pag⁄rbz.dirzdbm.ndbmz.dbNz.datr   zdbm.dumbÈ   Û   'Û   "È   È   r   z=lÈŒöWÈÕöWÈœöWzdbm.gnu)r   r   )r!   r"   r#   È¸ˇˇˇ)⁄ior   ⁄close⁄OSErrorr
   ⁄os⁄stat⁄st_size⁄read⁄len⁄structZunpackr   )⁄filename⁄f⁄d⁄sizeZs16⁄s⁄magicr   r   r	   r   a   s`    




	
	#	⁄__main__r   ZUNKNOWN)⁄__doc__⁄__all__r%   r(   r-   ⁄sys⁄	Exceptionr   r   r   r   r'   Zdbmr
   r   r   r   r   ⁄argvr.   ⁄printr   r   r   r	   ⁄<module>   s&   ,Y                                                                                                                                                                                   usr/lib/python3.4/dbm/__pycache__/dumb.cpython-34.pyc                                               0100644 0000000 0000000 00000016743 13077704335 020743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T+)  „               @   sq   d  Z  d d l Z d d l Z d d l Z d d g Z d Z e Z	 Gd d Ñ  d e j
 É Z d d d	 d Ñ Z d S)
a≠  A dumb and slow but simple dbm clone.

For database spam, spam.dir contains the index (a text file),
spam.bak *may* contain a backup of the index (also a text file),
while spam.dat contains the data (a binary file).

XXX TO DO:

- seems to contain a bug when updating...

- reclaim free space (currently, space once occupied by deleted or expanded
items is never reused)

- support concurrent access (currently, if two processes take turns making
updates, they can mess up the index)

- support efficient access to large databases (currently, the whole index
is read when the database is opened, and some updates rewrite the whole index)

- support opening for read-only (flag = 'm')

È    N⁄error⁄openi   c               @   s  e  Z d  Z e Z e Z d d Ñ  Z d d Ñ  Z d d Ñ  Z e Z d d Ñ  Z	 d	 d
 Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z e Z d d Ñ  Z d d  Ñ  Z e Z d! d" Ñ  Z d# d$ Ñ  Z d% d& Ñ  Z d' S)(⁄	_Databasec             C   sπ   | |  _  | d |  _ | d |  _ | d |  _ d  |  _ y t j |  j d d d É} WnF t k
 r† t j |  j d d d Éè } |  j |  j É Wd  QXYn X| j	 É  |  j
 É  d  S)Nz.dirz.datz.bak⁄r⁄encodingzLatin-1⁄w)⁄_mode⁄_dirfile⁄_datfile⁄_bakfile⁄_index⁄_ior   ⁄OSError⁄_chmod⁄close⁄_update)⁄selfZfilebasename⁄mode⁄f© r   ˙/usr/lib/python3.4/dbm/dumb.py⁄__init__/   s    		
z_Database.__init__c             C   sô   i  |  _  y t j |  j d d d É} Wn t k
 r< YnY X| èP xH | D]@ } | j É  } t | É \ } } | j d É } | |  j  | <qK WWd  QXd  S)Nr   r   zLatin-1)r   r   r   r	   r   ⁄rstrip⁄eval⁄encode)r   r   ⁄line⁄key⁄pos_and_siz_pairr   r   r   r   N   s    	z_Database._updatec             C   sÚ   |  j  d  k r d  Sy |  j j |  j É Wn t k
 r> Yn Xy |  j j |  j |  j É Wn t k
 rp Yn X|  j j |  j d d d Éè] } |  j	 |  j É xC |  j  j
 É  D]2 \ } } d | j d É | f } | j | É q≤ WWd  QXd  S)Nr   r   zLatin-1z%r, %r
)r   ⁄_os⁄unlinkr   r   ⁄renamer	   r   r   r   ⁄items⁄decode⁄write)r   r   r   r   ⁄entryr   r   r   ⁄_commit_   s    !z_Database._commitc             C   s"   |  j  d  k r t d É Ç n  d  S)Nz"DBM object has already been closed)r   r   )r   r   r   r   ⁄_verify_openz   s    z_Database._verify_openc          	   C   s|   t  | t É r! | j d É } n  |  j É  |  j | \ } } t j |  j d É è# } | j | É | j	 | É } Wd  QX| S)Nzutf-8⁄rb)
⁄
isinstance⁄strr   r&   r   r   r   r
   ⁄seek⁄read)r   r   ⁄pos⁄sizr   Zdatr   r   r   ⁄__getitem__~   s    
z_Database.__getitem__c             C   sé   t  j |  j d É èg } | j d d É t | j É  É } | t d t t } | j d | | É | } | j | É Wd  QX| t | É f S)Nzrb+r   È   È   s    )	r   r   r
   r*   ⁄int⁄tell⁄
_BLOCKSIZEr#   ⁄len)r   ⁄valr   r,   Znposr   r   r   ⁄_addvalå   s    z_Database._addvalc          	   C   sH   t  j |  j d É è! } | j | É | j | É Wd  QX| t | É f S)Nzrb+)r   r   r
   r*   r#   r4   )r   r,   r5   r   r   r   r   ⁄_setvalö   s    z_Database._setvalc             C   se   | |  j  | <t j |  j d d d Éè7 } |  j |  j É | j d | j d É | f É Wd  QXd  S)N⁄ar   zLatin-1z%r, %r
)r   r   r   r	   r   r#   r"   )r   r   r   r   r   r   r   ⁄_addkey£   s    z_Database._addkeyc             C   s>  t  | t É r! | j d É } n$ t  | t t f É sE t d É Ç n  t  | t É rf | j d É } n$ t  | t t f É sä t d É Ç n  |  j É  | |  j k rø |  j | |  j	 | É É n{ |  j | \ } } | t
 d t
 } t | É t
 d t
 } | | k r$|  j | | É |  j | <n |  j	 | É |  j | <d  S)Nzutf-8zkeys must be bytes or stringszvalues must be bytes or stringsr0   )r(   r)   r   ⁄bytes⁄	bytearray⁄	TypeErrorr&   r   r9   r6   r3   r4   r7   )r   r   r5   r,   r-   Z	oldblocksZ	newblocksr   r   r   ⁄__setitem__©   s"    
z_Database.__setitem__c             C   sC   t  | t É r! | j d É } n  |  j É  |  j | =|  j É  d  S)Nzutf-8)r(   r)   r   r&   r   r%   )r   r   r   r   r   ⁄__delitem__À   s
    

z_Database.__delitem__c             C   s9   y t  |  j É SWn! t k
 r4 t d É d  Ç Yn Xd  S)Nz"DBM object has already been closed)⁄listr   r<   r   )r   r   r   r   ⁄keys◊   s    z_Database.keysc                s*   à  j  É  á  f d d Ü  à  j j É  DÉ S)Nc                s    g  |  ] } | à  | f ë q Sr   r   )⁄.0r   )r   r   r   ˙
<listcomp>ﬂ   s   	 z#_Database.items.<locals>.<listcomp>)r&   r   r@   )r   r   )r   r   r!   ›   s    
z_Database.itemsc             C   so   t  | t É r! | j d É } n  y | |  j k SWn6 t k
 rj |  j d  k rc t d É d  Ç n Ç  Yn Xd  S)Nzutf-8z"DBM object has already been closed)r(   r)   r   r   r<   r   )r   r   r   r   r   ⁄__contains__·   s    z_Database.__contains__c             C   s9   y t  |  j É SWn! t k
 r4 t d É d  Ç Yn Xd  S)Nz"DBM object has already been closed)⁄iterr   r<   r   )r   r   r   r   ⁄iterkeysÏ   s    z_Database.iterkeysc             C   s9   y t  |  j É SWn! t k
 r4 t d É d  Ç Yn Xd  S)Nz"DBM object has already been closed)r4   r   r<   r   )r   r   r   r   ⁄__len__Û   s    z_Database.__len__c             C   s,   |  j  É  d  |  _ |  _ |  _ |  _ d  S)N)r%   r   r
   r	   r   )r   r   r   r   r   ˘   s    
z_Database.closec             C   s/   t  |  j d É r+ |  j j | |  j É n  d  S)N⁄chmod)⁄hasattrr   rG   r   )r   ⁄filer   r   r   r   ˇ   s    z_Database._chmodc             C   s   |  S)Nr   )r   r   r   r   ⁄	__enter__  s    z_Database.__enter__c             G   s   |  j  É  d  S)N)r   )r   ⁄argsr   r   r   ⁄__exit__  s    z_Database.__exit__N)⁄__name__⁄
__module__⁄__qualname__r   r   r   r   r%   ⁄syncr&   r.   r6   r7   r9   r=   r>   r@   r!   rC   rE   ⁄__iter__rF   r   ⁄__del__r   rJ   rL   r   r   r   r   r   "   s0   
	"r   i∂  c             C   sM   y  t  j d É } t  j | É Wn t k
 r4 Yn X| | @} t |  | É S)aˆ  Open the database file, filename, and return corresponding object.

    The flag argument, used to control how the database is opened in the
    other DBM implementations, is ignored in the dbm.dumb module; the
    database is always opened for update, and will be created if it does
    not exist.

    The optional mode argument is the UNIX mode of the file, used only when
    the database has to be created.  It defaults to octal code 0o666 (and
    will be modified by the prevailing umask).

    r   )r   ⁄umask⁄AttributeErrorr   )rI   Zflagr   Zumr   r   r   r   
  s    )⁄__doc__⁄ior   ⁄osr   ⁄collections⁄__all__r3   r   r   ⁄MutableMappingr   r   r   r   r   r   ⁄<module>   s   Ë                             usr/lib/python3.4/dbm/__pycache__/gnu.cpython-34.pyc                                                0100644 0000000 0000000 00000000521 13077704335 020570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T∫   „               @   sV   d  Z  y d d l TWn; e k
 rQ Z z e e e É d É Ç WYd d Z [ Xn Xd S)z,Provide the _gdbm module as a dbm submodule.È    )⁄*z), please install the python3-gdbm packageN)⁄__doc__Z_gdbm⁄ImportError⁄msg⁄str© r   r   ˙/usr/lib/python3.4/dbm/gnu.py⁄<module>   s                                                                                                                                                                                  usr/lib/python3.4/dbm/__pycache__/ndbm.cpython-34.pyc                                               0100644 0000000 0000000 00000000306 13077704335 020720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TF   „               @   s   d  Z  d d l Td S)z+Provide the _dbm module as a dbm submodule.È    )⁄*N)⁄__doc__Z_dbm© r   r   ˙/usr/lib/python3.4/dbm/ndbm.py⁄<module>   s                                                                                                                                                                                                                                                                                                                             usr/lib/python3.4/dbm/dumb.py                                                                       0100644 0000000 0000000 00000024453 12415221640 014442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """A dumb and slow but simple dbm clone.

For database spam, spam.dir contains the index (a text file),
spam.bak *may* contain a backup of the index (also a text file),
while spam.dat contains the data (a binary file).

XXX TO DO:

- seems to contain a bug when updating...

- reclaim free space (currently, space once occupied by deleted or expanded
items is never reused)

- support concurrent access (currently, if two processes take turns making
updates, they can mess up the index)

- support efficient access to large databases (currently, the whole index
is read when the database is opened, and some updates rewrite the whole index)

- support opening for read-only (flag = 'm')

"""

import io as _io
import os as _os
import collections

__all__ = ["error", "open"]

_BLOCKSIZE = 512

error = OSError

class _Database(collections.MutableMapping):

    # The on-disk directory and data files can remain in mutually
    # inconsistent states for an arbitrarily long time (see comments
    # at the end of __setitem__).  This is only repaired when _commit()
    # gets called.  One place _commit() gets called is from __del__(),
    # and if that occurs at program shutdown time, module globals may
    # already have gotten rebound to None.  Since it's crucial that
    # _commit() finish successfully, we can't ignore shutdown races
    # here, and _commit() must not reference any globals.
    _os = _os       # for _commit()
    _io = _io       # for _commit()

    def __init__(self, filebasename, mode):
        self._mode = mode

        # The directory file is a text file.  Each line looks like
        #    "%r, (%d, %d)\n" % (key, pos, siz)
        # where key is the string key, pos is the offset into the dat
        # file of the associated value's first byte, and siz is the number
        # of bytes in the associated value.
        self._dirfile = filebasename + '.dir'

        # The data file is a binary file pointed into by the directory
        # file, and holds the values associated with keys.  Each value
        # begins at a _BLOCKSIZE-aligned byte offset, and is a raw
        # binary 8-bit string value.
        self._datfile = filebasename + '.dat'
        self._bakfile = filebasename + '.bak'

        # The index is an in-memory dict, mirroring the directory file.
        self._index = None  # maps keys to (pos, siz) pairs

        # Mod by Jack: create data file if needed
        try:
            f = _io.open(self._datfile, 'r', encoding="Latin-1")
        except OSError:
            with _io.open(self._datfile, 'w', encoding="Latin-1") as f:
                self._chmod(self._datfile)
        else:
            f.close()
        self._update()

    # Read directory file into the in-memory index dict.
    def _update(self):
        self._index = {}
        try:
            f = _io.open(self._dirfile, 'r', encoding="Latin-1")
        except OSError:
            pass
        else:
            with f:
                for line in f:
                    line = line.rstrip()
                    key, pos_and_siz_pair = eval(line)
                    key = key.encode('Latin-1')
                    self._index[key] = pos_and_siz_pair

    # Write the index dict to the directory file.  The original directory
    # file (if any) is renamed with a .bak extension first.  If a .bak
    # file currently exists, it's deleted.
    def _commit(self):
        # CAUTION:  It's vital that _commit() succeed, and _commit() can
        # be called from __del__().  Therefore we must never reference a
        # global in this routine.
        if self._index is None:
            return  # nothing to do

        try:
            self._os.unlink(self._bakfile)
        except OSError:
            pass

        try:
            self._os.rename(self._dirfile, self._bakfile)
        except OSError:
            pass

        with self._io.open(self._dirfile, 'w', encoding="Latin-1") as f:
            self._chmod(self._dirfile)
            for key, pos_and_siz_pair in self._index.items():
                # Use Latin-1 since it has no qualms with any value in any
                # position; UTF-8, though, does care sometimes.
                entry = "%r, %r\n" % (key.decode('Latin-1'), pos_and_siz_pair)
                f.write(entry)

    sync = _commit

    def _verify_open(self):
        if self._index is None:
            raise error('DBM object has already been closed')

    def __getitem__(self, key):
        if isinstance(key, str):
            key = key.encode('utf-8')
        self._verify_open()
        pos, siz = self._index[key]     # may raise KeyError
        with _io.open(self._datfile, 'rb') as f:
            f.seek(pos)
            dat = f.read(siz)
        return dat

    # Append val to the data file, starting at a _BLOCKSIZE-aligned
    # offset.  The data file is first padded with NUL bytes (if needed)
    # to get to an aligned offset.  Return pair
    #     (starting offset of val, len(val))
    def _addval(self, val):
        with _io.open(self._datfile, 'rb+') as f:
            f.seek(0, 2)
            pos = int(f.tell())
            npos = ((pos + _BLOCKSIZE - 1) // _BLOCKSIZE) * _BLOCKSIZE
            f.write(b'\0'*(npos-pos))
            pos = npos
            f.write(val)
        return (pos, len(val))

    # Write val to the data file, starting at offset pos.  The caller
    # is responsible for ensuring that there's enough room starting at
    # pos to hold val, without overwriting some other value.  Return
    # pair (pos, len(val)).
    def _setval(self, pos, val):
        with _io.open(self._datfile, 'rb+') as f:
            f.seek(pos)
            f.write(val)
        return (pos, len(val))

    # key is a new key whose associated value starts in the data file
    # at offset pos and with length siz.  Add an index record to
    # the in-memory index dict, and append one to the directory file.
    def _addkey(self, key, pos_and_siz_pair):
        self._index[key] = pos_and_siz_pair
        with _io.open(self._dirfile, 'a', encoding="Latin-1") as f:
            self._chmod(self._dirfile)
            f.write("%r, %r\n" % (key.decode("Latin-1"), pos_and_siz_pair))

    def __setitem__(self, key, val):
        if isinstance(key, str):
            key = key.encode('utf-8')
        elif not isinstance(key, (bytes, bytearray)):
            raise TypeError("keys must be bytes or strings")
        if isinstance(val, str):
            val = val.encode('utf-8')
        elif not isinstance(val, (bytes, bytearray)):
            raise TypeError("values must be bytes or strings")
        self._verify_open()
        if key not in self._index:
            self._addkey(key, self._addval(val))
        else:
            # See whether the new value is small enough to fit in the
            # (padded) space currently occupied by the old value.
            pos, siz = self._index[key]
            oldblocks = (siz + _BLOCKSIZE - 1) // _BLOCKSIZE
            newblocks = (len(val) + _BLOCKSIZE - 1) // _BLOCKSIZE
            if newblocks <= oldblocks:
                self._index[key] = self._setval(pos, val)
            else:
                # The new value doesn't fit in the (padded) space used
                # by the old value.  The blocks used by the old value are
                # forever lost.
                self._index[key] = self._addval(val)

            # Note that _index may be out of synch with the directory
            # file now:  _setval() and _addval() don't update the directory
            # file.  This also means that the on-disk directory and data
            # files are in a mutually inconsistent state, and they'll
            # remain that way until _commit() is called.  Note that this
            # is a disaster (for the database) if the program crashes
            # (so that _commit() never gets called).

    def __delitem__(self, key):
        if isinstance(key, str):
            key = key.encode('utf-8')
        self._verify_open()
        # The blocks used by the associated value are lost.
        del self._index[key]
        # XXX It's unclear why we do a _commit() here (the code always
        # XXX has, so I'm not changing it).  __setitem__ doesn't try to
        # XXX keep the directory file in synch.  Why should we?  Or
        # XXX why shouldn't __setitem__?
        self._commit()

    def keys(self):
        try:
            return list(self._index)
        except TypeError:
            raise error('DBM object has already been closed') from None

    def items(self):
        self._verify_open()
        return [(key, self[key]) for key in self._index.keys()]

    def __contains__(self, key):
        if isinstance(key, str):
            key = key.encode('utf-8')
        try:
            return key in self._index
        except TypeError:
            if self._index is None:
                raise error('DBM object has already been closed') from None
            else:
                raise

    def iterkeys(self):
        try:
            return iter(self._index)
        except TypeError:
            raise error('DBM object has already been closed') from None
    __iter__ = iterkeys

    def __len__(self):
        try:
            return len(self._index)
        except TypeError:
            raise error('DBM object has already been closed') from None

    def close(self):
        self._commit()
        self._index = self._datfile = self._dirfile = self._bakfile = None

    __del__ = close

    def _chmod(self, file):
        if hasattr(self._os, 'chmod'):
            self._os.chmod(file, self._mode)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()


def open(file, flag=None, mode=0o666):
    """Open the database file, filename, and return corresponding object.

    The flag argument, used to control how the database is opened in the
    other DBM implementations, is ignored in the dbm.dumb module; the
    database is always opened for update, and will be created if it does
    not exist.

    The optional mode argument is the UNIX mode of the file, used only when
    the database has to be created.  It defaults to octal code 0o666 (and
    will be modified by the prevailing umask).

    """
    # flag argument is currently ignored

    # Modify mode depending on the umask
    try:
        um = _os.umask(0)
        _os.umask(um)
    except AttributeError:
        pass
    else:
        # Turn off any bits that are set in the umask
        mode = mode & (~um)

    return _Database(file, mode)
                                                                                                                                                                                                                     usr/lib/python3.4/dbm/gnu.py                                                                        0100644 0000000 0000000 00000000272 12415221640 014275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Provide the _gdbm module as a dbm submodule."""

try:
    from _gdbm import *
except ImportError as msg:
    raise ImportError(str(msg) + ', please install the python3-gdbm package')
                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/dbm/ndbm.py                                                                       0100644 0000000 0000000 00000000106 12415221640 014420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Provide the _dbm module as a dbm submodule."""

from _dbm import *
                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/decimal.py                                                                        0100644 0000000 0000000 00000676435 12415221636 014371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (c) 2004 Python Software Foundation.
# All rights reserved.

# Written by Eric Price <eprice at tjhsst.edu>
#    and Facundo Batista <facundo at taniquetil.com.ar>
#    and Raymond Hettinger <python at rcn.com>
#    and Aahz <aahz at pobox.com>
#    and Tim Peters

# This module should be kept in sync with the latest updates of the
# IBM specification as it evolves.  Those updates will be treated
# as bug fixes (deviation from the spec is a compatibility, usability
# bug) and will be backported.  At this point the spec is stabilizing
# and the updates are becoming fewer, smaller, and less significant.

"""
This is an implementation of decimal floating point arithmetic based on
the General Decimal Arithmetic Specification:

    http://speleotrove.com/decimal/decarith.html

and IEEE standard 854-1987:

    http://en.wikipedia.org/wiki/IEEE_854-1987

Decimal floating point has finite precision with arbitrarily large bounds.

The purpose of this module is to support arithmetic using familiar
"schoolhouse" rules and to avoid some of the tricky representation
issues associated with binary floating point.  The package is especially
useful for financial applications or for contexts where users have
expectations that are at odds with binary floating point (for instance,
in binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead
of 0.0; Decimal('1.00') % Decimal('0.1') returns the expected
Decimal('0.00')).

Here are some examples of using the decimal module:

>>> from decimal import *
>>> setcontext(ExtendedContext)
>>> Decimal(0)
Decimal('0')
>>> Decimal('1')
Decimal('1')
>>> Decimal('-.0123')
Decimal('-0.0123')
>>> Decimal(123456)
Decimal('123456')
>>> Decimal('123.45e12345678')
Decimal('1.2345E+12345680')
>>> Decimal('1.33') + Decimal('1.27')
Decimal('2.60')
>>> Decimal('12.34') + Decimal('3.87') - Decimal('18.41')
Decimal('-2.20')
>>> dig = Decimal(1)
>>> print(dig / Decimal(3))
0.333333333
>>> getcontext().prec = 18
>>> print(dig / Decimal(3))
0.333333333333333333
>>> print(dig.sqrt())
1
>>> print(Decimal(3).sqrt())
1.73205080756887729
>>> print(Decimal(3) ** 123)
4.85192780976896427E+58
>>> inf = Decimal(1) / Decimal(0)
>>> print(inf)
Infinity
>>> neginf = Decimal(-1) / Decimal(0)
>>> print(neginf)
-Infinity
>>> print(neginf + inf)
NaN
>>> print(neginf * inf)
-Infinity
>>> print(dig / 0)
Infinity
>>> getcontext().traps[DivisionByZero] = 1
>>> print(dig / 0)
Traceback (most recent call last):
  ...
  ...
  ...
decimal.DivisionByZero: x / 0
>>> c = Context()
>>> c.traps[InvalidOperation] = 0
>>> print(c.flags[InvalidOperation])
0
>>> c.divide(Decimal(0), Decimal(0))
Decimal('NaN')
>>> c.traps[InvalidOperation] = 1
>>> print(c.flags[InvalidOperation])
1
>>> c.flags[InvalidOperation] = 0
>>> print(c.flags[InvalidOperation])
0
>>> print(c.divide(Decimal(0), Decimal(0)))
Traceback (most recent call last):
  ...
  ...
  ...
decimal.InvalidOperation: 0 / 0
>>> print(c.flags[InvalidOperation])
1
>>> c.flags[InvalidOperation] = 0
>>> c.traps[InvalidOperation] = 0
>>> print(c.divide(Decimal(0), Decimal(0)))
NaN
>>> print(c.flags[InvalidOperation])
1
>>>
"""

__all__ = [
    # Two major classes
    'Decimal', 'Context',

    # Named tuple representation
    'DecimalTuple',

    # Contexts
    'DefaultContext', 'BasicContext', 'ExtendedContext',

    # Exceptions
    'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero',
    'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow',
    'FloatOperation',

    # Exceptional conditions that trigger InvalidOperation
    'DivisionImpossible', 'InvalidContext', 'ConversionSyntax', 'DivisionUndefined',

    # Constants for use in setting up contexts
    'ROUND_DOWN', 'ROUND_HALF_UP', 'ROUND_HALF_EVEN', 'ROUND_CEILING',
    'ROUND_FLOOR', 'ROUND_UP', 'ROUND_HALF_DOWN', 'ROUND_05UP',

    # Functions for manipulating contexts
    'setcontext', 'getcontext', 'localcontext',

    # Limits for the C version for compatibility
    'MAX_PREC',  'MAX_EMAX', 'MIN_EMIN', 'MIN_ETINY',

    # C version: compile time choice that enables the thread local context
    'HAVE_THREADS'
]

__version__ = '1.70'    # Highest version of the spec this complies with
                        # See http://speleotrove.com/decimal/
__libmpdec_version__ = "2.4.1" # compatible libmpdec version

import math as _math
import numbers as _numbers
import sys

try:
    from collections import namedtuple as _namedtuple
    DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')
except ImportError:
    DecimalTuple = lambda *args: args

# Rounding
ROUND_DOWN = 'ROUND_DOWN'
ROUND_HALF_UP = 'ROUND_HALF_UP'
ROUND_HALF_EVEN = 'ROUND_HALF_EVEN'
ROUND_CEILING = 'ROUND_CEILING'
ROUND_FLOOR = 'ROUND_FLOOR'
ROUND_UP = 'ROUND_UP'
ROUND_HALF_DOWN = 'ROUND_HALF_DOWN'
ROUND_05UP = 'ROUND_05UP'

# Compatibility with the C version
HAVE_THREADS = True
if sys.maxsize == 2**63-1:
    MAX_PREC = 999999999999999999
    MAX_EMAX = 999999999999999999
    MIN_EMIN = -999999999999999999
else:
    MAX_PREC = 425000000
    MAX_EMAX = 425000000
    MIN_EMIN = -425000000

MIN_ETINY = MIN_EMIN - (MAX_PREC-1)

# Errors

class DecimalException(ArithmeticError):
    """Base exception class.

    Used exceptions derive from this.
    If an exception derives from another exception besides this (such as
    Underflow (Inexact, Rounded, Subnormal) that indicates that it is only
    called if the others are present.  This isn't actually used for
    anything, though.

    handle  -- Called when context._raise_error is called and the
               trap_enabler is not set.  First argument is self, second is the
               context.  More arguments can be given, those being after
               the explanation in _raise_error (For example,
               context._raise_error(NewError, '(-x)!', self._sign) would
               call NewError().handle(context, self._sign).)

    To define a new exception, it should be sufficient to have it derive
    from DecimalException.
    """
    def handle(self, context, *args):
        pass


class Clamped(DecimalException):
    """Exponent of a 0 changed to fit bounds.

    This occurs and signals clamped if the exponent of a result has been
    altered in order to fit the constraints of a specific concrete
    representation.  This may occur when the exponent of a zero result would
    be outside the bounds of a representation, or when a large normal
    number would have an encoded exponent that cannot be represented.  In
    this latter case, the exponent is reduced to fit and the corresponding
    number of zero digits are appended to the coefficient ("fold-down").
    """

class InvalidOperation(DecimalException):
    """An invalid operation was performed.

    Various bad things cause this:

    Something creates a signaling NaN
    -INF + INF
    0 * (+-)INF
    (+-)INF / (+-)INF
    x % 0
    (+-)INF % x
    x._rescale( non-integer )
    sqrt(-x) , x > 0
    0 ** 0
    x ** (non-integer)
    x ** (+-)INF
    An operand is invalid

    The result of the operation after these is a quiet positive NaN,
    except when the cause is a signaling NaN, in which case the result is
    also a quiet NaN, but with the original sign, and an optional
    diagnostic information.
    """
    def handle(self, context, *args):
        if args:
            ans = _dec_from_triple(args[0]._sign, args[0]._int, 'n', True)
            return ans._fix_nan(context)
        return _NaN

class ConversionSyntax(InvalidOperation):
    """Trying to convert badly formed string.

    This occurs and signals invalid-operation if an string is being
    converted to a number and it does not conform to the numeric string
    syntax.  The result is [0,qNaN].
    """
    def handle(self, context, *args):
        return _NaN

class DivisionByZero(DecimalException, ZeroDivisionError):
    """Division by 0.

    This occurs and signals division-by-zero if division of a finite number
    by zero was attempted (during a divide-integer or divide operation, or a
    power operation with negative right-hand operand), and the dividend was
    not zero.

    The result of the operation is [sign,inf], where sign is the exclusive
    or of the signs of the operands for divide, or is 1 for an odd power of
    -0, for power.
    """

    def handle(self, context, sign, *args):
        return _SignedInfinity[sign]

class DivisionImpossible(InvalidOperation):
    """Cannot perform the division adequately.

    This occurs and signals invalid-operation if the integer result of a
    divide-integer or remainder operation had too many digits (would be
    longer than precision).  The result is [0,qNaN].
    """

    def handle(self, context, *args):
        return _NaN

class DivisionUndefined(InvalidOperation, ZeroDivisionError):
    """Undefined result of division.

    This occurs and signals invalid-operation if division by zero was
    attempted (during a divide-integer, divide, or remainder operation), and
    the dividend is also zero.  The result is [0,qNaN].
    """

    def handle(self, context, *args):
        return _NaN

class Inexact(DecimalException):
    """Had to round, losing information.

    This occurs and signals inexact whenever the result of an operation is
    not exact (that is, it needed to be rounded and any discarded digits
    were non-zero), or if an overflow or underflow condition occurs.  The
    result in all cases is unchanged.

    The inexact signal may be tested (or trapped) to determine if a given
    operation (or sequence of operations) was inexact.
    """

class InvalidContext(InvalidOperation):
    """Invalid context.  Unknown rounding, for example.

    This occurs and signals invalid-operation if an invalid context was
    detected during an operation.  This can occur if contexts are not checked
    on creation and either the precision exceeds the capability of the
    underlying concrete representation or an unknown or unsupported rounding
    was specified.  These aspects of the context need only be checked when
    the values are required to be used.  The result is [0,qNaN].
    """

    def handle(self, context, *args):
        return _NaN

class Rounded(DecimalException):
    """Number got rounded (not  necessarily changed during rounding).

    This occurs and signals rounded whenever the result of an operation is
    rounded (that is, some zero or non-zero digits were discarded from the
    coefficient), or if an overflow or underflow condition occurs.  The
    result in all cases is unchanged.

    The rounded signal may be tested (or trapped) to determine if a given
    operation (or sequence of operations) caused a loss of precision.
    """

class Subnormal(DecimalException):
    """Exponent < Emin before rounding.

    This occurs and signals subnormal whenever the result of a conversion or
    operation is subnormal (that is, its adjusted exponent is less than
    Emin, before any rounding).  The result in all cases is unchanged.

    The subnormal signal may be tested (or trapped) to determine if a given
    or operation (or sequence of operations) yielded a subnormal result.
    """

class Overflow(Inexact, Rounded):
    """Numerical overflow.

    This occurs and signals overflow if the adjusted exponent of a result
    (from a conversion or from an operation that is not an attempt to divide
    by zero), after rounding, would be greater than the largest value that
    can be handled by the implementation (the value Emax).

    The result depends on the rounding mode:

    For round-half-up and round-half-even (and for round-half-down and
    round-up, if implemented), the result of the operation is [sign,inf],
    where sign is the sign of the intermediate result.  For round-down, the
    result is the largest finite number that can be represented in the
    current precision, with the sign of the intermediate result.  For
    round-ceiling, the result is the same as for round-down if the sign of
    the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,
    the result is the same as for round-down if the sign of the intermediate
    result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded
    will also be raised.
    """

    def handle(self, context, sign, *args):
        if context.rounding in (ROUND_HALF_UP, ROUND_HALF_EVEN,
                                ROUND_HALF_DOWN, ROUND_UP):
            return _SignedInfinity[sign]
        if sign == 0:
            if context.rounding == ROUND_CEILING:
                return _SignedInfinity[sign]
            return _dec_from_triple(sign, '9'*context.prec,
                            context.Emax-context.prec+1)
        if sign == 1:
            if context.rounding == ROUND_FLOOR:
                return _SignedInfinity[sign]
            return _dec_from_triple(sign, '9'*context.prec,
                             context.Emax-context.prec+1)


class Underflow(Inexact, Rounded, Subnormal):
    """Numerical underflow with result rounded to 0.

    This occurs and signals underflow if a result is inexact and the
    adjusted exponent of the result would be smaller (more negative) than
    the smallest value that can be handled by the implementation (the value
    Emin).  That is, the result is both inexact and subnormal.

    The result after an underflow will be a subnormal number rounded, if
    necessary, so that its exponent is not less than Etiny.  This may result
    in 0 with the sign of the intermediate result and an exponent of Etiny.

    In all cases, Inexact, Rounded, and Subnormal will also be raised.
    """

class FloatOperation(DecimalException, TypeError):
    """Enable stricter semantics for mixing floats and Decimals.

    If the signal is not trapped (default), mixing floats and Decimals is
    permitted in the Decimal() constructor, context.create_decimal() and
    all comparison operators. Both conversion and comparisons are exact.
    Any occurrence of a mixed operation is silently recorded by setting
    FloatOperation in the context flags.  Explicit conversions with
    Decimal.from_float() or context.create_decimal_from_float() do not
    set the flag.

    Otherwise (the signal is trapped), only equality comparisons and explicit
    conversions are silent. All other mixed operations raise FloatOperation.
    """

# List of public traps and flags
_signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded,
            Underflow, InvalidOperation, Subnormal, FloatOperation]

# Map conditions (per the spec) to signals
_condition_map = {ConversionSyntax:InvalidOperation,
                  DivisionImpossible:InvalidOperation,
                  DivisionUndefined:InvalidOperation,
                  InvalidContext:InvalidOperation}

# Valid rounding modes
_rounding_modes = (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_CEILING,
                   ROUND_FLOOR, ROUND_UP, ROUND_HALF_DOWN, ROUND_05UP)

##### Context Functions ##################################################

# The getcontext() and setcontext() function manage access to a thread-local
# current context.  Py2.4 offers direct support for thread locals.  If that
# is not available, use threading.current_thread() which is slower but will
# work for older Pythons.  If threads are not part of the build, create a
# mock threading object with threading.local() returning the module namespace.

try:
    import threading
except ImportError:
    # Python was compiled without threads; create a mock object instead
    class MockThreading(object):
        def local(self, sys=sys):
            return sys.modules[__name__]
    threading = MockThreading()
    del MockThreading

try:
    threading.local

except AttributeError:

    # To fix reloading, force it to create a new context
    # Old contexts have different exceptions in their dicts, making problems.
    if hasattr(threading.current_thread(), '__decimal_context__'):
        del threading.current_thread().__decimal_context__

    def setcontext(context):
        """Set this thread's context to context."""
        if context in (DefaultContext, BasicContext, ExtendedContext):
            context = context.copy()
            context.clear_flags()
        threading.current_thread().__decimal_context__ = context

    def getcontext():
        """Returns this thread's context.

        If this thread does not yet have a context, returns
        a new context and sets this thread's context.
        New contexts are copies of DefaultContext.
        """
        try:
            return threading.current_thread().__decimal_context__
        except AttributeError:
            context = Context()
            threading.current_thread().__decimal_context__ = context
            return context

else:

    local = threading.local()
    if hasattr(local, '__decimal_context__'):
        del local.__decimal_context__

    def getcontext(_local=local):
        """Returns this thread's context.

        If this thread does not yet have a context, returns
        a new context and sets this thread's context.
        New contexts are copies of DefaultContext.
        """
        try:
            return _local.__decimal_context__
        except AttributeError:
            context = Context()
            _local.__decimal_context__ = context
            return context

    def setcontext(context, _local=local):
        """Set this thread's context to context."""
        if context in (DefaultContext, BasicContext, ExtendedContext):
            context = context.copy()
            context.clear_flags()
        _local.__decimal_context__ = context

    del threading, local        # Don't contaminate the namespace

def localcontext(ctx=None):
    """Return a context manager for a copy of the supplied context

    Uses a copy of the current context if no context is specified
    The returned context manager creates a local decimal context
    in a with statement:
        def sin(x):
             with localcontext() as ctx:
                 ctx.prec += 2
                 # Rest of sin calculation algorithm
                 # uses a precision 2 greater than normal
             return +s  # Convert result to normal precision

         def sin(x):
             with localcontext(ExtendedContext):
                 # Rest of sin calculation algorithm
                 # uses the Extended Context from the
                 # General Decimal Arithmetic Specification
             return +s  # Convert result to normal context

    >>> setcontext(DefaultContext)
    >>> print(getcontext().prec)
    28
    >>> with localcontext():
    ...     ctx = getcontext()
    ...     ctx.prec += 2
    ...     print(ctx.prec)
    ...
    30
    >>> with localcontext(ExtendedContext):
    ...     print(getcontext().prec)
    ...
    9
    >>> print(getcontext().prec)
    28
    """
    if ctx is None: ctx = getcontext()
    return _ContextManager(ctx)


##### Decimal class #######################################################

# Do not subclass Decimal from numbers.Real and do not register it as such
# (because Decimals are not interoperable with floats).  See the notes in
# numbers.py for more detail.

class Decimal(object):
    """Floating point class for decimal arithmetic."""

    __slots__ = ('_exp','_int','_sign', '_is_special')
    # Generally, the value of the Decimal instance is given by
    #  (-1)**_sign * _int * 10**_exp
    # Special values are signified by _is_special == True

    # We're immutable, so use __new__ not __init__
    def __new__(cls, value="0", context=None):
        """Create a decimal point instance.

        >>> Decimal('3.14')              # string input
        Decimal('3.14')
        >>> Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)
        Decimal('3.14')
        >>> Decimal(314)                 # int
        Decimal('314')
        >>> Decimal(Decimal(314))        # another decimal instance
        Decimal('314')
        >>> Decimal('  3.14  \\n')        # leading and trailing whitespace okay
        Decimal('3.14')
        """

        # Note that the coefficient, self._int, is actually stored as
        # a string rather than as a tuple of digits.  This speeds up
        # the "digits to integer" and "integer to digits" conversions
        # that are used in almost every arithmetic operation on
        # Decimals.  This is an internal detail: the as_tuple function
        # and the Decimal constructor still deal with tuples of
        # digits.

        self = object.__new__(cls)

        # From a string
        # REs insist on real strings, so we can too.
        if isinstance(value, str):
            m = _parser(value.strip())
            if m is None:
                if context is None:
                    context = getcontext()
                return context._raise_error(ConversionSyntax,
                                "Invalid literal for Decimal: %r" % value)

            if m.group('sign') == "-":
                self._sign = 1
            else:
                self._sign = 0
            intpart = m.group('int')
            if intpart is not None:
                # finite number
                fracpart = m.group('frac') or ''
                exp = int(m.group('exp') or '0')
                self._int = str(int(intpart+fracpart))
                self._exp = exp - len(fracpart)
                self._is_special = False
            else:
                diag = m.group('diag')
                if diag is not None:
                    # NaN
                    self._int = str(int(diag or '0')).lstrip('0')
                    if m.group('signal'):
                        self._exp = 'N'
                    else:
                        self._exp = 'n'
                else:
                    # infinity
                    self._int = '0'
                    self._exp = 'F'
                self._is_special = True
            return self

        # From an integer
        if isinstance(value, int):
            if value >= 0:
                self._sign = 0
            else:
                self._sign = 1
            self._exp = 0
            self._int = str(abs(value))
            self._is_special = False
            return self

        # From another decimal
        if isinstance(value, Decimal):
            self._exp  = value._exp
            self._sign = value._sign
            self._int  = value._int
            self._is_special  = value._is_special
            return self

        # From an internal working value
        if isinstance(value, _WorkRep):
            self._sign = value.sign
            self._int = str(value.int)
            self._exp = int(value.exp)
            self._is_special = False
            return self

        # tuple/list conversion (possibly from as_tuple())
        if isinstance(value, (list,tuple)):
            if len(value) != 3:
                raise ValueError('Invalid tuple size in creation of Decimal '
                                 'from list or tuple.  The list or tuple '
                                 'should have exactly three elements.')
            # process sign.  The isinstance test rejects floats
            if not (isinstance(value[0], int) and value[0] in (0,1)):
                raise ValueError("Invalid sign.  The first value in the tuple "
                                 "should be an integer; either 0 for a "
                                 "positive number or 1 for a negative number.")
            self._sign = value[0]
            if value[2] == 'F':
                # infinity: value[1] is ignored
                self._int = '0'
                self._exp = value[2]
                self._is_special = True
            else:
                # process and validate the digits in value[1]
                digits = []
                for digit in value[1]:
                    if isinstance(digit, int) and 0 <= digit <= 9:
                        # skip leading zeros
                        if digits or digit != 0:
                            digits.append(digit)
                    else:
                        raise ValueError("The second value in the tuple must "
                                         "be composed of integers in the range "
                                         "0 through 9.")
                if value[2] in ('n', 'N'):
                    # NaN: digits form the diagnostic
                    self._int = ''.join(map(str, digits))
                    self._exp = value[2]
                    self._is_special = True
                elif isinstance(value[2], int):
                    # finite number: digits give the coefficient
                    self._int = ''.join(map(str, digits or [0]))
                    self._exp = value[2]
                    self._is_special = False
                else:
                    raise ValueError("The third value in the tuple must "
                                     "be an integer, or one of the "
                                     "strings 'F', 'n', 'N'.")
            return self

        if isinstance(value, float):
            if context is None:
                context = getcontext()
            context._raise_error(FloatOperation,
                "strict semantics for mixing floats and Decimals are "
                "enabled")
            value = Decimal.from_float(value)
            self._exp  = value._exp
            self._sign = value._sign
            self._int  = value._int
            self._is_special  = value._is_special
            return self

        raise TypeError("Cannot convert %r to Decimal" % value)

    @classmethod
    def from_float(cls, f):
        """Converts a float to a decimal number, exactly.

        Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').
        Since 0.1 is not exactly representable in binary floating point, the
        value is stored as the nearest representable value which is
        0x1.999999999999ap-4.  The exact equivalent of the value in decimal
        is 0.1000000000000000055511151231257827021181583404541015625.

        >>> Decimal.from_float(0.1)
        Decimal('0.1000000000000000055511151231257827021181583404541015625')
        >>> Decimal.from_float(float('nan'))
        Decimal('NaN')
        >>> Decimal.from_float(float('inf'))
        Decimal('Infinity')
        >>> Decimal.from_float(-float('inf'))
        Decimal('-Infinity')
        >>> Decimal.from_float(-0.0)
        Decimal('-0')

        """
        if isinstance(f, int):                # handle integer inputs
            return cls(f)
        if not isinstance(f, float):
            raise TypeError("argument must be int or float.")
        if _math.isinf(f) or _math.isnan(f):
            return cls(repr(f))
        if _math.copysign(1.0, f) == 1.0:
            sign = 0
        else:
            sign = 1
        n, d = abs(f).as_integer_ratio()
        k = d.bit_length() - 1
        result = _dec_from_triple(sign, str(n*5**k), -k)
        if cls is Decimal:
            return result
        else:
            return cls(result)

    def _isnan(self):
        """Returns whether the number is not actually one.

        0 if a number
        1 if NaN
        2 if sNaN
        """
        if self._is_special:
            exp = self._exp
            if exp == 'n':
                return 1
            elif exp == 'N':
                return 2
        return 0

    def _isinfinity(self):
        """Returns whether the number is infinite

        0 if finite or not a number
        1 if +INF
        -1 if -INF
        """
        if self._exp == 'F':
            if self._sign:
                return -1
            return 1
        return 0

    def _check_nans(self, other=None, context=None):
        """Returns whether the number is not actually one.

        if self, other are sNaN, signal
        if self, other are NaN return nan
        return 0

        Done before operations.
        """

        self_is_nan = self._isnan()
        if other is None:
            other_is_nan = False
        else:
            other_is_nan = other._isnan()

        if self_is_nan or other_is_nan:
            if context is None:
                context = getcontext()

            if self_is_nan == 2:
                return context._raise_error(InvalidOperation, 'sNaN',
                                        self)
            if other_is_nan == 2:
                return context._raise_error(InvalidOperation, 'sNaN',
                                        other)
            if self_is_nan:
                return self._fix_nan(context)

            return other._fix_nan(context)
        return 0

    def _compare_check_nans(self, other, context):
        """Version of _check_nans used for the signaling comparisons
        compare_signal, __le__, __lt__, __ge__, __gt__.

        Signal InvalidOperation if either self or other is a (quiet
        or signaling) NaN.  Signaling NaNs take precedence over quiet
        NaNs.

        Return 0 if neither operand is a NaN.

        """
        if context is None:
            context = getcontext()

        if self._is_special or other._is_special:
            if self.is_snan():
                return context._raise_error(InvalidOperation,
                                            'comparison involving sNaN',
                                            self)
            elif other.is_snan():
                return context._raise_error(InvalidOperation,
                                            'comparison involving sNaN',
                                            other)
            elif self.is_qnan():
                return context._raise_error(InvalidOperation,
                                            'comparison involving NaN',
                                            self)
            elif other.is_qnan():
                return context._raise_error(InvalidOperation,
                                            'comparison involving NaN',
                                            other)
        return 0

    def __bool__(self):
        """Return True if self is nonzero; otherwise return False.

        NaNs and infinities are considered nonzero.
        """
        return self._is_special or self._int != '0'

    def _cmp(self, other):
        """Compare the two non-NaN decimal instances self and other.

        Returns -1 if self < other, 0 if self == other and 1
        if self > other.  This routine is for internal use only."""

        if self._is_special or other._is_special:
            self_inf = self._isinfinity()
            other_inf = other._isinfinity()
            if self_inf == other_inf:
                return 0
            elif self_inf < other_inf:
                return -1
            else:
                return 1

        # check for zeros;  Decimal('0') == Decimal('-0')
        if not self:
            if not other:
                return 0
            else:
                return -((-1)**other._sign)
        if not other:
            return (-1)**self._sign

        # If different signs, neg one is less
        if other._sign < self._sign:
            return -1
        if self._sign < other._sign:
            return 1

        self_adjusted = self.adjusted()
        other_adjusted = other.adjusted()
        if self_adjusted == other_adjusted:
            self_padded = self._int + '0'*(self._exp - other._exp)
            other_padded = other._int + '0'*(other._exp - self._exp)
            if self_padded == other_padded:
                return 0
            elif self_padded < other_padded:
                return -(-1)**self._sign
            else:
                return (-1)**self._sign
        elif self_adjusted > other_adjusted:
            return (-1)**self._sign
        else: # self_adjusted < other_adjusted
            return -((-1)**self._sign)

    # Note: The Decimal standard doesn't cover rich comparisons for
    # Decimals.  In particular, the specification is silent on the
    # subject of what should happen for a comparison involving a NaN.
    # We take the following approach:
    #
    #   == comparisons involving a quiet NaN always return False
    #   != comparisons involving a quiet NaN always return True
    #   == or != comparisons involving a signaling NaN signal
    #      InvalidOperation, and return False or True as above if the
    #      InvalidOperation is not trapped.
    #   <, >, <= and >= comparisons involving a (quiet or signaling)
    #      NaN signal InvalidOperation, and return False if the
    #      InvalidOperation is not trapped.
    #
    # This behavior is designed to conform as closely as possible to
    # that specified by IEEE 754.

    def __eq__(self, other, context=None):
        self, other = _convert_for_comparison(self, other, equality_op=True)
        if other is NotImplemented:
            return other
        if self._check_nans(other, context):
            return False
        return self._cmp(other) == 0

    def __ne__(self, other, context=None):
        self, other = _convert_for_comparison(self, other, equality_op=True)
        if other is NotImplemented:
            return other
        if self._check_nans(other, context):
            return True
        return self._cmp(other) != 0


    def __lt__(self, other, context=None):
        self, other = _convert_for_comparison(self, other)
        if other is NotImplemented:
            return other
        ans = self._compare_check_nans(other, context)
        if ans:
            return False
        return self._cmp(other) < 0

    def __le__(self, other, context=None):
        self, other = _convert_for_comparison(self, other)
        if other is NotImplemented:
            return other
        ans = self._compare_check_nans(other, context)
        if ans:
            return False
        return self._cmp(other) <= 0

    def __gt__(self, other, context=None):
        self, other = _convert_for_comparison(self, other)
        if other is NotImplemented:
            return other
        ans = self._compare_check_nans(other, context)
        if ans:
            return False
        return self._cmp(other) > 0

    def __ge__(self, other, context=None):
        self, other = _convert_for_comparison(self, other)
        if other is NotImplemented:
            return other
        ans = self._compare_check_nans(other, context)
        if ans:
            return False
        return self._cmp(other) >= 0

    def compare(self, other, context=None):
        """Compares one to another.

        -1 => a < b
        0  => a = b
        1  => a > b
        NaN => one is NaN
        Like __cmp__, but returns Decimal instances.
        """
        other = _convert_other(other, raiseit=True)

        # Compare(NaN, NaN) = NaN
        if (self._is_special or other and other._is_special):
            ans = self._check_nans(other, context)
            if ans:
                return ans

        return Decimal(self._cmp(other))

    def __hash__(self):
        """x.__hash__() <==> hash(x)"""

        # In order to make sure that the hash of a Decimal instance
        # agrees with the hash of a numerically equal integer, float
        # or Fraction, we follow the rules for numeric hashes outlined
        # in the documentation.  (See library docs, 'Built-in Types').
        if self._is_special:
            if self.is_snan():
                raise TypeError('Cannot hash a signaling NaN value.')
            elif self.is_nan():
                return _PyHASH_NAN
            else:
                if self._sign:
                    return -_PyHASH_INF
                else:
                    return _PyHASH_INF

        if self._exp >= 0:
            exp_hash = pow(10, self._exp, _PyHASH_MODULUS)
        else:
            exp_hash = pow(_PyHASH_10INV, -self._exp, _PyHASH_MODULUS)
        hash_ = int(self._int) * exp_hash % _PyHASH_MODULUS
        ans = hash_ if self >= 0 else -hash_
        return -2 if ans == -1 else ans

    def as_tuple(self):
        """Represents the number as a triple tuple.

        To show the internals exactly as they are.
        """
        return DecimalTuple(self._sign, tuple(map(int, self._int)), self._exp)

    def __repr__(self):
        """Represents the number as an instance of Decimal."""
        # Invariant:  eval(repr(d)) == d
        return "Decimal('%s')" % str(self)

    def __str__(self, eng=False, context=None):
        """Return string representation of the number in scientific notation.

        Captures all of the information in the underlying representation.
        """

        sign = ['', '-'][self._sign]
        if self._is_special:
            if self._exp == 'F':
                return sign + 'Infinity'
            elif self._exp == 'n':
                return sign + 'NaN' + self._int
            else: # self._exp == 'N'
                return sign + 'sNaN' + self._int

        # number of digits of self._int to left of decimal point
        leftdigits = self._exp + len(self._int)

        # dotplace is number of digits of self._int to the left of the
        # decimal point in the mantissa of the output string (that is,
        # after adjusting the exponent)
        if self._exp <= 0 and leftdigits > -6:
            # no exponent required
            dotplace = leftdigits
        elif not eng:
            # usual scientific notation: 1 digit on left of the point
            dotplace = 1
        elif self._int == '0':
            # engineering notation, zero
            dotplace = (leftdigits + 1) % 3 - 1
        else:
            # engineering notation, nonzero
            dotplace = (leftdigits - 1) % 3 + 1

        if dotplace <= 0:
            intpart = '0'
            fracpart = '.' + '0'*(-dotplace) + self._int
        elif dotplace >= len(self._int):
            intpart = self._int+'0'*(dotplace-len(self._int))
            fracpart = ''
        else:
            intpart = self._int[:dotplace]
            fracpart = '.' + self._int[dotplace:]
        if leftdigits == dotplace:
            exp = ''
        else:
            if context is None:
                context = getcontext()
            exp = ['e', 'E'][context.capitals] + "%+d" % (leftdigits-dotplace)

        return sign + intpart + fracpart + exp

    def to_eng_string(self, context=None):
        """Convert to engineering-type string.

        Engineering notation has an exponent which is a multiple of 3, so there
        are up to 3 digits left of the decimal place.

        Same rules for when in exponential and when as a value as in __str__.
        """
        return self.__str__(eng=True, context=context)

    def __neg__(self, context=None):
        """Returns a copy with the sign switched.

        Rounds, if it has reason.
        """
        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans

        if context is None:
            context = getcontext()

        if not self and context.rounding != ROUND_FLOOR:
            # -Decimal('0') is Decimal('0'), not Decimal('-0'), except
            # in ROUND_FLOOR rounding mode.
            ans = self.copy_abs()
        else:
            ans = self.copy_negate()

        return ans._fix(context)

    def __pos__(self, context=None):
        """Returns a copy, unless it is a sNaN.

        Rounds the number (if more then precision digits)
        """
        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans

        if context is None:
            context = getcontext()

        if not self and context.rounding != ROUND_FLOOR:
            # + (-0) = 0, except in ROUND_FLOOR rounding mode.
            ans = self.copy_abs()
        else:
            ans = Decimal(self)

        return ans._fix(context)

    def __abs__(self, round=True, context=None):
        """Returns the absolute value of self.

        If the keyword argument 'round' is false, do not round.  The
        expression self.__abs__(round=False) is equivalent to
        self.copy_abs().
        """
        if not round:
            return self.copy_abs()

        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans

        if self._sign:
            ans = self.__neg__(context=context)
        else:
            ans = self.__pos__(context=context)

        return ans

    def __add__(self, other, context=None):
        """Returns self + other.

        -INF + INF (or the reverse) cause InvalidOperation errors.
        """
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if context is None:
            context = getcontext()

        if self._is_special or other._is_special:
            ans = self._check_nans(other, context)
            if ans:
                return ans

            if self._isinfinity():
                # If both INF, same sign => same as both, opposite => error.
                if self._sign != other._sign and other._isinfinity():
                    return context._raise_error(InvalidOperation, '-INF + INF')
                return Decimal(self)
            if other._isinfinity():
                return Decimal(other)  # Can't both be infinity here

        exp = min(self._exp, other._exp)
        negativezero = 0
        if context.rounding == ROUND_FLOOR and self._sign != other._sign:
            # If the answer is 0, the sign should be negative, in this case.
            negativezero = 1

        if not self and not other:
            sign = min(self._sign, other._sign)
            if negativezero:
                sign = 1
            ans = _dec_from_triple(sign, '0', exp)
            ans = ans._fix(context)
            return ans
        if not self:
            exp = max(exp, other._exp - context.prec-1)
            ans = other._rescale(exp, context.rounding)
            ans = ans._fix(context)
            return ans
        if not other:
            exp = max(exp, self._exp - context.prec-1)
            ans = self._rescale(exp, context.rounding)
            ans = ans._fix(context)
            return ans

        op1 = _WorkRep(self)
        op2 = _WorkRep(other)
        op1, op2 = _normalize(op1, op2, context.prec)

        result = _WorkRep()
        if op1.sign != op2.sign:
            # Equal and opposite
            if op1.int == op2.int:
                ans = _dec_from_triple(negativezero, '0', exp)
                ans = ans._fix(context)
                return ans
            if op1.int < op2.int:
                op1, op2 = op2, op1
                # OK, now abs(op1) > abs(op2)
            if op1.sign == 1:
                result.sign = 1
                op1.sign, op2.sign = op2.sign, op1.sign
            else:
                result.sign = 0
                # So we know the sign, and op1 > 0.
        elif op1.sign == 1:
            result.sign = 1
            op1.sign, op2.sign = (0, 0)
        else:
            result.sign = 0
        # Now, op1 > abs(op2) > 0

        if op2.sign == 0:
            result.int = op1.int + op2.int
        else:
            result.int = op1.int - op2.int

        result.exp = op1.exp
        ans = Decimal(result)
        ans = ans._fix(context)
        return ans

    __radd__ = __add__

    def __sub__(self, other, context=None):
        """Return self - other"""
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if self._is_special or other._is_special:
            ans = self._check_nans(other, context=context)
            if ans:
                return ans

        # self - other is computed as self + other.copy_negate()
        return self.__add__(other.copy_negate(), context=context)

    def __rsub__(self, other, context=None):
        """Return other - self"""
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        return other.__sub__(self, context=context)

    def __mul__(self, other, context=None):
        """Return self * other.

        (+-) INF * 0 (or its reverse) raise InvalidOperation.
        """
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if context is None:
            context = getcontext()

        resultsign = self._sign ^ other._sign

        if self._is_special or other._is_special:
            ans = self._check_nans(other, context)
            if ans:
                return ans

            if self._isinfinity():
                if not other:
                    return context._raise_error(InvalidOperation, '(+-)INF * 0')
                return _SignedInfinity[resultsign]

            if other._isinfinity():
                if not self:
                    return context._raise_error(InvalidOperation, '0 * (+-)INF')
                return _SignedInfinity[resultsign]

        resultexp = self._exp + other._exp

        # Special case for multiplying by zero
        if not self or not other:
            ans = _dec_from_triple(resultsign, '0', resultexp)
            # Fixing in case the exponent is out of bounds
            ans = ans._fix(context)
            return ans

        # Special case for multiplying by power of 10
        if self._int == '1':
            ans = _dec_from_triple(resultsign, other._int, resultexp)
            ans = ans._fix(context)
            return ans
        if other._int == '1':
            ans = _dec_from_triple(resultsign, self._int, resultexp)
            ans = ans._fix(context)
            return ans

        op1 = _WorkRep(self)
        op2 = _WorkRep(other)

        ans = _dec_from_triple(resultsign, str(op1.int * op2.int), resultexp)
        ans = ans._fix(context)

        return ans
    __rmul__ = __mul__

    def __truediv__(self, other, context=None):
        """Return self / other."""
        other = _convert_other(other)
        if other is NotImplemented:
            return NotImplemented

        if context is None:
            context = getcontext()

        sign = self._sign ^ other._sign

        if self._is_special or other._is_special:
            ans = self._check_nans(other, context)
            if ans:
                return ans

            if self._isinfinity() and other._isinfinity():
                return context._raise_error(InvalidOperation, '(+-)INF/(+-)INF')

            if self._isinfinity():
                return _SignedInfinity[sign]

            if other._isinfinity():
                context._raise_error(Clamped, 'Division by infinity')
                return _dec_from_triple(sign, '0', context.Etiny())

        # Special cases for zeroes
        if not other:
            if not self:
                return context._raise_error(DivisionUndefined, '0 / 0')
            return context._raise_error(DivisionByZero, 'x / 0', sign)

        if not self:
            exp = self._exp - other._exp
            coeff = 0
        else:
            # OK, so neither = 0, INF or NaN
            shift = len(other._int) - len(self._int) + context.prec + 1
            exp = self._exp - other._exp - shift
            op1 = _WorkRep(self)
            op2 = _WorkRep(other)
            if shift >= 0:
                coeff, remainder = divmod(op1.int * 10**shift, op2.int)
            else:
                coeff, remainder = divmod(op1.int, op2.int * 10**-shift)
            if remainder:
                # result is not exact; adjust to ensure correct rounding
                if coeff % 5 == 0:
                    coeff += 1
            else:
                # result is exact; get as close to ideal exponent as possible
                ideal_exp = self._exp - other._exp
                while exp < ideal_exp and coeff % 10 == 0:
                    coeff //= 10
                    exp += 1

        ans = _dec_from_triple(sign, str(coeff), exp)
        return ans._fix(context)

    def _divide(self, other, context):
        """Return (self // other, self % other), to context.prec precision.

        Assumes that neither self nor other is a NaN, that self is not
        infinite and that other is nonzero.
        """
        sign = self._sign ^ other._sign
        if other._isinfinity():
            ideal_exp = self._exp
        else:
            ideal_exp = min(self._exp, other._exp)

        expdiff = self.adjusted() - other.adjusted()
        if not self or other._isinfinity() or expdiff <= -2:
            return (_dec_from_triple(sign, '0', 0),
                    self._rescale(ideal_exp, context.rounding))
        if expdiff <= context.prec:
            op1 = _WorkRep(self)
            op2 = _WorkRep(other)
            if op1.exp >= op2.exp:
                op1.int *= 10**(op1.exp - op2.exp)
            else:
                op2.int *= 10**(op2.exp - op1.exp)
            q, r = divmod(op1.int, op2.int)
            if q < 10**context.prec:
                return (_dec_from_triple(sign, str(q), 0),
                        _dec_from_triple(self._sign, str(r), ideal_exp))

        # Here the quotient is too large to be representable
        ans = context._raise_error(DivisionImpossible,
                                   'quotient too large in //, % or divmod')
        return ans, ans

    def __rtruediv__(self, other, context=None):
        """Swaps self/other and returns __truediv__."""
        other = _convert_other(other)
        if other is NotImplemented:
            return other
        return other.__truediv__(self, context=context)

    def __divmod__(self, other, context=None):
        """
        Return (self // other, self % other)
        """
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if context is None:
            context = getcontext()

        ans = self._check_nans(other, context)
        if ans:
            return (ans, ans)

        sign = self._sign ^ other._sign
        if self._isinfinity():
            if other._isinfinity():
                ans = context._raise_error(InvalidOperation, 'divmod(INF, INF)')
                return ans, ans
            else:
                return (_SignedInfinity[sign],
                        context._raise_error(InvalidOperation, 'INF % x'))

        if not other:
            if not self:
                ans = context._raise_error(DivisionUndefined, 'divmod(0, 0)')
                return ans, ans
            else:
                return (context._raise_error(DivisionByZero, 'x // 0', sign),
                        context._raise_error(InvalidOperation, 'x % 0'))

        quotient, remainder = self._divide(other, context)
        remainder = remainder._fix(context)
        return quotient, remainder

    def __rdivmod__(self, other, context=None):
        """Swaps self/other and returns __divmod__."""
        other = _convert_other(other)
        if other is NotImplemented:
            return other
        return other.__divmod__(self, context=context)

    def __mod__(self, other, context=None):
        """
        self % other
        """
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if context is None:
            context = getcontext()

        ans = self._check_nans(other, context)
        if ans:
            return ans

        if self._isinfinity():
            return context._raise_error(InvalidOperation, 'INF % x')
        elif not other:
            if self:
                return context._raise_error(InvalidOperation, 'x % 0')
            else:
                return context._raise_error(DivisionUndefined, '0 % 0')

        remainder = self._divide(other, context)[1]
        remainder = remainder._fix(context)
        return remainder

    def __rmod__(self, other, context=None):
        """Swaps self/other and returns __mod__."""
        other = _convert_other(other)
        if other is NotImplemented:
            return other
        return other.__mod__(self, context=context)

    def remainder_near(self, other, context=None):
        """
        Remainder nearest to 0-  abs(remainder-near) <= other/2
        """
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        ans = self._check_nans(other, context)
        if ans:
            return ans

        # self == +/-infinity -> InvalidOperation
        if self._isinfinity():
            return context._raise_error(InvalidOperation,
                                        'remainder_near(infinity, x)')

        # other == 0 -> either InvalidOperation or DivisionUndefined
        if not other:
            if self:
                return context._raise_error(InvalidOperation,
                                            'remainder_near(x, 0)')
            else:
                return context._raise_error(DivisionUndefined,
                                            'remainder_near(0, 0)')

        # other = +/-infinity -> remainder = self
        if other._isinfinity():
            ans = Decimal(self)
            return ans._fix(context)

        # self = 0 -> remainder = self, with ideal exponent
        ideal_exponent = min(self._exp, other._exp)
        if not self:
            ans = _dec_from_triple(self._sign, '0', ideal_exponent)
            return ans._fix(context)

        # catch most cases of large or small quotient
        expdiff = self.adjusted() - other.adjusted()
        if expdiff >= context.prec + 1:
            # expdiff >= prec+1 => abs(self/other) > 10**prec
            return context._raise_error(DivisionImpossible)
        if expdiff <= -2:
            # expdiff <= -2 => abs(self/other) < 0.1
            ans = self._rescale(ideal_exponent, context.rounding)
            return ans._fix(context)

        # adjust both arguments to have the same exponent, then divide
        op1 = _WorkRep(self)
        op2 = _WorkRep(other)
        if op1.exp >= op2.exp:
            op1.int *= 10**(op1.exp - op2.exp)
        else:
            op2.int *= 10**(op2.exp - op1.exp)
        q, r = divmod(op1.int, op2.int)
        # remainder is r*10**ideal_exponent; other is +/-op2.int *
        # 10**ideal_exponent.   Apply correction to ensure that
        # abs(remainder) <= abs(other)/2
        if 2*r + (q&1) > op2.int:
            r -= op2.int
            q += 1

        if q >= 10**context.prec:
            return context._raise_error(DivisionImpossible)

        # result has same sign as self unless r is negative
        sign = self._sign
        if r < 0:
            sign = 1-sign
            r = -r

        ans = _dec_from_triple(sign, str(r), ideal_exponent)
        return ans._fix(context)

    def __floordiv__(self, other, context=None):
        """self // other"""
        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if context is None:
            context = getcontext()

        ans = self._check_nans(other, context)
        if ans:
            return ans

        if self._isinfinity():
            if other._isinfinity():
                return context._raise_error(InvalidOperation, 'INF // INF')
            else:
                return _SignedInfinity[self._sign ^ other._sign]

        if not other:
            if self:
                return context._raise_error(DivisionByZero, 'x // 0',
                                            self._sign ^ other._sign)
            else:
                return context._raise_error(DivisionUndefined, '0 // 0')

        return self._divide(other, context)[0]

    def __rfloordiv__(self, other, context=None):
        """Swaps self/other and returns __floordiv__."""
        other = _convert_other(other)
        if other is NotImplemented:
            return other
        return other.__floordiv__(self, context=context)

    def __float__(self):
        """Float representation."""
        if self._isnan():
            if self.is_snan():
                raise ValueError("Cannot convert signaling NaN to float")
            s = "-nan" if self._sign else "nan"
        else:
            s = str(self)
        return float(s)

    def __int__(self):
        """Converts self to an int, truncating if necessary."""
        if self._is_special:
            if self._isnan():
                raise ValueError("Cannot convert NaN to integer")
            elif self._isinfinity():
                raise OverflowError("Cannot convert infinity to integer")
        s = (-1)**self._sign
        if self._exp >= 0:
            return s*int(self._int)*10**self._exp
        else:
            return s*int(self._int[:self._exp] or '0')

    __trunc__ = __int__

    def real(self):
        return self
    real = property(real)

    def imag(self):
        return Decimal(0)
    imag = property(imag)

    def conjugate(self):
        return self

    def __complex__(self):
        return complex(float(self))

    def _fix_nan(self, context):
        """Decapitate the payload of a NaN to fit the context"""
        payload = self._int

        # maximum length of payload is precision if clamp=0,
        # precision-1 if clamp=1.
        max_payload_len = context.prec - context.clamp
        if len(payload) > max_payload_len:
            payload = payload[len(payload)-max_payload_len:].lstrip('0')
            return _dec_from_triple(self._sign, payload, self._exp, True)
        return Decimal(self)

    def _fix(self, context):
        """Round if it is necessary to keep self within prec precision.

        Rounds and fixes the exponent.  Does not raise on a sNaN.

        Arguments:
        self - Decimal instance
        context - context used.
        """

        if self._is_special:
            if self._isnan():
                # decapitate payload if necessary
                return self._fix_nan(context)
            else:
                # self is +/-Infinity; return unaltered
                return Decimal(self)

        # if self is zero then exponent should be between Etiny and
        # Emax if clamp==0, and between Etiny and Etop if clamp==1.
        Etiny = context.Etiny()
        Etop = context.Etop()
        if not self:
            exp_max = [context.Emax, Etop][context.clamp]
            new_exp = min(max(self._exp, Etiny), exp_max)
            if new_exp != self._exp:
                context._raise_error(Clamped)
                return _dec_from_triple(self._sign, '0', new_exp)
            else:
                return Decimal(self)

        # exp_min is the smallest allowable exponent of the result,
        # equal to max(self.adjusted()-context.prec+1, Etiny)
        exp_min = len(self._int) + self._exp - context.prec
        if exp_min > Etop:
            # overflow: exp_min > Etop iff self.adjusted() > Emax
            ans = context._raise_error(Overflow, 'above Emax', self._sign)
            context._raise_error(Inexact)
            context._raise_error(Rounded)
            return ans

        self_is_subnormal = exp_min < Etiny
        if self_is_subnormal:
            exp_min = Etiny

        # round if self has too many digits
        if self._exp < exp_min:
            digits = len(self._int) + self._exp - exp_min
            if digits < 0:
                self = _dec_from_triple(self._sign, '1', exp_min-1)
                digits = 0
            rounding_method = self._pick_rounding_function[context.rounding]
            changed = rounding_method(self, digits)
            coeff = self._int[:digits] or '0'
            if changed > 0:
                coeff = str(int(coeff)+1)
                if len(coeff) > context.prec:
                    coeff = coeff[:-1]
                    exp_min += 1

            # check whether the rounding pushed the exponent out of range
            if exp_min > Etop:
                ans = context._raise_error(Overflow, 'above Emax', self._sign)
            else:
                ans = _dec_from_triple(self._sign, coeff, exp_min)

            # raise the appropriate signals, taking care to respect
            # the precedence described in the specification
            if changed and self_is_subnormal:
                context._raise_error(Underflow)
            if self_is_subnormal:
                context._raise_error(Subnormal)
            if changed:
                context._raise_error(Inexact)
            context._raise_error(Rounded)
            if not ans:
                # raise Clamped on underflow to 0
                context._raise_error(Clamped)
            return ans

        if self_is_subnormal:
            context._raise_error(Subnormal)

        # fold down if clamp == 1 and self has too few digits
        if context.clamp == 1 and self._exp > Etop:
            context._raise_error(Clamped)
            self_padded = self._int + '0'*(self._exp - Etop)
            return _dec_from_triple(self._sign, self_padded, Etop)

        # here self was representable to begin with; return unchanged
        return Decimal(self)

    # for each of the rounding functions below:
    #   self is a finite, nonzero Decimal
    #   prec is an integer satisfying 0 <= prec < len(self._int)
    #
    # each function returns either -1, 0, or 1, as follows:
    #   1 indicates that self should be rounded up (away from zero)
    #   0 indicates that self should be truncated, and that all the
    #     digits to be truncated are zeros (so the value is unchanged)
    #  -1 indicates that there are nonzero digits to be truncated

    def _round_down(self, prec):
        """Also known as round-towards-0, truncate."""
        if _all_zeros(self._int, prec):
            return 0
        else:
            return -1

    def _round_up(self, prec):
        """Rounds away from 0."""
        return -self._round_down(prec)

    def _round_half_up(self, prec):
        """Rounds 5 up (away from 0)"""
        if self._int[prec] in '56789':
            return 1
        elif _all_zeros(self._int, prec):
            return 0
        else:
            return -1

    def _round_half_down(self, prec):
        """Round 5 down"""
        if _exact_half(self._int, prec):
            return -1
        else:
            return self._round_half_up(prec)

    def _round_half_even(self, prec):
        """Round 5 to even, rest to nearest."""
        if _exact_half(self._int, prec) and \
                (prec == 0 or self._int[prec-1] in '02468'):
            return -1
        else:
            return self._round_half_up(prec)

    def _round_ceiling(self, prec):
        """Rounds up (not away from 0 if negative.)"""
        if self._sign:
            return self._round_down(prec)
        else:
            return -self._round_down(prec)

    def _round_floor(self, prec):
        """Rounds down (not towards 0 if negative)"""
        if not self._sign:
            return self._round_down(prec)
        else:
            return -self._round_down(prec)

    def _round_05up(self, prec):
        """Round down unless digit prec-1 is 0 or 5."""
        if prec and self._int[prec-1] not in '05':
            return self._round_down(prec)
        else:
            return -self._round_down(prec)

    _pick_rounding_function = dict(
        ROUND_DOWN = _round_down,
        ROUND_UP = _round_up,
        ROUND_HALF_UP = _round_half_up,
        ROUND_HALF_DOWN = _round_half_down,
        ROUND_HALF_EVEN = _round_half_even,
        ROUND_CEILING = _round_ceiling,
        ROUND_FLOOR = _round_floor,
        ROUND_05UP = _round_05up,
    )

    def __round__(self, n=None):
        """Round self to the nearest integer, or to a given precision.

        If only one argument is supplied, round a finite Decimal
        instance self to the nearest integer.  If self is infinite or
        a NaN then a Python exception is raised.  If self is finite
        and lies exactly halfway between two integers then it is
        rounded to the integer with even last digit.

        >>> round(Decimal('123.456'))
        123
        >>> round(Decimal('-456.789'))
        -457
        >>> round(Decimal('-3.0'))
        -3
        >>> round(Decimal('2.5'))
        2
        >>> round(Decimal('3.5'))
        4
        >>> round(Decimal('Inf'))
        Traceback (most recent call last):
          ...
        OverflowError: cannot round an infinity
        >>> round(Decimal('NaN'))
        Traceback (most recent call last):
          ...
        ValueError: cannot round a NaN

        If a second argument n is supplied, self is rounded to n
        decimal places using the rounding mode for the current
        context.

        For an integer n, round(self, -n) is exactly equivalent to
        self.quantize(Decimal('1En')).

        >>> round(Decimal('123.456'), 0)
        Decimal('123')
        >>> round(Decimal('123.456'), 2)
        Decimal('123.46')
        >>> round(Decimal('123.456'), -2)
        Decimal('1E+2')
        >>> round(Decimal('-Infinity'), 37)
        Decimal('NaN')
        >>> round(Decimal('sNaN123'), 0)
        Decimal('NaN123')

        """
        if n is not None:
            # two-argument form: use the equivalent quantize call
            if not isinstance(n, int):
                raise TypeError('Second argument to round should be integral')
            exp = _dec_from_triple(0, '1', -n)
            return self.quantize(exp)

        # one-argument form
        if self._is_special:
            if self.is_nan():
                raise ValueError("cannot round a NaN")
            else:
                raise OverflowError("cannot round an infinity")
        return int(self._rescale(0, ROUND_HALF_EVEN))

    def __floor__(self):
        """Return the floor of self, as an integer.

        For a finite Decimal instance self, return the greatest
        integer n such that n <= self.  If self is infinite or a NaN
        then a Python exception is raised.

        """
        if self._is_special:
            if self.is_nan():
                raise ValueError("cannot round a NaN")
            else:
                raise OverflowError("cannot round an infinity")
        return int(self._rescale(0, ROUND_FLOOR))

    def __ceil__(self):
        """Return the ceiling of self, as an integer.

        For a finite Decimal instance self, return the least integer n
        such that n >= self.  If self is infinite or a NaN then a
        Python exception is raised.

        """
        if self._is_special:
            if self.is_nan():
                raise ValueError("cannot round a NaN")
            else:
                raise OverflowError("cannot round an infinity")
        return int(self._rescale(0, ROUND_CEILING))

    def fma(self, other, third, context=None):
        """Fused multiply-add.

        Returns self*other+third with no rounding of the intermediate
        product self*other.

        self and other are multiplied together, with no rounding of
        the result.  The third operand is then added to the result,
        and a single final rounding is performed.
        """

        other = _convert_other(other, raiseit=True)
        third = _convert_other(third, raiseit=True)

        # compute product; raise InvalidOperation if either operand is
        # a signaling NaN or if the product is zero times infinity.
        if self._is_special or other._is_special:
            if context is None:
                context = getcontext()
            if self._exp == 'N':
                return context._raise_error(InvalidOperation, 'sNaN', self)
            if other._exp == 'N':
                return context._raise_error(InvalidOperation, 'sNaN', other)
            if self._exp == 'n':
                product = self
            elif other._exp == 'n':
                product = other
            elif self._exp == 'F':
                if not other:
                    return context._raise_error(InvalidOperation,
                                                'INF * 0 in fma')
                product = _SignedInfinity[self._sign ^ other._sign]
            elif other._exp == 'F':
                if not self:
                    return context._raise_error(InvalidOperation,
                                                '0 * INF in fma')
                product = _SignedInfinity[self._sign ^ other._sign]
        else:
            product = _dec_from_triple(self._sign ^ other._sign,
                                       str(int(self._int) * int(other._int)),
                                       self._exp + other._exp)

        return product.__add__(third, context)

    def _power_modulo(self, other, modulo, context=None):
        """Three argument version of __pow__"""

        other = _convert_other(other)
        if other is NotImplemented:
            return other
        modulo = _convert_other(modulo)
        if modulo is NotImplemented:
            return modulo

        if context is None:
            context = getcontext()

        # deal with NaNs: if there are any sNaNs then first one wins,
        # (i.e. behaviour for NaNs is identical to that of fma)
        self_is_nan = self._isnan()
        other_is_nan = other._isnan()
        modulo_is_nan = modulo._isnan()
        if self_is_nan or other_is_nan or modulo_is_nan:
            if self_is_nan == 2:
                return context._raise_error(InvalidOperation, 'sNaN',
                                        self)
            if other_is_nan == 2:
                return context._raise_error(InvalidOperation, 'sNaN',
                                        other)
            if modulo_is_nan == 2:
                return context._raise_error(InvalidOperation, 'sNaN',
                                        modulo)
            if self_is_nan:
                return self._fix_nan(context)
            if other_is_nan:
                return other._fix_nan(context)
            return modulo._fix_nan(context)

        # check inputs: we apply same restrictions as Python's pow()
        if not (self._isinteger() and
                other._isinteger() and
                modulo._isinteger()):
            return context._raise_error(InvalidOperation,
                                        'pow() 3rd argument not allowed '
                                        'unless all arguments are integers')
        if other < 0:
            return context._raise_error(InvalidOperation,
                                        'pow() 2nd argument cannot be '
                                        'negative when 3rd argument specified')
        if not modulo:
            return context._raise_error(InvalidOperation,
                                        'pow() 3rd argument cannot be 0')

        # additional restriction for decimal: the modulus must be less
        # than 10**prec in absolute value
        if modulo.adjusted() >= context.prec:
            return context._raise_error(InvalidOperation,
                                        'insufficient precision: pow() 3rd '
                                        'argument must not have more than '
                                        'precision digits')

        # define 0**0 == NaN, for consistency with two-argument pow
        # (even though it hurts!)
        if not other and not self:
            return context._raise_error(InvalidOperation,
                                        'at least one of pow() 1st argument '
                                        'and 2nd argument must be nonzero ;'
                                        '0**0 is not defined')

        # compute sign of result
        if other._iseven():
            sign = 0
        else:
            sign = self._sign

        # convert modulo to a Python integer, and self and other to
        # Decimal integers (i.e. force their exponents to be >= 0)
        modulo = abs(int(modulo))
        base = _WorkRep(self.to_integral_value())
        exponent = _WorkRep(other.to_integral_value())

        # compute result using integer pow()
        base = (base.int % modulo * pow(10, base.exp, modulo)) % modulo
        for i in range(exponent.exp):
            base = pow(base, 10, modulo)
        base = pow(base, exponent.int, modulo)

        return _dec_from_triple(sign, str(base), 0)

    def _power_exact(self, other, p):
        """Attempt to compute self**other exactly.

        Given Decimals self and other and an integer p, attempt to
        compute an exact result for the power self**other, with p
        digits of precision.  Return None if self**other is not
        exactly representable in p digits.

        Assumes that elimination of special cases has already been
        performed: self and other must both be nonspecial; self must
        be positive and not numerically equal to 1; other must be
        nonzero.  For efficiency, other._exp should not be too large,
        so that 10**abs(other._exp) is a feasible calculation."""

        # In the comments below, we write x for the value of self and y for the
        # value of other.  Write x = xc*10**xe and abs(y) = yc*10**ye, with xc
        # and yc positive integers not divisible by 10.

        # The main purpose of this method is to identify the *failure*
        # of x**y to be exactly representable with as little effort as
        # possible.  So we look for cheap and easy tests that
        # eliminate the possibility of x**y being exact.  Only if all
        # these tests are passed do we go on to actually compute x**y.

        # Here's the main idea.  Express y as a rational number m/n, with m and
        # n relatively prime and n>0.  Then for x**y to be exactly
        # representable (at *any* precision), xc must be the nth power of a
        # positive integer and xe must be divisible by n.  If y is negative
        # then additionally xc must be a power of either 2 or 5, hence a power
        # of 2**n or 5**n.
        #
        # There's a limit to how small |y| can be: if y=m/n as above
        # then:
        #
        #  (1) if xc != 1 then for the result to be representable we
        #      need xc**(1/n) >= 2, and hence also xc**|y| >= 2.  So
        #      if |y| <= 1/nbits(xc) then xc < 2**nbits(xc) <=
        #      2**(1/|y|), hence xc**|y| < 2 and the result is not
        #      representable.
        #
        #  (2) if xe != 0, |xe|*(1/n) >= 1, so |xe|*|y| >= 1.  Hence if
        #      |y| < 1/|xe| then the result is not representable.
        #
        # Note that since x is not equal to 1, at least one of (1) and
        # (2) must apply.  Now |y| < 1/nbits(xc) iff |yc|*nbits(xc) <
        # 10**-ye iff len(str(|yc|*nbits(xc)) <= -ye.
        #
        # There's also a limit to how large y can be, at least if it's
        # positive: the normalized result will have coefficient xc**y,
        # so if it's representable then xc**y < 10**p, and y <
        # p/log10(xc).  Hence if y*log10(xc) >= p then the result is
        # not exactly representable.

        # if len(str(abs(yc*xe)) <= -ye then abs(yc*xe) < 10**-ye,
        # so |y| < 1/xe and the result is not representable.
        # Similarly, len(str(abs(yc)*xc_bits)) <= -ye implies |y|
        # < 1/nbits(xc).

        x = _WorkRep(self)
        xc, xe = x.int, x.exp
        while xc % 10 == 0:
            xc //= 10
            xe += 1

        y = _WorkRep(other)
        yc, ye = y.int, y.exp
        while yc % 10 == 0:
            yc //= 10
            ye += 1

        # case where xc == 1: result is 10**(xe*y), with xe*y
        # required to be an integer
        if xc == 1:
            xe *= yc
            # result is now 10**(xe * 10**ye);  xe * 10**ye must be integral
            while xe % 10 == 0:
                xe //= 10
                ye += 1
            if ye < 0:
                return None
            exponent = xe * 10**ye
            if y.sign == 1:
                exponent = -exponent
            # if other is a nonnegative integer, use ideal exponent
            if other._isinteger() and other._sign == 0:
                ideal_exponent = self._exp*int(other)
                zeros = min(exponent-ideal_exponent, p-1)
            else:
                zeros = 0
            return _dec_from_triple(0, '1' + '0'*zeros, exponent-zeros)

        # case where y is negative: xc must be either a power
        # of 2 or a power of 5.
        if y.sign == 1:
            last_digit = xc % 10
            if last_digit in (2,4,6,8):
                # quick test for power of 2
                if xc & -xc != xc:
                    return None
                # now xc is a power of 2; e is its exponent
                e = _nbits(xc)-1

                # We now have:
                #
                #   x = 2**e * 10**xe, e > 0, and y < 0.
                #
                # The exact result is:
                #
                #   x**y = 5**(-e*y) * 10**(e*y + xe*y)
                #
                # provided that both e*y and xe*y are integers.  Note that if
                # 5**(-e*y) >= 10**p, then the result can't be expressed
                # exactly with p digits of precision.
                #
                # Using the above, we can guard against large values of ye.
                # 93/65 is an upper bound for log(10)/log(5), so if
                #
                #   ye >= len(str(93*p//65))
                #
                # then
                #
                #   -e*y >= -y >= 10**ye > 93*p/65 > p*log(10)/log(5),
                #
                # so 5**(-e*y) >= 10**p, and the coefficient of the result
                # can't be expressed in p digits.

                # emax >= largest e such that 5**e < 10**p.
                emax = p*93//65
                if ye >= len(str(emax)):
                    return None

                # Find -e*y and -xe*y; both must be integers
                e = _decimal_lshift_exact(e * yc, ye)
                xe = _decimal_lshift_exact(xe * yc, ye)
                if e is None or xe is None:
                    return None

                if e > emax:
                    return None
                xc = 5**e

            elif last_digit == 5:
                # e >= log_5(xc) if xc is a power of 5; we have
                # equality all the way up to xc=5**2658
                e = _nbits(xc)*28//65
                xc, remainder = divmod(5**e, xc)
                if remainder:
                    return None
                while xc % 5 == 0:
                    xc //= 5
                    e -= 1

                # Guard against large values of ye, using the same logic as in
                # the 'xc is a power of 2' branch.  10/3 is an upper bound for
                # log(10)/log(2).
                emax = p*10//3
                if ye >= len(str(emax)):
                    return None

                e = _decimal_lshift_exact(e * yc, ye)
                xe = _decimal_lshift_exact(xe * yc, ye)
                if e is None or xe is None:
                    return None

                if e > emax:
                    return None
                xc = 2**e
            else:
                return None

            if xc >= 10**p:
                return None
            xe = -e-xe
            return _dec_from_triple(0, str(xc), xe)

        # now y is positive; find m and n such that y = m/n
        if ye >= 0:
            m, n = yc*10**ye, 1
        else:
            if xe != 0 and len(str(abs(yc*xe))) <= -ye:
                return None
            xc_bits = _nbits(xc)
            if xc != 1 and len(str(abs(yc)*xc_bits)) <= -ye:
                return None
            m, n = yc, 10**(-ye)
            while m % 2 == n % 2 == 0:
                m //= 2
                n //= 2
            while m % 5 == n % 5 == 0:
                m //= 5
                n //= 5

        # compute nth root of xc*10**xe
        if n > 1:
            # if 1 < xc < 2**n then xc isn't an nth power
            if xc != 1 and xc_bits <= n:
                return None

            xe, rem = divmod(xe, n)
            if rem != 0:
                return None

            # compute nth root of xc using Newton's method
            a = 1 << -(-_nbits(xc)//n) # initial estimate
            while True:
                q, r = divmod(xc, a**(n-1))
                if a <= q:
                    break
                else:
                    a = (a*(n-1) + q)//n
            if not (a == q and r == 0):
                return None
            xc = a

        # now xc*10**xe is the nth root of the original xc*10**xe
        # compute mth power of xc*10**xe

        # if m > p*100//_log10_lb(xc) then m > p/log10(xc), hence xc**m >
        # 10**p and the result is not representable.
        if xc > 1 and m > p*100//_log10_lb(xc):
            return None
        xc = xc**m
        xe *= m
        if xc > 10**p:
            return None

        # by this point the result *is* exactly representable
        # adjust the exponent to get as close as possible to the ideal
        # exponent, if necessary
        str_xc = str(xc)
        if other._isinteger() and other._sign == 0:
            ideal_exponent = self._exp*int(other)
            zeros = min(xe-ideal_exponent, p-len(str_xc))
        else:
            zeros = 0
        return _dec_from_triple(0, str_xc+'0'*zeros, xe-zeros)

    def __pow__(self, other, modulo=None, context=None):
        """Return self ** other [ % modulo].

        With two arguments, compute self**other.

        With three arguments, compute (self**other) % modulo.  For the
        three argument form, the following restrictions on the
        arguments hold:

         - all three arguments must be integral
         - other must be nonnegative
         - either self or other (or both) must be nonzero
         - modulo must be nonzero and must have at most p digits,
           where p is the context precision.

        If any of these restrictions is violated the InvalidOperation
        flag is raised.

        The result of pow(self, other, modulo) is identical to the
        result that would be obtained by computing (self**other) %
        modulo with unbounded precision, but is computed more
        efficiently.  It is always exact.
        """

        if modulo is not None:
            return self._power_modulo(other, modulo, context)

        other = _convert_other(other)
        if other is NotImplemented:
            return other

        if context is None:
            context = getcontext()

        # either argument is a NaN => result is NaN
        ans = self._check_nans(other, context)
        if ans:
            return ans

        # 0**0 = NaN (!), x**0 = 1 for nonzero x (including +/-Infinity)
        if not other:
            if not self:
                return context._raise_error(InvalidOperation, '0 ** 0')
            else:
                return _One

        # result has sign 1 iff self._sign is 1 and other is an odd integer
        result_sign = 0
        if self._sign == 1:
            if other._isinteger():
                if not other._iseven():
                    result_sign = 1
            else:
                # -ve**noninteger = NaN
                # (-0)**noninteger = 0**noninteger
                if self:
                    return context._raise_error(InvalidOperation,
                        'x ** y with x negative and y not an integer')
            # negate self, without doing any unwanted rounding
            self = self.copy_negate()

        # 0**(+ve or Inf)= 0; 0**(-ve or -Inf) = Infinity
        if not self:
            if other._sign == 0:
                return _dec_from_triple(result_sign, '0', 0)
            else:
                return _SignedInfinity[result_sign]

        # Inf**(+ve or Inf) = Inf; Inf**(-ve or -Inf) = 0
        if self._isinfinity():
            if other._sign == 0:
                return _SignedInfinity[result_sign]
            else:
                return _dec_from_triple(result_sign, '0', 0)

        # 1**other = 1, but the choice of exponent and the flags
        # depend on the exponent of self, and on whether other is a
        # positive integer, a negative integer, or neither
        if self == _One:
            if other._isinteger():
                # exp = max(self._exp*max(int(other), 0),
                # 1-context.prec) but evaluating int(other) directly
                # is dangerous until we know other is small (other
                # could be 1e999999999)
                if other._sign == 1:
                    multiplier = 0
                elif other > context.prec:
                    multiplier = context.prec
                else:
                    multiplier = int(other)

                exp = self._exp * multiplier
                if exp < 1-context.prec:
                    exp = 1-context.prec
                    context._raise_error(Rounded)
            else:
                context._raise_error(Inexact)
                context._raise_error(Rounded)
                exp = 1-context.prec

            return _dec_from_triple(result_sign, '1'+'0'*-exp, exp)

        # compute adjusted exponent of self
        self_adj = self.adjusted()

        # self ** infinity is infinity if self > 1, 0 if self < 1
        # self ** -infinity is infinity if self < 1, 0 if self > 1
        if other._isinfinity():
            if (other._sign == 0) == (self_adj < 0):
                return _dec_from_triple(result_sign, '0', 0)
            else:
                return _SignedInfinity[result_sign]

        # from here on, the result always goes through the call
        # to _fix at the end of this function.
        ans = None
        exact = False

        # crude test to catch cases of extreme overflow/underflow.  If
        # log10(self)*other >= 10**bound and bound >= len(str(Emax))
        # then 10**bound >= 10**len(str(Emax)) >= Emax+1 and hence
        # self**other >= 10**(Emax+1), so overflow occurs.  The test
        # for underflow is similar.
        bound = self._log10_exp_bound() + other.adjusted()
        if (self_adj >= 0) == (other._sign == 0):
            # self > 1 and other +ve, or self < 1 and other -ve
            # possibility of overflow
            if bound >= len(str(context.Emax)):
                ans = _dec_from_triple(result_sign, '1', context.Emax+1)
        else:
            # self > 1 and other -ve, or self < 1 and other +ve
            # possibility of underflow to 0
            Etiny = context.Etiny()
            if bound >= len(str(-Etiny)):
                ans = _dec_from_triple(result_sign, '1', Etiny-1)

        # try for an exact result with precision +1
        if ans is None:
            ans = self._power_exact(other, context.prec + 1)
            if ans is not None:
                if result_sign == 1:
                    ans = _dec_from_triple(1, ans._int, ans._exp)
                exact = True

        # usual case: inexact result, x**y computed directly as exp(y*log(x))
        if ans is None:
            p = context.prec
            x = _WorkRep(self)
            xc, xe = x.int, x.exp
            y = _WorkRep(other)
            yc, ye = y.int, y.exp
            if y.sign == 1:
                yc = -yc

            # compute correctly rounded result:  start with precision +3,
            # then increase precision until result is unambiguously roundable
            extra = 3
            while True:
                coeff, exp = _dpower(xc, xe, yc, ye, p+extra)
                if coeff % (5*10**(len(str(coeff))-p-1)):
                    break
                extra += 3

            ans = _dec_from_triple(result_sign, str(coeff), exp)

        # unlike exp, ln and log10, the power function respects the
        # rounding mode; no need to switch to ROUND_HALF_EVEN here

        # There's a difficulty here when 'other' is not an integer and
        # the result is exact.  In this case, the specification
        # requires that the Inexact flag be raised (in spite of
        # exactness), but since the result is exact _fix won't do this
        # for us.  (Correspondingly, the Underflow signal should also
        # be raised for subnormal results.)  We can't directly raise
        # these signals either before or after calling _fix, since
        # that would violate the precedence for signals.  So we wrap
        # the ._fix call in a temporary context, and reraise
        # afterwards.
        if exact and not other._isinteger():
            # pad with zeros up to length context.prec+1 if necessary; this
            # ensures that the Rounded signal will be raised.
            if len(ans._int) <= context.prec:
                expdiff = context.prec + 1 - len(ans._int)
                ans = _dec_from_triple(ans._sign, ans._int+'0'*expdiff,
                                       ans._exp-expdiff)

            # create a copy of the current context, with cleared flags/traps
            newcontext = context.copy()
            newcontext.clear_flags()
            for exception in _signals:
                newcontext.traps[exception] = 0

            # round in the new context
            ans = ans._fix(newcontext)

            # raise Inexact, and if necessary, Underflow
            newcontext._raise_error(Inexact)
            if newcontext.flags[Subnormal]:
                newcontext._raise_error(Underflow)

            # propagate signals to the original context; _fix could
            # have raised any of Overflow, Underflow, Subnormal,
            # Inexact, Rounded, Clamped.  Overflow needs the correct
            # arguments.  Note that the order of the exceptions is
            # important here.
            if newcontext.flags[Overflow]:
                context._raise_error(Overflow, 'above Emax', ans._sign)
            for exception in Underflow, Subnormal, Inexact, Rounded, Clamped:
                if newcontext.flags[exception]:
                    context._raise_error(exception)

        else:
            ans = ans._fix(context)

        return ans

    def __rpow__(self, other, context=None):
        """Swaps self/other and returns __pow__."""
        other = _convert_other(other)
        if other is NotImplemented:
            return other
        return other.__pow__(self, context=context)

    def normalize(self, context=None):
        """Normalize- strip trailing 0s, change anything equal to 0 to 0e0"""

        if context is None:
            context = getcontext()

        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans

        dup = self._fix(context)
        if dup._isinfinity():
            return dup

        if not dup:
            return _dec_from_triple(dup._sign, '0', 0)
        exp_max = [context.Emax, context.Etop()][context.clamp]
        end = len(dup._int)
        exp = dup._exp
        while dup._int[end-1] == '0' and exp < exp_max:
            exp += 1
            end -= 1
        return _dec_from_triple(dup._sign, dup._int[:end], exp)

    def quantize(self, exp, rounding=None, context=None, watchexp=True):
        """Quantize self so its exponent is the same as that of exp.

        Similar to self._rescale(exp._exp) but with error checking.
        """
        exp = _convert_other(exp, raiseit=True)

        if context is None:
            context = getcontext()
        if rounding is None:
            rounding = context.rounding

        if self._is_special or exp._is_special:
            ans = self._check_nans(exp, context)
            if ans:
                return ans

            if exp._isinfinity() or self._isinfinity():
                if exp._isinfinity() and self._isinfinity():
                    return Decimal(self)  # if both are inf, it is OK
                return context._raise_error(InvalidOperation,
                                        'quantize with one INF')

        # if we're not watching exponents, do a simple rescale
        if not watchexp:
            ans = self._rescale(exp._exp, rounding)
            # raise Inexact and Rounded where appropriate
            if ans._exp > self._exp:
                context._raise_error(Rounded)
                if ans != self:
                    context._raise_error(Inexact)
            return ans

        # exp._exp should be between Etiny and Emax
        if not (context.Etiny() <= exp._exp <= context.Emax):
            return context._raise_error(InvalidOperation,
                   'target exponent out of bounds in quantize')

        if not self:
            ans = _dec_from_triple(self._sign, '0', exp._exp)
            return ans._fix(context)

        self_adjusted = self.adjusted()
        if self_adjusted > context.Emax:
            return context._raise_error(InvalidOperation,
                                        'exponent of quantize result too large for current context')
        if self_adjusted - exp._exp + 1 > context.prec:
            return context._raise_error(InvalidOperation,
                                        'quantize result has too many digits for current context')

        ans = self._rescale(exp._exp, rounding)
        if ans.adjusted() > context.Emax:
            return context._raise_error(InvalidOperation,
                                        'exponent of quantize result too large for current context')
        if len(ans._int) > context.prec:
            return context._raise_error(InvalidOperation,
                                        'quantize result has too many digits for current context')

        # raise appropriate flags
        if ans and ans.adjusted() < context.Emin:
            context._raise_error(Subnormal)
        if ans._exp > self._exp:
            if ans != self:
                context._raise_error(Inexact)
            context._raise_error(Rounded)

        # call to fix takes care of any necessary folddown, and
        # signals Clamped if necessary
        ans = ans._fix(context)
        return ans

    def same_quantum(self, other, context=None):
        """Return True if self and other have the same exponent; otherwise
        return False.

        If either operand is a special value, the following rules are used:
           * return True if both operands are infinities
           * return True if both operands are NaNs
           * otherwise, return False.
        """
        other = _convert_other(other, raiseit=True)
        if self._is_special or other._is_special:
            return (self.is_nan() and other.is_nan() or
                    self.is_infinite() and other.is_infinite())
        return self._exp == other._exp

    def _rescale(self, exp, rounding):
        """Rescale self so that the exponent is exp, either by padding with zeros
        or by truncating digits, using the given rounding mode.

        Specials are returned without change.  This operation is
        quiet: it raises no flags, and uses no information from the
        context.

        exp = exp to scale to (an integer)
        rounding = rounding mode
        """
        if self._is_special:
            return Decimal(self)
        if not self:
            return _dec_from_triple(self._sign, '0', exp)

        if self._exp >= exp:
            # pad answer with zeros if necessary
            return _dec_from_triple(self._sign,
                                        self._int + '0'*(self._exp - exp), exp)

        # too many digits; round and lose data.  If self.adjusted() <
        # exp-1, replace self by 10**(exp-1) before rounding
        digits = len(self._int) + self._exp - exp
        if digits < 0:
            self = _dec_from_triple(self._sign, '1', exp-1)
            digits = 0
        this_function = self._pick_rounding_function[rounding]
        changed = this_function(self, digits)
        coeff = self._int[:digits] or '0'
        if changed == 1:
            coeff = str(int(coeff)+1)
        return _dec_from_triple(self._sign, coeff, exp)

    def _round(self, places, rounding):
        """Round a nonzero, nonspecial Decimal to a fixed number of
        significant figures, using the given rounding mode.

        Infinities, NaNs and zeros are returned unaltered.

        This operation is quiet: it raises no flags, and uses no
        information from the context.

        """
        if places <= 0:
            raise ValueError("argument should be at least 1 in _round")
        if self._is_special or not self:
            return Decimal(self)
        ans = self._rescale(self.adjusted()+1-places, rounding)
        # it can happen that the rescale alters the adjusted exponent;
        # for example when rounding 99.97 to 3 significant figures.
        # When this happens we end up with an extra 0 at the end of
        # the number; a second rescale fixes this.
        if ans.adjusted() != self.adjusted():
            ans = ans._rescale(ans.adjusted()+1-places, rounding)
        return ans

    def to_integral_exact(self, rounding=None, context=None):
        """Rounds to a nearby integer.

        If no rounding mode is specified, take the rounding mode from
        the context.  This method raises the Rounded and Inexact flags
        when appropriate.

        See also: to_integral_value, which does exactly the same as
        this method except that it doesn't raise Inexact or Rounded.
        """
        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans
            return Decimal(self)
        if self._exp >= 0:
            return Decimal(self)
        if not self:
            return _dec_from_triple(self._sign, '0', 0)
        if context is None:
            context = getcontext()
        if rounding is None:
            rounding = context.rounding
        ans = self._rescale(0, rounding)
        if ans != self:
            context._raise_error(Inexact)
        context._raise_error(Rounded)
        return ans

    def to_integral_value(self, rounding=None, context=None):
        """Rounds to the nearest integer, without raising inexact, rounded."""
        if context is None:
            context = getcontext()
        if rounding is None:
            rounding = context.rounding
        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans
            return Decimal(self)
        if self._exp >= 0:
            return Decimal(self)
        else:
            return self._rescale(0, rounding)

    # the method name changed, but we provide also the old one, for compatibility
    to_integral = to_integral_value

    def sqrt(self, context=None):
        """Return the square root of self."""
        if context is None:
            context = getcontext()

        if self._is_special:
            ans = self._check_nans(context=context)
            if ans:
                return ans

            if self._isinfinity() and self._sign == 0:
                return Decimal(self)

        if not self:
            # exponent = self._exp // 2.  sqrt(-0) = -0
            ans = _dec_from_triple(self._sign, '0', self._exp // 2)
            return ans._fix(context)

        if self._sign == 1:
            return context._raise_error(InvalidOperation, 'sqrt(-x), x > 0')

        # At this point self represents a positive number.  Let p be
        # the desired precision and express self in the form c*100**e
        # with c a positive real number and e an integer, c and e
        # being chosen so that 100**(p-1) <= c < 100**p.  Then the
        # (exact) square root of self is sqrt(c)*10**e, and 10**(p-1)
        # <= sqrt(c) < 10**p, so the closest representable Decimal at
        # precision p is n*10**e where n = round_half_even(sqrt(c)),
        # the closest integer to sqrt(c) with the even integer chosen
        # in the case of a tie.
        #
        # To ensure correct rounding in all cases, we use the
        # following trick: we compute the square root to an extra
        # place (precision p+1 instead of precision p), rounding down.
        # Then, if the result is inexact and its last digit is 0 or 5,
        # we increase the last digit to 1 or 6 respectively; if it's
        # exact we leave the last digit alone.  Now the final round to
        # p places (or fewer in the case of underflow) will round
        # correctly and raise the appropriate flags.

        # use an extra digit of precision
        prec = context.prec+1

        # write argument in the form c*100**e where e = self._exp//2
        # is the 'ideal' exponent, to be used if the square root is
        # exactly representable.  l is the number of 'digits' of c in
        # base 100, so that 100**(l-1) <= c < 100**l.
        op = _WorkRep(self)
        e = op.exp >> 1
        if op.exp & 1:
            c = op.int * 10
            l = (len(self._int) >> 1) + 1
        else:
            c = op.int
            l = len(self._int)+1 >> 1

        # rescale so that c has exactly prec base 100 'digits'
        shift = prec-l
        if shift >= 0:
            c *= 100**shift
            exact = True
        else:
            c, remainder = divmod(c, 100**-shift)
            exact = not remainder
        e -= shift

        # find n = floor(sqrt(c)) using Newton's method
        n = 10**prec
        while True:
            q = c//n
            if n <= q:
                break
            else:
                n = n + q >> 1
        exact = exact and n*n == c

        if exact:
            # result is exact; rescale to use ideal exponent e
            if shift >= 0:
                # assert n % 10**shift == 0
                n //= 10**shift
            else:
                n *= 10**-shift
            e += shift
        else:
            # result is not exact; fix last digit as described above
            if n % 5 == 0:
                n += 1

        ans = _dec_from_triple(0, str(n), e)

        # round, and fit to current context
        context = context._shallow_copy()
        rounding = context._set_rounding(ROUND_HALF_EVEN)
        ans = ans._fix(context)
        context.rounding = rounding

        return ans

    def max(self, other, context=None):
        """Returns the larger value.

        Like max(self, other) except if one is not a number, returns
        NaN (and signals if one is sNaN).  Also rounds.
        """
        other = _convert_other(other, raiseit=True)

        if context is None:
            context = getcontext()

        if self._is_special or other._is_special:
            # If one operand is a quiet NaN and the other is number, then the
            # number is always returned
            sn = self._isnan()
            on = other._isnan()
            if sn or on:
                if on == 1 and sn == 0:
                    return self._fix(context)
                if sn == 1 and on == 0:
                    return other._fix(context)
                return self._check_nans(other, context)

        c = self._cmp(other)
        if c == 0:
            # If both operands are finite and equal in numerical value
            # then an ordering is applied:
            #
            # If the signs differ then max returns the operand with the
            # positive sign and min returns the operand with the negative sign
            #
            # If the signs are the same then the exponent is used to select
            # the result.  This is exactly the ordering used in compare_total.
            c = self.compare_total(other)

        if c == -1:
            ans = other
        else:
            ans = self

        return ans._fix(context)

    def min(self, other, context=None):
        """Returns the smaller value.

        Like min(self, other) except if one is not a number, returns
        NaN (and signals if one is sNaN).  Also rounds.
        """
        other = _convert_other(other, raiseit=True)

        if context is None:
            context = getcontext()

        if self._is_special or other._is_special:
            # If one operand is a quiet NaN and the other is number, then the
            # number is always returned
            sn = self._isnan()
            on = other._isnan()
            if sn or on:
                if on == 1 and sn == 0:
                    return self._fix(context)
                if sn == 1 and on == 0:
                    return other._fix(context)
                return self._check_nans(other, context)

        c = self._cmp(other)
        if c == 0:
            c = self.compare_total(other)

        if c == -1:
            ans = self
        else:
            ans = other

        return ans._fix(context)

    def _isinteger(self):
        """Returns whether self is an integer"""
        if self._is_special:
            return False
        if self._exp >= 0:
            return True
        rest = self._int[self._exp:]
        return rest == '0'*len(rest)

    def _iseven(self):
        """Returns True if self is even.  Assumes self is an integer."""
        if not self or self._exp > 0:
            return True
        return self._int[-1+self._exp] in '02468'

    def adjusted(self):
        """Return the adjusted exponent of self"""
        try:
            return self._exp + len(self._int) - 1
        # If NaN or Infinity, self._exp is string
        except TypeError:
            return 0

    def canonical(self):
        """Returns the same Decimal object.

        As we do not have different encodings for the same number, the
        received object already is in its canonical form.
        """
        return self

    def compare_signal(self, other, context=None):
        """Compares self to the other operand numerically.

        It's pretty much like compare(), but all NaNs signal, with signaling
        NaNs taking precedence over quiet NaNs.
        """
        other = _convert_other(other, raiseit = True)
        ans = self._compare_check_nans(other, context)
        if ans:
            return ans
        return self.compare(other, context=context)

    def compare_total(self, other, context=None):
        """Compares self to other using the abstract representations.

        This is not like the standard compare, which use their numerical
        value. Note that a total ordering is defined for all possible abstract
        representations.
        """
        other = _convert_other(other, raiseit=True)

        # if one is negative and the other is positive, it's easy
        if self._sign and not other._sign:
            return _NegativeOne
        if not self._sign and other._sign:
            return _One
        sign = self._sign

        # let's handle both NaN types
        self_nan = self._isnan()
        other_nan = other._isnan()
        if self_nan or other_nan:
            if self_nan == other_nan:
                # compare payloads as though they're integers
                self_key = len(self._int), self._int
                other_key = len(other._int), other._int
                if self_key < other_key:
                    if sign:
                        return _One
                    else:
                        return _NegativeOne
                if self_key > other_key:
                    if sign:
                        return _NegativeOne
                    else:
                        return _One
                return _Zero

            if sign:
                if self_nan == 1:
                    return _NegativeOne
                if other_nan == 1:
                    return _One
                if self_nan == 2:
                    return _NegativeOne
                if other_nan == 2:
                    return _One
            else:
                if self_nan == 1:
                    return _One
                if other_nan == 1:
                    return _NegativeOne
                if self_nan == 2:
                    return _One
                if other_nan == 2:
                    return _NegativeOne

        if self < other:
            return _NegativeOne
        if self > other:
            return _One

        if self._exp < other._exp:
            if sign:
                return _One
            else:
                return _NegativeOne
        if self._exp > other._exp:
            if sign:
                return _NegativeOne
            else:
                return _One
        return _Zero


    def compare_total_mag(self, other, context=None):
        """Compares self to other using abstract repr., ignoring sign.

        Like compare_total, but with operand's sign ignored and assumed to be 0.
        """
        other = _convert_other(other, raiseit=True)

        s = self.copy_abs()
        o = other.copy_abs()
        return s.compare_total(o)

    def copy_abs(self):
        """Returns a copy with the sign set to 0. """
        return _dec_from_triple(0, self._int, self._exp, self._is_special)

    def copy_negate(self):
        """Returns a copy with the sign inverted."""
        if self._sign:
            return _dec_from_triple(0, self._int, self._exp, self._is_special)
        else:
            return _dec_from_triple(1, self._int, self._exp, self._is_special)

    def copy_sign(self, other, context=None):
        """Returns self with the sign of other."""
        other = _convert_other(other, raiseit=True)
        return _dec_from_triple(other._sign, self._int,
                                self._exp, self._is_special)

    def exp(self, context=None):
        """Returns e ** self."""

        if context is None:
            context = getcontext()

        # exp(NaN) = NaN
        ans = self._check_nans(context=context)
        if ans:
            return ans

        # exp(-Infinity) = 0
        if self._isinfinity() == -1:
            return _Zero

        # exp(0) = 1
        if not self:
            return _One

        # exp(Infinity) = Infinity
        if self._isinfinity() == 1:
            return Decimal(self)

        # the result is now guaranteed to be inexact (the true
        # mathematical result is transcendental). There's no need to
        # raise Rounded and Inexact here---they'll always be raised as
        # a result of the call to _fix.
        p = context.prec
        adj = self.adjusted()

        # we only need to do any computation for quite a small range
        # of adjusted exponents---for example, -29 <= adj <= 10 for
        # the default context.  For smaller exponent the result is
        # indistinguishable from 1 at the given precision, while for
        # larger exponent the result either overflows or underflows.
        if self._sign == 0 and adj > len(str((context.Emax+1)*3)):
            # overflow
            ans = _dec_from_triple(0, '1', context.Emax+1)
        elif self._sign == 1 and adj > len(str((-context.Etiny()+1)*3)):
            # underflow to 0
            ans = _dec_from_triple(0, '1', context.Etiny()-1)
        elif self._sign == 0 and adj < -p:
            # p+1 digits; final round will raise correct flags
            ans = _dec_from_triple(0, '1' + '0'*(p-1) + '1', -p)
        elif self._sign == 1 and adj < -p-1:
            # p+1 digits; final round will raise correct flags
            ans = _dec_from_triple(0, '9'*(p+1), -p-1)
        # general case
        else:
            op = _WorkRep(self)
            c, e = op.int, op.exp
            if op.sign == 1:
                c = -c

            # compute correctly rounded result: increase precision by
            # 3 digits at a time until we get an unambiguously
            # roundable result
            extra = 3
            while True:
                coeff, exp = _dexp(c, e, p+extra)
                if coeff % (5*10**(len(str(coeff))-p-1)):
                    break
                extra += 3

            ans = _dec_from_triple(0, str(coeff), exp)

        # at this stage, ans should round correctly with *any*
        # rounding mode, not just with ROUND_HALF_EVEN
        context = context._shallow_copy()
        rounding = context._set_rounding(ROUND_HALF_EVEN)
        ans = ans._fix(context)
        context.rounding = rounding

        return ans

    def is_canonical(self):
        """Return True if self is canonical; otherwise return False.

        Currently, the encoding of a Decimal instance is always
        canonical, so this method returns True for any Decimal.
        """
        return True

    def is_finite(self):
        """Return True if self is finite; otherwise return False.

        A Decimal instance is considered finite if it is neither
        infinite nor a NaN.
        """
        return not self._is_special

    def is_infinite(self):
        """Return True if self is infinite; otherwise return False."""
        return self._exp == 'F'

    def is_nan(self):
        """Return True if self is a qNaN or sNaN; otherwise return False."""
        return self._exp in ('n', 'N')

    def is_normal(self, context=None):
        """Return True if self is a normal number; otherwise return False."""
        if self._is_special or not self:
            return False
        if context is None:
            context = getcontext()
        return context.Emin <= self.adjusted()

    def is_qnan(self):
        """Return True if self is a quiet NaN; otherwise return False."""
        return self._exp == 'n'

    def is_signed(self):
        """Return True if self is negative; otherwise return False."""
        return self._sign == 1

    def is_snan(self):
        """Return True if self is a signaling NaN; otherwise return False."""
        return self._exp == 'N'

    def is_subnormal(self, context=None):
        """Return True if self is subnormal; otherwise return False."""
        if self._is_special or not self:
            return False
        if context is None:
            context = getcontext()
        return self.adjusted() < context.Emin

    def is_zero(self):
        """Return True if self is a zero; otherwise return False."""
        return not self._is_special and self._int == '0'

    def _ln_exp_bound(self):
        """Compute a lower bound for the adjusted exponent of self.ln().
        In other words, compute r such that self.ln() >= 10**r.  Assumes
        that self is finite and positive and that self != 1.
        """

        # for 0.1 <= x <= 10 we use the inequalities 1-1/x <= ln(x) <= x-1
        adj = self._exp + len(self._int) - 1
        if adj >= 1:
            # argument >= 10; we use 23/10 = 2.3 as a lower bound for ln(10)
            return len(str(adj*23//10)) - 1
        if adj <= -2:
            # argument <= 0.1
            return len(str((-1-adj)*23//10)) - 1
        op = _WorkRep(self)
        c, e = op.int, op.exp
        if adj == 0:
            # 1 < self < 10
            num = str(c-10**-e)
            den = str(c)
            return len(num) - len(den) - (num < den)
        # adj == -1, 0.1 <= self < 1
        return e + len(str(10**-e - c)) - 1


    def ln(self, context=None):
        """Returns the natural (base e) logarithm of self."""

        if context is None:
            context = getcontext()

        # ln(NaN) = NaN
        ans = self._check_nans(context=context)
        if ans:
            return ans

        # ln(0.0) == -Infinity
        if not self:
            return _NegativeInfinity

        # ln(Infinity) = Infinity
        if self._isinfinity() == 1:
            return _Infinity

        # ln(1.0) == 0.0
        if self == _One:
            return _Zero

        # ln(negative) raises InvalidOperation
        if self._sign == 1:
            return context._raise_error(InvalidOperation,
                                        'ln of a negative value')

        # result is irrational, so necessarily inexact
        op = _WorkRep(self)
        c, e = op.int, op.exp
        p = context.prec

        # correctly rounded result: repeatedly increase precision by 3
        # until we get an unambiguously roundable result
        places = p - self._ln_exp_bound() + 2 # at least p+3 places
        while True:
            coeff = _dlog(c, e, places)
            # assert len(str(abs(coeff)))-p >= 1
            if coeff % (5*10**(len(str(abs(coeff)))-p-1)):
                break
            places += 3
        ans = _dec_from_triple(int(coeff<0), str(abs(coeff)), -places)

        context = context._shallow_copy()
        rounding = context._set_rounding(ROUND_HALF_EVEN)
        ans = ans._fix(context)
        context.rounding = rounding
        return ans

    def _log10_exp_bound(self):
        """Compute a lower bound for the adjusted exponent of self.log10().
        In other words, find r such that self.log10() >= 10**r.
        Assumes that self is finite and positive and that self != 1.
        """

        # For x >= 10 or x < 0.1 we only need a bound on the integer
        # part of log10(self), and this comes directly from the
        # exponent of x.  For 0.1 <= x <= 10 we use the inequalities
        # 1-1/x <= log(x) <= x-1. If x > 1 we have |log10(x)| >
        # (1-1/x)/2.31 > 0.  If x < 1 then |log10(x)| > (1-x)/2.31 > 0

        adj = self._exp + len(self._int) - 1
        if adj >= 1:
            # self >= 10
            return len(str(adj))-1
        if adj <= -2:
            # self < 0.1
            return len(str(-1-adj))-1
        op = _WorkRep(self)
        c, e = op.int, op.exp
        if adj == 0:
            # 1 < self < 10
            num = str(c-10**-e)
            den = str(231*c)
            return len(num) - len(den) - (num < den) + 2
        # adj == -1, 0.1 <= self < 1
        num = str(10**-e-c)
        return len(num) + e - (num < "231") - 1

    def log10(self, context=None):
        """Returns the base 10 logarithm of self."""

        if context is None:
            context = getcontext()

        # log10(NaN) = NaN
        ans = self._check_nans(context=context)
        if ans:
            return ans

        # log10(0.0) == -Infinity
        if not self:
            return _NegativeInfinity

        # log10(Infinity) = Infinity
        if self._isinfinity() == 1:
            return _Infinity

        # log10(negative or -Infinity) raises InvalidOperation
        if self._sign == 1:
            return context._raise_error(InvalidOperation,
                                        'log10 of a negative value')

        # log10(10**n) = n
        if self._int[0] == '1' and self._int[1:] == '0'*(len(self._int) - 1):
            # answer may need rounding
            ans = Decimal(self._exp + len(self._int) - 1)
        else:
            # result is irrational, so necessarily inexact
            op = _WorkRep(self)
            c, e = op.int, op.exp
            p = context.prec

            # correctly rounded result: repeatedly increase precision
            # until result is unambiguously roundable
            places = p-self._log10_exp_bound()+2
            while True:
                coeff = _dlog10(c, e, places)
                # assert len(str(abs(coeff)))-p >= 1
                if coeff % (5*10**(len(str(abs(coeff)))-p-1)):
                    break
                places += 3
            ans = _dec_from_triple(int(coeff<0), str(abs(coeff)), -places)

        context = context._shallow_copy()
        rounding = context._set_rounding(ROUND_HALF_EVEN)
        ans = ans._fix(context)
        context.rounding = rounding
        return ans

    def logb(self, context=None):
        """ Returns the exponent of the magnitude of self's MSD.

        The result is the integer which is the exponent of the magnitude
        of the most significant digit of self (as though it were truncated
        to a single digit while maintaining the value of that digit and
        without limiting the resulting exponent).
        """
        # logb(NaN) = NaN
        ans = self._check_nans(context=context)
        if ans:
            return ans

        if context is None:
            context = getcontext()

        # logb(+/-Inf) = +Inf
        if self._isinfinity():
            return _Infinity

        # logb(0) = -Inf, DivisionByZero
        if not self:
            return context._raise_error(DivisionByZero, 'logb(0)', 1)

        # otherwise, simply return the adjusted exponent of self, as a
        # Decimal.  Note that no attempt is made to fit the result
        # into the current context.
        ans = Decimal(self.adjusted())
        return ans._fix(context)

    def _islogical(self):
        """Return True if self is a logical operand.

        For being logical, it must be a finite number with a sign of 0,
        an exponent of 0, and a coefficient whose digits must all be
        either 0 or 1.
        """
        if self._sign != 0 or self._exp != 0:
            return False
        for dig in self._int:
            if dig not in '01':
                return False
        return True

    def _fill_logical(self, context, opa, opb):
        dif = context.prec - len(opa)
        if dif > 0:
            opa = '0'*dif + opa
        elif dif < 0:
            opa = opa[-context.prec:]
        dif = context.prec - len(opb)
        if dif > 0:
            opb = '0'*dif + opb
        elif dif < 0:
            opb = opb[-context.prec:]
        return opa, opb

    def logical_and(self, other, context=None):
        """Applies an 'and' operation between self and other's digits."""
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        if not self._islogical() or not other._islogical():
            return context._raise_error(InvalidOperation)

        # fill to context.prec
        (opa, opb) = self._fill_logical(context, self._int, other._int)

        # make the operation, and clean starting zeroes
        result = "".join([str(int(a)&int(b)) for a,b in zip(opa,opb)])
        return _dec_from_triple(0, result.lstrip('0') or '0', 0)

    def logical_invert(self, context=None):
        """Invert all its digits."""
        if context is None:
            context = getcontext()
        return self.logical_xor(_dec_from_triple(0,'1'*context.prec,0),
                                context)

    def logical_or(self, other, context=None):
        """Applies an 'or' operation between self and other's digits."""
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        if not self._islogical() or not other._islogical():
            return context._raise_error(InvalidOperation)

        # fill to context.prec
        (opa, opb) = self._fill_logical(context, self._int, other._int)

        # make the operation, and clean starting zeroes
        result = "".join([str(int(a)|int(b)) for a,b in zip(opa,opb)])
        return _dec_from_triple(0, result.lstrip('0') or '0', 0)

    def logical_xor(self, other, context=None):
        """Applies an 'xor' operation between self and other's digits."""
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        if not self._islogical() or not other._islogical():
            return context._raise_error(InvalidOperation)

        # fill to context.prec
        (opa, opb) = self._fill_logical(context, self._int, other._int)

        # make the operation, and clean starting zeroes
        result = "".join([str(int(a)^int(b)) for a,b in zip(opa,opb)])
        return _dec_from_triple(0, result.lstrip('0') or '0', 0)

    def max_mag(self, other, context=None):
        """Compares the values numerically with their sign ignored."""
        other = _convert_other(other, raiseit=True)

        if context is None:
            context = getcontext()

        if self._is_special or other._is_special:
            # If one operand is a quiet NaN and the other is number, then the
            # number is always returned
            sn = self._isnan()
            on = other._isnan()
            if sn or on:
                if on == 1 and sn == 0:
                    return self._fix(context)
                if sn == 1 and on == 0:
                    return other._fix(context)
                return self._check_nans(other, context)

        c = self.copy_abs()._cmp(other.copy_abs())
        if c == 0:
            c = self.compare_total(other)

        if c == -1:
            ans = other
        else:
            ans = self

        return ans._fix(context)

    def min_mag(self, other, context=None):
        """Compares the values numerically with their sign ignored."""
        other = _convert_other(other, raiseit=True)

        if context is None:
            context = getcontext()

        if self._is_special or other._is_special:
            # If one operand is a quiet NaN and the other is number, then the
            # number is always returned
            sn = self._isnan()
            on = other._isnan()
            if sn or on:
                if on == 1 and sn == 0:
                    return self._fix(context)
                if sn == 1 and on == 0:
                    return other._fix(context)
                return self._check_nans(other, context)

        c = self.copy_abs()._cmp(other.copy_abs())
        if c == 0:
            c = self.compare_total(other)

        if c == -1:
            ans = self
        else:
            ans = other

        return ans._fix(context)

    def next_minus(self, context=None):
        """Returns the largest representable number smaller than itself."""
        if context is None:
            context = getcontext()

        ans = self._check_nans(context=context)
        if ans:
            return ans

        if self._isinfinity() == -1:
            return _NegativeInfinity
        if self._isinfinity() == 1:
            return _dec_from_triple(0, '9'*context.prec, context.Etop())

        context = context.copy()
        context._set_rounding(ROUND_FLOOR)
        context._ignore_all_flags()
        new_self = self._fix(context)
        if new_self != self:
            return new_self
        return self.__sub__(_dec_from_triple(0, '1', context.Etiny()-1),
                            context)

    def next_plus(self, context=None):
        """Returns the smallest representable number larger than itself."""
        if context is None:
            context = getcontext()

        ans = self._check_nans(context=context)
        if ans:
            return ans

        if self._isinfinity() == 1:
            return _Infinity
        if self._isinfinity() == -1:
            return _dec_from_triple(1, '9'*context.prec, context.Etop())

        context = context.copy()
        context._set_rounding(ROUND_CEILING)
        context._ignore_all_flags()
        new_self = self._fix(context)
        if new_self != self:
            return new_self
        return self.__add__(_dec_from_triple(0, '1', context.Etiny()-1),
                            context)

    def next_toward(self, other, context=None):
        """Returns the number closest to self, in the direction towards other.

        The result is the closest representable number to self
        (excluding self) that is in the direction towards other,
        unless both have the same value.  If the two operands are
        numerically equal, then the result is a copy of self with the
        sign set to be the same as the sign of other.
        """
        other = _convert_other(other, raiseit=True)

        if context is None:
            context = getcontext()

        ans = self._check_nans(other, context)
        if ans:
            return ans

        comparison = self._cmp(other)
        if comparison == 0:
            return self.copy_sign(other)

        if comparison == -1:
            ans = self.next_plus(context)
        else: # comparison == 1
            ans = self.next_minus(context)

        # decide which flags to raise using value of ans
        if ans._isinfinity():
            context._raise_error(Overflow,
                                 'Infinite result from next_toward',
                                 ans._sign)
            context._raise_error(Inexact)
            context._raise_error(Rounded)
        elif ans.adjusted() < context.Emin:
            context._raise_error(Underflow)
            context._raise_error(Subnormal)
            context._raise_error(Inexact)
            context._raise_error(Rounded)
            # if precision == 1 then we don't raise Clamped for a
            # result 0E-Etiny.
            if not ans:
                context._raise_error(Clamped)

        return ans

    def number_class(self, context=None):
        """Returns an indication of the class of self.

        The class is one of the following strings:
          sNaN
          NaN
          -Infinity
          -Normal
          -Subnormal
          -Zero
          +Zero
          +Subnormal
          +Normal
          +Infinity
        """
        if self.is_snan():
            return "sNaN"
        if self.is_qnan():
            return "NaN"
        inf = self._isinfinity()
        if inf == 1:
            return "+Infinity"
        if inf == -1:
            return "-Infinity"
        if self.is_zero():
            if self._sign:
                return "-Zero"
            else:
                return "+Zero"
        if context is None:
            context = getcontext()
        if self.is_subnormal(context=context):
            if self._sign:
                return "-Subnormal"
            else:
                return "+Subnormal"
        # just a normal, regular, boring number, :)
        if self._sign:
            return "-Normal"
        else:
            return "+Normal"

    def radix(self):
        """Just returns 10, as this is Decimal, :)"""
        return Decimal(10)

    def rotate(self, other, context=None):
        """Returns a rotated copy of self, value-of-other times."""
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        ans = self._check_nans(other, context)
        if ans:
            return ans

        if other._exp != 0:
            return context._raise_error(InvalidOperation)
        if not (-context.prec <= int(other) <= context.prec):
            return context._raise_error(InvalidOperation)

        if self._isinfinity():
            return Decimal(self)

        # get values, pad if necessary
        torot = int(other)
        rotdig = self._int
        topad = context.prec - len(rotdig)
        if topad > 0:
            rotdig = '0'*topad + rotdig
        elif topad < 0:
            rotdig = rotdig[-topad:]

        # let's rotate!
        rotated = rotdig[torot:] + rotdig[:torot]
        return _dec_from_triple(self._sign,
                                rotated.lstrip('0') or '0', self._exp)

    def scaleb(self, other, context=None):
        """Returns self operand after adding the second value to its exp."""
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        ans = self._check_nans(other, context)
        if ans:
            return ans

        if other._exp != 0:
            return context._raise_error(InvalidOperation)
        liminf = -2 * (context.Emax + context.prec)
        limsup =  2 * (context.Emax + context.prec)
        if not (liminf <= int(other) <= limsup):
            return context._raise_error(InvalidOperation)

        if self._isinfinity():
            return Decimal(self)

        d = _dec_from_triple(self._sign, self._int, self._exp + int(other))
        d = d._fix(context)
        return d

    def shift(self, other, context=None):
        """Returns a shifted copy of self, value-of-other times."""
        if context is None:
            context = getcontext()

        other = _convert_other(other, raiseit=True)

        ans = self._check_nans(other, context)
        if ans:
            return ans

        if other._exp != 0:
            return context._raise_error(InvalidOperation)
        if not (-context.prec <= int(other) <= context.prec):
            return context._raise_error(InvalidOperation)

        if self._isinfinity():
            return Decimal(self)

        # get values, pad if necessary
        torot = int(other)
        rotdig = self._int
        topad = context.prec - len(rotdig)
        if topad > 0:
            rotdig = '0'*topad + rotdig
        elif topad < 0:
            rotdig = rotdig[-topad:]

        # let's shift!
        if torot < 0:
            shifted = rotdig[:torot]
        else:
            shifted = rotdig + '0'*torot
            shifted = shifted[-context.prec:]

        return _dec_from_triple(self._sign,
                                    shifted.lstrip('0') or '0', self._exp)

    # Support for pickling, copy, and deepcopy
    def __reduce__(self):
        return (self.__class__, (str(self),))

    def __copy__(self):
        if type(self) is Decimal:
            return self     # I'm immutable; therefore I am my own clone
        return self.__class__(str(self))

    def __deepcopy__(self, memo):
        if type(self) is Decimal:
            return self     # My components are also immutable
        return self.__class__(str(self))

    # PEP 3101 support.  the _localeconv keyword argument should be
    # considered private: it's provided for ease of testing only.
    def __format__(self, specifier, context=None, _localeconv=None):
        """Format a Decimal instance according to the given specifier.

        The specifier should be a standard format specifier, with the
        form described in PEP 3101.  Formatting types 'e', 'E', 'f',
        'F', 'g', 'G', 'n' and '%' are supported.  If the formatting
        type is omitted it defaults to 'g' or 'G', depending on the
        value of context.capitals.
        """

        # Note: PEP 3101 says that if the type is not present then
        # there should be at least one digit after the decimal point.
        # We take the liberty of ignoring this requirement for
        # Decimal---it's presumably there to make sure that
        # format(float, '') behaves similarly to str(float).
        if context is None:
            context = getcontext()

        spec = _parse_format_specifier(specifier, _localeconv=_localeconv)

        # special values don't care about the type or precision
        if self._is_special:
            sign = _format_sign(self._sign, spec)
            body = str(self.copy_abs())
            if spec['type'] == '%':
                body += '%'
            return _format_align(sign, body, spec)

        # a type of None defaults to 'g' or 'G', depending on context
        if spec['type'] is None:
            spec['type'] = ['g', 'G'][context.capitals]

        # if type is '%', adjust exponent of self accordingly
        if spec['type'] == '%':
            self = _dec_from_triple(self._sign, self._int, self._exp+2)

        # round if necessary, taking rounding mode from the context
        rounding = context.rounding
        precision = spec['precision']
        if precision is not None:
            if spec['type'] in 'eE':
                self = self._round(precision+1, rounding)
            elif spec['type'] in 'fF%':
                self = self._rescale(-precision, rounding)
            elif spec['type'] in 'gG' and len(self._int) > precision:
                self = self._round(precision, rounding)
        # special case: zeros with a positive exponent can't be
        # represented in fixed point; rescale them to 0e0.
        if not self and self._exp > 0 and spec['type'] in 'fF%':
            self = self._rescale(0, rounding)

        # figure out placement of the decimal point
        leftdigits = self._exp + len(self._int)
        if spec['type'] in 'eE':
            if not self and precision is not None:
                dotplace = 1 - precision
            else:
                dotplace = 1
        elif spec['type'] in 'fF%':
            dotplace = leftdigits
        elif spec['type'] in 'gG':
            if self._exp <= 0 and leftdigits > -6:
                dotplace = leftdigits
            else:
                dotplace = 1

        # find digits before and after decimal point, and get exponent
        if dotplace < 0:
            intpart = '0'
            fracpart = '0'*(-dotplace) + self._int
        elif dotplace > len(self._int):
            intpart = self._int + '0'*(dotplace-len(self._int))
            fracpart = ''
        else:
            intpart = self._int[:dotplace] or '0'
            fracpart = self._int[dotplace:]
        exp = leftdigits-dotplace

        # done with the decimal-specific stuff;  hand over the rest
        # of the formatting to the _format_number function
        return _format_number(self._sign, intpart, fracpart, exp, spec)

def _dec_from_triple(sign, coefficient, exponent, special=False):
    """Create a decimal instance directly, without any validation,
    normalization (e.g. removal of leading zeros) or argument
    conversion.

    This function is for *internal use only*.
    """

    self = object.__new__(Decimal)
    self._sign = sign
    self._int = coefficient
    self._exp = exponent
    self._is_special = special

    return self

# Register Decimal as a kind of Number (an abstract base class).
# However, do not register it as Real (because Decimals are not
# interoperable with floats).
_numbers.Number.register(Decimal)


##### Context class #######################################################

class _ContextManager(object):
    """Context manager class to support localcontext().

      Sets a copy of the supplied context in __enter__() and restores
      the previous decimal context in __exit__()
    """
    def __init__(self, new_context):
        self.new_context = new_context.copy()
    def __enter__(self):
        self.saved_context = getcontext()
        setcontext(self.new_context)
        return self.new_context
    def __exit__(self, t, v, tb):
        setcontext(self.saved_context)

class Context(object):
    """Contains the context for a Decimal instance.

    Contains:
    prec - precision (for use in rounding, division, square roots..)
    rounding - rounding type (how you round)
    traps - If traps[exception] = 1, then the exception is
                    raised when it is caused.  Otherwise, a value is
                    substituted in.
    flags  - When an exception is caused, flags[exception] is set.
             (Whether or not the trap_enabler is set)
             Should be reset by user of Decimal instance.
    Emin -   Minimum exponent
    Emax -   Maximum exponent
    capitals -      If 1, 1*10^1 is printed as 1E+1.
                    If 0, printed as 1e1
    clamp -  If 1, change exponents if too high (Default 0)
    """

    def __init__(self, prec=None, rounding=None, Emin=None, Emax=None,
                       capitals=None, clamp=None, flags=None, traps=None,
                       _ignored_flags=None):
        # Set defaults; for everything except flags and _ignored_flags,
        # inherit from DefaultContext.
        try:
            dc = DefaultContext
        except NameError:
            pass

        self.prec = prec if prec is not None else dc.prec
        self.rounding = rounding if rounding is not None else dc.rounding
        self.Emin = Emin if Emin is not None else dc.Emin
        self.Emax = Emax if Emax is not None else dc.Emax
        self.capitals = capitals if capitals is not None else dc.capitals
        self.clamp = clamp if clamp is not None else dc.clamp

        if _ignored_flags is None:
            self._ignored_flags = []
        else:
            self._ignored_flags = _ignored_flags

        if traps is None:
            self.traps = dc.traps.copy()
        elif not isinstance(traps, dict):
            self.traps = dict((s, int(s in traps)) for s in _signals + traps)
        else:
            self.traps = traps

        if flags is None:
            self.flags = dict.fromkeys(_signals, 0)
        elif not isinstance(flags, dict):
            self.flags = dict((s, int(s in flags)) for s in _signals + flags)
        else:
            self.flags = flags

    def _set_integer_check(self, name, value, vmin, vmax):
        if not isinstance(value, int):
            raise TypeError("%s must be an integer" % name)
        if vmin == '-inf':
            if value > vmax:
                raise ValueError("%s must be in [%s, %d]. got: %s" % (name, vmin, vmax, value))
        elif vmax == 'inf':
            if value < vmin:
                raise ValueError("%s must be in [%d, %s]. got: %s" % (name, vmin, vmax, value))
        else:
            if value < vmin or value > vmax:
                raise ValueError("%s must be in [%d, %d]. got %s" % (name, vmin, vmax, value))
        return object.__setattr__(self, name, value)

    def _set_signal_dict(self, name, d):
        if not isinstance(d, dict):
            raise TypeError("%s must be a signal dict" % d)
        for key in d:
            if not key in _signals:
                raise KeyError("%s is not a valid signal dict" % d)
        for key in _signals:
            if not key in d:
                raise KeyError("%s is not a valid signal dict" % d)
        return object.__setattr__(self, name, d)

    def __setattr__(self, name, value):
        if name == 'prec':
            return self._set_integer_check(name, value, 1, 'inf')
        elif name == 'Emin':
            return self._set_integer_check(name, value, '-inf', 0)
        elif name == 'Emax':
            return self._set_integer_check(name, value, 0, 'inf')
        elif name == 'capitals':
            return self._set_integer_check(name, value, 0, 1)
        elif name == 'clamp':
            return self._set_integer_check(name, value, 0, 1)
        elif name == 'rounding':
            if not value in _rounding_modes:
                # raise TypeError even for strings to have consistency
                # among various implementations.
                raise TypeError("%s: invalid rounding mode" % value)
            return object.__setattr__(self, name, value)
        elif name == 'flags' or name == 'traps':
            return self._set_signal_dict(name, value)
        elif name == '_ignored_flags':
            return object.__setattr__(self, name, value)
        else:
            raise AttributeError(
                "'decimal.Context' object has no attribute '%s'" % name)

    def __delattr__(self, name):
        raise AttributeError("%s cannot be deleted" % name)

    # Support for pickling, copy, and deepcopy
    def __reduce__(self):
        flags = [sig for sig, v in self.flags.items() if v]
        traps = [sig for sig, v in self.traps.items() if v]
        return (self.__class__,
                (self.prec, self.rounding, self.Emin, self.Emax,
                 self.capitals, self.clamp, flags, traps))

    def __repr__(self):
        """Show the current context."""
        s = []
        s.append('Context(prec=%(prec)d, rounding=%(rounding)s, '
                 'Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d, '
                 'clamp=%(clamp)d'
                 % vars(self))
        names = [f.__name__ for f, v in self.flags.items() if v]
        s.append('flags=[' + ', '.join(names) + ']')
        names = [t.__name__ for t, v in self.traps.items() if v]
        s.append('traps=[' + ', '.join(names) + ']')
        return ', '.join(s) + ')'

    def clear_flags(self):
        """Reset all flags to zero"""
        for flag in self.flags:
            self.flags[flag] = 0

    def clear_traps(self):
        """Reset all traps to zero"""
        for flag in self.traps:
            self.traps[flag] = 0

    def _shallow_copy(self):
        """Returns a shallow copy from self."""
        nc = Context(self.prec, self.rounding, self.Emin, self.Emax,
                     self.capitals, self.clamp, self.flags, self.traps,
                     self._ignored_flags)
        return nc

    def copy(self):
        """Returns a deep copy from self."""
        nc = Context(self.prec, self.rounding, self.Emin, self.Emax,
                     self.capitals, self.clamp,
                     self.flags.copy(), self.traps.copy(),
                     self._ignored_flags)
        return nc
    __copy__ = copy

    def _raise_error(self, condition, explanation = None, *args):
        """Handles an error

        If the flag is in _ignored_flags, returns the default response.
        Otherwise, it sets the flag, then, if the corresponding
        trap_enabler is set, it reraises the exception.  Otherwise, it returns
        the default value after setting the flag.
        """
        error = _condition_map.get(condition, condition)
        if error in self._ignored_flags:
            # Don't touch the flag
            return error().handle(self, *args)

        self.flags[error] = 1
        if not self.traps[error]:
            # The errors define how to handle themselves.
            return condition().handle(self, *args)

        # Errors should only be risked on copies of the context
        # self._ignored_flags = []
        raise error(explanation)

    def _ignore_all_flags(self):
        """Ignore all flags, if they are raised"""
        return self._ignore_flags(*_signals)

    def _ignore_flags(self, *flags):
        """Ignore the flags, if they are raised"""
        # Do not mutate-- This way, copies of a context leave the original
        # alone.
        self._ignored_flags = (self._ignored_flags + list(flags))
        return list(flags)

    def _regard_flags(self, *flags):
        """Stop ignoring the flags, if they are raised"""
        if flags and isinstance(flags[0], (tuple,list)):
            flags = flags[0]
        for flag in flags:
            self._ignored_flags.remove(flag)

    # We inherit object.__hash__, so we must deny this explicitly
    __hash__ = None

    def Etiny(self):
        """Returns Etiny (= Emin - prec + 1)"""
        return int(self.Emin - self.prec + 1)

    def Etop(self):
        """Returns maximum exponent (= Emax - prec + 1)"""
        return int(self.Emax - self.prec + 1)

    def _set_rounding(self, type):
        """Sets the rounding type.

        Sets the rounding type, and returns the current (previous)
        rounding type.  Often used like:

        context = context.copy()
        # so you don't change the calling context
        # if an error occurs in the middle.
        rounding = context._set_rounding(ROUND_UP)
        val = self.__sub__(other, context=context)
        context._set_rounding(rounding)

        This will make it round up for that operation.
        """
        rounding = self.rounding
        self.rounding= type
        return rounding

    def create_decimal(self, num='0'):
        """Creates a new Decimal instance but using self as context.

        This method implements the to-number operation of the
        IBM Decimal specification."""

        if isinstance(num, str) and num != num.strip():
            return self._raise_error(ConversionSyntax,
                                     "no trailing or leading whitespace is "
                                     "permitted.")

        d = Decimal(num, context=self)
        if d._isnan() and len(d._int) > self.prec - self.clamp:
            return self._raise_error(ConversionSyntax,
                                     "diagnostic info too long in NaN")
        return d._fix(self)

    def create_decimal_from_float(self, f):
        """Creates a new Decimal instance from a float but rounding using self
        as the context.

        >>> context = Context(prec=5, rounding=ROUND_DOWN)
        >>> context.create_decimal_from_float(3.1415926535897932)
        Decimal('3.1415')
        >>> context = Context(prec=5, traps=[Inexact])
        >>> context.create_decimal_from_float(3.1415926535897932)
        Traceback (most recent call last):
            ...
        decimal.Inexact: None

        """
        d = Decimal.from_float(f)       # An exact conversion
        return d._fix(self)             # Apply the context rounding

    # Methods
    def abs(self, a):
        """Returns the absolute value of the operand.

        If the operand is negative, the result is the same as using the minus
        operation on the operand.  Otherwise, the result is the same as using
        the plus operation on the operand.

        >>> ExtendedContext.abs(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.abs(Decimal('-100'))
        Decimal('100')
        >>> ExtendedContext.abs(Decimal('101.5'))
        Decimal('101.5')
        >>> ExtendedContext.abs(Decimal('-101.5'))
        Decimal('101.5')
        >>> ExtendedContext.abs(-1)
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        return a.__abs__(context=self)

    def add(self, a, b):
        """Return the sum of the two operands.

        >>> ExtendedContext.add(Decimal('12'), Decimal('7.00'))
        Decimal('19.00')
        >>> ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))
        Decimal('1.02E+4')
        >>> ExtendedContext.add(1, Decimal(2))
        Decimal('3')
        >>> ExtendedContext.add(Decimal(8), 5)
        Decimal('13')
        >>> ExtendedContext.add(5, 5)
        Decimal('10')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__add__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def _apply(self, a):
        return str(a._fix(self))

    def canonical(self, a):
        """Returns the same Decimal object.

        As we do not have different encodings for the same number, the
        received object already is in its canonical form.

        >>> ExtendedContext.canonical(Decimal('2.50'))
        Decimal('2.50')
        """
        if not isinstance(a, Decimal):
            raise TypeError("canonical requires a Decimal as an argument.")
        return a.canonical()

    def compare(self, a, b):
        """Compares values numerically.

        If the signs of the operands differ, a value representing each operand
        ('-1' if the operand is less than zero, '0' if the operand is zero or
        negative zero, or '1' if the operand is greater than zero) is used in
        place of that operand for the comparison instead of the actual
        operand.

        The comparison is then effected by subtracting the second operand from
        the first and then returning a value according to the result of the
        subtraction: '-1' if the result is less than zero, '0' if the result is
        zero or negative zero, or '1' if the result is greater than zero.

        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('3'))
        Decimal('-1')
        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))
        Decimal('0')
        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))
        Decimal('0')
        >>> ExtendedContext.compare(Decimal('3'), Decimal('2.1'))
        Decimal('1')
        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))
        Decimal('1')
        >>> ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))
        Decimal('-1')
        >>> ExtendedContext.compare(1, 2)
        Decimal('-1')
        >>> ExtendedContext.compare(Decimal(1), 2)
        Decimal('-1')
        >>> ExtendedContext.compare(1, Decimal(2))
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.compare(b, context=self)

    def compare_signal(self, a, b):
        """Compares the values of the two operands numerically.

        It's pretty much like compare(), but all NaNs signal, with signaling
        NaNs taking precedence over quiet NaNs.

        >>> c = ExtendedContext
        >>> c.compare_signal(Decimal('2.1'), Decimal('3'))
        Decimal('-1')
        >>> c.compare_signal(Decimal('2.1'), Decimal('2.1'))
        Decimal('0')
        >>> c.flags[InvalidOperation] = 0
        >>> print(c.flags[InvalidOperation])
        0
        >>> c.compare_signal(Decimal('NaN'), Decimal('2.1'))
        Decimal('NaN')
        >>> print(c.flags[InvalidOperation])
        1
        >>> c.flags[InvalidOperation] = 0
        >>> print(c.flags[InvalidOperation])
        0
        >>> c.compare_signal(Decimal('sNaN'), Decimal('2.1'))
        Decimal('NaN')
        >>> print(c.flags[InvalidOperation])
        1
        >>> c.compare_signal(-1, 2)
        Decimal('-1')
        >>> c.compare_signal(Decimal(-1), 2)
        Decimal('-1')
        >>> c.compare_signal(-1, Decimal(2))
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.compare_signal(b, context=self)

    def compare_total(self, a, b):
        """Compares two operands using their abstract representation.

        This is not like the standard compare, which use their numerical
        value. Note that a total ordering is defined for all possible abstract
        representations.

        >>> ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))
        Decimal('0')
        >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))
        Decimal('1')
        >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(1, 2)
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal(1), 2)
        Decimal('-1')
        >>> ExtendedContext.compare_total(1, Decimal(2))
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.compare_total(b)

    def compare_total_mag(self, a, b):
        """Compares two operands using their abstract representation ignoring sign.

        Like compare_total, but with operand's sign ignored and assumed to be 0.
        """
        a = _convert_other(a, raiseit=True)
        return a.compare_total_mag(b)

    def copy_abs(self, a):
        """Returns a copy of the operand with the sign set to 0.

        >>> ExtendedContext.copy_abs(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.copy_abs(Decimal('-100'))
        Decimal('100')
        >>> ExtendedContext.copy_abs(-1)
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        return a.copy_abs()

    def copy_decimal(self, a):
        """Returns a copy of the decimal object.

        >>> ExtendedContext.copy_decimal(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.copy_decimal(Decimal('-1.00'))
        Decimal('-1.00')
        >>> ExtendedContext.copy_decimal(1)
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        return Decimal(a)

    def copy_negate(self, a):
        """Returns a copy of the operand with the sign inverted.

        >>> ExtendedContext.copy_negate(Decimal('101.5'))
        Decimal('-101.5')
        >>> ExtendedContext.copy_negate(Decimal('-101.5'))
        Decimal('101.5')
        >>> ExtendedContext.copy_negate(1)
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.copy_negate()

    def copy_sign(self, a, b):
        """Copies the second operand's sign to the first one.

        In detail, it returns a copy of the first operand with the sign
        equal to the sign of the second operand.

        >>> ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))
        Decimal('1.50')
        >>> ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))
        Decimal('1.50')
        >>> ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))
        Decimal('-1.50')
        >>> ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))
        Decimal('-1.50')
        >>> ExtendedContext.copy_sign(1, -2)
        Decimal('-1')
        >>> ExtendedContext.copy_sign(Decimal(1), -2)
        Decimal('-1')
        >>> ExtendedContext.copy_sign(1, Decimal(-2))
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.copy_sign(b)

    def divide(self, a, b):
        """Decimal division in a specified context.

        >>> ExtendedContext.divide(Decimal('1'), Decimal('3'))
        Decimal('0.333333333')
        >>> ExtendedContext.divide(Decimal('2'), Decimal('3'))
        Decimal('0.666666667')
        >>> ExtendedContext.divide(Decimal('5'), Decimal('2'))
        Decimal('2.5')
        >>> ExtendedContext.divide(Decimal('1'), Decimal('10'))
        Decimal('0.1')
        >>> ExtendedContext.divide(Decimal('12'), Decimal('12'))
        Decimal('1')
        >>> ExtendedContext.divide(Decimal('8.00'), Decimal('2'))
        Decimal('4.00')
        >>> ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))
        Decimal('1.20')
        >>> ExtendedContext.divide(Decimal('1000'), Decimal('100'))
        Decimal('10')
        >>> ExtendedContext.divide(Decimal('1000'), Decimal('1'))
        Decimal('1000')
        >>> ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))
        Decimal('1.20E+6')
        >>> ExtendedContext.divide(5, 5)
        Decimal('1')
        >>> ExtendedContext.divide(Decimal(5), 5)
        Decimal('1')
        >>> ExtendedContext.divide(5, Decimal(5))
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__truediv__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def divide_int(self, a, b):
        """Divides two numbers and returns the integer part of the result.

        >>> ExtendedContext.divide_int(Decimal('2'), Decimal('3'))
        Decimal('0')
        >>> ExtendedContext.divide_int(Decimal('10'), Decimal('3'))
        Decimal('3')
        >>> ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))
        Decimal('3')
        >>> ExtendedContext.divide_int(10, 3)
        Decimal('3')
        >>> ExtendedContext.divide_int(Decimal(10), 3)
        Decimal('3')
        >>> ExtendedContext.divide_int(10, Decimal(3))
        Decimal('3')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__floordiv__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def divmod(self, a, b):
        """Return (a // b, a % b).

        >>> ExtendedContext.divmod(Decimal(8), Decimal(3))
        (Decimal('2'), Decimal('2'))
        >>> ExtendedContext.divmod(Decimal(8), Decimal(4))
        (Decimal('2'), Decimal('0'))
        >>> ExtendedContext.divmod(8, 4)
        (Decimal('2'), Decimal('0'))
        >>> ExtendedContext.divmod(Decimal(8), 4)
        (Decimal('2'), Decimal('0'))
        >>> ExtendedContext.divmod(8, Decimal(4))
        (Decimal('2'), Decimal('0'))
        """
        a = _convert_other(a, raiseit=True)
        r = a.__divmod__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def exp(self, a):
        """Returns e ** a.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.exp(Decimal('-Infinity'))
        Decimal('0')
        >>> c.exp(Decimal('-1'))
        Decimal('0.367879441')
        >>> c.exp(Decimal('0'))
        Decimal('1')
        >>> c.exp(Decimal('1'))
        Decimal('2.71828183')
        >>> c.exp(Decimal('0.693147181'))
        Decimal('2.00000000')
        >>> c.exp(Decimal('+Infinity'))
        Decimal('Infinity')
        >>> c.exp(10)
        Decimal('22026.4658')
        """
        a =_convert_other(a, raiseit=True)
        return a.exp(context=self)

    def fma(self, a, b, c):
        """Returns a multiplied by b, plus c.

        The first two operands are multiplied together, using multiply,
        the third operand is then added to the result of that
        multiplication, using add, all with only one final rounding.

        >>> ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))
        Decimal('22')
        >>> ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))
        Decimal('-8')
        >>> ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))
        Decimal('1.38435736E+12')
        >>> ExtendedContext.fma(1, 3, 4)
        Decimal('7')
        >>> ExtendedContext.fma(1, Decimal(3), 4)
        Decimal('7')
        >>> ExtendedContext.fma(1, 3, Decimal(4))
        Decimal('7')
        """
        a = _convert_other(a, raiseit=True)
        return a.fma(b, c, context=self)

    def is_canonical(self, a):
        """Return True if the operand is canonical; otherwise return False.

        Currently, the encoding of a Decimal instance is always
        canonical, so this method returns True for any Decimal.

        >>> ExtendedContext.is_canonical(Decimal('2.50'))
        True
        """
        if not isinstance(a, Decimal):
            raise TypeError("is_canonical requires a Decimal as an argument.")
        return a.is_canonical()

    def is_finite(self, a):
        """Return True if the operand is finite; otherwise return False.

        A Decimal instance is considered finite if it is neither
        infinite nor a NaN.

        >>> ExtendedContext.is_finite(Decimal('2.50'))
        True
        >>> ExtendedContext.is_finite(Decimal('-0.3'))
        True
        >>> ExtendedContext.is_finite(Decimal('0'))
        True
        >>> ExtendedContext.is_finite(Decimal('Inf'))
        False
        >>> ExtendedContext.is_finite(Decimal('NaN'))
        False
        >>> ExtendedContext.is_finite(1)
        True
        """
        a = _convert_other(a, raiseit=True)
        return a.is_finite()

    def is_infinite(self, a):
        """Return True if the operand is infinite; otherwise return False.

        >>> ExtendedContext.is_infinite(Decimal('2.50'))
        False
        >>> ExtendedContext.is_infinite(Decimal('-Inf'))
        True
        >>> ExtendedContext.is_infinite(Decimal('NaN'))
        False
        >>> ExtendedContext.is_infinite(1)
        False
        """
        a = _convert_other(a, raiseit=True)
        return a.is_infinite()

    def is_nan(self, a):
        """Return True if the operand is a qNaN or sNaN;
        otherwise return False.

        >>> ExtendedContext.is_nan(Decimal('2.50'))
        False
        >>> ExtendedContext.is_nan(Decimal('NaN'))
        True
        >>> ExtendedContext.is_nan(Decimal('-sNaN'))
        True
        >>> ExtendedContext.is_nan(1)
        False
        """
        a = _convert_other(a, raiseit=True)
        return a.is_nan()

    def is_normal(self, a):
        """Return True if the operand is a normal number;
        otherwise return False.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.is_normal(Decimal('2.50'))
        True
        >>> c.is_normal(Decimal('0.1E-999'))
        False
        >>> c.is_normal(Decimal('0.00'))
        False
        >>> c.is_normal(Decimal('-Inf'))
        False
        >>> c.is_normal(Decimal('NaN'))
        False
        >>> c.is_normal(1)
        True
        """
        a = _convert_other(a, raiseit=True)
        return a.is_normal(context=self)

    def is_qnan(self, a):
        """Return True if the operand is a quiet NaN; otherwise return False.

        >>> ExtendedContext.is_qnan(Decimal('2.50'))
        False
        >>> ExtendedContext.is_qnan(Decimal('NaN'))
        True
        >>> ExtendedContext.is_qnan(Decimal('sNaN'))
        False
        >>> ExtendedContext.is_qnan(1)
        False
        """
        a = _convert_other(a, raiseit=True)
        return a.is_qnan()

    def is_signed(self, a):
        """Return True if the operand is negative; otherwise return False.

        >>> ExtendedContext.is_signed(Decimal('2.50'))
        False
        >>> ExtendedContext.is_signed(Decimal('-12'))
        True
        >>> ExtendedContext.is_signed(Decimal('-0'))
        True
        >>> ExtendedContext.is_signed(8)
        False
        >>> ExtendedContext.is_signed(-8)
        True
        """
        a = _convert_other(a, raiseit=True)
        return a.is_signed()

    def is_snan(self, a):
        """Return True if the operand is a signaling NaN;
        otherwise return False.

        >>> ExtendedContext.is_snan(Decimal('2.50'))
        False
        >>> ExtendedContext.is_snan(Decimal('NaN'))
        False
        >>> ExtendedContext.is_snan(Decimal('sNaN'))
        True
        >>> ExtendedContext.is_snan(1)
        False
        """
        a = _convert_other(a, raiseit=True)
        return a.is_snan()

    def is_subnormal(self, a):
        """Return True if the operand is subnormal; otherwise return False.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.is_subnormal(Decimal('2.50'))
        False
        >>> c.is_subnormal(Decimal('0.1E-999'))
        True
        >>> c.is_subnormal(Decimal('0.00'))
        False
        >>> c.is_subnormal(Decimal('-Inf'))
        False
        >>> c.is_subnormal(Decimal('NaN'))
        False
        >>> c.is_subnormal(1)
        False
        """
        a = _convert_other(a, raiseit=True)
        return a.is_subnormal(context=self)

    def is_zero(self, a):
        """Return True if the operand is a zero; otherwise return False.

        >>> ExtendedContext.is_zero(Decimal('0'))
        True
        >>> ExtendedContext.is_zero(Decimal('2.50'))
        False
        >>> ExtendedContext.is_zero(Decimal('-0E+2'))
        True
        >>> ExtendedContext.is_zero(1)
        False
        >>> ExtendedContext.is_zero(0)
        True
        """
        a = _convert_other(a, raiseit=True)
        return a.is_zero()

    def ln(self, a):
        """Returns the natural (base e) logarithm of the operand.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.ln(Decimal('0'))
        Decimal('-Infinity')
        >>> c.ln(Decimal('1.000'))
        Decimal('0')
        >>> c.ln(Decimal('2.71828183'))
        Decimal('1.00000000')
        >>> c.ln(Decimal('10'))
        Decimal('2.30258509')
        >>> c.ln(Decimal('+Infinity'))
        Decimal('Infinity')
        >>> c.ln(1)
        Decimal('0')
        """
        a = _convert_other(a, raiseit=True)
        return a.ln(context=self)

    def log10(self, a):
        """Returns the base 10 logarithm of the operand.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.log10(Decimal('0'))
        Decimal('-Infinity')
        >>> c.log10(Decimal('0.001'))
        Decimal('-3')
        >>> c.log10(Decimal('1.000'))
        Decimal('0')
        >>> c.log10(Decimal('2'))
        Decimal('0.301029996')
        >>> c.log10(Decimal('10'))
        Decimal('1')
        >>> c.log10(Decimal('70'))
        Decimal('1.84509804')
        >>> c.log10(Decimal('+Infinity'))
        Decimal('Infinity')
        >>> c.log10(0)
        Decimal('-Infinity')
        >>> c.log10(1)
        Decimal('0')
        """
        a = _convert_other(a, raiseit=True)
        return a.log10(context=self)

    def logb(self, a):
        """ Returns the exponent of the magnitude of the operand's MSD.

        The result is the integer which is the exponent of the magnitude
        of the most significant digit of the operand (as though the
        operand were truncated to a single digit while maintaining the
        value of that digit and without limiting the resulting exponent).

        >>> ExtendedContext.logb(Decimal('250'))
        Decimal('2')
        >>> ExtendedContext.logb(Decimal('2.50'))
        Decimal('0')
        >>> ExtendedContext.logb(Decimal('0.03'))
        Decimal('-2')
        >>> ExtendedContext.logb(Decimal('0'))
        Decimal('-Infinity')
        >>> ExtendedContext.logb(1)
        Decimal('0')
        >>> ExtendedContext.logb(10)
        Decimal('1')
        >>> ExtendedContext.logb(100)
        Decimal('2')
        """
        a = _convert_other(a, raiseit=True)
        return a.logb(context=self)

    def logical_and(self, a, b):
        """Applies the logical operation 'and' between each operand's digits.

        The operands must be both logical numbers.

        >>> ExtendedContext.logical_and(Decimal('0'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_and(Decimal('0'), Decimal('1'))
        Decimal('0')
        >>> ExtendedContext.logical_and(Decimal('1'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_and(Decimal('1'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))
        Decimal('1000')
        >>> ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))
        Decimal('10')
        >>> ExtendedContext.logical_and(110, 1101)
        Decimal('100')
        >>> ExtendedContext.logical_and(Decimal(110), 1101)
        Decimal('100')
        >>> ExtendedContext.logical_and(110, Decimal(1101))
        Decimal('100')
        """
        a = _convert_other(a, raiseit=True)
        return a.logical_and(b, context=self)

    def logical_invert(self, a):
        """Invert all the digits in the operand.

        The operand must be a logical number.

        >>> ExtendedContext.logical_invert(Decimal('0'))
        Decimal('111111111')
        >>> ExtendedContext.logical_invert(Decimal('1'))
        Decimal('111111110')
        >>> ExtendedContext.logical_invert(Decimal('111111111'))
        Decimal('0')
        >>> ExtendedContext.logical_invert(Decimal('101010101'))
        Decimal('10101010')
        >>> ExtendedContext.logical_invert(1101)
        Decimal('111110010')
        """
        a = _convert_other(a, raiseit=True)
        return a.logical_invert(context=self)

    def logical_or(self, a, b):
        """Applies the logical operation 'or' between each operand's digits.

        The operands must be both logical numbers.

        >>> ExtendedContext.logical_or(Decimal('0'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_or(Decimal('0'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_or(Decimal('1'), Decimal('0'))
        Decimal('1')
        >>> ExtendedContext.logical_or(Decimal('1'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))
        Decimal('1110')
        >>> ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))
        Decimal('1110')
        >>> ExtendedContext.logical_or(110, 1101)
        Decimal('1111')
        >>> ExtendedContext.logical_or(Decimal(110), 1101)
        Decimal('1111')
        >>> ExtendedContext.logical_or(110, Decimal(1101))
        Decimal('1111')
        """
        a = _convert_other(a, raiseit=True)
        return a.logical_or(b, context=self)

    def logical_xor(self, a, b):
        """Applies the logical operation 'xor' between each operand's digits.

        The operands must be both logical numbers.

        >>> ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))
        Decimal('1')
        >>> ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))
        Decimal('0')
        >>> ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))
        Decimal('110')
        >>> ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))
        Decimal('1101')
        >>> ExtendedContext.logical_xor(110, 1101)
        Decimal('1011')
        >>> ExtendedContext.logical_xor(Decimal(110), 1101)
        Decimal('1011')
        >>> ExtendedContext.logical_xor(110, Decimal(1101))
        Decimal('1011')
        """
        a = _convert_other(a, raiseit=True)
        return a.logical_xor(b, context=self)

    def max(self, a, b):
        """max compares two values numerically and returns the maximum.

        If either operand is a NaN then the general rules apply.
        Otherwise, the operands are compared as though by the compare
        operation.  If they are numerically equal then the left-hand operand
        is chosen as the result.  Otherwise the maximum (closer to positive
        infinity) of the two operands is chosen as the result.

        >>> ExtendedContext.max(Decimal('3'), Decimal('2'))
        Decimal('3')
        >>> ExtendedContext.max(Decimal('-10'), Decimal('3'))
        Decimal('3')
        >>> ExtendedContext.max(Decimal('1.0'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.max(Decimal('7'), Decimal('NaN'))
        Decimal('7')
        >>> ExtendedContext.max(1, 2)
        Decimal('2')
        >>> ExtendedContext.max(Decimal(1), 2)
        Decimal('2')
        >>> ExtendedContext.max(1, Decimal(2))
        Decimal('2')
        """
        a = _convert_other(a, raiseit=True)
        return a.max(b, context=self)

    def max_mag(self, a, b):
        """Compares the values numerically with their sign ignored.

        >>> ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))
        Decimal('7')
        >>> ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))
        Decimal('-10')
        >>> ExtendedContext.max_mag(1, -2)
        Decimal('-2')
        >>> ExtendedContext.max_mag(Decimal(1), -2)
        Decimal('-2')
        >>> ExtendedContext.max_mag(1, Decimal(-2))
        Decimal('-2')
        """
        a = _convert_other(a, raiseit=True)
        return a.max_mag(b, context=self)

    def min(self, a, b):
        """min compares two values numerically and returns the minimum.

        If either operand is a NaN then the general rules apply.
        Otherwise, the operands are compared as though by the compare
        operation.  If they are numerically equal then the left-hand operand
        is chosen as the result.  Otherwise the minimum (closer to negative
        infinity) of the two operands is chosen as the result.

        >>> ExtendedContext.min(Decimal('3'), Decimal('2'))
        Decimal('2')
        >>> ExtendedContext.min(Decimal('-10'), Decimal('3'))
        Decimal('-10')
        >>> ExtendedContext.min(Decimal('1.0'), Decimal('1'))
        Decimal('1.0')
        >>> ExtendedContext.min(Decimal('7'), Decimal('NaN'))
        Decimal('7')
        >>> ExtendedContext.min(1, 2)
        Decimal('1')
        >>> ExtendedContext.min(Decimal(1), 2)
        Decimal('1')
        >>> ExtendedContext.min(1, Decimal(29))
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        return a.min(b, context=self)

    def min_mag(self, a, b):
        """Compares the values numerically with their sign ignored.

        >>> ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))
        Decimal('-2')
        >>> ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))
        Decimal('-3')
        >>> ExtendedContext.min_mag(1, -2)
        Decimal('1')
        >>> ExtendedContext.min_mag(Decimal(1), -2)
        Decimal('1')
        >>> ExtendedContext.min_mag(1, Decimal(-2))
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        return a.min_mag(b, context=self)

    def minus(self, a):
        """Minus corresponds to unary prefix minus in Python.

        The operation is evaluated using the same rules as subtract; the
        operation minus(a) is calculated as subtract('0', a) where the '0'
        has the same exponent as the operand.

        >>> ExtendedContext.minus(Decimal('1.3'))
        Decimal('-1.3')
        >>> ExtendedContext.minus(Decimal('-1.3'))
        Decimal('1.3')
        >>> ExtendedContext.minus(1)
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.__neg__(context=self)

    def multiply(self, a, b):
        """multiply multiplies two operands.

        If either operand is a special value then the general rules apply.
        Otherwise, the operands are multiplied together
        ('long multiplication'), resulting in a number which may be as long as
        the sum of the lengths of the two operands.

        >>> ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))
        Decimal('3.60')
        >>> ExtendedContext.multiply(Decimal('7'), Decimal('3'))
        Decimal('21')
        >>> ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))
        Decimal('0.72')
        >>> ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))
        Decimal('-0.0')
        >>> ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))
        Decimal('4.28135971E+11')
        >>> ExtendedContext.multiply(7, 7)
        Decimal('49')
        >>> ExtendedContext.multiply(Decimal(7), 7)
        Decimal('49')
        >>> ExtendedContext.multiply(7, Decimal(7))
        Decimal('49')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__mul__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def next_minus(self, a):
        """Returns the largest representable number smaller than a.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> ExtendedContext.next_minus(Decimal('1'))
        Decimal('0.999999999')
        >>> c.next_minus(Decimal('1E-1007'))
        Decimal('0E-1007')
        >>> ExtendedContext.next_minus(Decimal('-1.00000003'))
        Decimal('-1.00000004')
        >>> c.next_minus(Decimal('Infinity'))
        Decimal('9.99999999E+999')
        >>> c.next_minus(1)
        Decimal('0.999999999')
        """
        a = _convert_other(a, raiseit=True)
        return a.next_minus(context=self)

    def next_plus(self, a):
        """Returns the smallest representable number larger than a.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> ExtendedContext.next_plus(Decimal('1'))
        Decimal('1.00000001')
        >>> c.next_plus(Decimal('-1E-1007'))
        Decimal('-0E-1007')
        >>> ExtendedContext.next_plus(Decimal('-1.00000003'))
        Decimal('-1.00000002')
        >>> c.next_plus(Decimal('-Infinity'))
        Decimal('-9.99999999E+999')
        >>> c.next_plus(1)
        Decimal('1.00000001')
        """
        a = _convert_other(a, raiseit=True)
        return a.next_plus(context=self)

    def next_toward(self, a, b):
        """Returns the number closest to a, in direction towards b.

        The result is the closest representable number from the first
        operand (but not the first operand) that is in the direction
        towards the second operand, unless the operands have the same
        value.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.next_toward(Decimal('1'), Decimal('2'))
        Decimal('1.00000001')
        >>> c.next_toward(Decimal('-1E-1007'), Decimal('1'))
        Decimal('-0E-1007')
        >>> c.next_toward(Decimal('-1.00000003'), Decimal('0'))
        Decimal('-1.00000002')
        >>> c.next_toward(Decimal('1'), Decimal('0'))
        Decimal('0.999999999')
        >>> c.next_toward(Decimal('1E-1007'), Decimal('-100'))
        Decimal('0E-1007')
        >>> c.next_toward(Decimal('-1.00000003'), Decimal('-10'))
        Decimal('-1.00000004')
        >>> c.next_toward(Decimal('0.00'), Decimal('-0.0000'))
        Decimal('-0.00')
        >>> c.next_toward(0, 1)
        Decimal('1E-1007')
        >>> c.next_toward(Decimal(0), 1)
        Decimal('1E-1007')
        >>> c.next_toward(0, Decimal(1))
        Decimal('1E-1007')
        """
        a = _convert_other(a, raiseit=True)
        return a.next_toward(b, context=self)

    def normalize(self, a):
        """normalize reduces an operand to its simplest form.

        Essentially a plus operation with all trailing zeros removed from the
        result.

        >>> ExtendedContext.normalize(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.normalize(Decimal('-2.0'))
        Decimal('-2')
        >>> ExtendedContext.normalize(Decimal('1.200'))
        Decimal('1.2')
        >>> ExtendedContext.normalize(Decimal('-120'))
        Decimal('-1.2E+2')
        >>> ExtendedContext.normalize(Decimal('120.00'))
        Decimal('1.2E+2')
        >>> ExtendedContext.normalize(Decimal('0.00'))
        Decimal('0')
        >>> ExtendedContext.normalize(6)
        Decimal('6')
        """
        a = _convert_other(a, raiseit=True)
        return a.normalize(context=self)

    def number_class(self, a):
        """Returns an indication of the class of the operand.

        The class is one of the following strings:
          -sNaN
          -NaN
          -Infinity
          -Normal
          -Subnormal
          -Zero
          +Zero
          +Subnormal
          +Normal
          +Infinity

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.number_class(Decimal('Infinity'))
        '+Infinity'
        >>> c.number_class(Decimal('1E-10'))
        '+Normal'
        >>> c.number_class(Decimal('2.50'))
        '+Normal'
        >>> c.number_class(Decimal('0.1E-999'))
        '+Subnormal'
        >>> c.number_class(Decimal('0'))
        '+Zero'
        >>> c.number_class(Decimal('-0'))
        '-Zero'
        >>> c.number_class(Decimal('-0.1E-999'))
        '-Subnormal'
        >>> c.number_class(Decimal('-1E-10'))
        '-Normal'
        >>> c.number_class(Decimal('-2.50'))
        '-Normal'
        >>> c.number_class(Decimal('-Infinity'))
        '-Infinity'
        >>> c.number_class(Decimal('NaN'))
        'NaN'
        >>> c.number_class(Decimal('-NaN'))
        'NaN'
        >>> c.number_class(Decimal('sNaN'))
        'sNaN'
        >>> c.number_class(123)
        '+Normal'
        """
        a = _convert_other(a, raiseit=True)
        return a.number_class(context=self)

    def plus(self, a):
        """Plus corresponds to unary prefix plus in Python.

        The operation is evaluated using the same rules as add; the
        operation plus(a) is calculated as add('0', a) where the '0'
        has the same exponent as the operand.

        >>> ExtendedContext.plus(Decimal('1.3'))
        Decimal('1.3')
        >>> ExtendedContext.plus(Decimal('-1.3'))
        Decimal('-1.3')
        >>> ExtendedContext.plus(-1)
        Decimal('-1')
        """
        a = _convert_other(a, raiseit=True)
        return a.__pos__(context=self)

    def power(self, a, b, modulo=None):
        """Raises a to the power of b, to modulo if given.

        With two arguments, compute a**b.  If a is negative then b
        must be integral.  The result will be inexact unless b is
        integral and the result is finite and can be expressed exactly
        in 'precision' digits.

        With three arguments, compute (a**b) % modulo.  For the
        three argument form, the following restrictions on the
        arguments hold:

         - all three arguments must be integral
         - b must be nonnegative
         - at least one of a or b must be nonzero
         - modulo must be nonzero and have at most 'precision' digits

        The result of pow(a, b, modulo) is identical to the result
        that would be obtained by computing (a**b) % modulo with
        unbounded precision, but is computed more efficiently.  It is
        always exact.

        >>> c = ExtendedContext.copy()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.power(Decimal('2'), Decimal('3'))
        Decimal('8')
        >>> c.power(Decimal('-2'), Decimal('3'))
        Decimal('-8')
        >>> c.power(Decimal('2'), Decimal('-3'))
        Decimal('0.125')
        >>> c.power(Decimal('1.7'), Decimal('8'))
        Decimal('69.7575744')
        >>> c.power(Decimal('10'), Decimal('0.301029996'))
        Decimal('2.00000000')
        >>> c.power(Decimal('Infinity'), Decimal('-1'))
        Decimal('0')
        >>> c.power(Decimal('Infinity'), Decimal('0'))
        Decimal('1')
        >>> c.power(Decimal('Infinity'), Decimal('1'))
        Decimal('Infinity')
        >>> c.power(Decimal('-Infinity'), Decimal('-1'))
        Decimal('-0')
        >>> c.power(Decimal('-Infinity'), Decimal('0'))
        Decimal('1')
        >>> c.power(Decimal('-Infinity'), Decimal('1'))
        Decimal('-Infinity')
        >>> c.power(Decimal('-Infinity'), Decimal('2'))
        Decimal('Infinity')
        >>> c.power(Decimal('0'), Decimal('0'))
        Decimal('NaN')

        >>> c.power(Decimal('3'), Decimal('7'), Decimal('16'))
        Decimal('11')
        >>> c.power(Decimal('-3'), Decimal('7'), Decimal('16'))
        Decimal('-11')
        >>> c.power(Decimal('-3'), Decimal('8'), Decimal('16'))
        Decimal('1')
        >>> c.power(Decimal('3'), Decimal('7'), Decimal('-16'))
        Decimal('11')
        >>> c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))
        Decimal('11729830')
        >>> c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))
        Decimal('-0')
        >>> c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))
        Decimal('1')
        >>> ExtendedContext.power(7, 7)
        Decimal('823543')
        >>> ExtendedContext.power(Decimal(7), 7)
        Decimal('823543')
        >>> ExtendedContext.power(7, Decimal(7), 2)
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__pow__(b, modulo, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def quantize(self, a, b):
        """Returns a value equal to 'a' (rounded), having the exponent of 'b'.

        The coefficient of the result is derived from that of the left-hand
        operand.  It may be rounded using the current rounding setting (if the
        exponent is being increased), multiplied by a positive power of ten (if
        the exponent is being decreased), or is unchanged (if the exponent is
        already equal to that of the right-hand operand).

        Unlike other operations, if the length of the coefficient after the
        quantize operation would be greater than precision then an Invalid
        operation condition is raised.  This guarantees that, unless there is
        an error condition, the exponent of the result of a quantize is always
        equal to that of the right-hand operand.

        Also unlike other operations, quantize will never raise Underflow, even
        if the result is subnormal and inexact.

        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))
        Decimal('2.170')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))
        Decimal('2.17')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))
        Decimal('2.2')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))
        Decimal('2')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))
        Decimal('0E+1')
        >>> ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))
        Decimal('-Infinity')
        >>> ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))
        Decimal('NaN')
        >>> ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))
        Decimal('-0')
        >>> ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))
        Decimal('-0E+5')
        >>> ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))
        Decimal('NaN')
        >>> ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))
        Decimal('NaN')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))
        Decimal('217.0')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))
        Decimal('217')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))
        Decimal('2.2E+2')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))
        Decimal('2E+2')
        >>> ExtendedContext.quantize(1, 2)
        Decimal('1')
        >>> ExtendedContext.quantize(Decimal(1), 2)
        Decimal('1')
        >>> ExtendedContext.quantize(1, Decimal(2))
        Decimal('1')
        """
        a = _convert_other(a, raiseit=True)
        return a.quantize(b, context=self)

    def radix(self):
        """Just returns 10, as this is Decimal, :)

        >>> ExtendedContext.radix()
        Decimal('10')
        """
        return Decimal(10)

    def remainder(self, a, b):
        """Returns the remainder from integer division.

        The result is the residue of the dividend after the operation of
        calculating integer division as described for divide-integer, rounded
        to precision digits if necessary.  The sign of the result, if
        non-zero, is the same as that of the original dividend.

        This operation will fail under the same conditions as integer division
        (that is, if integer division on the same two operands would fail, the
        remainder cannot be calculated).

        >>> ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))
        Decimal('2.1')
        >>> ExtendedContext.remainder(Decimal('10'), Decimal('3'))
        Decimal('1')
        >>> ExtendedContext.remainder(Decimal('-10'), Decimal('3'))
        Decimal('-1')
        >>> ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))
        Decimal('0.2')
        >>> ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))
        Decimal('0.1')
        >>> ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))
        Decimal('1.0')
        >>> ExtendedContext.remainder(22, 6)
        Decimal('4')
        >>> ExtendedContext.remainder(Decimal(22), 6)
        Decimal('4')
        >>> ExtendedContext.remainder(22, Decimal(6))
        Decimal('4')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__mod__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def remainder_near(self, a, b):
        """Returns to be "a - b * n", where n is the integer nearest the exact
        value of "x / b" (if two integers are equally near then the even one
        is chosen).  If the result is equal to 0 then its sign will be the
        sign of a.

        This operation will fail under the same conditions as integer division
        (that is, if integer division on the same two operands would fail, the
        remainder cannot be calculated).

        >>> ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))
        Decimal('-0.9')
        >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))
        Decimal('-2')
        >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))
        Decimal('1')
        >>> ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))
        Decimal('-1')
        >>> ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))
        Decimal('0.2')
        >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))
        Decimal('0.1')
        >>> ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))
        Decimal('-0.3')
        >>> ExtendedContext.remainder_near(3, 11)
        Decimal('3')
        >>> ExtendedContext.remainder_near(Decimal(3), 11)
        Decimal('3')
        >>> ExtendedContext.remainder_near(3, Decimal(11))
        Decimal('3')
        """
        a = _convert_other(a, raiseit=True)
        return a.remainder_near(b, context=self)

    def rotate(self, a, b):
        """Returns a rotated copy of a, b times.

        The coefficient of the result is a rotated copy of the digits in
        the coefficient of the first operand.  The number of places of
        rotation is taken from the absolute value of the second operand,
        with the rotation being to the left if the second operand is
        positive or to the right otherwise.

        >>> ExtendedContext.rotate(Decimal('34'), Decimal('8'))
        Decimal('400000003')
        >>> ExtendedContext.rotate(Decimal('12'), Decimal('9'))
        Decimal('12')
        >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))
        Decimal('891234567')
        >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))
        Decimal('123456789')
        >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))
        Decimal('345678912')
        >>> ExtendedContext.rotate(1333333, 1)
        Decimal('13333330')
        >>> ExtendedContext.rotate(Decimal(1333333), 1)
        Decimal('13333330')
        >>> ExtendedContext.rotate(1333333, Decimal(1))
        Decimal('13333330')
        """
        a = _convert_other(a, raiseit=True)
        return a.rotate(b, context=self)

    def same_quantum(self, a, b):
        """Returns True if the two operands have the same exponent.

        The result is never affected by either the sign or the coefficient of
        either operand.

        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))
        False
        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))
        True
        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))
        False
        >>> ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))
        True
        >>> ExtendedContext.same_quantum(10000, -1)
        True
        >>> ExtendedContext.same_quantum(Decimal(10000), -1)
        True
        >>> ExtendedContext.same_quantum(10000, Decimal(-1))
        True
        """
        a = _convert_other(a, raiseit=True)
        return a.same_quantum(b)

    def scaleb (self, a, b):
        """Returns the first operand after adding the second value its exp.

        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))
        Decimal('0.0750')
        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))
        Decimal('7.50')
        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))
        Decimal('7.50E+3')
        >>> ExtendedContext.scaleb(1, 4)
        Decimal('1E+4')
        >>> ExtendedContext.scaleb(Decimal(1), 4)
        Decimal('1E+4')
        >>> ExtendedContext.scaleb(1, Decimal(4))
        Decimal('1E+4')
        """
        a = _convert_other(a, raiseit=True)
        return a.scaleb(b, context=self)

    def shift(self, a, b):
        """Returns a shifted copy of a, b times.

        The coefficient of the result is a shifted copy of the digits
        in the coefficient of the first operand.  The number of places
        to shift is taken from the absolute value of the second operand,
        with the shift being to the left if the second operand is
        positive or to the right otherwise.  Digits shifted into the
        coefficient are zeros.

        >>> ExtendedContext.shift(Decimal('34'), Decimal('8'))
        Decimal('400000000')
        >>> ExtendedContext.shift(Decimal('12'), Decimal('9'))
        Decimal('0')
        >>> ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))
        Decimal('1234567')
        >>> ExtendedContext.shift(Decimal('123456789'), Decimal('0'))
        Decimal('123456789')
        >>> ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))
        Decimal('345678900')
        >>> ExtendedContext.shift(88888888, 2)
        Decimal('888888800')
        >>> ExtendedContext.shift(Decimal(88888888), 2)
        Decimal('888888800')
        >>> ExtendedContext.shift(88888888, Decimal(2))
        Decimal('888888800')
        """
        a = _convert_other(a, raiseit=True)
        return a.shift(b, context=self)

    def sqrt(self, a):
        """Square root of a non-negative number to context precision.

        If the result must be inexact, it is rounded using the round-half-even
        algorithm.

        >>> ExtendedContext.sqrt(Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.sqrt(Decimal('-0'))
        Decimal('-0')
        >>> ExtendedContext.sqrt(Decimal('0.39'))
        Decimal('0.624499800')
        >>> ExtendedContext.sqrt(Decimal('100'))
        Decimal('10')
        >>> ExtendedContext.sqrt(Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.sqrt(Decimal('1.0'))
        Decimal('1.0')
        >>> ExtendedContext.sqrt(Decimal('1.00'))
        Decimal('1.0')
        >>> ExtendedContext.sqrt(Decimal('7'))
        Decimal('2.64575131')
        >>> ExtendedContext.sqrt(Decimal('10'))
        Decimal('3.16227766')
        >>> ExtendedContext.sqrt(2)
        Decimal('1.41421356')
        >>> ExtendedContext.prec
        9
        """
        a = _convert_other(a, raiseit=True)
        return a.sqrt(context=self)

    def subtract(self, a, b):
        """Return the difference between the two operands.

        >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))
        Decimal('0.23')
        >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))
        Decimal('0.00')
        >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))
        Decimal('-0.77')
        >>> ExtendedContext.subtract(8, 5)
        Decimal('3')
        >>> ExtendedContext.subtract(Decimal(8), 5)
        Decimal('3')
        >>> ExtendedContext.subtract(8, Decimal(5))
        Decimal('3')
        """
        a = _convert_other(a, raiseit=True)
        r = a.__sub__(b, context=self)
        if r is NotImplemented:
            raise TypeError("Unable to convert %s to Decimal" % b)
        else:
            return r

    def to_eng_string(self, a):
        """Converts a number to a string, using scientific notation.

        The operation is not affected by the context.
        """
        a = _convert_other(a, raiseit=True)
        return a.to_eng_string(context=self)

    def to_sci_string(self, a):
        """Converts a number to a string, using scientific notation.

        The operation is not affected by the context.
        """
        a = _convert_other(a, raiseit=True)
        return a.__str__(context=self)

    def to_integral_exact(self, a):
        """Rounds to an integer.

        When the operand has a negative exponent, the result is the same
        as using the quantize() operation using the given operand as the
        left-hand-operand, 1E+0 as the right-hand-operand, and the precision
        of the operand as the precision setting; Inexact and Rounded flags
        are allowed in this operation.  The rounding mode is taken from the
        context.

        >>> ExtendedContext.to_integral_exact(Decimal('2.1'))
        Decimal('2')
        >>> ExtendedContext.to_integral_exact(Decimal('100'))
        Decimal('100')
        >>> ExtendedContext.to_integral_exact(Decimal('100.0'))
        Decimal('100')
        >>> ExtendedContext.to_integral_exact(Decimal('101.5'))
        Decimal('102')
        >>> ExtendedContext.to_integral_exact(Decimal('-101.5'))
        Decimal('-102')
        >>> ExtendedContext.to_integral_exact(Decimal('10E+5'))
        Decimal('1.0E+6')
        >>> ExtendedContext.to_integral_exact(Decimal('7.89E+77'))
        Decimal('7.89E+77')
        >>> ExtendedContext.to_integral_exact(Decimal('-Inf'))
        Decimal('-Infinity')
        """
        a = _convert_other(a, raiseit=True)
        return a.to_integral_exact(context=self)

    def to_integral_value(self, a):
        """Rounds to an integer.

        When the operand has a negative exponent, the result is the same
        as using the quantize() operation using the given operand as the
        left-hand-operand, 1E+0 as the right-hand-operand, and the precision
        of the operand as the precision setting, except that no flags will
        be set.  The rounding mode is taken from the context.

        >>> ExtendedContext.to_integral_value(Decimal('2.1'))
        Decimal('2')
        >>> ExtendedContext.to_integral_value(Decimal('100'))
        Decimal('100')
        >>> ExtendedContext.to_integral_value(Decimal('100.0'))
        Decimal('100')
        >>> ExtendedContext.to_integral_value(Decimal('101.5'))
        Decimal('102')
        >>> ExtendedContext.to_integral_value(Decimal('-101.5'))
        Decimal('-102')
        >>> ExtendedContext.to_integral_value(Decimal('10E+5'))
        Decimal('1.0E+6')
        >>> ExtendedContext.to_integral_value(Decimal('7.89E+77'))
        Decimal('7.89E+77')
        >>> ExtendedContext.to_integral_value(Decimal('-Inf'))
        Decimal('-Infinity')
        """
        a = _convert_other(a, raiseit=True)
        return a.to_integral_value(context=self)

    # the method name changed, but we provide also the old one, for compatibility
    to_integral = to_integral_value

class _WorkRep(object):
    __slots__ = ('sign','int','exp')
    # sign: 0 or 1
    # int:  int
    # exp:  None, int, or string

    def __init__(self, value=None):
        if value is None:
            self.sign = None
            self.int = 0
            self.exp = None
        elif isinstance(value, Decimal):
            self.sign = value._sign
            self.int = int(value._int)
            self.exp = value._exp
        else:
            # assert isinstance(value, tuple)
            self.sign = value[0]
            self.int = value[1]
            self.exp = value[2]

    def __repr__(self):
        return "(%r, %r, %r)" % (self.sign, self.int, self.exp)

    __str__ = __repr__



def _normalize(op1, op2, prec = 0):
    """Normalizes op1, op2 to have the same exp and length of coefficient.

    Done during addition.
    """
    if op1.exp < op2.exp:
        tmp = op2
        other = op1
    else:
        tmp = op1
        other = op2

    # Let exp = min(tmp.exp - 1, tmp.adjusted() - precision - 1).
    # Then adding 10**exp to tmp has the same effect (after rounding)
    # as adding any positive quantity smaller than 10**exp; similarly
    # for subtraction.  So if other is smaller than 10**exp we replace
    # it with 10**exp.  This avoids tmp.exp - other.exp getting too large.
    tmp_len = len(str(tmp.int))
    other_len = len(str(other.int))
    exp = tmp.exp + min(-1, tmp_len - prec - 2)
    if other_len + other.exp - 1 < exp:
        other.int = 1
        other.exp = exp

    tmp.int *= 10 ** (tmp.exp - other.exp)
    tmp.exp = other.exp
    return op1, op2

##### Integer arithmetic functions used by ln, log10, exp and __pow__ #####

_nbits = int.bit_length

def _decimal_lshift_exact(n, e):
    """ Given integers n and e, return n * 10**e if it's an integer, else None.

    The computation is designed to avoid computing large powers of 10
    unnecessarily.

    >>> _decimal_lshift_exact(3, 4)
    30000
    >>> _decimal_lshift_exact(300, -999999999)  # returns None

    """
    if n == 0:
        return 0
    elif e >= 0:
        return n * 10**e
    else:
        # val_n = largest power of 10 dividing n.
        str_n = str(abs(n))
        val_n = len(str_n) - len(str_n.rstrip('0'))
        return None if val_n < -e else n // 10**-e

def _sqrt_nearest(n, a):
    """Closest integer to the square root of the positive integer n.  a is
    an initial approximation to the square root.  Any positive integer
    will do for a, but the closer a is to the square root of n the
    faster convergence will be.

    """
    if n <= 0 or a <= 0:
        raise ValueError("Both arguments to _sqrt_nearest should be positive.")

    b=0
    while a != b:
        b, a = a, a--n//a>>1
    return a

def _rshift_nearest(x, shift):
    """Given an integer x and a nonnegative integer shift, return closest
    integer to x / 2**shift; use round-to-even in case of a tie.

    """
    b, q = 1 << shift, x >> shift
    return q + (2*(x & (b-1)) + (q&1) > b)

def _div_nearest(a, b):
    """Closest integer to a/b, a and b positive integers; rounds to even
    in the case of a tie.

    """
    q, r = divmod(a, b)
    return q + (2*r + (q&1) > b)

def _ilog(x, M, L = 8):
    """Integer approximation to M*log(x/M), with absolute error boundable
    in terms only of x/M.

    Given positive integers x and M, return an integer approximation to
    M * log(x/M).  For L = 8 and 0.1 <= x/M <= 10 the difference
    between the approximation and the exact result is at most 22.  For
    L = 8 and 1.0 <= x/M <= 10.0 the difference is at most 15.  In
    both cases these are upper bounds on the error; it will usually be
    much smaller."""

    # The basic algorithm is the following: let log1p be the function
    # log1p(x) = log(1+x).  Then log(x/M) = log1p((x-M)/M).  We use
    # the reduction
    #
    #    log1p(y) = 2*log1p(y/(1+sqrt(1+y)))
    #
    # repeatedly until the argument to log1p is small (< 2**-L in
    # absolute value).  For small y we can use the Taylor series
    # expansion
    #
    #    log1p(y) ~ y - y**2/2 + y**3/3 - ... - (-y)**T/T
    #
    # truncating at T such that y**T is small enough.  The whole
    # computation is carried out in a form of fixed-point arithmetic,
    # with a real number z being represented by an integer
    # approximation to z*M.  To avoid loss of precision, the y below
    # is actually an integer approximation to 2**R*y*M, where R is the
    # number of reductions performed so far.

    y = x-M
    # argument reduction; R = number of reductions performed
    R = 0
    while (R <= L and abs(y) << L-R >= M or
           R > L and abs(y) >> R-L >= M):
        y = _div_nearest((M*y) << 1,
                         M + _sqrt_nearest(M*(M+_rshift_nearest(y, R)), M))
        R += 1

    # Taylor series with T terms
    T = -int(-10*len(str(M))//(3*L))
    yshift = _rshift_nearest(y, R)
    w = _div_nearest(M, T)
    for k in range(T-1, 0, -1):
        w = _div_nearest(M, k) - _div_nearest(yshift*w, M)

    return _div_nearest(w*y, M)

def _dlog10(c, e, p):
    """Given integers c, e and p with c > 0, p >= 0, compute an integer
    approximation to 10**p * log10(c*10**e), with an absolute error of
    at most 1.  Assumes that c*10**e is not exactly 1."""

    # increase precision by 2; compensate for this by dividing
    # final result by 100
    p += 2

    # write c*10**e as d*10**f with either:
    #   f >= 0 and 1 <= d <= 10, or
    #   f <= 0 and 0.1 <= d <= 1.
    # Thus for c*10**e close to 1, f = 0
    l = len(str(c))
    f = e+l - (e+l >= 1)

    if p > 0:
        M = 10**p
        k = e+p-f
        if k >= 0:
            c *= 10**k
        else:
            c = _div_nearest(c, 10**-k)

        log_d = _ilog(c, M) # error < 5 + 22 = 27
        log_10 = _log10_digits(p) # error < 1
        log_d = _div_nearest(log_d*M, log_10)
        log_tenpower = f*M # exact
    else:
        log_d = 0  # error < 2.31
        log_tenpower = _div_nearest(f, 10**-p) # error < 0.5

    return _div_nearest(log_tenpower+log_d, 100)

def _dlog(c, e, p):
    """Given integers c, e and p with c > 0, compute an integer
    approximation to 10**p * log(c*10**e), with an absolute error of
    at most 1.  Assumes that c*10**e is not exactly 1."""

    # Increase precision by 2. The precision increase is compensated
    # for at the end with a division by 100.
    p += 2

    # rewrite c*10**e as d*10**f with either f >= 0 and 1 <= d <= 10,
    # or f <= 0 and 0.1 <= d <= 1.  Then we can compute 10**p * log(c*10**e)
    # as 10**p * log(d) + 10**p*f * log(10).
    l = len(str(c))
    f = e+l - (e+l >= 1)

    # compute approximation to 10**p*log(d), with error < 27
    if p > 0:
        k = e+p-f
        if k >= 0:
            c *= 10**k
        else:
            c = _div_nearest(c, 10**-k)  # error of <= 0.5 in c

        # _ilog magnifies existing error in c by a factor of at most 10
        log_d = _ilog(c, 10**p) # error < 5 + 22 = 27
    else:
        # p <= 0: just approximate the whole thing by 0; error < 2.31
        log_d = 0

    # compute approximation to f*10**p*log(10), with error < 11.
    if f:
        extra = len(str(abs(f)))-1
        if p + extra >= 0:
            # error in f * _log10_digits(p+extra) < |f| * 1 = |f|
            # after division, error < |f|/10**extra + 0.5 < 10 + 0.5 < 11
            f_log_ten = _div_nearest(f*_log10_digits(p+extra), 10**extra)
        else:
            f_log_ten = 0
    else:
        f_log_ten = 0

    # error in sum < 11+27 = 38; error after division < 0.38 + 0.5 < 1
    return _div_nearest(f_log_ten + log_d, 100)

class _Log10Memoize(object):
    """Class to compute, store, and allow retrieval of, digits of the
    constant log(10) = 2.302585....  This constant is needed by
    Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__."""
    def __init__(self):
        self.digits = "23025850929940456840179914546843642076011014886"

    def getdigits(self, p):
        """Given an integer p >= 0, return floor(10**p)*log(10).

        For example, self.getdigits(3) returns 2302.
        """
        # digits are stored as a string, for quick conversion to
        # integer in the case that we've already computed enough
        # digits; the stored digits should always be correct
        # (truncated, not rounded to nearest).
        if p < 0:
            raise ValueError("p should be nonnegative")

        if p >= len(self.digits):
            # compute p+3, p+6, p+9, ... digits; continue until at
            # least one of the extra digits is nonzero
            extra = 3
            while True:
                # compute p+extra digits, correct to within 1ulp
                M = 10**(p+extra+2)
                digits = str(_div_nearest(_ilog(10*M, M), 100))
                if digits[-extra:] != '0'*extra:
                    break
                extra += 3
            # keep all reliable digits so far; remove trailing zeros
            # and next nonzero digit
            self.digits = digits.rstrip('0')[:-1]
        return int(self.digits[:p+1])

_log10_digits = _Log10Memoize().getdigits

def _iexp(x, M, L=8):
    """Given integers x and M, M > 0, such that x/M is small in absolute
    value, compute an integer approximation to M*exp(x/M).  For 0 <=
    x/M <= 2.4, the absolute error in the result is bounded by 60 (and
    is usually much smaller)."""

    # Algorithm: to compute exp(z) for a real number z, first divide z
    # by a suitable power R of 2 so that |z/2**R| < 2**-L.  Then
    # compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor
    # series
    #
    #     expm1(x) = x + x**2/2! + x**3/3! + ...
    #
    # Now use the identity
    #
    #     expm1(2x) = expm1(x)*(expm1(x)+2)
    #
    # R times to compute the sequence expm1(z/2**R),
    # expm1(z/2**(R-1)), ... , exp(z/2), exp(z).

    # Find R such that x/2**R/M <= 2**-L
    R = _nbits((x<<L)//M)

    # Taylor series.  (2**L)**T > M
    T = -int(-10*len(str(M))//(3*L))
    y = _div_nearest(x, T)
    Mshift = M<<R
    for i in range(T-1, 0, -1):
        y = _div_nearest(x*(Mshift + y), Mshift * i)

    # Expansion
    for k in range(R-1, -1, -1):
        Mshift = M<<(k+2)
        y = _div_nearest(y*(y+Mshift), Mshift)

    return M+y

def _dexp(c, e, p):
    """Compute an approximation to exp(c*10**e), with p decimal places of
    precision.

    Returns integers d, f such that:

      10**(p-1) <= d <= 10**p, and
      (d-1)*10**f < exp(c*10**e) < (d+1)*10**f

    In other words, d*10**f is an approximation to exp(c*10**e) with p
    digits of precision, and with an error in d of at most 1.  This is
    almost, but not quite, the same as the error being < 1ulp: when d
    = 10**(p-1) the error could be up to 10 ulp."""

    # we'll call iexp with M = 10**(p+2), giving p+3 digits of precision
    p += 2

    # compute log(10) with extra precision = adjusted exponent of c*10**e
    extra = max(0, e + len(str(c)) - 1)
    q = p + extra

    # compute quotient c*10**e/(log(10)) = c*10**(e+q)/(log(10)*10**q),
    # rounding down
    shift = e+q
    if shift >= 0:
        cshift = c*10**shift
    else:
        cshift = c//10**-shift
    quot, rem = divmod(cshift, _log10_digits(q))

    # reduce remainder back to original precision
    rem = _div_nearest(rem, 10**extra)

    # error in result of _iexp < 120;  error after division < 0.62
    return _div_nearest(_iexp(rem, 10**p), 1000), quot - p + 3

def _dpower(xc, xe, yc, ye, p):
    """Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and
    y = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:

      10**(p-1) <= c <= 10**p, and
      (c-1)*10**e < x**y < (c+1)*10**e

    in other words, c*10**e is an approximation to x**y with p digits
    of precision, and with an error in c of at most 1.  (This is
    almost, but not quite, the same as the error being < 1ulp: when c
    == 10**(p-1) we can only guarantee error < 10ulp.)

    We assume that: x is positive and not equal to 1, and y is nonzero.
    """

    # Find b such that 10**(b-1) <= |y| <= 10**b
    b = len(str(abs(yc))) + ye

    # log(x) = lxc*10**(-p-b-1), to p+b+1 places after the decimal point
    lxc = _dlog(xc, xe, p+b+1)

    # compute product y*log(x) = yc*lxc*10**(-p-b-1+ye) = pc*10**(-p-1)
    shift = ye-b
    if shift >= 0:
        pc = lxc*yc*10**shift
    else:
        pc = _div_nearest(lxc*yc, 10**-shift)

    if pc == 0:
        # we prefer a result that isn't exactly 1; this makes it
        # easier to compute a correctly rounded result in __pow__
        if ((len(str(xc)) + xe >= 1) == (yc > 0)): # if x**y > 1:
            coeff, exp = 10**(p-1)+1, 1-p
        else:
            coeff, exp = 10**p-1, -p
    else:
        coeff, exp = _dexp(pc, -(p+1), p+1)
        coeff = _div_nearest(coeff, 10)
        exp += 1

    return coeff, exp

def _log10_lb(c, correction = {
        '1': 100, '2': 70, '3': 53, '4': 40, '5': 31,
        '6': 23, '7': 16, '8': 10, '9': 5}):
    """Compute a lower bound for 100*log10(c) for a positive integer c."""
    if c <= 0:
        raise ValueError("The argument to _log10_lb should be nonnegative.")
    str_c = str(c)
    return 100*len(str_c) - correction[str_c[0]]

##### Helper Functions ####################################################

def _convert_other(other, raiseit=False, allow_float=False):
    """Convert other to Decimal.

    Verifies that it's ok to use in an implicit construction.
    If allow_float is true, allow conversion from float;  this
    is used in the comparison methods (__eq__ and friends).

    """
    if isinstance(other, Decimal):
        return other
    if isinstance(other, int):
        return Decimal(other)
    if allow_float and isinstance(other, float):
        return Decimal.from_float(other)

    if raiseit:
        raise TypeError("Unable to convert %s to Decimal" % other)
    return NotImplemented

def _convert_for_comparison(self, other, equality_op=False):
    """Given a Decimal instance self and a Python object other, return
    a pair (s, o) of Decimal instances such that "s op o" is
    equivalent to "self op other" for any of the 6 comparison
    operators "op".

    """
    if isinstance(other, Decimal):
        return self, other

    # Comparison with a Rational instance (also includes integers):
    # self op n/d <=> self*d op n (for n and d integers, d positive).
    # A NaN or infinity can be left unchanged without affecting the
    # comparison result.
    if isinstance(other, _numbers.Rational):
        if not self._is_special:
            self = _dec_from_triple(self._sign,
                                    str(int(self._int) * other.denominator),
                                    self._exp)
        return self, Decimal(other.numerator)

    # Comparisons with float and complex types.  == and != comparisons
    # with complex numbers should succeed, returning either True or False
    # as appropriate.  Other comparisons return NotImplemented.
    if equality_op and isinstance(other, _numbers.Complex) and other.imag == 0:
        other = other.real
    if isinstance(other, float):
        context = getcontext()
        if equality_op:
            context.flags[FloatOperation] = 1
        else:
            context._raise_error(FloatOperation,
                "strict semantics for mixing floats and Decimals are enabled")
        return self, Decimal.from_float(other)
    return NotImplemented, NotImplemented


##### Setup Specific Contexts ############################################

# The default context prototype used by Context()
# Is mutable, so that new contexts can have different default values

DefaultContext = Context(
        prec=28, rounding=ROUND_HALF_EVEN,
        traps=[DivisionByZero, Overflow, InvalidOperation],
        flags=[],
        Emax=999999,
        Emin=-999999,
        capitals=1,
        clamp=0
)

# Pre-made alternate contexts offered by the specification
# Don't change these; the user should be able to select these
# contexts and be able to reproduce results from other implementations
# of the spec.

BasicContext = Context(
        prec=9, rounding=ROUND_HALF_UP,
        traps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow],
        flags=[],
)

ExtendedContext = Context(
        prec=9, rounding=ROUND_HALF_EVEN,
        traps=[],
        flags=[],
)


##### crud for parsing strings #############################################
#
# Regular expression used for parsing numeric strings.  Additional
# comments:
#
# 1. Uncomment the two '\s*' lines to allow leading and/or trailing
# whitespace.  But note that the specification disallows whitespace in
# a numeric string.
#
# 2. For finite numbers (not infinities and NaNs) the body of the
# number between the optional sign and the optional exponent must have
# at least one decimal digit, possibly after the decimal point.  The
# lookahead expression '(?=\d|\.\d)' checks this.

import re
_parser = re.compile(r"""        # A numeric string consists of:
#    \s*
    (?P<sign>[-+])?              # an optional sign, followed by either...
    (
        (?=\d|\.\d)              # ...a number (with at least one digit)
        (?P<int>\d*)             # having a (possibly empty) integer part
        (\.(?P<frac>\d*))?       # followed by an optional fractional part
        (E(?P<exp>[-+]?\d+))?    # followed by an optional exponent, or...
    |
        Inf(inity)?              # ...an infinity, or...
    |
        (?P<signal>s)?           # ...an (optionally signaling)
        NaN                      # NaN
        (?P<diag>\d*)            # with (possibly empty) diagnostic info.
    )
#    \s*
    \Z
""", re.VERBOSE | re.IGNORECASE).match

_all_zeros = re.compile('0*$').match
_exact_half = re.compile('50*$').match

##### PEP3101 support functions ##############################################
# The functions in this section have little to do with the Decimal
# class, and could potentially be reused or adapted for other pure
# Python numeric classes that want to implement __format__
#
# A format specifier for Decimal looks like:
#
#   [[fill]align][sign][#][0][minimumwidth][,][.precision][type]

_parse_format_specifier_regex = re.compile(r"""\A
(?:
   (?P<fill>.)?
   (?P<align>[<>=^])
)?
(?P<sign>[-+ ])?
(?P<alt>\#)?
(?P<zeropad>0)?
(?P<minimumwidth>(?!0)\d+)?
(?P<thousands_sep>,)?
(?:\.(?P<precision>0|(?!0)\d+))?
(?P<type>[eEfFgGn%])?
\Z
""", re.VERBOSE|re.DOTALL)

del re

# The locale module is only needed for the 'n' format specifier.  The
# rest of the PEP 3101 code functions quite happily without it, so we
# don't care too much if locale isn't present.
try:
    import locale as _locale
except ImportError:
    pass

def _parse_format_specifier(format_spec, _localeconv=None):
    """Parse and validate a format specifier.

    Turns a standard numeric format specifier into a dict, with the
    following entries:

      fill: fill character to pad field to minimum width
      align: alignment type, either '<', '>', '=' or '^'
      sign: either '+', '-' or ' '
      minimumwidth: nonnegative integer giving minimum width
      zeropad: boolean, indicating whether to pad with zeros
      thousands_sep: string to use as thousands separator, or ''
      grouping: grouping for thousands separators, in format
        used by localeconv
      decimal_point: string to use for decimal point
      precision: nonnegative integer giving precision, or None
      type: one of the characters 'eEfFgG%', or None

    """
    m = _parse_format_specifier_regex.match(format_spec)
    if m is None:
        raise ValueError("Invalid format specifier: " + format_spec)

    # get the dictionary
    format_dict = m.groupdict()

    # zeropad; defaults for fill and alignment.  If zero padding
    # is requested, the fill and align fields should be absent.
    fill = format_dict['fill']
    align = format_dict['align']
    format_dict['zeropad'] = (format_dict['zeropad'] is not None)
    if format_dict['zeropad']:
        if fill is not None:
            raise ValueError("Fill character conflicts with '0'"
                             " in format specifier: " + format_spec)
        if align is not None:
            raise ValueError("Alignment conflicts with '0' in "
                             "format specifier: " + format_spec)
    format_dict['fill'] = fill or ' '
    # PEP 3101 originally specified that the default alignment should
    # be left;  it was later agreed that right-aligned makes more sense
    # for numeric types.  See http://bugs.python.org/issue6857.
    format_dict['align'] = align or '>'

    # default sign handling: '-' for negative, '' for positive
    if format_dict['sign'] is None:
        format_dict['sign'] = '-'

    # minimumwidth defaults to 0; precision remains None if not given
    format_dict['minimumwidth'] = int(format_dict['minimumwidth'] or '0')
    if format_dict['precision'] is not None:
        format_dict['precision'] = int(format_dict['precision'])

    # if format type is 'g' or 'G' then a precision of 0 makes little
    # sense; convert it to 1.  Same if format type is unspecified.
    if format_dict['precision'] == 0:
        if format_dict['type'] is None or format_dict['type'] in 'gGn':
            format_dict['precision'] = 1

    # determine thousands separator, grouping, and decimal separator, and
    # add appropriate entries to format_dict
    if format_dict['type'] == 'n':
        # apart from separators, 'n' behaves just like 'g'
        format_dict['type'] = 'g'
        if _localeconv is None:
            _localeconv = _locale.localeconv()
        if format_dict['thousands_sep'] is not None:
            raise ValueError("Explicit thousands separator conflicts with "
                             "'n' type in format specifier: " + format_spec)
        format_dict['thousands_sep'] = _localeconv['thousands_sep']
        format_dict['grouping'] = _localeconv['grouping']
        format_dict['decimal_point'] = _localeconv['decimal_point']
    else:
        if format_dict['thousands_sep'] is None:
            format_dict['thousands_sep'] = ''
        format_dict['grouping'] = [3, 0]
        format_dict['decimal_point'] = '.'

    return format_dict

def _format_align(sign, body, spec):
    """Given an unpadded, non-aligned numeric string 'body' and sign
    string 'sign', add padding and alignment conforming to the given
    format specifier dictionary 'spec' (as produced by
    parse_format_specifier).

    """
    # how much extra space do we have to play with?
    minimumwidth = spec['minimumwidth']
    fill = spec['fill']
    padding = fill*(minimumwidth - len(sign) - len(body))

    align = spec['align']
    if align == '<':
        result = sign + body + padding
    elif align == '>':
        result = padding + sign + body
    elif align == '=':
        result = sign + padding + body
    elif align == '^':
        half = len(padding)//2
        result = padding[:half] + sign + body + padding[half:]
    else:
        raise ValueError('Unrecognised alignment field')

    return result

def _group_lengths(grouping):
    """Convert a localeconv-style grouping into a (possibly infinite)
    iterable of integers representing group lengths.

    """
    # The result from localeconv()['grouping'], and the input to this
    # function, should be a list of integers in one of the
    # following three forms:
    #
    #   (1) an empty list, or
    #   (2) nonempty list of positive integers + [0]
    #   (3) list of positive integers + [locale.CHAR_MAX], or

    from itertools import chain, repeat
    if not grouping:
        return []
    elif grouping[-1] == 0 and len(grouping) >= 2:
        return chain(grouping[:-1], repeat(grouping[-2]))
    elif grouping[-1] == _locale.CHAR_MAX:
        return grouping[:-1]
    else:
        raise ValueError('unrecognised format for grouping')

def _insert_thousands_sep(digits, spec, min_width=1):
    """Insert thousands separators into a digit string.

    spec is a dictionary whose keys should include 'thousands_sep' and
    'grouping'; typically it's the result of parsing the format
    specifier using _parse_format_specifier.

    The min_width keyword argument gives the minimum length of the
    result, which will be padded on the left with zeros if necessary.

    If necessary, the zero padding adds an extra '0' on the left to
    avoid a leading thousands separator.  For example, inserting
    commas every three digits in '123456', with min_width=8, gives
    '0,123,456', even though that has length 9.

    """

    sep = spec['thousands_sep']
    grouping = spec['grouping']

    groups = []
    for l in _group_lengths(grouping):
        if l <= 0:
            raise ValueError("group length should be positive")
        # max(..., 1) forces at least 1 digit to the left of a separator
        l = min(max(len(digits), min_width, 1), l)
        groups.append('0'*(l - len(digits)) + digits[-l:])
        digits = digits[:-l]
        min_width -= l
        if not digits and min_width <= 0:
            break
        min_width -= len(sep)
    else:
        l = max(len(digits), min_width, 1)
        groups.append('0'*(l - len(digits)) + digits[-l:])
    return sep.join(reversed(groups))

def _format_sign(is_negative, spec):
    """Determine sign character."""

    if is_negative:
        return '-'
    elif spec['sign'] in ' +':
        return spec['sign']
    else:
        return ''

def _format_number(is_negative, intpart, fracpart, exp, spec):
    """Format a number, given the following data:

    is_negative: true if the number is negative, else false
    intpart: string of digits that must appear before the decimal point
    fracpart: string of digits that must come after the point
    exp: exponent, as an integer
    spec: dictionary resulting from parsing the format specifier

    This function uses the information in spec to:
      insert separators (decimal separator and thousands separators)
      format the sign
      format the exponent
      add trailing '%' for the '%' type
      zero-pad if necessary
      fill and align if necessary
    """

    sign = _format_sign(is_negative, spec)

    if fracpart or spec['alt']:
        fracpart = spec['decimal_point'] + fracpart

    if exp != 0 or spec['type'] in 'eE':
        echar = {'E': 'E', 'e': 'e', 'G': 'E', 'g': 'e'}[spec['type']]
        fracpart += "{0}{1:+}".format(echar, exp)
    if spec['type'] == '%':
        fracpart += '%'

    if spec['zeropad']:
        min_width = spec['minimumwidth'] - len(fracpart) - len(sign)
    else:
        min_width = 0
    intpart = _insert_thousands_sep(intpart, spec, min_width)

    return _format_align(sign, intpart+fracpart, spec)


##### Useful Constants (internal use only) ################################

# Reusable defaults
_Infinity = Decimal('Inf')
_NegativeInfinity = Decimal('-Inf')
_NaN = Decimal('NaN')
_Zero = Decimal(0)
_One = Decimal(1)
_NegativeOne = Decimal(-1)

# _SignedInfinity[sign] is infinity w/ that sign
_SignedInfinity = (_Infinity, _NegativeInfinity)

# Constants related to the hash implementation;  hash(x) is based
# on the reduction of x modulo _PyHASH_MODULUS
_PyHASH_MODULUS = sys.hash_info.modulus
# hash values to use for positive and negative infinities, and nans
_PyHASH_INF = sys.hash_info.inf
_PyHASH_NAN = sys.hash_info.nan

# _PyHASH_10INV is the inverse of 10 modulo the prime _PyHASH_MODULUS
_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)
del sys

try:
    import _decimal
except ImportError:
    pass
else:
    s1 = set(dir())
    s2 = set(dir(_decimal))
    for name in s1 - s2:
        del globals()[name]
    del s1, s2, name
    from _decimal import *

if __name__ == '__main__':
    import doctest, decimal
    doctest.testmod(decimal)
                                                                                                                                                                                                                                   usr/lib/python3.4/difflib.py                                                                        0100644 0000000 0000000 00000237417 12415221636 014363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
Module difflib -- helpers for computing deltas between objects.

Function get_close_matches(word, possibilities, n=3, cutoff=0.6):
    Use SequenceMatcher to return list of the best "good enough" matches.

Function context_diff(a, b):
    For two lists of strings, return a delta in context diff format.

Function ndiff(a, b):
    Return a delta: the difference between `a` and `b` (lists of strings).

Function restore(delta, which):
    Return one of the two sequences that generated an ndiff delta.

Function unified_diff(a, b):
    For two lists of strings, return a delta in unified diff format.

Class SequenceMatcher:
    A flexible class for comparing pairs of sequences of any type.

Class Differ:
    For producing human-readable deltas from sequences of lines of text.

Class HtmlDiff:
    For producing HTML side by side comparison with change highlights.
"""

__all__ = ['get_close_matches', 'ndiff', 'restore', 'SequenceMatcher',
           'Differ','IS_CHARACTER_JUNK', 'IS_LINE_JUNK', 'context_diff',
           'unified_diff', 'HtmlDiff', 'Match']

import heapq
from collections import namedtuple as _namedtuple

Match = _namedtuple('Match', 'a b size')

def _calculate_ratio(matches, length):
    if length:
        return 2.0 * matches / length
    return 1.0

class SequenceMatcher:

    """
    SequenceMatcher is a flexible class for comparing pairs of sequences of
    any type, so long as the sequence elements are hashable.  The basic
    algorithm predates, and is a little fancier than, an algorithm
    published in the late 1980's by Ratcliff and Obershelp under the
    hyperbolic name "gestalt pattern matching".  The basic idea is to find
    the longest contiguous matching subsequence that contains no "junk"
    elements (R-O doesn't address junk).  The same idea is then applied
    recursively to the pieces of the sequences to the left and to the right
    of the matching subsequence.  This does not yield minimal edit
    sequences, but does tend to yield matches that "look right" to people.

    SequenceMatcher tries to compute a "human-friendly diff" between two
    sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
    longest *contiguous* & junk-free matching subsequence.  That's what
    catches peoples' eyes.  The Windows(tm) windiff has another interesting
    notion, pairing up elements that appear uniquely in each sequence.
    That, and the method here, appear to yield more intuitive difference
    reports than does diff.  This method appears to be the least vulnerable
    to synching up on blocks of "junk lines", though (like blank lines in
    ordinary text files, or maybe "<P>" lines in HTML files).  That may be
    because this is the only method of the 3 that has a *concept* of
    "junk" <wink>.

    Example, comparing two strings, and considering blanks to be "junk":

    >>> s = SequenceMatcher(lambda x: x == " ",
    ...                     "private Thread currentThread;",
    ...                     "private volatile Thread currentThread;")
    >>>

    .ratio() returns a float in [0, 1], measuring the "similarity" of the
    sequences.  As a rule of thumb, a .ratio() value over 0.6 means the
    sequences are close matches:

    >>> print(round(s.ratio(), 3))
    0.866
    >>>

    If you're only interested in where the sequences match,
    .get_matching_blocks() is handy:

    >>> for block in s.get_matching_blocks():
    ...     print("a[%d] and b[%d] match for %d elements" % block)
    a[0] and b[0] match for 8 elements
    a[8] and b[17] match for 21 elements
    a[29] and b[38] match for 0 elements

    Note that the last tuple returned by .get_matching_blocks() is always a
    dummy, (len(a), len(b), 0), and this is the only case in which the last
    tuple element (number of elements matched) is 0.

    If you want to know how to change the first sequence into the second,
    use .get_opcodes():

    >>> for opcode in s.get_opcodes():
    ...     print("%6s a[%d:%d] b[%d:%d]" % opcode)
     equal a[0:8] b[0:8]
    insert a[8:8] b[8:17]
     equal a[8:29] b[17:38]

    See the Differ class for a fancy human-friendly file differencer, which
    uses SequenceMatcher both to compare sequences of lines, and to compare
    sequences of characters within similar (near-matching) lines.

    See also function get_close_matches() in this module, which shows how
    simple code building on SequenceMatcher can be used to do useful work.

    Timing:  Basic R-O is cubic time worst case and quadratic time expected
    case.  SequenceMatcher is quadratic time for the worst case and has
    expected-case behavior dependent in a complicated way on how many
    elements the sequences have in common; best case time is linear.

    Methods:

    __init__(isjunk=None, a='', b='')
        Construct a SequenceMatcher.

    set_seqs(a, b)
        Set the two sequences to be compared.

    set_seq1(a)
        Set the first sequence to be compared.

    set_seq2(b)
        Set the second sequence to be compared.

    find_longest_match(alo, ahi, blo, bhi)
        Find longest matching block in a[alo:ahi] and b[blo:bhi].

    get_matching_blocks()
        Return list of triples describing matching subsequences.

    get_opcodes()
        Return list of 5-tuples describing how to turn a into b.

    ratio()
        Return a measure of the sequences' similarity (float in [0,1]).

    quick_ratio()
        Return an upper bound on .ratio() relatively quickly.

    real_quick_ratio()
        Return an upper bound on ratio() very quickly.
    """

    def __init__(self, isjunk=None, a='', b='', autojunk=True):
        """Construct a SequenceMatcher.

        Optional arg isjunk is None (the default), or a one-argument
        function that takes a sequence element and returns true iff the
        element is junk.  None is equivalent to passing "lambda x: 0", i.e.
        no elements are considered to be junk.  For example, pass
            lambda x: x in " \\t"
        if you're comparing lines as sequences of characters, and don't
        want to synch up on blanks or hard tabs.

        Optional arg a is the first of two sequences to be compared.  By
        default, an empty string.  The elements of a must be hashable.  See
        also .set_seqs() and .set_seq1().

        Optional arg b is the second of two sequences to be compared.  By
        default, an empty string.  The elements of b must be hashable. See
        also .set_seqs() and .set_seq2().

        Optional arg autojunk should be set to False to disable the
        "automatic junk heuristic" that treats popular elements as junk
        (see module documentation for more information).
        """

        # Members:
        # a
        #      first sequence
        # b
        #      second sequence; differences are computed as "what do
        #      we need to do to 'a' to change it into 'b'?"
        # b2j
        #      for x in b, b2j[x] is a list of the indices (into b)
        #      at which x appears; junk and popular elements do not appear
        # fullbcount
        #      for x in b, fullbcount[x] == the number of times x
        #      appears in b; only materialized if really needed (used
        #      only for computing quick_ratio())
        # matching_blocks
        #      a list of (i, j, k) triples, where a[i:i+k] == b[j:j+k];
        #      ascending & non-overlapping in i and in j; terminated by
        #      a dummy (len(a), len(b), 0) sentinel
        # opcodes
        #      a list of (tag, i1, i2, j1, j2) tuples, where tag is
        #      one of
        #          'replace'   a[i1:i2] should be replaced by b[j1:j2]
        #          'delete'    a[i1:i2] should be deleted
        #          'insert'    b[j1:j2] should be inserted
        #          'equal'     a[i1:i2] == b[j1:j2]
        # isjunk
        #      a user-supplied function taking a sequence element and
        #      returning true iff the element is "junk" -- this has
        #      subtle but helpful effects on the algorithm, which I'll
        #      get around to writing up someday <0.9 wink>.
        #      DON'T USE!  Only __chain_b uses this.  Use "in self.bjunk".
        # bjunk
        #      the items in b for which isjunk is True.
        # bpopular
        #      nonjunk items in b treated as junk by the heuristic (if used).

        self.isjunk = isjunk
        self.a = self.b = None
        self.autojunk = autojunk
        self.set_seqs(a, b)

    def set_seqs(self, a, b):
        """Set the two sequences to be compared.

        >>> s = SequenceMatcher()
        >>> s.set_seqs("abcd", "bcde")
        >>> s.ratio()
        0.75
        """

        self.set_seq1(a)
        self.set_seq2(b)

    def set_seq1(self, a):
        """Set the first sequence to be compared.

        The second sequence to be compared is not changed.

        >>> s = SequenceMatcher(None, "abcd", "bcde")
        >>> s.ratio()
        0.75
        >>> s.set_seq1("bcde")
        >>> s.ratio()
        1.0
        >>>

        SequenceMatcher computes and caches detailed information about the
        second sequence, so if you want to compare one sequence S against
        many sequences, use .set_seq2(S) once and call .set_seq1(x)
        repeatedly for each of the other sequences.

        See also set_seqs() and set_seq2().
        """

        if a is self.a:
            return
        self.a = a
        self.matching_blocks = self.opcodes = None

    def set_seq2(self, b):
        """Set the second sequence to be compared.

        The first sequence to be compared is not changed.

        >>> s = SequenceMatcher(None, "abcd", "bcde")
        >>> s.ratio()
        0.75
        >>> s.set_seq2("abcd")
        >>> s.ratio()
        1.0
        >>>

        SequenceMatcher computes and caches detailed information about the
        second sequence, so if you want to compare one sequence S against
        many sequences, use .set_seq2(S) once and call .set_seq1(x)
        repeatedly for each of the other sequences.

        See also set_seqs() and set_seq1().
        """

        if b is self.b:
            return
        self.b = b
        self.matching_blocks = self.opcodes = None
        self.fullbcount = None
        self.__chain_b()

    # For each element x in b, set b2j[x] to a list of the indices in
    # b where x appears; the indices are in increasing order; note that
    # the number of times x appears in b is len(b2j[x]) ...
    # when self.isjunk is defined, junk elements don't show up in this
    # map at all, which stops the central find_longest_match method
    # from starting any matching block at a junk element ...
    # b2j also does not contain entries for "popular" elements, meaning
    # elements that account for more than 1 + 1% of the total elements, and
    # when the sequence is reasonably large (>= 200 elements); this can
    # be viewed as an adaptive notion of semi-junk, and yields an enormous
    # speedup when, e.g., comparing program files with hundreds of
    # instances of "return NULL;" ...
    # note that this is only called when b changes; so for cross-product
    # kinds of matches, it's best to call set_seq2 once, then set_seq1
    # repeatedly

    def __chain_b(self):
        # Because isjunk is a user-defined (not C) function, and we test
        # for junk a LOT, it's important to minimize the number of calls.
        # Before the tricks described here, __chain_b was by far the most
        # time-consuming routine in the whole module!  If anyone sees
        # Jim Roskind, thank him again for profile.py -- I never would
        # have guessed that.
        # The first trick is to build b2j ignoring the possibility
        # of junk.  I.e., we don't call isjunk at all yet.  Throwing
        # out the junk later is much cheaper than building b2j "right"
        # from the start.
        b = self.b
        self.b2j = b2j = {}

        for i, elt in enumerate(b):
            indices = b2j.setdefault(elt, [])
            indices.append(i)

        # Purge junk elements
        self.bjunk = junk = set()
        isjunk = self.isjunk
        if isjunk:
            for elt in b2j.keys():
                if isjunk(elt):
                    junk.add(elt)
            for elt in junk: # separate loop avoids separate list of keys
                del b2j[elt]

        # Purge popular elements that are not junk
        self.bpopular = popular = set()
        n = len(b)
        if self.autojunk and n >= 200:
            ntest = n // 100 + 1
            for elt, idxs in b2j.items():
                if len(idxs) > ntest:
                    popular.add(elt)
            for elt in popular: # ditto; as fast for 1% deletion
                del b2j[elt]

    def find_longest_match(self, alo, ahi, blo, bhi):
        """Find longest matching block in a[alo:ahi] and b[blo:bhi].

        If isjunk is not defined:

        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
            alo <= i <= i+k <= ahi
            blo <= j <= j+k <= bhi
        and for all (i',j',k') meeting those conditions,
            k >= k'
            i <= i'
            and if i == i', j <= j'

        In other words, of all maximal matching blocks, return one that
        starts earliest in a, and of all those maximal matching blocks that
        start earliest in a, return the one that starts earliest in b.

        >>> s = SequenceMatcher(None, " abcd", "abcd abcd")
        >>> s.find_longest_match(0, 5, 0, 9)
        Match(a=0, b=4, size=5)

        If isjunk is defined, first the longest matching block is
        determined as above, but with the additional restriction that no
        junk element appears in the block.  Then that block is extended as
        far as possible by matching (only) junk elements on both sides.  So
        the resulting block never matches on junk except as identical junk
        happens to be adjacent to an "interesting" match.

        Here's the same example as before, but considering blanks to be
        junk.  That prevents " abcd" from matching the " abcd" at the tail
        end of the second sequence directly.  Instead only the "abcd" can
        match, and matches the leftmost "abcd" in the second sequence:

        >>> s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
        >>> s.find_longest_match(0, 5, 0, 9)
        Match(a=1, b=0, size=4)

        If no blocks match, return (alo, blo, 0).

        >>> s = SequenceMatcher(None, "ab", "c")
        >>> s.find_longest_match(0, 2, 0, 1)
        Match(a=0, b=0, size=0)
        """

        # CAUTION:  stripping common prefix or suffix would be incorrect.
        # E.g.,
        #    ab
        #    acab
        # Longest matching block is "ab", but if common prefix is
        # stripped, it's "a" (tied with "b").  UNIX(tm) diff does so
        # strip, so ends up claiming that ab is changed to acab by
        # inserting "ca" in the middle.  That's minimal but unintuitive:
        # "it's obvious" that someone inserted "ac" at the front.
        # Windiff ends up at the same place as diff, but by pairing up
        # the unique 'b's and then matching the first two 'a's.

        a, b, b2j, isbjunk = self.a, self.b, self.b2j, self.bjunk.__contains__
        besti, bestj, bestsize = alo, blo, 0
        # find longest junk-free match
        # during an iteration of the loop, j2len[j] = length of longest
        # junk-free match ending with a[i-1] and b[j]
        j2len = {}
        nothing = []
        for i in range(alo, ahi):
            # look at all instances of a[i] in b; note that because
            # b2j has no junk keys, the loop is skipped if a[i] is junk
            j2lenget = j2len.get
            newj2len = {}
            for j in b2j.get(a[i], nothing):
                # a[i] matches b[j]
                if j < blo:
                    continue
                if j >= bhi:
                    break
                k = newj2len[j] = j2lenget(j-1, 0) + 1
                if k > bestsize:
                    besti, bestj, bestsize = i-k+1, j-k+1, k
            j2len = newj2len

        # Extend the best by non-junk elements on each end.  In particular,
        # "popular" non-junk elements aren't in b2j, which greatly speeds
        # the inner loop above, but also means "the best" match so far
        # doesn't contain any junk *or* popular non-junk elements.
        while besti > alo and bestj > blo and \
              not isbjunk(b[bestj-1]) and \
              a[besti-1] == b[bestj-1]:
            besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
        while besti+bestsize < ahi and bestj+bestsize < bhi and \
              not isbjunk(b[bestj+bestsize]) and \
              a[besti+bestsize] == b[bestj+bestsize]:
            bestsize += 1

        # Now that we have a wholly interesting match (albeit possibly
        # empty!), we may as well suck up the matching junk on each
        # side of it too.  Can't think of a good reason not to, and it
        # saves post-processing the (possibly considerable) expense of
        # figuring out what to do with it.  In the case of an empty
        # interesting match, this is clearly the right thing to do,
        # because no other kind of match is possible in the regions.
        while besti > alo and bestj > blo and \
              isbjunk(b[bestj-1]) and \
              a[besti-1] == b[bestj-1]:
            besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
        while besti+bestsize < ahi and bestj+bestsize < bhi and \
              isbjunk(b[bestj+bestsize]) and \
              a[besti+bestsize] == b[bestj+bestsize]:
            bestsize = bestsize + 1

        return Match(besti, bestj, bestsize)

    def get_matching_blocks(self):
        """Return list of triples describing matching subsequences.

        Each triple is of the form (i, j, n), and means that
        a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
        i and in j.  New in Python 2.5, it's also guaranteed that if
        (i, j, n) and (i', j', n') are adjacent triples in the list, and
        the second is not the last triple in the list, then i+n != i' or
        j+n != j'.  IOW, adjacent triples never describe adjacent equal
        blocks.

        The last triple is a dummy, (len(a), len(b), 0), and is the only
        triple with n==0.

        >>> s = SequenceMatcher(None, "abxcd", "abcd")
        >>> list(s.get_matching_blocks())
        [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]
        """

        if self.matching_blocks is not None:
            return self.matching_blocks
        la, lb = len(self.a), len(self.b)

        # This is most naturally expressed as a recursive algorithm, but
        # at least one user bumped into extreme use cases that exceeded
        # the recursion limit on their box.  So, now we maintain a list
        # ('queue`) of blocks we still need to look at, and append partial
        # results to `matching_blocks` in a loop; the matches are sorted
        # at the end.
        queue = [(0, la, 0, lb)]
        matching_blocks = []
        while queue:
            alo, ahi, blo, bhi = queue.pop()
            i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi)
            # a[alo:i] vs b[blo:j] unknown
            # a[i:i+k] same as b[j:j+k]
            # a[i+k:ahi] vs b[j+k:bhi] unknown
            if k:   # if k is 0, there was no matching block
                matching_blocks.append(x)
                if alo < i and blo < j:
                    queue.append((alo, i, blo, j))
                if i+k < ahi and j+k < bhi:
                    queue.append((i+k, ahi, j+k, bhi))
        matching_blocks.sort()

        # It's possible that we have adjacent equal blocks in the
        # matching_blocks list now.  Starting with 2.5, this code was added
        # to collapse them.
        i1 = j1 = k1 = 0
        non_adjacent = []
        for i2, j2, k2 in matching_blocks:
            # Is this block adjacent to i1, j1, k1?
            if i1 + k1 == i2 and j1 + k1 == j2:
                # Yes, so collapse them -- this just increases the length of
                # the first block by the length of the second, and the first
                # block so lengthened remains the block to compare against.
                k1 += k2
            else:
                # Not adjacent.  Remember the first block (k1==0 means it's
                # the dummy we started with), and make the second block the
                # new block to compare against.
                if k1:
                    non_adjacent.append((i1, j1, k1))
                i1, j1, k1 = i2, j2, k2
        if k1:
            non_adjacent.append((i1, j1, k1))

        non_adjacent.append( (la, lb, 0) )
        self.matching_blocks = list(map(Match._make, non_adjacent))
        return self.matching_blocks

    def get_opcodes(self):
        """Return list of 5-tuples describing how to turn a into b.

        Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
        has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
        tuple preceding it, and likewise for j1 == the previous j2.

        The tags are strings, with these meanings:

        'replace':  a[i1:i2] should be replaced by b[j1:j2]
        'delete':   a[i1:i2] should be deleted.
                    Note that j1==j2 in this case.
        'insert':   b[j1:j2] should be inserted at a[i1:i1].
                    Note that i1==i2 in this case.
        'equal':    a[i1:i2] == b[j1:j2]

        >>> a = "qabxcd"
        >>> b = "abycdf"
        >>> s = SequenceMatcher(None, a, b)
        >>> for tag, i1, i2, j1, j2 in s.get_opcodes():
        ...    print(("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %
        ...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2])))
         delete a[0:1] (q) b[0:0] ()
          equal a[1:3] (ab) b[0:2] (ab)
        replace a[3:4] (x) b[2:3] (y)
          equal a[4:6] (cd) b[3:5] (cd)
         insert a[6:6] () b[5:6] (f)
        """

        if self.opcodes is not None:
            return self.opcodes
        i = j = 0
        self.opcodes = answer = []
        for ai, bj, size in self.get_matching_blocks():
            # invariant:  we've pumped out correct diffs to change
            # a[:i] into b[:j], and the next matching block is
            # a[ai:ai+size] == b[bj:bj+size].  So we need to pump
            # out a diff to change a[i:ai] into b[j:bj], pump out
            # the matching block, and move (i,j) beyond the match
            tag = ''
            if i < ai and j < bj:
                tag = 'replace'
            elif i < ai:
                tag = 'delete'
            elif j < bj:
                tag = 'insert'
            if tag:
                answer.append( (tag, i, ai, j, bj) )
            i, j = ai+size, bj+size
            # the list of matching blocks is terminated by a
            # sentinel with size 0
            if size:
                answer.append( ('equal', ai, i, bj, j) )
        return answer

    def get_grouped_opcodes(self, n=3):
        """ Isolate change clusters by eliminating ranges with no changes.

        Return a generator of groups with up to n lines of context.
        Each group is in the same format as returned by get_opcodes().

        >>> from pprint import pprint
        >>> a = list(map(str, range(1,40)))
        >>> b = a[:]
        >>> b[8:8] = ['i']     # Make an insertion
        >>> b[20] += 'x'       # Make a replacement
        >>> b[23:28] = []      # Make a deletion
        >>> b[30] += 'y'       # Make another replacement
        >>> pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))
        [[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],
         [('equal', 16, 19, 17, 20),
          ('replace', 19, 20, 20, 21),
          ('equal', 20, 22, 21, 23),
          ('delete', 22, 27, 23, 23),
          ('equal', 27, 30, 23, 26)],
         [('equal', 31, 34, 27, 30),
          ('replace', 34, 35, 30, 31),
          ('equal', 35, 38, 31, 34)]]
        """

        codes = self.get_opcodes()
        if not codes:
            codes = [("equal", 0, 1, 0, 1)]
        # Fixup leading and trailing groups if they show no changes.
        if codes[0][0] == 'equal':
            tag, i1, i2, j1, j2 = codes[0]
            codes[0] = tag, max(i1, i2-n), i2, max(j1, j2-n), j2
        if codes[-1][0] == 'equal':
            tag, i1, i2, j1, j2 = codes[-1]
            codes[-1] = tag, i1, min(i2, i1+n), j1, min(j2, j1+n)

        nn = n + n
        group = []
        for tag, i1, i2, j1, j2 in codes:
            # End the current group and start a new one whenever
            # there is a large range with no changes.
            if tag == 'equal' and i2-i1 > nn:
                group.append((tag, i1, min(i2, i1+n), j1, min(j2, j1+n)))
                yield group
                group = []
                i1, j1 = max(i1, i2-n), max(j1, j2-n)
            group.append((tag, i1, i2, j1 ,j2))
        if group and not (len(group)==1 and group[0][0] == 'equal'):
            yield group

    def ratio(self):
        """Return a measure of the sequences' similarity (float in [0,1]).

        Where T is the total number of elements in both sequences, and
        M is the number of matches, this is 2.0*M / T.
        Note that this is 1 if the sequences are identical, and 0 if
        they have nothing in common.

        .ratio() is expensive to compute if you haven't already computed
        .get_matching_blocks() or .get_opcodes(), in which case you may
        want to try .quick_ratio() or .real_quick_ratio() first to get an
        upper bound.

        >>> s = SequenceMatcher(None, "abcd", "bcde")
        >>> s.ratio()
        0.75
        >>> s.quick_ratio()
        0.75
        >>> s.real_quick_ratio()
        1.0
        """

        matches = sum(triple[-1] for triple in self.get_matching_blocks())
        return _calculate_ratio(matches, len(self.a) + len(self.b))

    def quick_ratio(self):
        """Return an upper bound on ratio() relatively quickly.

        This isn't defined beyond that it is an upper bound on .ratio(), and
        is faster to compute.
        """

        # viewing a and b as multisets, set matches to the cardinality
        # of their intersection; this counts the number of matches
        # without regard to order, so is clearly an upper bound
        if self.fullbcount is None:
            self.fullbcount = fullbcount = {}
            for elt in self.b:
                fullbcount[elt] = fullbcount.get(elt, 0) + 1
        fullbcount = self.fullbcount
        # avail[x] is the number of times x appears in 'b' less the
        # number of times we've seen it in 'a' so far ... kinda
        avail = {}
        availhas, matches = avail.__contains__, 0
        for elt in self.a:
            if availhas(elt):
                numb = avail[elt]
            else:
                numb = fullbcount.get(elt, 0)
            avail[elt] = numb - 1
            if numb > 0:
                matches = matches + 1
        return _calculate_ratio(matches, len(self.a) + len(self.b))

    def real_quick_ratio(self):
        """Return an upper bound on ratio() very quickly.

        This isn't defined beyond that it is an upper bound on .ratio(), and
        is faster to compute than either .ratio() or .quick_ratio().
        """

        la, lb = len(self.a), len(self.b)
        # can't have more matches than the number of elements in the
        # shorter sequence
        return _calculate_ratio(min(la, lb), la + lb)

def get_close_matches(word, possibilities, n=3, cutoff=0.6):
    """Use SequenceMatcher to return list of the best "good enough" matches.

    word is a sequence for which close matches are desired (typically a
    string).

    possibilities is a list of sequences against which to match word
    (typically a list of strings).

    Optional arg n (default 3) is the maximum number of close matches to
    return.  n must be > 0.

    Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities
    that don't score at least that similar to word are ignored.

    The best (no more than n) matches among the possibilities are returned
    in a list, sorted by similarity score, most similar first.

    >>> get_close_matches("appel", ["ape", "apple", "peach", "puppy"])
    ['apple', 'ape']
    >>> import keyword as _keyword
    >>> get_close_matches("wheel", _keyword.kwlist)
    ['while']
    >>> get_close_matches("Apple", _keyword.kwlist)
    []
    >>> get_close_matches("accept", _keyword.kwlist)
    ['except']
    """

    if not n >  0:
        raise ValueError("n must be > 0: %r" % (n,))
    if not 0.0 <= cutoff <= 1.0:
        raise ValueError("cutoff must be in [0.0, 1.0]: %r" % (cutoff,))
    result = []
    s = SequenceMatcher()
    s.set_seq2(word)
    for x in possibilities:
        s.set_seq1(x)
        if s.real_quick_ratio() >= cutoff and \
           s.quick_ratio() >= cutoff and \
           s.ratio() >= cutoff:
            result.append((s.ratio(), x))

    # Move the best scorers to head of list
    result = heapq.nlargest(n, result)
    # Strip scores for the best n matches
    return [x for score, x in result]

def _count_leading(line, ch):
    """
    Return number of `ch` characters at the start of `line`.

    Example:

    >>> _count_leading('   abc', ' ')
    3
    """

    i, n = 0, len(line)
    while i < n and line[i] == ch:
        i += 1
    return i

class Differ:
    r"""
    Differ is a class for comparing sequences of lines of text, and
    producing human-readable differences or deltas.  Differ uses
    SequenceMatcher both to compare sequences of lines, and to compare
    sequences of characters within similar (near-matching) lines.

    Each line of a Differ delta begins with a two-letter code:

        '- '    line unique to sequence 1
        '+ '    line unique to sequence 2
        '  '    line common to both sequences
        '? '    line not present in either input sequence

    Lines beginning with '? ' attempt to guide the eye to intraline
    differences, and were not present in either input sequence.  These lines
    can be confusing if the sequences contain tab characters.

    Note that Differ makes no claim to produce a *minimal* diff.  To the
    contrary, minimal diffs are often counter-intuitive, because they synch
    up anywhere possible, sometimes accidental matches 100 pages apart.
    Restricting synch points to contiguous matches preserves some notion of
    locality, at the occasional cost of producing a longer diff.

    Example: Comparing two texts.

    First we set up the texts, sequences of individual single-line strings
    ending with newlines (such sequences can also be obtained from the
    `readlines()` method of file-like objects):

    >>> text1 = '''  1. Beautiful is better than ugly.
    ...   2. Explicit is better than implicit.
    ...   3. Simple is better than complex.
    ...   4. Complex is better than complicated.
    ... '''.splitlines(keepends=True)
    >>> len(text1)
    4
    >>> text1[0][-1]
    '\n'
    >>> text2 = '''  1. Beautiful is better than ugly.
    ...   3.   Simple is better than complex.
    ...   4. Complicated is better than complex.
    ...   5. Flat is better than nested.
    ... '''.splitlines(keepends=True)

    Next we instantiate a Differ object:

    >>> d = Differ()

    Note that when instantiating a Differ object we may pass functions to
    filter out line and character 'junk'.  See Differ.__init__ for details.

    Finally, we compare the two:

    >>> result = list(d.compare(text1, text2))

    'result' is a list of strings, so let's pretty-print it:

    >>> from pprint import pprint as _pprint
    >>> _pprint(result)
    ['    1. Beautiful is better than ugly.\n',
     '-   2. Explicit is better than implicit.\n',
     '-   3. Simple is better than complex.\n',
     '+   3.   Simple is better than complex.\n',
     '?     ++\n',
     '-   4. Complex is better than complicated.\n',
     '?            ^                     ---- ^\n',
     '+   4. Complicated is better than complex.\n',
     '?           ++++ ^                      ^\n',
     '+   5. Flat is better than nested.\n']

    As a single multi-line string it looks like this:

    >>> print(''.join(result), end="")
        1. Beautiful is better than ugly.
    -   2. Explicit is better than implicit.
    -   3. Simple is better than complex.
    +   3.   Simple is better than complex.
    ?     ++
    -   4. Complex is better than complicated.
    ?            ^                     ---- ^
    +   4. Complicated is better than complex.
    ?           ++++ ^                      ^
    +   5. Flat is better than nested.

    Methods:

    __init__(linejunk=None, charjunk=None)
        Construct a text differencer, with optional filters.

    compare(a, b)
        Compare two sequences of lines; generate the resulting delta.
    """

    def __init__(self, linejunk=None, charjunk=None):
        """
        Construct a text differencer, with optional filters.

        The two optional keyword parameters are for filter functions:

        - `linejunk`: A function that should accept a single string argument,
          and return true iff the string is junk. The module-level function
          `IS_LINE_JUNK` may be used to filter out lines without visible
          characters, except for at most one splat ('#').  It is recommended
          to leave linejunk None; as of Python 2.3, the underlying
          SequenceMatcher class has grown an adaptive notion of "noise" lines
          that's better than any static definition the author has ever been
          able to craft.

        - `charjunk`: A function that should accept a string of length 1. The
          module-level function `IS_CHARACTER_JUNK` may be used to filter out
          whitespace characters (a blank or tab; **note**: bad idea to include
          newline in this!).  Use of IS_CHARACTER_JUNK is recommended.
        """

        self.linejunk = linejunk
        self.charjunk = charjunk

    def compare(self, a, b):
        r"""
        Compare two sequences of lines; generate the resulting delta.

        Each sequence must contain individual single-line strings ending with
        newlines. Such sequences can be obtained from the `readlines()` method
        of file-like objects.  The delta generated also consists of newline-
        terminated strings, ready to be printed as-is via the writeline()
        method of a file-like object.

        Example:

        >>> print(''.join(Differ().compare('one\ntwo\nthree\n'.splitlines(True),
        ...                                'ore\ntree\nemu\n'.splitlines(True))),
        ...       end="")
        - one
        ?  ^
        + ore
        ?  ^
        - two
        - three
        ?  -
        + tree
        + emu
        """

        cruncher = SequenceMatcher(self.linejunk, a, b)
        for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():
            if tag == 'replace':
                g = self._fancy_replace(a, alo, ahi, b, blo, bhi)
            elif tag == 'delete':
                g = self._dump('-', a, alo, ahi)
            elif tag == 'insert':
                g = self._dump('+', b, blo, bhi)
            elif tag == 'equal':
                g = self._dump(' ', a, alo, ahi)
            else:
                raise ValueError('unknown tag %r' % (tag,))

            yield from g

    def _dump(self, tag, x, lo, hi):
        """Generate comparison results for a same-tagged range."""
        for i in range(lo, hi):
            yield '%s %s' % (tag, x[i])

    def _plain_replace(self, a, alo, ahi, b, blo, bhi):
        assert alo < ahi and blo < bhi
        # dump the shorter block first -- reduces the burden on short-term
        # memory if the blocks are of very different sizes
        if bhi - blo < ahi - alo:
            first  = self._dump('+', b, blo, bhi)
            second = self._dump('-', a, alo, ahi)
        else:
            first  = self._dump('-', a, alo, ahi)
            second = self._dump('+', b, blo, bhi)

        for g in first, second:
            yield from g

    def _fancy_replace(self, a, alo, ahi, b, blo, bhi):
        r"""
        When replacing one block of lines with another, search the blocks
        for *similar* lines; the best-matching pair (if any) is used as a
        synch point, and intraline difference marking is done on the
        similar pair. Lots of work, but often worth it.

        Example:

        >>> d = Differ()
        >>> results = d._fancy_replace(['abcDefghiJkl\n'], 0, 1,
        ...                            ['abcdefGhijkl\n'], 0, 1)
        >>> print(''.join(results), end="")
        - abcDefghiJkl
        ?    ^  ^  ^
        + abcdefGhijkl
        ?    ^  ^  ^
        """

        # don't synch up unless the lines have a similarity score of at
        # least cutoff; best_ratio tracks the best score seen so far
        best_ratio, cutoff = 0.74, 0.75
        cruncher = SequenceMatcher(self.charjunk)
        eqi, eqj = None, None   # 1st indices of equal lines (if any)

        # search for the pair that matches best without being identical
        # (identical lines must be junk lines, & we don't want to synch up
        # on junk -- unless we have to)
        for j in range(blo, bhi):
            bj = b[j]
            cruncher.set_seq2(bj)
            for i in range(alo, ahi):
                ai = a[i]
                if ai == bj:
                    if eqi is None:
                        eqi, eqj = i, j
                    continue
                cruncher.set_seq1(ai)
                # computing similarity is expensive, so use the quick
                # upper bounds first -- have seen this speed up messy
                # compares by a factor of 3.
                # note that ratio() is only expensive to compute the first
                # time it's called on a sequence pair; the expensive part
                # of the computation is cached by cruncher
                if cruncher.real_quick_ratio() > best_ratio and \
                      cruncher.quick_ratio() > best_ratio and \
                      cruncher.ratio() > best_ratio:
                    best_ratio, best_i, best_j = cruncher.ratio(), i, j
        if best_ratio < cutoff:
            # no non-identical "pretty close" pair
            if eqi is None:
                # no identical pair either -- treat it as a straight replace
                yield from self._plain_replace(a, alo, ahi, b, blo, bhi)
                return
            # no close pair, but an identical pair -- synch up on that
            best_i, best_j, best_ratio = eqi, eqj, 1.0
        else:
            # there's a close pair, so forget the identical pair (if any)
            eqi = None

        # a[best_i] very similar to b[best_j]; eqi is None iff they're not
        # identical

        # pump out diffs from before the synch point
        yield from self._fancy_helper(a, alo, best_i, b, blo, best_j)

        # do intraline marking on the synch pair
        aelt, belt = a[best_i], b[best_j]
        if eqi is None:
            # pump out a '-', '?', '+', '?' quad for the synched lines
            atags = btags = ""
            cruncher.set_seqs(aelt, belt)
            for tag, ai1, ai2, bj1, bj2 in cruncher.get_opcodes():
                la, lb = ai2 - ai1, bj2 - bj1
                if tag == 'replace':
                    atags += '^' * la
                    btags += '^' * lb
                elif tag == 'delete':
                    atags += '-' * la
                elif tag == 'insert':
                    btags += '+' * lb
                elif tag == 'equal':
                    atags += ' ' * la
                    btags += ' ' * lb
                else:
                    raise ValueError('unknown tag %r' % (tag,))
            yield from self._qformat(aelt, belt, atags, btags)
        else:
            # the synch pair is identical
            yield '  ' + aelt

        # pump out diffs from after the synch point
        yield from self._fancy_helper(a, best_i+1, ahi, b, best_j+1, bhi)

    def _fancy_helper(self, a, alo, ahi, b, blo, bhi):
        g = []
        if alo < ahi:
            if blo < bhi:
                g = self._fancy_replace(a, alo, ahi, b, blo, bhi)
            else:
                g = self._dump('-', a, alo, ahi)
        elif blo < bhi:
            g = self._dump('+', b, blo, bhi)

        yield from g

    def _qformat(self, aline, bline, atags, btags):
        r"""
        Format "?" output and deal with leading tabs.

        Example:

        >>> d = Differ()
        >>> results = d._qformat('\tabcDefghiJkl\n', '\tabcdefGhijkl\n',
        ...                      '  ^ ^  ^      ', '  ^ ^  ^      ')
        >>> for line in results: print(repr(line))
        ...
        '- \tabcDefghiJkl\n'
        '? \t ^ ^  ^\n'
        '+ \tabcdefGhijkl\n'
        '? \t ^ ^  ^\n'
        """

        # Can hurt, but will probably help most of the time.
        common = min(_count_leading(aline, "\t"),
                     _count_leading(bline, "\t"))
        common = min(common, _count_leading(atags[:common], " "))
        common = min(common, _count_leading(btags[:common], " "))
        atags = atags[common:].rstrip()
        btags = btags[common:].rstrip()

        yield "- " + aline
        if atags:
            yield "? %s%s\n" % ("\t" * common, atags)

        yield "+ " + bline
        if btags:
            yield "? %s%s\n" % ("\t" * common, btags)

# With respect to junk, an earlier version of ndiff simply refused to
# *start* a match with a junk element.  The result was cases like this:
#     before: private Thread currentThread;
#     after:  private volatile Thread currentThread;
# If you consider whitespace to be junk, the longest contiguous match
# not starting with junk is "e Thread currentThread".  So ndiff reported
# that "e volatil" was inserted between the 't' and the 'e' in "private".
# While an accurate view, to people that's absurd.  The current version
# looks for matching blocks that are entirely junk-free, then extends the
# longest one of those as far as possible but only with matching junk.
# So now "currentThread" is matched, then extended to suck up the
# preceding blank; then "private" is matched, and extended to suck up the
# following blank; then "Thread" is matched; and finally ndiff reports
# that "volatile " was inserted before "Thread".  The only quibble
# remaining is that perhaps it was really the case that " volatile"
# was inserted after "private".  I can live with that <wink>.

import re

def IS_LINE_JUNK(line, pat=re.compile(r"\s*#?\s*$").match):
    r"""
    Return 1 for ignorable line: iff `line` is blank or contains a single '#'.

    Examples:

    >>> IS_LINE_JUNK('\n')
    True
    >>> IS_LINE_JUNK('  #   \n')
    True
    >>> IS_LINE_JUNK('hello\n')
    False
    """

    return pat(line) is not None

def IS_CHARACTER_JUNK(ch, ws=" \t"):
    r"""
    Return 1 for ignorable character: iff `ch` is a space or tab.

    Examples:

    >>> IS_CHARACTER_JUNK(' ')
    True
    >>> IS_CHARACTER_JUNK('\t')
    True
    >>> IS_CHARACTER_JUNK('\n')
    False
    >>> IS_CHARACTER_JUNK('x')
    False
    """

    return ch in ws


########################################################################
###  Unified Diff
########################################################################

def _format_range_unified(start, stop):
    'Convert range to the "ed" format'
    # Per the diff spec at http://www.unix.org/single_unix_specification/
    beginning = start + 1     # lines start numbering with one
    length = stop - start
    if length == 1:
        return '{}'.format(beginning)
    if not length:
        beginning -= 1        # empty ranges begin at line just before the range
    return '{},{}'.format(beginning, length)

def unified_diff(a, b, fromfile='', tofile='', fromfiledate='',
                 tofiledate='', n=3, lineterm='\n'):
    r"""
    Compare two sequences of lines; generate the delta as a unified diff.

    Unified diffs are a compact way of showing line changes and a few
    lines of context.  The number of context lines is set by 'n' which
    defaults to three.

    By default, the diff control lines (those with ---, +++, or @@) are
    created with a trailing newline.  This is helpful so that inputs
    created from file.readlines() result in diffs that are suitable for
    file.writelines() since both the inputs and outputs have trailing
    newlines.

    For inputs that do not have trailing newlines, set the lineterm
    argument to "" so that the output will be uniformly newline free.

    The unidiff format normally has a header for filenames and modification
    times.  Any or all of these may be specified using strings for
    'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
    The modification times are normally expressed in the ISO 8601 format.

    Example:

    >>> for line in unified_diff('one two three four'.split(),
    ...             'zero one tree four'.split(), 'Original', 'Current',
    ...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',
    ...             lineterm=''):
    ...     print(line)                 # doctest: +NORMALIZE_WHITESPACE
    --- Original        2005-01-26 23:30:50
    +++ Current         2010-04-02 10:20:52
    @@ -1,4 +1,4 @@
    +zero
     one
    -two
    -three
    +tree
     four
    """

    started = False
    for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):
        if not started:
            started = True
            fromdate = '\t{}'.format(fromfiledate) if fromfiledate else ''
            todate = '\t{}'.format(tofiledate) if tofiledate else ''
            yield '--- {}{}{}'.format(fromfile, fromdate, lineterm)
            yield '+++ {}{}{}'.format(tofile, todate, lineterm)

        first, last = group[0], group[-1]
        file1_range = _format_range_unified(first[1], last[2])
        file2_range = _format_range_unified(first[3], last[4])
        yield '@@ -{} +{} @@{}'.format(file1_range, file2_range, lineterm)

        for tag, i1, i2, j1, j2 in group:
            if tag == 'equal':
                for line in a[i1:i2]:
                    yield ' ' + line
                continue
            if tag in {'replace', 'delete'}:
                for line in a[i1:i2]:
                    yield '-' + line
            if tag in {'replace', 'insert'}:
                for line in b[j1:j2]:
                    yield '+' + line


########################################################################
###  Context Diff
########################################################################

def _format_range_context(start, stop):
    'Convert range to the "ed" format'
    # Per the diff spec at http://www.unix.org/single_unix_specification/
    beginning = start + 1     # lines start numbering with one
    length = stop - start
    if not length:
        beginning -= 1        # empty ranges begin at line just before the range
    if length <= 1:
        return '{}'.format(beginning)
    return '{},{}'.format(beginning, beginning + length - 1)

# See http://www.unix.org/single_unix_specification/
def context_diff(a, b, fromfile='', tofile='',
                 fromfiledate='', tofiledate='', n=3, lineterm='\n'):
    r"""
    Compare two sequences of lines; generate the delta as a context diff.

    Context diffs are a compact way of showing line changes and a few
    lines of context.  The number of context lines is set by 'n' which
    defaults to three.

    By default, the diff control lines (those with *** or ---) are
    created with a trailing newline.  This is helpful so that inputs
    created from file.readlines() result in diffs that are suitable for
    file.writelines() since both the inputs and outputs have trailing
    newlines.

    For inputs that do not have trailing newlines, set the lineterm
    argument to "" so that the output will be uniformly newline free.

    The context diff format normally has a header for filenames and
    modification times.  Any or all of these may be specified using
    strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
    The modification times are normally expressed in the ISO 8601 format.
    If not specified, the strings default to blanks.

    Example:

    >>> print(''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(True),
    ...       'zero\none\ntree\nfour\n'.splitlines(True), 'Original', 'Current')),
    ...       end="")
    *** Original
    --- Current
    ***************
    *** 1,4 ****
      one
    ! two
    ! three
      four
    --- 1,4 ----
    + zero
      one
    ! tree
      four
    """

    prefix = dict(insert='+ ', delete='- ', replace='! ', equal='  ')
    started = False
    for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):
        if not started:
            started = True
            fromdate = '\t{}'.format(fromfiledate) if fromfiledate else ''
            todate = '\t{}'.format(tofiledate) if tofiledate else ''
            yield '*** {}{}{}'.format(fromfile, fromdate, lineterm)
            yield '--- {}{}{}'.format(tofile, todate, lineterm)

        first, last = group[0], group[-1]
        yield '***************' + lineterm

        file1_range = _format_range_context(first[1], last[2])
        yield '*** {} ****{}'.format(file1_range, lineterm)

        if any(tag in {'replace', 'delete'} for tag, _, _, _, _ in group):
            for tag, i1, i2, _, _ in group:
                if tag != 'insert':
                    for line in a[i1:i2]:
                        yield prefix[tag] + line

        file2_range = _format_range_context(first[3], last[4])
        yield '--- {} ----{}'.format(file2_range, lineterm)

        if any(tag in {'replace', 'insert'} for tag, _, _, _, _ in group):
            for tag, _, _, j1, j2 in group:
                if tag != 'delete':
                    for line in b[j1:j2]:
                        yield prefix[tag] + line

def ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK):
    r"""
    Compare `a` and `b` (lists of strings); return a `Differ`-style delta.

    Optional keyword parameters `linejunk` and `charjunk` are for filter
    functions (or None):

    - linejunk: A function that should accept a single string argument, and
      return true iff the string is junk.  The default is None, and is
      recommended; as of Python 2.3, an adaptive notion of "noise" lines is
      used that does a good job on its own.

    - charjunk: A function that should accept a string of length 1. The
      default is module-level function IS_CHARACTER_JUNK, which filters out
      whitespace characters (a blank or tab; note: bad idea to include newline
      in this!).

    Tools/scripts/ndiff.py is a command-line front-end to this function.

    Example:

    >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
    ...              'ore\ntree\nemu\n'.splitlines(keepends=True))
    >>> print(''.join(diff), end="")
    - one
    ?  ^
    + ore
    ?  ^
    - two
    - three
    ?  -
    + tree
    + emu
    """
    return Differ(linejunk, charjunk).compare(a, b)

def _mdiff(fromlines, tolines, context=None, linejunk=None,
           charjunk=IS_CHARACTER_JUNK):
    r"""Returns generator yielding marked up from/to side by side differences.

    Arguments:
    fromlines -- list of text lines to compared to tolines
    tolines -- list of text lines to be compared to fromlines
    context -- number of context lines to display on each side of difference,
               if None, all from/to text lines will be generated.
    linejunk -- passed on to ndiff (see ndiff documentation)
    charjunk -- passed on to ndiff (see ndiff documentation)

    This function returns an iterator which returns a tuple:
    (from line tuple, to line tuple, boolean flag)

    from/to line tuple -- (line num, line text)
        line num -- integer or None (to indicate a context separation)
        line text -- original line text with following markers inserted:
            '\0+' -- marks start of added text
            '\0-' -- marks start of deleted text
            '\0^' -- marks start of changed text
            '\1' -- marks end of added/deleted/changed text

    boolean flag -- None indicates context separation, True indicates
        either "from" or "to" line contains a change, otherwise False.

    This function/iterator was originally developed to generate side by side
    file difference for making HTML pages (see HtmlDiff class for example
    usage).

    Note, this function utilizes the ndiff function to generate the side by
    side difference markup.  Optional ndiff arguments may be passed to this
    function and they in turn will be passed to ndiff.
    """
    import re

    # regular expression for finding intraline change indices
    change_re = re.compile('(\++|\-+|\^+)')

    # create the difference iterator to generate the differences
    diff_lines_iterator = ndiff(fromlines,tolines,linejunk,charjunk)

    def _make_line(lines, format_key, side, num_lines=[0,0]):
        """Returns line of text with user's change markup and line formatting.

        lines -- list of lines from the ndiff generator to produce a line of
                 text from.  When producing the line of text to return, the
                 lines used are removed from this list.
        format_key -- '+' return first line in list with "add" markup around
                          the entire line.
                      '-' return first line in list with "delete" markup around
                          the entire line.
                      '?' return first line in list with add/delete/change
                          intraline markup (indices obtained from second line)
                      None return first line in list with no markup
        side -- indice into the num_lines list (0=from,1=to)
        num_lines -- from/to current line number.  This is NOT intended to be a
                     passed parameter.  It is present as a keyword argument to
                     maintain memory of the current line numbers between calls
                     of this function.

        Note, this function is purposefully not defined at the module scope so
        that data it needs from its parent function (within whose context it
        is defined) does not need to be of module scope.
        """
        num_lines[side] += 1
        # Handle case where no user markup is to be added, just return line of
        # text with user's line format to allow for usage of the line number.
        if format_key is None:
            return (num_lines[side],lines.pop(0)[2:])
        # Handle case of intraline changes
        if format_key == '?':
            text, markers = lines.pop(0), lines.pop(0)
            # find intraline changes (store change type and indices in tuples)
            sub_info = []
            def record_sub_info(match_object,sub_info=sub_info):
                sub_info.append([match_object.group(1)[0],match_object.span()])
                return match_object.group(1)
            change_re.sub(record_sub_info,markers)
            # process each tuple inserting our special marks that won't be
            # noticed by an xml/html escaper.
            for key,(begin,end) in sub_info[::-1]:
                text = text[0:begin]+'\0'+key+text[begin:end]+'\1'+text[end:]
            text = text[2:]
        # Handle case of add/delete entire line
        else:
            text = lines.pop(0)[2:]
            # if line of text is just a newline, insert a space so there is
            # something for the user to highlight and see.
            if not text:
                text = ' '
            # insert marks that won't be noticed by an xml/html escaper.
            text = '\0' + format_key + text + '\1'
        # Return line of text, first allow user's line formatter to do its
        # thing (such as adding the line number) then replace the special
        # marks with what the user's change markup.
        return (num_lines[side],text)

    def _line_iterator():
        """Yields from/to lines of text with a change indication.

        This function is an iterator.  It itself pulls lines from a
        differencing iterator, processes them and yields them.  When it can
        it yields both a "from" and a "to" line, otherwise it will yield one
        or the other.  In addition to yielding the lines of from/to text, a
        boolean flag is yielded to indicate if the text line(s) have
        differences in them.

        Note, this function is purposefully not defined at the module scope so
        that data it needs from its parent function (within whose context it
        is defined) does not need to be of module scope.
        """
        lines = []
        num_blanks_pending, num_blanks_to_yield = 0, 0
        while True:
            # Load up next 4 lines so we can look ahead, create strings which
            # are a concatenation of the first character of each of the 4 lines
            # so we can do some very readable comparisons.
            while len(lines) < 4:
                try:
                    lines.append(next(diff_lines_iterator))
                except StopIteration:
                    lines.append('X')
            s = ''.join([line[0] for line in lines])
            if s.startswith('X'):
                # When no more lines, pump out any remaining blank lines so the
                # corresponding add/delete lines get a matching blank line so
                # all line pairs get yielded at the next level.
                num_blanks_to_yield = num_blanks_pending
            elif s.startswith('-?+?'):
                # simple intraline change
                yield _make_line(lines,'?',0), _make_line(lines,'?',1), True
                continue
            elif s.startswith('--++'):
                # in delete block, add block coming: we do NOT want to get
                # caught up on blank lines yet, just process the delete line
                num_blanks_pending -= 1
                yield _make_line(lines,'-',0), None, True
                continue
            elif s.startswith(('--?+', '--+', '- ')):
                # in delete block and see a intraline change or unchanged line
                # coming: yield the delete line and then blanks
                from_line,to_line = _make_line(lines,'-',0), None
                num_blanks_to_yield,num_blanks_pending = num_blanks_pending-1,0
            elif s.startswith('-+?'):
                # intraline change
                yield _make_line(lines,None,0), _make_line(lines,'?',1), True
                continue
            elif s.startswith('-?+'):
                # intraline change
                yield _make_line(lines,'?',0), _make_line(lines,None,1), True
                continue
            elif s.startswith('-'):
                # delete FROM line
                num_blanks_pending -= 1
                yield _make_line(lines,'-',0), None, True
                continue
            elif s.startswith('+--'):
                # in add block, delete block coming: we do NOT want to get
                # caught up on blank lines yet, just process the add line
                num_blanks_pending += 1
                yield None, _make_line(lines,'+',1), True
                continue
            elif s.startswith(('+ ', '+-')):
                # will be leaving an add block: yield blanks then add line
                from_line, to_line = None, _make_line(lines,'+',1)
                num_blanks_to_yield,num_blanks_pending = num_blanks_pending+1,0
            elif s.startswith('+'):
                # inside an add block, yield the add line
                num_blanks_pending += 1
                yield None, _make_line(lines,'+',1), True
                continue
            elif s.startswith(' '):
                # unchanged text, yield it to both sides
                yield _make_line(lines[:],None,0),_make_line(lines,None,1),False
                continue
            # Catch up on the blank lines so when we yield the next from/to
            # pair, they are lined up.
            while(num_blanks_to_yield < 0):
                num_blanks_to_yield += 1
                yield None,('','\n'),True
            while(num_blanks_to_yield > 0):
                num_blanks_to_yield -= 1
                yield ('','\n'),None,True
            if s.startswith('X'):
                raise StopIteration
            else:
                yield from_line,to_line,True

    def _line_pair_iterator():
        """Yields from/to lines of text with a change indication.

        This function is an iterator.  It itself pulls lines from the line
        iterator.  Its difference from that iterator is that this function
        always yields a pair of from/to text lines (with the change
        indication).  If necessary it will collect single from/to lines
        until it has a matching pair from/to pair to yield.

        Note, this function is purposefully not defined at the module scope so
        that data it needs from its parent function (within whose context it
        is defined) does not need to be of module scope.
        """
        line_iterator = _line_iterator()
        fromlines,tolines=[],[]
        while True:
            # Collecting lines of text until we have a from/to pair
            while (len(fromlines)==0 or len(tolines)==0):
                from_line, to_line, found_diff = next(line_iterator)
                if from_line is not None:
                    fromlines.append((from_line,found_diff))
                if to_line is not None:
                    tolines.append((to_line,found_diff))
            # Once we have a pair, remove them from the collection and yield it
            from_line, fromDiff = fromlines.pop(0)
            to_line, to_diff = tolines.pop(0)
            yield (from_line,to_line,fromDiff or to_diff)

    # Handle case where user does not want context differencing, just yield
    # them up without doing anything else with them.
    line_pair_iterator = _line_pair_iterator()
    if context is None:
        while True:
            yield next(line_pair_iterator)
    # Handle case where user wants context differencing.  We must do some
    # storage of lines until we know for sure that they are to be yielded.
    else:
        context += 1
        lines_to_write = 0
        while True:
            # Store lines up until we find a difference, note use of a
            # circular queue because we only need to keep around what
            # we need for context.
            index, contextLines = 0, [None]*(context)
            found_diff = False
            while(found_diff is False):
                from_line, to_line, found_diff = next(line_pair_iterator)
                i = index % context
                contextLines[i] = (from_line, to_line, found_diff)
                index += 1
            # Yield lines that we have collected so far, but first yield
            # the user's separator.
            if index > context:
                yield None, None, None
                lines_to_write = context
            else:
                lines_to_write = index
                index = 0
            while(lines_to_write):
                i = index % context
                index += 1
                yield contextLines[i]
                lines_to_write -= 1
            # Now yield the context lines after the change
            lines_to_write = context-1
            while(lines_to_write):
                from_line, to_line, found_diff = next(line_pair_iterator)
                # If another change within the context, extend the context
                if found_diff:
                    lines_to_write = context-1
                else:
                    lines_to_write -= 1
                yield from_line, to_line, found_diff


_file_template = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>

<head>
    <meta http-equiv="Content-Type"
          content="text/html; charset=ISO-8859-1" />
    <title></title>
    <style type="text/css">%(styles)s
    </style>
</head>

<body>
    %(table)s%(legend)s
</body>

</html>"""

_styles = """
        table.diff {font-family:Courier; border:medium;}
        .diff_header {background-color:#e0e0e0}
        td.diff_header {text-align:right}
        .diff_next {background-color:#c0c0c0}
        .diff_add {background-color:#aaffaa}
        .diff_chg {background-color:#ffff77}
        .diff_sub {background-color:#ffaaaa}"""

_table_template = """
    <table class="diff" id="difflib_chg_%(prefix)s_top"
           cellspacing="0" cellpadding="0" rules="groups" >
        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
        %(header_row)s
        <tbody>
%(data_rows)s        </tbody>
    </table>"""

_legend = """
    <table class="diff" summary="Legends">
        <tr> <th colspan="2"> Legends </th> </tr>
        <tr> <td> <table border="" summary="Colors">
                      <tr><th> Colors </th> </tr>
                      <tr><td class="diff_add">&nbsp;Added&nbsp;</td></tr>
                      <tr><td class="diff_chg">Changed</td> </tr>
                      <tr><td class="diff_sub">Deleted</td> </tr>
                  </table></td>
             <td> <table border="" summary="Links">
                      <tr><th colspan="2"> Links </th> </tr>
                      <tr><td>(f)irst change</td> </tr>
                      <tr><td>(n)ext change</td> </tr>
                      <tr><td>(t)op</td> </tr>
                  </table></td> </tr>
    </table>"""

class HtmlDiff(object):
    """For producing HTML side by side comparison with change highlights.

    This class can be used to create an HTML table (or a complete HTML file
    containing the table) showing a side by side, line by line comparison
    of text with inter-line and intra-line change highlights.  The table can
    be generated in either full or contextual difference mode.

    The following methods are provided for HTML generation:

    make_table -- generates HTML for a single side by side table
    make_file -- generates complete HTML file with a single side by side table

    See tools/scripts/diff.py for an example usage of this class.
    """

    _file_template = _file_template
    _styles = _styles
    _table_template = _table_template
    _legend = _legend
    _default_prefix = 0

    def __init__(self,tabsize=8,wrapcolumn=None,linejunk=None,
                 charjunk=IS_CHARACTER_JUNK):
        """HtmlDiff instance initializer

        Arguments:
        tabsize -- tab stop spacing, defaults to 8.
        wrapcolumn -- column number where lines are broken and wrapped,
            defaults to None where lines are not wrapped.
        linejunk,charjunk -- keyword arguments passed into ndiff() (used to by
            HtmlDiff() to generate the side by side HTML differences).  See
            ndiff() documentation for argument default values and descriptions.
        """
        self._tabsize = tabsize
        self._wrapcolumn = wrapcolumn
        self._linejunk = linejunk
        self._charjunk = charjunk

    def make_file(self,fromlines,tolines,fromdesc='',todesc='',context=False,
                  numlines=5):
        """Returns HTML file of side by side comparison with change highlights

        Arguments:
        fromlines -- list of "from" lines
        tolines -- list of "to" lines
        fromdesc -- "from" file column header string
        todesc -- "to" file column header string
        context -- set to True for contextual differences (defaults to False
            which shows full differences).
        numlines -- number of context lines.  When context is set True,
            controls number of lines displayed before and after the change.
            When context is False, controls the number of lines to place
            the "next" link anchors before the next change (so click of
            "next" link jumps to just before the change).
        """

        return self._file_template % dict(
            styles = self._styles,
            legend = self._legend,
            table = self.make_table(fromlines,tolines,fromdesc,todesc,
                                    context=context,numlines=numlines))

    def _tab_newline_replace(self,fromlines,tolines):
        """Returns from/to line lists with tabs expanded and newlines removed.

        Instead of tab characters being replaced by the number of spaces
        needed to fill in to the next tab stop, this function will fill
        the space with tab characters.  This is done so that the difference
        algorithms can identify changes in a file when tabs are replaced by
        spaces and vice versa.  At the end of the HTML generation, the tab
        characters will be replaced with a nonbreakable space.
        """
        def expand_tabs(line):
            # hide real spaces
            line = line.replace(' ','\0')
            # expand tabs into spaces
            line = line.expandtabs(self._tabsize)
            # replace spaces from expanded tabs back into tab characters
            # (we'll replace them with markup after we do differencing)
            line = line.replace(' ','\t')
            return line.replace('\0',' ').rstrip('\n')
        fromlines = [expand_tabs(line) for line in fromlines]
        tolines = [expand_tabs(line) for line in tolines]
        return fromlines,tolines

    def _split_line(self,data_list,line_num,text):
        """Builds list of text lines by splitting text lines at wrap point

        This function will determine if the input text line needs to be
        wrapped (split) into separate lines.  If so, the first wrap point
        will be determined and the first line appended to the output
        text line list.  This function is used recursively to handle
        the second part of the split line to further split it.
        """
        # if blank line or context separator, just add it to the output list
        if not line_num:
            data_list.append((line_num,text))
            return

        # if line text doesn't need wrapping, just add it to the output list
        size = len(text)
        max = self._wrapcolumn
        if (size <= max) or ((size -(text.count('\0')*3)) <= max):
            data_list.append((line_num,text))
            return

        # scan text looking for the wrap point, keeping track if the wrap
        # point is inside markers
        i = 0
        n = 0
        mark = ''
        while n < max and i < size:
            if text[i] == '\0':
                i += 1
                mark = text[i]
                i += 1
            elif text[i] == '\1':
                i += 1
                mark = ''
            else:
                i += 1
                n += 1

        # wrap point is inside text, break it up into separate lines
        line1 = text[:i]
        line2 = text[i:]

        # if wrap point is inside markers, place end marker at end of first
        # line and start marker at beginning of second line because each
        # line will have its own table tag markup around it.
        if mark:
            line1 = line1 + '\1'
            line2 = '\0' + mark + line2

        # tack on first line onto the output list
        data_list.append((line_num,line1))

        # use this routine again to wrap the remaining text
        self._split_line(data_list,'>',line2)

    def _line_wrapper(self,diffs):
        """Returns iterator that splits (wraps) mdiff text lines"""

        # pull from/to data and flags from mdiff iterator
        for fromdata,todata,flag in diffs:
            # check for context separators and pass them through
            if flag is None:
                yield fromdata,todata,flag
                continue
            (fromline,fromtext),(toline,totext) = fromdata,todata
            # for each from/to line split it at the wrap column to form
            # list of text lines.
            fromlist,tolist = [],[]
            self._split_line(fromlist,fromline,fromtext)
            self._split_line(tolist,toline,totext)
            # yield from/to line in pairs inserting blank lines as
            # necessary when one side has more wrapped lines
            while fromlist or tolist:
                if fromlist:
                    fromdata = fromlist.pop(0)
                else:
                    fromdata = ('',' ')
                if tolist:
                    todata = tolist.pop(0)
                else:
                    todata = ('',' ')
                yield fromdata,todata,flag

    def _collect_lines(self,diffs):
        """Collects mdiff output into separate lists

        Before storing the mdiff from/to data into a list, it is converted
        into a single line of text with HTML markup.
        """

        fromlist,tolist,flaglist = [],[],[]
        # pull from/to data and flags from mdiff style iterator
        for fromdata,todata,flag in diffs:
            try:
                # store HTML markup of the lines into the lists
                fromlist.append(self._format_line(0,flag,*fromdata))
                tolist.append(self._format_line(1,flag,*todata))
            except TypeError:
                # exceptions occur for lines where context separators go
                fromlist.append(None)
                tolist.append(None)
            flaglist.append(flag)
        return fromlist,tolist,flaglist

    def _format_line(self,side,flag,linenum,text):
        """Returns HTML markup of "from" / "to" text lines

        side -- 0 or 1 indicating "from" or "to" text
        flag -- indicates if difference on line
        linenum -- line number (used for line number column)
        text -- line text to be marked up
        """
        try:
            linenum = '%d' % linenum
            id = ' id="%s%s"' % (self._prefix[side],linenum)
        except TypeError:
            # handle blank lines where linenum is '>' or ''
            id = ''
        # replace those things that would get confused with HTML symbols
        text=text.replace("&","&amp;").replace(">","&gt;").replace("<","&lt;")

        # make space non-breakable so they don't get compressed or line wrapped
        text = text.replace(' ','&nbsp;').rstrip()

        return '<td class="diff_header"%s>%s</td><td nowrap="nowrap">%s</td>' \
               % (id,linenum,text)

    def _make_prefix(self):
        """Create unique anchor prefixes"""

        # Generate a unique anchor prefix so multiple tables
        # can exist on the same HTML page without conflicts.
        fromprefix = "from%d_" % HtmlDiff._default_prefix
        toprefix = "to%d_" % HtmlDiff._default_prefix
        HtmlDiff._default_prefix += 1
        # store prefixes so line format method has access
        self._prefix = [fromprefix,toprefix]

    def _convert_flags(self,fromlist,tolist,flaglist,context,numlines):
        """Makes list of "next" links"""

        # all anchor names will be generated using the unique "to" prefix
        toprefix = self._prefix[1]

        # process change flags, generating middle column of next anchors/links
        next_id = ['']*len(flaglist)
        next_href = ['']*len(flaglist)
        num_chg, in_change = 0, False
        last = 0
        for i,flag in enumerate(flaglist):
            if flag:
                if not in_change:
                    in_change = True
                    last = i
                    # at the beginning of a change, drop an anchor a few lines
                    # (the context lines) before the change for the previous
                    # link
                    i = max([0,i-numlines])
                    next_id[i] = ' id="difflib_chg_%s_%d"' % (toprefix,num_chg)
                    # at the beginning of a change, drop a link to the next
                    # change
                    num_chg += 1
                    next_href[last] = '<a href="#difflib_chg_%s_%d">n</a>' % (
                         toprefix,num_chg)
            else:
                in_change = False
        # check for cases where there is no content to avoid exceptions
        if not flaglist:
            flaglist = [False]
            next_id = ['']
            next_href = ['']
            last = 0
            if context:
                fromlist = ['<td></td><td>&nbsp;No Differences Found&nbsp;</td>']
                tolist = fromlist
            else:
                fromlist = tolist = ['<td></td><td>&nbsp;Empty File&nbsp;</td>']
        # if not a change on first line, drop a link
        if not flaglist[0]:
            next_href[0] = '<a href="#difflib_chg_%s_0">f</a>' % toprefix
        # redo the last link to link to the top
        next_href[last] = '<a href="#difflib_chg_%s_top">t</a>' % (toprefix)

        return fromlist,tolist,flaglist,next_href,next_id

    def make_table(self,fromlines,tolines,fromdesc='',todesc='',context=False,
                   numlines=5):
        """Returns HTML table of side by side comparison with change highlights

        Arguments:
        fromlines -- list of "from" lines
        tolines -- list of "to" lines
        fromdesc -- "from" file column header string
        todesc -- "to" file column header string
        context -- set to True for contextual differences (defaults to False
            which shows full differences).
        numlines -- number of context lines.  When context is set True,
            controls number of lines displayed before and after the change.
            When context is False, controls the number of lines to place
            the "next" link anchors before the next change (so click of
            "next" link jumps to just before the change).
        """

        # make unique anchor prefixes so that multiple tables may exist
        # on the same page without conflict.
        self._make_prefix()

        # change tabs to spaces before it gets more difficult after we insert
        # markup
        fromlines,tolines = self._tab_newline_replace(fromlines,tolines)

        # create diffs iterator which generates side by side from/to data
        if context:
            context_lines = numlines
        else:
            context_lines = None
        diffs = _mdiff(fromlines,tolines,context_lines,linejunk=self._linejunk,
                      charjunk=self._charjunk)

        # set up iterator to wrap lines that exceed desired width
        if self._wrapcolumn:
            diffs = self._line_wrapper(diffs)

        # collect up from/to lines and flags into lists (also format the lines)
        fromlist,tolist,flaglist = self._collect_lines(diffs)

        # process change flags, generating middle column of next anchors/links
        fromlist,tolist,flaglist,next_href,next_id = self._convert_flags(
            fromlist,tolist,flaglist,context,numlines)

        s = []
        fmt = '            <tr><td class="diff_next"%s>%s</td>%s' + \
              '<td class="diff_next">%s</td>%s</tr>\n'
        for i in range(len(flaglist)):
            if flaglist[i] is None:
                # mdiff yields None on separator lines skip the bogus ones
                # generated for the first line
                if i > 0:
                    s.append('        </tbody>        \n        <tbody>\n')
            else:
                s.append( fmt % (next_id[i],next_href[i],fromlist[i],
                                           next_href[i],tolist[i]))
        if fromdesc or todesc:
            header_row = '<thead><tr>%s%s%s%s</tr></thead>' % (
                '<th class="diff_next"><br /></th>',
                '<th colspan="2" class="diff_header">%s</th>' % fromdesc,
                '<th class="diff_next"><br /></th>',
                '<th colspan="2" class="diff_header">%s</th>' % todesc)
        else:
            header_row = ''

        table = self._table_template % dict(
            data_rows=''.join(s),
            header_row=header_row,
            prefix=self._prefix[1])

        return table.replace('\0+','<span class="diff_add">'). \
                     replace('\0-','<span class="diff_sub">'). \
                     replace('\0^','<span class="diff_chg">'). \
                     replace('\1','</span>'). \
                     replace('\t','&nbsp;')

del re

def restore(delta, which):
    r"""
    Generate one of the two sequences that generated a delta.

    Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract
    lines originating from file 1 or 2 (parameter `which`), stripping off line
    prefixes.

    Examples:

    >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
    ...              'ore\ntree\nemu\n'.splitlines(keepends=True))
    >>> diff = list(diff)
    >>> print(''.join(restore(diff, 1)), end="")
    one
    two
    three
    >>> print(''.join(restore(diff, 2)), end="")
    ore
    tree
    emu
    """
    try:
        tag = {1: "- ", 2: "+ "}[int(which)]
    except KeyError:
        raise ValueError('unknown delta choice (must be 1 or 2): %r'
                           % which)
    prefixes = ("  ", tag)
    for line in delta:
        if line[:2] in prefixes:
            yield line[2:]

def _test():
    import doctest, difflib
    return doctest.testmod(difflib)

if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                 usr/lib/python3.4/dis.py                                                                            0100644 0000000 0000000 00000041410 12415221636 013525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Disassembler of Python byte code into mnemonics."""

import sys
import types
import collections
import io

from opcode import *
from opcode import __all__ as _opcodes_all

__all__ = ["code_info", "dis", "disassemble", "distb", "disco",
           "findlinestarts", "findlabels", "show_code",
           "get_instructions", "Instruction", "Bytecode"] + _opcodes_all
del _opcodes_all

_have_code = (types.MethodType, types.FunctionType, types.CodeType, type)

def _try_compile(source, name):
    """Attempts to compile the given source, first as an expression and
       then as a statement if the first approach fails.

       Utility function to accept strings in functions that otherwise
       expect code objects
    """
    try:
        c = compile(source, name, 'eval')
    except SyntaxError:
        c = compile(source, name, 'exec')
    return c

def dis(x=None, *, file=None):
    """Disassemble classes, methods, functions, or code.

    With no argument, disassemble the last traceback.

    """
    if x is None:
        distb(file=file)
        return
    if hasattr(x, '__func__'):  # Method
        x = x.__func__
    if hasattr(x, '__code__'):  # Function
        x = x.__code__
    if hasattr(x, '__dict__'):  # Class or module
        items = sorted(x.__dict__.items())
        for name, x1 in items:
            if isinstance(x1, _have_code):
                print("Disassembly of %s:" % name, file=file)
                try:
                    dis(x1, file=file)
                except TypeError as msg:
                    print("Sorry:", msg, file=file)
                print(file=file)
    elif hasattr(x, 'co_code'): # Code object
        disassemble(x, file=file)
    elif isinstance(x, (bytes, bytearray)): # Raw bytecode
        _disassemble_bytes(x, file=file)
    elif isinstance(x, str):    # Source code
        _disassemble_str(x, file=file)
    else:
        raise TypeError("don't know how to disassemble %s objects" %
                        type(x).__name__)

def distb(tb=None, *, file=None):
    """Disassemble a traceback (default: last traceback)."""
    if tb is None:
        try:
            tb = sys.last_traceback
        except AttributeError:
            raise RuntimeError("no last traceback to disassemble")
        while tb.tb_next: tb = tb.tb_next
    disassemble(tb.tb_frame.f_code, tb.tb_lasti, file=file)

# The inspect module interrogates this dictionary to build its
# list of CO_* constants. It is also used by pretty_flags to
# turn the co_flags field into a human readable list.
COMPILER_FLAG_NAMES = {
     1: "OPTIMIZED",
     2: "NEWLOCALS",
     4: "VARARGS",
     8: "VARKEYWORDS",
    16: "NESTED",
    32: "GENERATOR",
    64: "NOFREE",
}

def pretty_flags(flags):
    """Return pretty representation of code flags."""
    names = []
    for i in range(32):
        flag = 1<<i
        if flags & flag:
            names.append(COMPILER_FLAG_NAMES.get(flag, hex(flag)))
            flags ^= flag
            if not flags:
                break
    else:
        names.append(hex(flags))
    return ", ".join(names)

def _get_code_object(x):
    """Helper to handle methods, functions, strings and raw code objects"""
    if hasattr(x, '__func__'): # Method
        x = x.__func__
    if hasattr(x, '__code__'): # Function
        x = x.__code__
    if isinstance(x, str):     # Source code
        x = _try_compile(x, "<disassembly>")
    if hasattr(x, 'co_code'):  # Code object
        return x
    raise TypeError("don't know how to disassemble %s objects" %
                    type(x).__name__)

def code_info(x):
    """Formatted details of methods, functions, or code."""
    return _format_code_info(_get_code_object(x))

def _format_code_info(co):
    lines = []
    lines.append("Name:              %s" % co.co_name)
    lines.append("Filename:          %s" % co.co_filename)
    lines.append("Argument count:    %s" % co.co_argcount)
    lines.append("Kw-only arguments: %s" % co.co_kwonlyargcount)
    lines.append("Number of locals:  %s" % co.co_nlocals)
    lines.append("Stack size:        %s" % co.co_stacksize)
    lines.append("Flags:             %s" % pretty_flags(co.co_flags))
    if co.co_consts:
        lines.append("Constants:")
        for i_c in enumerate(co.co_consts):
            lines.append("%4d: %r" % i_c)
    if co.co_names:
        lines.append("Names:")
        for i_n in enumerate(co.co_names):
            lines.append("%4d: %s" % i_n)
    if co.co_varnames:
        lines.append("Variable names:")
        for i_n in enumerate(co.co_varnames):
            lines.append("%4d: %s" % i_n)
    if co.co_freevars:
        lines.append("Free variables:")
        for i_n in enumerate(co.co_freevars):
            lines.append("%4d: %s" % i_n)
    if co.co_cellvars:
        lines.append("Cell variables:")
        for i_n in enumerate(co.co_cellvars):
            lines.append("%4d: %s" % i_n)
    return "\n".join(lines)

def show_code(co, *, file=None):
    """Print details of methods, functions, or code to *file*.

    If *file* is not provided, the output is printed on stdout.
    """
    print(code_info(co), file=file)

_Instruction = collections.namedtuple("_Instruction",
     "opname opcode arg argval argrepr offset starts_line is_jump_target")

class Instruction(_Instruction):
    """Details for a bytecode operation

       Defined fields:
         opname - human readable name for operation
         opcode - numeric code for operation
         arg - numeric argument to operation (if any), otherwise None
         argval - resolved arg value (if known), otherwise same as arg
         argrepr - human readable description of operation argument
         offset - start index of operation within bytecode sequence
         starts_line - line started by this opcode (if any), otherwise None
         is_jump_target - True if other code jumps to here, otherwise False
    """

    def _disassemble(self, lineno_width=3, mark_as_current=False):
        """Format instruction details for inclusion in disassembly output

        *lineno_width* sets the width of the line number field (0 omits it)
        *mark_as_current* inserts a '-->' marker arrow as part of the line
        """
        fields = []
        # Column: Source code line number
        if lineno_width:
            if self.starts_line is not None:
                lineno_fmt = "%%%dd" % lineno_width
                fields.append(lineno_fmt % self.starts_line)
            else:
                fields.append(' ' * lineno_width)
        # Column: Current instruction indicator
        if mark_as_current:
            fields.append('-->')
        else:
            fields.append('   ')
        # Column: Jump target marker
        if self.is_jump_target:
            fields.append('>>')
        else:
            fields.append('  ')
        # Column: Instruction offset from start of code sequence
        fields.append(repr(self.offset).rjust(4))
        # Column: Opcode name
        fields.append(self.opname.ljust(20))
        # Column: Opcode argument
        if self.arg is not None:
            fields.append(repr(self.arg).rjust(5))
            # Column: Opcode argument details
            if self.argrepr:
                fields.append('(' + self.argrepr + ')')
        return ' '.join(fields).rstrip()


def get_instructions(x, *, first_line=None):
    """Iterator for the opcodes in methods, functions or code

    Generates a series of Instruction named tuples giving the details of
    each operations in the supplied code.

    If *first_line* is not None, it indicates the line number that should
    be reported for the first source line in the disassembled code.
    Otherwise, the source line information (if any) is taken directly from
    the disassembled code object.
    """
    co = _get_code_object(x)
    cell_names = co.co_cellvars + co.co_freevars
    linestarts = dict(findlinestarts(co))
    if first_line is not None:
        line_offset = first_line - co.co_firstlineno
    else:
        line_offset = 0
    return _get_instructions_bytes(co.co_code, co.co_varnames, co.co_names,
                                   co.co_consts, cell_names, linestarts,
                                   line_offset)

def _get_const_info(const_index, const_list):
    """Helper to get optional details about const references

       Returns the dereferenced constant and its repr if the constant
       list is defined.
       Otherwise returns the constant index and its repr().
    """
    argval = const_index
    if const_list is not None:
        argval = const_list[const_index]
    return argval, repr(argval)

def _get_name_info(name_index, name_list):
    """Helper to get optional details about named references

       Returns the dereferenced name as both value and repr if the name
       list is defined.
       Otherwise returns the name index and its repr().
    """
    argval = name_index
    if name_list is not None:
        argval = name_list[name_index]
        argrepr = argval
    else:
        argrepr = repr(argval)
    return argval, argrepr


def _get_instructions_bytes(code, varnames=None, names=None, constants=None,
                      cells=None, linestarts=None, line_offset=0):
    """Iterate over the instructions in a bytecode string.

    Generates a sequence of Instruction namedtuples giving the details of each
    opcode.  Additional information about the code's runtime environment
    (e.g. variable names, constants) can be specified using optional
    arguments.

    """
    labels = findlabels(code)
    extended_arg = 0
    starts_line = None
    free = None
    # enumerate() is not an option, since we sometimes process
    # multiple elements on a single pass through the loop
    n = len(code)
    i = 0
    while i < n:
        op = code[i]
        offset = i
        if linestarts is not None:
            starts_line = linestarts.get(i, None)
            if starts_line is not None:
                starts_line += line_offset
        is_jump_target = i in labels
        i = i+1
        arg = None
        argval = None
        argrepr = ''
        if op >= HAVE_ARGUMENT:
            arg = code[i] + code[i+1]*256 + extended_arg
            extended_arg = 0
            i = i+2
            if op == EXTENDED_ARG:
                extended_arg = arg*65536
            #  Set argval to the dereferenced value of the argument when
            #  availabe, and argrepr to the string representation of argval.
            #    _disassemble_bytes needs the string repr of the
            #    raw name index for LOAD_GLOBAL, LOAD_CONST, etc.
            argval = arg
            if op in hasconst:
                argval, argrepr = _get_const_info(arg, constants)
            elif op in hasname:
                argval, argrepr = _get_name_info(arg, names)
            elif op in hasjrel:
                argval = i + arg
                argrepr = "to " + repr(argval)
            elif op in haslocal:
                argval, argrepr = _get_name_info(arg, varnames)
            elif op in hascompare:
                argval = cmp_op[arg]
                argrepr = argval
            elif op in hasfree:
                argval, argrepr = _get_name_info(arg, cells)
            elif op in hasnargs:
                argrepr = "%d positional, %d keyword pair" % (code[i-2], code[i-1])
        yield Instruction(opname[op], op,
                          arg, argval, argrepr,
                          offset, starts_line, is_jump_target)

def disassemble(co, lasti=-1, *, file=None):
    """Disassemble a code object."""
    cell_names = co.co_cellvars + co.co_freevars
    linestarts = dict(findlinestarts(co))
    _disassemble_bytes(co.co_code, lasti, co.co_varnames, co.co_names,
                       co.co_consts, cell_names, linestarts, file=file)

def _disassemble_bytes(code, lasti=-1, varnames=None, names=None,
                       constants=None, cells=None, linestarts=None,
                       *, file=None, line_offset=0):
    # Omit the line number column entirely if we have no line number info
    show_lineno = linestarts is not None
    # TODO?: Adjust width upwards if max(linestarts.values()) >= 1000?
    lineno_width = 3 if show_lineno else 0
    for instr in _get_instructions_bytes(code, varnames, names,
                                         constants, cells, linestarts,
                                         line_offset=line_offset):
        new_source_line = (show_lineno and
                           instr.starts_line is not None and
                           instr.offset > 0)
        if new_source_line:
            print(file=file)
        is_current_instr = instr.offset == lasti
        print(instr._disassemble(lineno_width, is_current_instr), file=file)

def _disassemble_str(source, *, file=None):
    """Compile the source string, then disassemble the code object."""
    disassemble(_try_compile(source, '<dis>'), file=file)

disco = disassemble                     # XXX For backwards compatibility

def findlabels(code):
    """Detect all offsets in a byte code which are jump targets.

    Return the list of offsets.

    """
    labels = []
    # enumerate() is not an option, since we sometimes process
    # multiple elements on a single pass through the loop
    n = len(code)
    i = 0
    while i < n:
        op = code[i]
        i = i+1
        if op >= HAVE_ARGUMENT:
            arg = code[i] + code[i+1]*256
            i = i+2
            label = -1
            if op in hasjrel:
                label = i+arg
            elif op in hasjabs:
                label = arg
            if label >= 0:
                if label not in labels:
                    labels.append(label)
    return labels

def findlinestarts(code):
    """Find the offsets in a byte code which are start of lines in the source.

    Generate pairs (offset, lineno) as described in Python/compile.c.

    """
    byte_increments = list(code.co_lnotab[0::2])
    line_increments = list(code.co_lnotab[1::2])

    lastlineno = None
    lineno = code.co_firstlineno
    addr = 0
    for byte_incr, line_incr in zip(byte_increments, line_increments):
        if byte_incr:
            if lineno != lastlineno:
                yield (addr, lineno)
                lastlineno = lineno
            addr += byte_incr
        lineno += line_incr
    if lineno != lastlineno:
        yield (addr, lineno)

class Bytecode:
    """The bytecode operations of a piece of code

    Instantiate this with a function, method, string of code, or a code object
    (as returned by compile()).

    Iterating over this yields the bytecode operations as Instruction instances.
    """
    def __init__(self, x, *, first_line=None, current_offset=None):
        self.codeobj = co = _get_code_object(x)
        if first_line is None:
            self.first_line = co.co_firstlineno
            self._line_offset = 0
        else:
            self.first_line = first_line
            self._line_offset = first_line - co.co_firstlineno
        self._cell_names = co.co_cellvars + co.co_freevars
        self._linestarts = dict(findlinestarts(co))
        self._original_object = x
        self.current_offset = current_offset

    def __iter__(self):
        co = self.codeobj
        return _get_instructions_bytes(co.co_code, co.co_varnames, co.co_names,
                                       co.co_consts, self._cell_names,
                                       self._linestarts,
                                       line_offset=self._line_offset)

    def __repr__(self):
        return "{}({!r})".format(self.__class__.__name__,
                                 self._original_object)

    @classmethod
    def from_traceback(cls, tb):
        """ Construct a Bytecode from the given traceback """
        while tb.tb_next:
            tb = tb.tb_next
        return cls(tb.tb_frame.f_code, current_offset=tb.tb_lasti)

    def info(self):
        """Return formatted information about the code object."""
        return _format_code_info(self.codeobj)

    def dis(self):
        """Return a formatted view of the bytecode operations."""
        co = self.codeobj
        if self.current_offset is not None:
            offset = self.current_offset
        else:
            offset = -1
        with io.StringIO() as output:
            _disassemble_bytes(co.co_code, varnames=co.co_varnames,
                               names=co.co_names, constants=co.co_consts,
                               cells=self._cell_names,
                               linestarts=self._linestarts,
                               line_offset=self._line_offset,
                               file=output,
                               lasti=offset)
            return output.getvalue()


def _test():
    """Simple test program to disassemble a file."""
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('infile', type=argparse.FileType(), nargs='?', default='-')
    args = parser.parse_args()
    with args.infile as infile:
        source = infile.read()
    code = compile(source, args.infile.name, "exec")
    dis(code)

if __name__ == "__main__":
    _test()
                                                                                                                                                                                                                                                        usr/lib/python3.4/distutils/                                                                        0040755 0000000 0000000 00000000000 13077704335 014432  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/distutils/README                                                                  0100644 0000000 0000000 00000000447 12415221640 015300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        This directory contains the Distutils package.

There's a full documentation available at:

    http://docs.python.org/distutils/

The Distutils-SIG web page is also a good starting point:

    http://www.python.org/sigs/distutils-sig/

WARNING : Distutils must remain compatible with 2.3

$Id$
                                                                                                                                                                                                                         usr/lib/python3.4/distutils/__init__.py                                                             0100644 0000000 0000000 00000000472 12415221640 016527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils

The main package for the Python Module Distribution Utilities.  Normally
used from a setup script as

   from distutils.core import setup

   setup (...)
"""

# Distutils version
#
# Updated automatically by the Python release process.
#
#--start constants--
__version__ = "3.4.2"
#--end constants--
                                                                                                                                                                                                      usr/lib/python3.4/distutils/__pycache__/                                                            0040755 0000000 0000000 00000000000 13077704335 016642  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/distutils/__pycache__/__init__.cpython-34.pyc                                     0100644 0000000 0000000 00000000512 13077704335 023020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T:  „               @   s   d  Z  d Z d S)z•distutils

The main package for the Python Module Distribution Utilities.  Normally
used from a setup script as

   from distutils.core import setup

   setup (...)
z3.4.2N)⁄__doc__⁄__version__© r   r   ˙(/usr/lib/python3.4/distutils/__init__.py⁄<module>	   s                                                                                                                                                                                         usr/lib/python3.4/distutils/__pycache__/archive_util.cpython-34.pyc                                 0100644 0000000 0000000 00000015103 13077704335 023741  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T	  „                @   sÃ  d  Z  d d l Z d d l m Z d d l Z y d d l Z Wn e k
 rX d Z Yn Xd d l m Z d d l	 m
 Z
 d d l m Z d d l m Z y d d l m Z Wn e k
 r« d Z Yn Xy d d	 l m Z Wn e k
 rˆ d Z Yn Xd
 d Ñ  Z d d Ñ  Z d d d d d d d Ñ Z d d d d Ñ Z i e d# g d f d 6e d$ g d f d 6e d% g d f d 6e d& g d f d 6e g  d f d 6Z d d  Ñ  Z d d d d d d d! d" Ñ Z d S)'zodistutils.archive_util

Utility functions for creating archive files (tarballs, zip files,
that sort of thing).È    N)⁄warn)⁄DistutilsExecError)⁄spawn)⁄mkpath)⁄log)⁄getpwnam)⁄getgrnamc             C   s_   t  d k s |  d k r d Sy t  |  É } Wn t k
 rF d } Yn X| d k	 r[ | d Sd S)z"Returns a gid, given a group name.NÈ   )r   ⁄KeyError)⁄name⁄result© r   ˙,/usr/lib/python3.4/distutils/archive_util.py⁄_get_gid   s    r   c             C   s_   t  d k s |  d k r d Sy t  |  É } Wn t k
 rF d } Yn X| d k	 r[ | d Sd S)z"Returns an uid, given a user name.Nr	   )r   r
   )r   r   r   r   r   ⁄_get_uid+   s    r   ⁄gzipc                s∏  i d d 6d d 6d d 6d d 6} i d d 6d	 d 6d
 d 6} | d k	 rj | | j  É  k rj t d É Ç n  |  d }	 | d k rô |	 | j | d É 7}	 n  t t j j |	 É d | Éd d l }
 t j	 d É t
 à É â t à É â  á  á á á f d d Ü  } | sI|
 j |	 d | | É } z | j | d | ÉWd | j É  Xn  | d k r¥t d t É |	 | | } t j d k rë| |	 | g } n | d |	 g } t | d | É| S|	 S)a-  Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "compress", "bzip2", or None.
    (compress will be deprecated in Python 3.2)

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_dir' +  ".tar", possibly plus
    the appropriate compression extension (".gz", ".bz2" or ".Z").

    Returns the output filename.
    Zgzr   ⁄bz2⁄bzip2⁄ N⁄compressz.gzz.bz2z.ZzEbad value for 'compress': must be None, 'gzip', 'bzip2' or 'compress'z.tar⁄dry_runr   zCreating tar archivec                sF   à  d  k	 r! à  |  _  à |  _ n  à d  k	 rB à |  _ à |  _ n  |  S)N)⁄gidZgname⁄uid⁄uname)Ztarinfo)r   ⁄group⁄ownerr   r   r   ⁄_set_uid_gid_   s    		z"make_tarball.<locals>._set_uid_gidzw|%s⁄filterz'compress' will be deprecated.Zwin32z-f)⁄keys⁄
ValueError⁄getr   ⁄os⁄path⁄dirname⁄tarfiler   ⁄infor   r   ⁄open⁄add⁄closer   ⁄PendingDeprecationWarning⁄sys⁄platformr   )⁄	base_name⁄base_dirr   ⁄verboser   r   r   Ztar_compressionZcompress_extZarchive_namer$   r   ⁄tarZcompressed_name⁄cmdr   )r   r   r   r   r   ⁄make_tarball7   s8    "
	r1   c             C   sì  |  d } t  t j j | É d | Ét d k rè | rA d } n d } y  t d | | | g d | ÉWqèt k
 rã t d | É Ç YqèXn t j d | | É | sèy t j	 | d	 d
 t j
 É} Wn- t k
 rˆ t j	 | d	 d
 t j É} Yn Xxà t j | É D]w \ } } }	 xe |	 D]] }
 t j j t j j | |
 É É } t j j | É r| j | | É t j d | É qqWqW| j É  n  | S)av  Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises DistutilsExecError.  Returns the name of the output zip
    file.
    z.zipr   Nz-rz-rq⁄zipzkunable to create zip file '%s': could neither import the 'zipfile' module nor find a standalone zip utilityz#creating '%s' and adding '%s' to it⁄wZcompressionzadding '%s')r   r!   r"   r#   ⁄zipfiler   r   r   r%   ZZipFileZZIP_DEFLATED⁄RuntimeErrorZ
ZIP_STORED⁄walk⁄normpath⁄join⁄isfile⁄writer(   )r,   r-   r.   r   Zzip_filenameZ
zipoptionsr2   ⁄dirpathZdirnames⁄	filenamesr   r"   r   r   r   ⁄make_zipfile}   s:    	
		
!r=   r   zgzip'ed tar-fileZgztarr   zbzip2'ed tar-fileZbztarzcompressed tar fileZztarzuncompressed tar filer/   zZIP filer2   c             C   s%   x |  D] } | t  k r | Sq Wd S)zqReturns the first format from the 'format' list that is unknown.

    If all formats are known, returns None
    N)⁄ARCHIVE_FORMATS)Zformats⁄formatr   r   r   ⁄check_archive_formatsπ   s    r@   c             C   sG  t  j É  } | d k	 rS t j d | É t  j j |  É }  | sS t  j | É qS n  | d k rk t  j } n  i | d 6}	 y t | }
 Wn" t	 k
 r™ t
 d | É Ç Yn X|
 d } x" |
 d D] \ } } | |	 | <q¿ W| d k r˝ | |	 d <| |	 d	 <n  z | |  | |	 ç } Wd | d k	 rBt j d
 | É t  j | É n  X| S)aÍ  Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "ztar",
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    Nzchanging into '%s'r   zunknown archive format '%s'r   È   r2   r   r   zchanging back to '%s')r!   ⁄getcwdr   ⁄debugr"   ⁄abspath⁄chdir⁄curdirr>   r
   r   )r,   r?   Zroot_dirr-   r.   r   r   r   Zsave_cwd⁄kwargsZformat_info⁄func⁄arg⁄val⁄filenamer   r   r   ⁄make_archive√   s2    

rL   )˙compresszgzip)rM   zbzip2)rM   rM   )rM   N)⁄__doc__r!   ⁄warningsr   r*   r4   ⁄ImportErrorZdistutils.errorsr   Zdistutils.spawnr   Zdistutils.dir_utilr   Z	distutilsr   ⁄pwdr   Zgrpr   r   r   r1   r=   r>   r@   rL   r   r   r   r   ⁄<module>   sB   	E4
	                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python3.4/distutils/__pycache__/bcppcompiler.cpython-34.pyc                                 0100644 0000000 0000000 00000016155 13077704335 023752  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TW:  „               @   s¶   d  Z  d d l Z d d l m Z m Z m Z m Z m Z m Z d d l	 m
 Z
 m Z m Z d d l m Z d d l m Z d d l m Z Gd d	 Ñ  d	 e
 É Z d S)
zÉdistutils.bcppcompiler

Contains BorlandCCompiler, an implementation of the abstract CCompiler class
for the Borland C++ compiler.
È    N)⁄DistutilsExecError⁄DistutilsPlatformError⁄CompileError⁄LibError⁄	LinkError⁄UnknownFileError)⁄	CCompiler⁄gen_preprocess_options⁄gen_lib_options)⁄
write_file)⁄newer)⁄logc               @   s  e  Z d  Z d Z d Z i  Z d g Z d d d g Z e e Z d Z	 d Z
 d	 Z d
 Z Z d Z d d d d d Ñ Z d d d d d d d d d Ñ Z d d d d d Ñ Z d d d d d d d d d d d d Ñ
 Z d d d Ñ Z d d d d Ñ Z d d d d d d d Ñ Z d S)⁄BCPPCompilerzConcrete class that implements an interface to the Borland C/C++
    compiler, as defined by the CCompiler abstract class.
    Zbcppz.cz.ccz.cppz.cxxz.objz.libz.dllz%s%sz.exer   c             C   s¬   t  j |  | | | É d |  _ d |  _ d |  _ d  |  _ d d d d g |  _ d d d d g |  _ d	 d
 d d g |  _ d	 d
 d d g |  _	 g  |  _
 d
 d d g |  _ d
 d d d g |  _ d  S)Nz	bcc32.exezilink32.exeztlib.exez/tWMz/O2z/qz/g0z/Odz/Tpdz/Gnz/xz/r)r   ⁄__init__⁄cc⁄linker⁄libZpreprocess_options⁄compile_options⁄compile_options_debug⁄ldflags_shared⁄ldflags_shared_debugZldflags_static⁄ldflags_exe⁄ldflags_exe_debug)⁄self⁄verboseZdry_run⁄force© r   ˙,/usr/lib/python3.4/distutils/bcppcompiler.pyr   5   s    					zBCPPCompiler.__init__Nc	             C   s
  |  j  | | | | | | É \ } }	 } }
 } | p6 g  } | j d É | r_ | j |  j É n | j |  j É xî|	 D]å} y | | \ } } Wn t k
 rß wv Yn Xt j j | É } t j j | É } |  j	 t j j
 | É É | d k r˜ qv n  | d k rZy |  j d d | | g É Wqv t k
 rS} z t | É Ç WYd  d  } ~ Xqv Xqv n  | |  j k rrd } n | |  j k räd } n d } d | } y4 |  j |  j g | |
 | | g | | g É Wqv t k
 r} z t | É Ç WYd  d  } ~ Xqv Xqv W|	 S)	Nz-cz.resz.rcZbrcc32z-fo⁄ z-Pz-o)Z_setup_compile⁄append⁄extendr   r   ⁄KeyError⁄os⁄path⁄normpath⁄mkpath⁄dirname⁄spawnr   r   ⁄_c_extensions⁄_cpp_extensionsr   )r   Zsources⁄
output_dir⁄macros⁄include_dirs⁄debug⁄extra_preargs⁄extra_postargsZdepends⁄objects⁄pp_optsZbuildZcompile_opts⁄obj⁄src⁄ext⁄msgZ	input_optZ
output_optr   r   r   ⁄compileQ   sF    		
.#zBCPPCompiler.compilec       	      C   sæ   |  j  | | É \ } } |  j | d | É} |  j | | É r™ | d g | } | rX n  y |  j |  j g | É Wq∫ t k
 r¶ } z t | É Ç WYd  d  } ~ Xq∫ Xn t j d | É d  S)Nr*   z/uzskipping %s (up-to-date))	⁄_fix_object_args⁄library_filename⁄
_need_linkr'   r   r   r   r   r-   )	r   r0   Zoutput_libnamer*   r-   ⁄target_lang⁄output_filenameZlib_argsr5   r   r   r   ⁄create_static_libí   s    "zBCPPCompiler.create_static_libc              C   s˝  |  j  | | É \ } } |  j | | | É \ } } } | rU t j d t | É É n  | d  k	 ry t j j | | É } n  |  j | | É rÈ| t	 j
 k r“ d } |	 rº |  j d  d  Ö } q|  j d  d  Ö } n5 d } |	 rÙ |  j d  d  Ö } n |  j d  d  Ö } | d  k rd } n≥ t j j | É \ } } t j j | É \ } } t j j | d É } t j j | d | É } d g } x+ | pêg  D] } | j d | | f É qëW|  j t | | f d	 | É t t j j | É } | g } g  } x[ | D]S } t j j t j j | É É \ } } | d
 k r@| j | É q˙| j | É q˙Wx+ | D]# } | j d t j j | É É qXW| j d É | j | É | j d | g É | j d É xL | D]D } |  j | | |	 É } | d  k r˜| j | É q¿| j | É q¿W| j d É | j d É | j d | g É | j d É | j | É |
 rh|
 | d  d Ö <n  | r~| j | É n  |  j t j j | É É y |  j |  j g | É Wq˘t k
 rÂ} z t | É Ç WYd  d  } ~ Xq˘Xn t j d | É d  S)Nz7I don't know what to do with 'runtime_library_dirs': %sZc0w32Zc0d32r   r   z%s.defZEXPORTSz  %s=_%sz
writing %sz.resz/L%sz/L.˙,z,,Zimport32Zcw32mtzskipping %s (up-to-date)) r7   Z_fix_lib_argsr   ⁄warn⁄strr"   r#   ⁄joinr9   r   Z
EXECUTABLEr   r   r   r   ⁄split⁄splitextr&   r   Zexecuter   ⁄mapr$   ⁄normcaser    ⁄find_library_filer%   r'   r   r   r   r-   ) r   Ztarget_descr0   r;   r*   Z	librariesZlibrary_dirsZruntime_library_dirsZexport_symbolsr-   r.   r/   Z
build_tempr:   Zstartup_objZld_argsZdef_file⁄head⁄tail⁄modnamer4   Ztemp_dir⁄contentsZsymZobjects2Z	resources⁄file⁄base⁄lr   ⁄libfiler5   r   r   r   ⁄link´   s|    				$!"zBCPPCompiler.linkc       	      C   sõ   | r- | d } | d | d | | f } n | d | f } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É rQ | SqQ WqD Wd  Sd  S)NZ_dZ_bcpp)r"   r#   r@   r8   ⁄exists)	r   ⁄dirsr   r-   ZdlibZ	try_names⁄dir⁄namerM   r   r   r   rE   4  s    

zBCPPCompiler.find_library_filer   c             C   s"  | d  k r d } n  g  } x | D]¯ } t  j j t  j j | É É \ } } | |  j d d g k r~ t d | | f É Ç n  | rô t  j j | É } n  | d k r» | j t  j j | | | É É q" | d k r˜ | j t  j j | | d É É q" | j t  j j | | |  j	 É É q" W| S)Nr   z.rcz.resz"unknown file type '%s' (from '%s'))
r"   r#   rB   rD   ⁄src_extensionsr   ⁄basenamer   r@   ⁄obj_extension)r   Zsource_filenamesZ	strip_dirr*   Z	obj_namesZsrc_namerK   r4   r   r   r   ⁄object_filenamesN  s"     	$##zBCPPCompiler.object_filenamesc             C   s2  |  j  d  | | É \ } } } t | | É } d g | }	 | d  k	 rZ |	 j d | É n  | rs | |	 d  d Ö <n  | râ |	 j | É n  |	 j | É |  j s∫ | d  k s∫ t | | É r.| r‹ |  j t j j	 | É É n  y |  j
 |	 É Wq.t k
 r*}
 z t |
 É t |
 É Ç WYd  d  }
 ~
 Xq.Xn  d  S)Nz	cpp32.exez-or   )Z_fix_compile_argsr	   r   r    r   r   r%   r"   r#   r&   r'   r   ⁄printr   )r   ⁄sourceZoutput_filer+   r,   r.   r/   ⁄_r1   Zpp_argsr5   r   r   r   ⁄
preprocessi  s$    	$
zBCPPCompiler.preprocess)⁄__name__⁄
__module__⁄__qualname__⁄__doc__Zcompiler_typeZexecutablesr(   r)   rS   rU   Zstatic_lib_extensionZshared_lib_extensionZstatic_lib_formatZshared_lib_formatZexe_extensionr   r6   r<   rN   rE   rV   rZ   r   r   r   r   r      sJ   	

B|r   )r^   r"   Zdistutils.errorsr   r   r   r   r   r   Zdistutils.ccompilerr   r	   r
   Zdistutils.file_utilr   Zdistutils.dep_utilr   Z	distutilsr   r   r   r   r   r   ⁄<module>   s   
.                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python3.4/distutils/__pycache__/ccompiler.cpython-34.pyc                                    0100644 0000000 0000000 00000104056 13077704335 023246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tπ  „               @   s  d  Z  d d l Z d d l Z d d l Z d d l Td d l m Z d d l m Z d d l	 m
 Z
 d d l m Z m Z d d l m Z m Z d d	 l m Z Gd
 d Ñ  d É Z d d f d d f d d f f Z d d d d Ñ Z i d d d f d 6d d d f d 6d d d f d 6d d d f d 6d  d! d" f d# 6Z d$ d% Ñ  Z d d d d d d& d' Ñ Z d( d) Ñ  Z d* d+ Ñ  Z d S),zàdistutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
for the Distutils compiler abstraction model.È    N)⁄*)⁄spawn)⁄	move_file)⁄mkpath)⁄newer_pairwise⁄newer_group)⁄split_quoted⁄execute)⁄logc               @   s¿  e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 d Z
 d Z i d d 6d d 6d d 6d d 6d	 d
 6Z d d	 d g Z d d d d d Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z d$ d% Ñ  Z d& d' Ñ  Z d( d) Ñ  Z d* d+ Ñ  Z d, d- Ñ  Z d. d/ Ñ  Z d0 d1 Ñ  Z  d2 d3 Ñ  Z! d d4 d5 Ñ Z" d6 d7 Ñ  Z# d8 d9 Ñ  Z$ d: d; Ñ  Z% d< d= Ñ  Z& d d d d d d> d? Ñ Z' d d d d d d d d@ dA Ñ Z( dB dC Ñ  Z) d d d dD dE Ñ Z* dF Z+ dG Z, dH Z- d d d d d d d d d d dI dJ Ñ
 Z. d d d d d d d d d d dK dL Ñ
 Z/ d d d d d d d d d d dM dN Ñ
 Z0 d d d d d d d d dO dP Ñ Z1 dQ dR Ñ  Z2 dS dT Ñ  Z3 dU dV Ñ  Z4 d d d d dW dX Ñ Z5 d dY dZ Ñ Z6 d d[ d\ d] Ñ Z7 d d[ d^ d_ Ñ Z8 d d[ d` da Ñ Z9 db d d[ dc dd Ñ Z: de df dg Ñ Z; dh di Ñ  Z< dj dk Ñ  Z= d de dl dm Ñ Z> dn do Ñ  Z? dp dq Ñ  Z@ dr ds dt Ñ ZA d S)u⁄	CCompileraü  Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The basic idea behind a compiler abstraction class is that each
    instance can be used for all the compile/link steps in building a
    single project.  Thus, attributes common to all of those compile and
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow for
    variability in how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link basis.
    N⁄cz.czc++z.ccz.cppz.cxxZobjcz.mr   c             C   sè   | |  _  | |  _ | |  _ d  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _ g  |  _	 x. |  j
 j É  D] } |  j | |  j
 | É qj Wd  S)N)⁄dry_run⁄force⁄verbose⁄
output_dir⁄macros⁄include_dirs⁄	libraries⁄library_dirs⁄runtime_library_dirs⁄objects⁄executables⁄keys⁄set_executable)⁄selfr   r   r   ⁄key© r   ˙)/usr/lib/python3.4/distutils/ccompiler.py⁄__init__U   s    										zCCompiler.__init__c             K   sW   xP | D]H } | |  j  k r; t d | |  j j f É Ç n  |  j | | | É q Wd S)aã  Define the executables (and options for them) that will be run
        to perform the various stages of compilation.  The exact set of
        executables that may be specified here depends on the compiler
        class (via the 'executables' class attribute), but most will have:
          compiler      the C/C++ compiler
          linker_so     linker used to create shared objects and libraries
          linker_exe    linker used to create binary executables
          archiver      static library creator

        On platforms with a command-line (Unix, DOS/Windows), each of these
        is a string that will be split into executable name and (optional)
        list of arguments.  (Splitting the string is done similarly to how
        Unix shells operate: words are delimited by spaces, but quotes and
        backslashes can override this.  See
        'distutils.util.split_quoted()'.)
        z$unknown executable '%s' for class %sN)r   ⁄
ValueError⁄	__class__⁄__name__r   )r   ⁄kwargsr   r   r   r   ⁄set_executablesy   s
    zCCompiler.set_executablesc             C   s<   t  | t É r( t |  | t | É É n t |  | | É d  S)N)⁄
isinstance⁄str⁄setattrr   )r   r   ⁄valuer   r   r   r   ô   s    zCCompiler.set_executablec             C   s<   d } x/ |  j  D]$ } | d | k r* | S| d 7} q Wd  S)Nr   È   )r   )r   ⁄name⁄i⁄defnr   r   r   ⁄_find_macroü   s    zCCompiler._find_macroc             C   sá   xÄ | D]x } t  | t É oa t | É d k oa t  | d t É sQ | d d k oa t  | d t É s t d | d d É Ç q q Wd S)	z◊Ensures that every element of 'definitions' is a valid macro
        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do
        nothing if all definitions are OK, raise TypeError otherwise.
        r(   È   Nr   zinvalid macro definition '%s': z.must be tuple (string,), (string, string), or z(string, None))r(   r-   )r$   ⁄tuple⁄lenr%   ⁄	TypeError)r   Zdefinitionsr+   r   r   r   ⁄_check_macro_definitionsß   s    #z"CCompiler._check_macro_definitionsc             C   sB   |  j  | É } | d k	 r( |  j | =n  |  j j | | f É d S)a_  Define a preprocessor macro for all compilations driven by this
        compiler object.  The optional parameter 'value' should be a
        string; if it is not supplied, then the macro will be defined
        without an explicit value and the exact outcome depends on the
        compiler used (XXX true? does ANSI say anything about this?)
        N)r,   r   ⁄append)r   r)   r'   r*   r   r   r   ⁄define_macro∏   s    	zCCompiler.define_macroc             C   sE   |  j  | É } | d k	 r( |  j | =n  | f } |  j j | É d S)a≥  Undefine a preprocessor macro for all compilations driven by
        this compiler object.  If the same macro is defined by
        'define_macro()' and undefined by 'undefine_macro()' the last call
        takes precedence (including multiple redefinitions or
        undefinitions).  If the macro is redefined/undefined on a
        per-compilation basis (ie. in the call to 'compile()'), then that
        takes precedence.
        N)r,   r   r2   )r   r)   r*   Zundefnr   r   r   ⁄undefine_macro«   s
    	zCCompiler.undefine_macroc             C   s   |  j  j | É d S)zÛAdd 'dir' to the list of directories that will be searched for
        header files.  The compiler is instructed to search directories in
        the order in which they are supplied by successive calls to
        'add_include_dir()'.
        N)r   r2   )r   ⁄dirr   r   r   ⁄add_include_dirŸ   s    zCCompiler.add_include_dirc             C   s   | d d Ö |  _  d S)ay  Set the list of directories that will be searched to 'dirs' (a
        list of strings).  Overrides any preceding calls to
        'add_include_dir()'; subsequence calls to 'add_include_dir()' add
        to the list passed to 'set_include_dirs()'.  This does not affect
        any list of standard include directories that the compiler may
        search by default.
        N)r   )r   ⁄dirsr   r   r   ⁄set_include_dirs·   s    zCCompiler.set_include_dirsc             C   s   |  j  j | É d S)aø  Add 'libname' to the list of libraries that will be included in
        all links driven by this compiler object.  Note that 'libname'
        should *not* be the name of a file containing a library, but the
        name of the library itself: the actual filename will be inferred by
        the linker, the compiler, or the compiler class (depending on the
        platform).

        The linker will be instructed to link against libraries in the
        order they were supplied to 'add_library()' and/or
        'set_libraries()'.  It is perfectly valid to duplicate library
        names; the linker will be instructed to link against libraries as
        many times as they are mentioned.
        N)r   r2   )r   ⁄libnamer   r   r   ⁄add_libraryÎ   s    zCCompiler.add_libraryc             C   s   | d d Ö |  _  d S)zÙSet the list of libraries to be included in all links driven by
        this compiler object to 'libnames' (a list of strings).  This does
        not affect any standard system libraries that the linker may
        include by default.
        N)r   )r   Zlibnamesr   r   r   ⁄set_libraries˚   s    zCCompiler.set_librariesc             C   s   |  j  j | É d S)a'  Add 'dir' to the list of directories that will be searched for
        libraries specified to 'add_library()' and 'set_libraries()'.  The
        linker will be instructed to search for libraries in the order they
        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
        N)r   r2   )r   r5   r   r   r   ⁄add_library_dir  s    zCCompiler.add_library_dirc             C   s   | d d Ö |  _  d S)z¿Set the list of library search directories to 'dirs' (a list of
        strings).  This does not affect any standard library search path
        that the linker may search by default.
        N)r   )r   r7   r   r   r   ⁄set_library_dirs  s    zCCompiler.set_library_dirsc             C   s   |  j  j | É d S)zlAdd 'dir' to the list of directories that will be searched for
        shared libraries at runtime.
        N)r   r2   )r   r5   r   r   r   ⁄add_runtime_library_dir  s    z!CCompiler.add_runtime_library_dirc             C   s   | d d Ö |  _  d S)z„Set the list of directories to search for shared libraries at
        runtime to 'dirs' (a list of strings).  This does not affect any
        standard search path that the runtime linker may search by
        default.
        N)r   )r   r7   r   r   r   ⁄set_runtime_library_dirs  s    z"CCompiler.set_runtime_library_dirsc             C   s   |  j  j | É d S)z„Add 'object' to the list of object files (or analogues, such as
        explicitly named library files or the output of "resource
        compilers") to be included in every link driven by this compiler
        object.
        N)r   r2   )r   ⁄objectr   r   r   ⁄add_link_object   s    zCCompiler.add_link_objectc             C   s   | d d Ö |  _  d S)zÍSet the list of object files (or analogues) to be included in
        every link to 'objects'.  This does not affect any standard object
        files that the linker may include by default (such as system
        libraries).
        N)r   )r   r   r   r   r   ⁄set_link_objects(  s    zCCompiler.set_link_objectsc             C   s∫  | d k r |  j  } n t | t É s6 t d É Ç n  | d k rN |  j } n1 t | t É rs | |  j pl g  } n t d É Ç | d k ró |  j } n= t | t t f É r» t | É |  j p¡ g  } n t d É Ç | d k rÈ g  } n  |  j | d d d | É} t	 | É t	 | É k s"t
 Ç t | | É } i  }	 xm t t	 | É É D]Y }
 | |
 } | |
 } t j j | É d } |  j t j j | É É | | f |	 | <qJW| | | | |	 f S)	z;Process arguments and decide which source files to compile.Nz%'output_dir' must be a string or Nonez/'macros' (if supplied) must be a list of tuplesz6'include_dirs' (if supplied) must be a list of strings⁄	strip_dirr   r   r(   )r   r$   r%   r0   r   ⁄listr   r.   ⁄object_filenamesr/   ⁄AssertionError⁄gen_preprocess_options⁄range⁄os⁄path⁄splitextr   ⁄dirname)r   Zoutdirr   Zincdirs⁄sources⁄dependsZextrar   ⁄pp_opts⁄buildr*   ⁄src⁄obj⁄extr   r   r   ⁄_setup_compile6  s:    			

zCCompiler._setup_compilec             C   sF   | d g } | r) d g | d  d Ö <n  | rB | | d  d Ö <n  | S)Nz-cz-gr   r   )r   rO   ⁄debugZbefore⁄cc_argsr   r   r   ⁄_get_cc_argsa  s    zCCompiler._get_cc_argsc             C   s·   | d k r |  j  } n t | t É s6 t d É Ç n  | d k rN |  j } n1 t | t É rs | |  j pl g  } n t d É Ç | d k ró |  j } n= t | t t f É r» t | É |  j p¡ g  } n t d É Ç | | | f S)a'  Typecheck and fix-up some of the arguments to the 'compile()'
        method, and return fixed-up values.  Specifically: if 'output_dir'
        is None, replaces it with 'self.output_dir'; ensures that 'macros'
        is a list, and augments it with 'self.macros'; ensures that
        'include_dirs' is a list, and augments it with 'self.include_dirs'.
        Guarantees that the returned values are of the correct type,
        i.e. for 'output_dir' either string or None, and for 'macros' and
        'include_dirs' either list or None.
        Nz%'output_dir' must be a string or Nonez/'macros' (if supplied) must be a list of tuplesz6'include_dirs' (if supplied) must be a list of strings)r   r$   r%   r0   r   rD   r   r.   )r   r   r   r   r   r   r   ⁄_fix_compile_argsj  s     
	zCCompiler._fix_compile_argsc             C   s=   |  j  | d | É} t | É t | É k s3 t Ç | i  f S)a+  Decide which souce files must be recompiled.

        Determine the list of object files corresponding to 'sources',
        and figure out which ones really need to be recompiled.
        Return a list of all object files and a dictionary telling
        which source files can be skipped.
        r   )rE   r/   rF   )r   rM   r   rN   r   r   r   r   ⁄_prep_compileä  s    	zCCompiler._prep_compilec             C   sp   t  | t t f É s$ t d É Ç n  t | É } | d k rH |  j } n t  | t É sf t d É Ç n  | | f S)z˚Typecheck and fix up some arguments supplied to various methods.
        Specifically: ensure that 'objects' is a list; if output_dir is
        None, replace with self.output_dir.  Return fixed versions of
        'objects' and 'output_dir'.
        z,'objects' must be a list or tuple of stringsNz%'output_dir' must be a string or None)r$   rD   r.   r0   r   r%   )r   r   r   r   r   r   ⁄_fix_object_argsö  s    zCCompiler._fix_object_argsc             C   s  | d k r |  j  } n= t | t t f É rI t | É |  j  pB g  } n t d É Ç | d k rm |  j } n= t | t t f É rû t | É |  j pó g  } n t d É Ç | d k r¬ |  j } n= t | t t f É rÛ t | É |  j pÏ g  } n t d É Ç | | | f S)a;  Typecheck and fix up some of the arguments supplied to the
        'link_*' methods.  Specifically: ensure that all arguments are
        lists, and augment them with their permanent versions
        (eg. 'self.libraries' augments 'libraries').  Return a tuple with
        fixed versions of all arguments.
        Nz3'libraries' (if supplied) must be a list of stringsz6'library_dirs' (if supplied) must be a list of stringsz>'runtime_library_dirs' (if supplied) must be a list of strings)r   r$   rD   r.   r0   r   r   )r   r   r   r   r   r   r   ⁄_fix_lib_args´  s&    			zCCompiler._fix_lib_argsc             C   sE   |  j  r d S|  j r. t | | d d É} n t | | É } | Sd S)zjReturn true if we need to relink the files listed in 'objects'
        to recreate 'output_file'.
        TZmissing⁄newerN)r   r   r   )r   r   ⁄output_filer\   r   r   r   ⁄
_need_linkÕ  s    		zCCompiler._need_linkc       	      C   sµ   t  | t É s | g } n  d } t |  j É } x~ | D]v } t j j | É \ } } |  j j | É } y1 |  j j	 | É } | | k  ró | } | } n  Wq7 t
 k
 r¨ Yq7 Xq7 W| S)z|Detect the language of a given file, or list of files. Uses
        language_map, and language_order to do the job.
        N)r$   rD   r/   ⁄language_orderrI   rJ   rK   ⁄language_map⁄get⁄indexr   )	r   rM   Zlangrb   ⁄source⁄baserS   ZextlangZextindexr   r   r   ⁄detect_language⁄  s    	zCCompiler.detect_languagec             C   s   d S)a’  Preprocess a single C/C++ source file, named in 'source'.
        Output will be written to file named 'output_file', or stdout if
        'output_file' not supplied.  'macros' is a list of macro
        definitions as for 'compile()', which will augment the macros set
        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
        list of directory names that will be added to the default list.

        Raises PreprocessError on failure.
        Nr   )r   rc   r]   r   r   ⁄extra_preargs⁄extra_postargsr   r   r   ⁄
preprocessÚ  s    zCCompiler.preprocessc	             C   sü   |  j  | | | | | | É \ } }	 } }
 } |  j |
 | | É } xV |	 D]N } y | | \ } } Wn t k
 rz wI Yn X|  j | | | | | |
 É qI W|	 S)aK	  Compile one or more source files.

        'sources' must be a list of filenames, most likely C/C++
        files, but in reality anything that can be handled by a
        particular compiler and compiler class (eg. MSVCCompiler can
        handle resource files in 'sources').  Return a list of object
        filenames, one per source filename in 'sources'.  Depending on
        the implementation, not all source files will necessarily be
        compiled, but all corresponding object filenames will be
        returned.

        If 'output_dir' is given, object files will be put under it, while
        retaining their original path component.  That is, "foo/bar.c"
        normally compiles to "foo/bar.o" (for a Unix implementation); if
        'output_dir' is "build", then it would compile to
        "build/foo/bar.o".

        'macros', if given, must be a list of macro definitions.  A macro
        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
        The former defines a macro; if the value is None, the macro is
        defined without an explicit value.  The 1-tuple case undefines a
        macro.  Later definitions/redefinitions/ undefinitions take
        precedence.

        'include_dirs', if given, must be a list of strings, the
        directories to add to the default include file search path for this
        compilation only.

        'debug' is a boolean; if true, the compiler will be instructed to
        output debug symbols in (or alongside) the object file(s).

        'extra_preargs' and 'extra_postargs' are implementation- dependent.
        On platforms that have the notion of a command-line (e.g. Unix,
        DOS/Windows), they are most likely lists of strings: extra
        command-line arguments to prepand/append to the compiler command
        line.  On other platforms, consult the implementation class
        documentation.  In any event, they are intended as an escape hatch
        for those occasions when the abstract compiler framework doesn't
        cut the mustard.

        'depends', if given, is a list of filenames that all targets
        depend on.  If a source file is older than any file in
        depends, then the source file will be recompiled.  This
        supports dependency tracking, but only at a coarse
        granularity.

        Raises CompileError on failure.
        )rT   rW   ⁄KeyError⁄_compile)r   rM   r   r   r   rU   rf   rg   rN   r   rO   rP   rV   rR   rQ   rS   r   r   r   ⁄compileˇ  s    6 zCCompiler.compilec             C   s   d S)zCompile 'src' to product 'obj'.Nr   )r   rR   rQ   rS   rV   rg   rO   r   r   r   rj   C  s    zCCompiler._compilec             C   s   d S)a&  Link a bunch of stuff together to create a static library file.
        The "bunch of stuff" consists of the list of object files supplied
        as 'objects', the extra object files supplied to
        'add_link_object()' and/or 'set_link_objects()', the libraries
        supplied to 'add_library()' and/or 'set_libraries()', and the
        libraries supplied as 'libraries' (if any).

        'output_libname' should be a library name, not a filename; the
        filename will be inferred from the library name.  'output_dir' is
        the directory where the library file will be put.

        'debug' is a boolean; if true, debugging information will be
        included in the library (note that on most platforms, it is the
        compile step where this matters: the 'debug' flag is included here
        just for consistency).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LibError on failure.
        Nr   )r   r   ⁄output_libnamer   rU   ⁄target_langr   r   r   ⁄create_static_libI  s    zCCompiler.create_static_libZshared_objectZshared_library⁄
executablec             C   s
   t  Ç d S)au  Link a bunch of stuff together to create an executable or
        shared library file.

        The "bunch of stuff" consists of the list of object files supplied
        as 'objects'.  'output_filename' should be a filename.  If
        'output_dir' is supplied, 'output_filename' is relative to it
        (i.e. 'output_filename' can provide directory components if
        needed).

        'libraries' is a list of libraries to link against.  These are
        library names, not filenames, since they're translated into
        filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
        on Unix and "foo.lib" on DOS/Windows).  However, they can include a
        directory component, which means the linker will look in that
        specific directory rather than searching all the normal locations.

        'library_dirs', if supplied, should be a list of directories to
        search for libraries that were specified as bare library names
        (ie. no directory component).  These are on top of the system
        default and those supplied to 'add_library_dir()' and/or
        'set_library_dirs()'.  'runtime_library_dirs' is a list of
        directories that will be embedded into the shared library and used
        to search for other shared libraries that *it* depends on at
        run-time.  (This may only be relevant on Unix.)

        'export_symbols' is a list of symbols that the shared library will
        export.  (This appears to be relevant only on Windows.)

        'debug' is as for 'compile()' and 'create_static_lib()', with the
        slight distinction that it actually matters on most platforms (as
        opposed to 'create_static_lib()', which includes a 'debug' flag
        mostly for form's sake).

        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
        of course that they supply command-line arguments for the
        particular linker being used).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LinkError on failure.
        N)⁄NotImplementedError)r   Ztarget_descr   ⁄output_filenamer   r   r   r   ⁄export_symbolsrU   rf   rg   ⁄
build_temprm   r   r   r   ⁄linki  s    9zCCompiler.linkc             C   sG   |  j  t j | |  j | d d É| | | | | | |	 |
 | | É d  S)N⁄lib_type⁄shared)rt   r   ⁄SHARED_LIBRARY⁄library_filename)r   r   rl   r   r   r   r   rr   rU   rf   rg   rs   rm   r   r   r   ⁄link_shared_libß  s    	zCCompiler.link_shared_libc             C   s8   |  j  t j | | | | | | | | |	 |
 | | É d  S)N)rt   r   ⁄SHARED_OBJECT)r   r   rq   r   r   r   r   rr   rU   rf   rg   rs   rm   r   r   r   ⁄link_shared_objectº  s
    	zCCompiler.link_shared_objectc             C   sA   |  j  t j | |  j | É | | | | d  | | |	 d  |
 É d  S)N)rt   r   ⁄
EXECUTABLE⁄executable_filename)r   r   Zoutput_prognamer   r   r   r   rU   rf   rg   rm   r   r   r   ⁄link_executable–  s    zCCompiler.link_executablec             C   s
   t  Ç d S)zkReturn the compiler option to add 'dir' to the list of
        directories searched for libraries.
        N)rp   )r   r5   r   r   r   ⁄library_dir_optionÊ  s    zCCompiler.library_dir_optionc             C   s
   t  Ç d S)zsReturn the compiler option to add 'dir' to the list of
        directories searched for runtime libraries.
        N)rp   )r   r5   r   r   r   ⁄runtime_library_dir_optionÏ  s    z$CCompiler.runtime_library_dir_optionc             C   s
   t  Ç d S)zReturn the compiler option to add 'dir' to the list of libraries
        linked into the shared library or executable.
        N)rp   )r   ⁄libr   r   r   ⁄library_optionÚ  s    zCCompiler.library_optionc             C   sM  d d l  } | d k r! g  } n  | d k r6 g  } n  | d k rK g  } n  | d k r` g  } n  | j d | d d É\ } } t j | d É }	 z7 x | D] }
 |	 j d |
 É qö W|	 j d | É Wd |	 j É  Xy |  j | g d	 | É} Wn t k
 r	d
 SYn Xy  |  j | d d | d | ÉWn t	 t
 f k
 rHd
 SYn Xd S)z∑Return a boolean indicating whether funcname is supported on
        the current platform.  The optional arguments can be used to
        augment the compilation environment.
        r   Nz.c⁄textT⁄wz#include "%s"
z+main (int argc, char **argv) {
    %s();
}
r   Fza.outr   r   )⁄tempfileZmkstemprI   ⁄fdopen⁄write⁄closerk   ZCompileErrorr~   Z	LinkErrorr0   )r   ZfuncnameZincludesr   r   r   rÖ   ⁄fdZfname⁄fZinclr   r   r   r   ⁄has_function¯  s8    							zCCompiler.has_functionc             C   s
   t  Ç d S)aH  Search the specified list of directories for a static or shared
        library file 'lib' and return the full path to that file.  If
        'debug' true, look for a debugging version (if that makes sense on
        the current platform).  Return None if 'lib' wasn't found in any of
        the specified directories.
        N)rp   )r   r7   rÅ   rU   r   r   r   ⁄find_library_file#  s    zCCompiler.find_library_file⁄ c             C   s‡   | d  k r d } n  g  } xæ | D]∂ } t  j j | É \ } } t  j j | É d } | t  j j | É d  Ö } | |  j k rö t d | | f É Ç n  | rµ t  j j | É } n  | j t  j j	 | | |  j
 É É q" W| S)Nrç   r(   z"unknown file type '%s' (from '%s'))rI   rJ   rK   ⁄
splitdrive⁄isabs⁄src_extensionsZUnknownFileError⁄basenamer2   ⁄join⁄obj_extension)r   Zsource_filenamesrC   r   Z	obj_namesZsrc_namerd   rS   r   r   r   rE   N  s    	zCCompiler.object_filenamesc             C   sG   | d  k	 s t  Ç | r- t j j | É } n  t j j | | |  j É S)N)rF   rI   rJ   rë   rí   ⁄shared_lib_extension)r   rë   rC   r   r   r   r   ⁄shared_object_filename_  s    z CCompiler.shared_object_filenamec             C   sM   | d  k	 s t  Ç | r- t j j | É } n  t j j | | |  j pH d É S)Nrç   )rF   rI   rJ   rë   rí   ⁄exe_extension)r   rë   rC   r   r   r   r   r}   e  s    zCCompiler.executable_filename⁄staticc       
      C   s†   | d  k	 s t  Ç | d k r- t d É Ç n  t |  | d É } t |  | d É } t j j | É \ } } | | | f }	 | rä d } n  t j j | | |	 É S)	Nró   rv   ⁄dylibz0'lib_type' must be "static", "shared" or "dylib"Z_lib_formatZ_lib_extensionrç   )ró   zsharedrò   )rF   r   ⁄getattrrI   rJ   ⁄splitrí   )
r   r9   ru   rC   r   ZfmtrS   r5   rd   ⁄filenamer   r   r   rx   k  s    	zCCompiler.library_filenamer(   c             C   s   t  j | É d  S)N)r
   rU   )r   ⁄msg⁄levelr   r   r   ⁄announce~  s    zCCompiler.announcec             C   s'   d d l  m } | r# t | É n  d  S)Nr   )⁄DEBUG)Zdistutils.debugrü   ⁄print)r   rú   rü   r   r   r   ⁄debug_printÅ  s    zCCompiler.debug_printc             C   s   t  j j d | É d  S)Nzwarning: %s
)⁄sys⁄stderrrá   )r   rú   r   r   r   ⁄warnÜ  s    zCCompiler.warnc             C   s   t  | | | |  j É d  S)N)r	   r   )r   ⁄func⁄argsrú   rù   r   r   r   r	   â  s    zCCompiler.executec             C   s   t  | d |  j Éd  S)Nr   )r   r   )r   ⁄cmdr   r   r   r   å  s    zCCompiler.spawnc             C   s   t  | | d |  j ÉS)Nr   )r   r   )r   rQ   Zdstr   r   r   r   è  s    zCCompiler.move_fileiˇ  c             C   s   t  | | d |  j Éd  S)Nr   )r   r   )r   r)   ⁄moder   r   r   r   í  s    zCCompiler.mkpath)Br!   ⁄
__module__⁄__qualname__⁄__doc__Zcompiler_typerê   rì   Zstatic_lib_extensionrî   Zstatic_lib_formatZshared_lib_formatrñ   r`   r_   r   r#   r   r,   r1   r3   r4   r6   r8   r:   r;   r<   r=   r>   r?   rA   rB   rT   rW   rX   rY   rZ   r[   r^   re   rh   rk   rj   rn   rz   rw   r|   rt   ry   r{   r~   r   rÄ   rÇ   rã   rå   rE   rï   r}   rx   rû   r°   r§   r	   r   r   r   r   r   r   r   r      s÷   


$ 
+	 "	B4*+r   zcygwin.*⁄unix⁄posix⁄ntZmsvcc             C   s   |  d k r t  j }  n  | d k r0 t j } n  xH t D]@ \ } } t j | | É d k	 ss t j | |  É d k	 r7 | Sq7 Wd S)ak  Determine the default compiler to use for the given platform.

       osname should be one of the standard Python OS names (i.e. the
       ones returned by os.name) and platform the common value
       returned by sys.platform for the platform in question.

       The default values are os.name and sys.platform in case the
       parameters are not given.
    Nr¨   )rI   r)   r¢   ⁄platform⁄_default_compilers⁄re⁄match)ZosnamerØ   ⁄pattern⁄compilerr   r   r   ⁄get_default_compiler®  s    
rµ   ZunixccompilerZUnixCCompilerzstandard UNIX-style compilerZmsvccompilerZMSVCCompilerzMicrosoft Visual C++ZcygwinccompilerZCygwinCCompilerz'Cygwin port of GNU C Compiler for Win32⁄cygwinZMingw32CCompilerz(Mingw32 port of GNU C Compiler for Win32Zmingw32ZbcppcompilerZBCPPCompilerzBorland C++ CompilerZbcppc              C   sv   d d l  m }  g  } x6 t j É  D]( } | j d | d t | d f É q# W| j É  |  | É } | j d É d S)zyPrint list of available compilers (used by the "--help-compiler"
    options to "build", "build_ext", "build_clib").
    r   )⁄FancyGetoptz	compiler=Nr-   zList of available compilers:)Zdistutils.fancy_getoptr∑   ⁄compiler_classr   r2   ⁄sortZ
print_help)r∑   Z	compilersr¥   Zpretty_printerr   r   r   ⁄show_compilersÃ  s    
r∫   c             C   s#  |  d k r t  j }  n  y2 | d k r6 t |  É } n  t | \ } } } WnE t k
 rë d |  } | d k	 rÅ | d | } n  t | É Ç Yn Xy5 d | } t | É t j | }	 t	 |	 É | }
 WnI t
 k
 rÎ t d | É Ç Yn( t k
 rt d | | f É Ç Yn X|
 d | | É S)a[  Generate an instance of some CCompiler subclass for the supplied
    platform/compiler combination.  'plat' defaults to 'os.name'
    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler
    for that platform.  Currently only 'posix' and 'nt' are supported, and
    the default compilers are "traditional Unix interface" (UnixCCompiler
    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly
    possible to ask for a Unix compiler object under Windows, and a
    Microsoft compiler object under Unix -- if you supply a value for
    'compiler', 'plat' is ignored.
    Nz5don't know how to compile C/C++ code on platform '%s'z with '%s' compilerz
distutils.z4can't compile C/C++ code: unable to load module '%s'zBcan't compile C/C++ code: unable to find class '%s' in module '%s')rI   r)   rµ   r∏   ri   ZDistutilsPlatformError⁄
__import__r¢   ⁄modules⁄vars⁄ImportErrorZDistutilsModuleError)Zplatr¥   r   r   r   Zmodule_nameZ
class_nameZlong_descriptionrú   ⁄module⁄klassr   r   r   ⁄new_compiler›  s2    


r¡   c             C   s˘   g  } x  |  D]¬ } t  | t É oA d t | É k o? d k n sW t d | É Ç n  t | É d k rÅ | j d | d É q t | É d k r | d d k rª | j d | d É qœ | j d | É q q Wx | D] } | j d	 | É q⁄ W| S)
a  Generate C pre-processor options (-D, -U, -I) as used by at least
    two types of compilers: the typical Unix compiler and Visual C++.
    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)
    means undefine (-U) macro 'name', and (name,value) means define (-D)
    macro 'name' to 'value'.  'include_dirs' is just a list of directory
    names to be added to the header file search path (-I).  Returns a list
    of command-line options suitable for either Unix compilers or Visual
    C++.
    r(   r-   zPbad macro definition '%s': each element of 'macros' list must be a 1- or 2-tuplez-U%sr   Nz-D%sz-D%s=%sz-I%s)r$   r.   r/   r0   r2   )r   r   rO   Zmacror5   r   r   r   rG   
  s    1rG   c             C   s˛   g  } x$ | D] } | j  |  j | É É q WxF | D]> } |  j | É } t | t É re | | } q4 | j  | É q4 WxÅ | D]y } t j j | É \ } }	 | r‡ |  j | g |	 É }
 |
 rÃ | j  |
 É qˆ |  j	 d | É q} | j  |  j
 | É É q} W| S)ac  Generate linker options for searching library directories and
    linking with specific libraries.  'libraries' and 'library_dirs' are,
    respectively, lists of library names (not filenames!) and search
    directories.  Returns a list of command-line options suitable for use
    with some compiler (depending on the two format strings passed in).
    z6no library file corresponding to '%s' found (skipping))r2   r   rÄ   r$   rD   rI   rJ   rö   rå   r§   rÇ   )r¥   r   r   r   Zlib_optsr5   ZoptrÅ   Zlib_dirZlib_nameZlib_filer   r   r   ⁄gen_lib_options7  s$    	r¬   )r´   r¢   rI   r±   Zdistutils.errorsZdistutils.spawnr   Zdistutils.file_utilr   Zdistutils.dir_utilr   Zdistutils.dep_utilr   r   Zdistutils.utilr   r	   Z	distutilsr
   r   r∞   rµ   r∏   r∫   r¡   rG   r¬   r   r   r   r   ⁄<module>   s<   $
ˇ ˇ ˇ î			



--                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python3.4/distutils/__pycache__/cmd.cpython-34.pyc                                          0100644 0000000 0000000 00000036456 13077704335 022044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TÀJ  „               @   sü   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z m Z m	 Z	 m
 Z
 m Z d d l m Z Gd d Ñ  d É Z Gd d	 Ñ  d	 e É Z d S)
ztdistutils.cmd

Provides the Command class, the base class for the command classes
in the distutils.command package.
È    N)⁄DistutilsOptionError)⁄util⁄dir_util⁄	file_util⁄archive_util⁄dep_util)⁄logc               @   s€  e  Z d  Z d Z g  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d	 Ñ  Z d
 d Ñ  Z	 d d d d Ñ Z
 d d Ñ  Z d d d Ñ Z d d Ñ  Z d d d Ñ Z d d d Ñ Z d d Ñ  Z d d d Ñ Z d d  Ñ  Z d! d" Ñ  Z d# d$ Ñ  Z d% d& Ñ  Z d d' d( Ñ Z d) d* d+ Ñ Z d, d- Ñ  Z d. d/ Ñ  Z d0 d1 Ñ  Z d d d2 d3 Ñ Z d4 d5 d6 Ñ Z d d d d d7 d8 Ñ Z d d d) d d9 d: Ñ Z d d; d< Ñ Z d d d= d> Ñ Z  d d d d d? d@ Ñ Z! d d d dA dB Ñ Z" d S)C⁄Commanda}  Abstract base class for defining command classes, the "worker bees"
    of the Distutils.  A useful analogy for command classes is to think of
    them as subroutines with local variables called "options".  The options
    are "declared" in 'initialize_options()' and "defined" (given their
    final values, aka "finalized") in 'finalize_options()', both of which
    must be defined by every command class.  The distinction between the
    two is necessary because option values might come from the outside
    world (command line, config file, ...), and any options dependent on
    other options must be computed *after* these outside influences have
    been processed -- hence 'finalize_options()'.  The "body" of the
    subroutine, where it does all its work based on the values of its
    options, is the 'run()' method, which must also be implemented by every
    command class.
    c             C   sì   d d l  m } t | | É s. t d É Ç n  |  j t k rL t d É Ç n  | |  _ |  j É  d |  _	 | j
 |  _
 d |  _ d |  _ d |  _ d S)zﬁCreate and initialize a new Command object.  Most importantly,
        invokes the 'initialize_options()' method, which is the real
        initializer and depends on the actual command being
        instantiated.
        r   )⁄Distributionz$dist must be a Distribution instancezCommand is an abstract classN)Zdistutils.distr
   ⁄
isinstance⁄	TypeError⁄	__class__r	   ⁄RuntimeError⁄distribution⁄initialize_optionsZ_dry_run⁄verbose⁄force⁄help⁄	finalized)⁄selfZdistr
   © r   ˙#/usr/lib/python3.4/distutils/cmd.py⁄__init__/   s    	

			zCommand.__init__c             C   sR   | d k rB t  |  d | É } | d  k r; t  |  j | É S| Sn t | É Ç d  S)N⁄dry_run⁄_)⁄getattrr   ⁄AttributeError)r   ⁄attrZmyvalr   r   r   ⁄__getattr___   s    zCommand.__getattr__c             C   s#   |  j  s |  j É  n  d |  _  d  S)NÈ   )r   ⁄finalize_options)r   r   r   r   ⁄ensure_finalizedi   s    	zCommand.ensure_finalizedc             C   s   t  d |  j É Ç d S)aŸ  Set default values for all the options that this command
        supports.  Note that these defaults may be overridden by other
        commands, by the setup script, by config files, or by the
        command-line.  Thus, this is not the place to code dependencies
        between options; generally, 'initialize_options()' implementations
        are just a bunch of "self.foo = None" assignments.

        This method must be implemented by all command classes.
        z,abstract method -- subclass %s must overrideN)r   r   )r   r   r   r   r   {   s    
zCommand.initialize_optionsc             C   s   t  d |  j É Ç d S)a  Set final values for all the options that this command supports.
        This is always called as late as possible, ie.  after any option
        assignments from the command-line or from other commands have been
        done.  Thus, this is the place to code option dependencies: if
        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
        long as 'foo' still has the same value it was assigned in
        'initialize_options()'.

        This method must be implemented by all command classes.
        z,abstract method -- subclass %s must overrideN)r   r   )r   r   r   r   r    à   s    zCommand.finalize_optionsN⁄ c             C   sŸ   d d l  m } | d  k r/ d |  j É  } n  |  j | | d t j É| d } x |  j D]t \ } } } | j | É } | d	 d k rû | d  d
 Ö } n  t |  | É } |  j | d | | f d t j Éq] Wd  S)Nr   )⁄longopt_xlatezcommand options for '%s':⁄levelz  r   ˙=z%s = %sÈˇˇˇˇr&   )	Zdistutils.fancy_getoptr#   ⁄get_command_name⁄announcer   ⁄INFO⁄user_options⁄	translater   )r   ⁄header⁄indentr#   ⁄optionr   ⁄valuer   r   r   ⁄dump_optionsó   s    
zCommand.dump_optionsc             C   s   t  d |  j É Ç d S)aæ  A command's raison d'etre: carry out the action it exists to
        perform, controlled by the options initialized in
        'initialize_options()', customized by other commands, the setup
        script, the command-line, and config files, and finalized in
        'finalize_options()'.  All terminal output and filesystem
        interaction should be done by 'run()'.

        This method must be implemented by all command classes.
        z,abstract method -- subclass %s must overrideN)r   r   )r   r   r   r   ⁄run•   s    
zCommand.runr   c             C   s   t  j  | | É d S)zmIf the current verbosity level is of greater than or equal to
        'level' print 'msg' to stdout.
        N)r   )r   ⁄msgr$   r   r   r   r(   ≤   s    zCommand.announcec             C   s4   d d l  m } | r0 t | É t j j É  n  d S)z~Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        r   )⁄DEBUGN)Zdistutils.debugr3   ⁄print⁄sys⁄stdout⁄flush)r   r2   r3   r   r   r   ⁄debug_print∏   s    
zCommand.debug_printc             C   s^   t  |  | É } | d  k r/ t |  | | É | St | t É sZ t d | | | f É Ç n  | S)Nz'%s' must be a %s (got `%s`))r   ⁄setattrr   ⁄strr   )r   r.   ⁄what⁄default⁄valr   r   r   ⁄_ensure_stringlikeœ   s    zCommand._ensure_stringlikec             C   s   |  j  | d | É d S)zWEnsure that 'option' is a string; if not defined, set it to
        'default'.
        ⁄stringN)r>   )r   r.   r<   r   r   r   ⁄ensure_stringŸ   s    zCommand.ensure_stringc             C   s°   t  |  | É } | d k r d St | t É rM t |  | t j d | É É nP t | t É rx t d d Ñ  | DÉ É } n d } | sù t d | | f É Ç n  d S)zÓEnsure that 'option' is a list of strings.  If 'option' is
        currently a string, we split it either on /,\s*/ or /\s+/, so
        "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
        ["foo", "bar", "baz"].
        Nz,\s*|\s+c             s   s   |  ] } t  | t É Vq d  S)N)r   r:   )⁄.0⁄vr   r   r   ˙	<genexpr>Ï   s    z-Command.ensure_string_list.<locals>.<genexpr>Fz''%s' must be a list of strings (got %r))	r   r   r:   r9   ⁄re⁄split⁄list⁄allr   )r   r.   r=   ⁄okr   r   r   ⁄ensure_string_listﬂ   s    zCommand.ensure_string_listc             C   sO   |  j  | | | É } | d  k	 rK | | É rK t d | | | f É Ç n  d  S)Nzerror in '%s' option: )r>   r   )r   r.   Ztesterr;   Z	error_fmtr<   r=   r   r   r   ⁄_ensure_tested_stringÙ   s    
zCommand._ensure_tested_stringc             C   s    |  j  | t j j d d É d S)z5Ensure that 'option' is the name of an existing file.⁄filenamez$'%s' does not exist or is not a fileN)rJ   ⁄os⁄path⁄isfile)r   r.   r   r   r   ⁄ensure_filename˚   s    zCommand.ensure_filenamec             C   s    |  j  | t j j d d É d  S)Nzdirectory namez)'%s' does not exist or is not a directory)rJ   rL   rM   ⁄isdir)r   r.   r   r   r   ⁄ensure_dirname  s    zCommand.ensure_dirnamec             C   s$   t  |  d É r |  j S|  j j Sd  S)N⁄command_name)⁄hasattrrR   r   ⁄__name__)r   r   r   r   r'   	  s    zCommand.get_command_namec             G   sh   |  j  j | É } | j É  xE | D]= \ } } t |  | É d k r# t |  | t | | É É q# q# Wd S)a>  Set the values of any "undefined" options from corresponding
        option values in some other command object.  "Undefined" here means
        "is None", which is the convention used to indicate that an option
        has not been changed between 'initialize_options()' and
        'finalize_options()'.  Usually called from 'finalize_options()' for
        options that depend on some other command rather than another
        option of the same command.  'src_cmd' is the other command from
        which option values will be taken (a command object will be created
        for it if necessary); the remaining arguments are
        '(src_option,dst_option)' tuples which mean "take the value of
        'src_option' in the 'src_cmd' command object, and copy it to
        'dst_option' in the current command object".
        N)r   ⁄get_command_objr!   r   r9   )r   Zsrc_cmdZoption_pairsZsrc_cmd_objZ
src_optionZ
dst_optionr   r   r   ⁄set_undefined_options  s
    
zCommand.set_undefined_optionsc             C   s#   |  j  j | | É } | j É  | S)z˚Wrapper around Distribution's 'get_command_obj()' method: find
        (create if necessary and 'create' is true) the command object for
        'command', call its 'ensure_finalized()' method, and return the
        finalized command object.
        )r   rU   r!   )r   ⁄command⁄createZcmd_objr   r   r   ⁄get_finalized_command$  s    
zCommand.get_finalized_commandr   c             C   s   |  j  j | | É S)N)r   ⁄reinitialize_command)r   rW   Zreinit_subcommandsr   r   r   rZ   0  s    zCommand.reinitialize_commandc             C   s   |  j  j | É d S)z¬Run some other command: uses the 'run_command()' method of
        Distribution, which creates and finalizes the command object if
        necessary and then invokes its 'run()' method.
        N)r   ⁄run_command)r   rW   r   r   r   r[   4  s    zCommand.run_commandc             C   sL   g  } x? |  j  D]4 \ } } | d k s4 | |  É r | j | É q q W| S)ak  Determine the sub-commands that are relevant in the current
        distribution (ie., that need to be run).  This is based on the
        'sub_commands' class attribute: each tuple in that list may include
        a method that we call to determine if the subcommand needs to be
        run for the current distribution.  Return a list of command names.
        N)⁄sub_commands⁄append)r   ZcommandsZcmd_name⁄methodr   r   r   ⁄get_sub_commands;  s
    zCommand.get_sub_commandsc             C   s!   t  j d |  j É  | f É d  S)Nzwarning: %s: %s
)r   ⁄warnr'   )r   r2   r   r   r   r`   K  s    	zCommand.warnc             C   s    t  j | | | d |  j Éd  S)Nr   )r   ⁄executer   )r   ⁄func⁄argsr2   r$   r   r   r   ra   O  s    zCommand.executeiˇ  c             C   s   t  j | | d |  j Éd  S)Nr   )r   ⁄mkpathr   )r   ⁄name⁄moder   r   r   rd   R  s    zCommand.mkpathc          	   C   s)   t  j | | | | |  j | d |  j ÉS)z—Copy a file respecting verbose, dry-run and force flags.  (The
        former two default to whatever is in the Distribution object, and
        the latter defaults to false for commands that don't define it.)r   )r   ⁄	copy_filer   r   )r   ⁄infile⁄outfile⁄preserve_mode⁄preserve_times⁄linkr$   r   r   r   rg   U  s    zCommand.copy_filec          	   C   s)   t  j | | | | | |  j d |  j ÉS)z\Copy an entire directory tree respecting verbose, dry-run,
        and force flags.
        r   )r   ⁄	copy_treer   r   )r   rh   ri   rj   rk   Zpreserve_symlinksr$   r   r   r   rm   ^  s    zCommand.copy_treec             C   s   t  j | | d |  j ÉS)z$Move a file respecting dry-run flag.r   )r   ⁄	move_filer   )r   ⁄srcZdstr$   r   r   r   rn   g  s    zCommand.move_filec             C   s*   d d l  m } | | | d |  j Éd S)z2Spawn an external command respecting dry-run flag.r   )⁄spawnr   N)Zdistutils.spawnrp   r   )r   ⁄cmdZsearch_pathr$   rp   r   r   r   rp   k  s    zCommand.spawnc             C   s+   t  j | | | | d |  j d | d | ÉS)Nr   ⁄owner⁄group)r   ⁄make_archiver   )r   Z	base_name⁄formatZroot_dirZbase_dirrr   rs   r   r   r   rt   p  s    	zCommand.make_archivec             C   s≈   | d k r d | } n  t  | t É r4 | f } n$ t  | t t f É sX t d É Ç n  | d k rÄ d | d j | É f } n  |  j sõ t j | | É r¥ |  j	 | | | | É n t
 j | É d S)aÃ  Special case of 'execute()' for operations that process one or
        more input files and generate one output file.  Works just like
        'execute()', except the operation is skipped and a different
        message printed if 'outfile' already exists and is newer than all
        files listed in 'infiles'.  If the command defined 'self.force',
        and it is true, then the command is unconditionally run -- does no
        timestamp checks.
        Nzskipping %s (inputs unchanged)z9'infiles' must be a string, or a list or tuple of stringszgenerating %s from %sz, )r   r:   rF   ⁄tupler   ⁄joinr   r   Znewer_groupra   r   ⁄debug)r   Zinfilesri   rb   rc   Zexec_msgZskip_msgr$   r   r   r   ⁄	make_filev  s    
zCommand.make_file)#rT   ⁄
__module__⁄__qualname__⁄__doc__r\   r   r   r!   r   r    r0   r1   r(   r8   r>   r@   rI   rJ   rO   rQ   r'   rV   rY   rZ   r[   r_   r`   ra   rd   rg   rm   rn   rp   rt   ry   r   r   r   r   r	      sF   0

r	   c               @   sO   e  Z d  Z d Z d g Z d d Ñ  Z d d Ñ  Z d	 d
 Ñ  Z d d Ñ  Z d S)⁄install_miscz{Common base class for installing some files in a subdirectory.
    Currently used by install_data and install_scripts.
    ˙install-dir=⁄d˙!directory to install the files toc             C   s   d  |  _  g  |  _ d  S)N)⁄install_dir⁄outfiles)r   r   r   r   r   ¢  s    	zinstall_misc.initialize_optionsc             C   s   |  j  d | d f É d  S)NZinstallrÅ   )rV   )r   ⁄dirnamer   r   r   ⁄_install_dir_from¶  s    zinstall_misc._install_dir_fromc             C   sm   g  |  _  | s d  S|  j |  j É xC | D]; } |  j | |  j É |  j  j t j j |  j | É É q* Wd  S)N)rÇ   rd   rÅ   rg   r]   rL   rM   rw   )r   Zfilelist⁄fr   r   r   ⁄_copy_files©  s    	zinstall_misc._copy_filesc             C   s   |  j  S)N)rÇ   )r   r   r   r   ⁄get_outputs≤  s    zinstall_misc.get_outputsN)r~   r   rÄ   )	rT   rz   r{   r|   r*   r   rÑ   rÜ   rá   r   r   r   r   r}   õ  s   		r}   )r|   r5   rL   rD   Zdistutils.errorsr   Z	distutilsr   r   r   r   r   r   r	   r}   r   r   r   r   ⁄<module>   s   $(ˇ ê                                                                                                                                                                                                                  usr/lib/python3.4/distutils/__pycache__/config.cpython-34.pyc                                       0100644 0000000 0000000 00000007333 13077704335 022536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T  „               @   sR   d  Z  d d l Z d d l m Z d d l m Z d Z Gd d Ñ  d e É Z d S)zèdistutils.pypirc

Provides the PyPIRCCommand class, the base class for the command classes
that uses .pypirc in the distutils.command package.
È    N)⁄ConfigParser)⁄CommandzE[distutils]
index-servers =
    pypi

[pypi]
username:%s
password:%s
c               @   sò   e  Z d  Z d Z d Z d Z d Z d Z d d d e f d g Z d g Z	 d
 d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)⁄PyPIRCCommandz;Base command that knows how to handle the .pypirc file
    zhttps://pypi.python.org/pypi⁄pypiNzrepository=⁄rzurl of repository [default: %s]˙show-response˙&display full response text from serverc             C   s   t  j j t  j j d É d É S)zReturns rc file path.˙~z.pypirc)⁄os⁄path⁄join⁄
expanduser)⁄self© r   ˙&/usr/lib/python3.4/distutils/config.py⁄_get_rc_file&   s    zPyPIRCCommand._get_rc_filec             C   s[   |  j  É  } t j t j | t j t j Bd É d É è } | j t | | f É Wd QXd S)zCreates a default .pypirc file.iÄ  ⁄wN)r   r
   ⁄fdopen⁄open⁄O_CREAT⁄O_WRONLY⁄write⁄DEFAULT_PYPIRC)r   ⁄username⁄password⁄rc⁄fr   r   r   ⁄_store_pypirc*   s    .zPyPIRCCommand._store_pypircc             C   sY  |  j  É  } t j j | É rU|  j d | É |  j p> |  j } |  j pP |  j } t	 É  } | j
 | É | j É  } d | k rŒ| j d d É } d d Ñ  | j d É DÉ } | g  k r⁄ d | k r” d g } q⁄ i  Sn  xu| D]Ê } i | d 6}	 | j | d	 É |	 d	 <xd d
 |  j f d |  j f d f D]A \ }
 } | j | |
 É rc| j | |
 É |	 |
 <q,| |	 |
 <q,W| d k r£| |  j d f k r£|  j |	 d
 <|	 S|	 d | k s√|	 d
 | k r· |	 Sq· WqUd | k rUd } | j | d
 É r| j | d
 É } n	 |  j } i | j | d	 É d	 6| j | d É d 6| d
 6| d 6|  j d 6Sn  i  S)zReads the .pypirc file.zUsing PyPI login from %sZ	distutilszindex-serversc             S   s.   g  |  ]$ } | j  É  d  k r | j  É  ë q S)⁄ )⁄strip)⁄.0⁄serverr   r   r   ˙
<listcomp>>   s   	 z.PyPIRCCommand._read_pypirc.<locals>.<listcomp>⁄
r   r!   r   ⁄
repository⁄realmr   Nzserver-login)zpasswordN)r   r
   r   ⁄existsZannouncer$   ⁄DEFAULT_REPOSITORYr%   ⁄DEFAULT_REALMr   ⁄read⁄sections⁄get⁄splitZ
has_option)r   r   r$   r%   Zconfigr*   Zindex_serversZ_serversr!   Zcurrent⁄key⁄defaultr   r   r   ⁄_read_pypirc0   sX    				zPyPIRCCommand._read_pypircc             C   sP   d d l  } | j d d É } | j | É d j d d É } | j É  j | É S)z%Read and decode a PyPI HTTP response.r   Nzcontent-typez
text/plainÈ   ⁄charset⁄ascii)⁄cgiZ	getheaderZparse_headerr+   r)   ⁄decode)r   Zresponser3   Zcontent_type⁄encodingr   r   r   ⁄_read_pypi_responseq   s    z!PyPIRCCommand._read_pypi_responsec             C   s   d |  _  d |  _ d |  _ d S)zInitialize options.Nr   )r$   r%   Zshow_response)r   r   r   r   ⁄initialize_optionsx   s    		z PyPIRCCommand.initialize_optionsc             C   s@   |  j  d k r |  j |  _  n  |  j d k r< |  j |  _ n  d S)zFinalizes options.N)r$   r'   r%   r(   )r   r   r   r   ⁄finalize_options~   s    zPyPIRCCommand.finalize_options)r   Nr   )⁄__name__⁄
__module__⁄__qualname__⁄__doc__r'   r(   r$   r%   Zuser_optionsZboolean_optionsr   r   r/   r6   r7   r8   r   r   r   r   r      s"    		Ar   )r<   r
   Zconfigparserr   Zdistutils.cmdr   r   r   r   r   r   r   ⁄<module>   s
   
                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/distutils/__pycache__/core.cpython-34.pyc                                         0100644 0000000 0000000 00000015710 13077704335 022217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TÕ"  „               @   sƒ   d  Z  d d l Z d d l Z d d l m Z d d l Td d l m Z d d l m	 Z	 d d l
 m Z d d l m Z d	 Z d
 d Ñ  Z d a d a d4 Z d5 Z d/ d0 Ñ  Z d d1 d2 d3 Ñ Z d S)6a#  distutils.core

The only module that needs to be imported to use the Distutils; provides
the 'setup' function (which is to be called from the setup script).  Also
indirectly provides the Distribution and Command classes, although they are
really defined in distutils.dist and distutils.cmd.
È    N)⁄DEBUG)⁄*)⁄Distribution)⁄Command)⁄PyPIRCCommand)⁄	Extensionz∞usage: %(script)s [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: %(script)s --help [cmd1 cmd2 ...]
   or: %(script)s --help-commands
   or: %(script)s cmd --help
c             C   s   t  j j |  É } t t É  S)N)⁄os⁄path⁄basename⁄USAGE⁄vars)⁄script_nameZscript© r   ˙$/usr/lib/python3.4/distutils/core.py⁄	gen_usage    s    r   ⁄	distclassr   ⁄script_args⁄options⁄name⁄version⁄author⁄author_email⁄
maintainer⁄maintainer_email⁄url⁄license⁄description⁄long_description⁄keywords⁄	platforms⁄classifiers⁄download_url⁄requires⁄provides⁄	obsoletes⁄sources⁄include_dirs⁄define_macros⁄undef_macros⁄library_dirs⁄	libraries⁄runtime_library_dirs⁄extra_objects⁄extra_compile_args⁄extra_link_args⁄	swig_opts⁄export_symbols⁄depends⁄languagec           ,   K   só  |  j  d É } | r |  d =n t } d |  k rQ t j j t j d É |  d <n  d |  k rw t j d d Ö |  d <n  y | |  É a } Wn^ t k
 rÎ } z> d |  k rø t	 d | É Ç n t	 d	 |  d | f É Ç WYd d } ~ Xn Xt
 d
 k r¸ | S| j É  t r#t d É | j É  n  t
 d k r3| Sy | j É  } WnB t k
 rá} z" t	 t | j É d | É Ç WYd d } ~ Xn Xt r•t d É | j É  n  t
 d k rµ| S| rìy | j É  Wqìt k
 rÈt	 d É Ç Yqìt k
 rC} z; t rt j j d | f É Ç  n t	 d | f É Ç WYd d } ~ Xqìt t f k
 rè} z' t rgÇ  n t	 d t | É É Ç WYd d } ~ XqìXn  | S)aÃ  The gateway to the Distutils: do everything your setup script needs
    to do, in a highly flexible and user-driven way.  Briefly: create a
    Distribution instance; find and parse config files; parse the command
    line; run each Distutils command found there, customized by the options
    supplied to 'setup()' (as keyword arguments), in config files, and on
    the command line.

    The Distribution instance might be an instance of a class supplied via
    the 'distclass' keyword argument to 'setup'; if no such class is
    supplied, then the Distribution class (in dist.py) is instantiated.
    All other arguments to 'setup' (except for 'cmdclass') are used to set
    attributes of the Distribution instance.

    The 'cmdclass' argument, if supplied, is a dictionary mapping command
    names to command classes.  Each command encountered on the command line
    will be turned into a command class, which is in turn instantiated; any
    class found in 'cmdclass' is used in place of the default, which is
    (for command 'foo_bar') class 'foo_bar' in module
    'distutils.command.foo_bar'.  The command class must provide a
    'user_options' attribute which is a list of option specifiers for
    'distutils.fancy_getopt'.  Any command-line options between the current
    and the next command are used to set attributes of the current command
    object.

    When the entire command-line has been successfully parsed, calls the
    'run()' method on each command object in turn.  This method will be
    driven entirely by the Distribution object (which each command object
    has a reference to, thanks to its constructor), and the
    command-specific options that became attributes of each command
    object.
    r   r   r   r   È   Nr   zerror in setup command: %szerror in %s setup command: %s⁄initz%options (after parsing config files):⁄configz

error: %sz%options (after parsing command line):⁄commandlineZinterruptedz
error: %s
z	error: %szerror: )⁄getr   r   r	   r
   ⁄sys⁄argv⁄_setup_distributionZDistutilsSetupError⁄
SystemExit⁄_setup_stop_afterZparse_config_filesr   ⁄printZdump_option_dictsZparse_command_lineZDistutilsArgErrorr   r   Zrun_commands⁄KeyboardInterrupt⁄OSError⁄stderr⁄writeZDistutilsErrorZCCompilerError⁄str)Zattrs⁄klassZdist⁄msg⁄ok⁄excr   r   r   ⁄setup9   s`    %
 '

0
%,rG   ⁄runc             C   s˛   | d k r" t  d | f É Ç n  | a t j } i |  d 6} i  } yx za |  t j d <| d k	 ry | t j d	 d Ö <n  t |  d
 É è } t | j É  | | É Wd QXWd | t _ d a XWn t k
 r– Yn Ç  Yn Xt d k r˙ t	 d |  É Ç n  t S)a.  Run a setup script in a somewhat controlled environment, and
    return the Distribution instance that drives things.  This is useful
    if you need to find out the distribution meta-data (passed as
    keyword args from 'script' to 'setup()', or the contents of the
    config files or command-line.

    'script_name' is a file that will be read and run with 'exec()';
    'sys.argv[0]' will be replaced with 'script' for the duration of the
    call.  'script_args' is a list of strings; if supplied,
    'sys.argv[1:]' will be replaced by 'script_args' for the duration of
    the call.

    'stop_after' tells 'setup()' when to stop processing; possible
    values:
      init
        stop after the Distribution instance has been created and
        populated with the keyword arguments to 'setup()'
      config
        stop after config files have been parsed (and their data
        stored in the Distribution instance)
      commandline
        stop after the command-line ('sys.argv[1:]' or 'script_args')
        have been parsed (and the data stored in the Distribution)
      run [default]
        stop after all commands have been run (the same as if 'setup()'
        had been called in the usual way

    Returns the Distribution instance, which provides all information
    used to drive the Distutils.
    r4   r5   r6   rH   z"invalid value for 'stop_after': %r⁄__file__r   Nr3   ⁄rbzZ'distutils.core.setup()' was never called -- perhaps '%s' is not a Distutils setup script?)zinitzconfigzcommandlinerH   )
⁄
ValueErrorr<   r8   r9   ⁄open⁄exec⁄readr;   r:   ⁄RuntimeError)r   r   Z
stop_afterZ	save_argv⁄g⁄l⁄fr   r   r   ⁄	run_setup™   s.    	 	rS   )z	distclasszscript_namezscript_argsr   ˙namezversionr   r   r   r   r   r   r   r   zkeywordsr   r    r!   r"   r#   r$   )rT   r%   r&   r'   r(   r)   r*   r+   r,   r-   r.   r/   r0   r1   r2   )⁄__doc__r   r8   Zdistutils.debugr   Zdistutils.errorsZdistutils.distr   Zdistutils.cmdr   Zdistutils.configr   Zdistutils.extensionr   r   r   r<   r:   Zsetup_keywordsZextension_keywordsrG   rS   r   r   r   r   ⁄<module>   s2   
         q                                                        usr/lib/python3.4/distutils/__pycache__/cygwinccompiler.cpython-34.pyc                              0100644 0000000 0000000 00000022006 13077704335 024461  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TW@  „               @   sg  d  Z  d d l Z d d l Z d d l Z d d l m Z m Z m Z d d l Z d d l	 m
 Z
 m Z d d l m Z d d l m Z d d l m Z m Z m Z m Z d d l m Z d d	 l m Z d d
 l m Z d d Ñ  Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z d Z d Z d Z  d d Ñ  Z! e j" d É Z# d d Ñ  Z$ d d Ñ  Z% d d Ñ  Z& d S)a  distutils.cygwinccompiler

Provides the CygwinCCompiler class, a subclass of UnixCCompiler that
handles the Cygwin port of the GNU C compiler to Windows.  It also contains
the Mingw32CCompiler class which handles the mingw32 port of GCC (same as
cygwin in no-cygwin mode).
È    N)⁄Popen⁄PIPE⁄check_output)⁄gen_preprocess_options⁄gen_lib_options)⁄UnixCCompiler)⁄
write_file)⁄DistutilsExecError⁄CCompilerError⁄CompileError⁄UnknownFileError)⁄log)⁄LooseVersion)⁄find_executablec              C   sØ   t  j j d É }  |  d k r´ t  j |  d |  d Ö } | d k rL d g S| d k r_ d g S| d	 k rr d
 g S| d k rÖ d g S| d k rò d g St d | É Ç n  d S)zaInclude the appropriate MSVC runtime library if Python was built
    with MSVC 7.0 or later.
    zMSC v.È   È   È
   Z1300Zmsvcr70Z1310Zmsvcr71Z1400Zmsvcr80Z1500Zmsvcr90Z1600Zmsvcr100zUnknown MS Compiler version %s NÈˇˇˇˇ)⁄sys⁄version⁄find⁄
ValueError)Zmsc_posZmsc_ver© r   ˙//usr/lib/python3.4/distutils/cygwinccompiler.py⁄	get_msvcr?   s    r   c               @   sù   e  Z d  Z d Z d Z d Z d Z d Z d Z d Z	 d Z
 d	 d	 d	 d
 d Ñ Z d d Ñ  Z d d d d d d	 d d d d d d Ñ
 Z d	 d d d Ñ Z d S)⁄CygwinCCompilerz? Handles the Cygwin port of the GNU C compiler to Windows.
    ⁄cygwinz.oz.az.dllzlib%s%sz%s%sz.exer   c             C   sS  t  j |  | | | É t É  \ } } |  j d | | f É | t k	 r\ |  j d | É n  t É  \ |  _ |  _ |  _	 |  j |  j
 d |  j |  j |  j	 f É |  j d k rº d |  _ n	 d |  _ |  j d k r› d } n d	 } |  j d
 d d d d d d d d d |  j | f É |  j d k rCd g |  _ |  j d É n t É  |  _ d  S)Nz%Python's GCC status: %s (details: %s)zÉPython's pyconfig.h doesn't seem to support your compiler. Reason: %s. Compiling may fail because of undefined preprocessor macros.z: gcc %s, ld %s, dllwrap %s
z2.10.90⁄gcc⁄dllwrapz2.13z-sharedz-mdll -static⁄compilerzgcc -mcygwin -O -Wall⁄compiler_sozgcc -mcygwin -mdll -O -Wall⁄compiler_cxxzg++ -mcygwin -O -Wall⁄
linker_exezgcc -mcygwin⁄	linker_soz%s -mcygwin %sz2.91.57Zmsvcrtz,Consider upgrading to a newer version of gcc)r   ⁄__init__⁄check_config_hZdebug_print⁄CONFIG_H_OK⁄warn⁄get_versions⁄gcc_version⁄
ld_versionZdllwrap_version⁄compiler_type⁄
linker_dll⁄set_executables⁄dll_librariesr   )⁄self⁄verbose⁄dry_run⁄forceZstatusZdetails⁄shared_optionr   r   r   r$   d   s<    			
zCygwinCCompiler.__init__c             C   s–   | d k s | d k ro y  |  j  d d | d | g É WqÃ t k
 rk } z t | É Ç WYd d } ~ XqÃ Xn] y) |  j  |  j | | d | g | É Wn1 t k
 rÀ } z t | É Ç WYd d } ~ Xn Xd S)z:Compiles the source by spawning GCC and windres if needed.z.rcz.resZwindresz-iz-oN)Zspawnr	   r   r    )r/   ⁄obj⁄src⁄extZcc_args⁄extra_postargsZpp_opts⁄msgr   r   r   ⁄_compileü   s     "zCygwinCCompiler._compileNc             C   s÷  t  j  |
 p g  É }
 t  j  | p$ g  É } t  j  | p9 g  É } | j |  j É | d k	 rà| |  j k sy |  j d k ràt j j | d É } t j j t j j	 | É É \ } } t j j
 | | d É } t j j
 | d | d É } d t j j	 | É d g } x | D] } | j | É qW|  j t | | f d	 | É |  j d
 k rx|
 j d | g É |
 j d | g É qà| j | É n  |	 sû|
 j d É n  t j |  | | | | | | | d |	 |
 | | | É d S)zLink the objects.Nr   r   z.defZlibz.az
LIBRARY %sZEXPORTSz
writing %sr   z--output-libz--defz-s)⁄copy⁄extendr.   Z
EXECUTABLEr,   ⁄os⁄path⁄dirname⁄splitext⁄basename⁄join⁄appendZexecuter   r   ⁄link)r/   Ztarget_descZobjectsZoutput_filename⁄
output_dirZ	librariesZlibrary_dirsZruntime_library_dirsZexport_symbols⁄debugZextra_preargsr7   Z
build_tempZtarget_langZtemp_dirZdll_nameZdll_extensionZdef_fileZlib_file⁄contentsZsymr   r   r   rC   Æ   s:    				zCygwinCCompiler.link⁄ c             C   s˙   | d k r d } n  g  } xÿ | D]– } t  j j t  j j | É É \ } } | |  j d d g k r~ t d | | f É Ç n  | rô t  j j | É } n  | d k rœ | j t  j j | | | |  j	 É É q" | j t  j j | | |  j	 É É q" W| S)z#Adds supports for rc and res files.NrG   ˙.rc˙.resz"unknown file type '%s' (from '%s'))rI   rH   )
r<   r=   r?   ⁄normcaseZsrc_extensionsr   r@   rB   rA   ⁄obj_extension)r/   Zsource_filenamesZ	strip_dirrD   Z	obj_namesZsrc_name⁄baser6   r   r   r   ⁄object_filenames¸   s     	$z CygwinCCompiler.object_filenames)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r+   rK   Zstatic_lib_extensionZshared_lib_extensionZstatic_lib_formatZshared_lib_formatZexe_extensionr$   r9   rC   rM   r   r   r   r   r   Y   s   ;		Kr   c               @   s1   e  Z d  Z d Z d Z d d d d d Ñ Z d S)⁄Mingw32CCompilerz@ Handles the Mingw32 port of the GNU C compiler to Windows.
    Zmingw32r   c             C   sª   t  j |  | | | É |  j d k r. d } n d } |  j d k rL d } n d } t É  rj t d É Ç n  |  j d d	 d
 d d d d d d d |  j | | f É g  |  _ t	 É  |  _ d  S)Nz2.13z-sharedz-mdll -staticz2.91.57z--entry _DllMain@12rG   z1Cygwin gcc cannot be used with --compiler=mingw32r   zgcc -O -Wallr    zgcc -mdll -O -Wallr!   zg++ -O -Wallr"   r   r#   z%s %s %s)
r   r$   r*   r)   ⁄is_cygwingccr
   r-   r,   r.   r   )r/   r0   r1   r2   r3   Zentry_pointr   r   r   r$     s&    					zMingw32CCompiler.__init__N)rN   rO   rP   rQ   r+   r$   r   r   r   r   rR     s   rR   ⁄okznot okZ	uncertainc              C   s»   d d l  m }  d t j k r) t d f S|  j É  } yP t | É } z2 d | j É  k rg t d | f St d | f SWd | j	 É  XWn< t
 k
 r√ } z t d	 | | j f f SWYd d } ~ Xn Xd S)
aw  Check if the current Python installation appears amenable to building
    extensions with GCC.

    Returns a tuple (status, details), where 'status' is one of the following
    constants:

    - CONFIG_H_OK: all is well, go ahead and compile
    - CONFIG_H_NOTOK: doesn't look good
    - CONFIG_H_UNCERTAIN: not sure -- unable to read pyconfig.h

    'details' is a human-readable string explaining the situation.

    Note there are two ways to conclude "OK": either 'sys.version' contains
    the string "GCC" (implying that this Python was built with GCC), or the
    installed "pyconfig.h" contains the string "__GNUC__".
    r   )⁄	sysconfigZGCCzsys.version mentions 'GCC'Z__GNUC__z'%s' mentions '__GNUC__'z '%s' does not mention '__GNUC__'Nzcouldn't read '%s': %s)⁄	distutilsrU   r   r   r&   Zget_config_h_filename⁄open⁄read⁄CONFIG_H_NOTOK⁄close⁄OSError⁄CONFIG_H_UNCERTAIN⁄strerror)rU   ⁄fnZconfig_h⁄excr   r   r   r%   H  s    
r%   s   (\d+\.\d+(\.\d+)*)c             C   só   |  j  É  d } t | É d k r& d St |  d d d t Éj } z | j É  } Wd | j É  Xt j | É } | d k r~ d St	 | j
 d É j É  É S)z§Find the version of an executable by running `cmd` in the shell.

    If the command is not found, or the output does not match
    `RE_VERSION`, returns None.
    r   N⁄shellT⁄stdoutr   )⁄splitr   r   r   ra   rX   rZ   ⁄
RE_VERSION⁄searchr   ⁄group⁄decode)⁄cmd⁄
executable⁄out⁄
out_string⁄resultr   r   r   ⁄_find_exe_versionu  s    rl   c              C   s&   d d d g }  t  d d Ñ  |  DÉ É S)zg Try to find out the versions of gcc, ld and dllwrap.

    If not possible it returns None for it.
    zgcc -dumpversionzld -vzdllwrap --versionc             S   s   g  |  ] } t  | É ë q Sr   )rl   )⁄.0rg   r   r   r   ˙
<listcomp>ê  s   	 z get_versions.<locals>.<listcomp>)⁄tuple)Zcommandsr   r   r   r(   ä  s    r(   c              C   s%   t  d d g É }  |  j É  j d É S)z>Try to determine if the gcc that would be used is from cygwin.r   z-dumpmachines   cygwin)r   ⁄strip⁄endswith)rj   r   r   r   rS   í  s    rS   )'rQ   r<   r   r:   ⁄
subprocessr   r   r   ⁄reZdistutils.ccompilerr   r   Zdistutils.unixccompilerr   Zdistutils.file_utilr   Zdistutils.errorsr	   r
   r   r   rV   r   Zdistutils.versionr   Zdistutils.spawnr   r   r   rR   r&   rY   r\   r%   ⁄compilerc   rl   r(   rS   r   r   r   r   ⁄<module>   s.   )"∫1+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/distutils/__pycache__/debug.cpython-34.pyc                                        0100644 0000000 0000000 00000000304 13077704335 022346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tã   „               @   s"   d  d l  Z  e  j j d É Z d S)È    NZDISTUTILS_DEBUG)⁄os⁄environ⁄get⁄DEBUG© r   r   ˙%/usr/lib/python3.4/distutils/debug.py⁄<module>   s                                                                                                                                                                                                                                                                                                                               usr/lib/python3.4/distutils/__pycache__/dep_util.cpython-34.pyc                                     0100644 0000000 0000000 00000005442 13077704335 023075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T£  „               @   sM   d  Z  d d l Z d d l m Z d d Ñ  Z d d Ñ  Z d d	 d
 Ñ Z d S)zØdistutils.dep_util

Utility functions for simple, timestamp-based dependency of files
and groups of files; also, function based entirely on such
timestamp dependency analysis.È    N)⁄DistutilsFileErrorc             C   sá   t  j j |  É s1 t d t  j j |  É É Ç n  t  j j | É sG d Sd d l m } t  j |  É | } t  j | É | } | | k S)a  Return true if 'source' exists and is more recently modified than
    'target', or if 'source' exists and 'target' doesn't.  Return false if
    both exist and 'target' is the same age or younger than 'source'.
    Raise DistutilsFileError if 'source' does not exist.
    zfile '%s' does not existÈ   r   )⁄ST_MTIME)⁄os⁄path⁄existsr   ⁄abspath⁄statr   )⁄source⁄targetr   Zmtime1Zmtime2© r   ˙(/usr/lib/python3.4/distutils/dep_util.py⁄newer   s    r   c             C   sñ   t  |  É t  | É k r' t d É Ç n  g  } g  } xV t t  |  É É D]B } t |  | | | É rF | j |  | É | j | | É qF qF W| | f S)zÎWalk two filename lists in parallel, testing if each source is newer
    than its corresponding target.  Return a pair of lists (sources,
    targets) where source is newer than target, according to the semantics
    of 'newer()'.
    z+'sources' and 'targets' must be same length)⁄len⁄
ValueError⁄ranger   ⁄append)⁄sourcesZtargetsZ	n_sourcesZ	n_targets⁄ir   r   r   ⁄newer_pairwise    s    r   ⁄errorc             C   sª   t  j j | É s d Sd d l m } t  j | É | } x{ |  D]o } t  j j | É så | d k rg qå | d k ry q@ qå | d k rå d Sn  t  j | É | } | | k r@ d Sq@ Wd Sd S)aﬂ  Return true if 'target' is out-of-date with respect to any file
    listed in 'sources'.  In other words, if 'target' exists and is newer
    than every file in 'sources', return false; otherwise return true.
    'missing' controls what we do when a source file is missing; the
    default ("error") is to blow up with an OSError from inside 'stat()';
    if it is "ignore", we silently drop any missing source files; if it is
    "newer", any missing source files make us assume that 'target' is
    out-of-date (this is handy in "dry-run" mode: it'll make you pretend to
    carry out commands that wouldn't work because inputs are missing, but
    that doesn't matter because you're not actually going to run the
    commands).
    r   r   )r   r   ⁄ignorer   N)r   r   r   r	   r   )r   r   Zmissingr   Ztarget_mtimer
   ⁄source_mtimer   r   r   ⁄newer_group6   s     r   )⁄__doc__r   Zdistutils.errorsr   r   r   r   r   r   r   r   ⁄<module>   s
                                                                                                                                                                                                                                 usr/lib/python3.4/distutils/__pycache__/dir_util.cpython-34.pyc                                     0100644 0000000 0000000 00000014650 13077704335 023104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T   „               @   s“   d  Z  d d l Z d d l Z d d l m Z m Z d d l m Z i  a d d d d d Ñ Z	 d d d d	 d
 Ñ Z
 d d l Z d Z d d d d d d d d Ñ Z d d Ñ  Z d d d d Ñ Z d d Ñ  Z d S)zWdistutils.dir_util

Utility functions for manipulating directories and directory trees.È    N)⁄DistutilsFileError⁄DistutilsInternalError)⁄logiˇ  È   c             C   s˝  t  |  t É s% t d |  f É Ç n  t j j |  É }  g  } t j j |  É s[ |  d k r_ | St j t j j	 |  É É r~ | St j j
 |  É \ } } | g } xK | rÏ | rÏ t j j | É rÏ t j j
 | É \ } } | j d | É q¢ Wx	| D]} t j j | | É } t j j	 | É }	 t j |	 É r6qÙ n  | d k rUt j d | É n  | sÎy t j | | É Wni t k
 r⁄}
 zI |
 j t j k o•t j j | É s»t d | |
 j d f É Ç n  WYd d }
 ~
 Xn X| j | É n  d t |	 <qÙ W| S)	aÏ  Create a directory and any missing ancestor directories.

    If the directory already exists (or if 'name' is the empty string, which
    means the current directory, which of course exists), then do nothing.
    Raise DistutilsFileError if unable to create some directory along the way
    (eg. some sub-path exists, but is a file rather than a directory).
    If 'verbose' is true, print a one-line summary of each mkdir to stdout.
    Return the list of directories actually created.
    z(mkpath: 'name' must be a string (got %r)⁄ r   r   zcreating %szcould not create '%s': %sNÈˇˇˇˇ)⁄
isinstance⁄strr   ⁄os⁄path⁄normpath⁄isdir⁄_path_created⁄get⁄abspath⁄split⁄insert⁄joinr   ⁄info⁄mkdir⁄OSError⁄errno⁄EEXISTr   ⁄args⁄append)⁄name⁄mode⁄verbose⁄dry_runZcreated_dirs⁄head⁄tailZtails⁄dZabs_head⁄exc© r#   ˙(/usr/lib/python3.4/distutils/dir_util.py⁄mkpath   s>    	"$0r%   c             C   sv   t  É  } x6 | D]. } | j t j j |  t j j | É É É q Wx- t | É D] } t | | d | d | ÉqO Wd S)aØ  Create all the empty directories under 'base_dir' needed to put 'files'
    there.

    'base_dir' is just the a name of a directory which doesn't necessarily
    exist yet; 'files' is a list of filenames to be interpreted relative to
    'base_dir'.  'base_dir' + the directory portion of every file in 'files'
    will be created if it doesn't already exist.  'mode', 'verbose' and
    'dry_run' flags are as for 'mkpath()'.
    r   r   N)⁄set⁄addr
   r   r   ⁄dirname⁄sortedr%   )Zbase_dirZfilesr   r   r   Zneed_dir⁄file⁄dirr#   r#   r$   ⁄create_treeP   s
    	,r,   c             C   sï  d d l  m } | r= t j j |  É r= t d |  É Ç n  y t j |  É }	 WnM t k
 rü }
 z- | rt g  }	 n t d |  |
 j f É Ç WYd d }
 ~
 Xn Xt	 j
 d É } d | d d Ö t | d d Ö f } | sÔ t | d	 | Én  g  } xô|	 D]ë} t j j |  | É } t j j | | É } t rî| j | É rî| j | É rît j j | | j | | É É } t j d
 | | j | | É É n  | j d É r©q¸ n  | rt j j | É rt j | É } | d k rÚt j d | | É n  | st j | | É n  | j | É q¸ t j j | É r^| j t | | | | | | d	 | d | ÉÉ q¸ | | | | | | d	 | d | É| j | É q¸ W| S)a  Copy an entire directory tree 'src' to a new location 'dst'.

    Both 'src' and 'dst' must be directory names.  If 'src' is not a
    directory, raise DistutilsFileError.  If 'dst' does not exist, it is
    created with 'mkpath()'.  The end result of the copy is that every
    file in 'src' is copied to 'dst', and directories under 'src' are
    recursively copied to 'dst'.  Return the list of files that were
    copied or might have been copied, using their output name.  The
    return value is unaffected by 'update' or 'dry_run': it is simply
    the list of all files under 'src', with the names changed to be
    under 'dst'.

    'preserve_mode' and 'preserve_times' are the same as for
    'copy_file'; note that they only apply to regular files, not to
    directories.  If 'preserve_symlinks' is true, symlinks will be
    copied as symlinks (on platforms that support them!); otherwise
    (the default), the destination of the symlink will be copied.
    'update' and 'verbose' are the same as for 'copy_file'.
    r   )⁄	copy_filez&cannot copy tree '%s': not a directoryzerror listing files in '%s': %sNZ
EXT_SUFFIXz%s-%s%sÈ   r   zrenaming extension %s -> %sz.nfsr   zlinking %s -> %sr   È˝ˇˇˇr/   )Zdistutils.file_utilr-   r
   r   r   r   ⁄listdirr   ⁄strerror⁄	sysconfigZget_config_var⁄
_multiarchr%   r   ⁄endswith⁄replacer   r   ⁄
startswith⁄islink⁄readlink⁄symlinkr   ⁄extend⁄	copy_tree)⁄srcZdstZpreserve_modeZpreserve_timesZpreserve_symlinks⁄updater   r   r-   ⁄names⁄eZ
ext_suffixZ
new_suffixZoutputs⁄nZsrc_nameZdst_nameZ	link_destr#   r#   r$   r;   f   sR    	)'%!"r;   c             C   sî   xw t  j |  É D]f } t  j j |  | É } t  j j | É r` t  j j | É r` t | | É q | j t  j | f É q W| j t  j	 |  f É d S)zHelper for remove_tree().N)
r
   r0   r   r   r   r7   ⁄_build_cmdtupler   ⁄remove⁄rmdir)r   ⁄	cmdtuples⁄fZreal_fr#   r#   r$   rA   ±   s    %rA   c             C   sŒ   | d k r t  j d |  É n  | r) d Sg  } t |  | É xã | D]É } yB | d | d É t j j | d É } | t k rä t | =n  WqC t k
 r≈ } z t  j d |  | É WYd d } ~ XqC XqC Wd S)zçRecursively remove an entire directory tree.

    Any errors are ignored (apart from being reported to stdout if 'verbose'
    is true).
    r   z'removing '%s' (and everything under it)Nr   zerror removing %s: %s)	r   r   rA   r
   r   r   r   r   ⁄warn)Z	directoryr   r   rD   ⁄cmdr   r"   r#   r#   r$   ⁄remove_treeª   s    rH   c             C   sL   t  j j |  É \ } }  |  d d Ö t  j k rH | |  d d Ö }  n  |  S)zÜTake the full path 'path', and make it a relative path.

    This is useful to make 'path' the second argument to os.path.join().
    r   r   N)r
   r   ⁄
splitdrive⁄sep)r   Zdriver#   r#   r$   ⁄ensure_relative”   s    rK   )⁄__doc__r
   r   Zdistutils.errorsr   r   Z	distutilsr   r   r%   r,   r2   r3   r;   rA   rH   rK   r#   r#   r#   r$   ⁄<module>   s   ?J
                                                                                        usr/lib/python3.4/distutils/__pycache__/dist.cpython-34.pyc                                         0100644 0000000 0000000 00000107744 13077704335 022243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tz¬  „               @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z y d d l Z Wn e k
 rd d Z Yn Xd d l Td d l	 m
 Z
 m Z d d l m Z m Z m Z d d l m Z d d l m Z e j d	 É Z Gd
 d Ñ  d É Z Gd d Ñ  d É Z d d Ñ  Z d S)z}distutils.dist

Provides the Distribution class, which represents the module distribution
being built/installed/distributed.
È    N)⁄message_from_file)⁄*)⁄FancyGetopt⁄translate_longopt)⁄check_environ⁄	strtobool⁄rfc822_escape)⁄log)⁄DEBUGz^[a-zA-Z]([a-zA-Z0-9_]*)$c               @   s%  e  Z d  Z d Z d~ d dÄ dÅ dÇ g Z d Z dÉ dÑ dÖ dÜ dá dà dâ dä dã då dç dé dè dê dë dí dì dî dï dñ dó g Z d> d? Ñ  e DÉ Z i d d 6Z d d@ dA Ñ Z	 dB dC Ñ  Z
 d d dD dE dF Ñ Z dG dH Ñ  Z d dI dJ Ñ Z dK dL Ñ  Z dM dN Ñ  Z dO dP Ñ  Z dQ dR Ñ  Z d d g  dS dT Ñ Z dU dV Ñ  Z dW dX Ñ  Z dY dZ Ñ  Z d[ d\ Ñ  Z d] d^ Ñ  Z d_ d` Ñ  Z d da db Ñ Z d dc dd Ñ Z de df dg Ñ Z e j dh di Ñ Z dj dk Ñ  Z dl dm Ñ  Z  dn do Ñ  Z! dp dq Ñ  Z" dr ds Ñ  Z# dt du Ñ  Z$ dv dw Ñ  Z% dx dy Ñ  Z& dz d{ Ñ  Z' d| d} Ñ  Z( d S)ò⁄DistributionaΩ  The core of the Distutils.  Most of the work hiding behind 'setup'
    is really done within a Distribution instance, which farms the work out
    to the Distutils commands specified on the command line.

    Setup scripts will almost never instantiate Distribution directly,
    unless the 'setup()' function is totally inadequate to their needs.
    However, it is conceivable that a setup script might wish to subclass
    Distribution for some specialized purpose, and then pass the subclass
    to 'setup()' as the 'distclass' keyword argument.  If so, it is
    necessary to respect the expectations that 'setup' has of Distribution.
    See the code for 'setup()', in core.py, for details.
    ⁄verbose⁄v˙run verbosely (default)È   ⁄quiet⁄q˙!run quietly (turns verbosity off)˙dry-run⁄n˙don't actually do anything⁄help⁄h˙show detailed help message˙no-user-cfgN˙-ignore pydistutils.cfg in your home directoryz£Common commands: (see '--help-commands' for more)

  setup.py build      will build the package underneath 'build/'
  setup.py install    will install the package
˙help-commands˙list all available commands⁄name˙print package name⁄version⁄V˙print package version⁄fullname˙print <package name>-<version>⁄author˙print the author's name˙author-email˙ print the author's email address⁄
maintainer˙print the maintainer's name˙maintainer-email˙$print the maintainer's email address⁄contact˙7print the maintainer's name if known, else the author's˙contact-email˙@print the maintainer's email address if known, else the author's⁄url˙print the URL for this package⁄license˙ print the license of the package⁄licence˙alias for --license⁄description˙print the package description˙long-description˙"print the long package description⁄	platforms˙print the list of platforms⁄classifiers˙print the list of classifiers⁄keywords˙print the list of keywords⁄provides˙+print the list of packages/modules provided⁄requires˙+print the list of packages/modules required⁄	obsoletes˙0print the list of packages/modules made obsoletec             C   s    g  |  ] } t  | d  É ë q S)r   )r   )⁄.0⁄x© rH   ˙$/usr/lib/python3.4/distutils/dist.py˙
<listcomp>q   s   	 zDistribution.<listcomp>c             C   si  d |  _  d |  _ d |  _ x! |  j D] } t |  | d É q% Wt É  |  _ x: |  j j D], } d | } t |  | t |  j | É É qX Wi  |  _	 d |  _
 d |  _ d |  _ i  |  _ g  |  _ d |  _ i  |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ i  |  _ i  |  _ | r | j d É } | d k	 r…| d =xY | j É  D]H \ } } |  j  | É } x* | j É  D] \ }	 }
 d |
 f | |	 <q¢WqzWn  d | k r#| d | d	 <| d =d
 } t! d k	 rt! j" | É q#t# j$ j% | d É n  x⁄ | j É  D]… \ } }
 t& |  j d | É rot |  j d | É |
 É q0t& |  j | É rót |  j | |
 É q0t& |  | É rπt |  | |
 É q0d t' | É } t! d k	 rÂt! j" | É q0t# j$ j% | d É q0Wn  d |  _( |  j d k	 r[x@ |  j D]2 } | j) d É s;Pn  | d k r"d |  _( Pq"q"Wn  |  j* É  d S)a0  Construct a new Distribution instance: initialize all the
        attributes of a Distribution, and then use 'attrs' (a dictionary
        mapping attribute names to values) to assign some of those
        attributes their "real" values.  (Any attributes not mentioned in
        'attrs' will be assigned to some null value: 0, None, an empty list
        or dictionary, etc.)  Most importantly, initialize the
        'command_obj' attribute to the empty dictionary; this will be
        filled in with real command objects by 'parse_command_line()'.
        r   r   ⁄get_N⁄ ⁄optionszsetup scriptr4   r2   z:'licence' distribution option is deprecated; use 'license'⁄
Zset_zUnknown distribution option: %sT˙-z--no-user-cfgF)+r   ⁄dry_runr   ⁄display_option_names⁄setattr⁄DistributionMetadata⁄metadata⁄_METHOD_BASENAMES⁄getattr⁄cmdclass⁄command_packages⁄script_name⁄script_args⁄command_optionsZ
dist_files⁄packagesZpackage_dataZpackage_dir⁄
py_modules⁄	libraries⁄headers⁄ext_modulesZext_packageZinclude_dirsZ
extra_path⁄scripts⁄
data_filesZpassword⁄command_obj⁄have_run⁄get⁄items⁄get_option_dict⁄warnings⁄warn⁄sys⁄stderr⁄write⁄hasattr⁄repr⁄want_user_cfg⁄
startswith⁄finalize_options)⁄selfZattrs⁄attr⁄basenameZmethod_namerM   ⁄commandZcmd_options⁄opt_dict⁄opt⁄val⁄msg⁄key⁄argrH   rH   rI   ⁄__init__y   sÇ    			
 																							zDistribution.__init__c             C   s6   |  j  j | É } | d k r2 i  } |  j  | <n  | S)zÌGet the option dictionary for a given command.  If that
        command's option dictionary hasn't been created yet, then create it
        and return the new dictionary; otherwise, return the existing
        option dictionary.
        N)r[   re   )rr   ru   ⁄dictrH   rH   rI   rg     s    zDistribution.get_option_dictrL   c       	      C   s  d d l  m } | d  k r4 t |  j j É  É } n  | d  k	 r^ |  j | | É | d } n  | sy |  j | d É d  Sxî | D]å } |  j j | É } | d  k rº |  j | d | É qÄ |  j | d | É | | É } x, | j d É D] } |  j | d | É qÌ WqÄ Wd  S)Nr   )⁄pformatz  zno commands known yetzno option dict for '%s' commandzoption dict for '%s' command:rN   )Zpprintr~   ⁄sortedr[   ⁄keys⁄announcere   ⁄split)	rr   ⁄header⁄commands⁄indentr~   Zcmd_namerv   ⁄out⁄linerH   rH   rI   ⁄dump_option_dicts%  s&    		zDistribution.dump_option_dictsc             C   s  g  } t  É  t j j t j d j É } t j j | d É } t j j | É r` | j	 | É n  t j
 d k rx d } n d } |  j rÕ t j j t j j d É | É } t j j | É rÕ | j	 | É qÕ n  d } t j j | É rı | j	 | É n  t r|  j d d	 j | É É n  | S)
aæ  Find as many configuration files as should be processed for this
        platform, and return a list of filenames in the order in which they
        should be parsed.  The filenames returned are guaranteed to exist
        (modulo nasty race conditions).

        There are three possible config files: distutils.cfg in the
        Distutils installation directory (ie. where the top-level
        Distutils __inst__.py file lives), a file in the user's home
        directory named .pydistutils.cfg on Unix and pydistutils.cfg
        on Windows/Mac; and setup.cfg in the current directory.

        The file in the user's home directory can be disabled with the
        --no-user-cfg option.
        ⁄	distutilszdistutils.cfg⁄posixz.pydistutils.cfgzpydistutils.cfg˙~z	setup.cfgzusing config files: %sz, )r   ⁄os⁄path⁄dirnamerj   ⁄modules⁄__file__⁄join⁄isfile⁄appendr   ro   ⁄
expanduserr
   rÅ   )rr   ZfilesZsys_dirZsys_fileZuser_filenameZ	user_fileZ
local_filerH   rH   rI   ⁄find_config_filesA  s&    		!zDistribution.find_config_filesc             C   sT  d d l  m } t j t j k rR d d d d d d d	 d
 d d d d d g } n g  } t | É } | d  k r |  j É  } n  t rï |  j d É n  | É  } x‘ | D]Ã } t r≈ |  j d | É n  | j	 | É xí | j
 É  D]Ñ } | j | É } |  j | É } x] | D]U }	 |	 d k r
|	 | k r
| j | |	 É }
 |	 j d d É }	 | |
 f | |	 <q
q
Wqﬂ W| j É  q• Wd |  j k rPx… |  j d j É  D]± \ }	 \ } }
 |  j j |	 É } yY | rﬂt |  | t |
 É É n5 |	 d k rt |  |	 t |
 É É n t |  |	 |
 É Wqòt k
 rH} z t | É Ç WYd  d  } ~ XqòXqòWn  d  S)Nr   )⁄ConfigParserzinstall-basezinstall-platbasezinstall-libzinstall-platlibzinstall-purelibzinstall-headerszinstall-scriptszinstall-data⁄prefixzexec-prefixZhome⁄user⁄rootz"Distribution.parse_config_files():z  reading %s⁄__name__rO   ⁄_⁄globalr   rP   )zverbosezdry_run)Zconfigparserrñ   rj   ró   ⁄base_prefix⁄	frozensetrï   r
   rÅ   ⁄readZsectionsrM   rg   re   ⁄replacer|   r[   rf   ⁄negative_optrR   r   ⁄
ValueError⁄DistutilsOptionError)rr   ⁄	filenamesrñ   Zignore_options⁄parser⁄filenameZsectionrM   rv   rw   rx   ⁄src⁄aliasry   rH   rH   rI   ⁄parse_config_filesq  sJ    			&zDistribution.parse_config_filesc             C   s  |  j  É  } g  |  _ t | |  j É } | j |  j É | j i d d 6É | j d |  j d |  É } | j	 É  } t
 j |  j É |  j | É rñ d Sx, | rƒ |  j | | É } | d k rô d Sqô W|  j r˝ |  j | d t |  j É d k d |  j Éd S|  j st d	 É Ç n  d
 S)aá  Parse the setup script's command line, taken from the
        'script_args' instance attribute (which defaults to 'sys.argv[1:]'
        -- see 'setup()' in core.py).  This list is first processed for
        "global options" -- options that set attributes of the Distribution
        instance.  Then, it is alternately scanned for Distutils commands
        and options for that command.  Each new command terminates the
        options for the previous command.  The allowed options for a
        command are determined by the 'user_options' attribute of the
        command class -- thus, we have to be able to load command classes
        in order to parse the command line.  Any error in that 'options'
        attribute raises DistutilsGetoptError; any error on the
        command-line raises DistutilsArgError.  If no Distutils commands
        were found on the command line, raises DistutilsArgError.  Return
        true if command-line was successfully parsed and we should carry
        on with executing commands; false if no errors but we shouldn't
        execute commands (currently, this only happens if user asks for
        help).
        r2   r4   ⁄args⁄objectN⁄display_optionsr   rÑ   zno commands suppliedT)⁄_get_toplevel_optionsrÑ   r   r¨   ⁄set_negative_aliasesr°   Zset_aliases⁄getoptrZ   Zget_option_orderr	   Zset_verbosityr   ⁄handle_display_options⁄_parse_command_optsr   ⁄
_show_help⁄len⁄DistutilsArgError)rr   Ztoplevel_optionsr•   r™   ⁄option_orderrH   rH   rI   ⁄parse_command_line´  s,    				
	zDistribution.parse_command_linec             C   s   |  j  d g S)z√Return the non-display options recognized at the top level.

        This includes options that are recognized *only* at the top
        level as well as options recognized for commands.
        ˙command-packages=N˙0list of packages that provide distutils commands)r∑   Nr∏   )⁄global_options)rr   rH   rH   rI   r≠   Ó  s     z"Distribution._get_toplevel_optionsc             C   s√  d d l  m } | d } t j | É s< t d | É Ç n  |  j j | É y |  j | É } Wn1 t k
 rí } z t	 | É Ç WYd d } ~ Xn Xt
 | | É sµ t d | É Ç n  t | d É o” t | j t É sÌ t d d | É Ç n  |  j } t | d	 É r$| j É  } | j | j É n  t | d
 É rWt | j t É rWt | j É } n g  } | j |  j | j | É | j | É | j | d d Ö É \ } }	 t |	 d É r‹|	 j r‹|  j | d d d | g Éd St | d
 É r}t | j t É r}d }
 xj | j D]_ \ } } } } t |	 | j | É É rd }
 t | É rS| É  qlt d | | f É Ç qqW|
 r}d Sn  |  j | É } x0 t |	 É j É  D] \ } } d | f | | <qüW| S)a⁄  Parse the command-line options for a single command.
        'parser' must be a FancyGetopt instance; 'args' must be the list
        of arguments, starting with the current command (whose options
        we are about to parse).  Returns a new version of 'args' with
        the next command at the front of the list; will be the empty
        list if there are no more commands on the command line.  Returns
        None if the user asked for help on this command.
        r   )⁄Commandzinvalid command name '%s'Nz&command class %s must subclass Command⁄user_optionszcommand class %s must provide z+'user_options' attribute (a list of tuples)r°   ⁄help_optionsr   r   r¨   rÑ   zYinvalid help function %r for help option '%s': must be a callable object (function, etc.)zcommand line) ⁄distutils.cmdr∫   ⁄
command_re⁄match⁄
SystemExitrÑ   rì   ⁄get_command_class⁄DistutilsModuleErrorr¥   ⁄
issubclassZDistutilsClassErrorrm   ⁄
isinstancerª   ⁄listr°   ⁄copy⁄updaterº   ⁄fix_help_options⁄set_option_tablerπ   rÆ   rØ   r   r≤   Zget_attr_name⁄callablerg   ⁄varsrf   )rr   r•   r™   r∫   ru   Z	cmd_classry   r°   rº   ZoptsZhelp_option_foundZhelp_optionZshortZdesc⁄funcrv   r   ⁄valuerH   rH   rI   r±   ˘  sd    

	
z Distribution._parse_command_optsc             C   sz   xs d D]k } t  |  j | É } | d k r1 q n  t | t É r d d Ñ  | j d É DÉ } t |  j | | É q q Wd S)zõSet final values for all the options on the Distribution
        instance, analogous to the .finalize_options() method of Command
        objects.
        r>   r:   Nc             S   s   g  |  ] } | j  É  ë q SrH   )⁄strip)rF   ZelmrH   rH   rI   rJ   _  s   	 z1Distribution.finalize_options.<locals>.<listcomp>˙,)zkeywordsz	platforms)rV   rT   rƒ   ⁄strrÇ   rR   )rr   rs   rÕ   rH   rH   rI   rq   U  s    zDistribution.finalize_optionsc       
      C   sv  d d l  m } d d l m } | rr | r; |  j É  } n	 |  j } | j | É | j |  j d É t	 d É n  | r¶ | j |  j
 É | j d d É t	 d É n  x∂ |  j D]´ } t | t É r› t | | É r› | }	 n |  j | É }	 t |	 d É r-t |	 j t É r-| j |	 j t |	 j É É n | j |	 j É | j d	 |	 j É t	 d É q∞ Wt	 | |  j É É d
 S)ab  Show help for the setup script command-line in the form of
        several lists of command-line options.  'parser' should be a
        FancyGetopt instance; do not expect it to be returned in the
        same state, as its option table will be reset to make it
        generate the correct help text.

        If 'global_options' is true, lists the global options:
        --verbose, --dry-run, etc.  If 'display_options' is true, lists
        the "display-only" options: --name, --version, etc.  Finally,
        lists per-command help for every command name or command class
        in 'commands'.
        r   )⁄	gen_usage)r∫   z
Global options:rL   z*Information display options (just display z!information, ignore any commands)rº   zOptions for '%s' command:N)⁄distutils.corer—   rΩ   r∫   r≠   rπ   r…   Z
print_help⁄common_usage⁄printr¨   rÑ   rƒ   ⁄typer√   r¡   rm   rº   r≈   rª   r»   rö   rY   )
rr   r•   rπ   r¨   rÑ   r—   r∫   rM   ru   ⁄klassrH   rH   rI   r≤   b  s6    		zDistribution._show_helpc       	      C   s  d d l  m } |  j rD |  j É  t d É t | |  j É É d Sd } i  } x |  j D] } d | | d <qZ Wx• | D]ù \ } } | ry | j | É ry t | É } t	 |  j
 d | É É  } | d k r· t d j | É É n, | d k rt d j | É É n
 t | É d } qy qy W| S)z⁄If there were any non-global "display-only" options
        (--help-commands or the metadata display options) on the command
        line, display the requested info and return true; else return
        false.
        r   )r—   rL   r   rK   r>   r:   rœ   r<   r@   rB   rD   rN   )zkeywordsz	platforms)zclassifierszprovideszrequiresz	obsoletes)r“   r—   Zhelp_commands⁄print_commandsr‘   rY   r¨   re   r   rV   rT   rë   )	rr   rµ   r—   Zany_display_optionsZis_display_option⁄optionrw   rx   rÕ   rH   rH   rI   r∞   î  s,    	

	
z#Distribution.handle_display_optionsc             C   så   t  | d É xw | D]o } |  j j | É } | sE |  j | É } n  y | j } Wn t k
 rl d } Yn Xt  d | | | f É q Wd S)zZPrint a subset of the list of all commands -- used by
        'print_commands()'.
        ˙:z(no description available)z
  %-*s  %sN)r‘   rW   re   r¡   r6   ⁄AttributeError)rr   rÑ   rÉ   ⁄
max_length⁄cmdr÷   r6   rH   rH   rI   ⁄print_command_listº  s    zDistribution.print_command_listc             C   sÓ   d d l  } | j j } i  } x | D] } d | | <q% Wg  } x6 |  j j É  D]% } | j | É sO | j | É qO qO Wd } x3 | | D]' } t | É | k râ t | É } qâ qâ W|  j | d | É | rÍ t	 É  |  j | d | É n  d S)an  Print out a help message listing all available commands with a
        description of each.  The list is divided into "standard commands"
        (listed in distutils.command.__all__) and "extra commands"
        (mentioned in self.cmdclass, but not a standard command).  The
        descriptions come from the command class attribute
        'description'.
        r   Nr   zStandard commandszExtra commands)
⁄distutils.commandru   ⁄__all__rW   rÄ   re   rì   r≥   r›   r‘   )rr   râ   ⁄std_commands⁄is_stdr‹   ⁄extra_commandsr€   rH   rH   rI   r◊   Õ  s*    		zDistribution.print_commandsc       	      C   s¸   d d l  } | j j } i  } x | D] } d | | <q% Wg  } x6 |  j j É  D]% } | j | É sO | j | É qO qO Wg  } xw | | D]k } |  j j | É } | sπ |  j | É } n  y | j } Wn t	 k
 r‡ d } Yn X| j | | f É qâ W| S)a>  Get a list of (command, description) tuples.
        The list is divided into "standard commands" (listed in
        distutils.command.__all__) and "extra commands" (mentioned in
        self.cmdclass, but not a standard command).  The descriptions come
        from the command class attribute 'description'.
        r   Nr   z(no description available))
rﬁ   ru   rﬂ   rW   rÄ   re   rì   r¡   r6   r⁄   )	rr   râ   r‡   r·   r‹   r‚   ⁄rvr÷   r6   rH   rH   rI   ⁄get_command_listÓ  s(    	zDistribution.get_command_listc             C   sx   |  j  } t | t É st | d k r- d } n  d d Ñ  | j d É DÉ } d | k rh | j d d É n  | |  _  n  | S)z9Return a list of packages from which commands are loaded.NrL   c             S   s(   g  |  ] } | d  k r | j  É  ë q S)rL   )rŒ   )rF   ZpkgrH   rH   rI   rJ     s   	 z5Distribution.get_command_packages.<locals>.<listcomp>rœ   zdistutils.commandr   )rX   rƒ   r≈   rÇ   ⁄insert)rr   ZpkgsrH   rH   rI   ⁄get_command_packages  s    		z!Distribution.get_command_packagesc             C   sﬂ   |  j  j | É } | r | Sx¨ |  j É  D]û } d | | f } | } y t | É t j | } Wn t k
 rw w) Yn Xy t | | É } Wn+ t k
 r∏ t	 d | | | f É Ç Yn X| |  j  | <| SWt	 d | É Ç d S)ao  Return the class that implements the Distutils command named by
        'command'.  First we check the 'cmdclass' dictionary; if the
        command is mentioned there, we fetch the class object from the
        dictionary and return it.  Otherwise we load the command module
        ("distutils.command." + command) and fetch the command class from
        the module.  The loaded class is also stored in 'cmdclass'
        to speed future calls to 'get_command_class()'.

        Raises DistutilsModuleError if the expected module could not be
        found, or if that module does not define the expected class.
        z%s.%sz3invalid command '%s' (no class '%s' in module '%s')zinvalid command '%s'N)
rW   re   rÊ   ⁄
__import__rj   rè   ⁄ImportErrorrV   r⁄   r¬   )rr   ru   r÷   ZpkgnameZmodule_nameZ
klass_name⁄modulerH   rH   rI   r¡     s(    
zDistribution.get_command_classc             C   sû   |  j  j | É } | rö | rö t r9 |  j d | É n  |  j | É } | |  É } |  j  | <d |  j | <|  j j | É } | rö |  j | | É qö n  | S)a  Return the command object for 'command'.  Normally this object
        is cached on a previous call to 'get_command_obj()'; if no command
        object for 'command' is in the cache, then we either create and
        return it (if 'create' is true) or return None.
        z<Distribution.get_command_obj(): creating '%s' command objectr   )rc   re   r
   rÅ   r¡   rd   r[   ⁄_set_command_options)rr   ru   ⁄create⁄cmd_objr÷   rM   rH   rH   rI   ⁄get_command_objB  s    	zDistribution.get_command_objc          !   C   s»  | j  É  } | d k r* |  j | É } n  t rD |  j d | É n  x}| j É  D]o\ } \ } } t rÜ |  j d | | | f É n  y d d Ñ  | j DÉ } Wn t k
 r∫ g  } Yn Xy | j } Wn t k
 r‚ i  } Yn Xy© t | t	 É }	 | | k r%|	 r%t
 | | | t | É É nf | | k rP|	 rPt
 | | t | É É n; t | | É rrt
 | | | É n t d | | | f É Ç WqQ t k
 rø}
 z t |
 É Ç WYd d }
 ~
 XqQ XqQ Wd S)ay  Set the options for 'command_obj' from 'option_dict'.  Basically
        this means copying elements of a dictionary ('option_dict') to
        attributes of an instance ('command').

        'command_obj' must be a Command instance.  If 'option_dict' is not
        supplied, uses the standard option dictionary for this command
        (from 'self.command_options').
        Nz#  setting options for '%s' command:z    %s = %s (from %s)c             S   s   g  |  ] } t  | É ë q SrH   )r   )rF   ⁄orH   rH   rI   rJ   q  s   	z5Distribution._set_command_options.<locals>.<listcomp>z1error in %s: command '%s' has no such option '%s')⁄get_command_namerg   r
   rÅ   rf   Zboolean_optionsr⁄   r°   rƒ   r–   rR   r   rm   r£   r¢   )rr   rc   Zoption_dict⁄command_namerÿ   ⁄sourcerÕ   Z	bool_optsZneg_optZ	is_stringry   rH   rH   rI   rÍ   ]  s>    		z!Distribution._set_command_optionsr   c             C   s±   d d l  m } t | | É s7 | } |  j | É } n | j É  } | j sP | S| j É  d | _ d |  j | <|  j | É | r≠ x' | j	 É  D] } |  j
 | | É qê Wn  | S)a≥  Reinitializes a command to the state it was in when first
        returned by 'get_command_obj()': ie., initialized but not yet
        finalized.  This provides the opportunity to sneak option
        values in programmatically, overriding or supplementing
        user-supplied values from the config files and command line.
        You'll have to re-finalize the command object (by calling
        'finalize_options()' or 'ensure_finalized()') before using it for
        real.

        'command' should be a command name (string) or command object.  If
        'reinit_subcommands' is true, also reinitializes the command's
        sub-commands, as declared by the 'sub_commands' class attribute (if
        it has one).  See the "install" command for an example.  Only
        reinitializes the sub-commands that actually matter, ie. those
        whose test predicates return true.

        Returns the reinitialized command object.
        r   )r∫   )rΩ   r∫   rƒ   rÌ   rÔ   Z	finalizedZinitialize_optionsrd   rÍ   Zget_sub_commands⁄reinitialize_command)rr   ru   Zreinit_subcommandsr∫   r   ⁄subrH   rH   rI   rÚ   â  s    	
	z!Distribution.reinitialize_commandc             C   s   t  j  | | É d  S)N)r	   )rr   ry   ⁄levelrH   rH   rI   rÅ   ≤  s    zDistribution.announcec             C   s%   x |  j  D] } |  j | É q
 Wd S)z∂Run each command that was seen on the setup script command line.
        Uses the list of commands found and cache of command objects
        created by 'get_command_obj()'.
        N)rÑ   ⁄run_command)rr   r‹   rH   rH   rI   ⁄run_commandsµ  s    zDistribution.run_commandsc             C   sZ   |  j  j | É r d St j d | É |  j | É } | j É  | j É  d |  j  | <d S)a™  Do whatever it takes to run a command (including nothing at all,
        if the command has already been run).  Specifically: if we have
        already created and run the command named by 'command', return
        silently without doing anything.  If the command named by 'command'
        doesn't even have a command object yet, create one.  Then invoke
        'run()' on that command object (or an existing one).
        Nz
running %sr   )rd   re   r	   ⁄inforÌ   Zensure_finalizedZrun)rr   ru   rÏ   rH   rH   rI   rı   ø  s    	

zDistribution.run_commandc             C   s"   t  |  j p |  j p g  É d k S)Nr   )r≥   r\   r]   )rr   rH   rH   rI   ⁄has_pure_modules‘  s    zDistribution.has_pure_modulesc             C   s   |  j  o t |  j  É d k S)Nr   )r`   r≥   )rr   rH   rH   rI   ⁄has_ext_modules◊  s    zDistribution.has_ext_modulesc             C   s   |  j  o t |  j  É d k S)Nr   )r^   r≥   )rr   rH   rH   rI   ⁄has_c_libraries⁄  s    zDistribution.has_c_librariesc             C   s   |  j  É  p |  j É  S)N)r¯   r˘   )rr   rH   rH   rI   ⁄has_modules›  s    zDistribution.has_modulesc             C   s   |  j  o t |  j  É d k S)Nr   )r_   r≥   )rr   rH   rH   rI   ⁄has_headers‡  s    zDistribution.has_headersc             C   s   |  j  o t |  j  É d k S)Nr   )ra   r≥   )rr   rH   rH   rI   ⁄has_scripts„  s    zDistribution.has_scriptsc             C   s   |  j  o t |  j  É d k S)Nr   )rb   r≥   )rr   rH   rH   rI   ⁄has_data_filesÊ  s    zDistribution.has_data_filesc             C   s$   |  j  É  o# |  j É  o# |  j É  S)N)r¯   r˘   r˙   )rr   rH   rH   rI   ⁄is_pureÈ  s    zDistribution.is_pure)zverboser   r   r   )zquietr   r   )r   r   r   )zhelpr   r   )r   Nr   )r   Nr   )znameNr   )zversionr    r!   )zfullnameNr#   )zauthorNr%   )r&   Nr'   )z
maintainerNr)   )r*   Nr+   )r,   Nr-   )r.   Nr/   )zurlNr1   )zlicenseNr3   )zlicenceNr5   )zdescriptionNr7   )r8   Nr9   )z	platformsNr;   )zclassifiersNr=   )zkeywordsNr?   )zprovidesNrA   )zrequiresNrC   )z	obsoletesNrE   ))rö   ⁄
__module__⁄__qualname__⁄__doc__rπ   r”   r¨   rQ   r°   r|   rg   rà   rï   r©   r∂   r≠   r±   rq   r≤   r∞   r›   r◊   r‰   rÊ   r¡   rÌ   rÍ   rÚ   r	   ⁄INFOrÅ   rˆ   rı   r¯   r˘   r˙   r˚   r¸   r˝   r˛   rˇ   rH   rH   rH   rI   r      s¶    	
                     	°0:C\1(!"&,)
r   c               @   su  e  Z d  Z d Z dO Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d  Ñ  Z	 d! d" Ñ  Z
 d# d$ Ñ  Z d% d& Ñ  Z d' d( Ñ  Z d) d* Ñ  Z d+ d, Ñ  Z d- d. Ñ  Z d/ d0 Ñ  Z d1 d2 Ñ  Z d3 d4 Ñ  Z d5 d6 Ñ  Z e Z d7 d8 Ñ  Z d9 d: Ñ  Z d; d< Ñ  Z d= d> Ñ  Z d? d@ Ñ  Z dA dB Ñ  Z dC dD Ñ  Z dE dF Ñ  Z dG dH Ñ  Z dI dJ Ñ  Z dK dL Ñ  Z  dM dN Ñ  Z! d S)PrS   z]Dummy class to hold the distribution meta-data: name, version,
    author, and so forth.
    r   r   r$   ⁄author_emailr(   ⁄maintainer_emailr0   r2   r6   ⁄long_descriptionr>   r:   r"   r,   ⁄contact_emailr<   ⁄download_urlr@   rB   rD   Nc             C   sø   | d  k	 r" |  j  t | É É nô d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S)N)⁄read_pkg_file⁄openr   r   r$   r  r(   r  r0   r2   r6   r  r>   r:   r<   r  r@   rB   rD   )rr   rç   rH   rH   rI   r|     s&    																zDistributionMetadata.__init__c                sö  t  | É â  á  f d d Ü  } á  f d d Ü  } à  d } | d É |  _ | d É |  _ | d É |  _ | d	 É |  _ d
 |  _ | d É |  _ d
 |  _ | d É |  _ | d É |  _	 d à  k r” | d É |  _
 n	 d
 |  _
 | d É |  _ | d É |  _ d à  k r!| d É j d É |  _ n  | d É |  _ | d É |  _ | d k r{| d É |  _ | d É |  _ | d É |  _ n d
 |  _ d
 |  _ d
 |  _ d
 S)z-Reads the metadata values from a file object.c                s   à  |  } | d k r d  S| S)N⁄UNKNOWNrH   )r   rÕ   )ry   rH   rI   ⁄_read_field  s    
z7DistributionMetadata.read_pkg_file.<locals>._read_fieldc                s&   à  j  |  d  É } | g  k r" d  S| S)N)Zget_all)r   ⁄values)ry   rH   rI   ⁄
_read_list%  s    z6DistributionMetadata.read_pkg_file.<locals>._read_listzmetadata-versionr   r   Zsummaryr$   Nzauthor-emailz	home-pager2   zdownload-urlr6   r>   rœ   ⁄platformZ
classifierz1.1rB   r@   rD   )r   r   r   r6   r$   r(   r  r  r0   r2   r  r  rÇ   r>   r:   r<   rB   r@   rD   )rr   ⁄filer  r  Zmetadata_versionrH   )ry   rI   r	    s:    
					z"DistributionMetadata.read_pkg_filec          	   C   s>   t  t j j | d É d d d Éè } |  j | É Wd QXd S)z7Write the PKG-INFO file into the release tree.
        zPKG-INFO⁄w⁄encodingzUTF-8N)r
  rå   rç   rë   ⁄write_pkg_file)rr   Zbase_dirZpkg_inforH   rH   rI   ⁄write_pkg_infoO  s    z#DistributionMetadata.write_pkg_infoc             C   s·  d } |  j  s3 |  j s3 |  j s3 |  j s3 |  j r< d } n  | j d | É | j d |  j É  É | j d |  j É  É | j d |  j É  É | j d |  j	 É  É | j d |  j
 É  É | j d	 |  j É  É | j d
 |  j É  É |  j r| j d |  j É n  t |  j É  É } | j d | É d j |  j É  É } | r`| j d | É n  |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É |  j | d |  j É  É d S)z9Write the PKG-INFO format data to a file object.
        z1.0z1.1zMetadata-Version: %s
z	Name: %s
zVersion: %s
zSummary: %s
zHome-page: %s
zAuthor: %s
zAuthor-email: %s
zLicense: %s
zDownload-URL: %s
zDescription: %s
rœ   zKeywords: %s
ZPlatformZ
ClassifierZRequiresZProvidesZ	ObsoletesN)r@   rB   rD   r<   r  rl   ⁄get_name⁄get_version⁄get_description⁄get_url⁄get_contact⁄get_contact_email⁄get_licenser   ⁄get_long_descriptionrë   ⁄get_keywords⁄_write_list⁄get_platforms⁄get_classifiers⁄get_requires⁄get_provides⁄get_obsoletes)rr   r  r   Z	long_descr>   rH   rH   rI   r  V  s0    		z#DistributionMetadata.write_pkg_filec             C   s,   x% | D] } | j  d | | f É q Wd  S)Nz%s: %s
)rl   )rr   r  r   r  rÕ   rH   rH   rI   r  x  s    z DistributionMetadata._write_listc             C   s   |  j  p d S)Nr  )r   )rr   rH   rH   rI   r  ~  s    zDistributionMetadata.get_namec             C   s   |  j  p d S)Nz0.0.0)r   )rr   rH   rH   rI   r  Å  s    z DistributionMetadata.get_versionc             C   s   d |  j  É  |  j É  f S)Nz%s-%s)r  r  )rr   rH   rH   rI   ⁄get_fullnameÑ  s    z!DistributionMetadata.get_fullnamec             C   s   |  j  p d S)Nr  )r$   )rr   rH   rH   rI   ⁄
get_authorá  s    zDistributionMetadata.get_authorc             C   s   |  j  p d S)Nr  )r  )rr   rH   rH   rI   ⁄get_author_emailä  s    z%DistributionMetadata.get_author_emailc             C   s   |  j  p d S)Nr  )r(   )rr   rH   rH   rI   ⁄get_maintainerç  s    z#DistributionMetadata.get_maintainerc             C   s   |  j  p d S)Nr  )r  )rr   rH   rH   rI   ⁄get_maintainer_emailê  s    z)DistributionMetadata.get_maintainer_emailc             C   s   |  j  p |  j p d S)Nr  )r(   r$   )rr   rH   rH   rI   r  ì  s    z DistributionMetadata.get_contactc             C   s   |  j  p |  j p d S)Nr  )r  r  )rr   rH   rH   rI   r  ñ  s    z&DistributionMetadata.get_contact_emailc             C   s   |  j  p d S)Nr  )r0   )rr   rH   rH   rI   r  ô  s    zDistributionMetadata.get_urlc             C   s   |  j  p d S)Nr  )r2   )rr   rH   rH   rI   r  ú  s    z DistributionMetadata.get_licensec             C   s   |  j  p d S)Nr  )r6   )rr   rH   rH   rI   r  †  s    z$DistributionMetadata.get_descriptionc             C   s   |  j  p d S)Nr  )r  )rr   rH   rH   rI   r  £  s    z)DistributionMetadata.get_long_descriptionc             C   s   |  j  p g  S)N)r>   )rr   rH   rH   rI   r  ¶  s    z!DistributionMetadata.get_keywordsc             C   s   |  j  p d g S)Nr  )r:   )rr   rH   rH   rI   r  ©  s    z"DistributionMetadata.get_platformsc             C   s   |  j  p g  S)N)r<   )rr   rH   rH   rI   r   ¨  s    z$DistributionMetadata.get_classifiersc             C   s   |  j  p d S)Nr  )r  )rr   rH   rH   rI   ⁄get_download_urlØ  s    z%DistributionMetadata.get_download_urlc             C   s   |  j  p g  S)N)rB   )rr   rH   rH   rI   r!  ≥  s    z!DistributionMetadata.get_requiresc             C   s:   d d  l  } x | D] } | j j | É q W| |  _ d  S)Nr   )⁄distutils.versionpredicate⁄versionpredicate⁄VersionPredicaterB   )rr   rÕ   râ   r   rH   rH   rI   ⁄set_requires∂  s    z!DistributionMetadata.set_requiresc             C   s   |  j  p g  S)N)r@   )rr   rH   rH   rI   r"  º  s    z!DistributionMetadata.get_providesc             C   sM   d d Ñ  | DÉ } x* | D]" } d d  l  } | j j | É q W| |  _ d  S)Nc             S   s   g  |  ] } | j  É  ë q SrH   )rŒ   )rF   r   rH   rH   rI   rJ   ¿  s   	 z5DistributionMetadata.set_provides.<locals>.<listcomp>r   )r*  r+  Zsplit_provisionr@   )rr   rÕ   r   râ   rH   rH   rI   ⁄set_providesø  s
    z!DistributionMetadata.set_providesc             C   s   |  j  p g  S)N)rD   )rr   rH   rH   rI   r#  ∆  s    z"DistributionMetadata.get_obsoletesc             C   s:   d d  l  } x | D] } | j j | É q W| |  _ d  S)Nr   )r*  r+  r,  rD   )rr   rÕ   râ   r   rH   rH   rI   ⁄set_obsoletes…  s    z"DistributionMetadata.set_obsoletes)znamezversionzauthorzauthor_emailz
maintainerzmaintainer_emailzurl˙licensezdescriptionzlong_descriptionzkeywordsz	platformszfullnamezcontactr  r0  zclassifierszdownload_urlzprovideszrequiresz	obsoletes)"rö   r   r  r  rU   r|   r	  r  r  r  r  r  r$  r%  r&  r'  r(  r  r  r  r  Zget_licencer  r  r  r  r   r)  r!  r-  r"  r.  r#  r/  rH   rH   rH   rI   rS   ı  sJ         4"rS   c             C   s2   g  } x% |  D] } | j  | d d Ö É q W| S)zConvert a 4-tuple 'help_options' list as found in various command
    classes to the 3-tuple form required by FancyGetopt.
    r   È   )rì   )rM   Znew_optionsZ
help_tuplerH   rH   rI   r»   œ  s    r»   )r  rj   rå   ⁄reZemailr   rh   rË   Zdistutils.errorsZdistutils.fancy_getoptr   r   Zdistutils.utilr   r   r   râ   r	   Zdistutils.debugr
   ⁄compileræ   r   rS   r»   rH   rH   rH   rI   ⁄<module>   s$   $
ˇ ˇ ˇ ‹⁄                            usr/lib/python3.4/distutils/__pycache__/errors.cpython-34.pyc                                       0100644 0000000 0000000 00000013106 13077704335 022600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T˘  „               @   s¨  d  Z  Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd	 d
 Ñ  d
 e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z	 Gd d Ñ  d e É Z
 Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z Gd d  Ñ  d  e É Z Gd! d" Ñ  d" e É Z Gd# d$ Ñ  d$ e É Z Gd% d& Ñ  d& e É Z d' S)(aã  distutils.errors

Provides exceptions used by the Distutils modules.  Note that Distutils
modules may raise standard exceptions; in particular, SystemExit is
usually raised for errors that are obviously the end-user's fault
(eg. bad command-line arguments).

This module is safe to use in "from ... import *" mode; it only exports
symbols whose names start with "Distutils" and end with "Error".c               @   s   e  Z d  Z d Z d S)⁄DistutilsErrorzThe root of all Distutils evil.N)⁄__name__⁄
__module__⁄__qualname__⁄__doc__© r   r   ˙&/usr/lib/python3.4/distutils/errors.pyr      s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsModuleErrorzÑUnable to load an expected module, or to find an expected class
    within some module (in particular, command modules and classes).N)r   r   r   r   r   r   r   r   r      s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsClassErrorz›Some command class (or possibly distribution class, if anyone
    feels a need to subclass Distribution) is found not to be holding
    up its end of the bargain, ie. implementing some part of the
    "command "interface.N)r   r   r   r   r   r   r   r   r	      s   r	   c               @   s   e  Z d  Z d Z d S)⁄DistutilsGetoptErrorz7The option table provided to 'fancy_getopt()' is bogus.N)r   r   r   r   r   r   r   r   r
      s   r
   c               @   s   e  Z d  Z d Z d S)⁄DistutilsArgErrorzaRaised by fancy_getopt in response to getopt.error -- ie. an
    error in the command line usage.N)r   r   r   r   r   r   r   r   r      s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsFileErrorzìAny problems in the filesystem: expected file not found, etc.
    Typically this is for problems that we detect before OSError
    could be raised.N)r   r   r   r   r   r   r   r   r   $   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsOptionErroraâ  Syntactic/semantic errors in command options, such as use of
    mutually conflicting options, or inconsistent options,
    badly-spelled values, etc.  No distinction is made between option
    values originating in the setup script, the command line, config
    files, or what-have-you -- but if we *know* something originated in
    the setup script, we'll raise DistutilsSetupError instead.N)r   r   r   r   r   r   r   r   r   *   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsSetupErrorzqFor errors that can be definitely blamed on the setup script,
    such as invalid keyword arguments to 'setup()'.N)r   r   r   r   r   r   r   r   r   3   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsPlatformErrorz∆We don't know how to do something on the current platform (but
    we do know how to do it on some platform) -- eg. trying to compile
    C files on a platform not supported by a CCompiler subclass.N)r   r   r   r   r   r   r   r   r   8   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsExecErrorz`Any problems executing an external program (such as the C
    compiler, when compiling C files).N)r   r   r   r   r   r   r   r   r   >   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsInternalErrorzoInternal inconsistencies or impossibilities (obviously, this
    should never be seen if the code is working!).N)r   r   r   r   r   r   r   r   r   C   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsTemplateErrorz%Syntax error in a file list template.N)r   r   r   r   r   r   r   r   r   H   s   r   c               @   s   e  Z d  Z d Z d S)⁄DistutilsByteCompileErrorzByte compile error.N)r   r   r   r   r   r   r   r   r   K   s   r   c               @   s   e  Z d  Z d Z d S)⁄CCompilerErrorz#Some compile/link operation failed.N)r   r   r   r   r   r   r   r   r   O   s   r   c               @   s   e  Z d  Z d Z d S)⁄PreprocessErrorz.Failure to preprocess one or more C/C++ files.N)r   r   r   r   r   r   r   r   r   R   s   r   c               @   s   e  Z d  Z d Z d S)⁄CompileErrorz2Failure to compile one or more C/C++ source files.N)r   r   r   r   r   r   r   r   r   U   s   r   c               @   s   e  Z d  Z d Z d S)⁄LibErrorzKFailure to create a static library from one or more C/C++ object
    files.N)r   r   r   r   r   r   r   r   r   X   s   r   c               @   s   e  Z d  Z d Z d S)⁄	LinkErrorz]Failure to link one or more C/C++ object files into an executable
    or shared library file.N)r   r   r   r   r   r   r   r   r   \   s   r   c               @   s   e  Z d  Z d Z d S)⁄UnknownFileErrorz(Attempt to process an unknown file type.N)r   r   r   r   r   r   r   r   r   `   s   r   N)r   ⁄	Exceptionr   r   r	   r
   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   ⁄<module>	   s&   	                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/distutils/__pycache__/extension.cpython-34.pyc                                    0100644 0000000 0000000 00000016040 13077704335 023300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T_(  „               @   sM   d  Z  d d l Z d d l Z d d l Z Gd d Ñ  d É Z d d Ñ  Z d S)zmdistutils.extension

Provides the Extension class, used to describe C/C++ extension
modules in setup scripts.È    Nc               @   sL   e  Z d  Z d Z d d d d d d d d d d d d d d d d Ñ Z d S)⁄	Extensionaﬂ  Just a collection of attributes that describes an extension
    module and everything needed to build it (hopefully in a portable
    way, but there are hooks that let you be as unportable as you need).

    Instance attributes:
      name : string
        the full name of the extension, including any packages -- ie.
        *not* a filename or pathname, but Python dotted name
      sources : [string]
        list of source filenames, relative to the distribution root
        (where the setup script lives), in Unix form (slash-separated)
        for portability.  Source files may be C, C++, SWIG (.i),
        platform-specific resource files, or whatever else is recognized
        by the "build_ext" command as source for a Python extension.
      include_dirs : [string]
        list of directories to search for C/C++ header files (in Unix
        form for portability)
      define_macros : [(name : string, value : string|None)]
        list of macros to define; each macro is defined using a 2-tuple,
        where 'value' is either the string to define it to or None to
        define it without a particular value (equivalent of "#define
        FOO" in source or -DFOO on Unix C compiler command line)
      undef_macros : [string]
        list of macros to undefine explicitly
      library_dirs : [string]
        list of directories to search for C/C++ libraries at link time
      libraries : [string]
        list of library names (not filenames or paths) to link against
      runtime_library_dirs : [string]
        list of directories to search for C/C++ libraries at run time
        (for shared extensions, this is when the extension is loaded)
      extra_objects : [string]
        list of extra files to link with (eg. object files not implied
        by 'sources', static library that must be explicitly specified,
        binary resource files, etc.)
      extra_compile_args : [string]
        any extra platform- and compiler-specific information to use
        when compiling the source files in 'sources'.  For platforms and
        compilers where "command line" makes sense, this is typically a
        list of command-line arguments, but for other platforms it could
        be anything.
      extra_link_args : [string]
        any extra platform- and compiler-specific information to use
        when linking object files together to create the extension (or
        to create a new static Python interpreter).  Similar
        interpretation as for 'extra_compile_args'.
      export_symbols : [string]
        list of symbols to be exported from a shared extension.  Not
        used on all platforms, and not generally necessary for Python
        extensions, which typically export exactly one symbol: "init" +
        extension_name.
      swig_opts : [string]
        any extra options to pass to SWIG if a source file has the .i
        extension.
      depends : [string]
        list of files that the extension depends on
      language : string
        extension language (i.e. "c", "c++", "objc"). Will be detected
        from the source extensions if not provided.
      optional : boolean
        specifies that a build failure in the extension should not abort the
        build process, but simply not install the failing extension.
    Nc             K   sÖ  t  | t É s t d É Ç n  t  | t É oC t d d Ñ  | DÉ É sU t d É Ç n  | |  _ | |  _ | pp g  |  _ | p g  |  _ | pé g  |  _	 | pù g  |  _
 | p¨ g  |  _ | pª g  |  _ |	 p  g  |  _ |
 pŸ g  |  _ | pË g  |  _ | p˜ g  |  _ | pg  |  _ | pg  |  _ | |  _ | |  _ t | É d k rÅd d Ñ  | DÉ } d j t | É É } d	 | } t j | É n  d  S)
Nz'name' must be a stringc             s   s   |  ] } t  | t É Vq d  S)N)⁄
isinstance⁄str)⁄.0⁄v© r   ˙)/usr/lib/python3.4/distutils/extension.py˙	<genexpr>k   s    z%Extension.__init__.<locals>.<genexpr>z#'sources' must be a list of stringsr   c             S   s   g  |  ] } t  | É ë q Sr   )⁄repr)r   Zoptionr   r   r   ˙
<listcomp>Å   s   	 z&Extension.__init__.<locals>.<listcomp>z, zUnknown Extension options: %s)r   r   ⁄AssertionError⁄list⁄all⁄name⁄sources⁄include_dirs⁄define_macros⁄undef_macros⁄library_dirs⁄	libraries⁄runtime_library_dirs⁄extra_objects⁄extra_compile_args⁄extra_link_args⁄export_symbols⁄	swig_opts⁄depends⁄language⁄optional⁄len⁄join⁄sorted⁄warnings⁄warn)⁄selfr   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   ⁄kwZoptions⁄msgr   r   r   ⁄__init__W   s4    				
zExtension.__init__)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r'   r   r   r   r   r      s   ?r   c             C   s∞  d d l  m } m } m } d d l m } d d l m } | |  É } | |  d d d d d d d	 d d
 d É} z,g  } x| j É  }	 |	 d k rö Pn  | j	 |	 É rØ q~ n  |	 d |	 d( k oŒ d k n rÍ | j
 d |	 É q~ n  | |	 | É }	 | |	 É }
 |
 d } t | g  É } d } xf|
 d d Ö D]T} | d k	 r`| j | É d } q5n  t j j | É d } | d d Ö } | d d Ö } | d) k rµ| j j | É q5| d k r‘| j j | É q5| d k rE| j d É } | d* k r| j j | d f É qâ| j j | d | Ö | | d d Ö f É q5| d k rd| j j | É q5| d k rÉ| j j | É q5| d k r¢| j j | É q5| d k r¡| j j | É q5| d k r‡| j j | É q5| d k r¯| j } q5| d k r| j } q5| d  k r(| j } q5| d! k rY| j j | É | sâ| j } qâq5| d+ k rx| j j | É q5| j
 d' | É q5W| j | É q~ Wd | j É  X| S),z3Reads a Setup file and returns Extension instances.r   )⁄parse_makefile⁄expand_makefile_vars⁄_variable_rx)⁄TextFile)⁄split_quotedZstrip_commentsÈ   Zskip_blanksZ
join_linesZ	lstrip_wsZ	rstrip_wsN⁄*z'%s' lines not handled yetÈ   ˙.c˙.cc˙.cpp˙.cxx˙.c++˙.m˙.mmz-Iz-D˙=z-Uz-Cz-lz-Lz-Rz-rpathz-Xlinkerz
-Xcompilerz-u˙.a˙.so˙.sl˙.o˙.dylibzunrecognized argument '%s'Èˇˇˇˇ)r4   r5   r6   r7   r8   r9   r:   rA   )r<   r=   r>   r?   r@   )Zdistutils.sysconfigr,   r-   r.   Zdistutils.text_filer/   Zdistutils.utilr0   ⁄readline⁄matchr#   r   ⁄append⁄os⁄path⁄splitextr   r   ⁄findr   r   r   r   r   r   r   r   ⁄close)⁄filenamer,   r-   r.   r/   r0   ⁄vars⁄file⁄
extensions⁄lineZwords⁄moduleZextZappend_next_wordZword⁄suffixZswitch⁄valueZequalsr   r   r   ⁄read_setup_fileÜ   sÜ    	$
 rR   )r+   rE   ⁄sysr"   r   rR   r   r   r   r   ⁄<module>   s
   r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python3.4/distutils/__pycache__/fancy_getopt.cpython-34.pyc                                 0100644 0000000 0000000 00000026442 13077704335 023755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TxE  „               @   sK  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Td Z e j d e É Z e j d e e f É Z	 e
 j d d É Z Gd	 d
 Ñ  d
 É Z d d Ñ  Z d d Ñ  e j DÉ Z d d Ñ  Z d d Ñ  Z Gd d Ñ  d É Z e d k rGd Z xK d d d d f D]7 Z e d e É e d j e e e É É É e É  q	Wn  d S)a6  distutils.fancy_getopt

Wrapper around the standard getopt module that provides the following
additional features:
  * short and long options are tied together
  * options have help strings, so fancy_getopt could potentially
    create a complete usage summary
  * options set attributes of a passed-in object
È    N)⁄*z[a-zA-Z](?:[a-zA-Z0-9-]*)z^%s$z^(%s)=!(%s)$˙-⁄_c               @   s÷   e  Z d  Z d Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d d d	 d
 Ñ Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d d Ñ Z d d Ñ  Z d d d Ñ Z d d d d Ñ Z d S)⁄FancyGetopta’  Wrapper around the standard 'getopt()' module that provides some
    handy extra functionality:
      * short and long options are tied together
      * options have help strings, and help text can be assembled
        from them
      * options set attributes of a passed-in object
      * boolean options can have "negative aliases" -- eg. if
        --quiet is the "negative alias" of --verbose, then "--quiet"
        on the command line sets 'verbose' to false
    Nc             C   st   | |  _  i  |  _ |  j  r( |  j É  n  i  |  _ i  |  _ g  |  _ g  |  _ i  |  _ i  |  _ i  |  _	 g  |  _
 d  S)N)⁄option_table⁄option_index⁄_build_index⁄alias⁄negative_alias⁄
short_opts⁄	long_opts⁄
short2long⁄	attr_name⁄	takes_arg⁄option_order)⁄selfr   © r   ˙,/usr/lib/python3.4/distutils/fancy_getopt.py⁄__init__)   s    											zFancyGetopt.__init__c             C   s6   |  j  j É  x" |  j D] } | |  j  | d <q Wd  S)Nr   )r   ⁄clearr   )r   ⁄optionr   r   r   r   Q   s    zFancyGetopt._build_indexc             C   s   | |  _  |  j É  d  S)N)r   r   )r   r   r   r   r   ⁄set_option_tableV   s    	zFancyGetopt.set_option_tablec             C   sR   | |  j  k r" t d | É Ç n, | | | f } |  j j | É | |  j  | <d  S)Nz'option conflict: already an option '%s')r   ⁄DistutilsGetoptErrorr   ⁄append)r   ⁄long_optionZshort_optionZhelp_stringr   r   r   r   ⁄
add_optionZ   s    zFancyGetopt.add_optionc             C   s   | |  j  k S)zcReturn true if the option table for this parser has an
        option with long name 'long_option'.)r   )r   r   r   r   r   ⁄
has_optionc   s    zFancyGetopt.has_optionc             C   s   | j  t É S)zíTranslate long option name 'long_option' to the form it
        has as an attribute of some object: ie., translate hyphens
        to underscores.)⁄	translate⁄longopt_xlate)r   r   r   r   r   ⁄get_attr_nameh   s    zFancyGetopt.get_attr_namec             C   så   t  | t É s t Ç xp | j É  D]b \ } } | |  j k rY t d | | | f É Ç n  | |  j k r" t d | | | f É Ç q" q" Wd  S)Nz(invalid %s '%s': option '%s' not definedz0invalid %s '%s': aliased option '%s' not defined)⁄
isinstance⁄dict⁄AssertionError⁄itemsr   r   )r   ⁄aliasesZwhatr	   ⁄optr   r   r   ⁄_check_alias_dictn   s    zFancyGetopt._check_alias_dictc             C   s   |  j  | d É | |  _ d S)z'Set the aliases for this option parser.r	   N)r&   r	   )r   r	   r   r   r   ⁄set_aliasesx   s    zFancyGetopt.set_aliasesc             C   s   |  j  | d É | |  _ d S)z⁄Set the negative aliases for this option parser.
        'negative_alias' should be a dictionary mapping option names to
        option names, both the key and value must already be defined
        in the option table.znegative aliasN)r&   r
   )r   r
   r   r   r   ⁄set_negative_aliases}   s    z FancyGetopt.set_negative_aliasesc             C   sê  g  |  _  g  |  _ |  j j É  i  |  _ xa|  j D]V} t | É d k rb | \ } } } d } n: t | É d k râ | \ } } } } n t d | f É Ç t | t	 É sæ t | É d k  r— t
 d | É Ç n  | d k p˚ t | t	 É o˚ t | É d k st
 d	 | É Ç n  | |  j | <|  j  j | É | d d
 k rq| rQ| d } n  | d d Ö } d |  j | <na |  j j | É } | d k	 r≈|  j | rµt
 d | | f É Ç n  | |  j  d <n  d |  j | <|  j j | É } | d k	 r&|  j | |  j | k r&t
 d | | f É Ç q&n  t j | É sHt
 d | É Ç n  |  j | É |  j | <| r2 |  j j | É | |  j | d <q2 q2 Wd S)zùPopulate the various data structures that keep tabs on the
        option table.  Called by 'getopt()' before it can do anything
        worthwhile.
        È   r   È   zinvalid option tuple: %rÈ   z9invalid long option '%s': must be a string of length >= 2NÈ   z:invalid short option '%s': must a single character or None˙=˙:z>invalid negative alias '%s': aliased option '%s' takes a valuezginvalid alias '%s': inconsistent with aliased option '%s' (one of them takes a value, the other doesn'tzEinvalid long option name '%s' (must be letters, numbers, hyphens onlyÈˇˇˇˇr/   r/   )r   r   r   r   ⁄repeatr   ⁄len⁄
ValueErrorr    ⁄strr   r   r   r
   ⁄getr	   ⁄
longopt_re⁄matchr   r   )r   r   ⁄long⁄short⁄helpr0   Zalias_tor   r   r   ⁄_grok_option_tableÖ   s^    				"! zFancyGetopt._grok_option_tablec             C   s>  | d k r" t  j d d Ö } n  | d k r@ t É  } d } n d } |  j É  d j |  j É } y" t j | | |  j É \ } } Wn4 t j k
 r∫ } z t	 | É Ç WYd d } ~ Xn Xxh| D]`\ } } t
 | É d k r| d d k r|  j | d } n> t
 | É d k r,| d d Ö d	 k s2t Ç | d d Ö } |  j j | É }	 |	 rc|	 } n  |  j | s∏| d
 k sàt d É Ç |  j j | É }	 |	 rØ|	 } d } q∏d } n  |  j | }
 | r¸|  j j |
 É d k	 r¸t | |
 d É d } n  t | |
 | É |  j j | | f É q¬ W| r6| | f S| Sd S)a  Parse command-line options in args. Store as attributes on object.

        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If
        'object' is None or not supplied, creates a new OptionDummy
        object, stores option values there, and returns a tuple (args,
        object).  If 'object' is supplied, it is modified in place and
        'getopt()' just returns 'args'; in both cases, the returned
        'args' is a modified copy of the passed-in 'args' list, which
        is left untouched.
        Nr,   TF˙ r+   r   r   z--⁄ zboolean option can't have value)⁄sys⁄argv⁄OptionDummyr:   ⁄joinr   ⁄getoptr   ⁄errorZDistutilsArgErrorr1   r   r"   r	   r4   r   r
   r   r0   ⁄getattr⁄setattrr   r   )r   ⁄args⁄objectZcreated_objectr   Zopts⁄msgr%   ⁄valr	   ⁄attrr   r   r   rA   “   sF    		
"".			
zFancyGetopt.getoptc             C   s)   |  j  d k r t d É Ç n |  j  Sd S)z´Returns the list of (option, value) tuples processed by the
        previous run of 'getopt()'.  Raises RuntimeError if
        'getopt()' hasn't been called yet.
        Nz!'getopt()' hasn't been called yet)r   ⁄RuntimeError)r   r   r   r   ⁄get_option_order  s    zFancyGetopt.get_option_orderc             C   s  d } x| |  j  D]q } | d } | d } t | É } | d d k rS | d } n  | d k	 rl | d } n  | | k r | } q q W| d d d } d } | | }	 d | }
 | r√ | g } n	 d	 g } x|  j  D]} | d d
 Ö \ } } } t | |	 É } | d d k r'| d d Ö } n  | d k rt| rZ| j d | | | d f É qº| j d | | f É nH d | | f } | r´| j d | | | d f É n | j d | É x) | d d Ö D] } | j |
 | É qÕWq÷ W| S)zåGenerate help text (a list of strings, one per suggested line of
        output) from the option table for this FancyGetopt object.
        r   r,   r-   NÈ   r+   ÈN   r;   zOption summary:r)   z  --%-*s  %sz
  --%-*s  z%s (-%s)z  --%-*sr/   r/   r/   )r   r1   ⁄	wrap_textr   )r   ⁄headerZmax_optr   r7   r8   ⁄lZ	opt_widthZ
line_widthZ
text_widthZ
big_indent⁄linesr9   ⁄textZ	opt_namesr   r   r   ⁄generate_help  sF    



	!	zFancyGetopt.generate_helpc             C   sG   | d  k r t  j } n  x( |  j | É D] } | j | d É q( Wd  S)N⁄
)r=   ⁄stdoutrS   ⁄write)r   rO   ⁄file⁄liner   r   r   ⁄
print_helph  s    zFancyGetopt.print_help)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r   r   r   r   r   r&   r'   r(   r:   rA   rK   rS   rY   r   r   r   r   r      s   
(	
M=
Or   c             C   s)   t  |  É } | j | É | j | | É S)N)r   r(   rA   )⁄optionsZnegative_optrF   rE   ⁄parserr   r   r   ⁄fancy_getopto  s    r`   c             C   s   i  |  ] } d  t  | É ì q S)r;   )⁄ord)⁄.0Z_wscharr   r   r   ˙
<dictcomp>u  s   	 rc   c             C   sÇ  |  d k r g  St  |  É | k r) |  g S|  j É  }  |  j t É }  t j d |  É } d d Ñ  | DÉ } g  } x| r}g  } d } xt | r˙ t  | d É } | | | k r“ | j | d É | d =| | } qá | rˆ | d	 d d k rˆ | d
 =n  Pqá W| rd| d k rC| j | d d | Ö É | d | d Ö | d <n  | d d d k rd| d =qdn  | j d j | É É qr W| S)z∂wrap_text(text : string, width : int) -> [string]

    Split 'text' into multiple lines of no more than 'width' characters
    each, and return the list of strings that results.
    Nz( +|-+)c             S   s   g  |  ] } | r | ë q Sr   r   )rb   Zchr   r   r   ˙
<listcomp>Ö  s   	 zwrap_text.<locals>.<listcomp>r   r,   r;   r<   r/   r/   )r1   ⁄
expandtabsr   ⁄WS_TRANS⁄re⁄splitr   r@   )rR   ⁄widthZchunksrQ   Zcur_lineZcur_lenrP   r   r   r   rN   w  s:    		
rN   c             C   s   |  j  t É S)zXConvert a long option name to a valid Python identifier by
    changing "-" to "_".
    )r   r   )r%   r   r   r   ⁄translate_longopt≠  s    rj   c               @   s%   e  Z d  Z d Z g  d d Ñ Z d S)r?   z_Dummy class just used as a place to hold command-line option
    values as instance attributes.c             C   s%   x | D] } t  |  | d É q Wd S)zkCreate a new OptionDummy instance.  The attributes listed in
        'options' will be initialized to None.N)rD   )r   r^   r%   r   r   r   r   ∏  s    zOptionDummy.__init__N)rZ   r[   r\   r]   r   r   r   r   r   r?   ¥  s   r?   ⁄__main__z¢Tra-la-la, supercalifragilisticexpialidocious.
How *do* you spell that odd word, anyways?
(Someone ask Mary -- she'll know [or she'll
say, "How should I know?"].)È
   È   È   È(   z	width: %drT   )r]   r=   ⁄stringrg   rA   Zdistutils.errorsZlongopt_pat⁄compiler5   Zneg_alias_rer3   ⁄	maketransr   r   r`   Z
whitespacerf   rN   rj   r?   rZ   rR   ⁄w⁄printr@   r   r   r   r   ⁄<module>	   s(   $
ˇ S6                                                                                                                                                                                                                              usr/lib/python3.4/distutils/__pycache__/file_util.cpython-34.pyc                                    0100644 0000000 0000000 00000014111 13077704335 023235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TÑ  „               @   sú   d  Z  d d l Z d d l m Z d d l m Z i d d 6d d 6d d	 6Z d d d Ñ Z d d d d d d d d Ñ Z d d d d Ñ Z	 d d Ñ  Z
 d S)zFdistutils.file_util

Utility functions for operating on single files.
È    N)⁄DistutilsFileError)⁄logZcopyingzhard linking⁄hardzsymbolically linking⁄symÈ   i   c          N   C   s  d } d } z…y t  |  d É } Wn> t k
 rb } z t d |  | j f É Ç WYd d } ~ Xn Xt j j | É r  y t j | É Wq  t k
 r∆ } z t d | | j f É Ç WYd d } ~ Xq  Xn  y t  | d É } Wn> t k
 r} z t d | | j f É Ç WYd d } ~ Xn Xx≥ y | j | É } Wn> t k
 rt} z t d |  | j f É Ç WYd d } ~ Xn X| sPn  y | j	 | É Wq!t k
 r–} z t d | | j f É Ç WYd d } ~ Xq!Xq!Wd | rÎ| j
 É  n  | r˛| j
 É  n  Xd S)	a5  Copy the file 'src' to 'dst'; both must be filenames.  Any error
    opening either file, reading from 'src', or writing to 'dst', raises
    DistutilsFileError.  Data is read/written in chunks of 'buffer_size'
    bytes (default 16k).  No attempt is made to handle anything apart from
    regular files.
    N⁄rbzcould not open '%s': %szcould not delete '%s': %s⁄wbzcould not create '%s': %szcould not read from '%s': %szcould not write to '%s': %s)⁄open⁄OSErrorr   ⁄strerror⁄os⁄path⁄exists⁄unlink⁄read⁄write⁄close)⁄src⁄dstZbuffer_sizeZfsrcZfdst⁄eZbuf© r   ˙)/usr/lib/python3.4/distutils/file_util.py⁄_copy_file_contents   sF    	,,))0r   È   c             C   sö  d d l  m } d d l m }	 m }
 m } m } t j j	 |  É sW t
 d |  É Ç n  t j j | É rì | } t j j | t j j |  É É } n t j j | É } | r‰ | |  | É r‰ | d k r⁄ t j d |  É n  | d f Sy t | } Wn" t k
 rt d | É Ç Yn X| d k ryt j j | É t j j |  É k r`t j d | |  | É qyt j d | |  | É n  | râ| d f S| d	 k r“t j j | É oπt j j |  | É sêt j |  | É qênæ | d
 k rt j j | É ot j j |  | É sêt j |  | É qênu t |  | É | s4| rêt j |  É } | rjt j | | |	 | |
 f É n  | rêt j | | | | É É qên  | d f S)a·  Copy a file 'src' to 'dst'.  If 'dst' is a directory, then 'src' is
    copied there with the same name; otherwise, it must be a filename.  (If
    the file exists, it will be ruthlessly clobbered.)  If 'preserve_mode'
    is true (the default), the file's mode (type and permission bits, or
    whatever is analogous on the current platform) is copied.  If
    'preserve_times' is true (the default), the last-modified and
    last-access times are copied as well.  If 'update' is true, 'src' will
    only be copied if 'dst' does not exist, or if 'dst' does exist but is
    older than 'src'.

    'link' allows you to make hard links (os.link) or symbolic links
    (os.symlink) instead of copying: set it to "hard" or "sym"; if it is
    None (the default), files are copied.  Don't set 'link' on systems that
    don't support it: 'copy_file()' doesn't check if hard or symbolic
    linking is available.

    Under Mac OS, uses the native file copy function in macostools; on
    other systems, uses '_copy_file_contents()' to copy file contents.

    Return a tuple (dest_name, copied): 'dest_name' is the actual name of
    the output file, and 'copied' is true if the file was copied (or would
    have been copied, if 'dry_run' true).
    r   )⁄newer)⁄ST_ATIME⁄ST_MTIME⁄ST_MODE⁄S_IMODEz4can't copy '%s': doesn't exist or not a regular filer   z"not copying %s (output up-to-date)z&invalid value '%s' for 'link' argumentz%s %s -> %sr   r   )Zdistutils.dep_utilr   ⁄statr   r   r   r   r   r   ⁄isfiler   ⁄isdir⁄join⁄basename⁄dirnamer   ⁄debug⁄_copy_action⁄KeyError⁄
ValueError⁄infor   ⁄samefile⁄link⁄symlinkr   ⁄utime⁄chmod)r   r   Zpreserve_modeZpreserve_times⁄updater+   ⁄verbose⁄dry_runr   r   r   r   r   ⁄dir⁄action⁄str   r   r   ⁄	copy_fileC   sJ     "$
$
''! r5   c          (   C   s%  d d l  m } m } m } m } m } d d l }	 | d k rV t j d |  | É n  | r` | S| |  É s t	 d |  É Ç n  | | É r© t
 j j | | |  É É } n% | | É rŒ t	 d |  | f É Ç n  | | | É É s˘ t	 d |  | f É Ç n  d	 }
 y t
 j |  | É Wne t k
 rz} zE | j \ } } | |	 j k rOd
 }
 n t	 d |  | | f É Ç WYd d } ~ Xn X|
 r!t |  | d | Éy t
 j |  É Wq!t k
 r} zV | j \ } } y t
 j | É Wn t k
 rÓYn Xt	 d |  | |  | f É Ç WYd d } ~ Xq!Xn  | S)a%  Move a file 'src' to 'dst'.  If 'dst' is a directory, the file will
    be moved into it with the same name; otherwise, 'src' is just renamed
    to 'dst'.  Return the new full name of the file.

    Handles cross-device moves on Unix using 'copy_file()'.  What about
    other systems???
    r   )r   r    r!   r#   r$   Nr   zmoving %s -> %sz#can't move '%s': not a regular filez0can't move '%s': destination '%s' already existsz2can't move '%s': destination '%s' not a valid pathFTzcouldn't move '%s' to '%s': %sr0   zAcouldn't move '%s' to '%s' by copy/delete: delete '%s' failed: %s)⁄os.pathr   r    r!   r#   r$   ⁄errnor   r)   r   r   r   r"   ⁄renamer
   ⁄argsZEXDEVr5   r   )r   r   r0   r1   r   r    r!   r#   r$   r7   Zcopy_itr   Znum⁄msgr   r   r   ⁄	move_fileû   sR    (	),r;   c          
   C   sG   t  |  d É } z& x | D] } | j | d É q WWd | j É  Xd S)z{Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators) to it.
    ⁄w⁄
N)r	   r   r   )⁄filename⁄contents⁄f⁄liner   r   r   ⁄
write_file›   s
    rB   i @  )⁄__doc__r   Zdistutils.errorsr   Z	distutilsr   r&   r   r5   r;   rB   r   r   r   r   ⁄<module>   s   

3	[=                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/distutils/__pycache__/filelist.cpython-34.pyc                                     0100644 0000000 0000000 00000023650 13077704335 023104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T∞1  „               @   s™   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z m Z d d l	 m
 Z
 Gd d Ñ  d É Z e j d d	 Ñ Z d
 d Ñ  Z d d d d d Ñ Z d S)zsdistutils.filelist

Provides the FileList class, used for poking about the filesystem
and building lists of files.
È    N)⁄convert_path)⁄DistutilsTemplateError⁄DistutilsInternalError)⁄logc               @   sƒ   e  Z d  Z d Z d d d d Ñ Z d d Ñ  Z e j d d Ñ Z d	 d
 Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d d d Ñ Z d d d d d Ñ Z d S)⁄FileLista—  A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.

    Instance attributes:
      dir
        directory from which files will be taken -- only used if
        'allfiles' not supplied to constructor
      files
        list of filenames currently being built/filtered/manipulated
      allfiles
        complete list of files under consideration (ie. without any
        filtering applied)
    Nc             C   s   d  |  _  g  |  _ d  S)N)⁄allfiles⁄files)⁄self⁄warn⁄debug_print© r   ˙(/usr/lib/python3.4/distutils/filelist.py⁄__init__   s    	zFileList.__init__c             C   s   | |  _  d  S)N)r   )r	   r   r   r   r   ⁄set_allfiles"   s    zFileList.set_allfilesc             C   s   t  | É |  _ d  S)N)⁄findallr   )r	   ⁄dirr   r   r   r   %   s    zFileList.findallc             C   s'   d d l  m } | r# t | É n  d S)z~Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        r   )⁄DEBUGN)Zdistutils.debugr   ⁄print)r	   ⁄msgr   r   r   r   r   (   s    zFileList.debug_printc             C   s   |  j  j | É d  S)N)r   ⁄append)r	   ⁄itemr   r   r   r   2   s    zFileList.appendc             C   s   |  j  j | É d  S)N)r   ⁄extend)r	   ⁄itemsr   r   r   r   5   s    zFileList.extendc             C   sX   t  t t j j |  j É É } g  |  _ x* | D]" } |  j j t j j | å  É q. Wd  S)N)⁄sorted⁄map⁄os⁄path⁄splitr   r   ⁄join)r	   Zsortable_filesZ
sort_tupler   r   r   ⁄sort8   s    	zFileList.sortc             C   sY   xR t  t |  j É d d d É D]1 } |  j | |  j | d k r  |  j | =q  q  Wd  S)NÈ   r   Èˇˇˇˇ)⁄range⁄lenr   )r	   ⁄ir   r   r   ⁄remove_duplicatesB   s    &zFileList.remove_duplicatesc             C   s:  | j  É  } | d } d  } } } | d k ru t | É d k  rU t d | É Ç n  d d	 Ñ  | d
 d  Ö DÉ } nµ | d k r÷ t | É d k  r¶ t d | É Ç n  t | d
 É } d d	 Ñ  | d d  Ö DÉ } nT | d k rt | É d k rt d | É Ç n  t | d
 É } n t d | É Ç | | | | f S)Nr   ⁄include⁄exclude˙global-include˙global-excludeÈ   z&'%s' expects <pattern1> <pattern2> ...c             S   s   g  |  ] } t  | É ë q Sr   )r   )⁄.0⁄wr   r   r   ˙
<listcomp>V   s   	 z1FileList._parse_template_line.<locals>.<listcomp>r    ˙recursive-include˙recursive-excludeÈ   z,'%s' expects <dir> <pattern1> <pattern2> ...c             S   s   g  |  ] } t  | É ë q Sr   )r   )r+   r,   r   r   r   r-   \   s   	 ⁄graft⁄prunez#'%s' expects a single <dir_pattern>zunknown action '%s')r&   r'   r(   r)   )r.   r/   )r1   r2   )r   r#   r   r   )r	   ⁄lineZwords⁄action⁄patternsr   ⁄dir_patternr   r   r   ⁄_parse_template_lineK   s,    
	  zFileList._parse_template_linec             C   s  |  j  | É \ } } } } | d k r} |  j d d j | É É x’| D]. } |  j | d d ÉsH t j d | É qH qH Wnú| d k rﬂ |  j d d j | É É xs| D]. } |  j | d d És™ t j d	 | É q™ q™ Wn:| d
 k rA|  j d d j | É É x| D]. } |  j | d d Ést j d | É qqWnÿ| d k r£|  j d d j | É É xØ| D]. } |  j | d d Ésnt j d | É qnqnWnv| d k r|  j d | d j | É f É xG| D]1 } |  j | d | És÷t j d | | É q÷q÷Wn| d k ry|  j d | d j | É f É x‹ | D]1 } |  j | d | ÉsAt j d | | É qAqAWn† | d k r¡|  j d | É |  j d  d | Ést j d | É qnX | d k r	|  j d | É |  j d  d | Ést j d | É qn t d | É Ç d  S)Nr&   zinclude ˙ ⁄anchorr    z%warning: no files found matching '%s'r'   zexclude z9warning: no previously-included files found matching '%s'zglobal-includezglobal-include r   z>warning: no files found matching '%s' anywhere in distributionzglobal-excludezglobal-exclude zRwarning: no previously-included files matching '%s' found anywhere in distributionzrecursive-includezrecursive-include %s %s⁄prefixz:warning: no files found matching '%s' under directory '%s'zrecursive-excludezrecursive-exclude %s %szNwarning: no previously-included files matching '%s' found under directory '%s'r1   zgraft z+warning: no directories found matching '%s'r2   zprune z6no previously-included directories found matching '%s'z'this cannot happen: invalid action '%s')r7   r   r   ⁄include_patternr   r
   ⁄exclude_patternr   )r	   r3   r4   r5   r   r6   ⁄patternr   r   r   ⁄process_template_lineg   sf    										zFileList.process_template_liner    r   c             C   sú   d } t  | | | | É } |  j d | j É |  j d k rK |  j É  n  xJ |  j D]? } | j | É rU |  j d | É |  j j | É d } qU qU W| S)aó  Select strings (presumably filenames) from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob) pattern.  Patterns
        are not quite the same as implemented by the 'fnmatch' module: '*'
        and '?'  match non-special characters, where "special" is platform-
        dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default), then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern) and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return True if files are found, False otherwise.
        Fz%include_pattern: applying regex r'%s'Nz adding T)⁄translate_patternr   r=   r   r   ⁄searchr   r   )r	   r=   r9   r:   ⁄is_regex⁄files_found⁄
pattern_re⁄namer   r   r   r;   ≥   s    	zFileList.include_patternc             C   sû   d } t  | | | | É } |  j d | j É xh t t |  j É d d d É D]G } | j |  j | É rO |  j d |  j | É |  j | =d } qO qO W| S)a  Remove strings (presumably filenames) from 'files' that match
        'pattern'.  Other parameters are the same as for
        'include_pattern()', above.
        The list 'self.files' is modified in place.
        Return True if files are found, False otherwise.
        Fz%exclude_pattern: applying regex r'%s'r    z
 removing Tr!   r!   )r?   r   r=   r"   r#   r   r@   )r	   r=   r9   r:   rA   rB   rC   r$   r   r   r   r<   ﬁ   s    	&
zFileList.exclude_pattern)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r   r   ⁄curdirr   r   r   r   r   r%   r7   r>   r;   r<   r   r   r   r   r      s   

	L,r   c             C   s  d d l  m } m } m } m } g  } |  g } | j } | j } xª | r | É  }  t j |  É }	 xñ |	 D]é }
 |  t j	 k rò t j
 j |  |
 É } n |
 } t j  | É } | | } | | É r” | j | É qk | | É rk | | É rk | | É qk qk WqF W| S)z^Find all files under 'dir' and return the list of full filenames
    (relative to 'dir').
    r   )⁄ST_MODE⁄S_ISREG⁄S_ISDIR⁄S_ISLNK)⁄statrJ   rK   rL   rM   ⁄popr   r   ⁄listdirrI   r   r   )r   rJ   rK   rL   rM   ⁄list⁄stackrO   ⁄push⁄namesrD   ⁄fullnamerN   ⁄moder   r   r   r   ı   s&    "					
r   c             C   sS   t  j |  É } t j } t j d k r0 d } n  d | } t j d | | É } | S)zÊTranslate a shell-like glob pattern to a regular expression; return
    a string containing the regex.  Differs from 'fnmatch.translate()' in
    that '*' does not match "special characters" (which are
    platform-specific).
    ˙\z\\\\z\1[^%s]z((?<!\\)(\\\\)*)\.)⁄fnmatch⁄	translater   ⁄sep⁄re⁄sub)r=   rC   rZ   Zescapedr   r   r   ⁄
glob_to_re  s    		
r]   r    c             C   s⁄   | r) t  |  t É r" t j |  É S|  Sn  |  r> t |  É } n d } | d k	 r∫ t d É } t | É d t | É Ö } t j } t j d k rö d } n  d | j | d | f É } n | rÕ d | } n  t j | É S)a  Translate a shell-like wildcard pattern to a compiled regular
    expression.  Return the compiled regex.  If 'is_regex' true,
    then 'pattern' is directly compiled to a regex (if it's a string)
    or just returned as-is (assumes it's a regex object).
    ⁄ NrW   z\\˙^z.*)	⁄
isinstance⁄strr[   ⁄compiler]   r#   r   rZ   r   )r=   r9   r:   rA   rC   Zempty_patternZ	prefix_rerZ   r   r   r   r?   +  s"    		 r?   )rH   r   r[   rX   Zdistutils.utilr   Zdistutils.errorsr   r   Z	distutilsr   r   rI   r   r]   r?   r   r   r   r   ⁄<module>   s   Ë                                                                                        usr/lib/python3.4/distutils/__pycache__/log.cpython-34.pyc                                          0100644 0000000 0000000 00000004656 13077704335 022057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tt  „               @   sû   d  Z  d Z d Z d Z d Z d Z d d l Z Gd d	 Ñ  d	 É Z e É  Z e j	 Z	 e j
 Z
 e j Z e j Z e j Z e j Z d
 d Ñ  Z d d Ñ  Z d S)z,A simple log mechanism styled after PEP 282.È   È   È   È   È   È    Nc               @   ss   e  Z d  Z e d d Ñ Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d	 d
 Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d S)⁄Logc             C   s   | |  _  d  S)N)⁄	threshold)⁄selfr   © r
   ˙#/usr/lib/python3.4/distutils/log.py⁄__init__   s    zLog.__init__c             C   sÿ   | t  t t t t f k r4 t d t | É É Ç n  | |  j k r‘ | rV | | } n  | t t t f k rw t j	 } n	 t j
 } | j d k r∂ | j } | j | d É j | É } n  | j d | É | j É  n  d  S)Nz%s wrong log level⁄strict⁄backslashreplacez%s
)⁄DEBUG⁄INFO⁄WARN⁄ERROR⁄FATAL⁄
ValueError⁄strr   ⁄sys⁄stderr⁄stdout⁄errors⁄encoding⁄encode⁄decode⁄write⁄flush)r	   ⁄level⁄msg⁄args⁄streamr   r
   r
   r   ⁄_log   s    		zLog._logc             G   s   |  j  | | | É d  S)N)r#   )r	   r   r    r!   r
   r
   r   ⁄log%   s    zLog.logc             G   s   |  j  t | | É d  S)N)r#   r   )r	   r    r!   r
   r
   r   ⁄debug(   s    z	Log.debugc             G   s   |  j  t | | É d  S)N)r#   r   )r	   r    r!   r
   r
   r   ⁄info+   s    zLog.infoc             G   s   |  j  t | | É d  S)N)r#   r   )r	   r    r!   r
   r
   r   ⁄warn.   s    zLog.warnc             G   s   |  j  t | | É d  S)N)r#   r   )r	   r    r!   r
   r
   r   ⁄error1   s    z	Log.errorc             G   s   |  j  t | | É d  S)N)r#   r   )r	   r    r!   r
   r
   r   ⁄fatal4   s    z	Log.fatalN)⁄__name__⁄
__module__⁄__qualname__r   r   r#   r$   r%   r&   r'   r(   r)   r
   r
   r
   r   r      s   r   c             C   s   t  j } |  t  _ | S)N)⁄_global_logr   )r   ⁄oldr
   r
   r   ⁄set_threshold?   s    		r/   c             C   sO   |  d k r t  t É n2 |  d k r2 t  t É n |  d k rK t  t É n  d  S)Nr   r   r   )r/   r   r   r   )⁄vr
   r
   r   ⁄set_verbosityE   s    r1   )⁄__doc__r   r   r   r   r   r   r   r-   r$   r%   r&   r'   r(   r)   r/   r1   r
   r
   r
   r   ⁄<module>   s    )							                                                                                  usr/lib/python3.4/distutils/__pycache__/msvc9compiler.cpython-34.pyc                                0100644 0000000 0000000 00000045446 13077704335 024074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T@w  „               @   sı  d  Z  d d l Z d d l Z d d l Z d d l Z d d l m Z m Z m Z m	 Z	 m
 Z
 d d l m Z m Z m Z d d l m Z d d l m Z d d l Z e j Z e j Z e j Z e j Z e j e j e j e j f Z  e j! d k oe j" d' k Z# e# r!d
 Z$ d Z% d Z& n d Z$ d Z% d Z& i d d 6d d 6d d 6Z' Gd d Ñ  d É Z( Gd d Ñ  d É Z) d d Ñ  Z* d d Ñ  Z+ d d Ñ  Z, d d  Ñ  Z- d d! d" Ñ Z. e* É  Z/ e/ d# k  r€e d$ e/ É Ç n  Gd% d& Ñ  d& e É Z0 d S)(a  distutils.msvc9compiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio 2008.

The module is compatible with VS 2005 and VS 2008. You can find legacy support
for older versions of VS in distutils.msvccompiler.
È    N)⁄DistutilsExecError⁄DistutilsPlatformError⁄CompileError⁄LibError⁄	LinkError)⁄	CCompiler⁄gen_preprocess_options⁄gen_lib_options)⁄log)⁄get_platform⁄win32È   È    z1Software\Wow6432Node\Microsoft\VisualStudio\%0.1fz5Software\Wow6432Node\Microsoft\Microsoft SDKs\Windowsz,Software\Wow6432Node\Microsoft\.NETFrameworkz%Software\Microsoft\VisualStudio\%0.1fz)Software\Microsoft\Microsoft SDKs\Windowsz Software\Microsoft\.NETFramework⁄x86Zamd64z	win-amd64Zia64zwin-ia64c               @   sv   e  Z d  Z d Z d d Ñ  Z e e É Z d d Ñ  Z e e É Z d d Ñ  Z e e É Z d d	 Ñ  Z e	 e É Z d
 S)⁄Regz2Helper class to read values from the registry
    c             C   sM   x: t  D]2 } |  j | | É } | r | | k r | | Sq Wt | É Ç d  S)N)⁄HKEYS⁄read_values⁄KeyError)⁄cls⁄path⁄key⁄base⁄d© r   ˙-/usr/lib/python3.4/distutils/msvc9compiler.py⁄	get_valueA   s
    zReg.get_valuec             C   sÇ   y t  | | É } Wn t k
 r+ d SYn Xg  } d } xC y t | | É } Wn t k
 rc PYn X| j | É | d 7} q; | S)zReturn list of registry keys.Nr   È   )⁄RegOpenKeyEx⁄RegError⁄
RegEnumKey⁄append)r   r   r   ⁄handle⁄L⁄i⁄kr   r   r   ⁄	read_keysI   s    	zReg.read_keysc       	      C   s¶   y t  | | É } Wn t k
 r+ d SYn Xi  } d } xg y t | | É \ } } } Wn t k
 rl PYn X| j É  } |  j | É | |  j | É <| d 7} q; | S)z`Return dict of registry keys and values.

        All names are converted to lowercase.
        Nr   r   )r   r   ⁄RegEnumValue⁄lower⁄convert_mbcs)	r   r   r   r!   r   r#   ⁄name⁄value⁄typer   r   r   r   [   s    	zReg.read_valuesc             C   sJ   t  |  d d  É } | d  k	 rF y | d É }  WqF t k
 rB YqF Xn  |  S)N⁄decode⁄mbcs)⁄getattr⁄UnicodeError)⁄sZdecr   r   r   r(   q   s    zReg.convert_mbcsN)
⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   ⁄classmethodr%   r   r(   ⁄staticmethodr   r   r   r   r   =   s   r   c               @   s@   e  Z d  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d	 S)
⁄MacroExpanderc             C   s'   i  |  _  t | |  _ |  j | É d  S)N)⁄macros⁄VS_BASE⁄vsbase⁄load_macros)⁄self⁄versionr   r   r   ⁄__init__}   s    	zMacroExpander.__init__c             C   s!   t  j | | É |  j d | <d  S)Nz$(%s))r   r   r8   )r<   Zmacror   r   r   r   r   ⁄	set_macroÇ   s    zMacroExpander.set_macroc             C   sT  |  j  d |  j d d É |  j  d |  j d d É |  j  d t d É y2 | d k rl |  j  d	 t d
 É n t d
 É Ç Wn t k
 rô t d É Ç Yn X| d k r“ |  j  d |  j d É |  j  d t d É n~ d } xu t D]m } y t | | É } Wn t k
 rwﬂ Yn Xt	 | d É } t
 j | d | | f É } | d |  j d <qﬂ Wd  S)NZVCInstallDirz	\Setup\VC⁄
productdirZVSInstallDirz	\Setup\VSZFrameworkDirZinstallrootg       @ZFrameworkSDKDirzsdkinstallrootv2.0a  Python was built with Visual Studio 2008;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2008 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.g      "@ZFrameworkVersionzclr versionZWindowsSdkDirZcurrentinstallfolderz.Software\Microsoft\NET Framework Setup\Productr   z%s\%sr=   z$(FrameworkVersion))r?   r:   ⁄NET_BASEr   r   ⁄WINSDK_BASEr   r   r   r   r   r   r8   )r<   r=   ⁄pr   ⁄hr   r   r   r   r   r;   Ö   s.    
zMacroExpander.load_macrosc             C   s6   x/ |  j  j É  D] \ } } | j | | É } q W| S)N)r8   ⁄items⁄replace)r<   r0   r$   ⁄vr   r   r   ⁄sub§   s    zMacroExpander.subN)r1   r2   r3   r>   r?   r;   rH   r   r   r   r   r7   {   s   r7   c              C   sæ   d }  t  j j |  É } | d
 k r( d S| t |  É } t  j | d Ö j d d É \ } } t | d d Ö É d } t | d d Ö É d } | d k r¶ d	 } n  | d k r∫ | | Sd S)z√Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    zMSC v.r   È   N˙ r   È   g      $@r   ÈˇˇˇˇÈ˛ˇˇˇ)⁄sysr=   ⁄find⁄len⁄split⁄int)⁄prefixr#   r0   ⁄restZmajorVersionZminorVersionr   r   r   ⁄get_build_version©   s    %	rU   c             C   sI   g  } x< |  D]4 } t  j j | É } | | k r | j | É q q W| S)znReturn a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    )⁄osr   ⁄normpathr    )ZpathsZreduced_pathsrC   Znpr   r   r   ⁄normalize_and_reduce_pathsø   s    rX   c             C   s[   |  j  t j É } g  } x* | D]" } | | k r | j | É q q Wt j j | É } | S)z8Remove duplicate values of an environment variable.
    )rQ   rV   ⁄pathsepr    ⁄join)ZvariableZoldListZnewListr#   ZnewVariabler   r   r   ⁄removeDuplicatesÕ   s    r[   c             C   sa  t  |  } y t j d | d É } Wn% t k
 rK t j d É d } Yn X| sf t j j | É rd |  } t j	 j
 | d É } | r˙ t j j | É r˙ t j j | t j t j d É } t j j | É } t j j | É st j d | É d Sqt j d | É n  | s%t j d	 É d St j j | d
 É } t j j | É rP| St j d É d S)z®Find the vcvarsall.bat file

    At first it tries to find the productdir of VS 2008 in the registry. If
    that fails it falls back to the VS90COMNTOOLS env var.
    z%s\Setup\VCr@   z%Unable to find productdir in registryNzVS%0.f0COMNTOOLSZVCz%s is not a valid directoryz Env var %s is not set or invalidzNo productdir foundzvcvarsall.batzUnable to find vcvarsall.bat)r9   r   r   r   r
   ⁄debugrV   r   ⁄isdir⁄environ⁄getrZ   ⁄pardir⁄abspath⁄isfile)r=   r:   r@   ZtoolskeyZtoolsdir⁄	vcvarsallr   r   r   ⁄find_vcvarsallÿ   s2    

!rd   c             C   s–  t  |  É } t d É } i  } | d k r9 t d É Ç n  t j d | |  É t j d | | f d	 t j d
 t j É} z˛ | j É  \ } } | j	 É  d k r∂ t | j
 d É É Ç n  | j
 d É } x¨ | j d É D]õ } t j | É } d | k r¸ q’ n  | j É  } | j d d É \ }	 }
 |	 j É  }	 |	 | k r’ |
 j t j É r]|
 d d Ö }
 n  t |
 É | |	 <q’ q’ WWd | j j É  | j j É  Xt | É t | É k rÃt t t | j É  É É É Ç n  | S)zDLaunch vcvarsall.bat and read the settings from its environment
    ⁄include⁄lib⁄libpathr   NzUnable to find vcvarsall.batz'Calling 'vcvarsall.bat %s' (version=%s)z"%s" %s & set⁄stdout⁄stderrr   r-   ⁄
˙=r   )re   zlibrg   zpathrL   )rd   ⁄setr   r
   r\   ⁄
subprocess⁄Popen⁄PIPEZcommunicate⁄waitr,   rQ   r   r(   ⁄stripr'   ⁄endswithrV   rY   r[   rh   ⁄closeri   rP   ⁄
ValueError⁄str⁄list⁄keys)r=   Zarchrc   Zinteresting⁄result⁄popenrh   ri   ⁄liner   r*   r   r   r   ⁄query_vcvarsall˚   s<    	!r{   g       @z(VC %0.1f is not supported by this modulec               @   s  e  Z d  Z d Z d Z i  Z d g Z d d d g Z d g Z d g Z	 e e e e	 Z
 d	 Z d
 Z d Z d Z d Z Z d Z d d d d d Ñ Z d d d Ñ Z d d d d Ñ Z d d d d d d d d d Ñ Z d d d d d Ñ Z d d d d d d d d d d d d Ñ
 Z d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z d$ d% Ñ  Z d& d' Ñ  Z d( d) Ñ  Z d d* d+ Ñ Z d, d- Ñ  Z d S).⁄MSVCCompilerzwConcrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class.Zmsvcz.cz.ccz.cppz.cxxz.rcz.mcz.resz.objz.libz.dllz%s%sz.exer   c             C   sP   t  j |  | | | É t |  _ d |  _ g  |  _ d  |  _ d  |  _ d |  _ d  S)NzSoftware\Microsoft\VisualStudioF)	r   r>   ⁄VERSION⁄_MSVCCompiler__versionZ_MSVCCompiler__root⁄_MSVCCompiler__paths⁄	plat_name⁄_MSVCCompiler__arch⁄initialized)r<   ⁄verboseZdry_runZforcer   r   r   r>   G  s    					zMSVCCompiler.__init__Nc             C   s  |  j  s t d É Ç | d  k r. t É  } n  d& } | | k rV t d | f É Ç n  d t j k r≥ d t j k r≥ |  j d É r≥ d |  _ d	 |  _ d
 |  _	 d |  _
 d |  _ n| t É  k sŒ | d k r€ t | } n t t É  d t | } t t | É } | d j t j É |  _ | d t j d <| d t j d <t |  j É d k rit d |  j É Ç n  |  j d É |  _ |  j d	 É |  _ |  j d
 É |  _	 |  j d É |  _
 |  j d É |  _ y5 x. t j d j d É D] } |  j j | É q›WWn t k
 rYn Xt |  j É |  _ d j |  j É t j d <d  |  _ |  j d k rÜd d d d d g |  _ d d d d d d g |  _ n9 d d d d d d g |  _ d d d d d d d g |  _ d d d  g |  _ |  j d! k r˚d d d" d# d$ g |  _ n  d g |  _ d% |  _  d  S)'Nzdon't init multiple timesr   ˙	win-amd64˙win-ia64z--plat-name must be one of %sZDISTUTILS_USE_SDKZMSSdkzcl.exezlink.exezlib.exezrc.exezmc.exe⁄_r   rf   re   r   zxPython was built with %s, and extensions need to be built with the same version of the compiler, but it isn't installed.˙;r   z/nologoz/Oxz/MDz/W3z/DNDEBUGz/Odz/MDdz/Z7z/D_DEBUGz/GS-z/DLLz/INCREMENTAL:NOÈ   z/INCREMENTAL:noz/DEBUGz	/pdb:NoneT)r   rÑ   rÖ   ) rÇ   ⁄AssertionErrorr   r   rV   r^   ⁄find_exe⁄cc⁄linkerrf   ⁄rc⁄mc⁄PLAT_TO_VCVARSr{   r}   rQ   rY   r   rP   Z_MSVCCompiler__productr    r   rX   rZ   Zpreprocess_optionsrÅ   ⁄compile_options⁄compile_options_debug⁄ldflags_sharedr~   ⁄ldflags_shared_debugZldflags_static)r<   rÄ   Zok_platsZ	plat_specZvc_envrC   r   r   r   ⁄
initializeR  sf    -					zMSVCCompiler.initialize⁄ c             C   sD  | d  k r d } n  g  } x"| D]} t  j j | É \ } } t  j j | É d } | t  j j | É d  Ö } | |  j k rî t d | É Ç n  | rØ t  j j | É } n  | |  j k r‰ | j	 t  j j
 | | |  j É É q" | |  j k r| j	 t  j j
 | | |  j É É q" | j	 t  j j
 | | |  j É É q" W| S)Nrï   r   zDon't know how to compile %s)rV   r   ⁄splitext⁄
splitdrive⁄isabs⁄src_extensionsr   ⁄basename⁄_rc_extensionsr    rZ   ⁄res_extension⁄_mc_extensions⁄obj_extension)r<   Zsource_filenamesZ	strip_dir⁄
output_dirZ	obj_namesZsrc_namer   ⁄extr   r   r   ⁄object_filenames®  s(     	zMSVCCompiler.object_filenamesc	             C   s  |  j  s |  j É  n  |  j | | | | | | É }	 |	 \ } }
 } } } | pR g  } | j d É | r{ | j |  j É n | j |  j É xç|
 D]Ö} y | | \ } } Wn t k
 r√ wí Yn X| rﬂ t j	 j
 | É } n  | |  j k r˚ d | } n±| |  j k rd | } nï| |  j k rô| } d | } y) |  j |  j g | | g | g É Wqí t k
 rí} z t | É Ç WYd  d  } ~ Xqí Xqí n| |  j k rñt j	 j | É } t j	 j | É } yê |  j |  j g d | d | g | g É t j	 j t j	 j | É É \ } } t j	 j | | d É } |  j |  j g d | g | g É Wqí t k
 rè} z t | É Ç WYd  d  } ~ Xqí Xqí n t d | | f É Ç d	 | } y- |  j |  j g | | | | g | É Wqí t k
 r} z t | É Ç WYd  d  } ~ Xqí Xqí W|
 S)
Nz/cz/Tcz/Tpz/foz-hz-rz.rcz"Don't know how to compile %s to %sz/Fo)rÇ   rî   Z_setup_compiler    ⁄extendrë   rê   r   rV   r   ra   ⁄_c_extensions⁄_cpp_extensionsrõ   ⁄spawnrç   r   r   rù   ⁄dirnameré   rñ   rö   rZ   rã   )r<   Zsourcesrü   r8   Zinclude_dirsr\   ⁄extra_preargs⁄extra_postargsZdependsZcompile_info⁄objectsZpp_optsZbuildZcompile_opts⁄obj⁄srcr†   Z	input_optZ
output_opt⁄msgZh_dirZrc_dirr   rÜ   Zrc_filer   r   r   ⁄compile«  sj    	
#$$#
#zMSVCCompiler.compilec       	      C   s’   |  j  s |  j É  n  |  j | | É \ } } |  j | d | É} |  j | | É r¡ | d | g } | ro n  y |  j |  j g | É Wq— t k
 rΩ } z t | É Ç WYd  d  } ~ Xq— Xn t	 j
 d | É d  S)Nrü   z/OUT:zskipping %s (up-to-date))rÇ   rî   ⁄_fix_object_args⁄library_filename⁄
_need_linkr•   rf   r   r   r
   r\   )	r<   r©   Zoutput_libnamerü   r\   ⁄target_lang⁄output_filenameZlib_argsr¨   r   r   r   ⁄create_static_lib  s    		"zMSVCCompiler.create_static_libc             C   s.  |  j  s |  j É  n  |  j | | É \ } } |  j | | | É } | \ } } } | rr |  j d t | É É n  t |  | | | É } | d  k	 r´ t j j	 | | É } n  |  j
 | | É r| t j k r˛ |	 rË |  j d d  Ö } q|  j d d  Ö } n |	 r|  j } n	 |  j } g  } x% | p+g  D] } | j d | É q,W| | | | d | g } t j j | d É } | d  k	 r‹t j j t j j | É É \ } } t j j	 | |  j | É É } | j d | É n  |  j | | | É |
 r|
 | d  d Ö <n  | r| j | É n  |  j t j j | É É y |  j |  j g | É Wn1 t k
 rÖ} z t | É Ç WYd  d  } ~ Xn X|  j | | É } | d  k	 r*| \ } } d | | f } y  |  j d d	 d
 | | g É Wqt k
 r} z t | É Ç WYd  d  } ~ XqXq*n t j d | É d  S)Nz5I don't know what to do with 'runtime_library_dirs': r   z/EXPORT:z/OUT:r   z/IMPLIB:z-outputresource:%s;%szmt.exez-nologoz	-manifestzskipping %s (up-to-date))rÇ   rî   rÆ   Z_fix_lib_args⁄warnru   r	   rV   r   rZ   r∞   r   ⁄
EXECUTABLErì   rí   r    r¶   rñ   rö   rØ   ⁄manifest_setup_ldargsr¢   Zmkpathr•   rå   r   r   ⁄manifest_get_embed_infor
   r\   )r<   ⁄target_descr©   r≤   rü   Z	librariesZlibrary_dirsZruntime_library_dirsZexport_symbolsr\   rß   r®   ⁄
build_tempr±   Z
fixed_argsZlib_optsZldflagsZexport_optsZsym⁄ld_argsZdll_nameZdll_extZimplib_filer¨   ZmfinfoZ
mffilename⁄mfidZout_argr   r   r   ⁄link5  sl    							%zMSVCCompiler.linkc             C   s:   t  j j | t  j j | É d É } | j d | É d  S)Nz	.manifestz/MANIFESTFILE:)rV   r   rZ   rö   r    )r<   r≤   rπ   r∫   ⁄temp_manifestr   r   r   r∂   î  s    	z"MSVCCompiler.manifest_setup_ldargsc             C   sÖ   x; | D]/ } | j  d É r | j d d É d } Pq q Wd  S| t j k rV d } n d } |  j | É } | d  k r{ d  S| | f S)Nz/MANIFESTFILE:˙:r   r   )⁄
startswithrQ   r   rµ   ⁄_remove_visual_c_ref)r<   r∏   r∫   ⁄argrΩ   rª   r   r   r   r∑   †  s    	z$MSVCCompiler.manifest_get_embed_infoc             C   sÔ   y÷ t  | É } z | j É  } Wd  | j É  Xt j d t j É } t j | d | É } d } t j | d | É } t j d t j É } t j | | É d  k r£ d  St  | d É } z | j | É | SWd  | j É  XWn t	 k
 rÍ Yn Xd  S)NzU<assemblyIdentity.*?name=("|')Microsoft\.VC\d{2}\.CRT("|').*?(/>|</assemblyIdentity>)rï   z*<dependentAssembly>\s*</dependentAssembly>zI<assemblyIdentity.*?name=(?:"|')(.+?)(?:"|').*?(?:/>|</assemblyIdentity>)⁄w)
⁄open⁄readrs   ⁄rer≠   ⁄DOTALLrH   ⁄search⁄write⁄OSError)r<   Zmanifest_fileZ
manifest_fZmanifest_buf⁄patternr   r   r   r¿   ∏  s.    	z!MSVCCompiler._remove_visual_c_refc             C   s   d | S)Nz	/LIBPATH:r   )r<   ⁄dirr   r   r   ⁄library_dir_option„  s    zMSVCCompiler.library_dir_optionc             C   s   t  d É Ç d  S)Nz<don't know how to set runtime library search path for MSVC++)r   )r<   rÀ   r   r   r   ⁄runtime_library_dir_optionÊ  s    z'MSVCCompiler.runtime_library_dir_optionc             C   s   |  j  | É S)N)rØ   )r<   rf   r   r   r   ⁄library_optionÍ  s    zMSVCCompiler.library_optionc             C   sÄ   | r | d | g } n	 | g } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É r6 | Sq6 Wq) Wd  Sd  S)NZ_d)rV   r   rZ   rØ   ⁄exists)r<   ⁄dirsrf   r\   Z	try_namesrÀ   r)   Zlibfiler   r   r   ⁄find_library_fileÓ  s    	zMSVCCompiler.find_library_filec             C   sß   xH |  j  D]= } t j j t j j | É | É } t j j | É r
 | Sq
 WxU t j d j d É D]= } t j j t j j | É | É } t j j | É rb | Sqb W| S)aå  Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        ZPathrá   )r   rV   r   rZ   ra   rb   r^   rQ   )r<   ZexerC   ⁄fnr   r   r   rä      s    	!!zMSVCCompiler.find_exe) r1   r2   r3   r4   Zcompiler_typeZexecutablesr£   r§   rõ   rù   rô   rú   rû   Zstatic_lib_extensionZshared_lib_extensionZstatic_lib_formatZshared_lib_formatZexe_extensionr>   rî   r°   r≠   r≥   rº   r∂   r∑   r¿   rÃ   rÕ   rŒ   r—   rä   r   r   r   r   r|   )  sR   			
XVR+r|   l        )1r4   rV   rm   rN   r≈   Zdistutils.errorsr   r   r   r   r   Zdistutils.ccompilerr   r   r	   Z	distutilsr
   Zdistutils.utilr   ⁄winregZ	OpenKeyExr   ZEnumKeyr   Z	EnumValuer&   ⁄errorr   Z
HKEY_USERS⁄HKEY_CURRENT_USER⁄HKEY_LOCAL_MACHINEZHKEY_CLASSES_ROOTr   ⁄platform⁄maxsizeZNATIVE_WIN64r9   rB   rA   rè   r   r7   rU   rX   r[   rd   r{   r}   r|   r   r   r   r   ⁄<module>   sP   (					
>.#)	                                                                                                                                                                                                                          usr/lib/python3.4/distutils/__pycache__/msvccompiler.cpython-34.pyc                                 0100644 0000000 0000000 00000037137 13077704335 024001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T∑[  „               @   s  d  Z  d d l Z d d l Z d d l m Z m Z m Z m Z m Z d d l	 m
 Z
 m Z m Z d d l m Z d Z y@ d d l Z d Z e Z e j Z e j Z e j Z e j Z WnÄ e k
 r:yL d d l Z d d l Z d Z e Z e j Z e j Z e j Z e j Z Wn e k
 r5e j d É Yn XYn Xe rbe j e j e j  e j! f Z" n  d	 d
 Ñ  Z# d d Ñ  Z$ d d Ñ  Z% Gd d Ñ  d É Z& d d Ñ  Z' d d Ñ  Z( d d Ñ  Z) Gd d Ñ  d e
 É Z* e' É  d k re j+ d É e* Z, d d l- m* Z* d d l- m& Z& n  d S)zÇdistutils.msvccompiler

Contains MSVCCompiler, an implementation of the abstract CCompiler class
for the Microsoft Visual Studio.
È    N)⁄DistutilsExecError⁄DistutilsPlatformError⁄CompileError⁄LibError⁄	LinkError)⁄	CCompiler⁄gen_preprocess_options⁄gen_lib_options)⁄logFTzçWarning: Can't read registry to find the necessary compiler setting
Make sure that Python modules winreg, win32api or win32con are installed.c             C   sÇ   y t  |  | É } Wn t k
 r+ d SYn Xg  } d } xC y t | | É } Wn t k
 rc PYn X| j | É | d 7} q; | S)zReturn list of registry keys.Nr   È   )⁄RegOpenKeyEx⁄RegError⁄
RegEnumKey⁄append)⁄base⁄key⁄handle⁄L⁄i⁄k© r   ˙,/usr/lib/python3.4/distutils/msvccompiler.py⁄	read_keys7   s    	r   c             C   s†   y t  |  | É } Wn t k
 r+ d SYn Xi  } d } xa y t | | É \ } } } Wn t k
 rl PYn X| j É  } t | É | t | É <| d 7} q; | S)zXReturn dict of registry keys and values.

    All names are converted to lowercase.
    Nr   r   )r   r   ⁄RegEnumValue⁄lower⁄convert_mbcs)r   r   r   ⁄dr   ⁄name⁄value⁄typer   r   r   ⁄read_valuesH   s    	r    c             C   sJ   t  |  d d  É } | d  k	 rF y | d É }  WqF t k
 rB YqF Xn  |  S)N⁄decode⁄mbcs)⁄getattr⁄UnicodeError)⁄sZdecr   r   r   r   ]   s    r   c               @   s@   e  Z d  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d	 S)
⁄MacroExpanderc             C   s   i  |  _  |  j | É d  S)N)⁄macros⁄load_macros)⁄self⁄versionr   r   r   ⁄__init__g   s    	zMacroExpander.__init__c             C   sC   x< t  D]4 } t | | É } | r | | |  j d | <Pq q Wd  S)Nz$(%s))⁄HKEYSr    r'   )r)   Zmacro⁄pathr   r   r   r   r   r   ⁄	set_macrok   s
    zMacroExpander.set_macroc       
      C   s=  d | } |  j  d | d d É |  j  d | d d É d } |  j  d | d	 É y9 | d
 k rv |  j  d | d É n |  j  d | d É Wn1 t k
 rΩ } z t d É Ç WYd  d  } ~ Xn Xd } xr t D]j } y t | | É } Wn t k
 r˚ wÀ Yn Xt | d É } t | d | | f É }	 |	 d |  j d <qÀ Wd  S)Nz%Software\Microsoft\VisualStudio\%0.1fZVCInstallDirz	\Setup\VCZ
productdirZVSInstallDirz	\Setup\VSz Software\Microsoft\.NETFrameworkZFrameworkDirZinstallrootg      @ZFrameworkSDKDirzsdkinstallrootv1.1Zsdkinstallroota  Python was built with Visual Studio 2003;
extensions must be built with a compiler than can generate compatible binaries.
Visual Studio 2003 was not found on this system. If you have Cygwin installed,
you can try compiling with MingW32, by passing "-c mingw32" to setup.py.z.Software\Microsoft\NET Framework Setup\Productr   z%s\%sr*   z$(FrameworkVersion))	r.   ⁄KeyErrorr   r,   r   r   r   r    r'   )
r)   r*   ZvsbaseZnet⁄exc⁄pr   ⁄hr   r   r   r   r   r(   r   s*    
zMacroExpander.load_macrosc             C   s6   x/ |  j  j É  D] \ } } | j | | É } q W| S)N)r'   ⁄items⁄replace)r)   r%   r   ⁄vr   r   r   ⁄subé   s    zMacroExpander.subN)⁄__name__⁄
__module__⁄__qualname__r+   r.   r(   r6   r   r   r   r   r&   f   s   r&   c              C   sæ   d }  t  j j |  É } | d
 k r( d S| t |  É } t  j | d Ö j d d É \ } } t | d d Ö É d } t | d d Ö É d } | d k r¶ d	 } n  | d k r∫ | | Sd S)z√Return the version of MSVC that was used to build Python.

    For Python 2.3 and up, the version number is included in
    sys.version.  For earlier versions, assume the compiler is MSVC 6.
    zMSC v.r   È   N˙ È   È   g      $@r   ÈˇˇˇˇÈ˛ˇˇˇ)⁄sysr*   ⁄find⁄len⁄split⁄int)⁄prefixr   r%   ⁄restZmajorVersionZminorVersionr   r   r   ⁄get_build_versionì   s    %	rG   c              C   sX   d }  t  j j |  É } | d k r( d St  j j d | É } t  j | t |  É | Ö S)zaReturn the processor architecture.

    Possible results are "Intel", "Itanium", or "AMD64".
    z bit (r   ⁄Intel˙)r>   )r@   r*   rA   rB   )rE   r   ⁄jr   r   r   ⁄get_build_architecture©   s    rK   c             C   sI   g  } x< |  D]4 } t  j j | É } | | k r | j | É q q W| S)znReturn a list of normalized paths with duplicates removed.

    The current order of paths is maintained.
    )⁄osr-   ⁄normpathr   )ZpathsZreduced_pathsr1   Znpr   r   r   ⁄normalize_and_reduce_paths∂   s    rN   c               @   ss  e  Z d  Z d Z d Z i  Z d g Z d d d g Z d g Z d g Z	 e e e e	 Z
 d	 Z d
 Z d Z d Z d Z Z d Z d d d d d Ñ Z d d Ñ  Z d d d d Ñ Z d d d d d d d d d Ñ Z d d d d d Ñ Z d d d d d d d d d d d d Ñ
 Z d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z d d$ d% Ñ Z d& d' Ñ  Z d( d) d* Ñ Z d+ d, Ñ  Z d S)-⁄MSVCCompilerzwConcrete class that implements an interface to Microsoft Visual C++,
       as defined by the CCompiler abstract class.Zmsvcz.cz.ccz.cppz.cxxz.rcz.mcz.resz.objz.libz.dllz%s%sz.exer   c             C   sß   t  j |  | | | É t É  |  _ t É  |  _ |  j d k rÜ |  j d k rj d |  _ t |  j É |  _ n	 d |  _ d |  j |  _	 n d |  j d |  _	 d |  _
 d  S)	NrH   È   zSoftware\Microsoft\VisualStudiozSoftware\Microsoft\DevstudiozVisual Studio version %szMicrosoft SDK compiler %sr:   F)r   r+   rG   ⁄_MSVCCompiler__versionrK   ⁄_MSVCCompiler__arch⁄_MSVCCompiler__rootr&   ⁄_MSVCCompiler__macros⁄_MSVCCompiler__product⁄initialized)r)   ⁄verboseZdry_runZforcer   r   r   r+   „   s    		zMSVCCompiler.__init__c             C   sÉ  g  |  _  d t j k rf d t j k rf |  j d É rf d |  _ d |  _ d |  _ d |  _ d |  _ n± |  j	 d É |  _  t
 |  j  É d	 k r£ t d
 |  j É Ç n  |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  _ |  j d É |  j d É y5 x. t j d j d É D] } |  j  j | É q1WWn t k
 r`Yn Xt |  j  É |  _  d j |  j  É t j d <d  |  _ |  j d k r‡d d d d d d g |  _ d d d d d d d g |  _ n9 d d d d d d g |  _ d d d d d d d g |  _ d d d g |  _ |  j d k rRd d d d g |  _ n d d d d d g |  _ d g |  _ d  |  _ d  S)!NZDISTUTILS_USE_SDKZMSSdkzcl.exezlink.exezlib.exezrc.exezmc.exer-   r   zxPython was built with %s, and extensions need to be built with the same version of the compiler, but it isn't installed.⁄libZinclude˙;rH   z/nologoz/Oxz/MDz/W3z/GXz/DNDEBUGz/Odz/MDdz/Z7z/D_DEBUGz/GS-z/DLLz/INCREMENTAL:NOrP   z/INCREMENTAL:noz/DEBUGz	/pdb:NoneT)⁄_MSVCCompiler__pathsrL   ⁄environ⁄find_exe⁄cc⁄linkerrX   ⁄rc⁄mc⁄get_msvc_pathsrB   r   rU   ⁄set_path_env_varrC   r   r/   rN   ⁄joinZpreprocess_optionsrR   ⁄compile_options⁄compile_options_debug⁄ldflags_sharedrQ   ⁄ldflags_shared_debugZldflags_staticrV   )r)   r1   r   r   r   ⁄
initializeı   sR    	-					zMSVCCompiler.initialize⁄ c             C   sD  | d  k r d } n  g  } x"| D]} t  j j | É \ } } t  j j | É d } | t  j j | É d  Ö } | |  j k rî t d | É Ç n  | rØ t  j j | É } n  | |  j k r‰ | j	 t  j j
 | | |  j É É q" | |  j k r| j	 t  j j
 | | |  j É É q" | j	 t  j j
 | | |  j É É q" W| S)Nri   r   zDon't know how to compile %s)rL   r-   ⁄splitext⁄
splitdrive⁄isabs⁄src_extensionsr   ⁄basename⁄_rc_extensionsr   rc   ⁄res_extension⁄_mc_extensions⁄obj_extension)r)   Zsource_filenamesZ	strip_dir⁄
output_dirZ	obj_namesZsrc_namer   ⁄extr   r   r   ⁄object_filenames5  s(     	zMSVCCompiler.object_filenamesNc	             C   s  |  j  s |  j É  n  |  j | | | | | | É }	 |	 \ } }
 } } } | pR g  } | j d É | r{ | j |  j É n | j |  j É xç|
 D]Ö} y | | \ } } Wn t k
 r√ wí Yn X| rﬂ t j	 j
 | É } n  | |  j k r˚ d | } n±| |  j k rd | } nï| |  j k rô| } d | } y) |  j |  j g | | g | g É Wqí t k
 rí} z t | É Ç WYd  d  } ~ Xqí Xqí n| |  j k rñt j	 j | É } t j	 j | É } yê |  j |  j g d | d | g | g É t j	 j t j	 j | É É \ } } t j	 j | | d É } |  j |  j g d | g | g É Wqí t k
 rè} z t | É Ç WYd  d  } ~ Xqí Xqí n t d | | f É Ç d	 | } y- |  j |  j g | | | | g | É Wqí t k
 r} z t | É Ç WYd  d  } ~ Xqí Xqí W|
 S)
Nz/cz/Tcz/Tpz/foz-hz-rz.rcz"Don't know how to compile %s to %sz/Fo)rV   rh   Z_setup_compiler   ⁄extendre   rd   r/   rL   r-   ⁄abspath⁄_c_extensions⁄_cpp_extensionsro   ⁄spawnr_   r   r   rq   ⁄dirnamer`   rj   rn   rc   r]   )r)   Zsourcesrs   r'   Zinclude_dirs⁄debug⁄extra_preargs⁄extra_postargsZdependsZcompile_info⁄objectsZpp_optsZbuildZcompile_opts⁄obj⁄srcrt   Z	input_optZ
output_opt⁄msgZh_dirZrc_dirr   ⁄_Zrc_filer   r   r   ⁄compileT  sj    	
#$$#
#zMSVCCompiler.compilec       	      C   s’   |  j  s |  j É  n  |  j | | É \ } } |  j | d | É} |  j | | É r¡ | d | g } | ro n  y |  j |  j g | É Wq— t k
 rΩ } z t | É Ç WYd  d  } ~ Xq— Xn t	 j
 d | É d  S)Nrs   z/OUT:zskipping %s (up-to-date))rV   rh   ⁄_fix_object_args⁄library_filename⁄
_need_linkrz   rX   r   r   r
   r|   )	r)   r   Zoutput_libnamers   r|   ⁄target_lang⁄output_filenameZlib_argsrÇ   r   r   r   ⁄create_static_lib©  s    		"zMSVCCompiler.create_static_libc             C   sÑ  |  j  s |  j É  n  |  j | | É \ } } |  j | | | É } | \ } } } | rr |  j d t | É É n  t |  | | | É } | d  k	 r´ t j j	 | | É } n  |  j
 | | É rp| t j k r˛ |	 rË |  j d d  Ö } q|  j d d  Ö } n |	 r|  j } n	 |  j } g  } x% | p+g  D] } | j d | É q,W| | | | d | g } | d  k	 r÷t j j t j j | É É \ } } t j j	 t j j | d É |  j | É É } | j d | É n  |
 rÔ|
 | d  d Ö <n  | r| j | É n  |  j t j j | É É y |  j |  j g | É WqÄt k
 rl} z t | É Ç WYd  d  } ~ XqÄXn t j d | É d  S)Nz5I don't know what to do with 'runtime_library_dirs': r   z/EXPORT:z/OUT:r   z/IMPLIB:zskipping %s (up-to-date))rV   rh   rÖ   Z_fix_lib_args⁄warn⁄strr	   rL   r-   rc   rá   r   Z
EXECUTABLErg   rf   r   rj   rn   r{   rÜ   rv   Zmkpathrz   r^   r   r   r
   r|   )r)   Ztarget_descr   râ   rs   Z	librariesZlibrary_dirsZruntime_library_dirsZexport_symbolsr|   r}   r~   Z
build_temprà   Z
fixed_argsZlib_optsZldflagsZexport_optsZsymZld_argsZdll_nameZdll_extZimplib_filerÇ   r   r   r   ⁄link¬  sV    							"zMSVCCompiler.linkc             C   s   d | S)Nz	/LIBPATH:r   )r)   ⁄dirr   r   r   ⁄library_dir_option  s    zMSVCCompiler.library_dir_optionc             C   s   t  d É Ç d  S)Nz<don't know how to set runtime library search path for MSVC++)r   )r)   ré   r   r   r   ⁄runtime_library_dir_option  s    z'MSVCCompiler.runtime_library_dir_optionc             C   s   |  j  | É S)N)rÜ   )r)   rX   r   r   r   ⁄library_option  s    zMSVCCompiler.library_optionc             C   sÄ   | r | d | g } n	 | g } xW | D]K } xB | D]: } t  j j | |  j | É É } t  j j | É r6 | Sq6 Wq) Wd  Sd  S)NZ_d)rL   r-   rc   rÜ   ⁄exists)r)   ⁄dirsrX   r|   Z	try_namesré   r   Zlibfiler   r   r   ⁄find_library_file   s    	zMSVCCompiler.find_library_filec             C   sß   xH |  j  D]= } t j j t j j | É | É } t j j | É r
 | Sq
 WxU t j d j d É D]= } t j j t j j | É | É } t j j | É rb | Sqb W| S)aå  Return path to an MSVC executable program.

        Tries to find the program in several places: first, one of the
        MSVC program search paths from the registry; next, the directories
        in the PATH environment variable.  If any of those work, return an
        absolute path that is known to exist.  If none of them work, just
        return the original program name, 'exe'.
        ZPathrY   )rZ   rL   r-   rc   rw   ⁄isfiler[   rC   )r)   Zexer1   ⁄fnr   r   r   r\   2  s    	!!zMSVCCompiler.find_exeZx86c             C   s	  t  s
 g  S| d } |  j d k r< d |  j |  j f } n d |  j | f } xc t D][ } t | | É } | rV |  j d k rù |  j j | | É j d É S| | j d É SqV qV W|  j d k rx> t D]3 } t | d |  j É d k	 rÀ |  j d	 É PqÀ qÀ Wn  g  S)
z–Get a list of devstudio directories (include, lib or path).

        Return a list of strings.  The list will be empty if unable to
        access the registry or appropriate registry keys not found.
        z dirsrP   z6%s\%0.1f\VC\VC_OBJECTS_PLATFORM_INFO\Win32\Directoriesz?%s\6.0\Build System\Components\Platforms\Win32 (%s)\DirectoriesrY   r:   z%s\6.0Nz¥It seems you have Visual Studio 6 installed, but the expected registry settings are not present.
You must at least run the Visual Studio GUI once so that these entries are created.)	⁄_can_read_regrQ   rS   r,   r    rT   r6   rC   rã   )r)   r-   ⁄platformr   r   r   r   r   r   ra   H  s(    
zMSVCCompiler.get_msvc_pathsc             C   sP   | d k r |  j  d É } n |  j  | É } | rL d j | É t j | <n  d S)z°Set environment variable 'name' to an MSVC path type value.

        This is equivalent to a SET command prior to execution of spawned
        commands.
        rX   ZlibraryrY   N)ra   rc   rL   r[   )r)   r   r1   r   r   r   rb   l  s
    zMSVCCompiler.set_path_env_var)r7   r8   r9   ⁄__doc__Zcompiler_typeZexecutablesrx   ry   ro   rq   rm   rp   rr   Zstatic_lib_extensionZshared_lib_extensionZstatic_lib_formatZshared_lib_formatZexe_extensionr+   rh   ru   rÑ   rä   rç   rè   rê   rë   rî   r\   ra   rb   r   r   r   r   rO   ≈   sP   			
BVF$rO   g       @z3Importing new compiler from distutils.msvc9compiler)rO   )r&   ).rô   r@   rL   Zdistutils.errorsr   r   r   r   r   Zdistutils.ccompilerr   r   r	   Z	distutilsr
   ró   ⁄winregZhkey_modZ	OpenKeyExr   ZEnumKeyr   Z	EnumValuer   ⁄errorr   ⁄ImportErrorZwin32apiZwin32con⁄infoZ
HKEY_USERS⁄HKEY_CURRENT_USER⁄HKEY_LOCAL_MACHINEZHKEY_CLASSES_ROOTr,   r   r    r   r&   rG   rK   rN   rO   r|   ZOldMSVCCompilerZdistutils.msvc9compilerr   r   r   r   ⁄<module>   sZ   (						
	-ˇ ∑                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/distutils/__pycache__/spawn.cpython-34.pyc                                        0100644 0000000 0000000 00000012540 13077704335 022415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TZ  „               @   s‡   d  Z  d d l Z d d l Z d d l m Z m Z d d l m Z d d l m	 Z	 d d d d d Ñ Z
 d	 d
 Ñ  Z d d d d d Ñ Z e j d k r∏ d d l m Z d a d a n  d d d d d Ñ Z d d d Ñ Z d S)zÏdistutils.spawn

Provides the 'spawn()' function, a front-end to various platform-
specific functions for launching another program in a sub-process.
Also provides the 'find_executable()' to search the path for a given
executable name.
È    N)⁄DistutilsPlatformError⁄DistutilsExecError)⁄DEBUG)⁄logÈ   c             C   sm   t  |  É }  t j d k r1 t |  | d | Én8 t j d k rV t |  | d | Én t d t j É Ç d S)aè  Run another program, specified as a command list 'cmd', in a new process.

    'cmd' is just the argument list for the new process, ie.
    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.
    There is no way to run a program with a name different from that of its
    executable.

    If 'search_path' is true (the default), the system's executable
    search path will be used to find the program; otherwise, cmd[0]
    must be the exact path to the executable.  If 'dry_run' is true,
    the command will not actually be run.

    Raise DistutilsExecError if running the program fails in any way; just
    return on success.
    ⁄posix⁄dry_run⁄ntz1don't know how to spawn programs on platform '%s'N)⁄list⁄os⁄name⁄_spawn_posix⁄	_spawn_ntr   )⁄cmd⁄search_path⁄verboser   © r   ˙%/usr/lib/python3.4/distutils/spawn.py⁄spawn   s    r   c             C   s>   x7 t  |  É D]) \ } } d | k r d | |  | <q q W|  S)z™Quote command-line arguments for DOS/Windows conventions.

    Just wraps every argument which contains blanks in double quotes, and
    returns a new argument list.
    ˙ z"%s")⁄	enumerate)⁄args⁄i⁄argr   r   r   ⁄_nt_quote_args+   s    r   c             C   s	  |  d } t  |  É }  | r1 t | É p+ | } n  t j d j | g |  d d  Ö É É | sy t j t j | |  É } WnQ t k
 rÕ } z1 t	 sû | }  n  t
 d |  | j d f É Ç WYd  d  } ~ Xn X| d k rt	 sÈ | }  n  t
 d |  | f É Ç qn  d  S)Nr   r   r   zcommand %r failed: %sz%command %r failed with exit status %dÈˇˇˇˇ)r   ⁄find_executabler   ⁄info⁄joinr   ⁄spawnv⁄P_WAIT⁄OSErrorr   r   r   )r   r   r   r   ⁄
executableZrc⁄excr   r   r   r   ;   s$    
'	-	r   ⁄darwin)⁄	sysconfigc             C   sy  t  j d j |  É É | r  d  S|  d } | r9 t j p? t j } d  } t j d k r/t d  k r† t	 j
 d É pu d a t r† d d Ñ  t j d É DÉ a q† n  t r/t j j d t É } t d	 d Ñ  | j d É DÉ k r¸ d
 | t f } t | É Ç n  t t j d | É} | r t j p&t j } q/n  t j É  }	 |	 d k ry0 | d  k rf| | |  É n | | |  | É Wn^ t k
 r◊}
 z> t sõ| }  n  t j j d |  |
 j f É t j d É WYd  d  }
 ~
 Xn Xt sÁ| }  n  t j j d |  É t j d É njxgy t j |	 d É \ }	 } Wnu t k
 r°} zU d d  l } | j | j k rcwn  t sr| }  n  t d |  | j d f É Ç WYd  d  } ~ Xn Xt j | É r‚t s¿| }  n  t d |  t j  | É f É Ç qt j! | É r8t j" | É } | d k rd  St s| }  n  t d |  | f É Ç qt j# | É rMqqt s\| }  n  t d |  | f É Ç qd  S)Nr   r   r$   ZMACOSX_DEPLOYMENT_TARGET⁄ c             S   s   g  |  ] } t  | É ë q Sr   )⁄int)⁄.0⁄xr   r   r   ˙
<listcomp>e   s   	 z _spawn_posix.<locals>.<listcomp>⁄.c             S   s   g  |  ] } t  | É ë q Sr   )r'   )r(   r)   r   r   r   r*   k   s   	 zF$MACOSX_DEPLOYMENT_TARGET mismatch: now "%s" but "%s" during configurezunable to execute %r: %s
r   z(unable to execute %r for unknown reasonszcommand %r failed: %sz"command %r terminated by signal %dz%command %r failed with exit status %dz1unknown error executing %r: termination status %dr   )$r   r   r   r   ⁄execvp⁄execv⁄sys⁄platform⁄_cfg_targetr%   Zget_config_var⁄split⁄_cfg_target_split⁄environ⁄getr   ⁄dict⁄execvpe⁄execve⁄forkr!   r   ⁄stderr⁄write⁄strerror⁄_exit⁄waitpid⁄errnoZEINTRr   r   ⁄WIFSIGNALED⁄WTERMSIG⁄	WIFEXITED⁄WEXITSTATUS⁄
WIFSTOPPED)r   r   r   r   r"   Zexec_fn⁄envZ
cur_targetZmy_msg⁄pid⁄eZstatusr#   r>   Zexit_statusr   r   r   r   X   så    
""		 		-			r   c             C   s»   | d k r t  j d } n  | j t  j É } t  j j |  É \ } } t j d k rn | d k rn |  d }  n  t  j j |  É s¿ x9 | D]1 } t  j j	 | |  É } t  j j | É rá | Sqá Wd S|  Sd S)z⁄Tries to find 'executable' in the directories listed in 'path'.

    A string listing directories separated by 'os.pathsep'; defaults to
    os.environ['PATH'].  Returns the complete filename or None if not found.
    N⁄PATHZwin32z.exe)
r   r3   r1   ⁄pathsep⁄path⁄splitextr.   r/   ⁄isfiler   )r"   rI   Zpaths⁄baseZext⁄p⁄fr   r   r   r   ¨   s    r   )⁄__doc__r.   r   Zdistutils.errorsr   r   Zdistutils.debugr   Z	distutilsr   r   r   r   r/   r%   r0   r2   r   r   r   r   r   r   ⁄<module>   s   	T                                                                                                                                                                usr/lib/python3.4/distutils/__pycache__/sysconfig.cpython-34.pyc                                    0100644 0000000 0000000 00000032651 13077704335 023276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T‰S  „               @   sö  d  Z  d d l Z d d l Z d d l Z d d l m Z e j j e j É Z	 e j j e j
 É Z e j j e j É Z e j j e j É Z d e j k rπ e j j e j d É Z n! e j j e j j e j É É Z e j d k r/d e d1 d Ö j É  k r/e j j e j j e e j j É É Z n  e j d k rçd	 e d2 d Ö j É  k rçe j j e j j e e j j e j j É É Z n  e j d k rÎd e d3 d Ö j É  k rÎe j j e j j e e j j e j j É É Z n  d d Ñ  Z e e d d É Z e rle j d k rle j É  j d4 É rle j j e É Z e j d É rle j j e É Z qln  d d Ñ  Z e É  Z d Z y e súe j  Z n  Wn e! k
 r±Yn Xd d Ñ  Z" d d d d Ñ Z# d d d d d Ñ Z$ d d Ñ  Z% d d Ñ  Z& d d Ñ  Z' d d  d! Ñ Z( e j) d" É Z* e j) d# É Z+ e j) d$ É Z, d d% d& Ñ Z- d' d( Ñ  Z. d a/ d) d* Ñ  Z0 d+ d, Ñ  Z1 d- d. Ñ  Z2 d/ d0 Ñ  Z3 d S)5aç  Provide access to Python's configuration information.  The specific
configuration variables available depend heavily on the platform and
configuration.  The values may be retrieved using
get_config_var(name), and the list of variables is available via
get_config_vars().keys().  Additional convenience functions are also
available.

Written by:   Fred L. Drake, Jr.
Email:        <fdrake@acm.org>
È    NÈ   )⁄DistutilsPlatformErrorZ_PYTHON_PROJECT_BASE⁄nt⁄pcbuildÈ   z\pc\vÈ
   z\pcbuild\amd64È   c             C   s=   x6 d D]. } t  j j t  j j |  d | É É r d Sq Wd S)N˙
Setup.dist˙Setup.localZModulesTF)r	   r
   )⁄os⁄path⁄isfile⁄join)⁄d⁄fn© r   ˙)/usr/lib/python3.4/distutils/sysconfig.py⁄_is_python_source_dir0   s    $r   Z_home˙pcbuild\amd64c               C   s   t  r t t  É St t É S)N)⁄	_sys_homer   ⁄project_baser   r   r   r   ⁄_python_build;   s    
r   ⁄ c               C   s   t  j d d Ö S)zñReturn a string containing the major and minor Python version,
    leaving off the patchlevel.  Sample return values could be '1.5'
    or '2.2'.
    NÈ   )⁄sys⁄versionr   r   r   r   ⁄get_python_versionM   s    r   c             C   s!  | d k r! |  r t  p t } n  t j d k rË t rõ t p? t } |  rL | St rp t j j t t	 d É É } n t j j t	 d É d É } t j j
 | É Sd t É  t } t r“ |  r“ d d l } | j d É St j j | d	 | É St j d
 k r
t j j | d	 É St d t j É Ç d S)a§  Return the directory containing installed Python header files.

    If 'plat_specific' is false (the default), this is the path to the
    non-platform-specific header files, i.e. Python.h and so on;
    otherwise, this is the path to platform-specific header files
    (namely pyconfig.h).

    If 'prefix' is supplied, use it instead of sys.base_prefix or
    sys.base_exec_prefix -- i.e., ignore 'plat_specific'.
    N⁄posixZ	AST_H_DIR⁄srcdirZInclude⁄pythonr   ZplatincludeZincluder   zFI don't know where Python installs its C header files on platform '%s')⁄BASE_EXEC_PREFIX⁄BASE_PREFIXr   ⁄name⁄python_buildr   r   r   r   ⁄get_config_var⁄normpathr   ⁄build_flags⁄	sysconfigZget_pathr   )⁄plat_specific⁄prefix⁄baseZincdirZ
python_dirr'   r   r   r   ⁄get_python_incU   s*    r+   c             C   s_  | p t  j j | É d k } | d k r[ | rF |  r= t p@ t } q[ |  rR t pU t } n  t  j d k rt  j j | d d t	 É  É } | rì | S| rÒ d t  j
 k rÒ d t  j
 k rÒ d	 t j k rÒ t j t j k rÒ t  j j | d d
 d É St  j j | d É SnT t  j d k rH| r/t  j j | d É St  j j | d d É Sn t d t  j É Ç d S)aS  Return the directory containing the Python library (standard or
    site additions).

    If 'plat_specific' is true, return the directory containing
    platform-specific modules, i.e. any module from a non-pure-Python
    module distribution; otherwise, return the platform-shared library
    directory.  If 'standard_lib' is true, return the directory
    containing standard Python library modules; otherwise, return the
    directory for site-specific modules.

    If 'prefix' is supplied, use it instead of sys.base_prefix or
    sys.base_exec_prefix -- i.e., ignore 'plat_specific'.
    ˙/usr˙
/usr/localNr   Zlibr   ZPYTHONUSERBASEZVIRTUAL_ENVZreal_prefixZpython3zdist-packageszsite-packagesr   ZLibz?I don't know where Python installs its library on platform '%s')r,   r-   )r   r   r%   r    r!   ⁄EXEC_PREFIX⁄PREFIXr"   r   r   ⁄environr   ⁄__dict__r)   ⁄base_prefixr   )r(   ⁄standard_libr)   Zis_default_prefixZ	libpythonr   r   r   ⁄get_python_lib~   s0    r4   c             C   sK  |  j  d k rGt j d k rS t d É sS d d l } | j t É d t d <qS n  t d d d	 d
 d d d d d d d d É \ } } } } } } } }	 }
 } } } d t j	 k rt j	 d } t j d k r
d t j	 k r
| j
 | É r
| | t | É d Ö } n  | } n  d t j	 k r2t j	 d } n  d t j	 k rQt j	 d } n  d t j	 k rpt j	 d } n
 | d } d t j	 k r°| d t j	 d } n | r∏| d | } n  d
 t j	 k rÙ| d t j	 d
 } | d t j	 d
 } n% | r| d | } | d | } n  d t j	 k rj| d t j	 d } | d t j	 d } | d t j	 d } n3 | rù| d | } | d | } | d | } n  d t j	 k rºt j	 d }	 n  d t j	 k r„|	 d t j	 d } n |	 d |
 } | d | } |  j d | d | d | d | d | d | d | d | É | |  _ n  d S)zƒDo any platform-specific customization of a CCompiler instance.

    Mainly needed on Unix, so we can plug in the information that
    varies across Unices and is stored in Python's Makefile.
    Zunix⁄darwinZCUSTOMIZED_OSX_COMPILERr   N⁄TrueZCCZCXXZOPT⁄CFLAGSZCCSHAREDZLDSHAREDZSHLIB_SUFFIXZARZARFLAGSZCONFIGURE_CPPFLAGSZCONFIGURE_CFLAGSZCONFIGURE_LDFLAGSZCPPz -E⁄LDFLAGS˙ ⁄CPPFLAGSZpreprocessor⁄compilerZcompiler_soZcompiler_cxxZ	linker_soZ
linker_exe⁄archiver)Zcompiler_typer   ⁄platformr$   ⁄_osx_support⁄customize_compiler⁄_config_vars⁄get_config_varsr   r0   ⁄
startswith⁄lenZset_executablesZshared_lib_extension)r;   r>   ZccZcxxZoptZcflagsZccsharedZldsharedZshlib_suffixZarZar_flagsZconfigure_cppflagsZconfigure_cflagsZconfigure_ldflagsZnewccZcppr<   Zcc_cmdr   r   r   r?   ¨   sp    3	
	r?   c              C   sd   t  rB t j d k r3 t j j t p' t d É }  qQ t p< t }  n t d d É }  t j j |  d É S)z2Return full pathname of installed pyconfig.h file.r   ZPCr(   r   z
pyconfig.h)r#   r   r"   r   r   r   r   r+   )Zinc_dirr   r   r   ⁄get_config_h_filename   s    rD   c              C   sà   t  r t j j t p t d É St d d d d É }  d j t É  t	 É } t
 t j d É rr | d t j j 7} n  t j j |  | d É S)	zAReturn full pathname of installed Makefile from the Python build.ZMakefiler(   r   r3   r   zconfig-{}{}⁄
_multiarchz-%s)r#   r   r   r   r   r   r4   ⁄formatr   r&   ⁄hasattrr   ⁄implementationrE   )Zlib_dirZconfig_filer   r   r   ⁄get_makefile_filename  s    rI   c             C   s›   | d k r i  } n  t  j d É } t  j d É } x£ |  j É  } | sL Pn  | j | É } | r´ | j d d É \ } } y t | É } Wn t k
 rù Yn X| | | <q6 | j | É } | r6 d | | j d É <q6 q6 | S)zÃParse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    Nz"#define ([A-Z][A-Za-z0-9_]+) (.*)
z&/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/
r   È   r   )⁄re⁄compile⁄readline⁄match⁄group⁄int⁄
ValueError)⁄fp⁄gZ	define_rxZundef_rx⁄line⁄m⁄n⁄vr   r   r   ⁄parse_config_h  s(    	  rX   z"([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)z\$\(([A-Za-z][A-Za-z0-9_]*)\)z\${([A-Za-z][A-Za-z0-9_]*)}c             C   s¨  d d l  m } | |  d d d d d d d d É} | d	 k rI i  } n  i  } i  } xÀ | j É  } | d	 k rt Pn  t j | É } | rX | j d d
 É \ } }	 |	 j É  }	 |	 j d d É }
 d |
 k rÿ |	 | | <q y t |	 É }	 Wn( t	 k
 r|	 j d d É | | <Yq X|	 | | <qX qX d } x&| rQxt
 | É D]} | | } t j | É pjt j | É } | rC| j d É } d } | | k rßt | | É } n¨ | | k rºd } nó | t j k r€t j | } nx | | k rE| j d É r| d d	 Ö | k rd } qSd | | k r.d } qSt | d | É } n d | | <} | rJ| | j É  d	 Ö } | d	 | j É  Ö | | } d | k r¶| | | <q@y t | É } Wn" t	 k
 r⁄| j É  | | <Yn X| | | <| | =| j d É r@| d d	 Ö | k r@| d d	 Ö } | | k r=| | | <q=q@qJq?| | =q?Wq,W| j É  x< | j É  D]. \ } }	 t |	 t É ri|	 j É  | | <qiqiW| j | É | S)zÃParse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    r   )⁄TextFileZstrip_commentsr   Zskip_blanksZ
join_lines⁄errors⁄surrogateescapeNrJ   z$$r   ˙$r7   r8   r:   TFZPY_r   )zCFLAGSzLDFLAGSzCPPFLAGS)Zdistutils.text_filerY   rM   ⁄_variable_rxrN   rO   ⁄strip⁄replacerP   rQ   ⁄list⁄_findvar1_rx⁄search⁄_findvar2_rx⁄strr   r0   rB   ⁄end⁄start⁄close⁄items⁄
isinstance⁄update)r   rS   rY   rR   ZdoneZnotdonerT   rU   rV   rW   ZtmpvZrenamed_variablesr"   ⁄value⁄found⁄itemZafter⁄kr   r   r   ⁄parse_makefile;  sÑ    $		
	%		 

ro   c             C   sx   xq t  j |  É p t j |  É } | rp | j É  \ } } |  d | Ö | j | j d É É |  | d Ö }  q Pq |  S)a®  Expand Makefile-style variables -- "${foo}" or "$(foo)" -- in
    'string' according to 'vars' (a dictionary mapping variable names to
    values).  Variables not present in 'vars' are silently expanded to the
    empty string.  The variable values in 'vars' should not contain further
    variable expansions; if 'vars' is the output of 'parse_makefile()',
    you're fine.  Returns a variable-expanded version of 's'.
    r   r   N)ra   rb   rc   ⁄span⁄getrO   )⁄s⁄varsrU   Zbegre   r   r   r   ⁄expand_makefile_vars•  s    7rt   c              C   s'   d d l  m }  i  a t j |  É d S)z7Initialize the module as appropriate for POSIX systems.r   )⁄build_time_varsN)Z_sysconfigdataru   r@   rj   )ru   r   r   r   ⁄_init_posix¿  s    rv   c              C   sß   i  }  t  d d d d É |  d <t  d d d d É |  d <t d d É |  d <d |  d	 <d
 |  d <t É  j d d É |  d <t j j t j j t j	 É É |  d <|  a
 d S)z+Initialize the module as appropriate for NTr(   r   r3   r   ZLIBDESTZ
BINLIBDESTZ	INCLUDEPYz.pyd⁄
EXT_SUFFIXz.exeZEXE⁄.r   ZVERSIONZBINDIRN)r4   r+   r   r_   r   r   ⁄dirname⁄abspathr   ⁄
executabler@   )rS   r   r   r   ⁄_init_nt…  s    

%r|   c              G   sÎ  t  d k r¨t É  j d t j É } | r5 | É  n i  a  t t  d <t t  d <t  j d É } | d k	 rw | t  d <n  t  j d t É } t j d k r„ t rÀ t j	 j
 t É  É } t j	 j | | É } q„ t j	 j
 t É  É } n  t j	 j t j	 j | É É t  d <t r~t j d k r~t } t j	 j t  d É r~| t j É  k r~t j	 j | t  d É } t j	 j | É t  d <q~n  t j d	 k r¨d
 d l } | j t  É q¨n  |  r„g  } x$ |  D] } | j t  j | É É qøW| St  Sd S)aﬂ  With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.  Generally this includes
    everything needed to build extensions and install both pure modules and
    extensions.  On Unix, this means every variable defined in Python's
    installed Makefile; on Windows it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    NZ_init_r)   ⁄exec_prefixrw   ⁄SOr   r   r5   r   )r@   ⁄globalsrq   r   r"   r/   r.   r   r#   r   ry   rI   r   rz   r%   ⁄isabs⁄getcwdr   r=   r>   Zcustomize_config_vars⁄append)⁄args⁄funcr~   r   r*   r>   Zvalsr"   r   r   r   rA   ‹  s@    


"rA   c             C   s>   |  d k r. d d l  } | j d t d É n  t É  j |  É S)zìReturn the value of a single variable using the dictionary
    returned by 'get_config_vars()'.  Equivalent to
    get_config_vars().get(name)
    r~   r   Nz SO is deprecated, use EXT_SUFFIXrJ   )⁄warnings⁄warn⁄DeprecationWarningrA   rq   )r"   rÖ   r   r   r   r$   &  s    r$   i¯ˇˇˇiˆˇˇˇiÚˇˇˇ)r   r   )4⁄__doc__r   rK   r   rZ   r   r   r%   r)   r/   r}   r.   r2   r!   ⁄base_exec_prefixr    r0   rz   r   ry   r{   r"   ⁄lowerr   ⁄pardirr   ⁄getattrr   ⁄endswithr   r#   r&   ⁄abiflags⁄AttributeErrorr   r+   r4   r?   rD   rI   rX   rL   r]   ra   rc   ro   rt   r@   rv   r|   rA   r$   r   r   r   r   ⁄<module>
   sf   !+*++	).Tj	J                                                                                       usr/lib/python3.4/distutils/__pycache__/text_file.cpython-34.pyc                                    0100644 0000000 0000000 00000021311 13077704335 023244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T≥0  „               @   sA   d  Z  d d l Z d d l Z d d l Z Gd d Ñ  d É Z d S)zºtext_file

provides the TextFile class, which gives an interface to text files
that (optionally) takes care of stripping comments, ignoring blank
lines, and joining lines with backslashes.È    Nc               @   s»   e  Z d  Z d Z i d d 6d d 6d d 6d d 6d d 6d d	 6d
 d 6Z d d d d Ñ Z d d Ñ  Z d d Ñ  Z d d d Ñ Z d d d Ñ Z	 d d d Ñ Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)⁄TextFilea˚  Provides a file-like object that takes care of all the things you
       commonly want to do when processing a text file that has some
       line-by-line syntax: strip comments (as long as "#" is your
       comment character), skip blank lines, join adjacent lines by
       escaping the newline (ie. backslash at end of line), strip
       leading and/or trailing whitespace.  All of these are optional
       and independently controllable.

       Provides a 'warn()' method so you can generate warning messages that
       report physical line number, even if the logical line in question
       spans multiple physical lines.  Also provides 'unreadline()' for
       implementing line-at-a-time lookahead.

       Constructor is called as:

           TextFile (filename=None, file=None, **options)

       It bombs (RuntimeError) if both 'filename' and 'file' are None;
       'filename' should be a string, and 'file' a file object (or
       something that provides 'readline()' and 'close()' methods).  It is
       recommended that you supply at least 'filename', so that TextFile
       can include it in warning messages.  If 'file' is not supplied,
       TextFile creates its own using 'io.open()'.

       The options are all boolean, and affect the value returned by
       'readline()':
         strip_comments [default: true]
           strip from "#" to end-of-line, as well as any whitespace
           leading up to the "#" -- unless it is escaped by a backslash
         lstrip_ws [default: false]
           strip leading whitespace from each line before returning it
         rstrip_ws [default: true]
           strip trailing whitespace (including line terminator!) from
           each line before returning it
         skip_blanks [default: true}
           skip lines that are empty *after* stripping comments and
           whitespace.  (If both lstrip_ws and rstrip_ws are false,
           then some lines may consist of solely whitespace: these will
           *not* be skipped, even if 'skip_blanks' is true.)
         join_lines [default: false]
           if a backslash is the last non-newline character on a line
           after stripping comments and whitespace, join the following line
           to it to form one "logical line"; if N consecutive lines end
           with a backslash, then N+1 physical lines will be joined to
           form one logical line.
         collapse_join [default: false]
           strip leading whitespace from lines that are joined to their
           predecessor; only matters if (join_lines and not lstrip_ws)
         errors [default: 'strict']
           error handler used to decode the file content

       Note that since 'rstrip_ws' can strip the trailing newline, the
       semantics of 'readline()' must differ from those of the builtin file
       object's 'readline()' method!  In particular, 'readline()' returns
       None for end-of-file: an empty string might just be a blank line (or
       an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is
       not.È   ⁄strip_comments⁄skip_blanksr   ⁄	lstrip_ws⁄	rstrip_ws⁄
join_lines⁄collapse_join⁄strict⁄errorsNc             K   s¯   | d k r' | d k r' t  d É Ç n  xQ |  j j É  D]@ } | | k r` t |  | | | É q7 t |  | |  j | É q7 Wx6 | j É  D]( } | |  j k rà t d | É Ç qà qà W| d k r– |  j | É n | |  _ | |  _ d |  _ g  |  _	 d S)z¸Construct a new TextFile object.  At least one of 'filename'
           (a string) and 'file' (a file-like object) must be supplied.
           They keyword argument options are described above and affect
           the values returned by 'readline()'.Nz7you must supply either or both of 'filename' and 'file'zinvalid TextFile option '%s'r   )
⁄RuntimeError⁄default_options⁄keys⁄setattr⁄KeyError⁄open⁄filename⁄file⁄current_line⁄linebuf)⁄selfr   r   ZoptionsZopt© r   ˙)/usr/lib/python3.4/distutils/text_file.py⁄__init__N   s    			zTextFile.__init__c             C   s7   | |  _  t j |  j  d d |  j É|  _ d |  _ d S)zyOpen a new file named 'filename'.  This overrides both the
           'filename' and 'file' arguments to the constructor.⁄rr   r   N)r   ⁄ior   r   r   r   )r   r   r   r   r   r   o   s    	!zTextFile.openc             C   s,   |  j  j É  d |  _  d |  _ d |  _ d S)ziClose the current file and forget everything we know about it
           (filename, current line number).N)r   ⁄closer   r   )r   r   r   r   r   v   s    		zTextFile.closec             C   sí   g  } | d  k r |  j  } n  | j |  j d É t | t t f É ra | j d t | É É n | j d | É | j t | É É d j | É S)Nz, zlines %d-%d: z	line %d: ⁄ )r   ⁄appendr   ⁄
isinstance⁄list⁄tuple⁄str⁄join)r   ⁄msg⁄lineZoutmsgr   r   r   ⁄	gen_error~   s    zTextFile.gen_errorc             C   s    t  d |  j | | É É Ç d  S)Nzerror: )⁄
ValueErrorr&   )r   r$   r%   r   r   r   ⁄errorä   s    zTextFile.errorc             C   s(   t  j j d |  j | | É d É d S)a¡  Print (to stderr) a warning message tied to the current logical
           line in the current file.  If the current logical line in the
           file spans multiple physical lines, the warning refers to the
           whole range, eg. "lines 3-5".  If 'line' supplied, it overrides
           the current line number; it may be a list or tuple to indicate a
           range of physical lines, or an integer for a single physical
           line.z	warning: ⁄
N)⁄sys⁄stderr⁄writer&   )r   r$   r%   r   r   r   ⁄warnç   s    zTextFile.warnc             C   s¿  |  j  r$ |  j  d } |  j  d =| Sd } xè|  j j É  } | d k rQ d } n  |  j r˛ | r˛ | j d É } | d k r~ q˛ | d k sû | | d d k rÈ | d d k r¥ d p∑ d } | d | Ö | } | j É  d k r˚ q- q˚ q˛ | j d d É } n  |  j rï| rï| d k r*|  j d	 É | S|  j	 rB| j
 É  } n  | | } t |  j t É ry|  j d d |  j d <qﬁ|  j |  j d g |  _ nI | d k r•d St |  j t É rŒ|  j d d |  _ n |  j d |  _ |  j rˇ|  j rˇ| j É  } n0 |  j r| j
 É  } n |  j r/| j É  } n  | d k sG| d k rV|  j rVq- n  |  j r∏| d d k rÖ| d d Ö } q- n  | d d Ö d k r∏| d d Ö d } q- q∏n  | Sd S)aU  Read and return a single logical line from the current file (or
           from an internal buffer if lines have previously been "unread"
           with 'unreadline()').  If the 'join_lines' option is true, this
           may involve reading multiple physical lines concatenated into a
           single string.  Updates the current line number, so calling
           'warn()' after 'readline()' emits a warning about the physical
           line(s) just read.  Returns None on end-of-file, since the empty
           string can occur if 'rstrip_ws' is true but 'strip_blanks' is
           not.r   r   N˙#r   ˙\r)   z\#z2continuation line immediately precedes end-of-fileÈ   z\
Èˇˇˇˇr1   r1   r1   r1   r1   È˛ˇˇˇr2   )r   r   ⁄readliner   ⁄find⁄strip⁄replacer   r-   r	   ⁄lstripr   r   r    r   r   ⁄rstripr   )r   r%   Zbuildup_line⁄posZeolr   r   r   r3   ó   sf    	
	
 			
		!		zTextFile.readlinec             C   s9   g  } x, |  j  É  } | d k r% | S| j | É q	 d S)zWRead and return the list of all logical lines remaining in the
           current file.N)r3   r   )r   ⁄linesr%   r   r   r   ⁄	readlines  s    zTextFile.readlinesc             C   s   |  j  j | É d S)z∑Push 'line' (a string) onto an internal buffer that will be
           checked by future 'readline()' calls.  Handy for implementing
           a parser with line-at-a-time lookahead.N)r   r   )r   r%   r   r   r   ⁄
unreadline  s    zTextFile.unreadline)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r   r   r   r&   r(   r-   r3   r;   r<   r   r   r   r   r   
   s"   9

!
x
r   )r@   r*   ⁄osr   r   r   r   r   r   ⁄<module>   s   $                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/distutils/__pycache__/unixccompiler.cpython-34.pyc                                0100644 0000000 0000000 00000016577 13077704335 024164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T~5  „               @   s–   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 m
 Z
 m Z d d l m Z m Z m Z m Z d d l m Z e j d k r∂ d d l Z n  Gd	 d
 Ñ  d
 e	 É Z d S)a9  distutils.unixccompiler

Contains the UnixCCompiler class, a subclass of CCompiler that handles
the "typical" Unix-style command-line C compiler:
  * macros defined with -Dname[=value]
  * macros undefined with -Uname
  * include search directories specified with -Idir
  * libraries specified with -lllib
  * library search directories specified with -Ldir
  * compile handled by 'cc' (or similar) executable with -c option:
    compiles .c to .o
  * link static library handled by 'ar' command (possibly with 'ranlib')
  * link shared library handled by 'cc -shared'
È    N)⁄	sysconfig)⁄newer)⁄	CCompiler⁄gen_preprocess_options⁄gen_lib_options)⁄DistutilsExecError⁄CompileError⁄LibError⁄	LinkError)⁄log⁄darwinc               @   sê  e  Z d  Z d Z i d d 6d g d 6d g d 6d g d 6d d g d	 6d g d
 6d d g d 6d d 6Z e j d d Ö d k rë d g e d <n  d d d d d d g Z d Z d Z	 d Z
 d Z d Z Z Z e j d k rÁ d Z n  d d d d d d d Ñ Z d  d! Ñ  Z d d" d d# d$ Ñ Z d d d d d d" d d d d d% d& Ñ
 Z d' d( Ñ  Z d) d* Ñ  Z d+ d, Ñ  Z d- d. Ñ  Z d" d/ d0 Ñ Z d S)1⁄UnixCCompilerZunixN⁄preprocessorZcc⁄compiler⁄compiler_so⁄compiler_cxxz-shared⁄	linker_so⁄
linker_exeZarz-cr⁄archiver⁄ranlibÈ   r   z.cz.Cz.ccz.cxxz.cppz.mz.oz.az.soz.dylibzlib%s%s⁄cygwinz.exec             C   s*  |  j  d  | | É } | \ } } } t | | É }	 |  j |	 }
 | r\ |
 j d | g É n  | ru | |
 d  d Ö <n  | rã |
 j | É n  |
 j | É |  j sº | d  k sº t | | É r&| rﬁ |  j t j	 j
 | É É n  y |  j |
 É Wq&t k
 r"} z t | É Ç WYd  d  } ~ Xq&Xn  d  S)Nz-or   )Z_fix_compile_argsr   r   ⁄extend⁄appendZforcer   ⁄mkpath⁄os⁄path⁄dirname⁄spawnr   r   )⁄self⁄sourceZoutput_fileZmacrosZinclude_dirs⁄extra_preargs⁄extra_postargs⁄
fixed_args⁄ignore⁄pp_optsZpp_args⁄msg© r'   ˙-/usr/lib/python3.4/distutils/unixccompiler.py⁄
preprocessS   s$    $zUnixCCompiler.preprocessc       	      C   sè   |  j  } t j d k r1 t j | | | É } n  y& |  j | | | d | g | É Wn1 t k
 rä } z t | É Ç WYd  d  } ~ Xn Xd  S)Nr   z-o)r   ⁄sys⁄platform⁄_osx_support⁄compiler_fixupr   r   r   )	r   ⁄obj⁄srcZextZcc_argsr"   r%   r   r&   r'   r'   r(   ⁄_compilem   s    		zUnixCCompiler._compiler   c             C   sÏ   |  j  | | É \ } } |  j | d | É} |  j | | É rÿ |  j t j j | É É |  j |  j | g | |  j	 É |  j
 rË y |  j |  j
 | g É Wq’ t k
 r— } z t | É Ç WYd  d  } ~ Xq’ XqË n t j d | É d  S)N⁄
output_dirzskipping %s (up-to-date))⁄_fix_object_args⁄library_filename⁄
_need_linkr   r   r   r   r   r   ⁄objectsr   r   r	   r   ⁄debug)r   r5   Zoutput_libnamer1   r6   ⁄target_lang⁄output_filenamer&   r'   r'   r(   ⁄create_static_libx   s    	%zUnixCCompiler.create_static_libc                sÿ  |  j  | | É \ } } |  j | | | É } | \ } } } d d d d g â  t j d É } | rÅ à  j d | d | g É n  á  f d d	 Ü  | DÉ } á  f d
 d	 Ü  | DÉ } t |  | | | É } t | t t d  É f É sÚ t	 d É Ç n  | d  k	 rt
 j j | | É } n  |  j | | É rƒ| |  j | d | g } |	 r_d g | d  d Ö <n  |
 rx|
 | d  d Ö <n  | ré| j | É n  |  j t
 j j | É É yÊ | t j k rœ|  j d  d  Ö } n |  j d  d  Ö } | d k rW|  j rWd } t
 j j | d É d k rCd } x! d | | k r?| d 7} q"Wn  |  j | | | <n  t j d k r{t j | | É } n  |  j | | É Wq‘t k
 r¿} z t | É Ç WYd  d  } ~ Xq‘Xn t j d | É d  S)Nz/libz/lib64z/usr/libz
/usr/lib64Z	MULTIARCHz/lib/%sz/usr/lib/%sc                s"   g  |  ] } | à  k r | ë q Sr'   r'   )⁄.0⁄dir)⁄system_libdirsr'   r(   ˙
<listcomp>¢   s   	 z&UnixCCompiler.link.<locals>.<listcomp>c                s"   g  |  ] } | à  k r | ë q Sr'   r'   )r:   r;   )r<   r'   r(   r=   §   s   	 z%'output_dir' must be a string or Nonez-oz-gr   zc++⁄envÈ   ˙=r   zskipping %s (up-to-date)) r2   Z_fix_lib_argsr   ⁄get_config_varr   r   ⁄
isinstance⁄str⁄type⁄	TypeErrorr   r   ⁄joinr4   r5   r   r   r   Z
EXECUTABLEr   r   r   ⁄basenamer*   r+   r,   r-   r   r   r
   r   r6   )r   Ztarget_descr5   r8   r1   Z	librariesZlibrary_dirsZruntime_library_dirsZexport_symbolsr6   r!   r"   Z
build_tempr7   r#   Z	multiarchZlib_optsZld_argsZlinker⁄ir&   r'   )r<   r(   ⁄linkí   sT    		"zUnixCCompiler.linkc             C   s   d | S)Nz-Lr'   )r   r;   r'   r'   r(   ⁄library_dir_option◊   s    z UnixCCompiler.library_dir_optionc             C   s   d | k p d | k S)NZgcczg++r'   )r   Zcompiler_namer'   r'   r(   ⁄_is_gcc⁄   s    zUnixCCompiler._is_gccc             C   sˇ   t  j j t j d É É } t j d  d Ö d k r< d | St j d  d Ö d k rÄ |  j | É rr d d | g Sd d | g St j d  d	 Ö d
 k s≤ t j d  d Ö d k rº d | g S|  j | É rÛ t j d É d k rË d | Sd | Sn d | Sd  S)NZCCr   r   z-LÈ   zhp-uxz-Wl,+sz+sÈ   Zirix646Zosf1V5z-rpathZGNULDZyesz-Wl,--enable-new-dtags,-Rz-Wl,-Rz-R)r   r   rG   r   rA   r*   r+   rK   )r   r;   r   r'   r'   r(   ⁄runtime_library_dir_option›   s    2
z(UnixCCompiler.runtime_library_dir_optionc             C   s   d | S)Nz-lr'   )r   ⁄libr'   r'   r(   ⁄library_option  s    zUnixCCompiler.library_optionc             C   s“  |  j  | d d É} |  j  | d d É} |  j  | d d É} t j d k rñ t j d É } t j d | É } | d  k rÑ d }	 qñ | j d	 É }	 n  x5| D]-}
 t j	 j
 |
 | É } t j	 j
 |
 | É } t j	 j
 |
 | É } t j d k rà|
 j d
 É s|
 j d É rà|
 j d É ràt j	 j
 |	 |
 d	 d  Ö | É } t j	 j
 |	 |
 d	 d  Ö | É } t j	 j
 |	 |
 d	 d  Ö | É } n  t j	 j | É rû| St j	 j | É r¥| St j	 j | É rù | Sqù Wd  S)NZlib_type⁄shared⁄dylib⁄staticr   ZCFLAGSz-isysroot\s+(\S+)˙/r?   z/System/z/usr/z/usr/local/)r3   r*   r+   r   rA   ⁄re⁄search⁄groupr   r   rF   ⁄
startswith⁄exists)r   ⁄dirsrO   r6   Zshared_fZdylib_fZstatic_fZcflags⁄mZsysrootr;   rQ   rR   rS   r'   r'   r(   ⁄find_library_file
  s4    	""%zUnixCCompiler.find_library_file)⁄__name__⁄
__module__⁄__qualname__Zcompiler_typeZexecutablesr*   r+   Zsrc_extensionsZobj_extensionZstatic_lib_extensionZshared_lib_extensionZdylib_lib_extensionZstatic_lib_formatZshared_lib_formatZdylib_lib_formatZexe_extensionr)   r0   r9   rI   rJ   rK   rN   rP   r\   r'   r'   r'   r(   r   -   s@   





		A*r   )⁄__doc__r   r*   rU   Z	distutilsr   Zdistutils.dep_utilr   Zdistutils.ccompilerr   r   r   Zdistutils.errorsr   r   r	   r
   r   r+   r,   r   r'   r'   r'   r(   ⁄<module>   s   $"                                                                                                                                 usr/lib/python3.4/distutils/__pycache__/util.cpython-34.pyc                                         0100644 0000000 0000000 00000040325 13077704335 022244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TπP  „            	   @   sõ  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z d d l m Z d d	 Ñ  Z d
 d Ñ  Z d d Ñ  Z d a d d Ñ  Z d d Ñ  Z d d d Ñ Z d a a a d d Ñ  Z d d Ñ  Z d d d d d Ñ Z d d Ñ  Z d d d d d d d d d Ñ Z d  d! Ñ  Z d d d d" d# Ñ Z  d d d d d$ d% Ñ Z! Gd& d' Ñ  d' É Z" d S)(zudistutils.util

Miscellaneous utility functions -- anything that doesn't fit into
one of the other *util.py modules.
È    N)⁄DistutilsPlatformError)⁄newer)⁄spawn)⁄log)⁄DistutilsByteCompileErrorc              C   sÊ  t  j d k rô d }  t j j |  É } | d* k r: t j St j j d | É } t j | t |  É | Ö j É  } | d k rÇ d S| d k rí d St j Sd	 t  j k r≥ t  j d	 St  j d
 k s“ t	 t  d É rŸ t j St  j
 É  \ } } } } } | j É  j d d É } | j d d É } | j d d É } | d d Ö d k rTd | | f S| d d Ö d k r◊| d d k r’d } d t | d É d | d d Ö f } i d d 6d d 6}	 | d  |	 t j 7} q’n˛ | d d! Ö d" k r˚d | | f S| d d Ö d# k r"d$ | | | f S| d d% Ö d& k rzd& } t j d' t j É }
 |
 j | É } | r’| j É  } q’n[ | d d% Ö d( k r’d d l } d d l } | j | j j É  | | | É \ } } } n  d) | | | f S)+a´  Return a string that identifies the current platform.  This is used
    mainly to distinguish platform-specific build directories and
    platform-specific built distributions.  Typically includes the OS name
    and version and the architecture (as supplied by 'os.uname()'),
    although the exact information included depends on the OS; eg. for IRIX
    the architecture isn't particularly important (IRIX only runs on SGI
    hardware), but for Linux the kernel version isn't particularly
    important.

    Examples of returned values:
       linux-i586
       linux-alpha (?)
       solaris-2.6-sun4u
       irix-5.3
       irix64-6.2

    Windows will return one of:
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
       win-ia64 (64bit Windows on Itanium)
       win32 (all others - specifically, sys.platform is returned)

    For other non-POSIX platforms, currently just returns 'sys.platform'.
    ⁄ntz bit (È   ˙)Zamd64z	win-amd64Zitaniumzwin-ia64Z_PYTHON_HOST_PLATFORM⁄posix⁄uname˙/⁄ ˙ ⁄_˙-NÈ   Zlinuxz%s-%sZsunosr   ⁄5Zsolarisz%d.%sÈ   È   Z32bitiˇˇˇZ64bitl   ˇˇˇˇ z.%sÈ   ZirixZaixz%s-%s.%sÈ   ⁄cygwinz[\d.]+⁄darwinz%s-%s-%sÈˇˇˇˇ)⁄os⁄name⁄sys⁄version⁄find⁄platform⁄len⁄lower⁄environ⁄hasattrr   ⁄replace⁄int⁄maxsize⁄re⁄compile⁄ASCII⁄match⁄group⁄_osx_supportZdistutils.sysconfigZget_platform_osxZ	sysconfigZget_config_vars)⁄prefix⁄i⁄jZlookZosnameZhost⁄releaser   ⁄machineZbitnessZrel_re⁄mr,   ⁄	distutils© r4   ˙$/usr/lib/python3.4/distutils/util.py⁄get_platform   sX    #(r6   c             C   sØ   t  j d k r |  S|  s |  S|  d d k r@ t d |  É Ç n  |  d d k rc t d |  É Ç n  |  j d É } x d | k rë | j d É qu W| sü t  j St  j j | å  S)aŒ  Return 'pathname' as a name that will work on the native filesystem,
    i.e. split it on '/' and put it back together again using the current
    directory separator.  Needed because filenames in the setup script are
    always supplied in Unix style, and have to be converted to the local
    convention before we can actually use them in the filesystem.  Raises
    ValueError on non-Unix-ish systems if 'pathname' either starts or
    ends with a slash.
    r   r   zpath '%s' cannot be absoluter   zpath '%s' cannot end with '/'⁄.r   )r   ⁄sep⁄
ValueError⁄split⁄remove⁄curdir⁄path⁄join)⁄pathnameZpathsr4   r4   r5   ⁄convert_patho   s    	r@   c             C   s»   t  j d k rT t  j j | É s4 t  j j |  | É St  j j |  | d d Ö É Snp t  j d k r± t  j j | É \ } } | d d k rû | d d Ö } n  t  j j |  | É St d t  j É Ç d S)a	  Return 'pathname' with 'new_root' prepended.  If 'pathname' is
    relative, this is equivalent to "os.path.join(new_root,pathname)".
    Otherwise, it requires making 'pathname' relative and then joining the
    two, which is tricky on DOS/Windows and Mac OS.
    r
   r   Nr   r   ˙\z!nothing known about platform '%s')r   r   r=   ⁄isabsr>   ⁄
splitdriver   )Znew_rootr?   Zdriver=   r4   r4   r5   ⁄change_rootã   s     rD   c              C   sÉ   t  r
 d St j d k rW d t j k rW d d l }  |  j t j É  É d t j d <n  d t j k ry t É  t j d <n  d a  d S)aL  Ensure that 'os.environ' has all the environment variables we
    guarantee that users can use in config files, command-line options,
    etc.  Currently this includes:
      HOME - user's home directory (Unix only)
      PLAT - description of the current platform, including hardware
             and OS (see 'get_platform()')
    Nr
   ⁄HOMEr   r   ZPLATr   )⁄_environ_checkedr   r   r"   ⁄pwd⁄getpwuid⁄getuidr6   )rG   r4   r4   r5   ⁄check_environ¢   s    	#rJ   c             C   si   t  É  | d d Ñ } y t j d | |  É SWn5 t k
 rd } z t d | É Ç WYd d } ~ Xn Xd S)a‡  Perform shell/Perl-style variable substitution on 'string'.  Every
    occurrence of '$' followed by a name is considered a variable, and
    variable is substituted by the value found in the 'local_vars'
    dictionary, or in 'os.environ' if it's not in 'local_vars'.
    'os.environ' is first checked/augmented to guarantee that it contains
    certain values: see 'check_environ()'.  Raise ValueError for any
    variables not found in either 'local_vars' or 'os.environ'.
    c             S   s8   |  j  d É } | | k r) t | | É St j | Sd  S)Nr   )r+   ⁄strr   r"   )r*   ⁄
local_varsZvar_namer4   r4   r5   ⁄_subst¬   s    zsubst_vars.<locals>._substz\$([a-zA-Z_][a-zA-Z_0-9]*)zinvalid variable '$%s'N)rJ   r'   ⁄sub⁄KeyErrorr9   )⁄srL   rM   Zvarr4   r4   r5   ⁄
subst_vars∏   s    	rQ   zerror: c             C   s   | t  |  É S)N)rK   )⁄excr-   r4   r4   r5   ⁄grok_environment_error—   s    rS   c               C   s8   t  j d t j É a t  j d É a t  j d É a d  S)Nz[^\\\'\"%s ]*z'(?:[^'\\]|\\.)*'z"(?:[^"\\]|\\.)*")r'   r(   ⁄string⁄
whitespace⁄_wordchars_re⁄
_squote_re⁄
_dquote_rer4   r4   r4   r5   ⁄_init_regex⁄   s    rY   c             C   s  t  d k r t É  n  |  j É  }  g  } d } x◊|  rt  j |  | É } | j É  } | t |  É k rÇ | j |  d | Ö É Pn  |  | t j k rÀ | j |  d | Ö É |  | d Ö j	 É  }  d } n|  | d k r
|  d | Ö |  | d d Ö }  | d } n◊ |  | d k r/t
 j |  | É } n9 |  | d k rTt j |  | É } n t d |  | É Ç | d k rãt d |  | É Ç n  | j É  \ } } |  d | Ö |  | d | d Ö |  | d Ö }  | j É  d	 } | t |  É k r1 | j |  É Pq1 q1 W| S)
a  Split a string up according to Unix shell-like rules for quotes and
    backslashes.  In short: words are delimited by spaces, as long as those
    spaces are not escaped by a backslash, or inside a quoted string.
    Single and double quotes are equivalent, and the quote characters can
    be backslash-escaped.  The backslash is stripped from any two-character
    escape sequence, leaving only the escaped character.  The quote
    characters are stripped from any quoted string.  Returns a list of
    words.
    Nr   rA   r   ˙'˙"z!this can't happen (bad char '%c')z"bad string (mismatched %s quotes?)r   )rV   rY   ⁄stripr*   ⁄endr    ⁄appendrT   rU   ⁄lstriprW   rX   ⁄RuntimeErrorr9   ⁄span)rP   Zwords⁄posr2   r]   Zbegr4   r4   r5   ⁄split_quoted‡   s@     
		"4rc   c             C   ss   | d k rO d |  j  | f } | d d Ö d k rO | d d Ö d } qO n  t j | É | so |  | å  n  d S)	aú  Perform some action that affects the outside world (eg.  by
    writing to the filesystem).  Such actions are special because they
    are disabled by the 'dry_run' flag.  This method takes care of all
    that bureaucracy for you; all you have to do is supply the
    function to call and an argument tuple for it (to embody the
    "external action" being performed), and an optional message to
    print.
    Nz%s%rr   z,)r   r	   È˛ˇˇˇrd   )⁄__name__r   ⁄info)⁄func⁄args⁄msg⁄verbose⁄dry_runr4   r4   r5   ⁄execute  s    	rl   c             C   sC   |  j  É  }  |  d k r d S|  d k r, d St d |  f É Ç d S)zÙConvert a string representation of truth to true (1) or false (0).

    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
    'val' is anything else.
    ⁄y⁄yes⁄t⁄true⁄on⁄1r   ⁄n⁄no⁄f⁄false⁄off⁄0r   zinvalid truth value %rN)rm   rn   ro   rp   rq   rr   )rs   rt   ru   rv   rw   rx   )r!   r9   )⁄valr4   r4   r5   ⁄	strtobool0  s    rz   r   c             C   s%  t  j r t d É Ç n  | d k r9 t o3 | d k } n  | s¿y& d d l m } | d É \ }	 }
 Wn5 t k
 rú d d l m } d | d É }	 }
 Yn Xt j	 d |
 É | s@|	 d k	 r‘ t
 j |	 d É } n t |
 d É } | j d	 É | j d
 j t t |  É É d É | j d | | | | | f É | j É  n  t  j |
 g } | d k rn| j d d É n | d k rç| j d d É n  t | d | Ét t
 j |
 f d |
 d | Énad d l m } xN|  D]F} | d d Ö d k r˘q◊n  | d k r!t j j | d | É} n t j j | É } | } | rç| d t | É Ö | k rtt d | | f É Ç n  | t | É d Ö } n  | r´t
 j j | | É } n  t
 j j | É } | r◊| sÿt  | | É rt j	 d | | É | s| | | | É qqt j! d | | É q◊q◊Wd S)aù  Byte-compile a collection of Python source files to either .pyc
    or .pyo files in a __pycache__ subdirectory.  'py_files' is a list
    of files to compile; any files that don't end in ".py" are silently
    skipped.  'optimize' must be one of the following:
      0 - don't optimize (generate .pyc)
      1 - normal optimization (like "python -O")
      2 - extra optimization (like "python -OO")
    If 'force' is true, all files are recompiled regardless of
    timestamps.

    The source filename encoded in each bytecode file defaults to the
    filenames listed in 'py_files'; you can modify these with 'prefix' and
    'basedir'.  'prefix' is a string that will be stripped off of each
    source filename, and 'base_dir' is a directory name that will be
    prepended (after 'prefix' is stripped).  You can supply either or both
    (or neither) of 'prefix' and 'base_dir', as you wish.

    If 'dry_run' is true, doesn't actually do anything that would
    affect the filesystem.

    Byte-compilation is either done directly in this interpreter process
    with the standard py_compile module, or indirectly by writing a
    temporary script and executing it.  Normally, you should let
    'byte_compile()' figure out to use direct compilation or not (see
    the source for details).  The 'direct' flag is used by the script
    generated in indirect mode; unless you know what you're doing, leave
    it set to None.
    zbyte-compiling is disabled.Nr   )⁄mkstempz.py)⁄mktempz$writing byte-compilation script '%s'⁄wz2from distutils.util import byte_compile
files = [
z,
z]
zå
byte_compile(files, optimize=%r, force=%r,
             prefix=%r, base_dir=%r,
             verbose=%r, dry_run=0,
             direct=1)
r   z-Or   z-OOrk   zremoving %s)r(   r   ⁄debug_overridez1invalid prefix: filename %r doesn't start with %rzbyte-compiling %s to %sz%skipping byte-compilation of %s to %sÈ˝ˇˇˇ)"r   ⁄dont_write_bytecoder   ⁄	__debug__Ztempfiler{   ⁄ImportErrorr|   r   rf   r   ⁄fdopen⁄open⁄writer>   ⁄map⁄repr⁄close⁄
executable⁄insertr   rl   r;   Z
py_compiler(   ⁄	importlib⁄util⁄cache_from_sourcer    r9   r=   ⁄basenamer   ⁄debug)Zpy_files⁄optimizeZforcer-   Zbase_dirrj   rk   Zdirectr{   Z	script_fdZscript_namer|   Zscript⁄cmdr(   ⁄file⁄cfile⁄dfileZ
cfile_baser4   r4   r5   ⁄byte_compile@  sl    "	#
		rï   c             C   s"   |  j  d É } d } | j | É S)zåReturn a version of the string escaped for inclusion in an
    RFC-822 header, by ensuring there are 8 spaces space after each newline.
    ⁄
È   r   z        z	
        )r:   r>   )⁄header⁄linesr8   r4   r4   r5   ⁄rfc822_escape“  s    rö   c             C   sz   |  s
 d Sd d l  m } m } Gd d Ñ  d | É } | d k rQ | d É } n  | | d | É} | j |  d d	 Éd S)
a  Invoke 2to3 on a list of Python files.
    The files should all come from the build area, as the
    modification is done in-place. To reduce the build time,
    only files modified since the last invocation of this
    function should be passed in the files argument.Nr   )⁄RefactoringTool⁄get_fixers_from_packagec               @   s4   e  Z d  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)z*run_2to3.<locals>.DistutilsRefactoringToolc             _   s   t  j | | å d  S)N)r   ⁄error)⁄selfri   rh   ⁄kwr4   r4   r5   ⁄	log_errorÈ  s    z4run_2to3.<locals>.DistutilsRefactoringTool.log_errorc             W   s   t  j | | å d  S)N)r   rf   )rû   ri   rh   r4   r4   r5   ⁄log_messageÏ  s    z6run_2to3.<locals>.DistutilsRefactoringTool.log_messagec             W   s   t  j | | å d  S)N)r   rè   )rû   ri   rh   r4   r4   r5   ⁄	log_debugÔ  s    z4run_2to3.<locals>.DistutilsRefactoringTool.log_debugN)re   ⁄
__module__⁄__qualname__r†   r°   r¢   r4   r4   r4   r5   ⁄DistutilsRefactoringToolË  s   r•   zlib2to3.fixes⁄optionsrÖ   T)Zlib2to3.refactorrõ   rú   Zrefactor)⁄files⁄fixer_namesr¶   ⁄explicitrõ   rú   r•   ⁄rr4   r4   r5   ⁄run_2to3‹  s    
r´   c             C   s|  d d l  m } d d l m } d d l m } | É  }	 t j É  }
 t j |  É z |	 j	 É  Wd t j |
 É X|	 j
 |	 j d d Ö <| rÃ x< | j É  D]+ } | j É  } | s∏ qö n  |	 j | É qö Wn  g  } xz |	 j D]o } t j j | | É } | t j j | É É | t j j |  | É | d d É} | d r‹ | j | É q‹ q‹ Wt d d	 Ñ  | DÉ d
 | d | d | É| S)zœRecursively copy a directory, only copying new and changed files,
    running run_2to3 over all newly copied Python modules afterward.

    If you give a template string, it's parsed like a MANIFEST.in.
    r   )⁄mkpath)⁄	copy_file)⁄FileListN⁄updater   c             S   s+   g  |  ]! } | j  É  j d  É r | ë q S)z.py)r!   ⁄endswith)⁄.0⁄fnr4   r4   r5   ˙
<listcomp>  s   	 z$copydir_run_2to3.<locals>.<listcomp>r®   r¶   r©   )Zdistutils.dir_utilr¨   Zdistutils.file_utilr≠   Zdistutils.filelistrÆ   r   ⁄getcwd⁄chdir⁄findallZallfilesrß   ⁄
splitlinesr\   Zprocess_template_liner=   r>   ⁄dirnamer^   r´   )⁄src⁄dest⁄templater®   r¶   r©   r¨   r≠   rÆ   Zfilelistr<   ⁄lineZcopied⁄filenameZoutnameZresr4   r4   r5   ⁄copydir_run_2to3˜  s4    	 $
 ræ   c               @   s4   e  Z d  Z d Z d Z d Z d Z d d Ñ  Z d S)⁄	Mixin2to3z¿Mixin class for commands that run 2to3.
    To configure 2to3, setup scripts may either change
    the class variables, or inherit from individual commands
    to override how 2to3 is invoked.Nc             C   s   t  | |  j |  j |  j É S)N)r´   r®   r¶   r©   )rû   rß   r4   r4   r5   r´   (  s    zMixin2to3.run_2to3)re   r£   r§   ⁄__doc__r®   r¶   r©   r´   r4   r4   r4   r5   rø     s
   rø   )#r¿   r   r'   ⁄importlib.utilrã   r   rT   Zdistutils.errorsr   Zdistutils.dep_utilr   Zdistutils.spawnr   r3   r   r   r6   r@   rD   rF   rJ   rQ   rS   rV   rW   rX   rY   rc   rl   rz   rï   rö   r´   ræ   rø   r4   r4   r4   r5   ⁄<module>   s>   ]=é
                                                                                                                                                                                                                                                                                                            usr/lib/python3.4/distutils/__pycache__/version.cpython-34.pyc                                      0100644 0000000 0000000 00000017426 13077704335 022762  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tø0  „               @   sU   d  Z  d d l Z Gd d Ñ  d É Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z d S)	aƒ  Provides classes to represent module version numbers (one class for
each style of version numbering).  There are currently two such classes
implemented: StrictVersion and LooseVersion.

Every version number class implements the following interface:
  * the 'parse' method takes a string and parses it to some internal
    representation; if the string is an invalid version number,
    'parse' raises a ValueError exception
  * the class constructor takes an optional string argument which,
    if supplied, is passed to 'parse'
  * __str__ reconstructs the string that was passed to 'parse' (or
    an equivalent string -- ie. one that will generate an equivalent
    version number instance)
  * __repr__ generates Python code to recreate the version number instance
  * _cmp compares the current instance with either another instance
    of the same class or a string (which will be parsed to an instance
    of the same class, thus must follow the same rules)
È    Nc               @   sy   e  Z d  Z d Z d d d Ñ Z d d Ñ  Z d d Ñ  Z d	 d
 Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d S)⁄VersionzÌAbstract base class for version numbering classes.  Just provides
    constructor (__init__) and reproducer (__repr__), because those
    seem to be the same for all version numbering classes; and route
    rich comparisons to _cmp.
    Nc             C   s   | r |  j  | É n  d  S)N)⁄parse)⁄self⁄vstring© r   ˙'/usr/lib/python3.4/distutils/version.py⁄__init__&   s    zVersion.__init__c             C   s   d |  j  j t |  É f S)Nz	%s ('%s'))⁄	__class__⁄__name__⁄str)r   r   r   r   ⁄__repr__*   s    zVersion.__repr__c             C   s)   |  j  | É } | t k r | S| d k S)Nr   )⁄_cmp⁄NotImplemented)r   ⁄other⁄cr   r   r   ⁄__eq__-   s    zVersion.__eq__c             C   s)   |  j  | É } | t k r | S| d k S)Nr   )r   r   )r   r   r   r   r   r   ⁄__ne__3   s    zVersion.__ne__c             C   s)   |  j  | É } | t k r | S| d k  S)Nr   )r   r   )r   r   r   r   r   r   ⁄__lt__9   s    zVersion.__lt__c             C   s)   |  j  | É } | t k r | S| d k S)Nr   )r   r   )r   r   r   r   r   r   ⁄__le__?   s    zVersion.__le__c             C   s)   |  j  | É } | t k r | S| d k S)Nr   )r   r   )r   r   r   r   r   r   ⁄__gt__E   s    zVersion.__gt__c             C   s)   |  j  | É } | t k r | S| d k S)Nr   )r   r   )r   r   r   r   r   r   ⁄__ge__K   s    zVersion.__ge__)r
   ⁄
__module__⁄__qualname__⁄__doc__r   r   r   r   r   r   r   r   r   r   r   r   r      s   r   c               @   sV   e  Z d  Z d Z e j d e j e j BÉ Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d	 S)
⁄StrictVersiona?  Version numbering for anal retentives and software idealists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of two or three
    dot-separated numeric components, with an optional "pre-release" tag
    on the end.  The pre-release tag consists of the letter 'a' or 'b'
    followed by a number.  If the numeric components of two version
    numbers are equal, then one with a pre-release tag will always
    be deemed earlier (lesser) than one without.

    The following are valid version numbers (shown in the order that
    would be obtained by sorting according to the supplied cmp function):

        0.4       0.4.0  (these two are equivalent)
        0.4.1
        0.5a1
        0.5b3
        0.5
        0.9.6
        1.0
        1.0.4a3
        1.0.4b1
        1.0.4

    The following are examples of invalid version numbers:

        1
        2.7.2.2
        1.3.a4
        1.3pl1
        1.3c4

    The rationale for this version numbering system will be explained
    in the distutils documentation.
    z)^(\d+) \. (\d+) (\. (\d+))? ([ab](\d+))?$c             C   s–   |  j  j | É } | s+ t d | É Ç n  | j d d d d d É \ } } } } } | r t t t | | | g É É |  _ n" t t t | | g É É d |  _ | r√ | d t | É f |  _ n	 d  |  _ d  S)	Nzinvalid version number '%s'È   È   È   È   È   r   )r   )	⁄
version_re⁄match⁄
ValueError⁄group⁄tuple⁄map⁄int⁄version⁄
prerelease)r   r   r!   ⁄major⁄minorZpatchr(   Zprerelease_numr   r   r   r   å   s    *$"zStrictVersion.parsec             C   sà   |  j  d d k r; d j t t |  j  d d Ö É É } n d j t t |  j  É É } |  j rÑ | |  j d t |  j d É } n  | S)Nr   r   ⁄.r   )r'   ⁄joinr%   r   r(   )r   r   r   r   r   ⁄__str__ü   s    (	%zStrictVersion.__str__c             C   sÓ   t  | t É r t | É } n  |  j | j k rM |  j | j k  rF d Sd Sn  |  j re | j re d S|  j r| | j r| d S|  j rì | j rì d S|  j rÿ | j rÿ |  j | j k rª d S|  j | j k  r— d Sd Sn d sÍ t d É Ç d  S)Nr   r   Fznever get hereÈˇˇˇˇr.   r.   )⁄
isinstancer   r   r'   r(   ⁄AssertionError)r   r   r   r   r   r   ¨   s&    zStrictVersion._cmpN)r
   r   r   r   ⁄re⁄compile⁄VERBOSE⁄ASCIIr    r   r-   r   r   r   r   r   r   c   s   #	r   c               @   sj   e  Z d  Z d Z e j d e j É Z d d d Ñ Z d d Ñ  Z	 d d	 Ñ  Z
 d
 d Ñ  Z d d Ñ  Z d S)⁄LooseVersiona§  Version numbering for anarchists and software realists.
    Implements the standard interface for version number classes as
    described above.  A version number consists of a series of numbers,
    separated by either periods or strings of letters.  When comparing
    version numbers, the numeric components will be compared
    numerically, and the alphabetic components lexically.  The following
    are all valid version numbers, in no particular order:

        1.5.1
        1.5.2b2
        161
        3.10a
        8.02
        3.4j
        1996.07.12
        3.2.pl0
        3.1.1.6
        2g6
        11g
        0.960923
        2.2beta29
        1.13++
        5.5.kw
        2.0b1pl0

    In fact, there is no such thing as an invalid version number under
    this scheme; the rules for comparison are simple and predictable,
    but may not always give the results you want (for some definition
    of "want").
    z(\d+ | [a-z]+ | \.)Nc             C   s   | r |  j  | É n  d  S)N)r   )r   r   r   r   r   r   4  s    zLooseVersion.__init__c             C   s{   | |  _  d d Ñ  |  j j | É DÉ } xC t | É D]5 \ } } y t | É | | <Wq5 t k
 ri Yq5 Xq5 W| |  _ d  S)Nc             S   s(   g  |  ] } | r | d  k r | ë q S)r+   r   )⁄.0⁄xr   r   r   ˙
<listcomp>>  s   	 z&LooseVersion.parse.<locals>.<listcomp>)r   ⁄component_re⁄split⁄	enumerater&   r"   r'   )r   r   Z
components⁄i⁄objr   r   r   r   9  s    		zLooseVersion.parsec             C   s   |  j  S)N)r   )r   r   r   r   r-   I  s    zLooseVersion.__str__c             C   s   d t  |  É S)NzLooseVersion ('%s'))r   )r   r   r   r   r   M  s    zLooseVersion.__repr__c             C   sd   t  | t É r t | É } n  |  j | j k r4 d S|  j | j k  rJ d S|  j | j k r` d Sd  S)Nr   r   r.   )r/   r   r5   r'   )r   r   r   r   r   r   Q  s    zLooseVersion._cmp)r
   r   r   r   r1   r2   r3   r9   r   r   r-   r   r   r   r   r   r   r5     s   r5   )r   r1   r   r   r5   r   r   r   r   ⁄<module>   s   DÆ                                                                                                                                                                                                                                          usr/lib/python3.4/distutils/__pycache__/versionpredicate.cpython-34.pyc                             0100644 0000000 0000000 00000012410 13077704335 024627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T  „               @   s‘   d  Z  d d l Z d d l Z d d l Z e j d e j É Z e j d É Z e j d É Z	 d d Ñ  Z
 i e j d 6e j d	 6e j d
 6e j d 6e j d 6e j d 6Z Gd d Ñ  d É Z d a d d Ñ  Z d S)zBModule for parsing and testing package version predicate strings.
È    Nz'(?i)^\s*([a-z_]\w*(?:\.[a-z_]\w*)*)(.*)z^\s*\((.*)\)\s*$z%^\s*(<=|>=|<|>|!=|==)\s*([^\s,]+)\s*$c             C   sP   t  j |  É } | s( t d |  É Ç n  | j É  \ } } | t j j | É f S)zVParse a single version comparison.

    Return (comparison string, StrictVersion)
    z"bad package restriction syntax: %r)⁄re_splitComparison⁄match⁄
ValueError⁄groups⁄	distutils⁄version⁄StrictVersion)⁄predZres⁄compZverStr© r   ˙0/usr/lib/python3.4/distutils/versionpredicate.py⁄splitUp   s
    r   ˙<z<=z==˙>z>=z!=c               @   s:   e  Z d  Z d Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)	⁄VersionPredicateaº  Parse and test package version predicates.

    >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')

    The `name` attribute provides the full dotted name that is given::

    >>> v.name
    'pyepat.abc'

    The str() of a `VersionPredicate` provides a normalized
    human-readable version of the expression::

    >>> print(v)
    pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)

    The `satisfied_by()` method can be used to determine with a given
    version number is included in the set described by the version
    restrictions::

    >>> v.satisfied_by('1.1')
    True
    >>> v.satisfied_by('1.4')
    True
    >>> v.satisfied_by('1.0')
    False
    >>> v.satisfied_by('4444.4')
    False
    >>> v.satisfied_by('1555.1b3')
    False

    `VersionPredicate` is flexible in accepting extra whitespace::

    >>> v = VersionPredicate(' pat( ==  0.1  )  ')
    >>> v.name
    'pat'
    >>> v.satisfied_by('0.1')
    True
    >>> v.satisfied_by('0.2')
    False

    If any version numbers passed in do not conform to the
    restrictions of `StrictVersion`, a `ValueError` is raised::

    >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')
    Traceback (most recent call last):
      ...
    ValueError: invalid version number '1.2zb3'

    It the module or package name given does not conform to what's
    allowed as a legal module or package name, `ValueError` is
    raised::

    >>> v = VersionPredicate('foo-bar')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: '-bar'

    >>> v = VersionPredicate('foo bar (12.21)')
    Traceback (most recent call last):
      ...
    ValueError: expected parenthesized list: 'bar (12.21)'

    c             C   sÛ   | j  É  } | s! t d É Ç n  t j | É } | sI t d | É Ç n  | j É  \ |  _ } | j  É  } | rÊ t j | É } | sò t d | É Ç n  | j É  d } d d Ñ  | j d É DÉ |  _ |  j sÔ t d | É Ç qÔ n	 g  |  _ d	 S)
z*Parse a version predicate string.
        zempty package restrictionzbad package name in %rzexpected parenthesized list: %rr   c             S   s   g  |  ] } t  | É ë q Sr   )r   )⁄.0ZaPredr   r   r   ˙
<listcomp>t   s   	 z-VersionPredicate.__init__.<locals>.<listcomp>˙,zempty parenthesized list in %rN)	⁄stripr   ⁄re_validPackager   r   ⁄name⁄re_paren⁄splitr	   )⁄selfZversionPredicateStrr   Zparen⁄strr   r   r   ⁄__init__`   s$    	zVersionPredicate.__init__c             C   sF   |  j  r; d d Ñ  |  j  DÉ } |  j d d j | É d S|  j Sd  S)Nc             S   s*   g  |  ]  \ } } | d  t  | É ë q S)˙ )r   )r   ⁄cond⁄verr   r   r   r   }   s   	 z,VersionPredicate.__str__.<locals>.<listcomp>z (z, ˙))r	   r   ⁄join)r   ⁄seqr   r   r   ⁄__str__{   s    	zVersionPredicate.__str__c             C   s5   x. |  j  D]# \ } } t | | | É s
 d Sq
 Wd S)zœTrue if version is compatible with all the predicates in self.
        The parameter version must be acceptable to the StrictVersion
        constructor.  It may be either a string or StrictVersion.
        FT)r	   ⁄compmap)r   r   r   r   r   r   r   ⁄satisfied_byÇ   s    zVersionPredicate.satisfied_byN)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r"   r$   r   r   r   r   r      s   ?r   c             C   sõ   t  d k r$ t j d t j É a  n  |  j É  }  t  j |  É } | sX t d |  É Ç n  | j d É pj d } | rà t j	 j
 | É } n  | j d É | f S)a9  Return the name and optional version number of a provision.

    The version number, if given, will be returned as a `StrictVersion`
    instance, otherwise it will be `None`.

    >>> split_provision('mypkg')
    ('mypkg', None)
    >>> split_provision(' mypkg( 1.2 ) ')
    ('mypkg', StrictVersion ('1.2'))
    Nz=([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)(?:\s*\(\s*([^)\s]+)\s*\))?$z"illegal provides specification: %rÈ   È   )⁄_provision_rx⁄re⁄compile⁄ASCIIr   r   r   ⁄groupr   r   r   )⁄value⁄mr   r   r   r   ⁄split_provisionè   s    r2   )r(   r,   Zdistutils.versionr   ⁄operatorr-   r.   r   r   r   r   ⁄lt⁄le⁄eq⁄gt⁄ge⁄ner#   r   r+   r2   r   r   r   r   ⁄<module>   s   	!!n                                                                                                                                                                                                                                                        usr/lib/python3.4/distutils/archive_util.py                                                         0100644 0000000 0000000 00000017411 12415221640 017447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.archive_util

Utility functions for creating archive files (tarballs, zip files,
that sort of thing)."""

import os
from warnings import warn
import sys

try:
    import zipfile
except ImportError:
    zipfile = None


from distutils.errors import DistutilsExecError
from distutils.spawn import spawn
from distutils.dir_util import mkpath
from distutils import log

try:
    from pwd import getpwnam
except ImportError:
    getpwnam = None

try:
    from grp import getgrnam
except ImportError:
    getgrnam = None

def _get_gid(name):
    """Returns a gid, given a group name."""
    if getgrnam is None or name is None:
        return None
    try:
        result = getgrnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _get_uid(name):
    """Returns an uid, given a user name."""
    if getpwnam is None or name is None:
        return None
    try:
        result = getpwnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def make_tarball(base_name, base_dir, compress="gzip", verbose=0, dry_run=0,
                 owner=None, group=None):
    """Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "compress", "bzip2", or None.
    (compress will be deprecated in Python 3.2)

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_dir' +  ".tar", possibly plus
    the appropriate compression extension (".gz", ".bz2" or ".Z").

    Returns the output filename.
    """
    tar_compression = {'gzip': 'gz', 'bzip2': 'bz2', None: '', 'compress': ''}
    compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'}

    # flags for compression program, each element of list will be an argument
    if compress is not None and compress not in compress_ext.keys():
        raise ValueError(
              "bad value for 'compress': must be None, 'gzip', 'bzip2' "
              "or 'compress'")

    archive_name = base_name + '.tar'
    if compress != 'compress':
        archive_name += compress_ext.get(compress, '')

    mkpath(os.path.dirname(archive_name), dry_run=dry_run)

    # creating the tarball
    import tarfile  # late import so Python build itself doesn't break

    log.info('Creating tar archive')

    uid = _get_uid(owner)
    gid = _get_gid(group)

    def _set_uid_gid(tarinfo):
        if gid is not None:
            tarinfo.gid = gid
            tarinfo.gname = group
        if uid is not None:
            tarinfo.uid = uid
            tarinfo.uname = owner
        return tarinfo

    if not dry_run:
        tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])
        try:
            tar.add(base_dir, filter=_set_uid_gid)
        finally:
            tar.close()

    # compression using `compress`
    if compress == 'compress':
        warn("'compress' will be deprecated.", PendingDeprecationWarning)
        # the option varies depending on the platform
        compressed_name = archive_name + compress_ext[compress]
        if sys.platform == 'win32':
            cmd = [compress, archive_name, compressed_name]
        else:
            cmd = [compress, '-f', archive_name]
        spawn(cmd, dry_run=dry_run)
        return compressed_name

    return archive_name

def make_zipfile(base_name, base_dir, verbose=0, dry_run=0):
    """Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises DistutilsExecError.  Returns the name of the output zip
    file.
    """
    zip_filename = base_name + ".zip"
    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)

    # If zipfile module is not available, try spawning an external
    # 'zip' command.
    if zipfile is None:
        if verbose:
            zipoptions = "-r"
        else:
            zipoptions = "-rq"

        try:
            spawn(["zip", zipoptions, zip_filename, base_dir],
                  dry_run=dry_run)
        except DistutilsExecError:
            # XXX really should distinguish between "couldn't find
            # external 'zip' command" and "zip failed".
            raise DistutilsExecError(("unable to create zip file '%s': "
                   "could neither import the 'zipfile' module nor "
                   "find a standalone zip utility") % zip_filename)

    else:
        log.info("creating '%s' and adding '%s' to it",
                 zip_filename, base_dir)

        if not dry_run:
            try:
                zip = zipfile.ZipFile(zip_filename, "w",
                                      compression=zipfile.ZIP_DEFLATED)
            except RuntimeError:
                zip = zipfile.ZipFile(zip_filename, "w",
                                      compression=zipfile.ZIP_STORED)

            for dirpath, dirnames, filenames in os.walk(base_dir):
                for name in filenames:
                    path = os.path.normpath(os.path.join(dirpath, name))
                    if os.path.isfile(path):
                        zip.write(path, path)
                        log.info("adding '%s'" % path)
            zip.close()

    return zip_filename

ARCHIVE_FORMATS = {
    'gztar': (make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
    'bztar': (make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
    'ztar':  (make_tarball, [('compress', 'compress')], "compressed tar file"),
    'tar':   (make_tarball, [('compress', None)], "uncompressed tar file"),
    'zip':   (make_zipfile, [],"ZIP file")
    }

def check_archive_formats(formats):
    """Returns the first format from the 'format' list that is unknown.

    If all formats are known, returns None
    """
    for format in formats:
        if format not in ARCHIVE_FORMATS:
            return format
    return None

def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,
                 dry_run=0, owner=None, group=None):
    """Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "ztar",
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    """
    save_cwd = os.getcwd()
    if root_dir is not None:
        log.debug("changing into '%s'", root_dir)
        base_name = os.path.abspath(base_name)
        if not dry_run:
            os.chdir(root_dir)

    if base_dir is None:
        base_dir = os.curdir

    kwargs = {'dry_run': dry_run}

    try:
        format_info = ARCHIVE_FORMATS[format]
    except KeyError:
        raise ValueError("unknown archive format '%s'" % format)

    func = format_info[0]
    for arg, val in format_info[1]:
        kwargs[arg] = val

    if format != 'zip':
        kwargs['owner'] = owner
        kwargs['group'] = group

    try:
        filename = func(base_name, base_dir, **kwargs)
    finally:
        if root_dir is not None:
            log.debug("changing back to '%s'", save_cwd)
            os.chdir(save_cwd)

    return filename
                                                                                                                                                                                                                                                       usr/lib/python3.4/distutils/bcppcompiler.py                                                         0100644 0000000 0000000 00000035127 12415221640 017454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.bcppcompiler

Contains BorlandCCompiler, an implementation of the abstract CCompiler class
for the Borland C++ compiler.
"""

# This implementation by Lyle Johnson, based on the original msvccompiler.py
# module and using the directions originally published by Gordon Williams.

# XXX looks like there's a LOT of overlap between these two classes:
# someone should sit down and factor out the common code as
# WindowsCCompiler!  --GPW


import os
from distutils.errors import \
     DistutilsExecError, DistutilsPlatformError, \
     CompileError, LibError, LinkError, UnknownFileError
from distutils.ccompiler import \
     CCompiler, gen_preprocess_options, gen_lib_options
from distutils.file_util import write_file
from distutils.dep_util import newer
from distutils import log

class BCPPCompiler(CCompiler) :
    """Concrete class that implements an interface to the Borland C/C++
    compiler, as defined by the CCompiler abstract class.
    """

    compiler_type = 'bcpp'

    # Just set this so CCompiler's constructor doesn't barf.  We currently
    # don't use the 'set_executables()' bureaucracy provided by CCompiler,
    # as it really isn't necessary for this sort of single-compiler class.
    # Would be nice to have a consistent interface with UnixCCompiler,
    # though, so it's worth thinking about.
    executables = {}

    # Private class data (need to distinguish C from C++ source for compiler)
    _c_extensions = ['.c']
    _cpp_extensions = ['.cc', '.cpp', '.cxx']

    # Needed for the filename generation methods provided by the
    # base class, CCompiler.
    src_extensions = _c_extensions + _cpp_extensions
    obj_extension = '.obj'
    static_lib_extension = '.lib'
    shared_lib_extension = '.dll'
    static_lib_format = shared_lib_format = '%s%s'
    exe_extension = '.exe'


    def __init__ (self,
                  verbose=0,
                  dry_run=0,
                  force=0):

        CCompiler.__init__ (self, verbose, dry_run, force)

        # These executables are assumed to all be in the path.
        # Borland doesn't seem to use any special registry settings to
        # indicate their installation locations.

        self.cc = "bcc32.exe"
        self.linker = "ilink32.exe"
        self.lib = "tlib.exe"

        self.preprocess_options = None
        self.compile_options = ['/tWM', '/O2', '/q', '/g0']
        self.compile_options_debug = ['/tWM', '/Od', '/q', '/g0']

        self.ldflags_shared = ['/Tpd', '/Gn', '/q', '/x']
        self.ldflags_shared_debug = ['/Tpd', '/Gn', '/q', '/x']
        self.ldflags_static = []
        self.ldflags_exe = ['/Gn', '/q', '/x']
        self.ldflags_exe_debug = ['/Gn', '/q', '/x','/r']


    # -- Worker methods ------------------------------------------------

    def compile(self, sources,
                output_dir=None, macros=None, include_dirs=None, debug=0,
                extra_preargs=None, extra_postargs=None, depends=None):

        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)
        compile_opts = extra_preargs or []
        compile_opts.append ('-c')
        if debug:
            compile_opts.extend (self.compile_options_debug)
        else:
            compile_opts.extend (self.compile_options)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            # XXX why do the normpath here?
            src = os.path.normpath(src)
            obj = os.path.normpath(obj)
            # XXX _setup_compile() did a mkpath() too but before the normpath.
            # Is it possible to skip the normpath?
            self.mkpath(os.path.dirname(obj))

            if ext == '.res':
                # This is already a binary file -- skip it.
                continue # the 'for' loop
            if ext == '.rc':
                # This needs to be compiled to a .res file -- do it now.
                try:
                    self.spawn (["brcc32", "-fo", obj, src])
                except DistutilsExecError as msg:
                    raise CompileError(msg)
                continue # the 'for' loop

            # The next two are both for the real compiler.
            if ext in self._c_extensions:
                input_opt = ""
            elif ext in self._cpp_extensions:
                input_opt = "-P"
            else:
                # Unknown file type -- no extra options.  The compiler
                # will probably fail, but let it just in case this is a
                # file the compiler recognizes even if we don't.
                input_opt = ""

            output_opt = "-o" + obj

            # Compiler command line syntax is: "bcc32 [options] file(s)".
            # Note that the source file names must appear at the end of
            # the command line.
            try:
                self.spawn ([self.cc] + compile_opts + pp_opts +
                            [input_opt, output_opt] +
                            extra_postargs + [src])
            except DistutilsExecError as msg:
                raise CompileError(msg)

        return objects

    # compile ()


    def create_static_lib (self,
                           objects,
                           output_libname,
                           output_dir=None,
                           debug=0,
                           target_lang=None):

        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        output_filename = \
            self.library_filename (output_libname, output_dir=output_dir)

        if self._need_link (objects, output_filename):
            lib_args = [output_filename, '/u'] + objects
            if debug:
                pass                    # XXX what goes here?
            try:
                self.spawn ([self.lib] + lib_args)
            except DistutilsExecError as msg:
                raise LibError(msg)
        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # create_static_lib ()


    def link (self,
              target_desc,
              objects,
              output_filename,
              output_dir=None,
              libraries=None,
              library_dirs=None,
              runtime_library_dirs=None,
              export_symbols=None,
              debug=0,
              extra_preargs=None,
              extra_postargs=None,
              build_temp=None,
              target_lang=None):

        # XXX this ignores 'build_temp'!  should follow the lead of
        # msvccompiler.py

        (objects, output_dir) = self._fix_object_args (objects, output_dir)
        (libraries, library_dirs, runtime_library_dirs) = \
            self._fix_lib_args (libraries, library_dirs, runtime_library_dirs)

        if runtime_library_dirs:
            log.warn("I don't know what to do with 'runtime_library_dirs': %s",
                     str(runtime_library_dirs))

        if output_dir is not None:
            output_filename = os.path.join (output_dir, output_filename)

        if self._need_link (objects, output_filename):

            # Figure out linker args based on type of target.
            if target_desc == CCompiler.EXECUTABLE:
                startup_obj = 'c0w32'
                if debug:
                    ld_args = self.ldflags_exe_debug[:]
                else:
                    ld_args = self.ldflags_exe[:]
            else:
                startup_obj = 'c0d32'
                if debug:
                    ld_args = self.ldflags_shared_debug[:]
                else:
                    ld_args = self.ldflags_shared[:]


            # Create a temporary exports file for use by the linker
            if export_symbols is None:
                def_file = ''
            else:
                head, tail = os.path.split (output_filename)
                modname, ext = os.path.splitext (tail)
                temp_dir = os.path.dirname(objects[0]) # preserve tree structure
                def_file = os.path.join (temp_dir, '%s.def' % modname)
                contents = ['EXPORTS']
                for sym in (export_symbols or []):
                    contents.append('  %s=_%s' % (sym, sym))
                self.execute(write_file, (def_file, contents),
                             "writing %s" % def_file)

            # Borland C++ has problems with '/' in paths
            objects2 = map(os.path.normpath, objects)
            # split objects in .obj and .res files
            # Borland C++ needs them at different positions in the command line
            objects = [startup_obj]
            resources = []
            for file in objects2:
                (base, ext) = os.path.splitext(os.path.normcase(file))
                if ext == '.res':
                    resources.append(file)
                else:
                    objects.append(file)


            for l in library_dirs:
                ld_args.append("/L%s" % os.path.normpath(l))
            ld_args.append("/L.") # we sometimes use relative paths

            # list of object files
            ld_args.extend(objects)

            # XXX the command-line syntax for Borland C++ is a bit wonky;
            # certain filenames are jammed together in one big string, but
            # comma-delimited.  This doesn't mesh too well with the
            # Unix-centric attitude (with a DOS/Windows quoting hack) of
            # 'spawn()', so constructing the argument list is a bit
            # awkward.  Note that doing the obvious thing and jamming all
            # the filenames and commas into one argument would be wrong,
            # because 'spawn()' would quote any filenames with spaces in
            # them.  Arghghh!.  Apparently it works fine as coded...

            # name of dll/exe file
            ld_args.extend([',',output_filename])
            # no map file and start libraries
            ld_args.append(',,')

            for lib in libraries:
                # see if we find it and if there is a bcpp specific lib
                # (xxx_bcpp.lib)
                libfile = self.find_library_file(library_dirs, lib, debug)
                if libfile is None:
                    ld_args.append(lib)
                    # probably a BCPP internal library -- don't warn
                else:
                    # full name which prefers bcpp_xxx.lib over xxx.lib
                    ld_args.append(libfile)

            # some default libraries
            ld_args.append ('import32')
            ld_args.append ('cw32mt')

            # def file for export symbols
            ld_args.extend([',',def_file])
            # add resource files
            ld_args.append(',')
            ld_args.extend(resources)


            if extra_preargs:
                ld_args[:0] = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs)

            self.mkpath (os.path.dirname (output_filename))
            try:
                self.spawn ([self.linker] + ld_args)
            except DistutilsExecError as msg:
                raise LinkError(msg)

        else:
            log.debug("skipping %s (up-to-date)", output_filename)

    # link ()

    # -- Miscellaneous methods -----------------------------------------


    def find_library_file (self, dirs, lib, debug=0):
        # List of effective library names to try, in order of preference:
        # xxx_bcpp.lib is better than xxx.lib
        # and xxx_d.lib is better than xxx.lib if debug is set
        #
        # The "_bcpp" suffix is to handle a Python installation for people
        # with multiple compilers (primarily Distutils hackers, I suspect
        # ;-).  The idea is they'd have one static library for each
        # compiler they care about, since (almost?) every Windows compiler
        # seems to have a different format for static libraries.
        if debug:
            dlib = (lib + "_d")
            try_names = (dlib + "_bcpp", lib + "_bcpp", dlib, lib)
        else:
            try_names = (lib + "_bcpp", lib)

        for dir in dirs:
            for name in try_names:
                libfile = os.path.join(dir, self.library_filename(name))
                if os.path.exists(libfile):
                    return libfile
        else:
            # Oops, didn't find it in *any* of 'dirs'
            return None

    # overwrite the one from CCompiler to support rc and res-files
    def object_filenames (self,
                          source_filenames,
                          strip_dir=0,
                          output_dir=''):
        if output_dir is None: output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
            (base, ext) = os.path.splitext (os.path.normcase(src_name))
            if ext not in (self.src_extensions + ['.rc','.res']):
                raise UnknownFileError("unknown file type '%s' (from '%s')" % \
                      (ext, src_name))
            if strip_dir:
                base = os.path.basename (base)
            if ext == '.res':
                # these can go unchanged
                obj_names.append (os.path.join (output_dir, base + ext))
            elif ext == '.rc':
                # these need to be compiled to .res-files
                obj_names.append (os.path.join (output_dir, base + '.res'))
            else:
                obj_names.append (os.path.join (output_dir,
                                            base + self.obj_extension))
        return obj_names

    # object_filenames ()

    def preprocess (self,
                    source,
                    output_file=None,
                    macros=None,
                    include_dirs=None,
                    extra_preargs=None,
                    extra_postargs=None):

        (_, macros, include_dirs) = \
            self._fix_compile_args(None, macros, include_dirs)
        pp_opts = gen_preprocess_options(macros, include_dirs)
        pp_args = ['cpp32.exe'] + pp_opts
        if output_file is not None:
            pp_args.append('-o' + output_file)
        if extra_preargs:
            pp_args[:0] = extra_preargs
        if extra_postargs:
            pp_args.extend(extra_postargs)
        pp_args.append(source)

        # We need to preprocess: either we're being forced to, or the
        # source file is newer than the target (or the target doesn't
        # exist).
        if self.force or output_file is None or newer(source, output_file):
            if output_file:
                self.mkpath(os.path.dirname(output_file))
            try:
                self.spawn(pp_args)
            except DistutilsExecError as msg:
                print(msg)
                raise CompileError(msg)

    # preprocess()
                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python3.4/distutils/ccompiler.py                                                            0100644 0000000 0000000 00000134427 12415221640 016755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
for the Distutils compiler abstraction model."""

import sys, os, re
from distutils.errors import *
from distutils.spawn import spawn
from distutils.file_util import move_file
from distutils.dir_util import mkpath
from distutils.dep_util import newer_pairwise, newer_group
from distutils.util import split_quoted, execute
from distutils import log

class CCompiler:
    """Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The basic idea behind a compiler abstraction class is that each
    instance can be used for all the compile/link steps in building a
    single project.  Thus, attributes common to all of those compile and
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow for
    variability in how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link basis.
    """

    # 'compiler_type' is a class attribute that identifies this class.  It
    # keeps code that wants to know what kind of compiler it's dealing with
    # from having to import all possible compiler classes just to do an
    # 'isinstance'.  In concrete CCompiler subclasses, 'compiler_type'
    # should really, really be one of the keys of the 'compiler_class'
    # dictionary (see below -- used by the 'new_compiler()' factory
    # function) -- authors of new compiler interface classes are
    # responsible for updating 'compiler_class'!
    compiler_type = None

    # XXX things not handled by this compiler abstraction model:
    #   * client can't provide additional options for a compiler,
    #     e.g. warning, optimization, debugging flags.  Perhaps this
    #     should be the domain of concrete compiler abstraction classes
    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base
    #     class should have methods for the common ones.
    #   * can't completely override the include or library searchg
    #     path, ie. no "cc -I -Idir1 -Idir2" or "cc -L -Ldir1 -Ldir2".
    #     I'm not sure how widely supported this is even by Unix
    #     compilers, much less on other platforms.  And I'm even less
    #     sure how useful it is; maybe for cross-compiling, but
    #     support for that is a ways off.  (And anyways, cross
    #     compilers probably have a dedicated binary with the
    #     right paths compiled in.  I hope.)
    #   * can't do really freaky things with the library list/library
    #     dirs, e.g. "-Ldir1 -lfoo -Ldir2 -lfoo" to link against
    #     different versions of libfoo.a in different locations.  I
    #     think this is useless without the ability to null out the
    #     library search path anyways.


    # Subclasses that rely on the standard filename generation methods
    # implemented below should override these; see the comment near
    # those methods ('object_filenames()' et. al.) for details:
    src_extensions = None               # list of strings
    obj_extension = None                # string
    static_lib_extension = None
    shared_lib_extension = None         # string
    static_lib_format = None            # format string
    shared_lib_format = None            # prob. same as static_lib_format
    exe_extension = None                # string

    # Default language settings. language_map is used to detect a source
    # file or Extension target language, checking source filenames.
    # language_order is used to detect the language precedence, when deciding
    # what language to use when mixing source types. For example, if some
    # extension has two files with ".c" extension, and one with ".cpp", it
    # is still linked as c++.
    language_map = {".c"   : "c",
                    ".cc"  : "c++",
                    ".cpp" : "c++",
                    ".cxx" : "c++",
                    ".m"   : "objc",
                   }
    language_order = ["c++", "objc", "c"]

    def __init__(self, verbose=0, dry_run=0, force=0):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose

        # 'output_dir': a common output directory for object, library,
        # shared object, and shared library files
        self.output_dir = None

        # 'macros': a list of macro definitions (or undefinitions).  A
        # macro definition is a 2-tuple (name, value), where the value is
        # either a string or None (no explicit value).  A macro
        # undefinition is a 1-tuple (name,).
        self.macros = []

        # 'include_dirs': a list of directories to search for include files
        self.include_dirs = []

        # 'libraries': a list of libraries to include in any link
        # (library names, not filenames: eg. "foo" not "libfoo.a")
        self.libraries = []

        # 'library_dirs': a list of directories to search for libraries
        self.library_dirs = []

        # 'runtime_library_dirs': a list of directories to search for
        # shared libraries/objects at runtime
        self.runtime_library_dirs = []

        # 'objects': a list of object files (or similar, such as explicitly
        # named library files) to include on any link
        self.objects = []

        for key in self.executables.keys():
            self.set_executable(key, self.executables[key])

    def set_executables(self, **kwargs):
        """Define the executables (and options for them) that will be run
        to perform the various stages of compilation.  The exact set of
        executables that may be specified here depends on the compiler
        class (via the 'executables' class attribute), but most will have:
          compiler      the C/C++ compiler
          linker_so     linker used to create shared objects and libraries
          linker_exe    linker used to create binary executables
          archiver      static library creator

        On platforms with a command-line (Unix, DOS/Windows), each of these
        is a string that will be split into executable name and (optional)
        list of arguments.  (Splitting the string is done similarly to how
        Unix shells operate: words are delimited by spaces, but quotes and
        backslashes can override this.  See
        'distutils.util.split_quoted()'.)
        """

        # Note that some CCompiler implementation classes will define class
        # attributes 'cpp', 'cc', etc. with hard-coded executable names;
        # this is appropriate when a compiler class is for exactly one
        # compiler/OS combination (eg. MSVCCompiler).  Other compiler
        # classes (UnixCCompiler, in particular) are driven by information
        # discovered at run-time, since there are many different ways to do
        # basically the same things with Unix C compilers.

        for key in kwargs:
            if key not in self.executables:
                raise ValueError("unknown executable '%s' for class %s" %
                      (key, self.__class__.__name__))
            self.set_executable(key, kwargs[key])

    def set_executable(self, key, value):
        if isinstance(value, str):
            setattr(self, key, split_quoted(value))
        else:
            setattr(self, key, value)

    def _find_macro(self, name):
        i = 0
        for defn in self.macros:
            if defn[0] == name:
                return i
            i += 1
        return None

    def _check_macro_definitions(self, definitions):
        """Ensures that every element of 'definitions' is a valid macro
        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do
        nothing if all definitions are OK, raise TypeError otherwise.
        """
        for defn in definitions:
            if not (isinstance(defn, tuple) and
                    (len(defn) in (1, 2) and
                      (isinstance (defn[1], str) or defn[1] is None)) and
                    isinstance (defn[0], str)):
                raise TypeError(("invalid macro definition '%s': " % defn) + \
                      "must be tuple (string,), (string, string), or " + \
                      "(string, None)")


    # -- Bookkeeping methods -------------------------------------------

    def define_macro(self, name, value=None):
        """Define a preprocessor macro for all compilations driven by this
        compiler object.  The optional parameter 'value' should be a
        string; if it is not supplied, then the macro will be defined
        without an explicit value and the exact outcome depends on the
        compiler used (XXX true? does ANSI say anything about this?)
        """
        # Delete from the list of macro definitions/undefinitions if
        # already there (so that this one will take precedence).
        i = self._find_macro (name)
        if i is not None:
            del self.macros[i]

        self.macros.append((name, value))

    def undefine_macro(self, name):
        """Undefine a preprocessor macro for all compilations driven by
        this compiler object.  If the same macro is defined by
        'define_macro()' and undefined by 'undefine_macro()' the last call
        takes precedence (including multiple redefinitions or
        undefinitions).  If the macro is redefined/undefined on a
        per-compilation basis (ie. in the call to 'compile()'), then that
        takes precedence.
        """
        # Delete from the list of macro definitions/undefinitions if
        # already there (so that this one will take precedence).
        i = self._find_macro (name)
        if i is not None:
            del self.macros[i]

        undefn = (name,)
        self.macros.append(undefn)

    def add_include_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        header files.  The compiler is instructed to search directories in
        the order in which they are supplied by successive calls to
        'add_include_dir()'.
        """
        self.include_dirs.append(dir)

    def set_include_dirs(self, dirs):
        """Set the list of directories that will be searched to 'dirs' (a
        list of strings).  Overrides any preceding calls to
        'add_include_dir()'; subsequence calls to 'add_include_dir()' add
        to the list passed to 'set_include_dirs()'.  This does not affect
        any list of standard include directories that the compiler may
        search by default.
        """
        self.include_dirs = dirs[:]

    def add_library(self, libname):
        """Add 'libname' to the list of libraries that will be included in
        all links driven by this compiler object.  Note that 'libname'
        should *not* be the name of a file containing a library, but the
        name of the library itself: the actual filename will be inferred by
        the linker, the compiler, or the compiler class (depending on the
        platform).

        The linker will be instructed to link against libraries in the
        order they were supplied to 'add_library()' and/or
        'set_libraries()'.  It is perfectly valid to duplicate library
        names; the linker will be instructed to link against libraries as
        many times as they are mentioned.
        """
        self.libraries.append(libname)

    def set_libraries(self, libnames):
        """Set the list of libraries to be included in all links driven by
        this compiler object to 'libnames' (a list of strings).  This does
        not affect any standard system libraries that the linker may
        include by default.
        """
        self.libraries = libnames[:]

    def add_library_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        libraries specified to 'add_library()' and 'set_libraries()'.  The
        linker will be instructed to search for libraries in the order they
        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.
        """
        self.library_dirs.append(dir)

    def set_library_dirs(self, dirs):
        """Set the list of library search directories to 'dirs' (a list of
        strings).  This does not affect any standard library search path
        that the linker may search by default.
        """
        self.library_dirs = dirs[:]

    def add_runtime_library_dir(self, dir):
        """Add 'dir' to the list of directories that will be searched for
        shared libraries at runtime.
        """
        self.runtime_library_dirs.append(dir)

    def set_runtime_library_dirs(self, dirs):
        """Set the list of directories to search for shared libraries at
        runtime to 'dirs' (a list of strings).  This does not affect any
        standard search path that the runtime linker may search by
        default.
        """
        self.runtime_library_dirs = dirs[:]

    def add_link_object(self, object):
        """Add 'object' to the list of object files (or analogues, such as
        explicitly named library files or the output of "resource
        compilers") to be included in every link driven by this compiler
        object.
        """
        self.objects.append(object)

    def set_link_objects(self, objects):
        """Set the list of object files (or analogues) to be included in
        every link to 'objects'.  This does not affect any standard object
        files that the linker may include by default (such as system
        libraries).
        """
        self.objects = objects[:]


    # -- Private utility methods --------------------------------------
    # (here for the convenience of subclasses)

    # Helper method to prep compiler in subclass compile() methods

    def _setup_compile(self, outdir, macros, incdirs, sources, depends,
                       extra):
        """Process arguments and decide which source files to compile."""
        if outdir is None:
            outdir = self.output_dir
        elif not isinstance(outdir, str):
            raise TypeError("'output_dir' must be a string or None")

        if macros is None:
            macros = self.macros
        elif isinstance(macros, list):
            macros = macros + (self.macros or [])
        else:
            raise TypeError("'macros' (if supplied) must be a list of tuples")

        if incdirs is None:
            incdirs = self.include_dirs
        elif isinstance(incdirs, (list, tuple)):
            incdirs = list(incdirs) + (self.include_dirs or [])
        else:
            raise TypeError(
                  "'include_dirs' (if supplied) must be a list of strings")

        if extra is None:
            extra = []

        # Get the list of expected output (object) files
        objects = self.object_filenames(sources, strip_dir=0,
                                        output_dir=outdir)
        assert len(objects) == len(sources)

        pp_opts = gen_preprocess_options(macros, incdirs)

        build = {}
        for i in range(len(sources)):
            src = sources[i]
            obj = objects[i]
            ext = os.path.splitext(src)[1]
            self.mkpath(os.path.dirname(obj))
            build[obj] = (src, ext)

        return macros, objects, extra, pp_opts, build

    def _get_cc_args(self, pp_opts, debug, before):
        # works for unixccompiler, cygwinccompiler
        cc_args = pp_opts + ['-c']
        if debug:
            cc_args[:0] = ['-g']
        if before:
            cc_args[:0] = before
        return cc_args

    def _fix_compile_args(self, output_dir, macros, include_dirs):
        """Typecheck and fix-up some of the arguments to the 'compile()'
        method, and return fixed-up values.  Specifically: if 'output_dir'
        is None, replaces it with 'self.output_dir'; ensures that 'macros'
        is a list, and augments it with 'self.macros'; ensures that
        'include_dirs' is a list, and augments it with 'self.include_dirs'.
        Guarantees that the returned values are of the correct type,
        i.e. for 'output_dir' either string or None, and for 'macros' and
        'include_dirs' either list or None.
        """
        if output_dir is None:
            output_dir = self.output_dir
        elif not isinstance(output_dir, str):
            raise TypeError("'output_dir' must be a string or None")

        if macros is None:
            macros = self.macros
        elif isinstance(macros, list):
            macros = macros + (self.macros or [])
        else:
            raise TypeError("'macros' (if supplied) must be a list of tuples")

        if include_dirs is None:
            include_dirs = self.include_dirs
        elif isinstance(include_dirs, (list, tuple)):
            include_dirs = list(include_dirs) + (self.include_dirs or [])
        else:
            raise TypeError(
                  "'include_dirs' (if supplied) must be a list of strings")

        return output_dir, macros, include_dirs

    def _prep_compile(self, sources, output_dir, depends=None):
        """Decide which souce files must be recompiled.

        Determine the list of object files corresponding to 'sources',
        and figure out which ones really need to be recompiled.
        Return a list of all object files and a dictionary telling
        which source files can be skipped.
        """
        # Get the list of expected output (object) files
        objects = self.object_filenames(sources, output_dir=output_dir)
        assert len(objects) == len(sources)

        # Return an empty dict for the "which source files can be skipped"
        # return value to preserve API compatibility.
        return objects, {}

    def _fix_object_args(self, objects, output_dir):
        """Typecheck and fix up some arguments supplied to various methods.
        Specifically: ensure that 'objects' is a list; if output_dir is
        None, replace with self.output_dir.  Return fixed versions of
        'objects' and 'output_dir'.
        """
        if not isinstance(objects, (list, tuple)):
            raise TypeError("'objects' must be a list or tuple of strings")
        objects = list(objects)

        if output_dir is None:
            output_dir = self.output_dir
        elif not isinstance(output_dir, str):
            raise TypeError("'output_dir' must be a string or None")

        return (objects, output_dir)

    def _fix_lib_args(self, libraries, library_dirs, runtime_library_dirs):
        """Typecheck and fix up some of the arguments supplied to the
        'link_*' methods.  Specifically: ensure that all arguments are
        lists, and augment them with their permanent versions
        (eg. 'self.libraries' augments 'libraries').  Return a tuple with
        fixed versions of all arguments.
        """
        if libraries is None:
            libraries = self.libraries
        elif isinstance(libraries, (list, tuple)):
            libraries = list (libraries) + (self.libraries or [])
        else:
            raise TypeError(
                  "'libraries' (if supplied) must be a list of strings")

        if library_dirs is None:
            library_dirs = self.library_dirs
        elif isinstance(library_dirs, (list, tuple)):
            library_dirs = list (library_dirs) + (self.library_dirs or [])
        else:
            raise TypeError(
                  "'library_dirs' (if supplied) must be a list of strings")

        if runtime_library_dirs is None:
            runtime_library_dirs = self.runtime_library_dirs
        elif isinstance(runtime_library_dirs, (list, tuple)):
            runtime_library_dirs = (list(runtime_library_dirs) +
                                    (self.runtime_library_dirs or []))
        else:
            raise TypeError("'runtime_library_dirs' (if supplied) "
                            "must be a list of strings")

        return (libraries, library_dirs, runtime_library_dirs)

    def _need_link(self, objects, output_file):
        """Return true if we need to relink the files listed in 'objects'
        to recreate 'output_file'.
        """
        if self.force:
            return True
        else:
            if self.dry_run:
                newer = newer_group (objects, output_file, missing='newer')
            else:
                newer = newer_group (objects, output_file)
            return newer

    def detect_language(self, sources):
        """Detect the language of a given file, or list of files. Uses
        language_map, and language_order to do the job.
        """
        if not isinstance(sources, list):
            sources = [sources]
        lang = None
        index = len(self.language_order)
        for source in sources:
            base, ext = os.path.splitext(source)
            extlang = self.language_map.get(ext)
            try:
                extindex = self.language_order.index(extlang)
                if extindex < index:
                    lang = extlang
                    index = extindex
            except ValueError:
                pass
        return lang


    # -- Worker methods ------------------------------------------------
    # (must be implemented by subclasses)

    def preprocess(self, source, output_file=None, macros=None,
                   include_dirs=None, extra_preargs=None, extra_postargs=None):
        """Preprocess a single C/C++ source file, named in 'source'.
        Output will be written to file named 'output_file', or stdout if
        'output_file' not supplied.  'macros' is a list of macro
        definitions as for 'compile()', which will augment the macros set
        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a
        list of directory names that will be added to the default list.

        Raises PreprocessError on failure.
        """
        pass

    def compile(self, sources, output_dir=None, macros=None,
                include_dirs=None, debug=0, extra_preargs=None,
                extra_postargs=None, depends=None):
        """Compile one or more source files.

        'sources' must be a list of filenames, most likely C/C++
        files, but in reality anything that can be handled by a
        particular compiler and compiler class (eg. MSVCCompiler can
        handle resource files in 'sources').  Return a list of object
        filenames, one per source filename in 'sources'.  Depending on
        the implementation, not all source files will necessarily be
        compiled, but all corresponding object filenames will be
        returned.

        If 'output_dir' is given, object files will be put under it, while
        retaining their original path component.  That is, "foo/bar.c"
        normally compiles to "foo/bar.o" (for a Unix implementation); if
        'output_dir' is "build", then it would compile to
        "build/foo/bar.o".

        'macros', if given, must be a list of macro definitions.  A macro
        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.
        The former defines a macro; if the value is None, the macro is
        defined without an explicit value.  The 1-tuple case undefines a
        macro.  Later definitions/redefinitions/ undefinitions take
        precedence.

        'include_dirs', if given, must be a list of strings, the
        directories to add to the default include file search path for this
        compilation only.

        'debug' is a boolean; if true, the compiler will be instructed to
        output debug symbols in (or alongside) the object file(s).

        'extra_preargs' and 'extra_postargs' are implementation- dependent.
        On platforms that have the notion of a command-line (e.g. Unix,
        DOS/Windows), they are most likely lists of strings: extra
        command-line arguments to prepand/append to the compiler command
        line.  On other platforms, consult the implementation class
        documentation.  In any event, they are intended as an escape hatch
        for those occasions when the abstract compiler framework doesn't
        cut the mustard.

        'depends', if given, is a list of filenames that all targets
        depend on.  If a source file is older than any file in
        depends, then the source file will be recompiled.  This
        supports dependency tracking, but only at a coarse
        granularity.

        Raises CompileError on failure.
        """
        # A concrete compiler class can either override this method
        # entirely or implement _compile().
        macros, objects, extra_postargs, pp_opts, build = \
                self._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)
        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)

        for obj in objects:
            try:
                src, ext = build[obj]
            except KeyError:
                continue
            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)

        # Return *all* object filenames, not just the ones we just built.
        return objects

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
        """Compile 'src' to product 'obj'."""
        # A concrete compiler class that does not override compile()
        # should implement _compile().
        pass

    def create_static_lib(self, objects, output_libname, output_dir=None,
                          debug=0, target_lang=None):
        """Link a bunch of stuff together to create a static library file.
        The "bunch of stuff" consists of the list of object files supplied
        as 'objects', the extra object files supplied to
        'add_link_object()' and/or 'set_link_objects()', the libraries
        supplied to 'add_library()' and/or 'set_libraries()', and the
        libraries supplied as 'libraries' (if any).

        'output_libname' should be a library name, not a filename; the
        filename will be inferred from the library name.  'output_dir' is
        the directory where the library file will be put.

        'debug' is a boolean; if true, debugging information will be
        included in the library (note that on most platforms, it is the
        compile step where this matters: the 'debug' flag is included here
        just for consistency).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LibError on failure.
        """
        pass


    # values for target_desc parameter in link()
    SHARED_OBJECT = "shared_object"
    SHARED_LIBRARY = "shared_library"
    EXECUTABLE = "executable"

    def link(self,
             target_desc,
             objects,
             output_filename,
             output_dir=None,
             libraries=None,
             library_dirs=None,
             runtime_library_dirs=None,
             export_symbols=None,
             debug=0,
             extra_preargs=None,
             extra_postargs=None,
             build_temp=None,
             target_lang=None):
        """Link a bunch of stuff together to create an executable or
        shared library file.

        The "bunch of stuff" consists of the list of object files supplied
        as 'objects'.  'output_filename' should be a filename.  If
        'output_dir' is supplied, 'output_filename' is relative to it
        (i.e. 'output_filename' can provide directory components if
        needed).

        'libraries' is a list of libraries to link against.  These are
        library names, not filenames, since they're translated into
        filenames in a platform-specific way (eg. "foo" becomes "libfoo.a"
        on Unix and "foo.lib" on DOS/Windows).  However, they can include a
        directory component, which means the linker will look in that
        specific directory rather than searching all the normal locations.

        'library_dirs', if supplied, should be a list of directories to
        search for libraries that were specified as bare library names
        (ie. no directory component).  These are on top of the system
        default and those supplied to 'add_library_dir()' and/or
        'set_library_dirs()'.  'runtime_library_dirs' is a list of
        directories that will be embedded into the shared library and used
        to search for other shared libraries that *it* depends on at
        run-time.  (This may only be relevant on Unix.)

        'export_symbols' is a list of symbols that the shared library will
        export.  (This appears to be relevant only on Windows.)

        'debug' is as for 'compile()' and 'create_static_lib()', with the
        slight distinction that it actually matters on most platforms (as
        opposed to 'create_static_lib()', which includes a 'debug' flag
        mostly for form's sake).

        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except
        of course that they supply command-line arguments for the
        particular linker being used).

        'target_lang' is the target language for which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LinkError on failure.
        """
        raise NotImplementedError


    # Old 'link_*()' methods, rewritten to use the new 'link()' method.

    def link_shared_lib(self,
                        objects,
                        output_libname,
                        output_dir=None,
                        libraries=None,
                        library_dirs=None,
                        runtime_library_dirs=None,
                        export_symbols=None,
                        debug=0,
                        extra_preargs=None,
                        extra_postargs=None,
                        build_temp=None,
                        target_lang=None):
        self.link(CCompiler.SHARED_LIBRARY, objects,
                  self.library_filename(output_libname, lib_type='shared'),
                  output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)


    def link_shared_object(self,
                           objects,
                           output_filename,
                           output_dir=None,
                           libraries=None,
                           library_dirs=None,
                           runtime_library_dirs=None,
                           export_symbols=None,
                           debug=0,
                           extra_preargs=None,
                           extra_postargs=None,
                           build_temp=None,
                           target_lang=None):
        self.link(CCompiler.SHARED_OBJECT, objects,
                  output_filename, output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)


    def link_executable(self,
                        objects,
                        output_progname,
                        output_dir=None,
                        libraries=None,
                        library_dirs=None,
                        runtime_library_dirs=None,
                        debug=0,
                        extra_preargs=None,
                        extra_postargs=None,
                        target_lang=None):
        self.link(CCompiler.EXECUTABLE, objects,
                  self.executable_filename(output_progname), output_dir,
                  libraries, library_dirs, runtime_library_dirs, None,
                  debug, extra_preargs, extra_postargs, None, target_lang)


    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_options() function; there is
    # no appropriate default implementation so subclasses should
    # implement all of these.

    def library_dir_option(self, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched for libraries.
        """
        raise NotImplementedError

    def runtime_library_dir_option(self, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched for runtime libraries.
        """
        raise NotImplementedError

    def library_option(self, lib):
        """Return the compiler option to add 'dir' to the list of libraries
        linked into the shared library or executable.
        """
        raise NotImplementedError

    def has_function(self, funcname, includes=None, include_dirs=None,
                     libraries=None, library_dirs=None):
        """Return a boolean indicating whether funcname is supported on
        the current platform.  The optional arguments can be used to
        augment the compilation environment.
        """
        # this can't be included at module scope because it tries to
        # import math which might not be available at that point - maybe
        # the necessary logic should just be inlined?
        import tempfile
        if includes is None:
            includes = []
        if include_dirs is None:
            include_dirs = []
        if libraries is None:
            libraries = []
        if library_dirs is None:
            library_dirs = []
        fd, fname = tempfile.mkstemp(".c", funcname, text=True)
        f = os.fdopen(fd, "w")
        try:
            for incl in includes:
                f.write("""#include "%s"\n""" % incl)
            f.write("""\
main (int argc, char **argv) {
    %s();
}
""" % funcname)
        finally:
            f.close()
        try:
            objects = self.compile([fname], include_dirs=include_dirs)
        except CompileError:
            return False

        try:
            self.link_executable(objects, "a.out",
                                 libraries=libraries,
                                 library_dirs=library_dirs)
        except (LinkError, TypeError):
            return False
        return True

    def find_library_file (self, dirs, lib, debug=0):
        """Search the specified list of directories for a static or shared
        library file 'lib' and return the full path to that file.  If
        'debug' true, look for a debugging version (if that makes sense on
        the current platform).  Return None if 'lib' wasn't found in any of
        the specified directories.
        """
        raise NotImplementedError

    # -- Filename generation methods -----------------------------------

    # The default implementation of the filename generating methods are
    # prejudiced towards the Unix/DOS/Windows view of the world:
    #   * object files are named by replacing the source file extension
    #     (eg. .c/.cpp -> .o/.obj)
    #   * library files (shared or static) are named by plugging the
    #     library name and extension into a format string, eg.
    #     "lib%s.%s" % (lib_name, ".a") for Unix static libraries
    #   * executables are named by appending an extension (possibly
    #     empty) to the program name: eg. progname + ".exe" for
    #     Windows
    #
    # To reduce redundant code, these methods expect to find
    # several attributes in the current object (presumably defined
    # as class attributes):
    #   * src_extensions -
    #     list of C/C++ source file extensions, eg. ['.c', '.cpp']
    #   * obj_extension -
    #     object file extension, eg. '.o' or '.obj'
    #   * static_lib_extension -
    #     extension for static library files, eg. '.a' or '.lib'
    #   * shared_lib_extension -
    #     extension for shared library/object files, eg. '.so', '.dll'
    #   * static_lib_format -
    #     format string for generating static library filenames,
    #     eg. 'lib%s.%s' or '%s.%s'
    #   * shared_lib_format
    #     format string for generating shared library filenames
    #     (probably same as static_lib_format, since the extension
    #     is one of the intended parameters to the format string)
    #   * exe_extension -
    #     extension for executable files, eg. '' or '.exe'

    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
        if output_dir is None:
            output_dir = ''
        obj_names = []
        for src_name in source_filenames:
            base, ext = os.path.splitext(src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            if ext not in self.src_extensions:
                raise UnknownFileError(
                      "unknown file type '%s' (from '%s')" % (ext, src_name))
            if strip_dir:
                base = os.path.basename(base)
            obj_names.append(os.path.join(output_dir,
                                          base + self.obj_extension))
        return obj_names

    def shared_object_filename(self, basename, strip_dir=0, output_dir=''):
        assert output_dir is not None
        if strip_dir:
            basename = os.path.basename(basename)
        return os.path.join(output_dir, basename + self.shared_lib_extension)

    def executable_filename(self, basename, strip_dir=0, output_dir=''):
        assert output_dir is not None
        if strip_dir:
            basename = os.path.basename(basename)
        return os.path.join(output_dir, basename + (self.exe_extension or ''))

    def library_filename(self, libname, lib_type='static',     # or 'shared'
                         strip_dir=0, output_dir=''):
        assert output_dir is not None
        if lib_type not in ("static", "shared", "dylib"):
            raise ValueError(
                  "'lib_type' must be \"static\", \"shared\" or \"dylib\"")
        fmt = getattr(self, lib_type + "_lib_format")
        ext = getattr(self, lib_type + "_lib_extension")

        dir, base = os.path.split(libname)
        filename = fmt % (base, ext)
        if strip_dir:
            dir = ''

        return os.path.join(output_dir, dir, filename)


    # -- Utility methods -----------------------------------------------

    def announce(self, msg, level=1):
        log.debug(msg)

    def debug_print(self, msg):
        from distutils.debug import DEBUG
        if DEBUG:
            print(msg)

    def warn(self, msg):
        sys.stderr.write("warning: %s\n" % msg)

    def execute(self, func, args, msg=None, level=1):
        execute(func, args, msg, self.dry_run)

    def spawn(self, cmd):
        spawn(cmd, dry_run=self.dry_run)

    def move_file(self, src, dst):
        return move_file(src, dst, dry_run=self.dry_run)

    def mkpath (self, name, mode=0o777):
        mkpath(name, mode, dry_run=self.dry_run)


# Map a sys.platform/os.name ('posix', 'nt') to the default compiler
# type for that platform. Keys are interpreted as re match
# patterns. Order is important; platform mappings are preferred over
# OS names.
_default_compilers = (

    # Platform string mappings

    # on a cygwin built python we can use gcc like an ordinary UNIXish
    # compiler
    ('cygwin.*', 'unix'),

    # OS name mappings
    ('posix', 'unix'),
    ('nt', 'msvc'),

    )

def get_default_compiler(osname=None, platform=None):
    """Determine the default compiler to use for the given platform.

       osname should be one of the standard Python OS names (i.e. the
       ones returned by os.name) and platform the common value
       returned by sys.platform for the platform in question.

       The default values are os.name and sys.platform in case the
       parameters are not given.
    """
    if osname is None:
        osname = os.name
    if platform is None:
        platform = sys.platform
    for pattern, compiler in _default_compilers:
        if re.match(pattern, platform) is not None or \
           re.match(pattern, osname) is not None:
            return compiler
    # Default to Unix compiler
    return 'unix'

# Map compiler types to (module_name, class_name) pairs -- ie. where to
# find the code that implements an interface to this compiler.  (The module
# is assumed to be in the 'distutils' package.)
compiler_class = { 'unix':    ('unixccompiler', 'UnixCCompiler',
                               "standard UNIX-style compiler"),
                   'msvc':    ('msvccompiler', 'MSVCCompiler',
                               "Microsoft Visual C++"),
                   'cygwin':  ('cygwinccompiler', 'CygwinCCompiler',
                               "Cygwin port of GNU C Compiler for Win32"),
                   'mingw32': ('cygwinccompiler', 'Mingw32CCompiler',
                               "Mingw32 port of GNU C Compiler for Win32"),
                   'bcpp':    ('bcppcompiler', 'BCPPCompiler',
                               "Borland C++ Compiler"),
                 }

def show_compilers():
    """Print list of available compilers (used by the "--help-compiler"
    options to "build", "build_ext", "build_clib").
    """
    # XXX this "knows" that the compiler option it's describing is
    # "--compiler", which just happens to be the case for the three
    # commands that use it.
    from distutils.fancy_getopt import FancyGetopt
    compilers = []
    for compiler in compiler_class.keys():
        compilers.append(("compiler="+compiler, None,
                          compiler_class[compiler][2]))
    compilers.sort()
    pretty_printer = FancyGetopt(compilers)
    pretty_printer.print_help("List of available compilers:")


def new_compiler(plat=None, compiler=None, verbose=0, dry_run=0, force=0):
    """Generate an instance of some CCompiler subclass for the supplied
    platform/compiler combination.  'plat' defaults to 'os.name'
    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler
    for that platform.  Currently only 'posix' and 'nt' are supported, and
    the default compilers are "traditional Unix interface" (UnixCCompiler
    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly
    possible to ask for a Unix compiler object under Windows, and a
    Microsoft compiler object under Unix -- if you supply a value for
    'compiler', 'plat' is ignored.
    """
    if plat is None:
        plat = os.name

    try:
        if compiler is None:
            compiler = get_default_compiler(plat)

        (module_name, class_name, long_description) = compiler_class[compiler]
    except KeyError:
        msg = "don't know how to compile C/C++ code on platform '%s'" % plat
        if compiler is not None:
            msg = msg + " with '%s' compiler" % compiler
        raise DistutilsPlatformError(msg)

    try:
        module_name = "distutils." + module_name
        __import__ (module_name)
        module = sys.modules[module_name]
        klass = vars(module)[class_name]
    except ImportError:
        raise DistutilsModuleError(
              "can't compile C/C++ code: unable to load module '%s'" % \
              module_name)
    except KeyError:
        raise DistutilsModuleError(
               "can't compile C/C++ code: unable to find class '%s' "
               "in module '%s'" % (class_name, module_name))

    # XXX The None is necessary to preserve backwards compatibility
    # with classes that expect verbose to be the first positional
    # argument.
    return klass(None, dry_run, force)


def gen_preprocess_options(macros, include_dirs):
    """Generate C pre-processor options (-D, -U, -I) as used by at least
    two types of compilers: the typical Unix compiler and Visual C++.
    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)
    means undefine (-U) macro 'name', and (name,value) means define (-D)
    macro 'name' to 'value'.  'include_dirs' is just a list of directory
    names to be added to the header file search path (-I).  Returns a list
    of command-line options suitable for either Unix compilers or Visual
    C++.
    """
    # XXX it would be nice (mainly aesthetic, and so we don't generate
    # stupid-looking command lines) to go over 'macros' and eliminate
    # redundant definitions/undefinitions (ie. ensure that only the
    # latest mention of a particular macro winds up on the command
    # line).  I don't think it's essential, though, since most (all?)
    # Unix C compilers only pay attention to the latest -D or -U
    # mention of a macro on their command line.  Similar situation for
    # 'include_dirs'.  I'm punting on both for now.  Anyways, weeding out
    # redundancies like this should probably be the province of
    # CCompiler, since the data structures used are inherited from it
    # and therefore common to all CCompiler classes.
    pp_opts = []
    for macro in macros:
        if not (isinstance(macro, tuple) and 1 <= len(macro) <= 2):
            raise TypeError(
                  "bad macro definition '%s': "
                  "each element of 'macros' list must be a 1- or 2-tuple"
                  % macro)

        if len(macro) == 1:        # undefine this macro
            pp_opts.append("-U%s" % macro[0])
        elif len(macro) == 2:
            if macro[1] is None:    # define with no explicit value
                pp_opts.append("-D%s" % macro[0])
            else:
                # XXX *don't* need to be clever about quoting the
                # macro value here, because we're going to avoid the
                # shell at all costs when we spawn the command!
                pp_opts.append("-D%s=%s" % macro)

    for dir in include_dirs:
        pp_opts.append("-I%s" % dir)
    return pp_opts


def gen_lib_options (compiler, library_dirs, runtime_library_dirs, libraries):
    """Generate linker options for searching library directories and
    linking with specific libraries.  'libraries' and 'library_dirs' are,
    respectively, lists of library names (not filenames!) and search
    directories.  Returns a list of command-line options suitable for use
    with some compiler (depending on the two format strings passed in).
    """
    lib_opts = []

    for dir in library_dirs:
        lib_opts.append(compiler.library_dir_option(dir))

    for dir in runtime_library_dirs:
        opt = compiler.runtime_library_dir_option(dir)
        if isinstance(opt, list):
            lib_opts = lib_opts + opt
        else:
            lib_opts.append(opt)

    # XXX it's important that we *not* remove redundant library mentions!
    # sometimes you really do have to say "-lfoo -lbar -lfoo" in order to
    # resolve all symbols.  I just hope we never have to say "-lfoo obj.o
    # -lbar" to get things to work -- that's certainly a possibility, but a
    # pretty nasty way to arrange your C code.

    for lib in libraries:
        (lib_dir, lib_name) = os.path.split(lib)
        if lib_dir:
            lib_file = compiler.find_library_file([lib_dir], lib_name)
            if lib_file:
                lib_opts.append(lib_file)
            else:
                compiler.warn("no library file corresponding to "
                              "'%s' found (skipping)" % lib)
        else:
            lib_opts.append(compiler.library_option (lib))
    return lib_opts
                                                                                                                                                                                                                                         usr/lib/python3.4/distutils/cmd.py                                                                  0100644 0000000 0000000 00000045313 12415221640 015536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.cmd

Provides the Command class, the base class for the command classes
in the distutils.command package.
"""

import sys, os, re
from distutils.errors import DistutilsOptionError
from distutils import util, dir_util, file_util, archive_util, dep_util
from distutils import log

class Command:
    """Abstract base class for defining command classes, the "worker bees"
    of the Distutils.  A useful analogy for command classes is to think of
    them as subroutines with local variables called "options".  The options
    are "declared" in 'initialize_options()' and "defined" (given their
    final values, aka "finalized") in 'finalize_options()', both of which
    must be defined by every command class.  The distinction between the
    two is necessary because option values might come from the outside
    world (command line, config file, ...), and any options dependent on
    other options must be computed *after* these outside influences have
    been processed -- hence 'finalize_options()'.  The "body" of the
    subroutine, where it does all its work based on the values of its
    options, is the 'run()' method, which must also be implemented by every
    command class.
    """

    # 'sub_commands' formalizes the notion of a "family" of commands,
    # eg. "install" as the parent with sub-commands "install_lib",
    # "install_headers", etc.  The parent of a family of commands
    # defines 'sub_commands' as a class attribute; it's a list of
    #    (command_name : string, predicate : unbound_method | string | None)
    # tuples, where 'predicate' is a method of the parent command that
    # determines whether the corresponding command is applicable in the
    # current situation.  (Eg. we "install_headers" is only applicable if
    # we have any C header files to install.)  If 'predicate' is None,
    # that command is always applicable.
    #
    # 'sub_commands' is usually defined at the *end* of a class, because
    # predicates can be unbound methods, so they must already have been
    # defined.  The canonical example is the "install" command.
    sub_commands = []


    # -- Creation/initialization methods -------------------------------

    def __init__(self, dist):
        """Create and initialize a new Command object.  Most importantly,
        invokes the 'initialize_options()' method, which is the real
        initializer and depends on the actual command being
        instantiated.
        """
        # late import because of mutual dependence between these classes
        from distutils.dist import Distribution

        if not isinstance(dist, Distribution):
            raise TypeError("dist must be a Distribution instance")
        if self.__class__ is Command:
            raise RuntimeError("Command is an abstract class")

        self.distribution = dist
        self.initialize_options()

        # Per-command versions of the global flags, so that the user can
        # customize Distutils' behaviour command-by-command and let some
        # commands fall back on the Distribution's behaviour.  None means
        # "not defined, check self.distribution's copy", while 0 or 1 mean
        # false and true (duh).  Note that this means figuring out the real
        # value of each flag is a touch complicated -- hence "self._dry_run"
        # will be handled by __getattr__, below.
        # XXX This needs to be fixed.
        self._dry_run = None

        # verbose is largely ignored, but needs to be set for
        # backwards compatibility (I think)?
        self.verbose = dist.verbose

        # Some commands define a 'self.force' option to ignore file
        # timestamps, but methods defined *here* assume that
        # 'self.force' exists for all commands.  So define it here
        # just to be safe.
        self.force = None

        # The 'help' flag is just used for command-line parsing, so
        # none of that complicated bureaucracy is needed.
        self.help = 0

        # 'finalized' records whether or not 'finalize_options()' has been
        # called.  'finalize_options()' itself should not pay attention to
        # this flag: it is the business of 'ensure_finalized()', which
        # always calls 'finalize_options()', to respect/update it.
        self.finalized = 0

    # XXX A more explicit way to customize dry_run would be better.
    def __getattr__(self, attr):
        if attr == 'dry_run':
            myval = getattr(self, "_" + attr)
            if myval is None:
                return getattr(self.distribution, attr)
            else:
                return myval
        else:
            raise AttributeError(attr)

    def ensure_finalized(self):
        if not self.finalized:
            self.finalize_options()
        self.finalized = 1

    # Subclasses must define:
    #   initialize_options()
    #     provide default values for all options; may be customized by
    #     setup script, by options from config file(s), or by command-line
    #     options
    #   finalize_options()
    #     decide on the final values for all options; this is called
    #     after all possible intervention from the outside world
    #     (command-line, option file, etc.) has been processed
    #   run()
    #     run the command: do whatever it is we're here to do,
    #     controlled by the command's various option values

    def initialize_options(self):
        """Set default values for all the options that this command
        supports.  Note that these defaults may be overridden by other
        commands, by the setup script, by config files, or by the
        command-line.  Thus, this is not the place to code dependencies
        between options; generally, 'initialize_options()' implementations
        are just a bunch of "self.foo = None" assignments.

        This method must be implemented by all command classes.
        """
        raise RuntimeError("abstract method -- subclass %s must override"
                           % self.__class__)

    def finalize_options(self):
        """Set final values for all the options that this command supports.
        This is always called as late as possible, ie.  after any option
        assignments from the command-line or from other commands have been
        done.  Thus, this is the place to code option dependencies: if
        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as
        long as 'foo' still has the same value it was assigned in
        'initialize_options()'.

        This method must be implemented by all command classes.
        """
        raise RuntimeError("abstract method -- subclass %s must override"
                           % self.__class__)


    def dump_options(self, header=None, indent=""):
        from distutils.fancy_getopt import longopt_xlate
        if header is None:
            header = "command options for '%s':" % self.get_command_name()
        self.announce(indent + header, level=log.INFO)
        indent = indent + "  "
        for (option, _, _) in self.user_options:
            option = option.translate(longopt_xlate)
            if option[-1] == "=":
                option = option[:-1]
            value = getattr(self, option)
            self.announce(indent + "%s = %s" % (option, value),
                          level=log.INFO)

    def run(self):
        """A command's raison d'etre: carry out the action it exists to
        perform, controlled by the options initialized in
        'initialize_options()', customized by other commands, the setup
        script, the command-line, and config files, and finalized in
        'finalize_options()'.  All terminal output and filesystem
        interaction should be done by 'run()'.

        This method must be implemented by all command classes.
        """
        raise RuntimeError("abstract method -- subclass %s must override"
                           % self.__class__)

    def announce(self, msg, level=1):
        """If the current verbosity level is of greater than or equal to
        'level' print 'msg' to stdout.
        """
        log.log(level, msg)

    def debug_print(self, msg):
        """Print 'msg' to stdout if the global DEBUG (taken from the
        DISTUTILS_DEBUG environment variable) flag is true.
        """
        from distutils.debug import DEBUG
        if DEBUG:
            print(msg)
            sys.stdout.flush()


    # -- Option validation methods -------------------------------------
    # (these are very handy in writing the 'finalize_options()' method)
    #
    # NB. the general philosophy here is to ensure that a particular option
    # value meets certain type and value constraints.  If not, we try to
    # force it into conformance (eg. if we expect a list but have a string,
    # split the string on comma and/or whitespace).  If we can't force the
    # option into conformance, raise DistutilsOptionError.  Thus, command
    # classes need do nothing more than (eg.)
    #   self.ensure_string_list('foo')
    # and they can be guaranteed that thereafter, self.foo will be
    # a list of strings.

    def _ensure_stringlike(self, option, what, default=None):
        val = getattr(self, option)
        if val is None:
            setattr(self, option, default)
            return default
        elif not isinstance(val, str):
            raise DistutilsOptionError("'%s' must be a %s (got `%s`)"
                                       % (option, what, val))
        return val

    def ensure_string(self, option, default=None):
        """Ensure that 'option' is a string; if not defined, set it to
        'default'.
        """
        self._ensure_stringlike(option, "string", default)

    def ensure_string_list(self, option):
        """Ensure that 'option' is a list of strings.  If 'option' is
        currently a string, we split it either on /,\s*/ or /\s+/, so
        "foo bar baz", "foo,bar,baz", and "foo,   bar baz" all become
        ["foo", "bar", "baz"].
        """
        val = getattr(self, option)
        if val is None:
            return
        elif isinstance(val, str):
            setattr(self, option, re.split(r',\s*|\s+', val))
        else:
            if isinstance(val, list):
                ok = all(isinstance(v, str) for v in val)
            else:
                ok = False
            if not ok:
                raise DistutilsOptionError(
                      "'%s' must be a list of strings (got %r)"
                      % (option, val))

    def _ensure_tested_string(self, option, tester, what, error_fmt,
                              default=None):
        val = self._ensure_stringlike(option, what, default)
        if val is not None and not tester(val):
            raise DistutilsOptionError(("error in '%s' option: " + error_fmt)
                                       % (option, val))

    def ensure_filename(self, option):
        """Ensure that 'option' is the name of an existing file."""
        self._ensure_tested_string(option, os.path.isfile,
                                   "filename",
                                   "'%s' does not exist or is not a file")

    def ensure_dirname(self, option):
        self._ensure_tested_string(option, os.path.isdir,
                                   "directory name",
                                   "'%s' does not exist or is not a directory")


    # -- Convenience methods for commands ------------------------------

    def get_command_name(self):
        if hasattr(self, 'command_name'):
            return self.command_name
        else:
            return self.__class__.__name__

    def set_undefined_options(self, src_cmd, *option_pairs):
        """Set the values of any "undefined" options from corresponding
        option values in some other command object.  "Undefined" here means
        "is None", which is the convention used to indicate that an option
        has not been changed between 'initialize_options()' and
        'finalize_options()'.  Usually called from 'finalize_options()' for
        options that depend on some other command rather than another
        option of the same command.  'src_cmd' is the other command from
        which option values will be taken (a command object will be created
        for it if necessary); the remaining arguments are
        '(src_option,dst_option)' tuples which mean "take the value of
        'src_option' in the 'src_cmd' command object, and copy it to
        'dst_option' in the current command object".
        """
        # Option_pairs: list of (src_option, dst_option) tuples
        src_cmd_obj = self.distribution.get_command_obj(src_cmd)
        src_cmd_obj.ensure_finalized()
        for (src_option, dst_option) in option_pairs:
            if getattr(self, dst_option) is None:
                setattr(self, dst_option, getattr(src_cmd_obj, src_option))

    def get_finalized_command(self, command, create=1):
        """Wrapper around Distribution's 'get_command_obj()' method: find
        (create if necessary and 'create' is true) the command object for
        'command', call its 'ensure_finalized()' method, and return the
        finalized command object.
        """
        cmd_obj = self.distribution.get_command_obj(command, create)
        cmd_obj.ensure_finalized()
        return cmd_obj

    # XXX rename to 'get_reinitialized_command()'? (should do the
    # same in dist.py, if so)
    def reinitialize_command(self, command, reinit_subcommands=0):
        return self.distribution.reinitialize_command(command,
                                                      reinit_subcommands)

    def run_command(self, command):
        """Run some other command: uses the 'run_command()' method of
        Distribution, which creates and finalizes the command object if
        necessary and then invokes its 'run()' method.
        """
        self.distribution.run_command(command)

    def get_sub_commands(self):
        """Determine the sub-commands that are relevant in the current
        distribution (ie., that need to be run).  This is based on the
        'sub_commands' class attribute: each tuple in that list may include
        a method that we call to determine if the subcommand needs to be
        run for the current distribution.  Return a list of command names.
        """
        commands = []
        for (cmd_name, method) in self.sub_commands:
            if method is None or method(self):
                commands.append(cmd_name)
        return commands


    # -- External world manipulation -----------------------------------

    def warn(self, msg):
        log.warn("warning: %s: %s\n" %
                (self.get_command_name(), msg))

    def execute(self, func, args, msg=None, level=1):
        util.execute(func, args, msg, dry_run=self.dry_run)

    def mkpath(self, name, mode=0o777):
        dir_util.mkpath(name, mode, dry_run=self.dry_run)

    def copy_file(self, infile, outfile, preserve_mode=1, preserve_times=1,
                  link=None, level=1):
        """Copy a file respecting verbose, dry-run and force flags.  (The
        former two default to whatever is in the Distribution object, and
        the latter defaults to false for commands that don't define it.)"""
        return file_util.copy_file(infile, outfile, preserve_mode,
                                   preserve_times, not self.force, link,
                                   dry_run=self.dry_run)

    def copy_tree(self, infile, outfile, preserve_mode=1, preserve_times=1,
                   preserve_symlinks=0, level=1):
        """Copy an entire directory tree respecting verbose, dry-run,
        and force flags.
        """
        return dir_util.copy_tree(infile, outfile, preserve_mode,
                                  preserve_times, preserve_symlinks,
                                  not self.force, dry_run=self.dry_run)

    def move_file (self, src, dst, level=1):
        """Move a file respecting dry-run flag."""
        return file_util.move_file(src, dst, dry_run=self.dry_run)

    def spawn(self, cmd, search_path=1, level=1):
        """Spawn an external command respecting dry-run flag."""
        from distutils.spawn import spawn
        spawn(cmd, search_path, dry_run=self.dry_run)

    def make_archive(self, base_name, format, root_dir=None, base_dir=None,
                     owner=None, group=None):
        return archive_util.make_archive(base_name, format, root_dir, base_dir,
                                         dry_run=self.dry_run,
                                         owner=owner, group=group)

    def make_file(self, infiles, outfile, func, args,
                  exec_msg=None, skip_msg=None, level=1):
        """Special case of 'execute()' for operations that process one or
        more input files and generate one output file.  Works just like
        'execute()', except the operation is skipped and a different
        message printed if 'outfile' already exists and is newer than all
        files listed in 'infiles'.  If the command defined 'self.force',
        and it is true, then the command is unconditionally run -- does no
        timestamp checks.
        """
        if skip_msg is None:
            skip_msg = "skipping %s (inputs unchanged)" % outfile

        # Allow 'infiles' to be a single string
        if isinstance(infiles, str):
            infiles = (infiles,)
        elif not isinstance(infiles, (list, tuple)):
            raise TypeError(
                  "'infiles' must be a string, or a list or tuple of strings")

        if exec_msg is None:
            exec_msg = "generating %s from %s" % (outfile, ', '.join(infiles))

        # If 'outfile' must be regenerated (either because it doesn't
        # exist, is out-of-date, or the 'force' flag is true) then
        # perform the action that presumably regenerates it
        if self.force or dep_util.newer_group(infiles, outfile):
            self.execute(func, args, exec_msg, level)
        # Otherwise, print the "skip" message
        else:
            log.debug(skip_msg)

# XXX 'install_misc' class not currently used -- it was the base class for
# both 'install_scripts' and 'install_data', but they outgrew it.  It might
# still be useful for 'install_headers', though, so I'm keeping it around
# for the time being.

class install_misc(Command):
    """Common base class for installing some files in a subdirectory.
    Currently used by install_data and install_scripts.
    """

    user_options = [('install-dir=', 'd', "directory to install the files to")]

    def initialize_options (self):
        self.install_dir = None
        self.outfiles = []

    def _install_dir_from(self, dirname):
        self.set_undefined_options('install', (dirname, 'install_dir'))

    def _copy_files(self, filelist):
        self.outfiles = []
        if not filelist:
            return
        self.mkpath(self.install_dir)
        for f in filelist:
            self.copy_file(f, self.install_dir)
            self.outfiles.append(os.path.join(self.install_dir, f))

    def get_outputs(self):
        return self.outfiles
                                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/distutils/command/                                                                0040755 0000000 0000000 00000000000 13077704335 016050  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/distutils/command/__init__.py                                                     0100644 0000000 0000000 00000001437 12415221640 020147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command

Package containing implementation of all the standard Distutils
commands."""

__all__ = ['build',
           'build_py',
           'build_ext',
           'build_clib',
           'build_scripts',
           'clean',
           'install',
           'install_lib',
           'install_headers',
           'install_scripts',
           'install_data',
           'sdist',
           'register',
           'bdist',
           'bdist_dumb',
           'bdist_rpm',
           'bdist_wininst',
           'check',
           'upload',
           # These two are reserved for future use:
           #'bdist_sdux',
           #'bdist_pkgtool',
           # Note:
           # bdist_packager is not included because it only provides
           # an abstract base class
          ]
                                                                                                                                                                                                                                 usr/lib/python3.4/distutils/command/__pycache__/                                                    0040755 0000000 0000000 00000000000 13077704335 020260  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/distutils/command/__pycache__/__init__.cpython-34.pyc                             0100644 0000000 0000000 00000001054 13077704335 024440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T  „               @   sI   d  Z  d d d d d d d d d	 d
 d d d d d d d d d g Z d S)z\distutils.command

Package containing implementation of all the standard Distutils
commands.ZbuildZbuild_pyZ	build_extZ
build_clibZbuild_scriptsZcleanZinstallZinstall_libZinstall_headersZinstall_scriptsZinstall_dataZsdist⁄registerZbdistZ
bdist_dumbZ	bdist_rpmZbdist_wininstZcheckZuploadN)⁄__doc__⁄__all__© r   r   ˙0/usr/lib/python3.4/distutils/command/__init__.py⁄<module>   s&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/distutils/command/__pycache__/bdist.cpython-34.pyc                                0100644 0000000 0000000 00000007662 13077704335 024021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tp  „               @   sb   d  Z  d d l Z d d l m Z d d l Td d l m Z d d Ñ  Z Gd d	 Ñ  d	 e É Z d S)
zidistutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution).È    N)⁄Command)⁄*)⁄get_platformc              C   sl   d d l  m }  g  } x6 t j D]+ } | j d | d t j | d f É q  W|  | É } | j d É d S)zFPrint list of available formats (arguments to "--format" option).
    r   )⁄FancyGetoptzformats=NÈ   z'List of available distribution formats:)Zdistutils.fancy_getoptr   ⁄bdist⁄format_commands⁄append⁄format_commandZ
print_help)r   ⁄formats⁄formatZpretty_printer© r   ˙-/usr/lib/python3.4/distutils/command/bdist.py⁄show_formats   s    r   c            	   @   s˘   e  Z d  Z d Z d4 d d d e É  f d5 d6 d7 d8 d9 g Z d g Z d d	 d e f g Z d: Z	 i d d 6d d 6Z
 d d d d d  d! d d" g Z i d; d 6d< d 6d= d 6d> d 6d? d  6d@ d! 6dA d 6dB d" 6Z d. d/ Ñ  Z d0 d1 Ñ  Z d2 d3 Ñ  Z d	 S)Cr   z$create a built (binary) distribution˙bdist-base=⁄b˙4temporary directory for creating built distributionsz
plat-name=⁄pz;platform name to embed in generated filenames (default: %s)˙formats=N˙/formats for distribution (comma-separated list)˙	dist-dir=⁄d˙=directory to put final built distributions in [default: dist]˙
skip-build˙2skip rebuilding everything (for testing/debugging)˙owner=⁄u˙@Owner name used when creating a tar file [default: current user]˙group=⁄g˙AGroup name used when creating a tar file [default: current group]zhelp-formatsz$lists available distribution formats⁄	bdist_rpmZgztar⁄posix⁄zip⁄ntZrpmZbztarZztarZtarZwininstZmsi˙RPM distribution⁄
bdist_dumb˙gzip'ed tar file˙bzip2'ed tar file˙compressed tar file˙tar file⁄bdist_wininst˙Windows executable installer˙ZIP file⁄	bdist_msi˙Microsoft Installerc             C   sC   d  |  _  d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  S)Nr   )⁄
bdist_base⁄	plat_namer   ⁄dist_dir⁄
skip_build⁄group⁄owner)⁄selfr   r   r   ⁄initialize_optionsP   s    						zbdist.initialize_optionsc             C   s  |  j  d  k r? |  j r' t É  |  _  q? |  j d É j  |  _  n  |  j d  k rÇ |  j d É j } t j j | d |  j  É |  _ n  |  j	 d É |  j
 d  k r„ y |  j t j g |  _
 Wq„ t k
 rﬂ t d t j É Ç Yq„ Xn  |  j d  k r˛ d |  _ n  d  S)NZbuildzbdist.r   z;don't know how to create built distributions on platform %sZdist)r1   r3   r   Zget_finalized_commandr0   ⁄
build_base⁄os⁄path⁄joinZensure_string_listr   ⁄default_format⁄name⁄KeyErrorZDistutilsPlatformErrorr2   )r6   r8   r   r   r   ⁄finalize_optionsY   s$    	zbdist.finalize_optionsc             C   s  g  } xR |  j  D]G } y | j |  j | d É Wq t k
 rV t d | É Ç Yq Xq Wx≤ t t |  j  É É D]õ } | | } |  j | É } | |  j k r≤ |  j  | | _	 n  | d k rŸ |  j
 | _
 |  j | _ n  | | | d d  Ö k rˇ d | _ n  |  j | É qq Wd  S)Nr   zinvalid format '%s'r&   r   )r   r	   r
   r>   ZDistutilsOptionError⁄range⁄lenZreinitialize_command⁄no_format_optionr   r5   r4   Z	keep_tempZrun_command)r6   Zcommandsr   ⁄iZcmd_nameZsub_cmdr   r   r   ⁄runu   s"    
z	bdist.run)r   r   r   )r   Nr   )r   r   r   )r   Nr   )r   r   r   )r   r   r    )r!   )r!   r%   )˙
bdist_dumbr'   )rE   r(   )rE   r)   )rE   r*   )r+   r,   )rE   r-   )r.   r/   )⁄__name__⁄
__module__⁄__qualname__Zdescriptionr   Zuser_optionsZboolean_optionsr   Zhelp_optionsrB   r<   r   r
   r7   r?   rD   r   r   r   r   r      sH    
     		


 
	r   )	⁄__doc__r9   Zdistutils.corer   Zdistutils.errorsZdistutils.utilr   r   r   r   r   r   r   ⁄<module>   s   
                                                                              usr/lib/python3.4/distutils/command/__pycache__/bdist_dumb.cpython-34.pyc                           0100644 0000000 0000000 00000007561 13077704335 025026  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T  „               @   så   d  Z  d d l Z d d l m Z d d l m Z d d l m Z m Z d d l	 Td d l
 m Z d d l m Z Gd	 d
 Ñ  d
 e É Z d S)z∑distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix).È    N)⁄Command)⁄get_platform)⁄remove_tree⁄ensure_relative)⁄*)⁄get_python_version)⁄logc               @   sõ   e  Z d  Z d Z d& d d d e É  f d' d d d d f d( d) d* d+ d, g	 Z d d d g Z i d d 6d d 6Z d  d! Ñ  Z d" d# Ñ  Z	 d$ d% Ñ  Z
 d S)-⁄
bdist_dumbz"create a "dumb" built distribution˙
bdist-dir=⁄d˙1temporary directory for creating the distributionz
plat-name=⁄pz;platform name to embed in generated filenames (default: %s)˙format=⁄f˙0archive format to create (tar, ztar, gztar, zip)z	keep-temp⁄kz/keep the pseudo-installation tree around after z!creating the distribution archive˙	dist-dir=˙-directory to put final built distributions in˙
skip-buildN˙2skip rebuilding everything (for testing/debugging)⁄relative˙6build the archive using relative paths(default: false)˙owner=⁄u˙@Owner name used when creating a tar file [default: current user]˙group=⁄g˙AGroup name used when creating a tar file [default: current group]Zgztar⁄posix⁄zip⁄ntc             C   sU   d  |  _  d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  S)Nr   )	⁄	bdist_dir⁄	plat_name⁄format⁄	keep_temp⁄dist_dir⁄
skip_buildr   ⁄owner⁄group)⁄self© r*   ˙2/usr/lib/python3.4/distutils/command/bdist_dumb.py⁄initialize_options1   s    								zbdist_dumb.initialize_optionsc             C   sß   |  j  d  k r< |  j d É j } t j j | d É |  _  n  |  j d  k rç y |  j t j |  _ Wqç t	 k
 râ t
 d t j É Ç Yqç Xn  |  j d d d d	 É d  S)
NZbdistZdumbz@don't know how to create dumb built distributions on platform %sr%   r"   r&   )˙dist_dirr-   )˙	plat_namer.   )˙
skip_buildr/   )r!   Zget_finalized_command⁄
bdist_base⁄os⁄path⁄joinr#   ⁄default_format⁄name⁄KeyError⁄DistutilsPlatformErrorZset_undefined_options)r)   r0   r*   r*   r+   ⁄finalize_options<   s    	zbdist_dumb.finalize_optionsc          	   C   s∂  |  j  s |  j d É n  |  j d d d É} |  j | _ |  j  | _  d | _ t j d |  j É |  j d É d |  j j	 É  |  j
 f } t j j |  j | É } |  j sπ |  j } nm |  j j É  r| j | j k rt d t | j É t | j É f É Ç n! t j j |  j t | j É É } |  j | |  j d	 | d
 |  j d |  j É} |  j j É  rnt É  } n d } |  j j j d | | f É |  j s≤t |  j d |  j Én  d  S)NZbuild⁄installZreinit_subcommandsÈ   r   zinstalling to %sz%s.%szScan't make a dumb built distribution where base and platbase are different (%s, %s)Zroot_dirr'   r(   ⁄anyr	   ⁄dry_run) r&   Zrun_commandZreinitialize_commandr!   ⁄rootZwarn_dirr   ⁄infoZdistributionZget_fullnamer"   r1   r2   r3   r%   r   Zhas_ext_modulesZinstall_baseZinstall_platbaser7   ⁄reprr   Zmake_archiver#   r'   r(   r   Z
dist_files⁄appendr$   r   r<   )r)   r9   Zarchive_basenameZpseudoinstall_rootZarchive_root⁄filenameZ	pyversionr*   r*   r+   ⁄runN   s>    				
	zbdist_dumb.run)r
   r   r   )r   r   r   )r   r   r   )r   Nr   )zrelativeNr   )r   r   r   )r   r   r   )⁄__name__⁄
__module__⁄__qualname__Zdescriptionr   Zuser_optionsZboolean_optionsr4   r,   r8   rB   r*   r*   r*   r+   r	      s6    
      	

r	   )⁄__doc__r1   Zdistutils.corer   Zdistutils.utilr   Zdistutils.dir_utilr   r   Zdistutils.errorsZdistutils.sysconfigr   Z	distutilsr   r	   r*   r*   r*   r+   ⁄<module>   s   
                                                                                                                                               usr/lib/python3.4/distutils/command/__pycache__/bdist_msi.cpython-34.pyc                            0100644 0000000 0000000 00000052501 13077704335 024661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tëâ  „               @   s  d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z d d	 l m Z d d l Z d d
 l m Z m Z m Z d d l m Z m Z m Z m Z Gd d Ñ  d e É Z Gd d Ñ  d e É Z d S)z#
Implements the bdist_msi command.
È    N)⁄Command)⁄remove_tree)⁄get_python_version)⁄StrictVersion)⁄DistutilsOptionError)⁄get_platform)⁄log)⁄schema⁄sequence⁄text)⁄	Directory⁄Feature⁄Dialog⁄add_datac               @   sp   e  Z d  Z d Z d d Ñ  Z d d Ñ  Z d d d d	 Ñ Z d
 d d d Ñ Z d d d d Ñ Z d d Ñ  Z	 d S)⁄PyDialogzôDialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left.c             O   sK   t  j |  | å |  j d } d | d } |  j d d | |  j d É d S)zbDialog(database, name, x, y, w, h, attributes, title, first,
        default, cancel, bitmap=true)È$   Èò   iH  Z
BottomLiner   N)r   ⁄__init__⁄h⁄line⁄w)⁄self⁄args⁄kwZrulerZbmwidth© r   ˙1/usr/lib/python3.4/distutils/command/bdist_msi.pyr      s    zPyDialog.__init__c          	   C   s'   |  j  d d d d d d d | É d S)	z,Set the title text of the dialog at the top.⁄TitleÈ   È
   i@  È<   i  z{\VerdanaBold10}%sN)r   )r   ⁄titler   r   r   r    #   s    zPyDialog.title⁄BackÈ   c          	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S)zªAdd a back button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedÈ   r"   È¥   È   È8   È   )⁄
pushbuttonr   )r   r    ⁄next⁄name⁄active⁄flagsr   r   r   ⁄back*   s    	zPyDialog.back⁄Cancelc          	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S)zΩAdd a cancel button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedr#   r"   i0  r%   r&   r'   )r(   r   )r   r    r)   r*   r+   r,   r   r   r   ⁄cancel5   s    	zPyDialog.cancel⁄Nextc          	   C   s>   | r d } n d } |  j  | d |  j d d d | | | É S)zªAdd a Next button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associatedr#   r"   ÈÏ   r%   r&   r'   )r(   r   )r   r    r)   r*   r+   r,   r   r   r   r)   @   s    	zPyDialog.nextc          	   C   s:   |  j  | t |  j | d É |  j d d d d | | É S)zÍAdd a button with a given title, the tab-next button,
        its name in the Control table, giving its x position; the
        y-position is aligned with the other buttons.

        Return the button, so that events can be associatedÈ   r%   r&   r'   r#   )r(   ⁄intr   r   )r   r*   r    r)   Zxposr   r   r   ⁄xbuttonK   s    zPyDialog.xbuttonN)
⁄__name__⁄
__module__⁄__qualname__⁄__doc__r   r    r-   r/   r)   r4   r   r   r   r   r      s   
r   c               @   s]  e  Z d  Z d Z d d d f d d d e É  f d d	 d
 d f d d d d f d d d f d d d f d d d f d d d f d d d f d d d f g
 Z d d d d g Z d d d  d! d" d# d$ d% d& d' d( d) d* d+ d, d- d. d/ d0 d1 g Z d2 Z d3 d4 Ñ  Z	 d5 d6 Ñ  Z
 d7 d8 Ñ  Z d9 d: Ñ  Z d; d< Ñ  Z d= d> Ñ  Z d? d@ Ñ  Z dA dB Ñ  Z d S)C⁄	bdist_msiz7create a Microsoft Installer (.msi) binary distributionz
bdist-dir=Nz1temporary directory for creating the distributionz
plat-name=⁄pz;platform name to embed in generated filenames (default: %s)z	keep-temp⁄kz/keep the pseudo-installation tree around after z!creating the distribution archiveztarget-version=z!require a specific python versionz on the target systemzno-target-compile⁄cz/do not compile .py to .pyc on the target systemzno-target-optimize⁄oz:do not compile .py to .pyo (optimized)on the target systemz	dist-dir=⁄dz-directory to put final built distributions inz
skip-buildz2skip rebuilding everything (for testing/debugging)zinstall-script=zTbasename of installation script to be run afterinstallation or before deinstallationzpre-install-script=z{Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distributionz2.0z2.1z2.2z2.3z2.4z2.5z2.6z2.7z2.8z2.9z3.0z3.1z3.2z3.3z3.4z3.5z3.6z3.7z3.8z3.9⁄Xc             C   sg   d  |  _  d  |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  S)Nr   )⁄	bdist_dir⁄	plat_name⁄	keep_tempZno_target_compileZno_target_optimize⁄target_version⁄dist_dir⁄
skip_build⁄install_script⁄pre_install_script⁄versions)r   r   r   r   ⁄initialize_options}   s    										zbdist_msi.initialize_optionsc             C   sr  |  j  d d	 É |  j d  k rL |  j d É j } t j j | d É |  _ n  t É  } |  j rz |  j	 j
 É  rz | |  _ n  |  j r” |  j g |  _ |  j rÂ |  j	 j
 É  rÂ |  j | k rÂ t d | f É Ç qÂ n t |  j É |  _ |  j  d d
 d É |  j rt d É Ç n  |  j rexI |  j	 j D]% } |  j t j j | É k r&Pq&q&Wt d |  j É Ç n  d  |  _ d  S)NZbdistrE   ZmsizMtarget version can only be %s, or the '--skip-build' option must be specifiedrD   rA   z5the pre-install-script feature is not yet implementedz(install_script '%s' not found in scripts)˙
skip_buildrJ   )˙dist_dirrK   )˙	plat_namerL   )Zset_undefined_optionsr@   ⁄get_finalized_command⁄
bdist_base⁄os⁄path⁄joinr   rC   ⁄distribution⁄has_ext_modulesrH   rE   r   ⁄list⁄all_versionsrG   rF   Zscripts⁄basename⁄install_script_key)r   rN   Zshort_versionZscriptr   r   r   ⁄finalize_optionsä   s:    					zbdist_msi.finalize_optionsc             C   sí  |  j  s |  j d É n  |  j d d d É} |  j | _ |  j  | _  d | _ |  j d É } d | _ d | _ |  j j	 É  r˝ |  j
 } | sπ |  j  s£ t d É Ç t j d d Ö } n  d	 |  j | f } |  j d É } t j j | j d
 | É | _ n  t j d |  j É | j É  t j j d t j j |  j d É É | j É  t j d =|  j |  j É |  j j É  } |  j | É } t j j | É } t j j | É rµt j  | É n  |  j j! } | j" }	 |	 s‹| j# }	 n  |	 sÎd }	 n  | j$ É  }
 d t% |
 É j } |  j j É  } |  j
 r8d |  j
 | f } n
 d | } t& j' | t( | t& j) É  | |	 É |  _* t& j+ |  j* t, É d |
 f g } | j- pö| j. } | rπ| j/ d | f É n  | j0 r€| j/ d | j0 f É n  | r˜t1 |  j* d | É n  |  j2 É  |  j3 É  |  j4 É  |  j5 É  |  j* j6 É  t7 |  j d É rld |  j
 pMd | f } |  j j8 j/ | É n  |  j9 sét: |  j d |  j; Én  d  S)N⁄build⁄installZreinit_subcommandsr"   r   ⁄install_libz Should have already checked thisr#   z.%s-%sZlibzinstalling to %sZPURELIBZUNKNOWNz%d.%d.%dzPython %s %sz	Python %sZDistVersionZ
ARPCONTACTZARPURLINFOABOUT⁄Property⁄
dist_filesr9   ⁄any⁄dry_run)<rE   Zrun_commandZreinitialize_commandr@   ⁄prefixZwarn_dir⁄compile⁄optimizerR   rS   rC   ⁄AssertionError⁄sys⁄versionrA   rM   rO   rP   rQ   Z
build_baseZ	build_libr   ⁄infoZensure_finalized⁄insert⁄runZmkpathrD   ⁄get_fullname⁄get_installer_filename⁄abspath⁄exists⁄unlink⁄metadata⁄authorZ
maintainerZget_versionr   ⁄msilibZinit_databaser	   Zgen_uuid⁄dbZ
add_tablesr
   Zauthor_emailZmaintainer_email⁄appendZurlr   ⁄add_find_python⁄	add_files⁄add_scripts⁄add_ui⁄Commit⁄hasattrr]   rB   r   r_   )r   rZ   r[   rC   Zplat_specifierrY   ⁄fullname⁄installer_namern   ro   re   ZsversionZproduct_nameZpropsZemail⁄tupr   r   r   rh   ≤   s~    					
%

 			
	



	zbdist_msi.runc          
   C   sÔ  |  j  } t j d É } t j j |  j É } t | | d  | d d É } t | d d d d d d d É} | | d	 f g } xπ |  j	 |  j
 g D]§ } d | } d | }	 }
 d } | |  j
 k r— d
 } d } n d | } d } t | |	 | | d | d | É} t | | | | | |
 É } | j | | | f É qè W| j É  i  } xî| D]å\ } } } | g } xg| rœ| j É  } xNt j | j É D]:} t j j | j | É } t j j | É rd | j | É | f } | | }
 t | | | | |
 | É } | j | É qé| j s.| j | j | d É n  | | k rè| j | É } | | <| |  j k r»|  j r|t d | É Ç n  d | |  _ q»qé| | } t |  j  d | | | j | d  | j f g É qéWqiW| j É  qNW| j | É d  S)NZ	distfiles⁄	TARGETDIRZ	SourceDir⁄PythonZ
Everythingr   r"   Z	directory⁄ zPython from another locationÈ   zPython %s from registryz%s|%szMultiple files with name %sz[#%s]ZDuplicateFile)rq   rp   ZCABrO   rP   rk   r@   r   r   rH   ⁄other_versionrr   rw   ⁄pop⁄listdirZabsoluterQ   ⁄isdirZ
make_shortZ	componentZstart_componentZlogicalZadd_filerF   rW   r   r   Zcommit)r   rq   ZcabZrootdir⁄root⁄f⁄itemsre   ⁄targetr*   ⁄defaultZdescr    ⁄level⁄dir⁄seenZfeatureZtodo⁄fileZafileZshortZnewdir⁄keyr   r   r   rt     s\    	
	
!
		
		
+zbdist_msi.add_filesc             C   s  d } x|  j  D]˜} d | } d | } d | } d | } d | } d | } d | }	 d	 | }
 d
 | } d | } t j rå d  } n d } t |  j d | d | d | f | d | d | f g É t |  j d | | f | | f g É t |  j d | d! | d | d f |	 d" | d | d f |
 d# | d | d f g É t |  j d | | | f |	 | | d f |
 d | d f g É t |  j d | | | f |	 | | d f |
 d | d f g É t |  j d d | d d | f g É | d 7} | d k  s t Ç q Wd S)$as  Adds code to the installer to compute the location of Python.

        Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
        registry for each version of Python.

        Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
        else from PYTHON.MACHINE.X.Y.

        Properties PYTHONX.Y will be set to TARGETDIRX.Y\python.exeií  z)SOFTWARE\Python\PythonCore\%s\InstallPathzpython.machine.zpython.user.zPYTHON.MACHINE.zPYTHON.USER.ZPythonFromMachineZPythonFromUserZ	PythonExer|   ⁄PYTHONr   È   Z
RegLocatorNr"   Z	AppSearch⁄CustomActionÈ3   È   ˙[˙]z]\python.exe⁄InstallExecuteSequence⁄InstallUISequenceZ	Conditionr}   r   zNOT TARGETDIRÈ   iÙ  È   i3  i3  i3  )rH   rp   ZWin64r   rq   rc   )r   ⁄start⁄verZinstall_pathZmachine_regZuser_regZmachine_propZ	user_propZmachine_actionZuser_actionZ
exe_actionZtarget_dir_prop⁄exe_propZTyper   r   r   rs   C  sJ    









			
zbdist_msi.add_find_pythonc             C   sQ  |  j  rñ d } xÑ |  j |  j g D]l } d | } d | } t |  j d | d | |  j f g É t |  j d | d | | f g É | d 7} q# Wn  |  j rMt j j	 |  j
 d	 É } t | d
 É } | j d É | j t |  j É j É  É | j É  t |  j d d t j | É f g É t |  j d d g É t |  j d d g É n  d  S)Niê  zinstall_script.ré   rê   È2   rï   z&Python%s=3r"   zpreinstall.batr   zrem ="""
%1 %0
exit
"""
⁄Binary⁄
PreInstallr   ˙NOT InstalledÈ¬  )rû   r   rû   N)rû   rü   r†   )rF   rH   rÄ   r   rq   rW   rG   rO   rP   rQ   r@   ⁄open⁄write⁄read⁄closerp   rù   )r   rô   rö   Zinstall_actionrõ   ZscriptfnrÖ   r   r   r   ru   y  s,    	

		

zbdist_msi.add_scriptsc             C   sG  |  j  } d } } d } d } d } d } d } d }	 t | d dÚ dÛ dÙ dı dˆ d˜ g É t | d d¯ d˘ d˙ d˚ g É t | d  d¸ d˝ d˛ dˇ d g É t | d/ t j É t | d0 t j É t | d1 | | | | | | d2 d2 d2 É }
 |
 j d3 É |
 j d4 d2 d5 d É|
 j d6 d7 d5 d É|
 j d8 d9 d: d; d< d= d> É |
 j d? d9 d@ d; dA d= dB É |
 j	 d2 d6 dC d2 É} | j
 dD dE É t | dF | | | | | | d2 d2 d2 É } | j dG É | j d4 d2 d5 d É| j d6 d7 d5 d É| j d8 d9 d: d; d< d= dH É | j d? d9 d@ d; dA d= dB É | j	 d2 d6 dC d2 É} | j
 dD dE É t | dI | | | | | | d2 d2 d2 É } | j dJ É | j d4 d2 d5 d É| j d6 d7 d5 d É| j dK d9 dL d; dA d= dB É | j	 d2 d6 dC d2 É} | j
 dD dM É t | dN | | | | dO | dP dP dP dQ dR É} | j dS d9 dT dU d9 d= dV É | j dK dA dW dX dA d= dY É | j dZ dA d[ d\ d d d] É | j d^ d_ dA d` d\ da db dc d  d  d  É | j dE dd dC dE É} | j
 dD dE É | j	 dd dP dC dd É} | j
 dD dd É | j dP dE dC dP É} | j
 dD dP É t | d d d d\ de df | dg d  d  É } | j dg d d dX dh d di É | j dj dk dl dm dn d do d  É j
 dD dp É | j dq dr dl dm dn d ds d  É j
 dD dt É | j du d dl dm dn d dv d  É j
 dD dw É | j dx dy dl dm dn d d6 d  É j
 dD dz É | j d{ dm dl dm dn d dd d  É j
 dD d| É | j d} d~ dl dm dn d d d  É j
 dD dÄ É | j dÅ dÇ dl dm dn d dP d  É j
 dD dÉ É t | dÑ d d dÖ dÜ d | do do do É } | j dZ dh d9 dá dà d dâ É | j ds dl dä dã då d ds do É } | j
 dD dE É | j do dç dä dã då d do ds É } | j
 dD dM É t | dé d d dÖ dÜ | | dM dM dM É } | j dZ dh d9 dá dà d dè É | j dM dê dä dã då d dM d  É } | j
 dD dE É t | d! | | | | | | d6 d6 d6 É } | j dK d9 d: d; dë d= dí É | j dì É | j d/ d9 dî d; dA d= dï É } | j d/ dZ É | j dñ d9 dó d; dà d= d  É } | j dñ dZ É | j d7 d  d5 d É| j	 dò d  d5 d É| j d6 d  É } | j
 dô dÑ É t | d' | | | | | | dò dò d6 É } | j dö É | j dõ d9 dà d dA d dú |  j j É  É | j d4 d  d5 d É| j	 dù d6 É } d } | j
 dû dü d† | ÉxF |  j |  j g D]1 } | d 7} | j
 dû d° | d¢ | d† | Éq†W| j
 d£ dé d† | d É| j
 dD dM d† | d§ É| j d6 d• É } | j
 dô dÑ É | j d• d¶ d9 dß d dk d d® d  d© d  É } | j
 d™ d´ É |  j } d¢ | } d¨ | } | j d≠ d9 dU d d9 d dÆ É } | j dØ | É | j d∞ | É | j d± | É | j d≤ | É | j d© d© d9 d≥ d d¥ d dµ | d  dò d  É } | j dØ | É | j d∞ | É | j d± | É | j d≤ | É t | d∂ | | | | | | d∑ d∑ d∑ dQ dR É} | j dS d9 dT dU d9 d= d∏ É | j dK dA dA dX dA d= dπ É | j dZ dA d∫ d\ dß d dª É | j dº dΩ dA dæ d\ dø d¿ d  d¡ d  d  É | j d∑ d d  d¬ É j
 dD dM É t | d$ | | | | | | d√ dò d6 É } | j dƒ É | j d√ d9 dß dÖ d d d di dò É	 } | j d d d≈ dø dA d∆ É | j d« d d» dø dA d… É | j d7 d  d5 d É| j	 dù d6 É } | j
 d  d´ dÀ d É | j
 dD dM d† d§ É| j d6 d√ É } | j
 dô dÑ É t | d- | | | | | | d6 d6 d6 dQ dR É} | j dS dA d9 dU d9 d= dÃ É | j dZ dÕ dŒ d dà d dœ É | j d– dÕ dæ dÕ dA d d— É | j d/ d: dæ | d: dA d dï É } | j d/ dZ É | j d“ d“ dÕ dk d d d” d  d‘ d  d  É } | j d’ d÷ É | j d4 dò d5 dR É| j	 dù d6 d5 dR É| j d6 d7 É j
 dô dÑ É t | d* | | | | | | dò dò d6 É } | j d◊ É | j dÿ d9 dŸ d\ dy d d⁄ É | j d€ d9 d‹ d\ dß d d di dò É	 } | j d d d› dU då dﬁ É | j dﬂ d d‡ dU då d· É | j d4 d  d5 dR É| j	 d2 d6 É } | j
 d‚ d d„ d≈ É | j
 d‰ dÂ d„ dT É | j
 dÊ dÁ d„ db É | j
 dË d d„ d É | j
 dÈ d dÍ dÎ É | j
 d‰ dÏ dÍ dÌ É | j
 dÊ dÓ dÍ dÔ É | j
 dﬂ d dÍ d É | j
 dD dM dÒ dA É | j d6 d€ É j
 dô dÑ É d  S(  Nrú   ir  i,  z[ProductName] Setupr#   r"   È    r\   ⁄DefaultUIFont⁄DlgFont8⁄ErrorDialog⁄ErrorDlg⁄	Progress1⁄Install⁄	Progress2⁄installs⁄MaintenanceForm_Action⁄Repair⁄
WhichUsers⁄ALLZ	TextStyle⁄TahomaÈ	   r   ⁄DlgFontBold8È   ⁄VerdanaBold10⁄Verdanar   ⁄VerdanaRed9Èˇ   rñ   ⁄
PrepareDlg˙(Not Privileged or Windows9x or InstalledÈå   ⁄WhichUsersDlg˙.Privileged and not Windows9x and not InstalledÈç   ⁄SelectFeaturesDlg˙Not InstalledÈŒ  ⁄MaintenanceTypeDlg˙,Installed AND NOT RESUME AND NOT PreselectedÈ‚  ⁄ProgressDlgÈ   ⁄
ActionText⁄UITextZ
FatalErrorZFinishz)[ProductName] Installer ended prematurelyz< Backr+   r.   r!   ZDescription1r   ÈF   i@  ÈP   i  z´[ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.ZDescription2Èõ   È   z.Click the Finish button to exit the Installer.r*   Z	EndDialogZExitZUserExitz'[ProductName] Installer was interruptedzï[ProductName] setup was interrupted.  Your system has not been modified.  To install this program at a later time, please run the installation again.Z
ExitDialogz&Completing the [ProductName] InstallerZDescriptionÈÎ   ZReturnZ
FilesInUseÈ   ZRetryZbitmapFr   È   È»   z{\DlgFontBold8}Files in UseÈ   i  z8Some files that need to be updated are currently in use.ZTextÈ7   iJ  z≤The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.ZListZListBoxÈk   ÈÇ   È   ZFileInUseProcess⁄IgnoreÈe   i  Z	ErrorTextÈ0   r~   ⁄NÈx   ÈH   ÈQ   È   ZNoZErrorNo⁄YÈ   ZYesZErrorYes⁄AZAbortZ
ErrorAbort⁄CÈ*   ZErrorCancel⁄IZErrorIgnore⁄OÈü   ZOkZErrorOk⁄RÈ∆   Z
ErrorRetryZ	CancelDlgi  ÈU   È¬   È   z;Are you sure you want to cancel [ProductName] installation?È9   r&   r'   ÈÑ   ZWaitForCostingDlgzRPlease wait while the installer finishes determining your disk space requirements.Èf   È(   zOPlease wait while the Installer prepares to guide you through the installation.z&Welcome to the [ProductName] InstallerÈn   zPondering...Z
ActionDataÈá   r0   ZSpawnDialogzSelect Python InstallationsZHintz9Select the Python locations where %s should be installed.zNext >z[TARGETDIR]z[SourceDir]Zorderingz[TARGETDIR%s]z FEATURE_SELECTED AND &Python%s=3ZSpawnWaitDialogr   ZFeaturesZSelectionTreer   ZFEATUREZPathEditz[FEATURE_SELECTED]⁄1z!FEATURE_SELECTED AND &Python%s<>3ZOtherz$Provide an alternate Python locationZEnableZShowZDisableZHideÈ◊   rè   r|   ZDiskCostDlgZOKz&{\DlgFontBold8}Disk Space RequirementszFThe disk space required for the installation of the selected features.È5   a  The highlighted volumes (if any) do not have enough disk space available for the currently selected features.  You can either remove some files from the highlighted volumes, or choose to install less features onto local drive(s), or select different destination drive(s).Z
VolumeListZVolumeCostListÈd   Èñ   i  z{120}{70}{70}{70}{70}g      ‡?ZAdminInstallzGSelect whether to install [ProductName] for all users of this computer.È   zInstall for all usersZJUSTMEÈ   zInstall just for mez
[ALLUSERS]zWhichUsers="ALL"z({\DlgFontBold8}[Progress1] [ProductName]È#   ÈA   zYPlease wait while the Installer [Progress2] [ProductName]. This may take several minutes.ZStatusLabelzStatus:ZProgressBari  zProgress doneZSetProgressZProgressz)Welcome to the [ProductName] Setup WizardZBodyTextÈ?   z:Select whether you want to repair or remove [ProductName].ZRepairRadioGroupÈl   rò   z&Repair [ProductName]ZRemover   zRe&move [ProductName]z[REINSTALL]zMaintenanceForm_Action="Repair"z[Progress1]Z	Repairingz[Progress2]ZrepairsZ	Reinstallz[REMOVE]zMaintenanceForm_Action="Remove"È   ZRemovingÈ   ZremovesÈ   È   z MaintenanceForm_Action<>"Change")r¶   rß   )r®   r©   )r™   r´   )r¨   r≠   )rÆ   rØ   )r∞   r±   )rß   r≤   r≥   Nr   )r¥   r≤   rµ   Nr"   )r∂   r∑   r   Nr"   )r∏   r∑   r≥   rπ   r   )r∫   rª   rº   )rΩ   ræ   rø   )r¿   r¡   r¬   )r√   rƒ   r≈   )r∆   Nr«   )rq   r   r   r»   r…   r   r    r-   r/   r)   ZeventZcontrolr   r(   ⁄mappingrR   ri   rH   rÄ   Z	conditionr4   Z
radiogroup⁄add)r   rq   ⁄x⁄yr   r   r    ZmodalZmodelessZtrack_disk_spaceZfatalr<   Z	user_exitZexit_dialogZinuse⁄errorr/   ZcostingZprepZseldlgZorderre   rö   Zinstall_other_condZdont_install_other_condZcostZ
whichusers⁄gZprogressZmaintr   r   r   rv   ü  sÆ   	
	
	
	
		.......$$$!!

	

	"%zbdist_msi.add_uic             C   sT   |  j  r% d | |  j |  j  f } n d | |  j f } t j j |  j | É } | S)Nz%s.%s-py%s.msiz	%s.%s.msi)rC   rA   rO   rP   rQ   rD   )r   ry   Z	base_namerz   r   r   r   rj   ›  s    	z bdist_msi.get_installer_filename)r5   r6   r7   Zdescriptionr   Zuser_optionsZboolean_optionsrU   rÄ   rI   rX   rh   rt   rs   ru   rv   rj   r   r   r   r   r9   S   sP   
		([66&ˇ ?r9   )r8   rd   rO   Zdistutils.corer   Zdistutils.dir_utilr   Zdistutils.sysconfigr   Zdistutils.versionr   Zdistutils.errorsr   Zdistutils.utilr   Z	distutilsr   rp   r	   r
   r   r   r   r   r   r   r9   r   r   r   r   ⁄<module>   s   ">                                                                                                                                                                                               usr/lib/python3.4/distutils/command/__pycache__/bdist_rpm.cpython-34.pyc                            0100644 0000000 0000000 00000033735 13077704335 024677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T¶T  „               @   sÆ   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z d d l Td d l m Z d d	 l m Z Gd
 d Ñ  d e É Z d S)zwdistutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions).È    N)⁄Command)⁄DEBUG)⁄get_platform)⁄
write_file)⁄*)⁄get_python_version)⁄logc            +   @   s  e  Z d  Z d Z df dg dh di dj dk dl dm dn do dp dq dr ds dt du dv dw dx dy dz d{ d| d} d~ d dÄ dÅ dÇ dÉ dÑ dÖ dÜ dá dà dâ dä dã då dç dé g) Z d4 d9 d= d2 dU g Z i d4 d7 6d9 d; 6d= d? 6Z dX dY Ñ  Z dZ d[ Ñ  Z d\ d] Ñ  Z	 d^ d_ Ñ  Z
 d` da Ñ  Z db dc Ñ  Z dd de Ñ  Z d S)è⁄	bdist_rpmzcreate an RPM distribution˙bdist-base=N˙/base directory for creating built distributions˙	rpm-base=˙dbase directory for creating RPMs (defaults to "rpm" under --bdist-base; must be specified for RPM 2)˙	dist-dir=⁄d˙Ddirectory to put final RPM files in (and .spec files if --spec-only)˙python=˙Mpath to Python interpreter to hard-code in the .spec file (default: "python")˙
fix-python˙Lhard-code the exact path to the current Python interpreter in the .spec file˙	spec-only˙only regenerate spec file˙source-only˙only generate source RPM˙binary-only˙only generate binary RPM˙	use-bzip2˙7use bzip2 instead of gzip to create source distribution˙distribution-name=˙gname of the (Linux) distribution to which this RPM applies (*not* the name of the module distribution!)˙group=˙9package classification [default: "Development/Libraries"]˙release=˙RPM release number˙serial=˙RPM serial number˙vendor=˙aRPM "vendor" (eg. "Joe Blow <joe@example.com>") [default: maintainer or author from setup script]˙	packager=˙ARPM packager (eg. "Jane Doe <jane@example.net>")[default: vendor]˙
doc-files=˙6list of documentation files (space or comma-separated)˙
changelog=˙RPM changelog˙icon=˙name of icon file˙	provides=˙%capabilities provided by this package˙	requires=˙%capabilities required by this package˙
conflicts=˙-capabilities which conflict with this package˙build-requires=˙+capabilities required to build this package˙
obsoletes=˙*capabilities made obsolete by this package˙
no-autoreq˙+do not automatically calculate dependencies˙	keep-temp⁄k˙"don't clean up RPM build directory˙no-keep-temp˙&clean up RPM build directory [default]˙use-rpm-opt-flags˙8compile with RPM_OPT_FLAGS when building from source RPM˙no-rpm-opt-flags˙&do not pass any RPM CFLAGS to compiler˙	rpm3-mode˙"RPM 3 compatibility mode (default)˙	rpm2-mode˙RPM 2 compatibility mode˙prep-script=˙3Specify a script for the PREP phase of RPM building˙build-script=˙4Specify a script for the BUILD phase of RPM building˙pre-install=˙:Specify a script for the pre-INSTALL phase of RPM building˙install-script=˙6Specify a script for the INSTALL phase of RPM building˙post-install=˙;Specify a script for the post-INSTALL phase of RPM building˙pre-uninstall=˙<Specify a script for the pre-UNINSTALL phase of RPM building˙post-uninstall=˙=Specify a script for the post-UNINSTALL phase of RPM building˙clean-script=˙4Specify a script for the CLEAN phase of RPM building˙verify-script=˙6Specify a script for the VERIFY phase of the RPM build˙force-arch=˙0Force an architecture onto the RPM build process⁄quiet⁄q˙3Run the INSTALL phase of RPM building in quiet modec             C   sc  d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _  d |  _! d |  _" d |  _# d |  _$ d  |  _% d |  _& d  S)Nr   È   )'⁄
bdist_base⁄rpm_base⁄dist_dir⁄python⁄
fix_python⁄	spec_only⁄binary_only⁄source_only⁄	use_bzip2⁄distribution_name⁄group⁄release⁄serial⁄vendor⁄packager⁄	doc_files⁄	changelog⁄icon⁄prep_script⁄build_script⁄install_script⁄clean_script⁄verify_script⁄pre_install⁄post_install⁄pre_uninstall⁄post_uninstall⁄prep⁄provides⁄requires⁄	conflicts⁄build_requires⁄	obsoletes⁄	keep_temp⁄use_rpm_opt_flags⁄	rpm3_mode⁄
no_autoreq⁄
force_archr\   )⁄self© rá   ˙1/usr/lib/python3.4/distutils/command/bdist_rpm.py⁄initialize_optionsà   sN    																																						zbdist_rpm.initialize_optionsc             C   s  |  j  d d É |  j d  k rU |  j s7 t d É Ç n  t j j |  j d É |  _ n  |  j d  k rà |  j	 r| t
 j |  _ q† d |  _ n |  j	 r† t d É Ç n  t j d k r≈ t d t j É Ç n  |  j rÊ |  j rÊ t d	 É Ç n  |  j j É  sd
 |  _ n  |  j  d d É |  j É  d  S)NZbdistr`   z)you must specify --rpm-base in RPM 2 mode⁄rpmZpython3z8--python and --fix-python are mutually exclusive options⁄posixz9don't know how to create RPM distributions on platform %sz6cannot supply both '--source-only' and '--binary-only'r   rb   )˙
bdist_baserå   )˙dist_dirrç   )Zset_undefined_optionsra   rÉ   ZDistutilsOptionError⁄os⁄path⁄joinr`   rc   rd   ⁄sys⁄
executable⁄nameZDistutilsPlatformErrorrf   rg   ⁄distribution⁄has_ext_modulesrÇ   ⁄finalize_package_data)rÜ   rá   rá   rà   ⁄finalize_optionsµ   s.    			zbdist_rpm.finalize_optionsc             C   s–  |  j  d d É |  j  d d |  j j É  |  j j É  f É |  j  d É |  j d É t |  j t É r∞ xE d D]: } t j	 j
 | É ro | |  j k ro |  j j | É qo qo Wn  |  j  d	 d
 É |  j  d É |  j  d É |  j  d É |  j |  j É |  _ |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j d É |  j  d É d  S)Nrj   zDevelopment/Librariesrm   z%s <%s>rn   ro   ⁄README˙
README.txtrk   ⁄1rl   ri   rp   rq   rr   rs   rt   ru   rv   rw   rx   ry   rz   r|   r}   r~   r   rÄ   rÖ   )rò   rô   )Zensure_stringrî   Zget_contactZget_contact_emailZensure_string_list⁄
isinstancero   ⁄listré   rè   ⁄exists⁄append⁄_format_changelogrp   Zensure_filename)rÜ   Zreadmerá   rá   rà   rñ   ‘   s>    	!zbdist_rpm.finalize_package_datac             C   sT  t  rS t d É t d |  j É t d |  j É t d |  j É t d |  j É n  |  j ru |  j } |  j | É nN i  } x; d) D]3 } t	 j
 j |  j | É | | <|  j | | É qÇ W| d } t	 j
 j | d |  j j É  É } |  j t | |  j É  f d | É |  j rd  S|  j j d  d  Ö } |  j d É } |  j rRd g | _ n d g | _ |  j d É | |  j _ | j É  d } | d } |  j | | É |  j rÎt	 j
 j |  j É r’|  j |  j | É qÎt d |  j É Ç n  t j d É d g }	 t	 j
 j d É s%t	 j
 j d É r1d g }	 n  |  j rJ|	 j d É n& |  j  rc|	 j d É n |	 j d É |	 j! d d |  j" g É |  j# rº|	 j! d d t	 j
 j$ |  j É g É n  |  j% s’|	 j d É n  |  j& rÓ|	 j d É n  |	 j | É d }
 |
 d  } d! |
 d" } d# | | | f } t	 j' | É } z´ g  } d  } xm | j( É  } | scPn  | j) É  j* É  } t+ | É d$ k sçt, Ç | j | d% É | d  k rM| d } qMqM| j- É  } | rÂt. d& t/ | É É Ç n  Wd  | j- É  X|  j0 |	 É |  j1 sP|  j j2 É  r%t3 É  } n d' } |  j  sØt	 j
 j | d
 | É } t	 j
 j | É set, Ç |  j4 | |  j É t	 j
 j |  j | É } |  j j j d( | | f É n  |  j sPxí | D]á } t	 j
 j | d	 | É } t	 j
 j | É rø|  j4 | |  j É t	 j
 j |  j t	 j
 j5 | É É } |  j j j d( | | f É qøqøWqPn  d  S)*Nzbefore _get_package_data():zvendor =z
packager =zdoc_files =zchangelog =⁄SOURCES⁄SPECS⁄BUILD⁄RPMS⁄SRPMSz%s.speczwriting '%s'⁄sdistZbztarZgztarr   zicon file '%s' does not existzbuilding RPMsrä   z/usr/bin/rpmbuildz/bin/rpmbuildZrpmbuildz-bsz-bbz-baz--definez__python %sz
_topdir %sz--cleanz--quietz%{name}-%{version}-%{release}z.src.rpmz%{arch}/z.%{arch}.rpmz%rpm -q --qf '%s %s\n' --specfile '%s'È   r_   zFailed to execute: %s⁄anyr	   )r†   r°   r¢   r£   r§   )6r   ⁄printrm   rn   ro   rp   re   rb   Zmkpathré   rè   rê   ra   rî   ⁄get_nameZexecuter   ⁄_make_spec_fileZ
dist_filesZreinitialize_commandrh   ZformatsZrun_commandZget_archive_filesZ	copy_filerq   rù   ZDistutilsFileErrorr   ⁄inforg   rû   rf   ⁄extendrc   rÉ   ⁄abspathrÅ   r\   ⁄popen⁄readline⁄strip⁄split⁄len⁄AssertionError⁄closeZDistutilsExecError⁄reprZspawnZdry_runrï   r   Z	move_file⁄basename)rÜ   Zspec_dirZrpm_dirr   Z	spec_pathZsaved_dist_filesr•   ⁄sourceZ
source_dirZrpm_cmdZ
nvr_stringZsrc_rpmZnon_src_rpmZq_cmd⁄outZbinary_rpmsZ
source_rpm⁄line⁄lZstatusZ	pyversionZsrpm⁄filenamerä   rá   rá   rà   ⁄run  s∆    
		
			
						 		
			zbdist_rpm.runc             C   s"   t  j j |  j t  j j | É É S)N)ré   rè   rê   rb   r∂   )rÜ   rè   rá   rá   rà   ⁄
_dist_pathà  s    zbdist_rpm._dist_pathc             C   so  d |  j  j É  d |  j  j É  j d d É d |  j  j É  d |  j j d d É d d |  j  j É  g } t j d	 É } d
 j d d Ñ  | j	 É  DÉ É } d } d } | j | | É } | | k rÎ | j
 d É | j
 d | d
 É n  | j d d d g É |  j r| j
 d É n | j
 d É | j d |  j  j É  d |  j d d g É |  j s|  j  j É  sì| j
 d É qìn | j
 d |  j É x{ dK D]s } t |  | j É  É } t | t É rÁ| j
 d" | d# j | É f É qö| d$ k	 rö| j
 d" | | f É qöqöW|  j  j É  d% k rC| j
 d& |  j  j É  É n  |  j rc| j
 d' |  j É n  |  j rå| j
 d( d# j |  j É É n  |  j r∏| j
 d) t j j |  j É É n  |  j r—| j
 d* É n  | j d d+ |  j  j É  g É d, |  j t j j t j  d- É f } d. | }	 |  j! r6d/ |	 }	 n  d0 | }
 dL d4 d5 |	 f d6 d7 |
 f dM dN dO dP dQ dR g	 } xá | D] \ } } } t |  | É } | s§| rz| j d dE | g É | rÈ| j t" | dF É j# É  j$ d
 É É q˘| j
 | É qzqzW| j d dG dH g É |  j% r<| j
 dI d# j |  j% É É n  |  j& rk| j d dJ g É | j |  j& É n  | S)SziGenerate the text of an RPM spec file and return it as a
        list of strings (one per line).
        z%define name z%define version ˙-⁄_z%define unmangled_version z%define release ⁄ z	Summary: zrpm --eval %{__os_install_post}⁄
c             S   s    g  |  ] } d  | j  É  ë q S)z  %s \)r∞   )⁄.0rπ   rá   rá   rà   ˙
<listcomp>ü  s   	z-bdist_rpm._make_spec_file.<locals>.<listcomp>zbrp-python-bytecompile \
z%brp-python-bytecompile %{__python} \
z2# Workaround for http://bugs.python.org/issue14443z%define __os_install_post zName: %{name}zVersion: %{version}zRelease: %{release}z-Source0: %{name}-%{unmangled_version}.tar.bz2z,Source0: %{name}-%{unmangled_version}.tar.gzz	License: zGroup: z>BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildrootzPrefix: %{_prefix}zBuildArch: noarchzBuildArch: %s⁄Vendor⁄Packager⁄Provides⁄Requires⁄	Conflicts⁄	Obsoletesz%s: %s˙ NZUNKNOWNzUrl: zDistribution: zBuildRequires: zIcon: z
AutoReq: 0z%descriptionz%s %sr   z%s buildzenv CFLAGS="$RPM_OPT_FLAGS" z>%s install -O1 --root=$RPM_BUILD_ROOT --record=INSTALLED_FILESr{   rr   ˙&%setup -n %{name}-%{unmangled_version}Zbuildrs   Zinstallrt   ⁄cleanru   ˙rm -rf $RPM_BUILD_ROOT⁄verifyscriptrv   ⁄prerw   ⁄postrx   ⁄preunry   ⁄postunrz   ˙%⁄rz%files -f INSTALLED_FILESz%defattr(-,root,root)z%doc z
%changelog)rƒ   r≈   r∆   r«   r»   r…   )zprepzprep_scriptrÀ   )rÃ   zclean_scriptrÕ   )rŒ   zverify_scriptN)rœ   zpre_installN)r–   zpost_installN)r—   zpre_uninstallN)r“   zpost_uninstallN)'rî   r©   Zget_version⁄replacerk   Zget_description⁄
subprocessZ	getoutputrê   ⁄
splitlinesrû   r¨   rh   Zget_licenserj   rÖ   rï   ⁄getattr⁄lowerrõ   rú   Zget_urlri   r   rq   ré   rè   r∂   rÑ   Zget_long_descriptionrc   rë   ⁄argvrÇ   ⁄open⁄readr±   ro   rp   )rÜ   Z	spec_fileZvendor_hookZproblemZfixedZ
fixed_hookZfield⁄valZdef_setup_callZ	def_buildZinstall_cmdZscript_optionsZrpm_opt⁄attr⁄defaultrá   rá   rà   r™   ã  s∫    	
	

	    
#				#	&
		(
	 	
zbdist_rpm._make_spec_filec             C   s´   | s
 | Sg  } xÄ | j  É  j d É D]i } | j  É  } | d d k r^ | j d | g É q& | d d k r~ | j | É q& | j d | É q& W| d sß | d =n  | S)zKFormat the changelog correctly and convert it to a list of strings
        r¡   r   r   r¿   ræ   z  )r∞   r±   r¨   rû   )rÜ   rp   Znew_changelogrπ   rá   rá   rà   rü   3  s    

zbdist_rpm._format_changelog)r
   Nr   )r   Nr   )r   r   r   )r   Nr   )r   Nr   )r   Nr   )r   Nr   )r   Nr   )r   Nr   )r   Nr   )r   Nr    )r!   Nr"   )r#   Nr$   )r%   Nr&   )r'   Nr(   )r)   Nr*   )r+   Nr,   )r-   Nr.   )r/   Nr0   )r1   Nr2   )r3   Nr4   )r5   Nr6   )r7   Nr8   )r9   Nr:   )r;   r<   r=   )r>   Nr?   )r@   NrA   )rB   NrC   )rD   NrE   )rF   NrG   )rH   NrI   )rJ   NrK   )rL   NrM   )rN   NrO   )rP   NrQ   )rR   NrS   )rT   NrU   )rV   NrW   )rX   NrY   )rZ   Nr[   )zquietr]   r^   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsZnegative_optrâ   ró   rñ   rº   rΩ   r™   rü   rá   rá   rá   rà   r	      sæ                                            		

--á®r	   )⁄__doc__r÷   rë   ré   Zdistutils.corer   Zdistutils.debugr   Zdistutils.utilr   Zdistutils.file_utilr   Zdistutils.errorsZdistutils.sysconfigr   Z	distutilsr   r	   rá   rá   rá   rà   ⁄<module>   s   $
                                   usr/lib/python3.4/distutils/command/__pycache__/bdist_wininst.cpython-34.pyc                        0100644 0000000 0000000 00000021417 13077704335 025566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tƒ:  „               @   sò   d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z m	 Z	 d d l
 Td d l m Z d d l m Z Gd	 d
 Ñ  d
 e É Z d S)zzdistutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program.È    N)⁄Command)⁄get_platform)⁄create_tree⁄remove_tree)⁄*)⁄get_python_version)⁄logc               @   s÷   e  Z d  Z d Z d4 d d d e É  f d d	 d
 d f d d d d f d5 d6 d7 d8 d9 d: d; d< d= g Z d d d d g Z d& d' Ñ  Z d( d) Ñ  Z d* d+ Ñ  Z	 d, d- Ñ  Z
 d d. d/ Ñ Z d0 d1 Ñ  Z d2 d3 Ñ  Z d S)>⁄bdist_wininstz-create an executable installer for MS Windows˙
bdist-dir=N˙1temporary directory for creating the distributionz
plat-name=⁄pz;platform name to embed in generated filenames (default: %s)z	keep-temp⁄kz/keep the pseudo-installation tree around after z!creating the distribution archiveztarget-version=z!require a specific python versionz on the target system˙no-target-compile⁄c˙/do not compile .py to .pyc on the target system˙no-target-optimize⁄o˙:do not compile .py to .pyo (optimized)on the target system˙	dist-dir=⁄d˙-directory to put final built distributions in˙bitmap=⁄b˙>bitmap to use for the installer instead of python-powered logo˙title=⁄t˙?title to display on the installer background instead of default˙
skip-build˙2skip rebuilding everything (for testing/debugging)˙install-script=˙Tbasename of installation script to be run afterinstallation or before deinstallation˙pre-install-script=˙{Fully qualified filename of a script to be run before any files are installed.  This script need not be in the distribution˙user-access-control=˙äspecify Vista's UAC handling - 'none'/default=no handling, 'auto'=use UAC if target Python installed for all users, 'force'=always use UACc             C   sy   d  |  _  d  |  _ d |  _ d |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  S)Nr   )⁄	bdist_dir⁄	plat_name⁄	keep_temp⁄no_target_compile⁄no_target_optimize⁄target_version⁄dist_dir⁄bitmap⁄title⁄
skip_build⁄install_script⁄pre_install_script⁄user_access_control)⁄self© r3   ˙5/usr/lib/python3.4/distutils/command/bdist_wininst.py⁄initialize_options:   s    												z bdist_wininst.initialize_optionsc             C   s\  |  j  d d	 É |  j d  k r |  j rR |  j rR |  j j d É } |  j | _ n  |  j d É j } t j	 j
 | d É |  _ n  |  j sî d |  _ n  |  j r |  j j É  r t É  } |  j r‰ |  j | k r‰ t d | f É Ç n  | |  _ n  |  j  d d
 d É |  j rXxI |  j j D]% } |  j t j	 j | É k rPqqWt d |  j É Ç n  d  S)N⁄bdistr.   Zwininst⁄ zMtarget version can only be %s, or the '--skip-build' option must be specifiedr+   r&   z(install_script '%s' not found in scripts)˙
skip_buildr8   )˙dist_dirr9   )˙	plat_namer:   )Zset_undefined_optionsr%   r.   r&   ⁄distributionZget_command_obj⁄get_finalized_command⁄
bdist_base⁄os⁄path⁄joinr*   ⁄has_ext_modulesr   ZDistutilsOptionErrorr/   ⁄scripts⁄basename)r2   r6   r=   Zshort_version⁄scriptr3   r3   r4   ⁄finalize_optionsJ   s4    				zbdist_wininst.finalize_optionsc             C   s«  t  j d k r< |  j j É  s- |  j j É  r< t d É Ç n  |  j sU |  j d É n  |  j d d d É} |  j	 | _
 |  j | _ d | _ |  j | _ |  j d É } d | _ d | _ |  j j É  rE|  j } | s|  j sÎ t d	 É Ç t  j d d
 Ö } n  d |  j | f } |  j d É } t j j | j d | É | _ n  xG d D]? } | j É  } | d k rw| d } n  t | d | | É qLWt j d |  j	 É | j É  t  j j d t j j |  j	 d É É | j É  t  j d =d d l m  } | É  }	 |  j j! É  }
 |  j" |	 d d |  j	 É} |  j# | |
 |  j$ É |  j j É  rYt% É  } n d } |  j j& j' d | |  j( |
 É f É t j) d | É t j* | É |  j+ s√t, |  j	 d |  j- Én  d  S)N⁄win32z^distribution contains extensions and/or C libraries; must be compiled on a Windows 32 platform⁄build⁄installZreinit_subcommandsÈ   r   ⁄install_libz Should have already checked thisÈ   z.%s-%sZlib⁄purelib⁄platlib⁄headersrB   ⁄dataz/Include/$dist_nameZinstall_zinstalling to %sZPURELIB)⁄mktemp⁄zipZroot_dir⁄anyr	   zremoving temporary file '%s'⁄dry_run)rL   rM   rN   zscriptszdata).⁄sys⁄platformr;   rA   Zhas_c_librariesZDistutilsPlatformErrorr.   Zrun_commandZreinitialize_commandr%   ⁄rootZwarn_dirr&   ⁄compile⁄optimizer*   ⁄AssertionError⁄versionr<   r>   r?   r@   Z
build_baseZ	build_lib⁄upper⁄setattrr   ⁄infoZensure_finalized⁄insert⁄runZtempfilerP   ⁄get_fullnameZmake_archive⁄
create_exer,   r   Z
dist_files⁄append⁄get_installer_filename⁄debug⁄remover'   r   rS   )r2   rH   rJ   r*   Zplat_specifierrG   ⁄key⁄valuerP   Zarchive_basename⁄fullname⁄arcnameZ	pyversionr3   r3   r4   r_   p   sd    					
%

		zbdist_wininst.runc             C   sÙ  g  } |  j  j } | j d É | j p+ d d } d d Ñ  } x~ d d d d	 d
 d d d g D]^ } t | | d É } | r] | d | j É  | | É f } | j d | | | É f É q] q] W| j d É |  j rÏ | j d |  j É n  | j d | | É É | j d |  j É | j d |  j É |  j	 rM| j d |  j	 É n  |  j
 rm| j d |  j
 É n  |  j pÇ|  j  j É  } | j d | | É É d d  l } d d  l }	 d | j | j É  É |	 j f }
 | j d |
 É d j | É S)Nz
[metadata]r7   ⁄
c             S   s   |  j  d d É S)Nrj   z\n)⁄replace)⁄sr3   r3   r4   ⁄escapeŒ   s    z)bdist_wininst.get_inidata.<locals>.escapeZauthorZauthor_email⁄descriptionZ
maintainerZmaintainer_email⁄nameZurlrZ   z
    %s: %sz%s=%sz
[Setup]zinstall_script=%szinfo=%sztarget_compile=%dztarget_optimize=%dztarget_version=%szuser_access_control=%sztitle=%sr   zBuilt %s with distutils-%szbuild_info=%s)r;   ⁄metadatarb   Zlong_description⁄getattr⁄
capitalizer/   r(   r)   r*   r1   r-   r`   ⁄time⁄	distutilsZctime⁄__version__r@   )r2   ⁄linesrp   r]   rm   ro   rO   r-   rs   rt   Z
build_infor3   r3   r4   ⁄get_inidata¡   s<    $			zbdist_wininst.get_inidatac             C   sç  d d  l  } |  j |  j É |  j É  } |  j | É } |  j d | É | rr t | d É j É  } t | É } n d } t | d É }	 |	 j	 |  j
 É  É | r∞ |	 j	 | É n  t | t É r— | j d É } n  | d } |  j r+t |  j d d d	 Éè }
 |
 j É  j d	 É } Wd  QX| | d
 } n
 | d } |	 j	 | É | j d d t | É | É } |	 j	 | É |	 j	 t | d É j É  É d  S)Nr   zcreating %s⁄rb⁄wb⁄mbcss    ⁄r⁄encodingzlatin-1s   
 z<iiii{V4)⁄structZmkpathr+   rw   rc   Zannounce⁄open⁄read⁄len⁄write⁄get_exe_bytes⁄
isinstance⁄str⁄encoder0   Zpack)r2   ri   rh   r,   r}   Zcfgdata⁄installer_nameZ
bitmapdataZ	bitmaplen⁄filerD   Zscript_data⁄headerr3   r3   r4   ra   Ô   s:    
	
			zbdist_wininst.create_exec             C   s`   |  j  r7 t j j |  j d | |  j |  j  f É } n% t j j |  j d | |  j f É } | S)Nz%s.%s-py%s.exez	%s.%s.exe)r*   r>   r?   r@   r+   r&   )r2   rh   rÜ   r3   r3   r4   rc   $  s    	z$bdist_wininst.get_installer_filenamec       	      C   s`  d d l  m } t É  } |  j rm |  j | k rm |  j | k rL | É  } qv |  j d k  rd d } qv d } n	 | É  } t j j t É } |  j d k r∆ |  j d  d Ö d k r∆ |  j d d  Ö } n d	 } t j j	 | d
 | | f É } y t
 | d É } Wn? t k
 r?} z t t | É d | É Ç WYd  d  } ~ Xn Xz | j É  SWd  | j É  Xd  S)Nr   )⁄get_build_versionz2.4g      @gffffff@rF   rK   ⁄winr7   zwininst-%.1f%s.exerx   z), %s not included in the Debian packages.)Zdistutils.msvccompilerrâ   r   r*   r>   r?   ⁄dirname⁄__file__r&   r@   r~   ⁄IOErrorZDistutilsFileErrorrÑ   r   ⁄close)	r2   râ   Zcur_versionZbvZ	directoryZsfix⁄filename⁄f⁄er3   r3   r4   rÇ   1  s*    					(-zbdist_wininst.get_exe_bytes)r
   Nr   )r   r   r   )r   r   r   )r   r   r   )r   r   r   )r   r   r   )r   Nr   )r   Nr    )r!   Nr"   )r#   Nr$   )⁄__name__⁄
__module__⁄__qualname__rn   r   Zuser_optionsZboolean_optionsr5   rE   r_   rw   ra   rc   rÇ   r3   r3   r3   r4   r	      sN    
         			&Q.5r	   )⁄__doc__rT   r>   Zdistutils.corer   Zdistutils.utilr   Zdistutils.dir_utilr   r   Zdistutils.errorsZdistutils.sysconfigr   rt   r   r	   r3   r3   r3   r4   ⁄<module>   s   
                                                                                                                                                                                                                                                 usr/lib/python3.4/distutils/command/__pycache__/build.cpython-34.pyc                                0100644 0000000 0000000 00000007724 13077704335 024012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T%  „               @   st   d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d Ñ  Z	 Gd d	 Ñ  d	 e É Z
 d S)
zBdistutils.command.build

Implements the Distutils 'build' command.È    N)⁄Command)⁄DistutilsOptionError)⁄get_platformc              C   s   d d l  m }  |  É  d  S)Nr   )⁄show_compilers)Zdistutils.ccompilerr   )r   © r   ˙-/usr/lib/python3.4/distutils/command/build.pyr      s    r   c               @   s˘   e  Z d  Z d Z d5 d6 d7 d
 d d d f d8 d9 d d d e É  f d: d; d< d= g Z d d g Z d! d d" e f g Z d# d$ Ñ  Z	 d% d& Ñ  Z
 d' d( Ñ  Z d) d* Ñ  Z d+ d, Ñ  Z d- d. Ñ  Z d/ d0 Ñ  Z d1 e f d2 e f d3 e f d4 e f g Z d S)>⁄buildz"build everything needed to install˙build-base=⁄b˙ base directory for build library˙build-purelib=N˙2build directory for platform-neutral distributions˙build-platlib=˙3build directory for platform-specific distributionsz
build-lib=z9build directory for all distribution (defaults to either zbuild-purelib or build-platlib˙build-scripts=˙build directory for scripts˙build-temp=⁄t˙temporary build directoryz
plat-name=⁄pz6platform name to build for, if supported (default: %s)˙	compiler=⁄c˙specify the compiler type⁄debug⁄g˙;compile extensions and libraries with debugging information⁄force⁄f˙2forcibly build everything (ignore file timestamps)˙executable=⁄e˙5specify final destination interpreter path (build.py)zhelp-compilerzlist available compilersc             C   sg   d |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _	 d  |  _
 d  S)Nr   r   )⁄
build_base⁄build_purelib⁄build_platlib⁄	build_lib⁄
build_temp⁄build_scriptsZcompiler⁄	plat_namer   r   ⁄
executable)⁄selfr   r   r   ⁄initialize_options6   s    										zbuild.initialize_optionsc             C   s¨  |  j  d  k r t É  |  _  n t j d k r< t d É Ç n  d |  j  t j d d Ö f } t t d É rx | d 7} n  |  j d  k r• t j	 j
 |  j d É |  _ n  |  j d  k r÷ t j	 j
 |  j d | É |  _ n  |  j d  k r|  j j r |  j |  _ q|  j |  _ n  |  j d  k r@t j	 j
 |  j d	 | É |  _ n  |  j d  k r~t j	 j
 |  j d
 t j d d Ö É |  _ n  |  j d  k r®t j	 j t j É |  _ n  d  S)N⁄ntzW--plat-name only supported on Windows (try using './configure --help' on your platform)z.%s-%sr   È   Zgettotalrefcountz-pydebugZlibZtempzscripts-)r(   r   ⁄os⁄namer   ⁄sys⁄version⁄hasattrr#   ⁄path⁄joinr"   r$   r%   ⁄distributionZext_modulesr&   r'   r)   ⁄normpath)r*   Zplat_specifierr   r   r   ⁄finalize_optionsE   s2      zbuild.finalize_optionsc             C   s(   x! |  j  É  D] } |  j | É q Wd  S)N)Zget_sub_commandsZrun_command)r*   Zcmd_namer   r   r   ⁄runw   s    z	build.runc             C   s   |  j  j É  S)N)r5   ⁄has_pure_modules)r*   r   r   r   r9   É   s    zbuild.has_pure_modulesc             C   s   |  j  j É  S)N)r5   ⁄has_c_libraries)r*   r   r   r   r:   Ü   s    zbuild.has_c_librariesc             C   s   |  j  j É  S)N)r5   ⁄has_ext_modules)r*   r   r   r   r;   â   s    zbuild.has_ext_modulesc             C   s   |  j  j É  S)N)r5   ⁄has_scripts)r*   r   r   r   r<   å   s    zbuild.has_scriptsZbuild_pyZ
build_clibZ	build_extr'   )r	   r
   r   )r   Nr   )r   Nr   )r   Nr   )r   r   r   )r   r   r   )zdebugr   r   )zforcer   r   )r   r    r!   )⁄__name__⁄
__module__⁄__qualname__Zdescriptionr   Zuser_optionsZboolean_optionsr   Zhelp_optionsr+   r7   r8   r9   r:   r;   r<   Zsub_commandsr   r   r   r   r      sN        
    	2			r   )⁄__doc__r0   r.   Zdistutils.corer   Zdistutils.errorsr   Zdistutils.utilr   r   r   r   r   r   r   ⁄<module>   s                                               usr/lib/python3.4/distutils/command/__pycache__/build_clib.cpython-34.pyc                           0100644 0000000 0000000 00000012466 13077704335 025002  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TV  „               @   sr   d  Z  d d l Z d d l m Z d d l Td d l m Z d d l m Z d d Ñ  Z	 Gd	 d
 Ñ  d
 e É Z
 d S)z¥distutils.command.build_clib

Implements the Distutils 'build_clib' command, to build a C/C++ library
that is included in the module distribution and needed by an extension
module.È    N)⁄Command)⁄*)⁄customize_compiler)⁄logc              C   s   d d l  m }  |  É  d  S)Nr   )⁄show_compilers)⁄distutils.ccompilerr   )r   © r   ˙2/usr/lib/python3.4/distutils/command/build_clib.pyr      s    r   c               @   s†   e  Z d  Z d Z d" d# d$ d% d& g Z d d g Z d d d e f g Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d  d! Ñ  Z d S)'⁄
build_clibz/build C/C++ libraries used by Python extensions˙build-clib=⁄b˙%directory to build C/C++ libraries to˙build-temp=⁄t˙,directory to put temporary build by-products⁄debug⁄g˙"compile with debugging information⁄force⁄f˙2forcibly build everything (ignore file timestamps)˙	compiler=⁄c˙specify the compiler typezhelp-compilerNzlist available compilersc             C   sU   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  S)Nr   )	r
   ⁄
build_temp⁄	libraries⁄include_dirs⁄define⁄undefr   r   ⁄compiler)⁄selfr   r   r	   ⁄initialize_options4   s    								zbuild_clib.initialize_optionsc             C   sü   |  j  d d d d	 d
 d É |  j j |  _ |  j rG |  j |  j É n  |  j d  k rn |  j j pe g  |  _ n  t |  j t É rõ |  j j t j	 É |  _ n  d  S)NZbuildr   r
   r   r   r   )˙
build_tempz
build_clib)r"   r"   )˙compilerr#   )˙debugr$   )˙forcer%   )
Zset_undefined_optionsZdistributionr   ⁄check_library_listr   ⁄
isinstance⁄str⁄split⁄os⁄pathsep)r    r   r   r	   ⁄finalize_optionsD   s    		zbuild_clib.finalize_optionsc             C   sˇ   |  j  s d  Sd d l m } | d |  j d |  j d |  j É |  _ t |  j É |  j d  k	 rv |  j j |  j É n  |  j	 d  k	 rµ x- |  j	 D] \ } } |  j j
 | | É qè Wn  |  j d  k	 rÎ x$ |  j D] } |  j j | É qŒ Wn  |  j |  j  É d  S)Nr   )⁄new_compilerr   ⁄dry_runr   )r   r   r-   r   r.   r   r   r   Zset_include_dirsr   Zdefine_macror   Zundefine_macro⁄build_libraries)r    r-   ⁄name⁄valueZmacror   r   r	   ⁄run^   s     		zbuild_clib.runc             C   sÌ   t  | t É s t d É Ç n  x» | D]¿ } t  | t É r\ t | É d k r\ t d É Ç n  | \ } } t  | t É sÜ t d É Ç n  d | k s∞ t j d k r« t j | k r« t d | d É Ç n  t  | t É s% t d É Ç q% q% Wd	 S)
a`  Ensure that the list of libraries is valid.

        `library` is presumably provided as a command option 'libraries'.
        This method checks that it is a list of 2-tuples, where the tuples
        are (library_name, build_info_dict).

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        z+'libraries' option must be a list of tuplesÈ   z*each element of 'libraries' must a 2-tuplezNfirst element of each tuple in 'libraries' must be a string (the library name)˙/z;bad library name '%s': may not contain directory separatorsr   zMsecond element of each tuple in 'libraries' must be a dictionary (build info)N)	r'   ⁄list⁄DistutilsSetupError⁄tuple⁄lenr(   r*   ⁄sep⁄dict)r    r   Zlibr0   ⁄
build_infor   r   r	   r&   v   s"    
"*zbuild_clib.check_library_listc             C   s>   |  j  s d  Sg  } x$ |  j  D] \ } } | j | É q W| S)N)r   ⁄append)r    Z	lib_names⁄lib_namer;   r   r   r	   ⁄get_library_namesö   s    	zbuild_clib.get_library_namesc             C   sÖ   |  j  |  j É g  } xh |  j D]] \ } } | j d É } | d  k s] t | t t f É rp t d | É Ç n  | j | É q  W| S)N⁄sourceszfin 'libraries' option (library '%s'), 'sources' must be present and must be a list of source filenames)r&   r   ⁄getr'   r5   r7   r6   ⁄extend)r    ⁄	filenamesr=   r;   r?   r   r   r	   ⁄get_source_files¶   s    "zbuild_clib.get_source_filesc             C   sÓ   xÁ | D]ﬂ \ } } | j  d É } | d  k sD t | t t f É rW t d | É Ç n  t | É } t j d | É | j  d É } | j  d É } |  j j | d |  j	 d | d | d |  j
 É} |  j j | | d |  j d |  j
 Éq Wd  S)Nr?   zfin 'libraries' option (library '%s'), 'sources' must be present and must be a list of source filenameszbuilding '%s' library⁄macrosr   Z
output_dirr   )r@   r'   r5   r7   r6   r   ⁄infor   ⁄compiler   r   Zcreate_static_libr
   )r    r   r=   r;   r?   rD   r   Zobjectsr   r   r	   r/   µ   s$    "		zbuild_clib.build_libraries)r   r   r   )r   r   r   )zdebugr   r   )zforcer   r   )r   r   r   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsr   Zhelp_optionsr!   r,   r2   r&   r>   rC   r/   r   r   r   r	   r
      s*        	$r
   )⁄__doc__r*   Zdistutils.corer   Zdistutils.errorsZdistutils.sysconfigr   Z	distutilsr   r   r
   r   r   r   r	   ⁄<module>   s   
                                                                                                                                                                                                          usr/lib/python3.4/distutils/command/__pycache__/build_ext.cpython-34.pyc                            0100644 0000000 0000000 00000041346 13077704335 024670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tz  „               @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l Td d l m Z m	 Z	 d d l m
 Z
 d d l m Z d d l m Z d d	 l m Z d d
 l m Z d d l m Z e j d k rÎ d d l m Z e e É  É Z n  e j d É Z d d Ñ  Z Gd d Ñ  d e É Z d S)z∂distutils.command.build_ext

Implements the Distutils 'build_ext' command, for building extension
modules (currently limited to C extensions, should accommodate C++
extensions ASAP).È    N)⁄Command)⁄*)⁄customize_compiler⁄get_python_version)⁄get_config_h_filename)⁄newer_group)⁄	Extension)⁄get_platform)⁄log)⁄	USER_BASE⁄nt)⁄get_build_versionz3^[a-zA-Z_][a-zA-Z_0-9]*(\.[a-zA-Z_][a-zA-Z_0-9]*)*$c              C   s   d d l  m }  |  É  d  S)Nr   )⁄show_compilers)⁄distutils.ccompilerr   )r   © r   ˙1/usr/lib/python3.4/distutils/command/build_ext.pyr      s    r   c               @   st  e  Z d  Z d Z d e j Z dW dX d	 d
 d e É  f d d d d f d d d e f dY dZ d[ d d d e f d\ d] d^ d_ d` da db dc dd g Z d d% d( d. d5 g Z	 d7 d/ d8 e
 f g Z d9 d: Ñ  Z d; d< Ñ  Z d= d> Ñ  Z d? d@ Ñ  Z dA dB Ñ  Z dC dD Ñ  Z dE dF Ñ  Z dG dH Ñ  Z dI dJ Ñ  Z dK dL Ñ  Z dM dN Ñ  Z dO dP Ñ  Z dQ dR Ñ  Z dS dT Ñ  Z dU dV Ñ  Z d/ S)e⁄	build_extz8build C/C++ extensions (compile/link to build directory)z (separated by '%s')˙
build-lib=⁄b˙(directory for compiled extension modules˙build-temp=⁄t˙1directory for temporary files (build by-products)z
plat-name=⁄pz>platform name to cross-compile for, if supported (default: %s)⁄inplace⁄iz=ignore build-lib and put compiled extensions into the source z,directory alongside your pure Python moduleszinclude-dirs=⁄Iz.list of directories to search for header files˙define=⁄D˙C preprocessor macros to define˙undef=⁄U˙!C preprocessor macros to undefine˙
libraries=⁄l˙!external C libraries to link withzlibrary-dirs=⁄Lz.directories to search for external C libraries˙rpath=⁄R˙7directories to search for shared C libraries at runtime˙link-objects=⁄O˙2extra explicit link objects to include in the link⁄debug⁄g˙'compile/link with debugging information⁄force⁄f˙2forcibly build everything (ignore file timestamps)˙	compiler=⁄c˙specify the compiler type˙swig-cppN˙)make SWIG create C++ files (default is C)˙
swig-opts=˙!list of SWIG command line options˙swig=˙path to the SWIG executable⁄user˙#add user include, library and rpathzhelp-compilerzlist available compilersc             C   s∏   d  |  _  d  |  _ d  |  _ d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S)Nr   )⁄
extensions⁄	build_lib⁄	plat_name⁄
build_tempr   ⁄package⁄include_dirs⁄define⁄undef⁄	libraries⁄library_dirs⁄rpath⁄link_objectsr-   r0   ⁄compiler⁄swig⁄swig_cpp⁄	swig_optsr<   )⁄selfr   r   r   ⁄initialize_optionsi   s(    																			zbuild_ext.initialize_optionsc       
   	   C   sÙ  d d l  m } |  j d d- d. d/ d0 d1 d2 É |  j d  k rP |  j j |  _ n  |  j j |  _ | j É  } | j d
 d É } |  j	 d  k r§ |  j j	 põ g  |  _	 n  t
 |  j	 t É r— |  j	 j t j É |  _	 n  t j t j k r|  j	 j t j j t j d É É n  |  j	 j | É | | k r7|  j	 j | É n  |  j d É |  j d  k r_g  |  _ n  |  j d  k rzg  |  _ n- t
 |  j t É rß|  j j t j É |  _ n  |  j d  k r¬g  |  _ n- t
 |  j t É rÔ|  j j t j É |  _ n  t j d k rÛ|  j j t j j t j d É É t j t j k rW|  j j t j j t j d É É n  |  j r~t j j |  j d É |  _ n t j j |  j d É |  _ |  j	 j t j j t É  É É t t d d  É } | r„|  j j | É n  t  d k rc|  j! d k rd } n |  j! d d  Ö } t j j t j d É } | rPt j j | | É } n  |  j j | É qÛt  d k ró|  j j t j j t j d d É É qÛt  d k rÀ|  j j t j j t j d d É É qÛ|  j j t j j t j d d É É n  t j" d  d Ö d k s%t j" d  d Ö d  k rét j# j$ t j j t j d! É É r{|  j j t j j t j d" d# t% É  d$ É É qé|  j j d% É n  d& r€| j& d' É r€| j' s»|  j j | j& d( É É q€|  j j d% É n  |  j( r|  j( j d) É } d* d+ Ñ  | DÉ |  _( n  |  j) r0|  j) j d) É |  _) n  |  j* d  k rKg  |  _* n |  j* j d, É |  _* |  j+ rt j j t, d É } t j j t, d" É }	 t j j- | É r∏|  j	 j | É n  t j j- |	 É r|  j j |	 É |  j j |	 É qn  d  S)3Nr   )⁄	sysconfigZbuildr?   rA   rJ   r-   r0   r@   Zplat_specificÈ   ZincluderF   r   ZlibsZDebugZReleaseZ_homeÈ	   ⁄win32⁄ È   ZPCbuildÈ   ZPCzVS8.0È   zVS7.1ZVC6È   ⁄cygwin⁄atheos⁄bin⁄libZpythonZconfig⁄.F⁄Py_ENABLE_SHAREDZLIBDIR˙,c             S   s   g  |  ] } | d  f ë q S)⁄1r   )⁄.0Zsymbolr   r   r   ˙
<listcomp>˛   s   	 z.build_ext.finalize_options.<locals>.<listcomp>˙ )˙	build_librd   )˙
build_tempre   )˙compilerrf   )˙debugrg   )˙forcerh   )˙	plat_nameri   ).⁄	distutilsrP   Zset_undefined_optionsrB   ⁄distributionZext_packageZext_modulesr>   Zget_python_incrC   ⁄
isinstance⁄str⁄split⁄os⁄pathsep⁄sys⁄exec_prefix⁄base_exec_prefix⁄append⁄path⁄joinZensure_string_listrF   rG   rH   ⁄name⁄prefixr-   rA   ⁄dirnamer   ⁄getattr⁄MSVC_VERSIONr@   ⁄platform⁄
executable⁄
startswithr   ⁄get_config_varZpython_buildrD   rE   rM   r<   r   ⁄isdir)
rN   rP   Z
py_includeZplat_py_includeZ	_sys_home⁄suffixZnew_libZdefinesZuser_includeZuser_libr   r   r   ⁄finalize_optionsÄ   s¨    	%"%		2$
				zbuild_ext.finalize_optionsc          	   C   s  d d l  m } |  j s d  S|  j j É  rm |  j d É } |  j j | j É  pS g  É |  j	 j
 | j É n  | d |  j d |  j d |  j d |  j É |  _ t |  j É t j d k r· |  j t É  k r· |  j j |  j É n  |  j d  k	 r|  j j |  j É n  |  j d  k	 rEx- |  j D] \ } } |  j j | | É qWn  |  j d  k	 r{x$ |  j D] } |  j j | É q^Wn  |  j d  k	 r†|  j j |  j É n  |  j	 d  k	 r≈|  j j |  j	 É n  |  j d  k	 rÍ|  j j |  j É n  |  j  d  k	 r|  j j! |  j  É n  |  j" É  d  S)	Nr   )⁄new_compiler⁄
build_clibrJ   ⁄verbose⁄dry_runr0   r   )#r   rÉ   r>   rk   Zhas_c_libraries⁄get_finalized_commandrF   ⁄extendZget_library_namesrG   rt   rÑ   rJ   rÖ   rÜ   r0   r   ro   rw   r@   r	   Z
initializerC   Zset_include_dirsrD   Zdefine_macrorE   Zundefine_macroZset_librariesZset_library_dirsrH   Zset_runtime_library_dirsrI   Zset_link_objects⁄build_extensions)rN   rÉ   rÑ   rw   ⁄value⁄macror   r   r   ⁄run  s>    			!zbuild_ext.runc       
      C   s0  t  | t É s t d É Ç n  xt | É D]˝\ } } t  | t É rL q+ n  t  | t É sn t | É d k r} t d É Ç n  | \ } } t j d | É t  | t	 É oµ t
 j | É s« t d É Ç n  t  | t É sÂ t d É Ç n  t | | d É } x< d D]4 } | j | É } | d k	 rˇ t | | | É qˇ qˇ W| j d É | _ d | k ret j d É n  | j d É } | rg  | _ g  | _ xè | D]Ñ }	 t  |	 t É o∑t |	 É d k s…t d É Ç n  t |	 É d k rÚ| j j |	 d É qìt |	 É d k rì| j j |	 É qìqìWn  | | | <q+ Wd S)a¨  Ensure that the list of extensions (presumably provided as a
        command option 'extensions') is valid, i.e. it is a list of
        Extension objects.  We also support the old-style list of 2-tuples,
        where the tuples are (ext_name, build_info), which are converted to
        Extension instances here.

        Raise DistutilsSetupError if the structure is invalid anywhere;
        just returns otherwise.
        z:'ext_modules' option must be a list of Extension instancesÈ   zMeach element of 'ext_modules' option must be an Extension instance or 2-tuplezuold-style (ext_name, build_info) tuple found in ext_modules for extension '%s'-- please convert to Extension instancezRfirst element of each tuple in 'ext_modules' must be the extension name (a string)zOsecond element of each tuple in 'ext_modules' must be a dictionary (build info)⁄sourcesrC   rG   rF   ⁄extra_objects⁄extra_compile_args⁄extra_link_argsNrH   Zdef_filez9'def_file' element of build info dict no longer supported⁄macrosrQ   z9'macros' element of build info dict must be 1- or 2-tupler   )zinclude_dirszlibrary_dirsz	librarieszextra_objectszextra_compile_argszextra_link_args)rQ   rç   )rl   ⁄list⁄DistutilsSetupError⁄	enumerater   ⁄tuple⁄lenr
   ⁄warnrm   ⁄extension_name_re⁄match⁄dict⁄get⁄setattr⁄runtime_library_dirs⁄define_macros⁄undef_macrosrt   )
rN   r>   r   ⁄ext⁄ext_nameZ
build_info⁄key⁄valrí   rã   r   r   r   ⁄check_extensions_listU  sT    
"	 
		!zbuild_ext.check_extensions_listc             C   s>   |  j  |  j É g  } x! |  j D] } | j | j É q  W| S)N)r•   r>   rà   ré   )rN   ⁄	filenamesr°   r   r   r   ⁄get_source_files£  s
    zbuild_ext.get_source_filesc             C   sG   |  j  |  j É g  } x* |  j D] } | j |  j | j É É q  W| S)N)r•   r>   rt   ⁄get_ext_fullpathrw   )rN   Zoutputsr°   r   r   r   ⁄get_outputs¨  s
    zbuild_ext.get_outputsc             C   sì   |  j  |  j É x| |  j D]q } y |  j | É Wq t t t f k
 rä } z. | j s^ Ç  n  |  j d | j | f É WYd  d  } ~ Xq Xq Wd  S)Nz"building extension "%s" failed: %s)	r•   r>   ⁄build_extensionZCCompilerErrorZDistutilsErrorZCompileErrorZoptionalrò   rw   )rN   r°   ⁄er   r   r   râ   ∫  s    		zbuild_ext.build_extensionsc       
      C   s	  | j  } | d  k s+ t | t t f É rA t d | j É Ç n  t | É } |  j | j É } | | j } |  j pÑ t	 | | d É sû t
 j d | j É d  St
 j d | j É |  j | | É } | j pœ g  } | j d  d  Ö } x! | j D] } | j | f É qÔ W|  j j | d |  j d | d | j d |  j d	 | d
 | j É} | d  d  Ö |  _ | j rz| j | j É n  | j pÜg  } | j p°|  j j | É }	 |  j j | | d |  j | É d | j d | j d	 | d |  j  | É d |  j d |  j d |	 Éd  S)Nzjin 'ext_modules' option (extension '%s'), 'sources' must be present and must be a list of source filenamesZnewerz$skipping '%s' extension (up-to-date)zbuilding '%s' extensionZ
output_dirrí   rC   r-   Zextra_postargs⁄dependsrF   rG   rû   ⁄export_symbolsrA   Ztarget_lang)!ré   rl   rì   rñ   rî   rw   r®   r¨   r0   r   r
   r-   ⁄info⁄swig_sourcesrê   rü   r†   rt   rJ   ⁄compilerA   rC   Z_built_objectsrè   rà   rë   ⁄languageZdetect_languageZlink_shared_object⁄get_librariesrG   rû   ⁄get_export_symbols)
rN   r°   ré   ⁄ext_pathr¨   Z
extra_argsrí   rE   Zobjectsr±   r   r   r   r™   «  sN    	"										zbuild_ext.build_extensionc             C   s£  g  } g  } i  } |  j  r+ t j d É n  |  j  sR d |  j k sR d | j k r[ d } n d } xr | D]j } t j j | É \ } }	 |	 d k r≈ | j | d | É | j | É | d | | <qh | j | É qh W| s‡ | S|  j pÚ |  j	 É  }
 |
 d g } | j
 |  j É |  j  r*| j d É n  |  j sWx! | j D] } | j | É q=Wn  xE | D]= } | | } t j d	 | | É |  j | d
 | | g É q^W| S)z¸Walk the list of source files in 'sources', looking for SWIG
        interface (.i) files.  Run SWIG on all that are found, and
        return a modified 'sources' list with SWIG source files replaced
        by the generated C (or C++) files.
        z/--swig-cpp is deprecated - use --swig-opts=-c++z-c++z.cppz.cz.i⁄_wraprQ   z-pythonzswigging %s to %sz-oÈˇˇˇˇ)rL   r
   rò   rM   ro   ru   ⁄splitextrt   rK   ⁄	find_swigrà   rÆ   Zspawn)rN   ré   ⁄	extensionZnew_sourcesrØ   Zswig_targetsZ
target_ext⁄source⁄baser°   rK   Zswig_cmd⁄o⁄targetr   r   r   rØ     s>    				
zbuild_ext.swig_sourcesc             C   sÄ   t  j d k r d St  j d k ri xW d D]5 } t  j j d | d É } t  j j | É r) | Sq) Wd Sn t d	 t  j É Ç d
 S)zõReturn the name of the SWIG executable.  On Unix, this is
        just "swig" -- it should be in the PATH.  Tries a bit harder on
        Windows.
        ⁄posixrK   r   ˙1.3˙1.2˙1.1z	c:\swig%szswig.exez>I don't know how to find (much less run) SWIG on platform '%s'N)rø   r¿   r¡   )ro   rw   ru   rv   ⁄isfileZDistutilsPlatformError)rN   Zvers⁄fnr   r   r   r∏   O  s    zbuild_ext.find_swigc             C   s…   |  j  | É } | j d É } |  j | d É } |  j ss t j j | d d Ö | g å  } t j j |  j | É Sd j | d d Ö É } |  j d É } t j j	 | j
 | É É } t j j | | É S)	z°Returns the path of the filename for a given extension.

        The file is located in `build_lib` or directly in the package
        (inplace option).
        r]   rQ   Nr   ⁄build_pyr∂   r∂   r∂   )⁄get_ext_fullnamern   ⁄get_ext_filenamer   ro   ru   rv   r?   rá   ⁄abspathZget_package_dir)rN   r¢   ⁄fullnameZmodpath⁄filenamerB   rƒ   Zpackage_dirr   r   r   r®   g  s    	#zbuild_ext.get_ext_fullpathc             C   s&   |  j  d k r | S|  j  d | Sd S)zSReturns the fullname of a given extension name.

        Adds the `package.` prefixNr]   )rB   )rN   r¢   r   r   r   r≈   Ç  s    zbuild_ext.get_ext_fullnamec             C   so   d d l  m } | j d É } | d É } t j d k r[ |  j r[ t j j | å  d | St j j | å  | S)z¶Convert the name of an extension (eg. "foo.bar") into the name
        of the file from which it will be loaded (eg. "foo/bar.so", or
        "foo\bar.pyd").
        r   )r   r]   Z
EXT_SUFFIXr   ⁄_d)⁄distutils.sysconfigr   rn   ro   rw   r-   ru   rv   )rN   r¢   r   r¥   Z
ext_suffixr   r   r   r∆   ã  s    zbuild_ext.get_ext_filenamec             C   sC   d | j  j d É d } | | j k r< | j j | É n  | j S)a  Return the list of symbols that a shared extension has to
        export.  This either uses 'ext.export_symbols' or, if it's not
        provided, "PyInit_" + module_name.  Only relevant on Windows, where
        the .pyd file (DLL) must export the module "PyInit_" function.
        ZPyInit_r]   rQ   r∂   )rw   rn   r≠   rt   )rN   r°   Zinitfunc_namer   r   r   r≥   ò  s    zbuild_ext.get_export_symbolsc             C   s6  t  j d k rá d d l m } t |  j | É s} d } |  j rM | d } n  | t  j d ?t  j d ?d @f } | j | g S| j Sn´t  j d	 d
 Ö d k r÷ d } | t  j d ?t  j d ?d @f } | j | g St  j d	 d
 Ö d k ròd d l	 m
 } d } | t  j d ?t  j d ?d @f } g  } xS | j d É j É  D]< } | j d É rr| j | d d	 Ö É qC| j | É qCW| j | d g | St  j d k rÆ| j St  j d	 d Ö d k rŒ| j Sd d l	 m
 } d r+| j d É r+d j t  j d ?t  j d ?d @t  j É } | j | g S| j Sd	 S)z”Return the list of libraries to link against when building a
        shared extension.  On most platforms, this is just 'ext.libraries';
        on Windows, we add the Python library (eg. python20.dll).
        rS   r   )⁄MSVCCompilerz
python%d%dr    È   È   Èˇ   NrX   rY   zpython%d.%drZ   )rP   ZSHLIBSz-lrç   ⁄m⁄darwinÈ   ZaixFr^   zpython{}.{}{})rq   r|   ⁄distutils.msvccompilerrÃ   rl   rJ   r-   ⁄
hexversionrF   rj   rP   r   rn   r~   rt   ⁄format⁄abiflags)rN   r°   rÃ   ⁄templateZ	pythonlibrP   Zextrar\   r   r   r   r≤   £  sJ    
	
zbuild_ext.get_libraries)r   r   r   )r   r   r   )r   r   r   )r    r!   r"   )r#   r$   r%   )r'   r(   r)   )r*   r+   r,   )zdebugr.   r/   )zforcer1   r2   )r3   r4   r5   )r6   Nr7   )r8   Nr9   )r:   Nr;   )zuserNr=   )⁄__name__⁄
__module__⁄__qualname__Zdescriptionro   rp   Zsep_byr	   Zuser_optionsZboolean_optionsr   Zhelp_optionsrO   rÇ   rå   r•   rß   r©   râ   r™   rØ   r∏   r®   r≈   r∆   r≥   r≤   r   r   r   r   r   "   st     

   
         	ï@N	R6	r   )⁄__doc__rq   ro   ⁄reZdistutils.corer   Zdistutils.errorsrÀ   r   r   r   Zdistutils.dep_utilr   Zdistutils.extensionr   Zdistutils.utilr	   rj   r
   Zsiter   rw   r”   r   ⁄intr{   r∞   rô   r   r   r   r   r   r   ⁄<module>   s    $
                                                                                                                                                                                                                                                                                          usr/lib/python3.4/distutils/command/__pycache__/build_py.cpython-34.pyc                             0100644 0000000 0000000 00000026375 13077704335 024525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T
C  „               @   s≠   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l Td d l	 m
 Z
 m Z d d l m Z Gd d	 Ñ  d	 e É Z Gd
 d Ñ  d e e É Z d S)zHdistutils.command.build_py

Implements the Distutils 'build_py' command.È    N)⁄glob)⁄Command)⁄*)⁄convert_path⁄	Mixin2to3)⁄logc               @   s+  e  Z d  Z d Z d8 d9 d: d; d< g Z d d g Z i d d 6Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d  Ñ  Z d! d" Ñ  Z d# d$ Ñ  Z d% d& Ñ  Z d' d( Ñ  Z d) d* Ñ  Z d+ d, Ñ  Z d- d. d/ Ñ Z d0 d1 Ñ  Z d2 d3 Ñ  Z d4 d5 Ñ  Z d6 d7 Ñ  Z d	 S)=⁄build_pyz5"build" pure Python modules (copy to build directory)˙
build-lib=⁄d˙directory to "build" (copy) to⁄compile⁄c˙compile .py to .pyc˙
no-compileN˙!don't compile .py files [default]˙	optimize=⁄O˙lalso compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]⁄force⁄f˙2forcibly build everything (ignore file timestamps)c             C   sL   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ d  |  _ d  S)Nr   )⁄	build_lib⁄
py_modules⁄package⁄package_data⁄package_dirr   ⁄optimizer   )⁄self© r   ˙0/usr/lib/python3.4/distutils/command/build_py.py⁄initialize_options    s    							zbuild_py.initialize_optionsc             C   s  |  j  d d d É |  j j |  _ |  j j |  _ |  j j |  _ i  |  _ |  j j ré x6 |  j j j É  D] \ } } t | É |  j | <qh Wn  |  j É  |  _	 t
 |  j t É sy; t |  j É |  _ d |  j k oﬁ d k n sÈ t Ç Wqt t f k
 rt d É Ç YqXn  d  S)	NZbuildr   r   r   È   zoptimize must be 0, 1, or 2)˙	build_libr"   )˙forcer#   )Zset_undefined_options⁄distribution⁄packagesr   r   r   ⁄itemsr   ⁄get_data_files⁄
data_files⁄
isinstancer   ⁄int⁄AssertionError⁄
ValueErrorZDistutilsOptionError)r   ⁄name⁄pathr   r   r   ⁄finalize_options*   s"    		)zbuild_py.finalize_optionsc             C   sS   |  j  r |  j É  n  |  j r6 |  j É  |  j É  n  |  j |  j d d É É d  S)N⁄include_bytecoder   )r   ⁄build_modulesr%   ⁄build_packages⁄build_package_data⁄byte_compile⁄get_outputs)r   r   r   r   ⁄runC   s    		
zbuild_py.runc                sº   g  } |  j  s | Sx¢ |  j  D]ó } |  j | É } t j j |  j g | j d É å  } d â  | rv t | É d â  n  á  f d d Ü  |  j | | É DÉ } | j	 | | | | f É q W| S)z?Generate list of '(package,src_dir,build_dir,filenames)' tuples⁄.r   È   c                s    g  |  ] } | à  d  Ö ë q S)Nr   )⁄.0⁄file)⁄plenr   r   ˙
<listcomp>t   s   	 z+build_py.get_data_files.<locals>.<listcomp>)
r%   ⁄get_package_dir⁄osr.   ⁄joinr   ⁄split⁄len⁄find_data_files⁄append)r   ⁄datar   ⁄src_dir⁄	build_dir⁄	filenamesr   )r;   r   r'   a   s    	%%zbuild_py.get_data_filesc                sÑ   |  j  j d g  É |  j  j | g  É } g  â  xO | D]G } t t j j | t | É É É } à  j á  f d d Ü  | DÉ É q5 Wà  S)z6Return filenames for package's data files in 'src_dir'⁄ c                s4   g  |  ]* } | à  k r t  j j | É r | ë q Sr   )r>   r.   ⁄isfile)r9   ⁄fn)⁄filesr   r   r<   Ç   s   	 z,build_py.find_data_files.<locals>.<listcomp>)r   ⁄getr   r>   r.   r?   r   ⁄extend)r   r   rE   Zglobs⁄patternZfilelistr   )rK   r   rB   y   s    !$zbuild_py.find_data_filesc             C   sé   d } xÅ |  j  D]v \ } } } } xa | D]Y } t j j | | É } |  j t j j | É É |  j t j j | | É | d d Éq) Wq Wd S)z$Copy data files into build directoryN⁄preserve_modeF)r(   r>   r.   r?   ⁄mkpath⁄dirname⁄	copy_file)r   Zlastdirr   rE   rF   rG   ⁄filename⁄targetr   r   r   r3   Ü   s    zbuild_py.build_package_datac             C   s  | j  d É } |  j s5 | r. t j j | å  Sd Sn» g  } xø | r± y |  j d j | É } Wn- t k
 rç | j d | d É | d =Yq> X| j d | É t j j | å  Sq> W|  j j d É } | d k	 r„ | j d | É n  | r˘ t j j | å  Sd Sd S)zΩReturn the directory, relative to the top of the source
           distribution, where package 'package' should be found
           (at least according to the 'package_dir' option, if any).r7   rH   r   r8   NÈˇˇˇˇrU   )r@   r   r>   r.   r?   ⁄KeyError⁄insertrL   )r   r   r.   ⁄tailZpdirr   r   r   r=   ê   s(    			zbuild_py.get_package_dirc             C   s•   | d k rY t  j j | É s1 t d | É Ç n  t  j j | É sY t d | É Ç qY n  | r° t  j j | d É } t  j j | É rä | St j d d | É n  d  S)NrH   z%package directory '%s' does not existz>supposed package directory '%s' exists, but is not a directoryz__init__.pyz!package init file '%s' not found z(or not a regular file))	r>   r.   ⁄existsZDistutilsFileError⁄isdirr?   rI   r   ⁄warn)r   r   r   ⁄init_pyr   r   r   ⁄check_package∑   s    	zbuild_py.check_packagec             C   s1   t  j j | É s) t j d | | É d Sd Sd  S)Nz!file %s (for module %s) not foundFT)r>   r.   rI   r   r[   )r   ⁄module⁄module_filer   r   r   ⁄check_module“   s    zbuild_py.check_modulec       	      C   s»   |  j  | | É t t j j | d É É } g  } t j j |  j j É } xx | D]p } t j j | É } | | k rØ t j j t j j	 | É É d } | j
 | | | f É qP |  j d | É qP W| S)Nz*.pyr   zexcluding %s)r]   r   r>   r.   r?   ⁄abspathr$   Zscript_name⁄splitext⁄basenamerC   Zdebug_print)	r   r   r   Zmodule_files⁄modulesZsetup_scriptr   Zabs_fr^   r   r   r   ⁄find_package_modulesŸ   s    "zbuild_py.find_package_modulesc             C   s%  i  } g  } x|  j  D]} | j d É } d j | d d Ö É } | d } y | | \ } } Wn' t k
 rã |  j | É } d } Yn X| s÷ |  j | | É }	 | d f | | <|	 r÷ | j | d |	 f É q÷ n  t j j | | d É }
 |  j	 | |
 É sq n  | j | | |
 f É q W| S)a»  Finds individually-specified Python modules, ie. those listed by
        module name in 'self.py_modules'.  Returns a list of tuples (package,
        module_base, filename): 'package' is a tuple of the path through
        package-space to the module; 'module_base' is the bare (no
        packages, no dots) module name, and 'filename' is the path to the
        ".py" file (relative to the distribution root) that implements the
        module.
        r7   r   r8   ⁄__init__z.pyrU   rU   )
r   r@   r?   rV   r=   r]   rC   r>   r.   r`   )r   r%   rd   r^   r.   r   Zmodule_baser   Zcheckedr\   r_   r   r   r   ⁄find_modulesË   s*    
zbuild_py.find_modulesc             C   sw   g  } |  j  r% | j |  j É  É n  |  j rs xB |  j D]4 } |  j | É } |  j | | É } | j | É q8 Wn  | S)a4  Compute the list of all modules that will be built, whether
        they are specified one-module-at-a-time ('self.py_modules') or
        by whole packages ('self.packages').  Return a list of tuples
        (package, module, module_file), just like 'find_modules()' and
        'find_package_modules()' do.)r   rM   rg   r%   r=   re   )r   rd   r   r   ⁄mr   r   r   ⁄find_all_modules  s    		zbuild_py.find_all_modulesc             C   s   d d Ñ  |  j  É  DÉ S)Nc             S   s   g  |  ] } | d ë q S)r8   rU   r   )r9   r^   r   r   r   r<   -  s   	 z-build_py.get_source_files.<locals>.<listcomp>)ri   )r   r   r   r   ⁄get_source_files,  s    zbuild_py.get_source_filesc             C   s.   | g t  | É | d g } t j j | å  S)Nz.py)⁄listr>   r.   r?   )r   rF   r   r^   Zoutfile_pathr   r   r   ⁄get_module_outfile/  s    zbuild_py.get_module_outfiler8   c             C   s„   |  j  É  } g  } x∞ | D]® \ } } } | j d É } |  j |  j | | É } | j | É | r |  j rç | j t j j | d d ÉÉ n  |  j	 d k r¡ | j t j j | d d ÉÉ q¡ q q W| d d Ñ  |  j
 DÉ 7} | S)Nr7   ⁄debug_overrideTr   Fc             S   s>   g  |  ]4 \ } } } } | D] } t  j j | | É ë q q Sr   )r>   r.   r?   )r9   r   rE   rF   rG   rS   r   r   r   r<   C  s   	z(build_py.get_outputs.<locals>.<listcomp>)ri   r@   rl   r   rC   r   ⁄	importlib⁄util⁄cache_from_sourcer   r(   )r   r0   rd   Zoutputsr   r^   r_   rS   r   r   r   r5   3  s"    		zbuild_py.get_outputsc             C   sí   t  | t É r! | j d É } n$ t  | t t f É sE t d É Ç n  |  j |  j | | É } t j	 j
 | É } |  j | É |  j | | d d ÉS)Nr7   z:'package' must be a string (dot-separated), list, or tuplerO   r   )r)   ⁄strr@   rk   ⁄tuple⁄	TypeErrorrl   r   r>   r.   rQ   rP   rR   )r   r^   r_   r   Zoutfile⁄dirr   r   r   ⁄build_moduleJ  s    zbuild_py.build_modulec             C   s=   |  j  É  } x* | D]" \ } } } |  j | | | É q Wd  S)N)rg   ru   )r   rd   r   r^   r_   r   r   r   r1   Y  s    zbuild_py.build_modulesc             C   sx   xq |  j  D]f } |  j | É } |  j | | É } x< | D]4 \ } } } | | k sY t Ç |  j | | | É q8 Wq
 Wd  S)N)r%   r=   re   r+   ru   )r   r   r   rd   Zpackage_r^   r_   r   r   r   r2   b  s    
zbuild_py.build_packagesc          
   C   sÀ   t  j r |  j d É d  Sd d l m } |  j } | d	 t j k rV | t j } n  |  j rä | | d d d |  j	 d | d |  j
 Én  |  j d k r« | | d |  j d |  j	 d | d |  j
 Én  d  S)
Nz%byte-compiling is disabled, skipping.r   )r4   r8   r   r   ⁄prefix⁄dry_runrU   )⁄sys⁄dont_write_bytecoder[   ⁄distutils.utilr4   r   r>   ⁄sepr   r   rw   r   )r   rK   r4   rv   r   r   r   r4   v  s    			zbuild_py.byte_compile)r	   r
   r   )zcompiler   r   )r   Nr   )r   r   r   )zforcer   r   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsZnegative_optr    r/   r6   r'   rB   r3   r=   r]   r`   re   rg   ri   rj   rl   r5   ru   r1   r2   r4   r   r   r   r   r      s8    	

'4	r   c               @   s(   e  Z d  Z d d Ñ  Z d d Ñ  Z d S)⁄build_py_2to3c             C   sl   g  |  _  |  j r |  j É  n  |  j r? |  j É  |  j É  n  |  j |  j  É |  j |  j d d É É d  S)Nr0   r   )	⁄updated_filesr   r1   r%   r2   r3   Zrun_2to3r4   r5   )r   r   r   r   r6   ã  s    			
zbuild_py_2to3.runc             C   s=   t  j |  | | | É } | d r9 |  j j | d É n  | S)Nr8   r   )r   ru   rÄ   rC   )r   r^   r_   r   Zresr   r   r   ru   õ  s    
zbuild_py_2to3.build_moduleN)r|   r}   r~   r6   ru   r   r   r   r   r   ä  s   r   )⁄__doc__r>   ⁄importlib.utilrn   rx   r   Zdistutils.corer   Zdistutils.errorsrz   r   r   Z	distutilsr   r   r   r   r   r   r   ⁄<module>   s   
ˇ |                                                                                                                                                                                                                                                                   usr/lib/python3.4/distutils/command/__pycache__/build_scripts.cpython-34.pyc                        0100644 0000000 0000000 00000011165 13077704335 025553  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5TW  „               @   s“   d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z m Z d d l m Z d d l Z e j d	 É Z Gd
 d Ñ  d e É Z Gd d Ñ  d e e É Z d S)zRdistutils.command.build_scripts

Implements the Distutils 'build_scripts' command.È    N)⁄ST_MODE)⁄	sysconfig)⁄Command)⁄newer)⁄convert_path⁄	Mixin2to3)⁄logs   ^#!.*python[0-9.]*([ 	].*)?$c               @   sj   e  Z d  Z d Z d d d g Z d g Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d S)⁄build_scriptsz("build" scripts (copy and fixup #! line)˙
build-dir=⁄d˙directory to "build" (copy) to⁄force⁄f˙1forcibly build everything (ignore file timestamps˙executable=⁄e˙*specify final destination interpreter pathc             C   s1   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  S)N)⁄	build_dir⁄scriptsr   ⁄
executable⁄outfiles)⁄self© r   ˙5/usr/lib/python3.4/distutils/command/build_scripts.py⁄initialize_options   s
    				z build_scripts.initialize_optionsc             C   s)   |  j  d d d d É |  j j |  _ d  S)	NZbuildr	   r   r   r   )zbuild_scriptsz	build_dir)˙forcer   )˙
executabler   )Zset_undefined_optionsZdistributionr   )r   r   r   r   ⁄finalize_options%   s
    	zbuild_scripts.finalize_optionsc             C   s   |  j  S)N)r   )r   r   r   r   ⁄get_source_files,   s    zbuild_scripts.get_source_filesc             C   s   |  j  s d  S|  j É  d  S)N)r   ⁄copy_scripts)r   r   r   r   ⁄run/   s    	zbuild_scripts.runc          "   C   s†  |  j  |  j É g  } g  } xﬁ|  j D]”} d } t | É } t j j |  j t j j | É É } | j | É |  j	 rü t
 | | É rü t j d | É q& n  y t | d É } Wn' t k
 r€ |  j s— Ç  n  d } YnÇ Xt j | j É \ } } | j d É | j É  }	 |	 s*|  j d | É q& n  t j |	 É }
 |
 r]d } |
 j d É pWd	 } n  | r…t j d
 | |  j É | j | É |  j s≥t j s§|  j } n: t j j t j d É d t j d É t j d É f É } t j | É } d | | d } y | j d É Wn' t k
 r9t  d j! | É É Ç Yn Xy | j | É Wn* t k
 rwt  d j! | | É É Ç Yn Xt | d É è' } | j" | É | j# | j$ É  É Wd QXn  | r˘| j% É  q˘q& | r‹| j% É  n  | j | É |  j& | | É q& Wt j' d k rñxá | D]| } |  j r5t j d | É qt j( | É t) d @} | d Bd @} | | k rt j d | | | É t j* | | É qqWn  | | f S)a"  Copy each script listed in 'self.scripts'; if it's marked as a
        Python script in the Unix way (first line matches 'first_line_re',
        ie. starts with "\#!" and contains "python"), then adjust the first
        line to refer to the current Python interpreter as we copy.
        Fznot copying %s (up-to-date)⁄rbNr   z%s is an empty file (skipping)TÈ   Û    zcopying and adjusting %s -> %sZBINDIRz
python%s%sZVERSIONZEXEs   #!s   
zutf-8z.The shebang ({!r}) is not decodable from utf-8zAThe shebang ({!r}) is not decodable from the script encoding ({})⁄wb⁄posixzchanging mode of %siˇ  im  z!changing mode of %s from %o to %o)+Zmkpathr   r   r   ⁄os⁄path⁄join⁄basename⁄appendr   r   r   ⁄debug⁄open⁄OSError⁄dry_run⁄tokenize⁄detect_encoding⁄readline⁄seek⁄warn⁄first_line_re⁄match⁄group⁄infor   Zpython_buildr   Zget_config_var⁄fsencode⁄decode⁄UnicodeDecodeError⁄
ValueError⁄format⁄write⁄
writelines⁄	readlines⁄closeZ	copy_file⁄name⁄statr   ⁄chmod)r   r   ⁄updated_filesZscriptZadjustZoutfiler   ⁄encoding⁄linesZ
first_liner5   Zpost_interpr   ZshebangZoutf⁄fileZoldmodeZnewmoder   r   r   r   5   så    $	
					zbuild_scripts.copy_scriptsN)r
   r   r   )zforcer   r   )r   r   r   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsr   r   r   r    r   r   r   r   r   r	      s   		r	   c               @   s   e  Z d  Z d d Ñ  Z d S)⁄build_scripts_2to3c             C   s8   t  j |  É \ } } |  j s. |  j | É n  | | f S)N)r	   r   r.   Zrun_2to3)r   r   rD   r   r   r   r   ú   s    	zbuild_scripts_2to3.copy_scriptsN)rH   rI   rJ   r   r   r   r   r   rK   ö   s   rK   )⁄__doc__r&   ⁄rerB   r   Z	distutilsr   Zdistutils.corer   Zdistutils.dep_utilr   Zdistutils.utilr   r   r   r/   ⁄compiler4   r	   rK   r   r   r   r   ⁄<module>   s   â                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python3.4/distutils/command/__pycache__/check.cpython-34.pyc                                0100644 0000000 0000000 00000012121 13077704335 023753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tl  „               @   sÀ   d  Z  d d l m Z d d l m Z yp d d l m Z d d l m Z d d l	 m
 Z
 d d l	 m Z d d l m Z Gd	 d
 Ñ  d
 e É Z d Z Wn e k
 r∞ d Z Yn XGd d Ñ  d e É Z d S)zCdistutils.command.check

Implements the Distutils 'check' command.
È    )⁄Command)⁄DistutilsSetupError)⁄Reporter)⁄Parser)⁄frontend)⁄nodes)⁄StringIOc               @   s4   e  Z d  Z d d d d d d Ñ Z d d Ñ  Z d S)	⁄SilentReporterNr   ⁄ascii⁄replacec          	   C   s/   g  |  _  t j |  | | | | | | | É d  S)N)⁄messagesr   ⁄__init__)⁄self⁄source⁄report_level⁄
halt_level⁄stream⁄debug⁄encoding⁄error_handler© r   ˙-/usr/lib/python3.4/distutils/command/check.pyr      s    	zSilentReporter.__init__c             O   sB   |  j  j | | | | f É t j | d | d |  j | | | éS)N⁄level⁄type)r   ⁄appendr   ⁄system_messageZlevels)r   r   ⁄messageZchildren⁄kwargsr   r   r   r      s    
zSilentReporter.system_message)⁄__name__⁄
__module__⁄__qualname__r   r   r   r   r   r   r	      s   r	   TFc               @   sé   e  Z d  Z d Z d Z d d d g Z d d d	 g Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)⁄checkz6This command checks the meta-data of the package.
    z"perform some checks on the package⁄metadata⁄m˙Verify meta-data⁄restructuredtext⁄r˙EChecks if long string meta-data syntax are reStructuredText-compliant⁄strict⁄s˙(Will exit with an error if a check failsc             C   s(   d |  _  d |  _ d |  _ d |  _ d S)z Sets default values for options.r   È   N)r%   r"   r(   ⁄	_warnings)r   r   r   r   ⁄initialize_options1   s    			zcheck.initialize_optionsc             C   s   d  S)Nr   )r   r   r   r   ⁄finalize_options8   s    zcheck.finalize_optionsc             C   s   |  j  d 7_  t j |  | É S)z*Counts the number of warnings that occurs.r+   )r,   r   ⁄warn)r   ⁄msgr   r   r   r/   ;   s    z
check.warnc             C   sx   |  j  r |  j É  n  |  j rM t r2 |  j É  qM |  j rM t d É Ç qM n  |  j rt |  j d k rt t d É Ç n  d S)zRuns the command.zThe docutils package is needed.r   zPlease correct your package.N)r"   ⁄check_metadatar%   ⁄HAS_DOCUTILS⁄check_restructuredtextr(   r   r,   )r   r   r   r   ⁄run@   s    			z	check.runc             C   sﬂ   |  j  j } g  } x< d D]4 } t | | É o: t | | É s | j | É q q W| rt |  j d d j | É É n  | j rù | j s€ |  j d d É q€ n> | j	 r∆ | j
 s€ |  j d d	 É q€ n |  j d
 d d É d S)zœEnsures that all required elements of meta-data are supplied.

        name, version, URL, (author and author_email) or
        (maintainer and maintainer_email)).

        Warns if any are missing.
        ⁄name⁄version⁄urlzmissing required meta-data: %sz, z)missing meta-data: if 'author' supplied, z#'author_email' must be supplied tooz-missing meta-data: if 'maintainer' supplied, z''maintainer_email' must be supplied tooz4missing meta-data: either (author and author_email) z%or (maintainer and maintainer_email) zmust be suppliedN)znamezversionr7   )⁄distributionr"   ⁄hasattr⁄getattrr   r/   ⁄joinZauthorZauthor_emailZ
maintainerZmaintainer_email)r   r"   Zmissing⁄attrr   r   r   r1   P   s$    						zcheck.check_metadatac             C   sz   |  j  j É  } xd |  j | É D]S } | d j d É } | d k rQ | d } n d | d | f } |  j | É q Wd S)z4Checks if the long string fields are reST-compliant.r+   ⁄lineNz%s (line %s)Èˇˇˇˇ)r8   Zget_long_description⁄_check_rst_data⁄getr/   )r   ⁄dataZwarningr=   r   r   r   r3   n   s    zcheck.check_restructuredtextc             C   sÔ   t  É  } t É  } t j É  j É  } d | _ d | _ d | _ t | | j	 | j
 d | j d | j d | j d | j É} t j | | d | É} | j | d É y | j | | É Wn. t k
 rÁ | j j d d	 d
 i  f É Yn X| j S)z8Returns warnings when the provided data doesn't compile.È   Nr   r   r   r   r   r+   zCould not finish the parsing.⁄ r>   r>   )r   r   r   ZOptionParserZget_default_valuesZ	tab_widthZpep_referencesZrfc_referencesr	   r   r   Zwarning_streamr   Zerror_encodingZerror_encoding_error_handlerr   ⁄documentZnote_source⁄parse⁄AttributeErrorr   r   )r   rA   ⁄source_path⁄parserZsettingsZreporterrD   r   r   r   r?   y   s*    									zcheck._check_rst_dataN)zmetadatar#   r$   )zrestructuredtextr&   r'   )zstrictr)   r*   )r   r   r    ⁄__doc__ZdescriptionZuser_optionsZboolean_optionsr-   r.   r/   r4   r1   r3   r?   r   r   r   r   r!   $   s     	r!   N)rI   Zdistutils.corer   Zdistutils.errorsr   Zdocutils.utilsr   Zdocutils.parsers.rstr   Zdocutilsr   r   ⁄ior   r	   r2   ⁄	Exceptionr!   r   r   r   r   ⁄<module>   s   
                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python3.4/distutils/command/__pycache__/clean.cpython-34.pyc                                0100644 0000000 0000000 00000004466 13077704335 023775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tÿ
  „               @   s\   d  Z  d d l Z d d l m Z d d l m Z d d l m Z Gd d Ñ  d e É Z d S)zBdistutils.command.clean

Implements the Distutils 'clean' command.È    N)⁄Command)⁄remove_tree)⁄logc               @   s[   e  Z d  Z d Z d d d d d d g Z d g Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d S)⁄cleanz-clean up temporary files from 'build' command˙build-base=⁄b˙2base build directory (default: 'build.build-base')˙
build-lib=N˙<build directory for all modules (default: 'build.build-lib')˙build-temp=⁄t˙7temporary build directory (default: 'build.build-temp')˙build-scripts=˙<build directory for scripts (default: 'build.build-scripts')˙bdist-base=˙+temporary directory for built distributions⁄all⁄a˙7remove all build output, not just temporary by-productsc             C   s:   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S)N)⁄
build_base⁄	build_lib⁄
build_temp⁄build_scripts⁄
bdist_baser   )⁄self© r   ˙-/usr/lib/python3.4/distutils/command/clean.py⁄initialize_options    s    					zclean.initialize_optionsc             C   s-   |  j  d d d	 d
 d É |  j  d d É d  S)NZbuildr   r   r   r   Zbdistr   )˙
build_baser   )˙	build_libr   )˙build_scriptsr    )˙
build_tempr!   )˙
bdist_baser"   )Zset_undefined_options)r   r   r   r   ⁄finalize_options(   s    		zclean.finalize_optionsc             C   sÙ   t  j j |  j É r. t |  j d |  j Én t j d |  j É |  j r® x[ |  j	 |  j
 |  j f D]> } t  j j | É rë t | d |  j Éqc t j d | É qc Wn  |  j s y' t  j |  j É t j d |  j É Wq t k
 rÏ Yq Xn  d  S)N⁄dry_runz%'%s' does not exist -- can't clean itzremoving '%s')⁄os⁄path⁄existsr   r   r$   r   ⁄debugr   r   r   r   ⁄warn⁄rmdirr   ⁄info⁄OSError)r   Z	directoryr   r   r   ⁄run1   s$    	
				z	clean.run)r   r   r   )r	   Nr
   )r   r   r   )r   Nr   )r   Nr   )zallr   r   )	⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsr   r#   r-   r   r   r   r   r      s"         			r   )	⁄__doc__r%   Zdistutils.corer   Zdistutils.dir_utilr   Z	distutilsr   r   r   r   r   r   ⁄<module>   s
                                                                                                                                                                                                             usr/lib/python3.4/distutils/command/__pycache__/config.cpython-34.pyc                               0100644 0000000 0000000 00000025447 13077704335 024162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T$3  „               @   sß   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 d d l
 m Z i d d 6d	 d
 6Z Gd d Ñ  d e É Z d d d Ñ Z d S)aÍ  distutils.command.config

Implements the Distutils 'config' command, a (mostly) empty command class
that exists mainly to be sub-classed by specific module distributions and
applications.  The idea is that while every "config" command is different,
at least they're all named the same, and users always see "config" in the
list of standard commands.  Also, this is a good place to put common
configure-like tasks: "try to compile this C code", or "figure out where
this header file lives".
È    N)⁄Command)⁄DistutilsExecError)⁄customize_compiler)⁄logz.c⁄cz.cxxzc++c               @   si  e  Z d  Z d Z d> d? d@ dA dB dC dD dE dF g	 Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z	 d$ d% Ñ  Z
 d& d' Ñ  Z d( d) Ñ  Z d* d+ Ñ  Z d d d d, d- d. Ñ Z d d d d, d/ d0 Ñ Z d d d, d1 d2 Ñ Z d d d d d, d3 d4 Ñ Z d d d d d, d5 d6 Ñ Z d d d d d7 d7 d8 d9 Ñ Z d d d g  d: d; Ñ Z d d d, d< d= Ñ Z d S)G⁄configzprepare to build˙	compiler=N˙specify the compiler type˙cc=˙specify the compiler executable˙include-dirs=⁄I˙.list of directories to search for header files˙define=⁄D˙C preprocessor macros to define˙undef=⁄U˙!C preprocessor macros to undefine˙
libraries=⁄l˙!external C libraries to link with˙library-dirs=⁄L˙.directories to search for external C libraries⁄noisy˙1show every action (compile, link, run, ...) taken˙dump-source˙=dump generated source files before attempting to compile themc             C   sL   d  |  _  d  |  _ d  |  _ d  |  _ d  |  _ d |  _ d |  _ g  |  _ d  S)NÈ   )⁄compilerZcc⁄include_dirs⁄	libraries⁄library_dirsr   ⁄dump_source⁄
temp_files)⁄self© r'   ˙./usr/lib/python3.4/distutils/command/config.py⁄initialize_options3   s    							zconfig.initialize_optionsc             C   sﬂ   |  j  d  k r' |  j j  p g  |  _  n- t |  j  t É rT |  j  j t j É |  _  n  |  j d  k ro g  |  _ n$ t |  j t É rì |  j g |  _ n  |  j d  k rÆ g  |  _ n- t |  j t É r€ |  j j t j É |  _ n  d  S)N)	r!   Zdistribution⁄
isinstance⁄str⁄split⁄os⁄pathsepr"   r#   )r&   r'   r'   r(   ⁄finalize_optionsB   s    zconfig.finalize_optionsc             C   s   d  S)Nr'   )r&   r'   r'   r(   ⁄runR   s    z
config.runc             C   sΩ   d d l  m } m } t |  j | É sπ | d |  j d |  j d d É |  _ t |  j É |  j rx |  j j |  j É n  |  j	 ró |  j j
 |  j	 É n  |  j rπ |  j j |  j É qπ n  d S)z^Check that 'self.compiler' really is a CCompiler object;
        if not, make it one.
        r   )⁄	CCompiler⁄new_compilerr    ⁄dry_runZforcer   N)⁄distutils.ccompilerr1   r2   r*   r    r3   r   r!   Zset_include_dirsr"   Zset_librariesr#   Zset_library_dirs)r&   r1   r2   r'   r'   r(   ⁄_check_compilerY   s    			zconfig._check_compilerc             C   sê   d t  | } t | d É } | rU x | D] } | j d | É q* W| j d É n  | j | É | d d k rÇ | j d É n  | j É  | S)NZ_configtest⁄wz#include <%s>
⁄
r   Èˇˇˇˇ)⁄LANG_EXT⁄open⁄write⁄close)r&   ⁄body⁄headers⁄lang⁄filename⁄file⁄headerr'   r'   r(   ⁄_gen_temp_sourcefilek   s    
zconfig._gen_temp_sourcefilec             C   sT   |  j  | | | É } d } |  j j | | g É |  j j | | d | É| | f S)Nz_configtest.ir!   )rC   r%   ⁄extendr    Z
preprocess)r&   r=   r>   r!   r?   ⁄src⁄outr'   r'   r(   ⁄_preprocessx   s
    zconfig._preprocessc             C   sÉ   |  j  | | | É } |  j r2 t | d | É n  |  j j | g É \ } |  j j | | g É |  j j | g d | É| | f S)Nzcompiling '%s':r!   )rC   r$   ⁄	dump_filer    Zobject_filenamesr%   rD   ⁄compile)r&   r=   r>   r!   r?   rE   ⁄objr'   r'   r(   ⁄_compile   s    	zconfig._compilec       
   	   C   s™   |  j  | | | | É \ } } t j j t j j | É É d }	 |  j j | g |	 d | d | d | É|  j j d  k	 rç |	 |  j j }	 n  |  j j	 |	 É | | |	 f S)Nr   r"   r#   Ztarget_lang)
rK   r-   ⁄path⁄splitext⁄basenamer    Zlink_executableZexe_extensionr%   ⁄append)
r&   r=   r>   r!   r"   r#   r?   rE   rJ   ⁄progr'   r'   r(   ⁄_linkà   s    "zconfig._linkc             G   so   | s |  j  } g  |  _  n  t j d d j | É É x4 | D], } y t j | É Wq; t k
 rf Yq; Xq; Wd  S)Nzremoving: %s˙ )r%   r   ⁄info⁄joinr-   ⁄remove⁄OSError)r&   ⁄	filenamesr@   r'   r'   r(   ⁄_cleanó   s    	zconfig._cleanr   c             C   sc   d d l  m } |  j É  d } y |  j | | | | É Wn | k
 rT d } Yn X|  j É  | S)aQ  Construct a source file from 'body' (a string containing lines
        of C/C++ code) and 'headers' (a list of header files to include)
        and run it through the preprocessor.  Return true if the
        preprocessor succeeded, false if there were any errors.
        ('body' probably isn't of much use, but what the heck.)
        r   )⁄CompileErrorTF)r4   rY   r5   rG   rX   )r&   r=   r>   r!   r?   rY   ⁄okr'   r'   r(   ⁄try_cpp≠   s    

zconfig.try_cppc             C   sÆ   |  j  É  |  j | | | | É \ } } t | t É rI t j | É } n  t | É } d }	 x8 | j É  }
 |
 d k rz Pn  | j |
 É r^ d }	 Pq^ q^ | j	 É  |  j
 É  |	 S)a¥  Construct a source file (just like 'try_cpp()'), run it through
        the preprocessor, and return true if any line of the output matches
        'pattern'.  'pattern' should either be a compiled regex object or a
        string containing a regex.  If both 'body' and 'headers' are None,
        preprocesses an empty file -- which can be useful to determine the
        symbols the preprocessor and compiler set by default.
        F⁄ T)r5   rG   r*   r+   ⁄rerI   r:   ⁄readline⁄searchr<   rX   )r&   ⁄patternr=   r>   r!   r?   rE   rF   rA   ⁄match⁄liner'   r'   r(   ⁄
search_cppø   s     	


zconfig.search_cppc             C   s|   d d l  m } |  j É  y  |  j | | | | É d } Wn | k
 rT d } Yn Xt j | rg d pj d É |  j É  | S)zwTry to compile a source file built from 'body' and 'headers'.
        Return true on success, false otherwise.
        r   )rY   TFzsuccess!zfailure.)r4   rY   r5   rK   r   rS   rX   )r&   r=   r>   r!   r?   rY   rZ   r'   r'   r(   ⁄try_compile‹   s    


zconfig.try_compilec       
      C   sé   d d l  m } m } |  j É  y& |  j | | | | | | É d }	 Wn | | f k
 rf d }	 Yn Xt j |	 ry d p| d É |  j É  |	 S)zûTry to compile and link a source file, built from 'body' and
        'headers', to executable form.  Return true on success, false
        otherwise.
        r   )rY   ⁄	LinkErrorTFzsuccess!zfailure.)r4   rY   re   r5   rQ   r   rS   rX   )
r&   r=   r>   r!   r"   r#   r?   rY   re   rZ   r'   r'   r(   ⁄try_linkÏ   s    


zconfig.try_linkc             C   s¨   d d l  m } m } |  j É  yA |  j | | | | | | É \ }	 }
 } |  j | g É d } Wn! | | t f k
 rÑ d } Yn Xt j | ró d pö d É |  j	 É  | S)zúTry to compile, link to an executable, and run a program
        built from 'body' and 'headers'.  Return true on success, false
        otherwise.
        r   )rY   re   TFzsuccess!zfailure.)
r4   rY   re   r5   rQ   Zspawnr   r   rS   rX   )r&   r=   r>   r!   r"   r#   r?   rY   re   rE   rJ   ZexerZ   r'   r'   r(   ⁄try_runˇ   s    


zconfig.try_runr   c       	      C   sõ   |  j  É  g  } | r* | j d | É n  | j d É | rQ | j d | É n | j d | É | j d É d j | É d } |  j | | | | | É S)a€  Determine if function 'func' is available by constructing a
        source file that refers to 'func', and compiles and links it.
        If everything succeeds, returns true; otherwise returns false.

        The constructed source file starts out by including the header
        files listed in 'headers'.  If 'decl' is true, it then declares
        'func' (as "int func()"); you probably shouldn't supply 'headers'
        and set 'decl' true in the same call, or you might get errors about
        a conflicting declarations for 'func'.  Finally, the constructed
        'main()' function either references 'func' or (if 'call' is true)
        calls it.  'libraries' and 'library_dirs' are used when
        linking.
        z
int %s ();zint main () {z  %s();z  %s;˙}r7   )r5   rO   rT   rf   )	r&   ⁄funcr>   r!   r"   r#   Zdecl⁄callr=   r'   r'   r(   ⁄
check_func  s    
zconfig.check_funcc             C   s*   |  j  É  |  j d | | | g | | É S)a·  Determine if 'library' is available to be linked against,
        without actually checking that any particular symbols are provided
        by it.  'headers' will be used in constructing the source file to
        be compiled, but the only effect of this is to check if all the
        header files listed are available.  Any libraries listed in
        'other_libraries' will be included in the link, in case 'library'
        has symbols that depend on other libraries.
        zint main (void) { })r5   rf   )r&   Zlibraryr#   r>   r!   Zother_librariesr'   r'   r(   ⁄	check_lib6  s    

zconfig.check_libc             C   s   |  j  d d d | g d | É S)z§Determine if the system header file named by 'header_file'
        exists and can be found by the preprocessor; return true if so,
        false otherwise.
        r=   z/* No body */r>   r!   )r[   )r&   rB   r!   r#   r?   r'   r'   r(   ⁄check_headerD  s    zconfig.check_header)r   Nr	   )r
   Nr   )r   r   r   )r   r   r   )r   r   r   )r   r   r   )r   r   r   )znoisyNr   )r   Nr   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsr)   r/   r0   r5   rC   rG   rK   rQ   rX   r[   rc   rd   rf   rg   rk   rl   rm   r'   r'   r'   r(   r      sT            					r   c          
   C   sb   | d k r  t  j d |  É n t  j | É t |  É } z t  j | j É  É Wd | j É  Xd S)zjDumps a file content into log.info.

    If head is not None, will be dumped before the file content.
    Nz%s)r   rS   r:   ⁄readr<   )r@   ⁄headrA   r'   r'   r(   rH   N  s    rH   )⁄__doc__⁄sysr-   r]   Zdistutils.corer   Zdistutils.errorsr   Zdistutils.sysconfigr   Z	distutilsr   r9   r   rH   r'   r'   r'   r(   ⁄<module>
   s   $ˇ :                                                                                                                                                                                                                         usr/lib/python3.4/distutils/command/__pycache__/install.cpython-34.pyc                              0100644 0000000 0000000 00000037657 13077704335 024371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tlo  „               @   sA  d  Z  d d l Z d d l Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 d d l m Z d d l m Z d d	 l m Z m Z m Z d d
 l m Z d d l m Z d d l m Z d d l m Z d Z i d d 6d d 6d d 6d d 6d d 6Z i i d d 6d d 6d d 6d d 6d d 6d 6i d d 6d d 6d d 6d  d 6d! d 6d" 6i d# d 6d$ d 6d% d 6d d 6d d 6d& 6i d' d 6d' d 6d( d 6d d 6d d 6d) 6e d* 6Z e r!i d+ d 6d+ d 6d, d 6d- d 6d. d 6e d/ <i d+ d 6d+ d 6d0 d 6d1 d 6d. d 6e d2 <n  d5 Z Gd3 d4 Ñ  d4 e É Z d S)6zFdistutils.command.install

Implements the Distutils 'install' command.È    N)⁄log)⁄Command)⁄DEBUG)⁄get_config_vars)⁄DistutilsPlatformError)⁄
write_file)⁄convert_path⁄
subst_vars⁄change_root)⁄get_platform)⁄DistutilsOptionError)⁄	USER_BASE)⁄	USER_SITETz$base/Lib/site-packages⁄purelib⁄platlibz$base/Include/$dist_name⁄headersz$base/Scripts⁄scriptsz$base⁄dataz/$base/lib/python$py_version_short/site-packagesz3$platbase/lib/python$py_version_short/site-packagesz9$base/include/python$py_version_short$abiflags/$dist_namez	$base/bin⁄unix_prefixz5$base/local/lib/python$py_version_short/dist-packagesz9$platbase/local/lib/python$py_version_short/dist-packagesz6$base/local/include/python$py_version_short/$dist_namez$base/local/binz$base/local⁄
unix_localz$base/lib/python3/dist-packagesz#$platbase/lib/python3/dist-packagesz0$base/include/python$py_version_short/$dist_name⁄
deb_systemz$base/lib/pythonz$base/include/python/$dist_name⁄	unix_home⁄ntz	$usersitez4$userbase/Python$py_version_nodot/Include/$dist_namez$userbase/Scriptsz	$userbaseZnt_userz=$userbase/include/python$py_version_short$abiflags/$dist_namez$userbase/bin⁄	unix_userc               @   s  e  Z d  Z d Z da db dc dd d d d d f de df dg d d d d f dh di dj dk dl dm dn do dp dq g Z d d% d( g Z e r™ e j d. d d/ e f É e j d. É n  i d d  6Z	 d0 d1 Ñ  Z
 d2 d3 Ñ  Z d4 d5 Ñ  Z d6 d7 Ñ  Z d8 d9 Ñ  Z d: d; Ñ  Z d< d= Ñ  Z d> d? Ñ  Z d@ dA Ñ  Z dB dC Ñ  Z dD dE Ñ  Z dF dG Ñ  Z dH dI Ñ  Z dJ dK Ñ  Z dL dM Ñ  Z dN dO Ñ  Z dP dQ Ñ  Z dR dS Ñ  Z dT dU Ñ  Z dV dW Ñ  Z dX dY Ñ  Z dZ e f d[ e f d\ e f d] e f d^ d_ d` Ñ  f g Z d S)r⁄installz'install everything from build directory˙prefix=N˙installation prefix˙exec-prefix=˙.(Unix only) prefix for platform-specific files˙home=˙+(Unix only) home directory to install under˙install-base=˙;base installation directory (instead of --prefix or --home)zinstall-platbase=z8base installation directory for platform-specific files z$(instead of --exec-prefix or --home)˙root=˙<install everything relative to this alternate root directory˙install-purelib=˙;installation directory for pure Python module distributions˙install-platlib=˙8installation directory for non-pure module distributionszinstall-lib=z4installation directory for all module distributions z3(overrides --install-purelib and --install-platlib)˙install-headers=˙(installation directory for C/C++ headers˙install-scripts=˙)installation directory for Python scripts˙install-data=˙%installation directory for data files⁄compile⁄c˙compile .py to .pyc [default]˙
no-compile˙don't compile .py files˙	optimize=⁄O˙lalso compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]⁄force⁄f˙1force installation (overwrite any existing files)˙
skip-build˙2skip rebuilding everything (for testing/debugging)˙record=˙3filename in which to record list of installed files˙install-layout=˙7installation layout to choose (known values: deb, unix)⁄userz!install in user site-package '%s'c             C   s   d |  _  d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _	 d |  _
 d |  _ d |  _ d |  _ t |  _ t |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d S)zInitializes options.Nr   È   )⁄prefix⁄exec_prefix⁄homer@   ⁄prefix_option⁄install_base⁄install_platbase⁄root⁄install_purelib⁄install_platlib⁄install_headers⁄install_lib⁄install_scripts⁄install_datar   ⁄install_userbaser   ⁄install_usersite⁄install_layout⁄	multiarchr/   ⁄optimize⁄
extra_path⁄install_path_filer7   ⁄
skip_build⁄warn_dir⁄
build_base⁄	build_lib⁄record)⁄self© r\   ˙//usr/lib/python3.4/distutils/command/install.py⁄initialize_options£   s8    																				
							zinstall.initialize_optionsc             C   sõ  |  j  s |  j s |  j r@ |  j s- |  j r@ t d d É Ç n  |  j rj |  j  s[ |  j rj t d É Ç n  |  j rØ |  j  s† |  j s† |  j s† |  j s† |  j rØ t d É Ç n  t j d k r„ |  j r„ |  j	 d É d |  _ q„ n  |  j
 d É t j d k r|  j É  n
 |  j É  |  j
 d	 É t j j É  d
 } t d d É \ } } y t j } Wn t k
 rrd } Yn Xi |  j j É  d 6|  j j É  d 6|  j j É  d 6| d 6| d
 d Ö d 6| d
 | d d 6| d 6| d 6| d 6| d 6| d 6|  _ t r#|  j |  j d <|  j |  j d <n  |  j É  |  j
 d É |  j |  j d <|  j |  j d <t räd
 d l m } t d É | |  j É n  |  j É  |  j
 d  É |  j r∑|  j  É  n  |  j! d k r|  j j" r·|  j# |  _! q|  j$ |  _! n  |  j% d! d" d# d$ d% d& d d É |  j& É  |  j! |  _' t j( j) |  j! |  j* É |  _! |  j+ d k	 rw|  j, d' d! d" d# d$ d% d& É n  |  j
 d( É |  j- d) d, d- É d S).zFinalizes options.z.must supply either prefix/exec-prefix/home or z)install-base/install-platbase -- not bothz9must supply either home or prefix/exec-prefix -- not bothzGcan't combine user with prefix, exec_prefix/home, or install_(plat)base⁄posixz+exec-prefix option ignored on this platformNzpre-finalize_{unix,other}zpost-finalize_{unix,other}()r   rB   rC   ⁄ Z	dist_nameZdist_versionZdist_fullname⁄
py_versionÈ   Zpy_version_shortÈ   Zpy_version_nodotZ
sys_prefixZsys_exec_prefix⁄abiflagsZuserbaseZusersitezpost-expand_basedirs()⁄baseZplatbase)⁄pprintzconfig vars:zpost-expand_dirs()Zlibr   r   r   r   r   Zlibbasezafter prepending root⁄buildrX   rY   )˙
build_baserh   )˙	build_libri   ).rB   rC   rD   rF   rG   r   r@   ⁄os⁄name⁄warn⁄	dump_dirs⁄finalize_unix⁄finalize_other⁄sys⁄version⁄splitr   rd   ⁄AttributeError⁄distributionZget_nameZget_versionZget_fullname⁄config_vars⁄HAS_USER_SITErO   rP   ⁄expand_basedirsr   rf   ⁄print⁄expand_dirs⁄create_home_pathrL   Zext_modulesrJ   rI   ⁄convert_paths⁄handle_extra_path⁄install_libbase⁄path⁄join⁄
extra_dirsrH   ⁄change_rootsZset_undefined_options)r[   ra   rB   rC   rd   rf   r\   r\   r]   ⁄finalize_optionsı   sä    $	




		

	zinstall.finalize_optionsc             C   s„   t  s
 d Sd d l m } t j | d É x± |  j D]¶ } | d } | d d k rh | d d	 Ö } n  | |  j k r¶ |  j | } | j | É } t |  | É } n | j | É } t |  | É } t j d | | f É q5 Wd S)
zDumps the list of user options.Nr   )⁄longopt_xlate˙:rA   ˙=z  %s: %sÈˇˇˇˇrÜ   )	r   Zdistutils.fancy_getoptrÉ   r   ⁄debug⁄user_options⁄negative_opt⁄	translate⁄getattr)r[   ⁄msgrÉ   ZoptZopt_name⁄valr\   r\   r]   rm   â  s    
zinstall.dump_dirsc             C   sÎ  |  j  d k	 s |  j d k	 rã |  j d k rK |  j d k rK |  j d k sx |  j d k sx |  j d k sx |  j d k rá t d É Ç n  d S|  j	 r’ |  j
 d k r≤ t d É Ç n  |  j
 |  _  |  _ |  j d É n|  j d k	 r|  j |  _  |  _ |  j d É n‡|  j |  _ |  j d k rs|  j d k	 r@t d É Ç n  t j j t j É |  _ t j j t j É |  _ n |  j d k rë|  j |  _ n  |  j |  _  |  j |  _ |  j r)|  j j É  d k rıd d l } | j d	 É |  _ |  j d
 É qÁ|  j j É  d k r|  j d É qÁt d É Ç næ |  j rMt j j |  j É d k såt j t j k såd t j k såd t j k såd t j k rú|  j d É nK t j j |  j É d k r⁄d |  _ |  _ d |  _  |  _ n  |  j d É d S)z&Finalizes options for posix platforms.NzPinstall-base or install-platbase supplied, but installation scheme is incompletez$User base directory is not specifiedr   r   z*must not supply exec-prefix without prefix⁄debr   Z	MULTIARCHr   ⁄unixr   z"unknown value for --install-layoutz
/usr/localZPYTHONUSERBASEZVIRTUAL_ENVZreal_prefixz/usrr   )ré   )rè   )rF   rG   rL   rI   rJ   rK   rM   rN   r   r@   rO   r   ⁄select_schemerD   rB   rE   rC   rj   r~   ⁄normpathrp   rQ   ⁄lower⁄	sysconfigZget_config_varrR   ⁄base_prefix⁄environ⁄__dict__)r[   rì   r\   r\   r]   rn   ú  sd    			zinstall.finalize_unixc             C   s   |  j  rQ |  j d k r' t d É Ç n  |  j |  _ |  _ |  j t j d É n´ |  j d k	 rÉ |  j |  _ |  _ |  j d É ny |  j	 d k r≠ t j
 j t j	 É |  _	 n  |  j	 |  _ |  _ y |  j t j É Wn% t k
 r˚ t d t j É Ç Yn Xd S)z)Finalizes options for non-posix platformsNz$User base directory is not specifiedZ_userr   z)I don't know how to install stuff on '%s')r@   rO   r   rF   rG   rê   rj   rk   rD   rB   r~   rë   rp   ⁄KeyError)r[   r\   r\   r]   ro   ⁄  s"    	zinstall.finalize_otherc             C   sU   t  | } xD t D]< } d | } t |  | É d k r t |  | | | É q q Wd S)z=Sets the install directories by applying the install schemes.⁄install_N)⁄INSTALL_SCHEMES⁄SCHEME_KEYSrã   ⁄setattr)r[   rk   Zscheme⁄keyZattrnamer\   r\   r]   rê     s
    

zinstall.select_schemec             C   sà   xÅ | D]y } t  |  | É } | d  k	 r t j d k sF t j d k r[ t j j | É } n  t | |  j É } t |  | | É q q Wd  S)Nr_   r   )rã   rj   rk   r~   ⁄
expanduserr	   ru   rõ   )r[   Zattrs⁄attrrç   r\   r\   r]   ⁄_expand_attrs˘  s    zinstall._expand_attrsc             C   s   |  j  d d d g É d S)zNCalls `os.path.expanduser` on install_base, install_platbase and
        root.rF   rG   rH   N)rü   )r[   r\   r\   r]   rw     s    zinstall.expand_basedirsc             C   s#   |  j  d d d d d d g É d S)z+Calls `os.path.expanduser` on install dirs.rI   rJ   rL   rK   rM   rN   N)rü   )r[   r\   r\   r]   ry     s    zinstall.expand_dirsc             G   s>   x7 | D]/ } d | } t  |  | t t |  | É É É q Wd S)z!Call `convert_path` over `names`.rò   N)rõ   r   rã   )r[   ⁄namesrk   rû   r\   r\   r]   r{     s    
zinstall.convert_pathsc             C   sÁ   |  j  d k r! |  j j  |  _  n  |  j  d k	 r≈ t |  j  t É rZ |  j  j d É |  _  n  t |  j  É d k rÉ |  j  d } } n3 t |  j  É d k r™ |  j  \ } } n t d É Ç t | É } n d } d } | |  _ | |  _	 d S)z4Set `path_file` and `extra_dirs` using `extra_path`.N˙,rA   r   rc   zY'extra_path' option must be a list, tuple, or comma-separated string with 1 or 2 elementsr`   )
rT   rt   ⁄
isinstance⁄strrr   ⁄lenr   r   ⁄	path_filerÄ   )r[   r•   rÄ   r\   r\   r]   r|     s     		zinstall.handle_extra_pathc          	   G   sD   x= | D]5 } d | } t  |  | t |  j t |  | É É É q Wd S)z:Change the install directories pointed by name using root.rò   N)rõ   r
   rH   rã   )r[   r†   rk   rû   r\   r\   r]   rÅ   1  s    
zinstall.change_rootsc             C   sè   |  j  s d St t j j d É É } xc |  j j É  D]R \ } } | j | É r5 t j j | É r5 |  j	 d | É t j
 | d É q5 q5 Wd S)zCreate directories under ~.N˙~zos.makedirs('%s', 0o700)i¿  )r@   r   rj   r~   rù   ru   ⁄items⁄
startswith⁄isdirZdebug_print⁄makedirs)r[   rD   rk   r~   r\   r\   r]   rz   7  s    	"zinstall.create_home_pathc             C   s™  |  j  sU |  j d É |  j j d É j } |  j rU | t É  k rU t d É Ç qU n  x! |  j É  D] } |  j | É qb W|  j	 rè |  j
 É  n  |  j r|  j É  } |  j rÙ t |  j É } x5 t t | É É D] } | | | d Ö | | <qœ Wn  |  j t |  j | f d |  j É n  t t j j t j É } t t j j | É } t j j t j j |  j É É } |  j r¶|  j	 oÄ|  j r¶| | k r¶t j d |  j É n  d S)zRuns the command.rg   z"Can't install when cross-compilingNz'writing list of installed files to '%s'zÉmodules installed to '%s', which is not in Python's module search path (sys.path) -- you'll have to change the search path yourself)rV   Zrun_commandrt   Zget_command_objZ	plat_namerW   r   r   ⁄get_sub_commandsr•   ⁄create_path_filerZ   ⁄get_outputsrH   r§   ⁄range⁄executer   ⁄maprj   r~   rë   rp   ⁄normcaserL   rU   r   rá   )r[   Z
build_plat⁄cmd_name⁄outputsZroot_lenZcounterZsys_pathrL   r\   r\   r]   ⁄runC  s6    					!		zinstall.runc             C   sc   t  j j |  j |  j d É } |  j rN |  j t | |  j g f d | É n |  j	 d | É d S)zCreates the .pth filez.pthzcreating %szpath file '%s' not createdN)
rj   r~   r   r}   r•   rU   rØ   r   rÄ   rl   )r[   ⁄filenamer\   r\   r]   r¨   o  s    		zinstall.create_path_filec             C   sû   g  } xV |  j  É  D]H } |  j | É } x0 | j É  D]" } | | k r5 | j | É q5 q5 Wq W|  j rö |  j rö | j t j j |  j	 |  j d É É n  | S)z.Assembles the outputs of all the sub-commands.z.pth)
r´   ⁄get_finalized_commandr≠   ⁄appendr•   rU   rj   r~   r   r}   )r[   r≥   r≤   ⁄cmdrµ   r\   r\   r]   r≠   }  s    zinstall.get_outputsc             C   sC   g  } x6 |  j  É  D]( } |  j | É } | j | j É  É q W| S)z*Returns the inputs of all the sub-commands)r´   r∂   ⁄extend⁄
get_inputs)r[   Zinputsr≤   r∏   r\   r\   r]   r∫   é  s
    zinstall.get_inputsc             C   s   |  j  j É  p |  j  j É  S)zSReturns true if the current distribution has any Python
        modules to install.)rt   Zhas_pure_modulesZhas_ext_modules)r[   r\   r\   r]   ⁄has_libö  s    zinstall.has_libc             C   s   |  j  j É  S)zLReturns true if the current distribution has any headers to
        install.)rt   ⁄has_headers)r[   r\   r\   r]   rº   †  s    zinstall.has_headersc             C   s   |  j  j É  S)zMReturns true if the current distribution has any scripts to.
        install.)rt   ⁄has_scripts)r[   r\   r\   r]   rΩ   •  s    zinstall.has_scriptsc             C   s   |  j  j É  S)zJReturns true if the current distribution has any data to.
        install.)rt   Zhas_data_files)r[   r\   r\   r]   ⁄has_data™  s    zinstall.has_datarL   rK   rM   rN   Zinstall_egg_infoc             C   s   d S)NTr\   )r[   r\   r\   r]   ⁄<lambda>µ  s    zinstall.<lambda>)r   Nr   )r   Nr   )r   Nr    )r!   Nr"   )r#   Nr$   )r%   Nr&   )r'   Nr(   )r)   Nr*   )r+   Nr,   )r-   Nr.   )zcompiler0   r1   )r2   Nr3   )r4   r5   r6   )zforcer8   r9   )r:   Nr;   )r<   Nr=   )r>   Nr?   ) ⁄__name__⁄
__module__⁄__qualname__Zdescriptionrà   Zboolean_optionsrv   r∑   r   râ   r^   rÇ   rm   rn   ro   rê   rü   rw   ry   r{   r|   rÅ   rz   r¥   r¨   r≠   r∫   rª   rº   rΩ   ræ   Zsub_commandsr\   r\   r\   r]   r   W   sé                  	Rî>		,				r   )zpurelibzplatlibzheaderszscriptszdata)⁄__doc__rp   rj   Z	distutilsr   Zdistutils.corer   Zdistutils.debugr   Zdistutils.sysconfigr   Zdistutils.errorsr   Zdistutils.file_utilr   Zdistutils.utilr   r	   r
   r   r   Zsiter   r   rv   ZWINDOWS_SCHEMErô   rö   r   r\   r\   r\   r]   ⁄<module>   sz   

                                                                                 usr/lib/python3.4/distutils/command/__pycache__/install_data.cpython-34.pyc                         0100644 0000000 0000000 00000004747 13077704335 025354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T  „               @   sR   d  Z  d d l Z d d l m Z d d l m Z m Z Gd d Ñ  d e É Z d S)zÄdistutils.command.install_data

Implements the Distutils 'install_data' command, for installing
platform-independent data files.È    N)⁄Command)⁄change_root⁄convert_pathc               @   sj   e  Z d  Z d Z d d d g Z d g Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d S)⁄install_datazinstall data files˙install-dir=⁄d˙Ibase directory for installing data files (default: installation base dir)˙root=N˙<install everything relative to this alternate root directory⁄force⁄f˙-force installation (overwrite existing files)c             C   s@   d  |  _  g  |  _ d  |  _ d |  _ |  j j |  _ d |  _ d  S)Nr   È   )⁄install_dir⁄outfiles⁄rootr   Zdistribution⁄
data_files⁄warn_dir)⁄self© r   ˙4/usr/lib/python3.4/distutils/command/install_data.py⁄initialize_options   s    				zinstall_data.initialize_optionsc             C   s   |  j  d d d d É d  S)	NZinstallr   r   r   r   )zinstall_datazinstall_dir)˙rootr   )˙forcer   )Zset_undefined_options)r   r   r   r   ⁄finalize_options#   s    	zinstall_data.finalize_optionsc             C   sk  |  j  |  j É xT|  j D]I} t | t É rè t | É } |  j ra |  j d | |  j f É n  |  j | |  j É \ } } |  j	 j
 | É q t | d É } t j j | É sÃ t j j |  j | É } n |  j rÍ t |  j | É } n  |  j  | É | d g  k r|  j	 j
 | É q xF | d D]: } t | É } |  j | | É \ } } |  j	 j
 | É q%Wq Wd  S)NzMsetup script did not provide a directory for '%s' -- installing right in '%s'r   r   )Zmkpathr   r   ⁄
isinstance⁄strr   r   ⁄warnZ	copy_filer   ⁄append⁄os⁄path⁄isabs⁄joinr   r   )r   r   ⁄out⁄_⁄dir⁄datar   r   r   ⁄run*   s*    			zinstall_data.runc             C   s   |  j  p g  S)N)r   )r   r   r   r   ⁄
get_inputsK   s    zinstall_data.get_inputsc             C   s   |  j  S)N)r   )r   r   r   r   ⁄get_outputsN   s    zinstall_data.get_outputs)r   r   r   )r	   Nr
   )zforcer   r   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsr   r   r'   r(   r)   r   r   r   r   r      s     		!r   )⁄__doc__r   Zdistutils.corer   Zdistutils.utilr   r   r   r   r   r   r   ⁄<module>   s                            usr/lib/python3.4/distutils/command/__pycache__/install_egg_info.cpython-34.pyc                     0100644 0000000 0000000 00000007171 13077704335 026212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T¬  „               @   sé   d  Z  d d l m Z d d l m Z m Z d d l Z d d l Z d d l Z Gd d Ñ  d e É Z	 d d Ñ  Z
 d	 d
 Ñ  Z d d Ñ  Z d S)zÜdistutils.command.install_egg_info

Implements the Distutils 'install_egg_info' command, for installing
a package's PKG-INFO metadata.È    )⁄Command)⁄log⁄dir_utilNc               @   sX   e  Z d  Z d Z d Z d d g Z d	 d
 Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d S)⁄install_egg_infoz)Install an .egg-info file for the packagez8Install package's PKG-INFO metadata as an .egg-info file˙install-dir=⁄d˙directory to install to˙install-layoutN˙custom installation layoutc             C   s   d  |  _  d  |  _ d  |  _ d  S)N)⁄install_dir⁄install_layout⁄prefix_option)⁄self© r   ˙8/usr/lib/python3.4/distutils/command/install_egg_info.py⁄initialize_options   s    		z#install_egg_info.initialize_optionsc             C   sH  |  j  d d É |  j  d d É |  j  d d É |  j ru |  j j É  d k r] t d É Ç n  |  j j É  d k } n |  j rá d	 } n d
 } | r– d t t |  j j É  É É t t	 |  j j
 É  É É f } nJ d t t |  j j É  É É t t	 |  j j
 É  É É t j d  d Ö f } t j j |  j | É |  _ |  j g |  _ d  S)NZinstall_libr   Zinstallr   r   ⁄deb⁄unixz"unknown value for --install-layoutFTz%s-%s.egg-infoz%s-%s-py%s.egg-infoÈ   )˙install_dirr   )˙install_layoutr   )˙prefix_optionr   )r   r   )Zset_undefined_optionsr   ⁄lowerZDistutilsOptionErrorr   ⁄to_filename⁄	safe_name⁄distributionZget_name⁄safe_versionZget_version⁄sys⁄version⁄os⁄path⁄joinr   ⁄target⁄outputs)r   Zno_pyver⁄basenamer   r   r   ⁄finalize_options   s*    			"z!install_egg_info.finalize_optionsc          	   C   s  |  j  } t j j | É rG t j j | É rG t j | d |  j Énp t j j | É r| |  j	 t j
 |  j  f d | É n; t j j |  j É s∑ |  j	 t j |  j f d |  j É n  t j d | É |  j st | d d d Éè } |  j j j | É Wd  QXn  d  S)N⁄dry_runz	Removing z	Creating z
Writing %s⁄w⁄encodingzUTF-8)r"   r   r    ⁄isdir⁄islinkr   Zremove_treer&   ⁄existsZexecute⁄unlinkr   ⁄makedirsr   ⁄info⁄openr   ZmetadataZwrite_pkg_file)r   r"   ⁄fr   r   r   ⁄run4   s    	%#	zinstall_egg_info.runc             C   s   |  j  S)N)r#   )r   r   r   r   ⁄get_outputsB   s    zinstall_egg_info.get_outputs)r   r   r   )r	   Nr
   )
⁄__name__⁄
__module__⁄__qualname__⁄__doc__ZdescriptionZuser_optionsr   r%   r1   r2   r   r   r   r   r      s   	r   c             C   s   t  j d d |  É S)zèConvert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    z[^A-Za-z0-9.]+˙-)⁄re⁄sub)⁄namer   r   r   r   J   s    r   c             C   s%   |  j  d d É }  t j d d |  É S)zÃConvert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    ˙ ⁄.z[^A-Za-z0-9.]+r7   )⁄replacer8   r9   )r   r   r   r   r   R   s    r   c             C   s   |  j  d d É S)z|Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    r7   ⁄_)r=   )r:   r   r   r   r   \   s    r   )r6   Zdistutils.cmdr   Z	distutilsr   r   r   r   r8   r   r   r   r   r   r   r   r   ⁄<module>   s   $?
                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/distutils/command/__pycache__/install_headers.cpython-34.pyc                      0100644 0000000 0000000 00000003454 13077704335 026050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T  „               @   s0   d  Z  d d l m Z Gd d Ñ  d e É Z d S)zïdistutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory.È    )⁄Commandc               @   sg   e  Z d  Z d Z d d g Z d g Z d d	 Ñ  Z d
 d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d S)⁄install_headerszinstall C/C++ header files˙install-dir=⁄d˙$directory to install header files to⁄force⁄f˙-force installation (overwrite existing files)c             C   s   d  |  _  d |  _ g  |  _ d  S)Nr   )⁄install_dirr   ⁄outfiles)⁄self© r   ˙7/usr/lib/python3.4/distutils/command/install_headers.py⁄initialize_options   s    		z"install_headers.initialize_optionsc             C   s   |  j  d d d É d  S)NZinstallr   r
   r   )zinstall_headerszinstall_dir)˙forcer   )Zset_undefined_options)r   r   r   r   ⁄finalize_options   s    	z install_headers.finalize_optionsc             C   sf   |  j  j } | s d  S|  j |  j É x9 | D]1 } |  j | |  j É \ } } |  j j | É q- Wd  S)N)⁄distribution⁄headersZmkpathr
   Z	copy_filer   ⁄append)r   r   ⁄header⁄out⁄_r   r   r   ⁄run!   s    zinstall_headers.runc             C   s   |  j  j p g  S)N)r   r   )r   r   r   r   ⁄
get_inputs+   s    zinstall_headers.get_inputsc             C   s   |  j  S)N)r   )r   r   r   r   ⁄get_outputs.   s    zinstall_headers.get_outputsN)r   r   r   )zforcer   r	   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsr   r   r   r   r   r   r   r   r   r   
   s     		
r   N)⁄__doc__Zdistutils.corer   r   r   r   r   r   ⁄<module>   s                                                                                                                                                                                                                       usr/lib/python3.4/distutils/command/__pycache__/install_lib.cpython-34.pyc                          0100644 0000000 0000000 00000013273 13077704335 025203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tµ!  „               @   sj   d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d Z	 Gd d Ñ  d e É Z
 d S)zkdistutils.command.install_lib

Implements the Distutils 'install_lib' command
(install all Python modules).È    N)⁄Command)⁄DistutilsOptionErrorz.pyc            	   @   s≈   e  Z d  Z d Z d* d+ d, d- d. d/ d0 g Z d d d g Z i d d 6Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d  d! Ñ  Z d" d# Ñ  Z d$ d% Ñ  Z d& d' Ñ  Z d( d) Ñ  Z d S)1⁄install_libz7install all Python modules (extensions and pure Python)˙install-dir=⁄d˙directory to install to˙
build-dir=⁄b˙'build directory (where to install from)⁄force⁄f˙-force installation (overwrite existing files)⁄compile⁄c˙compile .py to .pyc [default]˙
no-compileN˙don't compile .py files˙	optimize=⁄O˙lalso compile with optimization: -O1 for "python -O", -O2 for "python -OO", and -O0 to disable [default: -O0]˙
skip-build˙skip the build stepsc             C   sC   d  |  _  d  |  _ d |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S)Nr   )⁄install_dir⁄	build_dirr   r   ⁄optimize⁄
skip_build⁄	multiarch)⁄self© r   ˙3/usr/lib/python3.4/distutils/command/install_lib.py⁄initialize_options3   s    						zinstall_lib.initialize_optionsc             C   s∆   |  j  d d d d d d d d É |  j d  k r= d |  _ n  |  j d  k rX d |  _ n  t |  j t É s¬ y. t |  j É |  _ |  j d k ró t Ç n  Wq¬ t t f k
 ræ t d É Ç Yq¬ Xn  d  S)N⁄install⁄	build_libr   r   r   r   r   r   r   r   TFr   È   È   zoptimize must be 0, 1, or 2)r"   z	build_dir)zinstall_libzinstall_dir)˙forcer%   )˙compiler&   )˙optimizer'   )˙
skip_buildr(   )˙	multiarchr)   )r   r#   r$   )Zset_undefined_optionsr   r   ⁄
isinstance⁄int⁄AssertionError⁄
ValueErrorr   )r   r   r   r   ⁄finalize_options=   s&    	zinstall_lib.finalize_optionsc             C   sE   |  j  É  |  j É  } | d  k	 rA |  j j É  rA |  j | É n  d  S)N)⁄buildr!   ⁄distribution⁄has_pure_modules⁄byte_compile)r   ⁄outfilesr   r   r   ⁄runX   s    
zinstall_lib.runc             C   sN   |  j  sJ |  j j É  r( |  j d É n  |  j j É  rJ |  j d É qJ n  d  S)N⁄build_py⁄	build_ext)r   r0   r1   Zrun_command⁄has_ext_modules)r   r   r   r   r/   h   s
    	zinstall_lib.buildc             C   sg   t  j j |  j É rK d d  l } |  j | j _ |  j |  j |  j	 É } n |  j
 d |  j É d  S| S)Nr   z3'%s' does not exist -- no Python modules to install)⁄os⁄path⁄isdirr   Zdistutils.dir_utilr   Zdir_util⁄
_multiarchZ	copy_treer   ⁄warn)r   Z	distutilsr3   r   r   r   r!   o   s    	zinstall_lib.installc             C   s∫   t  j r |  j d É d  Sd d l m } |  j d É j } |  j rp | | d d d |  j d | d |  j	 Én  |  j
 d k r∂ | | d |  j
 d |  j d | d	 |  j d |  j	 Én  d  S)
Nz%byte-compiling is disabled, skipping.r   )r2   r!   r   r   ⁄prefix⁄dry_run⁄verbose)⁄sys⁄dont_write_bytecoder<   Zdistutils.utilr2   ⁄get_finalized_command⁄rootr   r   r>   r   r?   )r   Zfilesr2   Zinstall_rootr   r   r   r2   z   s    		zinstall_lib.byte_compilec       
      C   sé   | s
 g  S|  j  | É } | j É  } t | | É } t | É t t j É } g  } x4 | D], }	 | j t j j | |	 | d  Ö É É qZ W| S)N)	rB   ⁄get_outputs⁄getattr⁄lenr8   ⁄sep⁄appendr9   ⁄join)
r   Zhas_anyZ	build_cmdZ
cmd_optionZ
output_dirZbuild_filesr   Z
prefix_lenZoutputs⁄filer   r   r   ⁄_mutate_outputsì   s    *zinstall_lib._mutate_outputsc             C   s´   g  } xû | D]ñ } t  j j t  j j | É É d } | t k rG q n  |  j rr | j t j j	 | d d ÉÉ n  |  j
 d k r | j t j j	 | d d ÉÉ q q W| S)Nr#   ⁄debug_overrideTr   F)r8   r9   ⁄splitext⁄normcase⁄PYTHON_SOURCE_EXTENSIONr   rH   ⁄	importlib⁄util⁄cache_from_sourcer   )r   Zpy_filenamesZbytecode_filesZpy_fileZextr   r   r   ⁄_bytecode_filenames¢   s    "	zinstall_lib._bytecode_filenamesc             C   su   |  j  |  j j É  d d |  j É } |  j r? |  j | É } n g  } |  j  |  j j É  d d |  j É } | | | S)z¡Return the list of files that would be installed if this command
        were actually run.  Not affected by the "dry-run" flag or whether
        modules have actually been built yet.
        r5   r"   r6   )rK   r0   r1   r   r   rS   r7   )r   Zpure_outputsZbytecode_outputsZext_outputsr   r   r   rD   ∏   s    	zinstall_lib.get_outputsc             C   sr   g  } |  j  j É  r: |  j d É } | j | j É  É n  |  j  j É  rn |  j d É } | j | j É  É n  | S)z˛Get the list of files that are input to this command, ie. the
        files that get installed as they are named in the build tree.
        The files in this list correspond one-to-one to the output
        filenames returned by 'get_outputs()'.
        r5   r6   )r0   r1   rB   ⁄extendrD   r7   )r   Zinputsr5   r6   r   r   r   ⁄
get_inputsÕ   s    zinstall_lib.get_inputs)r   r   r   )r   r	   r
   )zforcer   r   )zcompiler   r   )r   Nr   )r   r   r   )r   Nr   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsZnegative_optr    r.   r4   r/   r!   r2   rK   rS   rD   rU   r   r   r   r   r      s*    	
r   )⁄__doc__r8   ⁄importlib.utilrP   r@   Zdistutils.corer   Zdistutils.errorsr   rO   r   r   r   r   r   ⁄<module>   s                                                                                                                                                                                                                                                                                                                                        usr/lib/python3.4/distutils/command/__pycache__/install_scripts.cpython-34.pyc                      0100644 0000000 0000000 00000004477 13077704335 026132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T·  „               @   s\   d  Z  d d l Z d d l m Z d d l m Z d d l m Z Gd d Ñ  d e É Z d S)zudistutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts.È    N)⁄Command)⁄log)⁄ST_MODEc               @   sp   e  Z d  Z d Z d d d d g Z d d g Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d S)⁄install_scriptsz%install scripts (Python or otherwise)˙install-dir=⁄d˙directory to install scripts to˙
build-dir=⁄b˙'build directory (where to install from)⁄force⁄f˙-force installation (overwrite existing files)˙
skip-buildN˙skip the build stepsc             C   s(   d  |  _  d |  _ d  |  _ d  |  _ d  S)Nr   )⁄install_dirr   ⁄	build_dir⁄
skip_build)⁄self© r   ˙7/usr/lib/python3.4/distutils/command/install_scripts.py⁄initialize_options   s    			z"install_scripts.initialize_optionsc             C   s*   |  j  d d	 É |  j  d d
 d d É d  S)NZbuild⁄build_scriptsr   Zinstallr   r   r   r   )r   z	build_dir)zinstall_scriptszinstall_dir)˙forcer   )˙
skip_buildr   )Zset_undefined_options)r   r   r   r   ⁄finalize_options!   s
    	z install_scripts.finalize_optionsc             C   sª   |  j  s |  j d É n  |  j |  j |  j É |  _ t j d k r∑ xq |  j É  D]` } |  j	 rr t
 j d | É qP t j | É t d Bd @} t
 j d | | É t j | | É qP Wn  d  S)Nr   ⁄posixzchanging mode of %sim  iˇ  zchanging mode of %s to %o)r   Zrun_commandZ	copy_treer   r   ⁄outfiles⁄os⁄name⁄get_outputsZdry_runr   ⁄info⁄statr   ⁄chmod)r   ⁄file⁄moder   r   r   ⁄run)   s    		zinstall_scripts.runc             C   s   |  j  j p g  S)N)ZdistributionZscripts)r   r   r   r   ⁄
get_inputs8   s    zinstall_scripts.get_inputsc             C   s   |  j  p g  S)N)r   )r   r   r   r   r    ;   s    zinstall_scripts.get_outputs)r   r   r   )r	   r
   r   )zforcer   r   )r   Nr   )⁄__name__⁄
__module__⁄__qualname__ZdescriptionZuser_optionsZboolean_optionsr   r   r&   r'   r    r   r   r   r   r      s   	r   )	⁄__doc__r   Zdistutils.corer   Z	distutilsr   r"   r   r   r   r   r   r   ⁄<module>   s
                                                                                                                                                                                                    usr/lib/python3.4/distutils/command/__pycache__/register.cpython-34.pyc                             0100644 0000000 0000000 00000022030 13077704335 024522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5Tº-  „               @   s¢   d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m	 Z	 d d l
 m Z d d l Td d l m Z Gd d Ñ  d e É Z d S)	zhdistutils.command.register

Implements the Distutils 'register' command (register with the repository).
È    N)⁄warn)⁄PyPIRCCommand)⁄*)⁄logc               @   sœ   e  Z d  Z d Z e j d d  g Z e j d d d g Z d d	 d
 Ñ  f g Z d d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d Ñ  Z d d d Ñ Z d S)!⁄registerz7register the distribution with the Python package index˙list-classifiersN˙ list the valid Trove classifiers⁄strict˙BWill stop the registering if the meta-data are not fully compliant⁄verify⁄checkc             C   s   d S)NT© )⁄selfr   r   ˙0/usr/lib/python3.4/distutils/command/register.py⁄<lambda>   s    zregister.<lambda>c             C   s#   t  j |  É d |  _ d |  _ d  S)Nr   )r   ⁄initialize_options⁄list_classifiersr	   )r   r   r   r   r      s    	zregister.initialize_optionsc             C   s>   t  j |  É i d |  j f d 6d d 6} | |  j j d <d  S)Nr   r	   È   ⁄restructuredtextr   )zregisterr   )r   ⁄finalize_optionsr	   ⁄distributionZcommand_options)r   Zcheck_optionsr   r   r   r   $   s    
zregister.finalize_optionsc             C   sr   |  j  É  |  j É  x! |  j É  D] } |  j | É q! W|  j rN |  j É  n  |  j rd |  j É  n
 |  j É  d  S)N)	r   ⁄_set_configZget_sub_commandsZrun_commandZdry_run⁄verify_metadatar   ⁄classifiers⁄send_metadata)r   Zcmd_namer   r   r   ⁄run+   s    

		zregister.runc             C   sL   t  d t É |  j j d É } | j É  |  j | _ d | _ | j É  d S)zDeprecated API.zddistutils.command.register.check_metadata is deprecated,               use the check command insteadr   r   N)r   ⁄PendingDeprecationWarningr   Zget_command_objZensure_finalizedr	   r   r   )r   r   r   r   r   ⁄check_metadata:   s    

	zregister.check_metadatac             C   s±   |  j  É  } | i  k rX | d |  _ | d |  _ | d |  _ | d |  _ d |  _ nU |  j d |  j f k rÜ t d |  j É Ç n  |  j d k r§ |  j |  _ n  d |  _ d	 S)
z: Reads the configuration file and set attributes.
        ⁄username⁄password⁄
repository⁄realmTZpypiz%s not found in .pypircFN)Z_read_pypircr   r   r    r!   ⁄
has_configZDEFAULT_REPOSITORY⁄
ValueError)r   Zconfigr   r   r   r   D   s    zregister._set_configc             C   s9   |  j  d } t j j | É } t j |  j | É É d S)z8 Fetch the list of classifiers from the server.
        z?:action=list_classifiersN)r    ⁄urllib⁄requestZurlopenr   ⁄infoZ_read_pypi_response)r   ZurlZresponser   r   r   r   U   s    zregister.classifiersc             C   s9   |  j  |  j d É É \ } } t j d | | f É d S)zF Send the metadata to the package index server to be checked.
        r   zServer response (%s): %sN)⁄post_to_server⁄build_post_datar   r&   )r   ⁄code⁄resultr   r   r   r   \   s    zregister.verify_metadatac       
      C   sˆ  |  j  r$ d } |  j } |  j } n d } d } } d j É  } xT | | k rñ |  j d t j É t É  } | sz d } qC | | k rC t d É qC qC W| d k rx | sª t d É } q¶ Wx | s◊ t	 j	 d É } qø Wt
 j j É  } t
 j j |  j É d	 } | j |  j | | | É |  j |  j d
 É | É \ } } |  j d | | f t j É | d k rÚ|  j  r{| |  j _ q|  j d t j É |  j d |  j É  t j É d } x1 | j É  d k r‰t d É } | s¥d } q¥q¥W| j É  d k r|  j | | É qqÚn‚| d k ri d d 6}	 d |	 d <|	 d <|	 d <d |	 d <x |	 d smt d É |	 d <qPWxï |	 d |	 d k rx! |	 d s®t	 j	 d É |	 d <qàWx! |	 d sÃt	 j	 d É |	 d <q¨W|	 d |	 d k rqd |	 d <d |	 d <t d É qqqqWx |	 d s&t d É |	 d <q	W|  j |	 É \ } } | d k rbt j d | | f É qÚt j d É t j d  É ns | d! k rÚi d" d 6}	 d |	 d <x |	 d s¬t d# É |	 d <q•W|  j |	 É \ } } t j d | | f É n  d S)$a_   Send the metadata to the package index server.

            Well, do the following:
            1. figure who the user is, and then
            2. send the data as a Basic auth'ed POST.

            First we try to read the username/password from $HOME/.pypirc,
            which is a ConfigParser-formatted file with a section
            [distutils] containing username and password entries (both
            in clear text). Eg:

                [distutils]
                index-servers =
                    pypi

                [pypi]
                username: fred
                password: sekrit

            Otherwise, to figure who the user is, we offer the user three
            choices:

             1. use existing login,
             2. register as a new user, or
             3. set the password to a random string and email the user.

        ⁄1⁄x⁄ z1 2 3 4z‚We need to know who you are, so please choose either:
 1. use your existing login,
 2. register as a new user,
 3. have the server generate a new password for you (and email it to you), or
 4. quit
Your selection [default 1]: z&Please choose one of the four options!z
Username: z
Password: r   ZsubmitzServer response (%s): %sÈ»   zAI can store your PyPI login so future submissions will be faster.z (the login will be stored in %s)⁄XZynzSave your login (y/N)?⁄n⁄y⁄2⁄userz:action⁄namer   ZemailNZconfirmz
 Confirm: z!Password and confirm don't match!z
   EMail: z"You will receive an email shortly.z7Follow the instructions in it to complete registration.⁄3Zpassword_resetzYour email address: )r"   r   r   ⁄split⁄announcer   ⁄INFO⁄input⁄print⁄getpassr$   r%   ZHTTPPasswordMgr⁄parseZurlparser    Zadd_passwordr!   r'   r(   r   Z_get_rc_file⁄lowerZ_store_pypircr&   )
r   Zchoicer   r   ⁄choices⁄authZhostr)   r*   ⁄datar   r   r   r   c   så    		
				
		
	



zregister.send_metadatac             C   s  |  j  j } i | d 6d d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d	 6| j É  d
 6| j	 É  d 6| j
 É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6} | d s| d s| d rd | d <n  | S)Nz:actionz1.0Zmetadata_versionr4   ⁄versionZsummaryZ	home_pageZauthorZauthor_emailZlicense⁄description⁄keywords⁄platformr   Zdownload_urlZprovidesZrequiresZ	obsoletesz1.1)r   ZmetadataZget_nameZget_versionZget_descriptionZget_urlZget_contactZget_contact_emailZget_licenceZget_long_descriptionZget_keywordsZget_platformsZget_classifiersZget_download_urlZget_providesZget_requiresZget_obsoletes)r   ⁄action⁄metar@   r   r   r   r(   ›   s,    zregister.build_post_datac             C   s≤  d | k r3 |  j  d | d |  j f t j É n  d } d | } | d } t j É  } x≈ | j É  D]∑ \ } } t | É t g  É t f  É f k r¢ | g } n  xx | D]p } t | É } | j	 | É | j	 d | É | j	 d É | j	 | É | r© | d d	 k r© | j	 d
 É q© q© Wqf W| j	 | É | j	 d
 É | j
 É  j d É } i d | d 6t t | É É d 6}	 t j j |  j | |	 É }
 t j j t j j d | É É } d } y | j |
 É } Wnî t j j k
 r#} z2 |  j rˇ| j j É  } n  | j | j f } WYd d } ~ Xn[ t j j k
 r_} z d t | É f } WYd d } ~ Xn X|  j rx| j É  } n  d } |  j rÆd d } |  j  d | | | f É n  | S)zC Post a query to the server, and return a string response.
        r4   zRegistering %s to %sz3--------------GHSKFJDLGDS7543FJKLFHRE75642756743254z
--z--z*
Content-Disposition: form-data; name="%s"z

r   ˙⁄
zutf-8z/multipart/form-data; boundary=%s; charset=utf-8zContent-typezContent-lengthZpassword_mgrr-   NiÙ  r.   ⁄OK˙-ÈK   z%s%r%sÈˇˇˇˇ)r.   rI   )r7   r    r   r8   ⁄io⁄StringIO⁄items⁄type⁄str⁄write⁄getvalue⁄encode⁄lenr$   r%   ZRequestZbuild_openerZHTTPBasicAuthHandler⁄open⁄errorZ	HTTPErrorZshow_response⁄fp⁄readr)   ⁄msgZURLError)r   r@   r?   ⁄boundaryZsep_boundaryZend_boundaryZbody⁄key⁄valueZheadersZreqZopenerr*   ⁄eZdashesr   r   r   r'   ˘   sX    


$		$%		
zregister.post_to_server)r   Nr   )zstrictNr
   )⁄__name__⁄
__module__⁄__qualname__rB   r   Zuser_optionsZboolean_optionsZsub_commandsr   r   r   r   r   r   r   r   r(   r'   r   r   r   r   r      s&     

zr   )⁄__doc__⁄os⁄stringr;   rM   Zurllib.parser$   Zurllib.request⁄warningsr   Zdistutils.corer   Zdistutils.errorsZ	distutilsr   r   r   r   r   r   ⁄<module>   s   $
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python3.4/distutils/command/__pycache__/sdist.cpython-34.pyc                                0100644 0000000 0000000 00000033542 13077704335 024036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T-G  „               @   sˆ   d  Z  d d l Z d d l Z d d l Z d d l Td d l m Z d d l m Z d d l m	 Z	 d d l
 m Z m Z m Z m Z d d l m Z d d l Td d	 l m Z d d
 l
 m Z d d l m Z d d Ñ  Z Gd d Ñ  d e	 É Z d S)zadistutils.command.sdist

Implements the Distutils 'sdist' command (create a source distribution).È    N)⁄*)⁄glob)⁄warn)⁄Command)⁄dir_util⁄dep_util⁄	file_util⁄archive_util)⁄TextFile)⁄FileList)⁄log)⁄convert_pathc              C   sÄ   d d l  m }  d d l m } g  } x6 | j É  D]( } | j d | d | | d f É q3 W| j É  |  | É j d É d S)zoPrint all possible values for the 'formats' option (used by
    the "--help-formats" command-line option).
    r   )⁄FancyGetopt)⁄ARCHIVE_FORMATSzformats=NÈ   z.List of available source distribution formats:)Zdistutils.fancy_getoptr   Zdistutils.archive_utilr   ⁄keys⁄append⁄sortZ
print_help)r   r   ⁄formats⁄format© r   ˙-/usr/lib/python3.4/distutils/command/sdist.py⁄show_formats   s    
r   c               @   sk  e  Z d  Z d Z d d Ñ  Z dM dN dO dP dQ dR dS dT dU d d d d f dV dW dX dY g Z d
 d d d d d" g Z d* d d+ e f g Z i d
 d 6d d 6Z	 i d, d- 6d. d/ 6Z
 d0 e f g Z d1 d2 Ñ  Z d3 d4 Ñ  Z d5 d6 Ñ  Z d7 d8 Ñ  Z d9 d: Ñ  Z d; d< Ñ  Z d= d> Ñ  Z d? d@ Ñ  Z dA dB Ñ  Z dC dD Ñ  Z dE dF Ñ  Z dG dH Ñ  Z dI dJ Ñ  Z dK dL Ñ  Z d S)Z⁄sdistz6create a source distribution (tarball, zip file, etc.)c             C   s   |  j  S)zYCallable used for the check sub-command.

        Placed here so user_options can view it)⁄metadata_check)⁄selfr   r   r   ⁄checking_metadata&   s    zsdist.checking_metadata˙	template=⁄t˙5name of manifest template file [default: MANIFEST.in]˙	manifest=⁄m˙)name of manifest file [default: MANIFEST]˙use-defaultsN˙Rinclude the default file set in the manifest [default; disable with --no-defaults]˙no-defaults˙"don't include the default file set⁄prune˙âspecifically exclude files/directories that should not be distributed (build tree, RCS/CVS dirs, etc.) [default; disable with --no-prune]˙no-prune˙$don't automatically exclude anything˙manifest-only⁄o˙Ejust regenerate the manifest and then stop (implies --force-manifest)˙force-manifest⁄f˙kforcibly regenerate the manifest and carry on as usual. Deprecated: now the manifest is always regenerated.˙formats=˙6formats for source distribution (comma-separated list)z	keep-temp⁄kz1keep the distribution tree around after creating zarchive file(s)˙	dist-dir=⁄d˙Fdirectory to put the source distribution archive(s) in [default: dist]˙metadata-check˙[Ensure that all required elements of meta-data are supplied. Warn if any missing. [default]˙owner=⁄u˙@Owner name used when creating a tar file [default: current user]˙group=⁄g˙AGroup name used when creating a tar file [default: current group]zhelp-formatsz#list available distribution formatsZgztar⁄posix⁄zip⁄nt⁄checkc             C   sy   d  |  _  d  |  _ d |  _ d |  _ d |  _ d |  _ d  |  _ d |  _ d  |  _ d  |  _	 d |  _
 d  |  _ d  |  _ d  S)NÈ   r   )⁄template⁄manifest⁄use_defaultsr'   ⁄manifest_onlyZforce_manifestr   ⁄	keep_temp⁄dist_dir⁄archive_filesr   ⁄owner⁄group)r   r   r   r   ⁄initialize_optionsd   s    												zsdist.initialize_optionsc             C   s·   |  j  d  k r d |  _  n  |  j d  k r6 d |  _ n  |  j d É |  j d  k ró y |  j t j g |  _ Wqó t k
 rì t d t j É Ç Yqó Xn  t	 j
 |  j É } | r¬ t d | É Ç n  |  j d  k r› d |  _ n  d  S)NZMANIFESTzMANIFEST.inr   z<don't know how to create source distributions on platform %szunknown archive format '%s'Zdist)rE   rD   Zensure_string_listr   ⁄default_format⁄os⁄name⁄KeyErrorZDistutilsPlatformErrorr	   Zcheck_archive_formatsZDistutilsOptionErrorrI   )r   Z
bad_formatr   r   r   ⁄finalize_options{   s$    zsdist.finalize_optionsc             C   sU   t  É  |  _ x! |  j É  D] } |  j | É q W|  j É  |  j rG d  S|  j É  d  S)N)r   ⁄filelistZget_sub_commandsZrun_command⁄get_file_listrG   ⁄make_distribution)r   Zcmd_namer   r   r   ⁄runí   s    
	z	sdist.runc             C   s7   t  d t É |  j j d É } | j É  | j É  d S)zDeprecated API.zadistutils.command.sdist.check_metadata is deprecated,               use the check command insteadrB   N)r   ⁄PendingDeprecationWarning⁄distributionZget_command_objZensure_finalizedrV   )r   rB   r   r   r   ⁄check_metadata®   s
    

zsdist.check_metadatac             C   sÂ   t  j j |  j É } | rP |  j É  rP |  j É  |  j j É  |  j j É  d S| sq |  j	 d d |  j É n  |  j j
 É  |  j rî |  j É  n  | rß |  j É  n  |  j rΩ |  j É  n  |  j j É  |  j j É  |  j É  d S)aC  Figure out the list of files to include in the source
        distribution, and put it in 'self.filelist'.  This might involve
        reading the manifest template (and writing the manifest), or just
        reading the manifest, or just using the default file set -- it all
        depends on the user's options.
        Nz&manifest template '%s' does not exist z(using default file list))rO   ⁄path⁄isfilerD   ⁄_manifest_is_not_generated⁄read_manifestrS   r   Zremove_duplicatesr   ⁄findallrF   ⁄add_defaults⁄read_templater'   ⁄prune_file_list⁄write_manifest)r   Ztemplate_existsr   r   r   rT   ∞   s(    
			zsdist.get_file_listc             C   s	  d |  j  j g } x¬ | D]∫ } t | t É rù | } d } x: | D]2 } t j j | É rA d } |  j j | É PqA qA W| s” |  j	 d d j
 | É É q” q t j j | É r¬ |  j j | É q |  j	 d | É q Wd d	 g } x9 | D]1 } t t j j t | É É } |  j j | É qÍ W|  j d
 É } |  j  j É  rV|  j j | j É  É n  xM | j D]B \ }	 }
 } } x- | D]% } |  j j t j j
 |
 | É É qyWq`W|  j  j É  r`x® |  j  j D]ó } t | t É rt | É } t j j | É rY|  j j | É qYq¬| \ } } x? | D]7 } t | É } t j j | É r|  j j | É qqWq¬Wn  |  j  j É  ró|  j d É } |  j j | j É  É n  |  j  j É  rŒ|  j d É } |  j j | j É  É n  |  j  j É  r|  j d É } |  j j | j É  É n  d S)a9  Add all the default files to self.filelist:
          - README or README.txt
          - setup.py
          - test/test*.py
          - all pure Python modules mentioned in setup script
          - all files pointed by package_data (build_py)
          - all files defined in data_files.
          - all files defined as scripts.
          - all C sources listed as part of extensions or C libraries
            in the setup script (doesn't catch C headers!)
        Warns if (README or README.txt) or setup.py are missing; everything
        else is optional.
        ⁄README˙
README.txtFTz,standard file not found: should have one of z, zstandard file '%s' not foundztest/test*.pyz	setup.cfg⁄build_py⁄	build_ext⁄
build_clib⁄build_scriptsN)rc   rd   )rX   Zscript_name⁄
isinstance⁄tuplerO   rZ   ⁄existsrS   r   r   ⁄join⁄filterr[   r   ⁄extend⁄get_finalized_commandZhas_pure_modulesZget_source_filesZ
data_filesZhas_data_files⁄strr   Zhas_ext_modulesZhas_c_librariesZhas_scripts)r   Z	standards⁄fnZaltsZgot_itZoptional⁄pattern⁄filesre   ZpkgZsrc_dirZ	build_dir⁄	filenames⁄filename⁄item⁄dirnamer/   rf   rg   rh   r   r   r   r_   ÿ   s\    	'zsdist.add_defaultsc             C   s‡   t  j d |  j É t |  j d d d d d d d d d d d d É} zà xÅ | j É  } | d	 k rh Pn  y |  j j | É WqL t t f k
 r… } z% |  j	 d
 | j
 | j | f É WYd	 d	 } ~ XqL XqL Wd	 | j É  Xd	 S)z»Read and parse manifest template file named by self.template.

        (usually "MANIFEST.in") The parsing and processing is done by
        'self.filelist', which updates itself accordingly.
        zreading manifest template '%s'Zstrip_commentsrC   Zskip_blanksZ
join_linesZ	lstrip_wsZ	rstrip_wsZcollapse_joinNz%s, line %d: %s)r   ⁄inforD   r
   ⁄readlinerS   Zprocess_template_lineZDistutilsTemplateError⁄
ValueErrorr   ru   Zcurrent_line⁄close)r   rD   ⁄line⁄msgr   r   r   r`   (  s     	%zsdist.read_templatec             C   sº   |  j  d É } |  j j É  } |  j j d d | j É|  j j d d | Ét j d k re d } n d } d d d	 d
 d d d g } d | d j | É | f } |  j j | d d Éd S)av  Prune off branches that might slip into the file list as created
        by 'read_template()', but really don't belong there:
          * the build tree (typically "build")
          * the release tree itself (only an issue if we ran "sdist"
            previously with --keep-temp, or it aborted)
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories
        ⁄buildN⁄prefixZwin32z/|\\˙/ZRCSZCVSz\.svnz\.hgz\.gitz\.bzrZ_darcsz(^|%s)(%s)(%s).*˙|Zis_regexrC   )	ro   rX   ⁄get_fullnamerS   Zexclude_patternZ
build_base⁄sys⁄platformrl   )r   r~   ⁄base_dirZsepsZvcs_dirsZvcs_ptrnr   r   r   ra   E  s    		zsdist.prune_file_listc             C   st   |  j  É  r$ t j d |  j É d S|  j j d d Ö } | j d d É |  j t j	 |  j | f d |  j É d S)z≤Write the file list in 'self.filelist' (presumably as filled in
        by 'add_defaults()' and 'read_template()') to the manifest file
        named by 'self.manifest'.
        z5not writing to manually maintained manifest file '%s'Nr   z*# file GENERATED by distutils, do NOT editzwriting manifest file '%s')
r\   r   rx   rE   rS   rs   ⁄insertZexecuter   Z
write_file)r   Zcontentr   r   r   rb   ]  s    	zsdist.write_manifestc          
   C   sP   t  j j |  j É s d St |  j É } z | j É  } Wd  | j É  X| d k S)NFz+# file GENERATED by distutils, do NOT edit
)rO   rZ   r[   rE   ⁄openry   r{   )r   ⁄fpZ
first_liner   r   r   r\   l  s    z sdist._manifest_is_not_generatedc             C   sy   t  j d |  j É t |  j É } xF | D]> } | j É  } | j d É s) | rW q) n  |  j j | É q) W| j É  d S)z™Read the manifest file (named by 'self.manifest') and use it to
        fill in 'self.filelist', the list of files to include in the source
        distribution.
        zreading manifest file '%s'˙#N)	r   rx   rE   rá   ⁄strip⁄
startswithrS   r   r{   )r   rE   r|   r   r   r   r]   x  s    zsdist.read_manifestc             C   sÙ   |  j  | É t j | | d |  j Ét t d É rH d } d | } n d } d | } | sn t j d É n t j | É x_ | D]W } t j	 j
 | É sÆ t j d | É qÇ t j	 j | | É } |  j | | d | ÉqÇ W|  j j j | É d S)	a∆  Create the directory tree that will become the source
        distribution archive.  All directories implied by the filenames in
        'files' are created under 'base_dir', and then we hard link or copy
        (if hard linking is unavailable) those files into place.
        Essentially, this duplicates the developer's source tree, but in a
        directory named after the distribution, containing only the files
        to be distributed.
        ⁄dry_run⁄linkZhardzmaking hard links in %s...Nzcopying files to %s...z)no files to distribute -- empty manifest?z#'%s' not a regular file -- skipping)Zmkpathr   Zcreate_treerå   ⁄hasattrrO   r   r   rx   rZ   r[   rl   Z	copy_filerX   ZmetadataZwrite_pkg_info)r   rÖ   rs   rç   r}   ⁄file⁄destr   r   r   ⁄make_release_treeá  s     	
zsdist.make_release_treec          
   C   s  |  j  j É  } t j j |  j | É } |  j | |  j j É g  } d |  j	 k r} |  j	 j
 |  j	 j |  j	 j d É É É n  xd |  j	 D]Y } |  j | | d | d |  j d |  j É} | j
 | É |  j  j j
 d d | f É qá W| |  _ |  j st j | d |  j Én  d S)	aØ  Create the source distribution(s).  First, we create the release
        tree with 'make_release_tree()'; then, we create all required
        archive files (according to 'self.formats') from the release tree.
        Finally, we clean up by blowing away the release tree (unless
        'self.keep_temp' is true).  The list of archive files created is
        stored so it can be retrieved later by 'get_archive_files()'.
        ZtarrÖ   rK   rL   r   ⁄ rå   N)rX   rÇ   rO   rZ   rl   rI   rë   rS   rs   r   r   ⁄pop⁄indexZmake_archiverK   rL   Z
dist_filesrJ   rH   r   Zremove_treerå   )r   rÖ   Z	base_namerJ   Zfmtrè   r   r   r   rU   ±  s    
+ 		zsdist.make_distributionc             C   s   |  j  S)zzReturn the list of archive files created when the command
        was run, or None if the command hasn't run yet.
        )rJ   )r   r   r   r   ⁄get_archive_filesœ  s    zsdist.get_archive_files)r   r   r   )r    r!   r"   )r#   Nr$   )r%   Nr&   )zpruneNr(   )r)   Nr*   )r+   r,   r-   )r.   r/   r0   )r1   Nr2   )r4   r5   r6   )r7   Nr8   )r9   r:   r;   )r<   r=   r>   )⁄__name__⁄
__module__⁄__qualname__Zdescriptionr   Zuser_optionsZboolean_optionsr   Zhelp_optionsZnegative_optrN   Zsub_commandsrM   rR   rV   rY   rT   r_   r`   ra   rb   r\   r]   rë   rU   rï   r   r   r   r   r   "   sn                	



(P*r   )⁄__doc__rO   ⁄stringrÉ   ⁄typesr   ⁄warningsr   Zdistutils.corer   Z	distutilsr   r   r   r	   Zdistutils.text_filer
   Zdistutils.errorsZdistutils.filelistr   r   Zdistutils.utilr   r   r   r   r   r   r   ⁄<module>   s   
"
                                                                                                                                                              usr/lib/python3.4/distutils/command/__pycache__/upload.cpython-34.pyc                               0100644 0000000 0000000 00000013234 13077704335 024170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Ó
†#5T„  „               @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l m	 Z	 m
 Z
 m Z d d l m Z d d l m Z m Z d d l m Z d d l m Z d d	 l m Z e j d
 k  rÊ d d l m Z n d d l m Z Gd d Ñ  d e É Z d S)z`distutils.command.upload

Implements the Distutils 'upload' subcommand (upload package to PyPI).È    N)⁄standard_b64encode)⁄urlopen⁄Request⁄	HTTPError)⁄urlparse)⁄DistutilsError⁄DistutilsOptionError)⁄PyPIRCCommand)⁄spawn)⁄logz2.5)⁄md5c               @   si   e  Z d  Z d Z e j d d g Z e j d g Z d d	 Ñ  Z d
 d Ñ  Z d d Ñ  Z	 d d Ñ  Z
 d S)⁄uploadzupload binary package to PyPI⁄sign⁄s˙sign files to upload using gpg˙	identity=⁄i˙GPG identity used to sign filesc             C   s>   t  j |  É d |  _ d |  _ d |  _ d |  _ d  |  _ d  S)N⁄ r   F)r	   ⁄initialize_options⁄username⁄password⁄show_responser   ⁄identity)⁄self© r   ˙./usr/lib/python3.4/distutils/command/upload.pyr   #   s    				zupload.initialize_optionsc             C   s™   t  j |  É |  j r/ |  j r/ t d É Ç n  |  j É  } | i  k r~ | d |  _ | d |  _ | d |  _ | d |  _	 n  |  j r¶ |  j
 j r¶ |  j
 j |  _ n  d  S)Nz.Must use --sign for --identity to have meaningr   r   ⁄
repository⁄realm)r	   ⁄finalize_optionsr   r   r   Z_read_pypircr   r   r   r   ⁄distribution)r   Zconfigr   r   r   r   +   s    zupload.finalize_optionsc             C   sR   |  j  j s t d É Ç n  x0 |  j  j D]" \ } } } |  j | | | É q( Wd  S)Nz'No dist file created in earlier command)r    Z
dist_filesr   ⁄upload_file)r   ⁄command⁄	pyversion⁄filenamer   r   r   ⁄run=   s    z
upload.runc       $      C   s˚  t  |  j É \ } } } } } }	 | s3 | s3 |	 rI t d |  j É Ç n  | dI k rh t d | É Ç n  |  j ræ d d d | g }
 |  j r® d |  j g |
 d	 d	 Ö <n  t |
 d
 |  j Én  t | d É } z | j É  } Wd  | j	 É  X|  j
 j } i d d 6d d 6| j É  d 6| j É  d 6t j j | É | f d 6| d 6| d 6t | É j É  d 6d d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d 6| j É  d  6| j É  d! 6| j É  d" 6| j É  d# 6| j É  d$ 6} d% } | d& k rRt  j! É  \ } } } | rwd' | | f } qwn% | d( k rwd) t  j  d* d+ É } n  | | d, <|  j r¿t j j | É d- t | d- d É j É  f | d. <n  |  j" d/ |  j# j$ d0 É } d1 t% | É j& d0 É } d2 } d3 | j$ d0 É } | d4 } t' j( É  } x| j) É  D]˙ \ } } d5 | } t* | É t* g  É k rl| g } n  xΩ | D]µ } t* | É t+ k r™| d6 | d7 7} | d+ } n t, | É j$ d8 É } | j- | É | j- | j$ d8 É É | j- d9 É | j- | É | rs| dJ d  Ö d: k rs| j- d; É qsqsWq2W| j- | É | j. É  } |  j/ d< | |  j f t0 j1 É i d= | d> 6t, t2 | É É d? 6| d@ 6} t3 |  j dA | dB | É} y% t4 | É } | j5 É  } | j6 }  Wnw t7 k
 r}! z! |  j/ t, |! É t0 j8 É Ç  WYd  d  }! ~! Xn7 t9 k
 rM}! z |! j: } |! j6 }  WYd  d  }! ~! Xn X| dC k rz|  j/ dD | |  f t0 j1 É n/ dE | |  f }" |  j/ |" t0 j8 É t; |" É Ç |  j< r˜|  j= | É }# dF j> dG dH |# dG dH f É }" |  j/ |" t0 j1 É n  d  S)KNzIncompatible url %s⁄http⁄httpszunsupported schema Zgpgz--detach-signz-az--local-userÈ   ⁄dry_run⁄rbZfile_uploadz:action⁄1Zprotcol_version⁄name⁄version⁄contentZfiletyper#   Z
md5_digestz1.0Zmetadata_versionZsummaryZ	home_pageZauthorZauthor_emailZlicense⁄description⁄keywords⁄platformZclassifiersZdownload_urlZprovidesZrequiresZ	obsoletesr   Z	bdist_rpmzbuilt for %s %sZ
bdist_dumbzbuilt for %sZterseÈ   ⁄commentz.ascZgpg_signature˙:⁄asciizBasic z3--------------GHSKFJDLGDS7543FJKLFHRE75642756743254s   
--s   --
z+
Content-Disposition: form-data; name="%s"z; filename="%s"r   zutf-8s   

s   s   
zSubmitting %s to %sz multipart/form-data; boundary=%szContent-typezContent-lengthZAuthorization⁄data⁄headersÈ»   zServer response (%s): %szUpload failed (%s): %s⁄
˙-ÈK   )r&   r'   Èˇˇˇˇ)?r   r   ⁄AssertionErrorr   r   r
   r)   ⁄open⁄read⁄closer    ZmetadataZget_nameZget_version⁄os⁄path⁄basenamer   Z	hexdigestZget_descriptionZget_urlZget_contactZget_contact_emailZget_licenceZget_long_descriptionZget_keywordsZget_platformsZget_classifiersZget_download_urlZget_providesZget_requiresZget_obsoletesr1   ⁄distr   r   ⁄encoder   ⁄decode⁄io⁄BytesIO⁄items⁄type⁄tuple⁄str⁄write⁄getvalueZannouncer   ⁄INFO⁄lenr   r   Zgetcode⁄msg⁄OSErrorZERRORr   ⁄coder   r   Z_read_pypi_response⁄join)$r   r"   r#   r$   ZschemaZnetlocZurlZparamsZqueryZ	fragmentsZgpg_args⁄fr.   ⁄metar6   r3   rD   r-   ⁄idZ	user_passZauth⁄boundaryZsep_boundaryZend_boundaryZbody⁄key⁄value⁄titler7   Zrequest⁄resultZstatus⁄reason⁄erQ   ⁄textr   r   r   r!   C   s»    !			
	#

 
			 zupload.upload_fileN)zsignr   r   )r   r   r   )⁄__name__⁄
__module__⁄__qualname__r/   r	   Zuser_optionsZboolean_optionsr   r   r%   r!   r   r   r   r   r      s    
r   )⁄__doc__⁄sysrA   rG   Zsocketr1   ⁄base64r   Zurllib.requestr   r   r   Zurllib.parser   Zdistutils.errorsr   r   Zdistutils.corer	   Zdistutils.spawnr
   Z	distutilsr   r-   r   Zhashlibr   r   r   r   r   ⁄<module>   s                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/distutils/command/bdist.py                                                        0100644 0000000 0000000 00000012560 12415221640 017514  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist

Implements the Distutils 'bdist' command (create a built [binary]
distribution)."""

import os
from distutils.core import Command
from distutils.errors import *
from distutils.util import get_platform


def show_formats():
    """Print list of available formats (arguments to "--format" option).
    """
    from distutils.fancy_getopt import FancyGetopt
    formats = []
    for format in bdist.format_commands:
        formats.append(("formats=" + format, None,
                        bdist.format_command[format][1]))
    pretty_printer = FancyGetopt(formats)
    pretty_printer.print_help("List of available distribution formats:")


class bdist(Command):

    description = "create a built (binary) distribution"

    user_options = [('bdist-base=', 'b',
                     "temporary directory for creating built distributions"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('formats=', None,
                     "formats for distribution (comma-separated list)"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in "
                     "[default: dist]"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user]"),
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group]"),
                   ]

    boolean_options = ['skip-build']

    help_options = [
        ('help-formats', None,
         "lists available distribution formats", show_formats),
        ]

    # The following commands do not take a format option from bdist
    no_format_option = ('bdist_rpm',)

    # This won't do in reality: will need to distinguish RPM-ish Linux,
    # Debian-ish Linux, Solaris, FreeBSD, ..., Windows, Mac OS.
    default_format = {'posix': 'gztar',
                      'nt': 'zip'}

    # Establish the preferred order (for the --help-formats option).
    format_commands = ['rpm', 'gztar', 'bztar', 'ztar', 'tar',
                       'wininst', 'zip', 'msi']

    # And the real information.
    format_command = {'rpm':   ('bdist_rpm',  "RPM distribution"),
                      'gztar': ('bdist_dumb', "gzip'ed tar file"),
                      'bztar': ('bdist_dumb', "bzip2'ed tar file"),
                      'ztar':  ('bdist_dumb', "compressed tar file"),
                      'tar':   ('bdist_dumb', "tar file"),
                      'wininst': ('bdist_wininst',
                                  "Windows executable installer"),
                      'zip':   ('bdist_dumb', "ZIP file"),
                      'msi':   ('bdist_msi',  "Microsoft Installer")
                      }


    def initialize_options(self):
        self.bdist_base = None
        self.plat_name = None
        self.formats = None
        self.dist_dir = None
        self.skip_build = 0
        self.group = None
        self.owner = None

    def finalize_options(self):
        # have to finalize 'plat_name' before 'bdist_base'
        if self.plat_name is None:
            if self.skip_build:
                self.plat_name = get_platform()
            else:
                self.plat_name = self.get_finalized_command('build').plat_name

        # 'bdist_base' -- parent of per-built-distribution-format
        # temporary directories (eg. we'll probably have
        # "build/bdist.<plat>/dumb", "build/bdist.<plat>/rpm", etc.)
        if self.bdist_base is None:
            build_base = self.get_finalized_command('build').build_base
            self.bdist_base = os.path.join(build_base,
                                           'bdist.' + self.plat_name)

        self.ensure_string_list('formats')
        if self.formats is None:
            try:
                self.formats = [self.default_format[os.name]]
            except KeyError:
                raise DistutilsPlatformError(
                      "don't know how to create built distributions "
                      "on platform %s" % os.name)

        if self.dist_dir is None:
            self.dist_dir = "dist"

    def run(self):
        # Figure out which sub-commands we need to run.
        commands = []
        for format in self.formats:
            try:
                commands.append(self.format_command[format][0])
            except KeyError:
                raise DistutilsOptionError("invalid format '%s'" % format)

        # Reinitialize and run each command.
        for i in range(len(self.formats)):
            cmd_name = commands[i]
            sub_cmd = self.reinitialize_command(cmd_name)
            if cmd_name not in self.no_format_option:
                sub_cmd.format = self.formats[i]

            # passing the owner and group names for tar archiving
            if cmd_name == 'bdist_dumb':
                sub_cmd.owner = self.owner
                sub_cmd.group = self.group

            # If we're going to need to run this command again, tell it to
            # keep its temporary files around so subsequent runs go faster.
            if cmd_name in commands[i+1:]:
                sub_cmd.keep_temp = 1
            self.run_command(cmd_name)
                                                                                                                                                usr/lib/python3.4/distutils/command/bdist_dumb.py                                                   0100644 0000000 0000000 00000011413 12415221640 020517  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist_dumb

Implements the Distutils 'bdist_dumb' command (create a "dumb" built
distribution -- i.e., just an archive to be unpacked under $prefix or
$exec_prefix)."""

import os
from distutils.core import Command
from distutils.util import get_platform
from distutils.dir_util import remove_tree, ensure_relative
from distutils.errors import *
from distutils.sysconfig import get_python_version
from distutils import log

class bdist_dumb(Command):

    description = "create a \"dumb\" built distribution"

    user_options = [('bdist-dir=', 'd',
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('format=', 'f',
                     "archive format to create (tar, ztar, gztar, zip)"),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('relative', None,
                     "build the archive using relative paths"
                     "(default: false)"),
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user]"),
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group]"),
                   ]

    boolean_options = ['keep-temp', 'skip-build', 'relative']

    default_format = { 'posix': 'gztar',
                       'nt': 'zip' }

    def initialize_options(self):
        self.bdist_dir = None
        self.plat_name = None
        self.format = None
        self.keep_temp = 0
        self.dist_dir = None
        self.skip_build = None
        self.relative = 0
        self.owner = None
        self.group = None

    def finalize_options(self):
        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'dumb')

        if self.format is None:
            try:
                self.format = self.default_format[os.name]
            except KeyError:
                raise DistutilsPlatformError(
                       "don't know how to create dumb built distributions "
                       "on platform %s" % os.name)

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                   ('skip_build', 'skip_build'))

    def run(self):
        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.root = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0

        log.info("installing to %s" % self.bdist_dir)
        self.run_command('install')

        # And make an archive relative to the root of the
        # pseudo-installation tree.
        archive_basename = "%s.%s" % (self.distribution.get_fullname(),
                                      self.plat_name)

        pseudoinstall_root = os.path.join(self.dist_dir, archive_basename)
        if not self.relative:
            archive_root = self.bdist_dir
        else:
            if (self.distribution.has_ext_modules() and
                (install.install_base != install.install_platbase)):
                raise DistutilsPlatformError(
                       "can't make a dumb built distribution where "
                       "base and platbase are different (%s, %s)"
                       % (repr(install.install_base),
                          repr(install.install_platbase)))
            else:
                archive_root = os.path.join(self.bdist_dir,
                                   ensure_relative(install.install_base))

        # Make the archive
        filename = self.make_archive(pseudoinstall_root,
                                     self.format, root_dir=archive_root,
                                     owner=self.owner, group=self.group)
        if self.distribution.has_ext_modules():
            pyversion = get_python_version()
        else:
            pyversion = 'any'
        self.distribution.dist_files.append(('bdist_dumb', pyversion,
                                             filename))

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)
                                                                                                                                                                                                                                                     usr/lib/python3.4/distutils/command/bdist_msi.py                                                    0100644 0000000 0000000 00000104621 12415221640 020364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright (C) 2005, 2006 Martin von L√∂wis
# Licensed to PSF under a Contributor Agreement.
# The bdist_wininst command proper
# based on bdist_wininst
"""
Implements the bdist_msi command.
"""

import sys, os
from distutils.core import Command
from distutils.dir_util import remove_tree
from distutils.sysconfig import get_python_version
from distutils.version import StrictVersion
from distutils.errors import DistutilsOptionError
from distutils.util import get_platform
from distutils import log
import msilib
from msilib import schema, sequence, text
from msilib import Directory, Feature, Dialog, add_data

class PyDialog(Dialog):
    """Dialog class with a fixed layout: controls at the top, then a ruler,
    then a list of buttons: back, next, cancel. Optionally a bitmap at the
    left."""
    def __init__(self, *args, **kw):
        """Dialog(database, name, x, y, w, h, attributes, title, first,
        default, cancel, bitmap=true)"""
        Dialog.__init__(self, *args)
        ruler = self.h - 36
        bmwidth = 152*ruler/328
        #if kw.get("bitmap", True):
        #    self.bitmap("Bitmap", 0, 0, bmwidth, ruler, "PythonWin")
        self.line("BottomLine", 0, ruler, self.w, 0)

    def title(self, title):
        "Set the title text of the dialog at the top."
        # name, x, y, w, h, flags=Visible|Enabled|Transparent|NoPrefix,
        # text, in VerdanaBold10
        self.text("Title", 15, 10, 320, 60, 0x30003,
                  r"{\VerdanaBold10}%s" % title)

    def back(self, title, next, name = "Back", active = 1):
        """Add a back button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 180, self.h-27 , 56, 17, flags, title, next)

    def cancel(self, title, next, name = "Cancel", active = 1):
        """Add a cancel button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 304, self.h-27, 56, 17, flags, title, next)

    def next(self, title, next, name = "Next", active = 1):
        """Add a Next button with a given title, the tab-next button,
        its name in the Control table, possibly initially disabled.

        Return the button, so that events can be associated"""
        if active:
            flags = 3 # Visible|Enabled
        else:
            flags = 1 # Visible
        return self.pushbutton(name, 236, self.h-27, 56, 17, flags, title, next)

    def xbutton(self, name, title, next, xpos):
        """Add a button with a given title, the tab-next button,
        its name in the Control table, giving its x position; the
        y-position is aligned with the other buttons.

        Return the button, so that events can be associated"""
        return self.pushbutton(name, int(self.w*xpos - 28), self.h-27, 56, 17, 3, title, next)

class bdist_msi(Command):

    description = "create a Microsoft Installer (.msi) binary distribution"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    all_versions = ['2.0', '2.1', '2.2', '2.3', '2.4',
                    '2.5', '2.6', '2.7', '2.8', '2.9',
                    '3.0', '3.1', '3.2', '3.3', '3.4',
                    '3.5', '3.6', '3.7', '3.8', '3.9']
    other_version = 'X'

    def initialize_options(self):
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.no_target_compile = 0
        self.no_target_optimize = 0
        self.target_version = None
        self.dist_dir = None
        self.skip_build = None
        self.install_script = None
        self.pre_install_script = None
        self.versions = None

    def finalize_options(self):
        self.set_undefined_options('bdist', ('skip_build', 'skip_build'))

        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'msi')

        short_version = get_python_version()
        if (not self.target_version) and self.distribution.has_ext_modules():
            self.target_version = short_version

        if self.target_version:
            self.versions = [self.target_version]
            if not self.skip_build and self.distribution.has_ext_modules()\
               and self.target_version != short_version:
                raise DistutilsOptionError(
                      "target version can only be %s, or the '--skip-build'"
                      " option must be specified" % (short_version,))
        else:
            self.versions = list(self.all_versions)

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                   )

        if self.pre_install_script:
            raise DistutilsOptionError(
                  "the pre-install-script feature is not yet implemented")

        if self.install_script:
            for script in self.distribution.scripts:
                if self.install_script == os.path.basename(script):
                    break
            else:
                raise DistutilsOptionError(
                      "install_script '%s' not found in scripts"
                      % self.install_script)
        self.install_script_key = None

    def run(self):
        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.prefix = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0

        install_lib = self.reinitialize_command('install_lib')
        # we do not want to include pyc or pyo files
        install_lib.compile = 0
        install_lib.optimize = 0

        if self.distribution.has_ext_modules():
            # If we are building an installer for a Python version other
            # than the one we are currently running, then we need to ensure
            # our build_lib reflects the other Python version rather than ours.
            # Note that for target_version!=sys.version, we must have skipped the
            # build step, so there is no issue with enforcing the build of this
            # version.
            target_version = self.target_version
            if not target_version:
                assert self.skip_build, "Should have already checked this"
                target_version = sys.version[0:3]
            plat_specifier = ".%s-%s" % (self.plat_name, target_version)
            build = self.get_finalized_command('build')
            build.build_lib = os.path.join(build.build_base,
                                           'lib' + plat_specifier)

        log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()

        # avoid warning of 'install_lib' about installing
        # into a directory not in sys.path
        sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

        install.run()

        del sys.path[0]

        self.mkpath(self.dist_dir)
        fullname = self.distribution.get_fullname()
        installer_name = self.get_installer_filename(fullname)
        installer_name = os.path.abspath(installer_name)
        if os.path.exists(installer_name): os.unlink(installer_name)

        metadata = self.distribution.metadata
        author = metadata.author
        if not author:
            author = metadata.maintainer
        if not author:
            author = "UNKNOWN"
        version = metadata.get_version()
        # ProductVersion must be strictly numeric
        # XXX need to deal with prerelease versions
        sversion = "%d.%d.%d" % StrictVersion(version).version
        # Prefix ProductName with Python x.y, so that
        # it sorts together with the other Python packages
        # in Add-Remove-Programs (APR)
        fullname = self.distribution.get_fullname()
        if self.target_version:
            product_name = "Python %s %s" % (self.target_version, fullname)
        else:
            product_name = "Python %s" % (fullname)
        self.db = msilib.init_database(installer_name, schema,
                product_name, msilib.gen_uuid(),
                sversion, author)
        msilib.add_tables(self.db, sequence)
        props = [('DistVersion', version)]
        email = metadata.author_email or metadata.maintainer_email
        if email:
            props.append(("ARPCONTACT", email))
        if metadata.url:
            props.append(("ARPURLINFOABOUT", metadata.url))
        if props:
            add_data(self.db, 'Property', props)

        self.add_find_python()
        self.add_files()
        self.add_scripts()
        self.add_ui()
        self.db.Commit()

        if hasattr(self.distribution, 'dist_files'):
            tup = 'bdist_msi', self.target_version or 'any', fullname
            self.distribution.dist_files.append(tup)

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)

    def add_files(self):
        db = self.db
        cab = msilib.CAB("distfiles")
        rootdir = os.path.abspath(self.bdist_dir)

        root = Directory(db, cab, None, rootdir, "TARGETDIR", "SourceDir")
        f = Feature(db, "Python", "Python", "Everything",
                    0, 1, directory="TARGETDIR")

        items = [(f, root, '')]
        for version in self.versions + [self.other_version]:
            target = "TARGETDIR" + version
            name = default = "Python" + version
            desc = "Everything"
            if version is self.other_version:
                title = "Python from another location"
                level = 2
            else:
                title = "Python %s from registry" % version
                level = 1
            f = Feature(db, name, title, desc, 1, level, directory=target)
            dir = Directory(db, cab, root, rootdir, target, default)
            items.append((f, dir, version))
        db.Commit()

        seen = {}
        for feature, dir, version in items:
            todo = [dir]
            while todo:
                dir = todo.pop()
                for file in os.listdir(dir.absolute):
                    afile = os.path.join(dir.absolute, file)
                    if os.path.isdir(afile):
                        short = "%s|%s" % (dir.make_short(file), file)
                        default = file + version
                        newdir = Directory(db, cab, dir, file, default, short)
                        todo.append(newdir)
                    else:
                        if not dir.component:
                            dir.start_component(dir.logical, feature, 0)
                        if afile not in seen:
                            key = seen[afile] = dir.add_file(file)
                            if file==self.install_script:
                                if self.install_script_key:
                                    raise DistutilsOptionError(
                                          "Multiple files with name %s" % file)
                                self.install_script_key = '[#%s]' % key
                        else:
                            key = seen[afile]
                            add_data(self.db, "DuplicateFile",
                                [(key + version, dir.component, key, None, dir.logical)])
            db.Commit()
        cab.commit(db)

    def add_find_python(self):
        """Adds code to the installer to compute the location of Python.

        Properties PYTHON.MACHINE.X.Y and PYTHON.USER.X.Y will be set from the
        registry for each version of Python.

        Properties TARGETDIRX.Y will be set from PYTHON.USER.X.Y if defined,
        else from PYTHON.MACHINE.X.Y.

        Properties PYTHONX.Y will be set to TARGETDIRX.Y\\python.exe"""

        start = 402
        for ver in self.versions:
            install_path = r"SOFTWARE\Python\PythonCore\%s\InstallPath" % ver
            machine_reg = "python.machine." + ver
            user_reg = "python.user." + ver
            machine_prop = "PYTHON.MACHINE." + ver
            user_prop = "PYTHON.USER." + ver
            machine_action = "PythonFromMachine" + ver
            user_action = "PythonFromUser" + ver
            exe_action = "PythonExe" + ver
            target_dir_prop = "TARGETDIR" + ver
            exe_prop = "PYTHON" + ver
            if msilib.Win64:
                # type: msidbLocatorTypeRawValue + msidbLocatorType64bit
                Type = 2+16
            else:
                Type = 2
            add_data(self.db, "RegLocator",
                    [(machine_reg, 2, install_path, None, Type),
                     (user_reg, 1, install_path, None, Type)])
            add_data(self.db, "AppSearch",
                    [(machine_prop, machine_reg),
                     (user_prop, user_reg)])
            add_data(self.db, "CustomAction",
                    [(machine_action, 51+256, target_dir_prop, "[" + machine_prop + "]"),
                     (user_action, 51+256, target_dir_prop, "[" + user_prop + "]"),
                     (exe_action, 51+256, exe_prop, "[" + target_dir_prop + "]\\python.exe"),
                    ])
            add_data(self.db, "InstallExecuteSequence",
                    [(machine_action, machine_prop, start),
                     (user_action, user_prop, start + 1),
                     (exe_action, None, start + 2),
                    ])
            add_data(self.db, "InstallUISequence",
                    [(machine_action, machine_prop, start),
                     (user_action, user_prop, start + 1),
                     (exe_action, None, start + 2),
                    ])
            add_data(self.db, "Condition",
                    [("Python" + ver, 0, "NOT TARGETDIR" + ver)])
            start += 4
            assert start < 500

    def add_scripts(self):
        if self.install_script:
            start = 6800
            for ver in self.versions + [self.other_version]:
                install_action = "install_script." + ver
                exe_prop = "PYTHON" + ver
                add_data(self.db, "CustomAction",
                        [(install_action, 50, exe_prop, self.install_script_key)])
                add_data(self.db, "InstallExecuteSequence",
                        [(install_action, "&Python%s=3" % ver, start)])
                start += 1
        # XXX pre-install scripts are currently refused in finalize_options()
        #     but if this feature is completed, it will also need to add
        #     entries for each version as the above code does
        if self.pre_install_script:
            scriptfn = os.path.join(self.bdist_dir, "preinstall.bat")
            f = open(scriptfn, "w")
            # The batch file will be executed with [PYTHON], so that %1
            # is the path to the Python interpreter; %0 will be the path
            # of the batch file.
            # rem ="""
            # %1 %0
            # exit
            # """
            # <actual script>
            f.write('rem ="""\n%1 %0\nexit\n"""\n')
            f.write(open(self.pre_install_script).read())
            f.close()
            add_data(self.db, "Binary",
                [("PreInstall", msilib.Binary(scriptfn))
                ])
            add_data(self.db, "CustomAction",
                [("PreInstall", 2, "PreInstall", None)
                ])
            add_data(self.db, "InstallExecuteSequence",
                    [("PreInstall", "NOT Installed", 450)])


    def add_ui(self):
        db = self.db
        x = y = 50
        w = 370
        h = 300
        title = "[ProductName] Setup"

        # see "Dialog Style Bits"
        modal = 3      # visible | modal
        modeless = 1   # visible
        track_disk_space = 32

        # UI customization properties
        add_data(db, "Property",
                 # See "DefaultUIFont Property"
                 [("DefaultUIFont", "DlgFont8"),
                  # See "ErrorDialog Style Bit"
                  ("ErrorDialog", "ErrorDlg"),
                  ("Progress1", "Install"),   # modified in maintenance type dlg
                  ("Progress2", "installs"),
                  ("MaintenanceForm_Action", "Repair"),
                  # possible values: ALL, JUSTME
                  ("WhichUsers", "ALL")
                 ])

        # Fonts, see "TextStyle Table"
        add_data(db, "TextStyle",
                 [("DlgFont8", "Tahoma", 9, None, 0),
                  ("DlgFontBold8", "Tahoma", 8, None, 1), #bold
                  ("VerdanaBold10", "Verdana", 10, None, 1),
                  ("VerdanaRed9", "Verdana", 9, 255, 0),
                 ])

        # UI Sequences, see "InstallUISequence Table", "Using a Sequence Table"
        # Numbers indicate sequence; see sequence.py for how these action integrate
        add_data(db, "InstallUISequence",
                 [("PrepareDlg", "Not Privileged or Windows9x or Installed", 140),
                  ("WhichUsersDlg", "Privileged and not Windows9x and not Installed", 141),
                  # In the user interface, assume all-users installation if privileged.
                  ("SelectFeaturesDlg", "Not Installed", 1230),
                  # XXX no support for resume installations yet
                  #("ResumeDlg", "Installed AND (RESUME OR Preselected)", 1240),
                  ("MaintenanceTypeDlg", "Installed AND NOT RESUME AND NOT Preselected", 1250),
                  ("ProgressDlg", None, 1280)])

        add_data(db, 'ActionText', text.ActionText)
        add_data(db, 'UIText', text.UIText)
        #####################################################################
        # Standard dialogs: FatalError, UserExit, ExitDialog
        fatal=PyDialog(db, "FatalError", x, y, w, h, modal, title,
                     "Finish", "Finish", "Finish")
        fatal.title("[ProductName] Installer ended prematurely")
        fatal.back("< Back", "Finish", active = 0)
        fatal.cancel("Cancel", "Back", active = 0)
        fatal.text("Description1", 15, 70, 320, 80, 0x30003,
                   "[ProductName] setup ended prematurely because of an error.  Your system has not been modified.  To install this program at a later time, please run the installation again.")
        fatal.text("Description2", 15, 155, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c=fatal.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Exit")

        user_exit=PyDialog(db, "UserExit", x, y, w, h, modal, title,
                     "Finish", "Finish", "Finish")
        user_exit.title("[ProductName] Installer was interrupted")
        user_exit.back("< Back", "Finish", active = 0)
        user_exit.cancel("Cancel", "Back", active = 0)
        user_exit.text("Description1", 15, 70, 320, 80, 0x30003,
                   "[ProductName] setup was interrupted.  Your system has not been modified.  "
                   "To install this program at a later time, please run the installation again.")
        user_exit.text("Description2", 15, 155, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c = user_exit.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Exit")

        exit_dialog = PyDialog(db, "ExitDialog", x, y, w, h, modal, title,
                             "Finish", "Finish", "Finish")
        exit_dialog.title("Completing the [ProductName] Installer")
        exit_dialog.back("< Back", "Finish", active = 0)
        exit_dialog.cancel("Cancel", "Back", active = 0)
        exit_dialog.text("Description", 15, 235, 320, 20, 0x30003,
                   "Click the Finish button to exit the Installer.")
        c = exit_dialog.next("Finish", "Cancel", name="Finish")
        c.event("EndDialog", "Return")

        #####################################################################
        # Required dialog: FilesInUse, ErrorDlg
        inuse = PyDialog(db, "FilesInUse",
                         x, y, w, h,
                         19,                # KeepModeless|Modal|Visible
                         title,
                         "Retry", "Retry", "Retry", bitmap=False)
        inuse.text("Title", 15, 6, 200, 15, 0x30003,
                   r"{\DlgFontBold8}Files in Use")
        inuse.text("Description", 20, 23, 280, 20, 0x30003,
               "Some files that need to be updated are currently in use.")
        inuse.text("Text", 20, 55, 330, 50, 3,
                   "The following applications are using files that need to be updated by this setup. Close these applications and then click Retry to continue the installation or Cancel to exit it.")
        inuse.control("List", "ListBox", 20, 107, 330, 130, 7, "FileInUseProcess",
                      None, None, None)
        c=inuse.back("Exit", "Ignore", name="Exit")
        c.event("EndDialog", "Exit")
        c=inuse.next("Ignore", "Retry", name="Ignore")
        c.event("EndDialog", "Ignore")
        c=inuse.cancel("Retry", "Exit", name="Retry")
        c.event("EndDialog","Retry")

        # See "Error Dialog". See "ICE20" for the required names of the controls.
        error = Dialog(db, "ErrorDlg",
                       50, 10, 330, 101,
                       65543,       # Error|Minimize|Modal|Visible
                       title,
                       "ErrorText", None, None)
        error.text("ErrorText", 50,9,280,48,3, "")
        #error.control("ErrorIcon", "Icon", 15, 9, 24, 24, 5242881, None, "py.ico", None, None)
        error.pushbutton("N",120,72,81,21,3,"No",None).event("EndDialog","ErrorNo")
        error.pushbutton("Y",240,72,81,21,3,"Yes",None).event("EndDialog","ErrorYes")
        error.pushbutton("A",0,72,81,21,3,"Abort",None).event("EndDialog","ErrorAbort")
        error.pushbutton("C",42,72,81,21,3,"Cancel",None).event("EndDialog","ErrorCancel")
        error.pushbutton("I",81,72,81,21,3,"Ignore",None).event("EndDialog","ErrorIgnore")
        error.pushbutton("O",159,72,81,21,3,"Ok",None).event("EndDialog","ErrorOk")
        error.pushbutton("R",198,72,81,21,3,"Retry",None).event("EndDialog","ErrorRetry")

        #####################################################################
        # Global "Query Cancel" dialog
        cancel = Dialog(db, "CancelDlg", 50, 10, 260, 85, 3, title,
                        "No", "No", "No")
        cancel.text("Text", 48, 15, 194, 30, 3,
                    "Are you sure you want to cancel [ProductName] installation?")
        #cancel.control("Icon", "Icon", 15, 15, 24, 24, 5242881, None,
        #               "py.ico", None, None)
        c=cancel.pushbutton("Yes", 72, 57, 56, 17, 3, "Yes", "No")
        c.event("EndDialog", "Exit")

        c=cancel.pushbutton("No", 132, 57, 56, 17, 3, "No", "Yes")
        c.event("EndDialog", "Return")

        #####################################################################
        # Global "Wait for costing" dialog
        costing = Dialog(db, "WaitForCostingDlg", 50, 10, 260, 85, modal, title,
                         "Return", "Return", "Return")
        costing.text("Text", 48, 15, 194, 30, 3,
                     "Please wait while the installer finishes determining your disk space requirements.")
        c = costing.pushbutton("Return", 102, 57, 56, 17, 3, "Return", None)
        c.event("EndDialog", "Exit")

        #####################################################################
        # Preparation dialog: no user input except cancellation
        prep = PyDialog(db, "PrepareDlg", x, y, w, h, modeless, title,
                        "Cancel", "Cancel", "Cancel")
        prep.text("Description", 15, 70, 320, 40, 0x30003,
                  "Please wait while the Installer prepares to guide you through the installation.")
        prep.title("Welcome to the [ProductName] Installer")
        c=prep.text("ActionText", 15, 110, 320, 20, 0x30003, "Pondering...")
        c.mapping("ActionText", "Text")
        c=prep.text("ActionData", 15, 135, 320, 30, 0x30003, None)
        c.mapping("ActionData", "Text")
        prep.back("Back", None, active=0)
        prep.next("Next", None, active=0)
        c=prep.cancel("Cancel", None)
        c.event("SpawnDialog", "CancelDlg")

        #####################################################################
        # Feature (Python directory) selection
        seldlg = PyDialog(db, "SelectFeaturesDlg", x, y, w, h, modal, title,
                        "Next", "Next", "Cancel")
        seldlg.title("Select Python Installations")

        seldlg.text("Hint", 15, 30, 300, 20, 3,
                    "Select the Python locations where %s should be installed."
                    % self.distribution.get_fullname())

        seldlg.back("< Back", None, active=0)
        c = seldlg.next("Next >", "Cancel")
        order = 1
        c.event("[TARGETDIR]", "[SourceDir]", ordering=order)
        for version in self.versions + [self.other_version]:
            order += 1
            c.event("[TARGETDIR]", "[TARGETDIR%s]" % version,
                    "FEATURE_SELECTED AND &Python%s=3" % version,
                    ordering=order)
        c.event("SpawnWaitDialog", "WaitForCostingDlg", ordering=order + 1)
        c.event("EndDialog", "Return", ordering=order + 2)
        c = seldlg.cancel("Cancel", "Features")
        c.event("SpawnDialog", "CancelDlg")

        c = seldlg.control("Features", "SelectionTree", 15, 60, 300, 120, 3,
                           "FEATURE", None, "PathEdit", None)
        c.event("[FEATURE_SELECTED]", "1")
        ver = self.other_version
        install_other_cond = "FEATURE_SELECTED AND &Python%s=3" % ver
        dont_install_other_cond = "FEATURE_SELECTED AND &Python%s<>3" % ver

        c = seldlg.text("Other", 15, 200, 300, 15, 3,
                        "Provide an alternate Python location")
        c.condition("Enable", install_other_cond)
        c.condition("Show", install_other_cond)
        c.condition("Disable", dont_install_other_cond)
        c.condition("Hide", dont_install_other_cond)

        c = seldlg.control("PathEdit", "PathEdit", 15, 215, 300, 16, 1,
                           "TARGETDIR" + ver, None, "Next", None)
        c.condition("Enable", install_other_cond)
        c.condition("Show", install_other_cond)
        c.condition("Disable", dont_install_other_cond)
        c.condition("Hide", dont_install_other_cond)

        #####################################################################
        # Disk cost
        cost = PyDialog(db, "DiskCostDlg", x, y, w, h, modal, title,
                        "OK", "OK", "OK", bitmap=False)
        cost.text("Title", 15, 6, 200, 15, 0x30003,
                  "{\DlgFontBold8}Disk Space Requirements")
        cost.text("Description", 20, 20, 280, 20, 0x30003,
                  "The disk space required for the installation of the selected features.")
        cost.text("Text", 20, 53, 330, 60, 3,
                  "The highlighted volumes (if any) do not have enough disk space "
              "available for the currently selected features.  You can either "
              "remove some files from the highlighted volumes, or choose to "
              "install less features onto local drive(s), or select different "
              "destination drive(s).")
        cost.control("VolumeList", "VolumeCostList", 20, 100, 330, 150, 393223,
                     None, "{120}{70}{70}{70}{70}", None, None)
        cost.xbutton("OK", "Ok", None, 0.5).event("EndDialog", "Return")

        #####################################################################
        # WhichUsers Dialog. Only available on NT, and for privileged users.
        # This must be run before FindRelatedProducts, because that will
        # take into account whether the previous installation was per-user
        # or per-machine. We currently don't support going back to this
        # dialog after "Next" was selected; to support this, we would need to
        # find how to reset the ALLUSERS property, and how to re-run
        # FindRelatedProducts.
        # On Windows9x, the ALLUSERS property is ignored on the command line
        # and in the Property table, but installer fails according to the documentation
        # if a dialog attempts to set ALLUSERS.
        whichusers = PyDialog(db, "WhichUsersDlg", x, y, w, h, modal, title,
                            "AdminInstall", "Next", "Cancel")
        whichusers.title("Select whether to install [ProductName] for all users of this computer.")
        # A radio group with two options: allusers, justme
        g = whichusers.radiogroup("AdminInstall", 15, 60, 260, 50, 3,
                                  "WhichUsers", "", "Next")
        g.add("ALL", 0, 5, 150, 20, "Install for all users")
        g.add("JUSTME", 0, 25, 150, 20, "Install just for me")

        whichusers.back("Back", None, active=0)

        c = whichusers.next("Next >", "Cancel")
        c.event("[ALLUSERS]", "1", 'WhichUsers="ALL"', 1)
        c.event("EndDialog", "Return", ordering = 2)

        c = whichusers.cancel("Cancel", "AdminInstall")
        c.event("SpawnDialog", "CancelDlg")

        #####################################################################
        # Installation Progress dialog (modeless)
        progress = PyDialog(db, "ProgressDlg", x, y, w, h, modeless, title,
                            "Cancel", "Cancel", "Cancel", bitmap=False)
        progress.text("Title", 20, 15, 200, 15, 0x30003,
                      "{\DlgFontBold8}[Progress1] [ProductName]")
        progress.text("Text", 35, 65, 300, 30, 3,
                      "Please wait while the Installer [Progress2] [ProductName]. "
                      "This may take several minutes.")
        progress.text("StatusLabel", 35, 100, 35, 20, 3, "Status:")

        c=progress.text("ActionText", 70, 100, w-70, 20, 3, "Pondering...")
        c.mapping("ActionText", "Text")

        #c=progress.text("ActionData", 35, 140, 300, 20, 3, None)
        #c.mapping("ActionData", "Text")

        c=progress.control("ProgressBar", "ProgressBar", 35, 120, 300, 10, 65537,
                           None, "Progress done", None, None)
        c.mapping("SetProgress", "Progress")

        progress.back("< Back", "Next", active=False)
        progress.next("Next >", "Cancel", active=False)
        progress.cancel("Cancel", "Back").event("SpawnDialog", "CancelDlg")

        ###################################################################
        # Maintenance type: repair/uninstall
        maint = PyDialog(db, "MaintenanceTypeDlg", x, y, w, h, modal, title,
                         "Next", "Next", "Cancel")
        maint.title("Welcome to the [ProductName] Setup Wizard")
        maint.text("BodyText", 15, 63, 330, 42, 3,
                   "Select whether you want to repair or remove [ProductName].")
        g=maint.radiogroup("RepairRadioGroup", 15, 108, 330, 60, 3,
                            "MaintenanceForm_Action", "", "Next")
        #g.add("Change", 0, 0, 200, 17, "&Change [ProductName]")
        g.add("Repair", 0, 18, 200, 17, "&Repair [ProductName]")
        g.add("Remove", 0, 36, 200, 17, "Re&move [ProductName]")

        maint.back("< Back", None, active=False)
        c=maint.next("Finish", "Cancel")
        # Change installation: Change progress dialog to "Change", then ask
        # for feature selection
        #c.event("[Progress1]", "Change", 'MaintenanceForm_Action="Change"', 1)
        #c.event("[Progress2]", "changes", 'MaintenanceForm_Action="Change"', 2)

        # Reinstall: Change progress dialog to "Repair", then invoke reinstall
        # Also set list of reinstalled features to "ALL"
        c.event("[REINSTALL]", "ALL", 'MaintenanceForm_Action="Repair"', 5)
        c.event("[Progress1]", "Repairing", 'MaintenanceForm_Action="Repair"', 6)
        c.event("[Progress2]", "repairs", 'MaintenanceForm_Action="Repair"', 7)
        c.event("Reinstall", "ALL", 'MaintenanceForm_Action="Repair"', 8)

        # Uninstall: Change progress to "Remove", then invoke uninstall
        # Also set list of removed features to "ALL"
        c.event("[REMOVE]", "ALL", 'MaintenanceForm_Action="Remove"', 11)
        c.event("[Progress1]", "Removing", 'MaintenanceForm_Action="Remove"', 12)
        c.event("[Progress2]", "removes", 'MaintenanceForm_Action="Remove"', 13)
        c.event("Remove", "ALL", 'MaintenanceForm_Action="Remove"', 14)

        # Close dialog when maintenance action scheduled
        c.event("EndDialog", "Return", 'MaintenanceForm_Action<>"Change"', 20)
        #c.event("NewDialog", "SelectFeaturesDlg", 'MaintenanceForm_Action="Change"', 21)

        maint.cancel("Cancel", "RepairRadioGroup").event("SpawnDialog", "CancelDlg")

    def get_installer_filename(self, fullname):
        # Factored out to allow overriding in subclasses
        if self.target_version:
            base_name = "%s.%s-py%s.msi" % (fullname, self.plat_name,
                                            self.target_version)
        else:
            base_name = "%s.%s.msi" % (fullname, self.plat_name)
        installer_name = os.path.join(self.dist_dir, base_name)
        return installer_name
                                                                                                               usr/lib/python3.4/distutils/command/bdist_rpm.py                                                    0100644 0000000 0000000 00000052246 12415221640 020377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist_rpm

Implements the Distutils 'bdist_rpm' command (create RPM source and binary
distributions)."""

import subprocess, sys, os
from distutils.core import Command
from distutils.debug import DEBUG
from distutils.util import get_platform
from distutils.file_util import write_file
from distutils.errors import *
from distutils.sysconfig import get_python_version
from distutils import log

class bdist_rpm(Command):

    description = "create an RPM distribution"

    user_options = [
        ('bdist-base=', None,
         "base directory for creating built distributions"),
        ('rpm-base=', None,
         "base directory for creating RPMs (defaults to \"rpm\" under "
         "--bdist-base; must be specified for RPM 2)"),
        ('dist-dir=', 'd',
         "directory to put final RPM files in "
         "(and .spec files if --spec-only)"),
        ('python=', None,
         "path to Python interpreter to hard-code in the .spec file "
         "(default: \"python\")"),
        ('fix-python', None,
         "hard-code the exact path to the current Python interpreter in "
         "the .spec file"),
        ('spec-only', None,
         "only regenerate spec file"),
        ('source-only', None,
         "only generate source RPM"),
        ('binary-only', None,
         "only generate binary RPM"),
        ('use-bzip2', None,
         "use bzip2 instead of gzip to create source distribution"),

        # More meta-data: too RPM-specific to put in the setup script,
        # but needs to go in the .spec file -- so we make these options
        # to "bdist_rpm".  The idea is that packagers would put this
        # info in setup.cfg, although they are of course free to
        # supply it on the command line.
        ('distribution-name=', None,
         "name of the (Linux) distribution to which this "
         "RPM applies (*not* the name of the module distribution!)"),
        ('group=', None,
         "package classification [default: \"Development/Libraries\"]"),
        ('release=', None,
         "RPM release number"),
        ('serial=', None,
         "RPM serial number"),
        ('vendor=', None,
         "RPM \"vendor\" (eg. \"Joe Blow <joe@example.com>\") "
         "[default: maintainer or author from setup script]"),
        ('packager=', None,
         "RPM packager (eg. \"Jane Doe <jane@example.net>\")"
         "[default: vendor]"),
        ('doc-files=', None,
         "list of documentation files (space or comma-separated)"),
        ('changelog=', None,
         "RPM changelog"),
        ('icon=', None,
         "name of icon file"),
        ('provides=', None,
         "capabilities provided by this package"),
        ('requires=', None,
         "capabilities required by this package"),
        ('conflicts=', None,
         "capabilities which conflict with this package"),
        ('build-requires=', None,
         "capabilities required to build this package"),
        ('obsoletes=', None,
         "capabilities made obsolete by this package"),
        ('no-autoreq', None,
         "do not automatically calculate dependencies"),

        # Actions to take when building RPM
        ('keep-temp', 'k',
         "don't clean up RPM build directory"),
        ('no-keep-temp', None,
         "clean up RPM build directory [default]"),
        ('use-rpm-opt-flags', None,
         "compile with RPM_OPT_FLAGS when building from source RPM"),
        ('no-rpm-opt-flags', None,
         "do not pass any RPM CFLAGS to compiler"),
        ('rpm3-mode', None,
         "RPM 3 compatibility mode (default)"),
        ('rpm2-mode', None,
         "RPM 2 compatibility mode"),

        # Add the hooks necessary for specifying custom scripts
        ('prep-script=', None,
         "Specify a script for the PREP phase of RPM building"),
        ('build-script=', None,
         "Specify a script for the BUILD phase of RPM building"),

        ('pre-install=', None,
         "Specify a script for the pre-INSTALL phase of RPM building"),
        ('install-script=', None,
         "Specify a script for the INSTALL phase of RPM building"),
        ('post-install=', None,
         "Specify a script for the post-INSTALL phase of RPM building"),

        ('pre-uninstall=', None,
         "Specify a script for the pre-UNINSTALL phase of RPM building"),
        ('post-uninstall=', None,
         "Specify a script for the post-UNINSTALL phase of RPM building"),

        ('clean-script=', None,
         "Specify a script for the CLEAN phase of RPM building"),

        ('verify-script=', None,
         "Specify a script for the VERIFY phase of the RPM build"),

        # Allow a packager to explicitly force an architecture
        ('force-arch=', None,
         "Force an architecture onto the RPM build process"),

        ('quiet', 'q',
         "Run the INSTALL phase of RPM building in quiet mode"),
        ]

    boolean_options = ['keep-temp', 'use-rpm-opt-flags', 'rpm3-mode',
                       'no-autoreq', 'quiet']

    negative_opt = {'no-keep-temp': 'keep-temp',
                    'no-rpm-opt-flags': 'use-rpm-opt-flags',
                    'rpm2-mode': 'rpm3-mode'}


    def initialize_options(self):
        self.bdist_base = None
        self.rpm_base = None
        self.dist_dir = None
        self.python = None
        self.fix_python = None
        self.spec_only = None
        self.binary_only = None
        self.source_only = None
        self.use_bzip2 = None

        self.distribution_name = None
        self.group = None
        self.release = None
        self.serial = None
        self.vendor = None
        self.packager = None
        self.doc_files = None
        self.changelog = None
        self.icon = None

        self.prep_script = None
        self.build_script = None
        self.install_script = None
        self.clean_script = None
        self.verify_script = None
        self.pre_install = None
        self.post_install = None
        self.pre_uninstall = None
        self.post_uninstall = None
        self.prep = None
        self.provides = None
        self.requires = None
        self.conflicts = None
        self.build_requires = None
        self.obsoletes = None

        self.keep_temp = 0
        self.use_rpm_opt_flags = 1
        self.rpm3_mode = 1
        self.no_autoreq = 0

        self.force_arch = None
        self.quiet = 0

    def finalize_options(self):
        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))
        if self.rpm_base is None:
            if not self.rpm3_mode:
                raise DistutilsOptionError(
                      "you must specify --rpm-base in RPM 2 mode")
            self.rpm_base = os.path.join(self.bdist_base, "rpm")

        if self.python is None:
            if self.fix_python:
                self.python = sys.executable
            else:
                self.python = "python3"
        elif self.fix_python:
            raise DistutilsOptionError(
                  "--python and --fix-python are mutually exclusive options")

        if os.name != 'posix':
            raise DistutilsPlatformError("don't know how to create RPM "
                   "distributions on platform %s" % os.name)
        if self.binary_only and self.source_only:
            raise DistutilsOptionError(
                  "cannot supply both '--source-only' and '--binary-only'")

        # don't pass CFLAGS to pure python distributions
        if not self.distribution.has_ext_modules():
            self.use_rpm_opt_flags = 0

        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))
        self.finalize_package_data()

    def finalize_package_data(self):
        self.ensure_string('group', "Development/Libraries")
        self.ensure_string('vendor',
                           "%s <%s>" % (self.distribution.get_contact(),
                                        self.distribution.get_contact_email()))
        self.ensure_string('packager')
        self.ensure_string_list('doc_files')
        if isinstance(self.doc_files, list):
            for readme in ('README', 'README.txt'):
                if os.path.exists(readme) and readme not in self.doc_files:
                    self.doc_files.append(readme)

        self.ensure_string('release', "1")
        self.ensure_string('serial')   # should it be an int?

        self.ensure_string('distribution_name')

        self.ensure_string('changelog')
          # Format changelog correctly
        self.changelog = self._format_changelog(self.changelog)

        self.ensure_filename('icon')

        self.ensure_filename('prep_script')
        self.ensure_filename('build_script')
        self.ensure_filename('install_script')
        self.ensure_filename('clean_script')
        self.ensure_filename('verify_script')
        self.ensure_filename('pre_install')
        self.ensure_filename('post_install')
        self.ensure_filename('pre_uninstall')
        self.ensure_filename('post_uninstall')

        # XXX don't forget we punted on summaries and descriptions -- they
        # should be handled here eventually!

        # Now *this* is some meta-data that belongs in the setup script...
        self.ensure_string_list('provides')
        self.ensure_string_list('requires')
        self.ensure_string_list('conflicts')
        self.ensure_string_list('build_requires')
        self.ensure_string_list('obsoletes')

        self.ensure_string('force_arch')

    def run(self):
        if DEBUG:
            print("before _get_package_data():")
            print("vendor =", self.vendor)
            print("packager =", self.packager)
            print("doc_files =", self.doc_files)
            print("changelog =", self.changelog)

        # make directories
        if self.spec_only:
            spec_dir = self.dist_dir
            self.mkpath(spec_dir)
        else:
            rpm_dir = {}
            for d in ('SOURCES', 'SPECS', 'BUILD', 'RPMS', 'SRPMS'):
                rpm_dir[d] = os.path.join(self.rpm_base, d)
                self.mkpath(rpm_dir[d])
            spec_dir = rpm_dir['SPECS']

        # Spec file goes into 'dist_dir' if '--spec-only specified',
        # build/rpm.<plat> otherwise.
        spec_path = os.path.join(spec_dir,
                                 "%s.spec" % self.distribution.get_name())
        self.execute(write_file,
                     (spec_path,
                      self._make_spec_file()),
                     "writing '%s'" % spec_path)

        if self.spec_only: # stop if requested
            return

        # Make a source distribution and copy to SOURCES directory with
        # optional icon.
        saved_dist_files = self.distribution.dist_files[:]
        sdist = self.reinitialize_command('sdist')
        if self.use_bzip2:
            sdist.formats = ['bztar']
        else:
            sdist.formats = ['gztar']
        self.run_command('sdist')
        self.distribution.dist_files = saved_dist_files

        source = sdist.get_archive_files()[0]
        source_dir = rpm_dir['SOURCES']
        self.copy_file(source, source_dir)

        if self.icon:
            if os.path.exists(self.icon):
                self.copy_file(self.icon, source_dir)
            else:
                raise DistutilsFileError(
                      "icon file '%s' does not exist" % self.icon)

        # build package
        log.info("building RPMs")
        rpm_cmd = ['rpm']
        if os.path.exists('/usr/bin/rpmbuild') or \
           os.path.exists('/bin/rpmbuild'):
            rpm_cmd = ['rpmbuild']

        if self.source_only: # what kind of RPMs?
            rpm_cmd.append('-bs')
        elif self.binary_only:
            rpm_cmd.append('-bb')
        else:
            rpm_cmd.append('-ba')
        rpm_cmd.extend(['--define', '__python %s' % self.python])
        if self.rpm3_mode:
            rpm_cmd.extend(['--define',
                             '_topdir %s' % os.path.abspath(self.rpm_base)])
        if not self.keep_temp:
            rpm_cmd.append('--clean')

        if self.quiet:
            rpm_cmd.append('--quiet')

        rpm_cmd.append(spec_path)
        # Determine the binary rpm names that should be built out of this spec
        # file
        # Note that some of these may not be really built (if the file
        # list is empty)
        nvr_string = "%{name}-%{version}-%{release}"
        src_rpm = nvr_string + ".src.rpm"
        non_src_rpm = "%{arch}/" + nvr_string + ".%{arch}.rpm"
        q_cmd = r"rpm -q --qf '%s %s\n' --specfile '%s'" % (
            src_rpm, non_src_rpm, spec_path)

        out = os.popen(q_cmd)
        try:
            binary_rpms = []
            source_rpm = None
            while True:
                line = out.readline()
                if not line:
                    break
                l = line.strip().split()
                assert(len(l) == 2)
                binary_rpms.append(l[1])
                # The source rpm is named after the first entry in the spec file
                if source_rpm is None:
                    source_rpm = l[0]

            status = out.close()
            if status:
                raise DistutilsExecError("Failed to execute: %s" % repr(q_cmd))

        finally:
            out.close()

        self.spawn(rpm_cmd)

        if not self.dry_run:
            if self.distribution.has_ext_modules():
                pyversion = get_python_version()
            else:
                pyversion = 'any'

            if not self.binary_only:
                srpm = os.path.join(rpm_dir['SRPMS'], source_rpm)
                assert(os.path.exists(srpm))
                self.move_file(srpm, self.dist_dir)
                filename = os.path.join(self.dist_dir, source_rpm)
                self.distribution.dist_files.append(
                    ('bdist_rpm', pyversion, filename))

            if not self.source_only:
                for rpm in binary_rpms:
                    rpm = os.path.join(rpm_dir['RPMS'], rpm)
                    if os.path.exists(rpm):
                        self.move_file(rpm, self.dist_dir)
                        filename = os.path.join(self.dist_dir,
                                                os.path.basename(rpm))
                        self.distribution.dist_files.append(
                            ('bdist_rpm', pyversion, filename))

    def _dist_path(self, path):
        return os.path.join(self.dist_dir, os.path.basename(path))

    def _make_spec_file(self):
        """Generate the text of an RPM spec file and return it as a
        list of strings (one per line).
        """
        # definitions and headers
        spec_file = [
            '%define name ' + self.distribution.get_name(),
            '%define version ' + self.distribution.get_version().replace('-','_'),
            '%define unmangled_version ' + self.distribution.get_version(),
            '%define release ' + self.release.replace('-','_'),
            '',
            'Summary: ' + self.distribution.get_description(),
            ]

        # Workaround for #14443 which affects some RPM based systems such as
        # RHEL6 (and probably derivatives)
        vendor_hook = subprocess.getoutput('rpm --eval %{__os_install_post}')
        # Generate a potential replacement value for __os_install_post (whilst
        # normalizing the whitespace to simplify the test for whether the
        # invocation of brp-python-bytecompile passes in __python):
        vendor_hook = '\n'.join(['  %s \\' % line.strip()
                                 for line in vendor_hook.splitlines()])
        problem = "brp-python-bytecompile \\\n"
        fixed = "brp-python-bytecompile %{__python} \\\n"
        fixed_hook = vendor_hook.replace(problem, fixed)
        if fixed_hook != vendor_hook:
            spec_file.append('# Workaround for http://bugs.python.org/issue14443')
            spec_file.append('%define __os_install_post ' + fixed_hook + '\n')

        # put locale summaries into spec file
        # XXX not supported for now (hard to put a dictionary
        # in a config file -- arg!)
        #for locale in self.summaries.keys():
        #    spec_file.append('Summary(%s): %s' % (locale,
        #                                          self.summaries[locale]))

        spec_file.extend([
            'Name: %{name}',
            'Version: %{version}',
            'Release: %{release}',])

        # XXX yuck! this filename is available from the "sdist" command,
        # but only after it has run: and we create the spec file before
        # running "sdist", in case of --spec-only.
        if self.use_bzip2:
            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.bz2')
        else:
            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.gz')

        spec_file.extend([
            'License: ' + self.distribution.get_license(),
            'Group: ' + self.group,
            'BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot',
            'Prefix: %{_prefix}', ])

        if not self.force_arch:
            # noarch if no extension modules
            if not self.distribution.has_ext_modules():
                spec_file.append('BuildArch: noarch')
        else:
            spec_file.append( 'BuildArch: %s' % self.force_arch )

        for field in ('Vendor',
                      'Packager',
                      'Provides',
                      'Requires',
                      'Conflicts',
                      'Obsoletes',
                      ):
            val = getattr(self, field.lower())
            if isinstance(val, list):
                spec_file.append('%s: %s' % (field, ' '.join(val)))
            elif val is not None:
                spec_file.append('%s: %s' % (field, val))


        if self.distribution.get_url() != 'UNKNOWN':
            spec_file.append('Url: ' + self.distribution.get_url())

        if self.distribution_name:
            spec_file.append('Distribution: ' + self.distribution_name)

        if self.build_requires:
            spec_file.append('BuildRequires: ' +
                             ' '.join(self.build_requires))

        if self.icon:
            spec_file.append('Icon: ' + os.path.basename(self.icon))

        if self.no_autoreq:
            spec_file.append('AutoReq: 0')

        spec_file.extend([
            '',
            '%description',
            self.distribution.get_long_description()
            ])

        # put locale descriptions into spec file
        # XXX again, suppressed because config file syntax doesn't
        # easily support this ;-(
        #for locale in self.descriptions.keys():
        #    spec_file.extend([
        #        '',
        #        '%description -l ' + locale,
        #        self.descriptions[locale],
        #        ])

        # rpm scripts
        # figure out default build script
        def_setup_call = "%s %s" % (self.python,os.path.basename(sys.argv[0]))
        def_build = "%s build" % def_setup_call
        if self.use_rpm_opt_flags:
            def_build = 'env CFLAGS="$RPM_OPT_FLAGS" ' + def_build

        # insert contents of files

        # XXX this is kind of misleading: user-supplied options are files
        # that we open and interpolate into the spec file, but the defaults
        # are just text that we drop in as-is.  Hmmm.

        install_cmd = ('%s install -O1 --root=$RPM_BUILD_ROOT '
                       '--record=INSTALLED_FILES') % def_setup_call

        script_options = [
            ('prep', 'prep_script', "%setup -n %{name}-%{unmangled_version}"),
            ('build', 'build_script', def_build),
            ('install', 'install_script', install_cmd),
            ('clean', 'clean_script', "rm -rf $RPM_BUILD_ROOT"),
            ('verifyscript', 'verify_script', None),
            ('pre', 'pre_install', None),
            ('post', 'post_install', None),
            ('preun', 'pre_uninstall', None),
            ('postun', 'post_uninstall', None),
        ]

        for (rpm_opt, attr, default) in script_options:
            # Insert contents of file referred to, if no file is referred to
            # use 'default' as contents of script
            val = getattr(self, attr)
            if val or default:
                spec_file.extend([
                    '',
                    '%' + rpm_opt,])
                if val:
                    spec_file.extend(open(val, 'r').read().split('\n'))
                else:
                    spec_file.append(default)


        # files section
        spec_file.extend([
            '',
            '%files -f INSTALLED_FILES',
            '%defattr(-,root,root)',
            ])

        if self.doc_files:
            spec_file.append('%doc ' + ' '.join(self.doc_files))

        if self.changelog:
            spec_file.extend([
                '',
                '%changelog',])
            spec_file.extend(self.changelog)

        return spec_file

    def _format_changelog(self, changelog):
        """Format the changelog correctly and convert it to a list of strings
        """
        if not changelog:
            return changelog
        new_changelog = []
        for line in changelog.strip().split('\n'):
            line = line.strip()
            if line[0] == '*':
                new_changelog.extend(['', line])
            elif line[0] == '-':
                new_changelog.append(line)
            else:
                new_changelog.append('  ' + line)

        # strip trailing newline inserted by first changelog entry
        if not new_changelog[0]:
            del new_changelog[0]

        return new_changelog
                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/distutils/command/bdist_wininst.py                                                0100644 0000000 0000000 00000035304 12415221640 021270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """distutils.command.bdist_wininst

Implements the Distutils 'bdist_wininst' command: create a windows installer
exe-program."""

import sys, os
from distutils.core import Command
from distutils.util import get_platform
from distutils.dir_util import create_tree, remove_tree
from distutils.errors import *
from distutils.sysconfig import get_python_version
from distutils import log

class bdist_wininst(Command):

    description = "create an executable installer for MS Windows"

    user_options = [('bdist-dir=', None,
                     "temporary directory for creating the distribution"),
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s)" % get_platform()),
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"),
                    ('target-version=', None,
                     "require a specific python version" +
                     " on the target system"),
                    ('no-target-compile', 'c',
                     "do not compile .py to .pyc on the target system"),
                    ('no-target-optimize', 'o',
                     "do not compile .py to .pyo (optimized)"
                     "on the target system"),
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"),
                    ('bitmap=', 'b',
                     "bitmap to use for the installer instead of python-powered logo"),
                    ('title=', 't',
                     "title to display on the installer background instead of default"),
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging)"),
                    ('install-script=', None,
                     "basename of installation script to be run after"
                     "installation or before deinstallation"),
                    ('pre-install-script=', None,
                     "Fully qualified filename of a script to be run before "
                     "any files are installed.  This script need not be in the "
                     "distribution"),
                    ('user-access-control=', None,
                     "specify Vista's UAC handling - 'none'/default=no "
                     "handling, 'auto'=use UAC if target Python installed for "
                     "all users, 'force'=always use UAC"),
                   ]

    boolean_options = ['keep-temp', 'no-target-compile', 'no-target-optimize',
                       'skip-build']

    def initialize_options(self):
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.no_target_compile = 0
        self.no_target_optimize = 0
        self.target_version = None
        self.dist_dir = None
        self.bitmap = None
        self.title = None
        self.skip_build = None
        self.install_script = None
        self.pre_install_script = None
        self.user_access_control = None


    def finalize_options(self):
        self.set_undefined_options('bdist', ('skip_build', 'skip_build'))

        if self.bdist_dir is None:
            if self.skip_build and self.plat_name:
                # If build is skipped and plat_name is overridden, bdist will
                # not see the correct 'plat_name' - so set that up manually.
                bdist = self.distribution.get_command_obj('bdist')
                bdist.plat_name = self.plat_name
                # next the command will be initialized using that name
            bdist_base = self.get_finalized_command('bdist').bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'wininst')

        if not self.target_version:
            self.target_version = ""

        if not self.skip_build and self.distribution.has_ext_modules():
            short_version = get_python_version()
            if self.target_version and self.target_version != short_version:
                raise DistutilsOptionError(
                      "target version can only be %s, or the '--skip-build'" \
                      " option must be specified" % (short_version,))
            self.target_version = short_version

        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'),
                                   ('plat_name', 'plat_name'),
                                  )

        if self.install_script:
            for script in self.distribution.scripts:
                if self.install_script == os.path.basename(script):
                    break
            else:
                raise DistutilsOptionError(
                      "install_script '%s' not found in scripts"
                      % self.install_script)

    def run(self):
        if (sys.platform != "win32" and
            (self.distribution.has_ext_modules() or
             self.distribution.has_c_libraries())):
            raise DistutilsPlatformError \
                  ("distribution contains extensions and/or C libraries; "
                   "must be compiled on a Windows 32 platform")

        if not self.skip_build:
            self.run_command('build')

        install = self.reinitialize_command('install', reinit_subcommands=1)
        install.root = self.bdist_dir
        install.skip_build = self.skip_build
        install.warn_dir = 0
        install.plat_name = self.plat_name

        install_lib = self.reinitialize_command('install_lib')
        # we do not want to include pyc or pyo files
        install_lib.compile = 0
        install_lib.optimize = 0

        if self.distribution.has_ext_modules():
            # If we are building an installer for a Python version other
            # than the one we are currently running, then we need to ensure
            # our build_lib reflects the other Python version rather than ours.
            # Note that for target_version!=sys.version, we must have skipped the
            # build step, so there is no issue with enforcing the build of this
            # version.
            target_version = self.target_version
            if not target_version:
                assert self.skip_build, "Should have already checked this"
                target_version = sys.version[0:3]
            plat_specifier = ".%s-%s" % (self.plat_name, target_version)
            build = self.get_finalized_command('build')
            build.build_lib = os.path.join(build.build_base,
                                           'lib' + plat_specifier)

        # Use a custom scheme for the zip-file, because we have to decide
        # at installation time which scheme to use.
        for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):
            value = key.upper()
            if key == 'headers':
                value = value + '/Include/$dist_name'
            setattr(install,
                    'install_' + key,
                    value)

        log.info("installing to %s", self.bdist_dir)
        install.ensure_finalized()

        # avoid warning of 'install_lib' about installing
        # into a directory not in sys.path
        sys.path.insert(0, os.path.join(self.bdist_dir, 'PURELIB'))

        install.run()

        del sys.path[0]

        # And make an archive relative to the root of the
        # pseudo-installation tree.
        from tempfile import mktemp
        archive_basename = mktemp()
        fullname = self.distribution.get_fullname()
        arcname = self.make_archive(archive_basename, "zip",
                                    root_dir=self.bdist_dir)
        # create an exe containing the zip-file
        self.create_exe(arcname, fullname, self.bitmap)
        if self.distribution.has_ext_modules():
            pyversion = get_python_version()
        else:
            pyversion = 'any'
        self.distribution.dist_files.append(('bdist_wininst', pyversion,
                                             self.get_installer_filename(fullname)))
        # remove the zip-file again
        log.debug("removing temporary file '%s'", arcname)
        os.remove(arcname)

        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run)

    def get_inidata(self):
        # Return data describing the installation.
        lines = []
        metadata = self.distribution.metadata

        # Write the [metadata] section.
        lines.append("[metadata]")

        # 'info' will be displayed in the installer's dialog box,
        # describing the items to be installed.
        info = (metadata.long_description or '') + '\n'

        # Escape newline characters
        def escape(s):
            return s.replace("\n", "\\n")

        for name in ["author", "author_email", "description", "maintainer",
                     "maintainer_email", "name", "url", "version"]:
            data = getattr(metadata, name, "")
            if data:
                info = info + ("\n    %s: %s" % \
                               (name.capitalize(), escape(data)))
                lines.append("%s=%s" % (name, escape(data)))

        # The [setup] section contains entries controlling
        # the installer runtime.
        lines.append("\n[Setup]")
        if self.install_script:
            lines.append("install_script=%s" % self.install_script)
        lines.append("info=%s" % escape(info))
        lines.append("target_compile=%d" % (not self.no_target_compile))
        lines.append("target_optimize=%d" % (not self.no_target_optimize))
        if self.target_version:
            lines.append("target_version=%s" % self.target_version)
        if self.user_access_control:
            lines.append("user_access_control=%s" % self.user_access_control)

        title = self.title or self.distribution.get_fullname()
        lines.append("title=%s" % escape(title))
        import time
        import distutils
        build_info = "Built %s with distutils-%s" % \
                     (time.ctime(time.time()), distutils.__version__)
        lines.append("build_info=%s" % build_info)
        return "\n".join(lines)

    def create_exe(self, arcname, fullname, bitmap=None):
        import struct

        self.mkpath(self.dist_dir)

        cfgdata = self.get_inidata()

        installer_name = self.get_installer_filename(fullname)
        self.announce("creating %s" % installer_name)

        if bitmap:
            bitmapdata = open(bitmap, "rb").read()
            bitmaplen = len(bitmapdata)
        else:
            bitmaplen = 0

        file = open(installer_name, "wb")
        file.write(self.get_exe_bytes())
        if bitmap:
            file.write(bitmapdata)

        # Convert cfgdata from unicode to ascii, mbcs encoded
        if isinstance(cfgdata, str):
            cfgdata = cfgdata.encode("mbcs")

        # Append the pre-install script
        cfgdata = cfgdata + b"\0"
        if self.pre_install_script:
            # We need to normalize newlines, so we open in text mode and
            # convert back to bytes. "latin-1" simply avoids any possible
            # failures.
            with open(self.pre_install_script, "r",
                encoding="latin-