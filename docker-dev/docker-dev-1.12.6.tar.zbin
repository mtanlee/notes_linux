,
         ],
      q(kbs) => [
         q(3203),
         q(0),
         ],
      q(kbt) => [
         q(3204),
         q(0),
         ],
      q(kbu) => [
         q(3205),
         q(0),
         ],
      q(kbv) => [
         q(3206),
         q(0),
         ],
      q(kbw) => [
         q(3207),
         q(0),
         ],
      q(kbx) => [
         q(3208),
         q(0),
         ],
      q(kby) => [
         q(3209),
         q(0),
         ],
      q(kbz) => [
         q(3210),
         q(0),
         ],
      q(kca) => [
         q(3211),
         q(0),
         ],
      q(kcb) => [
         q(3212),
         q(0),
         ],
      q(kcc) => [
         q(3213),
         q(0),
         ],
      q(kcd) => [
         q(3214),
         q(0),
         ],
      q(kce) => [
         q(3215),
         q(0),
         ],
      q(kcf) => [
         q(3216),
         q(0),
         ],
      q(kcg) => [
         q(3217),
         q(0),
         ],
      q(kch) => [
         q(3218),
         q(0),
         ],
      q(kci) => [
         q(3219),
         q(0),
         ],
      q(kcj) => [
         q(3220),
         q(0),
         ],
      q(kck) => [
         q(3221),
         q(0),
         ],
      q(kcl) => [
         q(3222),
         q(0),
         ],
      q(kcm) => [
         q(3223),
         q(0),
         ],
      q(kcn) => [
         q(3224),
         q(0),
         ],
      q(kco) => [
         q(3225),
         q(0),
         ],
      q(kcp) => [
         q(3226),
         q(0),
         ],
      q(kcq) => [
         q(3227),
         q(0),
         ],
      q(kcr) => [
         q(3228),
         q(0),
         ],
      q(kcs) => [
         q(3229),
         q(0),
         ],
      q(kct) => [
         q(3230),
         q(0),
         ],
      q(kcu) => [
         q(3231),
         q(0),
         ],
      q(kcv) => [
         q(3232),
         q(0),
         ],
      q(kcw) => [
         q(3233),
         q(0),
         ],
      q(kcx) => [
         q(3234),
         q(0),
         ],
      q(kcy) => [
         q(3235),
         q(0),
         ],
      q(kcz) => [
         q(3236),
         q(0),
         ],
      q(kda) => [
         q(3237),
         q(0),
         ],
      q(kdc) => [
         q(3238),
         q(0),
         ],
      q(kdd) => [
         q(3239),
         q(0),
         ],
      q(kde) => [
         q(3240),
         q(0),
         ],
      q(kdf) => [
         q(3241),
         q(0),
         ],
      q(kdg) => [
         q(3242),
         q(0),
         ],
      q(kdh) => [
         q(3243),
         q(0),
         ],
      q(kdi) => [
         q(3244),
         q(0),
         ],
      q(kdj) => [
         q(3245),
         q(0),
         ],
      q(kdk) => [
         q(3246),
         q(0),
         ],
      q(kdl) => [
         q(3247),
         q(0),
         ],
      q(kdm) => [
         q(3248),
         q(0),
         ],
      q(kdn) => [
         q(3249),
         q(0),
         ],
      q(kdo) => [
         q(0515),
         q(0),
         ],
      q(kdp) => [
         q(3250),
         q(0),
         ],
      q(kdq) => [
         q(3251),
         q(0),
         ],
      q(kdr) => [
         q(3252),
         q(0),
         ],
      q(kdt) => [
         q(3253),
         q(0),
         ],
      q(kdu) => [
         q(3254),
         q(0),
         ],
      q(kdw) => [
         q(3255),
         q(0),
         ],
      q(kdx) => [
         q(3256),
         q(0),
         ],
      q(kdy) => [
         q(3257),
         q(0),
         ],
      q(kdz) => [
         q(3258),
         q(0),
         ],
      q(kea) => [
         q(3259),
         q(0),
         ],
      q(keb) => [
         q(3260),
         q(0),
         ],
      q(kec) => [
         q(3261),
         q(0),
         ],
      q(ked) => [
         q(3262),
         q(0),
         ],
      q(kee) => [
         q(3263),
         q(0),
         ],
      q(kef) => [
         q(3264),
         q(0),
         ],
      q(keg) => [
         q(3265),
         q(0),
         ],
      q(keh) => [
         q(3266),
         q(0),
         ],
      q(kei) => [
         q(3267),
         q(0),
         ],
      q(kej) => [
         q(3268),
         q(0),
         ],
      q(kek) => [
         q(3269),
         q(0),
         ],
      q(kel) => [
         q(3270),
         q(0),
         ],
      q(kem) => [
         q(3271),
         q(0),
         ],
      q(ken) => [
         q(3272),
         q(0),
         ],
      q(keo) => [
         q(3273),
         q(0),
         ],
      q(kep) => [
         q(3274),
         q(0),
         ],
      q(keq) => [
         q(3275),
         q(0),
         ],
      q(ker) => [
         q(3276),
         q(0),
         ],
      q(kes) => [
         q(3277),
         q(0),
         ],
      q(ket) => [
         q(3278),
         q(0),
         ],
      q(keu) => [
         q(3279),
         q(0),
         ],
      q(kev) => [
         q(3280),
         q(0),
         ],
      q(kew) => [
         q(3281),
         q(0),
         ],
      q(kex) => [
         q(3282),
         q(0),
         ],
      q(key) => [
         q(3283),
         q(0),
         ],
      q(kez) => [
         q(3284),
         q(0),
         ],
      q(kfa) => [
         q(3285),
         q(0),
         ],
      q(kfb) => [
         q(3286),
         q(0),
         ],
      q(kfc) => [
         q(3287),
         q(0),
         ],
      q(kfd) => [
         q(3288),
         q(0),
         ],
      q(kfe) => [
         q(3289),
         q(0),
         ],
      q(kff) => [
         q(3290),
         q(0),
         ],
      q(kfg) => [
         q(3291),
         q(0),
         ],
      q(kfh) => [
         q(3292),
         q(0),
         ],
      q(kfi) => [
         q(3293),
         q(0),
         ],
      q(kfj) => [
         q(3294),
         q(0),
         ],
      q(kfk) => [
         q(3295),
         q(0),
         ],
      q(kfl) => [
         q(3296),
         q(0),
         ],
      q(kfm) => [
         q(3297),
         q(0),
         ],
      q(kfn) => [
         q(3298),
         q(0),
         ],
      q(kfo) => [
         q(3299),
         q(0),
         ],
      q(kfp) => [
         q(3300),
         q(0),
         ],
      q(kfq) => [
         q(3301),
         q(0),
         ],
      q(kfr) => [
         q(3302),
         q(0),
         ],
      q(kfs) => [
         q(3303),
         q(0),
         ],
      q(kft) => [
         q(3304),
         q(0),
         ],
      q(kfu) => [
         q(3305),
         q(0),
         ],
      q(kfv) => [
         q(3306),
         q(0),
         ],
      q(kfw) => [
         q(3307),
         q(0),
         ],
      q(kfx) => [
         q(3308),
         q(0),
         ],
      q(kfy) => [
         q(3309),
         q(0),
         ],
      q(kfz) => [
         q(3310),
         q(0),
         ],
      q(kga) => [
         q(3311),
         q(0),
         ],
      q(kgb) => [
         q(3312),
         q(0),
         ],
      q(kgc) => [
         q(3313),
         q(0),
         ],
      q(kgd) => [
         q(3314),
         q(0),
         ],
      q(kge) => [
         q(3315),
         q(0),
         ],
      q(kgf) => [
         q(3316),
         q(0),
         ],
      q(kgg) => [
         q(3317),
         q(0),
         ],
      q(kgi) => [
         q(3318),
         q(0),
         ],
      q(kgj) => [
         q(3319),
         q(0),
         ],
      q(kgk) => [
         q(3320),
         q(0),
         ],
      q(kgl) => [
         q(3321),
         q(0),
         ],
      q(kgm) => [
         q(3322),
         q(0),
         ],
      q(kgn) => [
         q(3323),
         q(0),
         ],
      q(kgo) => [
         q(3324),
         q(0),
         ],
      q(kgp) => [
         q(3325),
         q(0),
         ],
      q(kgq) => [
         q(3326),
         q(0),
         ],
      q(kgr) => [
         q(3327),
         q(0),
         ],
      q(kgs) => [
         q(3328),
         q(0),
         ],
      q(kgt) => [
         q(3329),
         q(0),
         ],
      q(kgu) => [
         q(3330),
         q(0),
         ],
      q(kgv) => [
         q(3331),
         q(0),
         ],
      q(kgw) => [
         q(3332),
         q(0),
         ],
      q(kgx) => [
         q(3333),
         q(0),
         ],
      q(kgy) => [
         q(3334),
         q(0),
         ],
      q(kha) => [
         q(0220),
         q(0),
         ],
      q(khb) => [
         q(3335),
         q(0),
         ],
      q(khc) => [
         q(3336),
         q(0),
         ],
      q(khd) => [
         q(3337),
         q(0),
         ],
      q(khe) => [
         q(3338),
         q(0),
         ],
      q(khf) => [
         q(3339),
         q(0),
         ],
      q(khg) => [
         q(3340),
         q(0),
         ],
      q(khh) => [
         q(3341),
         q(0),
         ],
      q(khi) => [
         q(0221),
         q(0),
         ],
      q(khj) => [
         q(3342),
         q(0),
         ],
      q(khk) => [
         q(3343),
         q(0),
         ],
      q(khl) => [
         q(3344),
         q(0),
         ],
      q(khm) => [
         q(0222),
         q(0),
         ],
      q(khn) => [
         q(3345),
         q(0),
         ],
      q(kho) => [
         q(0223),
         q(0),
         ],
      q(khp) => [
         q(3346),
         q(0),
         ],
      q(khq) => [
         q(3347),
         q(0),
         ],
      q(khr) => [
         q(3348),
         q(0),
         ],
      q(khs) => [
         q(3349),
         q(0),
         ],
      q(kht) => [
         q(3350),
         q(0),
         ],
      q(khu) => [
         q(3351),
         q(0),
         ],
      q(khv) => [
         q(3352),
         q(0),
         ],
      q(khw) => [
         q(3353),
         q(0),
         ],
      q(khx) => [
         q(3354),
         q(0),
         ],
      q(khy) => [
         q(3355),
         q(0),
         ],
      q(khz) => [
         q(3356),
         q(0),
         ],
      q(kia) => [
         q(3357),
         q(0),
         ],
      q(kib) => [
         q(3358),
         q(0),
         ],
      q(kic) => [
         q(3359),
         q(0),
         ],
      q(kid) => [
         q(3360),
         q(0),
         ],
      q(kie) => [
         q(3361),
         q(0),
         ],
      q(kif) => [
         q(3362),
         q(0),
         ],
      q(kig) => [
         q(3363),
         q(0),
         ],
      q(kih) => [
         q(3364),
         q(0),
         ],
      q(kii) => [
         q(3365),
         q(0),
         ],
      q(kij) => [
         q(3366),
         q(0),
         ],
      q(kik) => [
         q(0224),
         q(0),
         ],
      q(kil) => [
         q(3367),
         q(0),
         ],
      q(kim) => [
         q(3368),
         q(0),
         ],
      q(kin) => [
         q(0225),
         q(0),
         ],
      q(kio) => [
         q(3369),
         q(0),
         ],
      q(kip) => [
         q(3370),
         q(0),
         ],
      q(kiq) => [
         q(3371),
         q(0),
         ],
      q(kir) => [
         q(0226),
         q(0),
         ],
      q(kis) => [
         q(3372),
         q(0),
         ],
      q(kit) => [
         q(3373),
         q(0),
         ],
      q(kiu) => [
         q(3374),
         q(0),
         ],
      q(kiv) => [
         q(3375),
         q(0),
         ],
      q(kiw) => [
         q(3376),
         q(0),
         ],
      q(kix) => [
         q(3377),
         q(0),
         ],
      q(kiy) => [
         q(3378),
         q(0),
         ],
      q(kiz) => [
         q(3379),
         q(0),
         ],
      q(kja) => [
         q(3380),
         q(0),
         ],
      q(kjb) => [
         q(3381),
         q(0),
         ],
      q(kjc) => [
         q(3382),
         q(0),
         ],
      q(kjd) => [
         q(3383),
         q(0),
         ],
      q(kje) => [
         q(3384),
         q(0),
         ],
      q(kjf) => [
         q(3385),
         q(0),
         ],
      q(kjg) => [
         q(3386),
         q(0),
         ],
      q(kjh) => [
         q(3387),
         q(0),
         ],
      q(kji) => [
         q(3388),
         q(0),
         ],
      q(kjj) => [
         q(3389),
         q(0),
         ],
      q(kjk) => [
         q(3390),
         q(0),
         ],
      q(kjl) => [
         q(3391),
         q(0),
         ],
      q(kjm) => [
         q(3392),
         q(0),
         ],
      q(kjn) => [
         q(3393),
         q(0),
         ],
      q(kjo) => [
         q(3394),
         q(0),
         ],
      q(kjp) => [
         q(3395),
         q(0),
         ],
      q(kjq) => [
         q(3396),
         q(0),
         ],
      q(kjr) => [
         q(3397),
         q(0),
         ],
      q(kjs) => [
         q(3398),
         q(0),
         ],
      q(kjt) => [
         q(3399),
         q(0),
         ],
      q(kju) => [
         q(3400),
         q(0),
         ],
      q(kjx) => [
         q(3401),
         q(0),
         ],
      q(kjy) => [
         q(3402),
         q(0),
         ],
      q(kjz) => [
         q(3403),
         q(0),
         ],
      q(kka) => [
         q(3404),
         q(0),
         ],
      q(kkb) => [
         q(3405),
         q(0),
         ],
      q(kkc) => [
         q(3406),
         q(0),
         ],
      q(kkd) => [
         q(3407),
         q(0),
         ],
      q(kke) => [
         q(3408),
         q(0),
         ],
      q(kkf) => [
         q(3409),
         q(0),
         ],
      q(kkg) => [
         q(3410),
         q(0),
         ],
      q(kkh) => [
         q(3411),
         q(0),
         ],
      q(kki) => [
         q(3412),
         q(0),
         ],
      q(kkj) => [
         q(3413),
         q(0),
         ],
      q(kkk) => [
         q(3414),
         q(0),
         ],
      q(kkl) => [
         q(3415),
         q(0),
         ],
      q(kkm) => [
         q(3416),
         q(0),
         ],
      q(kkn) => [
         q(3417),
         q(0),
         ],
      q(kko) => [
         q(3418),
         q(0),
         ],
      q(kkp) => [
         q(3419),
         q(0),
         ],
      q(kkq) => [
         q(3420),
         q(0),
         ],
      q(kkr) => [
         q(3421),
         q(0),
         ],
      q(kks) => [
         q(3422),
         q(0),
         ],
      q(kkt) => [
         q(3423),
         q(0),
         ],
      q(kku) => [
         q(3424),
         q(0),
         ],
      q(kkv) => [
         q(3425),
         q(0),
         ],
      q(kkw) => [
         q(3426),
         q(0),
         ],
      q(kkx) => [
         q(3427),
         q(0),
         ],
      q(kky) => [
         q(3428),
         q(0),
         ],
      q(kkz) => [
         q(3429),
         q(0),
         ],
      q(kla) => [
         q(3430),
         q(0),
         ],
      q(klb) => [
         q(3431),
         q(0),
         ],
      q(klc) => [
         q(3432),
         q(0),
         ],
      q(kld) => [
         q(3433),
         q(0),
         ],
      q(kle) => [
         q(3434),
         q(0),
         ],
      q(klf) => [
         q(3435),
         q(0),
         ],
      q(klg) => [
         q(3436),
         q(0),
         ],
      q(klh) => [
         q(3437),
         q(0),
         ],
      q(kli) => [
         q(3438),
         q(0),
         ],
      q(klj) => [
         q(3439),
         q(0),
         ],
      q(klk) => [
         q(3440),
         q(0),
         ],
      q(kll) => [
         q(3441),
         q(0),
         ],
      q(klm) => [
         q(3442),
         q(0),
         ],
      q(kln) => [
         q(3443),
         q(0),
         ],
      q(klo) => [
         q(3444),
         q(0),
         ],
      q(klp) => [
         q(3445),
         q(0),
         ],
      q(klq) => [
         q(3446),
         q(0),
         ],
      q(klr) => [
         q(3447),
         q(0),
         ],
      q(kls) => [
         q(3448),
         q(0),
         ],
      q(klt) => [
         q(3449),
         q(0),
         ],
      q(klu) => [
         q(3450),
         q(0),
         ],
      q(klv) => [
         q(3451),
         q(0),
         ],
      q(klw) => [
         q(3452),
         q(0),
         ],
      q(klx) => [
         q(3453),
         q(0),
         ],
      q(kly) => [
         q(3454),
         q(0),
         ],
      q(klz) => [
         q(3455),
         q(0),
         ],
      q(kma) => [
         q(3456),
         q(0),
         ],
      q(kmb) => [
         q(0227),
         q(0),
         ],
      q(kmc) => [
         q(3457),
         q(0),
         ],
      q(kmd) => [
         q(3458),
         q(0),
         ],
      q(kme) => [
         q(3459),
         q(0),
         ],
      q(kmf) => [
         q(3460),
         q(0),
         ],
      q(kmg) => [
         q(3461),
         q(0),
         ],
      q(kmh) => [
         q(3462),
         q(0),
         ],
      q(kmi) => [
         q(3463),
         q(0),
         ],
      q(kmj) => [
         q(3464),
         q(0),
         ],
      q(kmk) => [
         q(3465),
         q(0),
         ],
      q(kml) => [
         q(3466),
         q(0),
         ],
      q(kmm) => [
         q(3467),
         q(0),
         ],
      q(kmn) => [
         q(3468),
         q(0),
         ],
      q(kmo) => [
         q(3469),
         q(0),
         ],
      q(kmp) => [
         q(3470),
         q(0),
         ],
      q(kmq) => [
         q(3471),
         q(0),
         ],
      q(kmr) => [
         q(3472),
         q(0),
         ],
      q(kms) => [
         q(3473),
         q(0),
         ],
      q(kmt) => [
         q(3474),
         q(0),
         ],
      q(kmu) => [
         q(3475),
         q(0),
         ],
      q(kmv) => [
         q(3476),
         q(0),
         ],
      q(kmw) => [
         q(3477),
         q(0),
         ],
      q(kmx) => [
         q(3478),
         q(0),
         ],
      q(kmy) => [
         q(3479),
         q(0),
         ],
      q(kmz) => [
         q(3480),
         q(0),
         ],
      q(kna) => [
         q(3481),
         q(0),
         ],
      q(knb) => [
         q(3482),
         q(0),
         ],
      q(knc) => [
         q(3483),
         q(0),
         ],
      q(knd) => [
         q(3484),
         q(0),
         ],
      q(kne) => [
         q(3485),
         q(0),
         ],
      q(knf) => [
         q(3486),
         q(0),
         ],
      q(kng) => [
         q(3487),
         q(0),
         ],
      q(kni) => [
         q(3488),
         q(0),
         ],
      q(knj) => [
         q(3489),
         q(0),
         ],
      q(knk) => [
         q(3490),
         q(0),
         ],
      q(knl) => [
         q(3491),
         q(0),
         ],
      q(knm) => [
         q(3492),
         q(0),
         ],
      q(knn) => [
         q(3493),
         q(0),
         ],
      q(kno) => [
         q(3494),
         q(0),
         ],
      q(knp) => [
         q(3495),
         q(0),
         ],
      q(knq) => [
         q(3496),
         q(0),
         ],
      q(knr) => [
         q(3497),
         q(0),
         ],
      q(kns) => [
         q(3498),
         q(0),
         ],
      q(knt) => [
         q(3499),
         q(0),
         ],
      q(knu) => [
         q(3500),
         q(0),
         ],
      q(knv) => [
         q(3501),
         q(0),
         ],
      q(knw) => [
         q(3502),
         q(0),
         ],
      q(knx) => [
         q(3503),
         q(0),
         ],
      q(kny) => [
         q(3504),
         q(0),
         ],
      q(knz) => [
         q(3505),
         q(0),
         ],
      q(koa) => [
         q(3506),
         q(0),
         ],
      q(koc) => [
         q(3507),
         q(0),
         ],
      q(kod) => [
         q(3508),
         q(0),
         ],
      q(koe) => [
         q(3509),
         q(0),
         ],
      q(kof) => [
         q(3510),
         q(0),
         ],
      q(kog) => [
         q(3511),
         q(0),
         ],
      q(koh) => [
         q(3512),
         q(0),
         ],
      q(koi) => [
         q(3513),
         q(0),
         ],
      q(koj) => [
         q(3514),
         q(0),
         ],
      q(kok) => [
         q(0228),
         q(1),
         ],
      q(kol) => [
         q(3515),
         q(0),
         ],
      q(kom) => [
         q(0229),
         q(0),
         ],
      q(kon) => [
         q(0230),
         q(0),
         ],
      q(koo) => [
         q(3516),
         q(0),
         ],
      q(kop) => [
         q(3517),
         q(0),
         ],
      q(koq) => [
         q(3518),
         q(0),
         ],
      q(kor) => [
         q(0231),
         q(0),
         ],
      q(kos) => [
         q(0232),
         q(0),
         ],
      q(kot) => [
         q(3519),
         q(0),
         ],
      q(kou) => [
         q(3520),
         q(0),
         ],
      q(kov) => [
         q(3521),
         q(0),
         ],
      q(kow) => [
         q(3522),
         q(0),
         ],
      q(kox) => [
         q(3523),
         q(0),
         ],
      q(koy) => [
         q(3524),
         q(0),
         ],
      q(koz) => [
         q(3525),
         q(0),
         ],
      q(kpa) => [
         q(3526),
         q(0),
         ],
      q(kpb) => [
         q(3527),
         q(0),
         ],
      q(kpc) => [
         q(3528),
         q(0),
         ],
      q(kpd) => [
         q(3529),
         q(0),
         ],
      q(kpe) => [
         q(0233),
         q(0),
         ],
      q(kpf) => [
         q(3530),
         q(0),
         ],
      q(kpg) => [
         q(3531),
         q(0),
         ],
      q(kph) => [
         q(3532),
         q(0),
         ],
      q(kpi) => [
         q(3533),
         q(0),
         ],
      q(kpj) => [
         q(3534),
         q(0),
         ],
      q(kpk) => [
         q(3535),
         q(0),
         ],
      q(kpl) => [
         q(3536),
         q(0),
         ],
      q(kpm) => [
         q(3537),
         q(0),
         ],
      q(kpn) => [
         q(3538),
         q(0),
         ],
      q(kpo) => [
         q(3539),
         q(0),
         ],
      q(kpq) => [
         q(3540),
         q(0),
         ],
      q(kpr) => [
         q(3541),
         q(0),
         ],
      q(kps) => [
         q(3542),
         q(0),
         ],
      q(kpt) => [
         q(3543),
         q(0),
         ],
      q(kpu) => [
         q(3544),
         q(0),
         ],
      q(kpv) => [
         q(3545),
         q(0),
         ],
      q(kpw) => [
         q(3546),
         q(0),
         ],
      q(kpx) => [
         q(3547),
         q(0),
         ],
      q(kpy) => [
         q(3548),
         q(0),
         ],
      q(kpz) => [
         q(3549),
         q(0),
         ],
      q(kqa) => [
         q(3550),
         q(0),
         ],
      q(kqb) => [
         q(3551),
         q(0),
         ],
      q(kqc) => [
         q(3552),
         q(0),
         ],
      q(kqd) => [
         q(3553),
         q(0),
         ],
      q(kqe) => [
         q(3554),
         q(0),
         ],
      q(kqf) => [
         q(3555),
         q(0),
         ],
      q(kqg) => [
         q(3556),
         q(0),
         ],
      q(kqh) => [
         q(3557),
         q(0),
         ],
      q(kqi) => [
         q(3558),
         q(0),
         ],
      q(kqj) => [
         q(3559),
         q(0),
         ],
      q(kqk) => [
         q(3560),
         q(0),
         ],
      q(kql) => [
         q(3561),
         q(0),
         ],
      q(kqm) => [
         q(3562),
         q(0),
         ],
      q(kqn) => [
         q(3563),
         q(0),
         ],
      q(kqo) => [
         q(3564),
         q(0),
         ],
      q(kqp) => [
         q(3565),
         q(0),
         ],
      q(kqq) => [
         q(3566),
         q(0),
         ],
      q(kqr) => [
         q(3567),
         q(0),
         ],
      q(kqs) => [
         q(3568),
         q(0),
         ],
      q(kqt) => [
         q(3569),
         q(0),
         ],
      q(kqu) => [
         q(3570),
         q(0),
         ],
      q(kqv) => [
         q(3571),
         q(0),
         ],
      q(kqw) => [
         q(3572),
         q(0),
         ],
      q(kqx) => [
         q(3573),
         q(0),
         ],
      q(kqy) => [
         q(3574),
         q(0),
         ],
      q(kqz) => [
         q(3575),
         q(0),
         ],
      q(kra) => [
         q(3576),
         q(0),
         ],
      q(krb) => [
         q(3577),
         q(0),
         ],
      q(krc) => [
         q(0234),
         q(0),
         ],
      q(krd) => [
         q(3578),
         q(0),
         ],
      q(kre) => [
         q(3579),
         q(0),
         ],
      q(krf) => [
         q(3580),
         q(0),
         ],
      q(krh) => [
         q(3581),
         q(0),
         ],
      q(kri) => [
         q(3582),
         q(0),
         ],
      q(krj) => [
         q(3583),
         q(0),
         ],
      q(krk) => [
         q(3584),
         q(0),
         ],
      q(krl) => [
         q(0235),
         q(0),
         ],
      q(krm) => [
         q(3585),
         q(0),
         ],
      q(krn) => [
         q(3586),
         q(0),
         ],
      q(kro) => [
         q(0236),
         q(0),
         ],
      q(krp) => [
         q(3587),
         q(0),
         ],
      q(krr) => [
         q(3588),
         q(0),
         ],
      q(krs) => [
         q(3589),
         q(0),
         ],
      q(krt) => [
         q(3590),
         q(0),
         ],
      q(kru) => [
         q(0237),
         q(0),
         ],
      q(krv) => [
         q(3591),
         q(0),
         ],
      q(krw) => [
         q(3592),
         q(0),
         ],
      q(krx) => [
         q(3593),
         q(0),
         ],
      q(kry) => [
         q(3594),
         q(0),
         ],
      q(krz) => [
         q(3595),
         q(0),
         ],
      q(ksa) => [
         q(3596),
         q(0),
         ],
      q(ksb) => [
         q(3597),
         q(0),
         ],
      q(ksc) => [
         q(3598),
         q(0),
         ],
      q(ksd) => [
         q(3599),
         q(0),
         ],
      q(kse) => [
         q(3600),
         q(0),
         ],
      q(ksf) => [
         q(3601),
         q(0),
         ],
      q(ksg) => [
         q(3602),
         q(0),
         ],
      q(ksh) => [
         q(3603),
         q(0),
         ],
      q(ksi) => [
         q(3604),
         q(0),
         ],
      q(ksj) => [
         q(3605),
         q(0),
         ],
      q(ksk) => [
         q(3606),
         q(0),
         ],
      q(ksl) => [
         q(3607),
         q(0),
         ],
      q(ksm) => [
         q(3608),
         q(0),
         ],
      q(ksn) => [
         q(3609),
         q(0),
         ],
      q(kso) => [
         q(3610),
         q(0),
         ],
      q(ksp) => [
         q(3611),
         q(0),
         ],
      q(ksq) => [
         q(3612),
         q(0),
         ],
      q(ksr) => [
         q(3613),
         q(0),
         ],
      q(kss) => [
         q(3614),
         q(0),
         ],
      q(kst) => [
         q(3615),
         q(0),
         ],
      q(ksu) => [
         q(3616),
         q(0),
         ],
      q(ksv) => [
         q(3617),
         q(0),
         ],
      q(ksw) => [
         q(3618),
         q(0),
         ],
      q(ksx) => [
         q(3619),
         q(0),
         ],
      q(ksy) => [
         q(3620),
         q(0),
         ],
      q(ksz) => [
         q(3621),
         q(0),
         ],
      q(kta) => [
         q(3622),
         q(0),
         ],
      q(ktb) => [
         q(3623),
         q(0),
         ],
      q(ktc) => [
         q(3624),
         q(0),
         ],
      q(ktd) => [
         q(3625),
         q(0),
         ],
      q(kte) => [
         q(3626),
         q(0),
         ],
      q(ktf) => [
         q(3627),
         q(0),
         ],
      q(ktg) => [
         q(3628),
         q(0),
         ],
      q(kth) => [
         q(3629),
         q(0),
         ],
      q(kti) => [
         q(3630),
         q(0),
         ],
      q(ktj) => [
         q(3631),
         q(0),
         ],
      q(ktk) => [
         q(3632),
         q(0),
         ],
      q(ktl) => [
         q(3633),
         q(0),
         ],
      q(ktm) => [
         q(3634),
         q(0),
         ],
      q(ktn) => [
         q(3635),
         q(0),
         ],
      q(kto) => [
         q(3636),
         q(0),
         ],
      q(ktp) => [
         q(3637),
         q(0),
         ],
      q(ktq) => [
         q(3638),
         q(0),
         ],
      q(ktr) => [
         q(3639),
         q(0),
         ],
      q(kts) => [
         q(3640),
         q(0),
         ],
      q(ktt) => [
         q(3641),
         q(0),
         ],
      q(ktu) => [
         q(3642),
         q(0),
         ],
      q(ktv) => [
         q(3643),
         q(0),
         ],
      q(ktw) => [
         q(3644),
         q(0),
         ],
      q(ktx) => [
         q(3645),
         q(0),
         ],
      q(kty) => [
         q(3646),
         q(0),
         ],
      q(ktz) => [
         q(3647),
         q(0),
         ],
      q(kua) => [
         q(0238),
         q(0),
         ],
      q(kub) => [
         q(3648),
         q(0),
         ],
      q(kuc) => [
         q(3649),
         q(0),
         ],
      q(kud) => [
         q(3650),
         q(0),
         ],
      q(kue) => [
         q(3651),
         q(0),
         ],
      q(kuf) => [
         q(3652),
         q(0),
         ],
      q(kug) => [
         q(3653),
         q(0),
         ],
      q(kuh) => [
         q(3654),
         q(0),
         ],
      q(kui) => [
         q(3655),
         q(0),
         ],
      q(kuj) => [
         q(3656),
         q(0),
         ],
      q(kuk) => [
         q(3657),
         q(0),
         ],
      q(kul) => [
         q(3658),
         q(0),
         ],
      q(kum) => [
         q(0239),
         q(0),
         ],
      q(kun) => [
         q(3659),
         q(0),
         ],
      q(kuo) => [
         q(3660),
         q(0),
         ],
      q(kup) => [
         q(3661),
         q(0),
         ],
      q(kuq) => [
         q(3322),
         q(0),
         ],
      q(kur) => [
         q(0240),
         q(0),
         ],
      q(kus) => [
         q(3662),
         q(0),
         ],
      q(kut) => [
         q(0241),
         q(0),
         ],
      q(kuu) => [
         q(3663),
         q(0),
         ],
      q(kuv) => [
         q(3664),
         q(0),
         ],
      q(kuw) => [
         q(3665),
         q(0),
         ],
      q(kux) => [
         q(3666),
         q(0),
         ],
      q(kuy) => [
         q(3667),
         q(0),
         ],
      q(kuz) => [
         q(3668),
         q(0),
         ],
      q(kva) => [
         q(3669),
         q(0),
         ],
      q(kvb) => [
         q(3670),
         q(0),
         ],
      q(kvc) => [
         q(3671),
         q(0),
         ],
      q(kvd) => [
         q(3672),
         q(0),
         ],
      q(kve) => [
         q(3673),
         q(0),
         ],
      q(kvf) => [
         q(3674),
         q(0),
         ],
      q(kvg) => [
         q(3675),
         q(0),
         ],
      q(kvh) => [
         q(3676),
         q(0),
         ],
      q(kvi) => [
         q(3677),
         q(0),
         ],
      q(kvj) => [
         q(3678),
         q(0),
         ],
      q(kvk) => [
         q(3679),
         q(0),
         ],
      q(kvl) => [
         q(3680),
         q(0),
         ],
      q(kvm) => [
         q(3681),
         q(0),
         ],
      q(kvn) => [
         q(3682),
         q(0),
         ],
      q(kvo) => [
         q(3683),
         q(0),
         ],
      q(kvp) => [
         q(3684),
         q(0),
         ],
      q(kvq) => [
         q(3685),
         q(0),
         ],
      q(kvr) => [
         q(3686),
         q(0),
         ],
      q(kvs) => [
         q(3687),
         q(0),
         ],
      q(kvt) => [
         q(3688),
         q(0),
         ],
      q(kvu) => [
         q(3689),
         q(0),
         ],
      q(kvv) => [
         q(3690),
         q(0),
         ],
      q(kvw) => [
         q(3691),
         q(0),
         ],
      q(kvx) => [
         q(3692),
         q(0),
         ],
      q(kvy) => [
         q(3693),
         q(0),
         ],
      q(kvz) => [
         q(3694),
         q(0),
         ],
      q(kwa) => [
         q(3695),
         q(0),
         ],
      q(kwb) => [
         q(3696),
         q(0),
         ],
      q(kwc) => [
         q(3697),
         q(0),
         ],
      q(kwd) => [
         q(3698),
         q(0),
         ],
      q(kwe) => [
         q(3699),
         q(0),
         ],
      q(kwf) => [
         q(3700),
         q(0),
         ],
      q(kwg) => [
         q(3701),
         q(0),
         ],
      q(kwh) => [
         q(3702),
         q(0),
         ],
      q(kwi) => [
         q(3703),
         q(0),
         ],
      q(kwj) => [
         q(3704),
         q(0),
         ],
      q(kwk) => [
         q(3705),
         q(0),
         ],
      q(kwl) => [
         q(3706),
         q(0),
         ],
      q(kwm) => [
         q(3707),
         q(0),
         ],
      q(kwn) => [
         q(3708),
         q(0),
         ],
      q(kwo) => [
         q(3709),
         q(0),
         ],
      q(kwp) => [
         q(3710),
         q(0),
         ],
      q(kwq) => [
         q(3711),
         q(0),
         ],
      q(kwr) => [
         q(3712),
         q(0),
         ],
      q(kws) => [
         q(3713),
         q(0),
         ],
      q(kwt) => [
         q(3714),
         q(0),
         ],
      q(kwu) => [
         q(3715),
         q(0),
         ],
      q(kwv) => [
         q(3716),
         q(0),
         ],
      q(kww) => [
         q(3717),
         q(0),
         ],
      q(kwx) => [
         q(3718),
         q(0),
         ],
      q(kwy) => [
         q(3719),
         q(0),
         ],
      q(kwz) => [
         q(3720),
         q(0),
         ],
      q(kxa) => [
         q(3721),
         q(0),
         ],
      q(kxb) => [
         q(3722),
         q(0),
         ],
      q(kxc) => [
         q(3723),
         q(0),
         ],
      q(kxd) => [
         q(3724),
         q(0),
         ],
      q(kxe) => [
         q(3725),
         q(0),
         ],
      q(kxf) => [
         q(3726),
         q(0),
         ],
      q(kxh) => [
         q(3727),
         q(0),
         ],
      q(kxi) => [
         q(3728),
         q(0),
         ],
      q(kxj) => [
         q(3729),
         q(0),
         ],
      q(kxk) => [
         q(3730),
         q(0),
         ],
      q(kxl) => [
         q(3731),
         q(0),
         ],
      q(kxm) => [
         q(3732),
         q(0),
         ],
      q(kxn) => [
         q(3733),
         q(0),
         ],
      q(kxo) => [
         q(3734),
         q(0),
         ],
      q(kxp) => [
         q(3735),
         q(0),
         ],
      q(kxq) => [
         q(3736),
         q(0),
         ],
      q(kxr) => [
         q(3737),
         q(0),
         ],
      q(kxs) => [
         q(3738),
         q(0),
         ],
      q(kxt) => [
         q(3739),
         q(0),
         ],
      q(kxu) => [
         q(3740),
         q(0),
         ],
      q(kxv) => [
         q(3741),
         q(0),
         ],
      q(kxw) => [
         q(3742),
         q(0),
         ],
      q(kxx) => [
         q(3743),
         q(0),
         ],
      q(kxy) => [
         q(3744),
         q(0),
         ],
      q(kxz) => [
         q(3745),
         q(0),
         ],
      q(kya) => [
         q(3746),
         q(0),
         ],
      q(kyb) => [
         q(3747),
         q(0),
         ],
      q(kyc) => [
         q(3748),
         q(0),
         ],
      q(kyd) => [
         q(3749),
         q(0),
         ],
      q(kye) => [
         q(3750),
         q(0),
         ],
      q(kyf) => [
         q(3751),
         q(0),
         ],
      q(kyg) => [
         q(3752),
         q(0),
         ],
      q(kyh) => [
         q(3753),
         q(0),
         ],
      q(kyi) => [
         q(3754),
         q(0),
         ],
      q(kyj) => [
         q(3755),
         q(0),
         ],
      q(kyk) => [
         q(3756),
         q(0),
         ],
      q(kyl) => [
         q(3757),
         q(0),
         ],
      q(kym) => [
         q(3758),
         q(0),
         ],
      q(kyn) => [
         q(3759),
         q(0),
         ],
      q(kyo) => [
         q(3760),
         q(0),
         ],
      q(kyp) => [
         q(3761),
         q(0),
         ],
      q(kyq) => [
         q(3762),
         q(0),
         ],
      q(kyr) => [
         q(3763),
         q(0),
         ],
      q(kys) => [
         q(3764),
         q(0),
         ],
      q(kyt) => [
         q(3765),
         q(0),
         ],
      q(kyu) => [
         q(3766),
         q(0),
         ],
      q(kyv) => [
         q(3767),
         q(0),
         ],
      q(kyw) => [
         q(3768),
         q(0),
         ],
      q(kyx) => [
         q(3769),
         q(0),
         ],
      q(kyy) => [
         q(3770),
         q(0),
         ],
      q(kyz) => [
         q(3771),
         q(0),
         ],
      q(kza) => [
         q(3772),
         q(0),
         ],
      q(kzb) => [
         q(3773),
         q(0),
         ],
      q(kzc) => [
         q(3774),
         q(0),
         ],
      q(kzd) => [
         q(3775),
         q(0),
         ],
      q(kze) => [
         q(3776),
         q(0),
         ],
      q(kzf) => [
         q(3777),
         q(0),
         ],
      q(kzg) => [
         q(3778),
         q(0),
         ],
      q(kzi) => [
         q(3779),
         q(0),
         ],
      q(kzj) => [
         q(3780),
         q(0),
         ],
      q(kzk) => [
         q(3781),
         q(0),
         ],
      q(kzl) => [
         q(3782),
         q(0),
         ],
      q(kzm) => [
         q(3783),
         q(0),
         ],
      q(kzn) => [
         q(3784),
         q(0),
         ],
      q(kzo) => [
         q(3785),
         q(0),
         ],
      q(kzp) => [
         q(3786),
         q(0),
         ],
      q(kzq) => [
         q(3787),
         q(0),
         ],
      q(kzr) => [
         q(3788),
         q(0),
         ],
      q(kzs) => [
         q(3789),
         q(0),
         ],
      q(kzt) => [
         q(3790),
         q(0),
         ],
      q(kzu) => [
         q(3791),
         q(0),
         ],
      q(kzv) => [
         q(3792),
         q(0),
         ],
      q(kzw) => [
         q(3793),
         q(0),
         ],
      q(kzx) => [
         q(3794),
         q(0),
         ],
      q(kzy) => [
         q(3795),
         q(0),
         ],
      q(kzz) => [
         q(3796),
         q(0),
         ],
      q(laa) => [
         q(3797),
         q(0),
         ],
      q(lab) => [
         q(3798),
         q(0),
         ],
      q(lac) => [
         q(3799),
         q(0),
         ],
      q(lad) => [
         q(0242),
         q(0),
         ],
      q(lae) => [
         q(3800),
         q(0),
         ],
      q(laf) => [
         q(3801),
         q(0),
         ],
      q(lag) => [
         q(3802),
         q(0),
         ],
      q(lah) => [
         q(0243),
         q(0),
         ],
      q(lai) => [
         q(3803),
         q(0),
         ],
      q(laj) => [
         q(3804),
         q(0),
         ],
      q(lak) => [
         q(3805),
         q(0),
         ],
      q(lal) => [
         q(3806),
         q(0),
         ],
      q(lam) => [
         q(0244),
         q(0),
         ],
      q(lan) => [
         q(3807),
         q(0),
         ],
      q(lao) => [
         q(0245),
         q(0),
         ],
      q(lap) => [
         q(3808),
         q(0),
         ],
      q(laq) => [
         q(3809),
         q(0),
         ],
      q(lar) => [
         q(3810),
         q(0),
         ],
      q(las) => [
         q(3811),
         q(0),
         ],
      q(lat) => [
         q(0246),
         q(0),
         ],
      q(lau) => [
         q(3812),
         q(0),
         ],
      q(lav) => [
         q(0247),
         q(0),
         ],
      q(law) => [
         q(3813),
         q(0),
         ],
      q(lax) => [
         q(3814),
         q(0),
         ],
      q(lay) => [
         q(3815),
         q(0),
         ],
      q(laz) => [
         q(3816),
         q(0),
         ],
      q(lba) => [
         q(3817),
         q(0),
         ],
      q(lbb) => [
         q(3818),
         q(0),
         ],
      q(lbc) => [
         q(3819),
         q(0),
         ],
      q(lbe) => [
         q(3820),
         q(0),
         ],
      q(lbf) => [
         q(3821),
         q(0),
         ],
      q(lbg) => [
         q(3822),
         q(0),
         ],
      q(lbi) => [
         q(3823),
         q(0),
         ],
      q(lbj) => [
         q(3824),
         q(0),
         ],
      q(lbk) => [
         q(3825),
         q(0),
         ],
      q(lbl) => [
         q(3826),
         q(0),
         ],
      q(lbm) => [
         q(3827),
         q(0),
         ],
      q(lbn) => [
         q(3828),
         q(0),
         ],
      q(lbo) => [
         q(3829),
         q(0),
         ],
      q(lbq) => [
         q(3830),
         q(0),
         ],
      q(lbr) => [
         q(3831),
         q(0),
         ],
      q(lbs) => [
         q(3832),
         q(0),
         ],
      q(lbt) => [
         q(3833),
         q(0),
         ],
      q(lbu) => [
         q(3834),
         q(0),
         ],
      q(lbv) => [
         q(3835),
         q(0),
         ],
      q(lbw) => [
         q(3836),
         q(0),
         ],
      q(lbx) => [
         q(3837),
         q(0),
         ],
      q(lby) => [
         q(3838),
         q(0),
         ],
      q(lbz) => [
         q(3839),
         q(0),
         ],
      q(lcc) => [
         q(3840),
         q(0),
         ],
      q(lcd) => [
         q(3841),
         q(0),
         ],
      q(lce) => [
         q(3842),
         q(0),
         ],
      q(lcf) => [
         q(3843),
         q(0),
         ],
      q(lch) => [
         q(3844),
         q(0),
         ],
      q(lcl) => [
         q(3845),
         q(0),
         ],
      q(lcm) => [
         q(3846),
         q(0),
         ],
      q(lcp) => [
         q(3847),
         q(0),
         ],
      q(lcq) => [
         q(3848),
         q(0),
         ],
      q(lcs) => [
         q(3849),
         q(0),
         ],
      q(lda) => [
         q(3850),
         q(0),
         ],
      q(ldb) => [
         q(3851),
         q(0),
         ],
      q(ldd) => [
         q(3852),
         q(0),
         ],
      q(ldg) => [
         q(3853),
         q(0),
         ],
      q(ldh) => [
         q(3854),
         q(0),
         ],
      q(ldi) => [
         q(3855),
         q(0),
         ],
      q(ldj) => [
         q(3856),
         q(0),
         ],
      q(ldk) => [
         q(3857),
         q(0),
         ],
      q(ldl) => [
         q(3858),
         q(0),
         ],
      q(ldm) => [
         q(3859),
         q(0),
         ],
      q(ldn) => [
         q(3860),
         q(0),
         ],
      q(ldo) => [
         q(3861),
         q(0),
         ],
      q(ldp) => [
         q(3862),
         q(0),
         ],
      q(ldq) => [
         q(3863),
         q(0),
         ],
      q(lea) => [
         q(3864),
         q(0),
         ],
      q(leb) => [
         q(3865),
         q(0),
         ],
      q(lec) => [
         q(3866),
         q(0),
         ],
      q(led) => [
         q(3867),
         q(0),
         ],
      q(lee) => [
         q(3868),
         q(0),
         ],
      q(lef) => [
         q(3869),
         q(0),
         ],
      q(leg) => [
         q(3870),
         q(0),
         ],
      q(leh) => [
         q(3871),
         q(0),
         ],
      q(lei) => [
         q(3872),
         q(0),
         ],
      q(lej) => [
         q(3873),
         q(0),
         ],
      q(lek) => [
         q(3874),
         q(0),
         ],
      q(lel) => [
         q(3875),
         q(0),
         ],
      q(lem) => [
         q(3876),
         q(0),
         ],
      q(len) => [
         q(3877),
         q(0),
         ],
      q(leo) => [
         q(3878),
         q(0),
         ],
      q(lep) => [
         q(3879),
         q(0),
         ],
      q(leq) => [
         q(3880),
         q(0),
         ],
      q(ler) => [
         q(3881),
         q(0),
         ],
      q(les) => [
         q(3882),
         q(0),
         ],
      q(let) => [
         q(3883),
         q(0),
         ],
      q(leu) => [
         q(3884),
         q(0),
         ],
      q(lev) => [
         q(3885),
         q(0),
         ],
      q(lew) => [
         q(3886),
         q(0),
         ],
      q(lex) => [
         q(3887),
         q(0),
         ],
      q(ley) => [
         q(3888),
         q(0),
         ],
      q(lez) => [
         q(0248),
         q(0),
         ],
      q(lfa) => [
         q(3889),
         q(0),
         ],
      q(lfn) => [
         q(3890),
         q(0),
         ],
      q(lga) => [
         q(3891),
         q(0),
         ],
      q(lgb) => [
         q(3892),
         q(0),
         ],
      q(lgg) => [
         q(3893),
         q(0),
         ],
      q(lgh) => [
         q(3894),
         q(0),
         ],
      q(lgi) => [
         q(3895),
         q(0),
         ],
      q(lgk) => [
         q(3896),
         q(0),
         ],
      q(lgl) => [
         q(3897),
         q(0),
         ],
      q(lgm) => [
         q(3898),
         q(0),
         ],
      q(lgn) => [
         q(3899),
         q(0),
         ],
      q(lgq) => [
         q(3900),
         q(0),
         ],
      q(lgr) => [
         q(3901),
         q(0),
         ],
      q(lgt) => [
         q(3902),
         q(0),
         ],
      q(lgu) => [
         q(3903),
         q(0),
         ],
      q(lgz) => [
         q(3904),
         q(0),
         ],
      q(lha) => [
         q(3905),
         q(0),
         ],
      q(lhh) => [
         q(3906),
         q(0),
         ],
      q(lhi) => [
         q(3907),
         q(0),
         ],
      q(lhl) => [
         q(3908),
         q(0),
         ],
      q(lhm) => [
         q(3909),
         q(0),
         ],
      q(lhn) => [
         q(3910),
         q(0),
         ],
      q(lhp) => [
         q(3911),
         q(0),
         ],
      q(lhs) => [
         q(3912),
         q(0),
         ],
      q(lht) => [
         q(3913),
         q(0),
         ],
      q(lhu) => [
         q(3914),
         q(0),
         ],
      q(lia) => [
         q(3915),
         q(0),
         ],
      q(lib) => [
         q(3916),
         q(0),
         ],
      q(lic) => [
         q(3917),
         q(0),
         ],
      q(lid) => [
         q(3918),
         q(0),
         ],
      q(lie) => [
         q(3919),
         q(0),
         ],
      q(lif) => [
         q(3920),
         q(0),
         ],
      q(lig) => [
         q(3921),
         q(0),
         ],
      q(lih) => [
         q(3922),
         q(0),
         ],
      q(lii) => [
         q(3923),
         q(0),
         ],
      q(lij) => [
         q(3924),
         q(0),
         ],
      q(lik) => [
         q(3925),
         q(0),
         ],
      q(lil) => [
         q(3926),
         q(0),
         ],
      q(lim) => [
         q(0249),
         q(0),
         ],
      q(lin) => [
         q(0250),
         q(0),
         ],
      q(lio) => [
         q(3927),
         q(0),
         ],
      q(lip) => [
         q(3928),
         q(0),
         ],
      q(liq) => [
         q(3929),
         q(0),
         ],
      q(lir) => [
         q(3930),
         q(0),
         ],
      q(lis) => [
         q(3931),
         q(0),
         ],
      q(lit) => [
         q(0251),
         q(0),
         ],
      q(liu) => [
         q(3932),
         q(0),
         ],
      q(liv) => [
         q(3933),
         q(0),
         ],
      q(liw) => [
         q(3934),
         q(0),
         ],
      q(lix) => [
         q(3935),
         q(0),
         ],
      q(liy) => [
         q(3936),
         q(0),
         ],
      q(liz) => [
         q(3937),
         q(0),
         ],
      q(lja) => [
         q(3938),
         q(0),
         ],
      q(lje) => [
         q(3939),
         q(0),
         ],
      q(lji) => [
         q(3940),
         q(0),
         ],
      q(ljl) => [
         q(3941),
         q(0),
         ],
      q(ljp) => [
         q(3942),
         q(0),
         ],
      q(ljw) => [
         q(3943),
         q(0),
         ],
      q(ljx) => [
         q(3944),
         q(0),
         ],
      q(lka) => [
         q(3945),
         q(0),
         ],
      q(lkb) => [
         q(3946),
         q(0),
         ],
      q(lkc) => [
         q(3947),
         q(0),
         ],
      q(lkd) => [
         q(3948),
         q(0),
         ],
      q(lke) => [
         q(3949),
         q(0),
         ],
      q(lkh) => [
         q(3950),
         q(0),
         ],
      q(lki) => [
         q(3951),
         q(0),
         ],
      q(lkj) => [
         q(3952),
         q(0),
         ],
      q(lkl) => [
         q(3953),
         q(0),
         ],
      q(lkm) => [
         q(3954),
         q(0),
         ],
      q(lkn) => [
         q(3955),
         q(0),
         ],
      q(lko) => [
         q(3956),
         q(0),
         ],
      q(lkr) => [
         q(3957),
         q(0),
         ],
      q(lks) => [
         q(3958),
         q(0),
         ],
      q(lkt) => [
         q(3959),
         q(0),
         ],
      q(lku) => [
         q(3960),
         q(0),
         ],
      q(lky) => [
         q(3961),
         q(0),
         ],
      q(lla) => [
         q(3962),
         q(0),
         ],
      q(llb) => [
         q(3963),
         q(0),
         ],
      q(llc) => [
         q(3964),
         q(0),
         ],
      q(lld) => [
         q(3965),
         q(0),
         ],
      q(lle) => [
         q(3966),
         q(0),
         ],
      q(llf) => [
         q(3967),
         q(0),
         ],
      q(llg) => [
         q(3968),
         q(0),
         ],
      q(llh) => [
         q(3969),
         q(0),
         ],
      q(lli) => [
         q(3970),
         q(0),
         ],
      q(llj) => [
         q(3971),
         q(0),
         ],
      q(llk) => [
         q(3972),
         q(0),
         ],
      q(lll) => [
         q(3973),
         q(0),
         ],
      q(llm) => [
         q(3974),
         q(0),
         ],
      q(lln) => [
         q(3975),
         q(0),
         ],
      q(llo) => [
         q(3976),
         q(0),
         ],
      q(llp) => [
         q(3977),
         q(0),
         ],
      q(llq) => [
         q(3978),
         q(0),
         ],
      q(lls) => [
         q(3979),
         q(0),
         ],
      q(llu) => [
         q(3980),
         q(0),
         ],
      q(llx) => [
         q(3981),
         q(0),
         ],
      q(lma) => [
         q(3982),
         q(0),
         ],
      q(lmb) => [
         q(3983),
         q(0),
         ],
      q(lmc) => [
         q(3984),
         q(0),
         ],
      q(lmd) => [
         q(3985),
         q(0),
         ],
      q(lme) => [
         q(3986),
         q(0),
         ],
      q(lmf) => [
         q(3987),
         q(0),
         ],
      q(lmg) => [
         q(3988),
         q(0),
         ],
      q(lmh) => [
         q(3989),
         q(0),
         ],
      q(lmi) => [
         q(3990),
         q(0),
         ],
      q(lmj) => [
         q(3991),
         q(0),
         ],
      q(lmk) => [
         q(3992),
         q(0),
         ],
      q(lml) => [
         q(3993),
         q(0),
         ],
      q(lmm) => [
         q(3994),
         q(0),
         ],
      q(lmn) => [
         q(3995),
         q(0),
         ],
      q(lmo) => [
         q(3996),
         q(0),
         ],
      q(lmp) => [
         q(3997),
         q(0),
         ],
      q(lmq) => [
         q(3998),
         q(0),
         ],
      q(lmr) => [
         q(3999),
         q(0),
         ],
      q(lmu) => [
         q(4000),
         q(0),
         ],
      q(lmv) => [
         q(4001),
         q(0),
         ],
      q(lmw) => [
         q(4002),
         q(0),
         ],
      q(lmx) => [
         q(4003),
         q(0),
         ],
      q(lmy) => [
         q(4004),
         q(0),
         ],
      q(lmz) => [
         q(4005),
         q(0),
         ],
      q(lna) => [
         q(4006),
         q(0),
         ],
      q(lnb) => [
         q(4007),
         q(0),
         ],
      q(lnd) => [
         q(4008),
         q(0),
         ],
      q(lng) => [
         q(4009),
         q(0),
         ],
      q(lnh) => [
         q(4010),
         q(0),
         ],
      q(lni) => [
         q(4011),
         q(0),
         ],
      q(lnj) => [
         q(4012),
         q(0),
         ],
      q(lnl) => [
         q(4013),
         q(0),
         ],
      q(lnm) => [
         q(4014),
         q(0),
         ],
      q(lnn) => [
         q(4015),
         q(0),
         ],
      q(lno) => [
         q(4016),
         q(0),
         ],
      q(lns) => [
         q(4017),
         q(0),
         ],
      q(lnu) => [
         q(4018),
         q(0),
         ],
      q(lnw) => [
         q(4019),
         q(0),
         ],
      q(lnz) => [
         q(4020),
         q(0),
         ],
      q(loa) => [
         q(4021),
         q(0),
         ],
      q(lob) => [
         q(4022),
         q(0),
         ],
      q(loc) => [
         q(4023),
         q(0),
         ],
      q(loe) => [
         q(4024),
         q(0),
         ],
      q(lof) => [
         q(4025),
         q(0),
         ],
      q(log) => [
         q(4026),
         q(0),
         ],
      q(loh) => [
         q(4027),
         q(0),
         ],
      q(loi) => [
         q(4028),
         q(0),
         ],
      q(loj) => [
         q(4029),
         q(0),
         ],
      q(lok) => [
         q(4030),
         q(0),
         ],
      q(lol) => [
         q(0252),
         q(0),
         ],
      q(lom) => [
         q(4031),
         q(0),
         ],
      q(lon) => [
         q(4032),
         q(0),
         ],
      q(loo) => [
         q(4033),
         q(0),
         ],
      q(lop) => [
         q(4034),
         q(0),
         ],
      q(loq) => [
         q(4035),
         q(0),
         ],
      q(lor) => [
         q(4036),
         q(0),
         ],
      q(los) => [
         q(4037),
         q(0),
         ],
      q(lot) => [
         q(4038),
         q(0),
         ],
      q(lou) => [
         q(4039),
         q(0),
         ],
      q(lov) => [
         q(4040),
         q(0),
         ],
      q(low) => [
         q(4041),
         q(0),
         ],
      q(lox) => [
         q(4042),
         q(0),
         ],
      q(loy) => [
         q(4043),
         q(0),
         ],
      q(loz) => [
         q(0253),
         q(0),
         ],
      q(lpa) => [
         q(4044),
         q(0),
         ],
      q(lpe) => [
         q(4045),
         q(0),
         ],
      q(lpn) => [
         q(4046),
         q(0),
         ],
      q(lpo) => [
         q(4047),
         q(0),
         ],
      q(lpx) => [
         q(4048),
         q(0),
         ],
      q(lra) => [
         q(4049),
         q(0),
         ],
      q(lrc) => [
         q(4050),
         q(0),
         ],
      q(lre) => [
         q(4051),
         q(0),
         ],
      q(lrg) => [
         q(4052),
         q(0),
         ],
      q(lri) => [
         q(4053),
         q(0),
         ],
      q(lrk) => [
         q(4054),
         q(0),
         ],
      q(lrl) => [
         q(4055),
         q(0),
         ],
      q(lrm) => [
         q(4056),
         q(0),
         ],
      q(lrn) => [
         q(4057),
         q(0),
         ],
      q(lro) => [
         q(4058),
         q(0),
         ],
      q(lrr) => [
         q(4059),
         q(0),
         ],
      q(lrt) => [
         q(4060),
         q(0),
         ],
      q(lrv) => [
         q(4061),
         q(0),
         ],
      q(lrz) => [
         q(4062),
         q(0),
         ],
      q(lsa) => [
         q(4063),
         q(0),
         ],
      q(lsd) => [
         q(4064),
         q(0),
         ],
      q(lse) => [
         q(4065),
         q(0),
         ],
      q(lsg) => [
         q(4066),
         q(0),
         ],
      q(lsh) => [
         q(4067),
         q(0),
         ],
      q(lsi) => [
         q(4068),
         q(0),
         ],
      q(lsl) => [
         q(4069),
         q(0),
         ],
      q(lsm) => [
         q(4070),
         q(0),
         ],
      q(lso) => [
         q(4071),
         q(0),
         ],
      q(lsp) => [
         q(4072),
         q(0),
         ],
      q(lsr) => [
         q(4073),
         q(0),
         ],
      q(lss) => [
         q(4074),
         q(0),
         ],
      q(lst) => [
         q(4075),
         q(0),
         ],
      q(lsy) => [
         q(4076),
         q(0),
         ],
      q(ltc) => [
         q(4077),
         q(0),
         ],
      q(ltg) => [
         q(4078),
         q(0),
         ],
      q(lti) => [
         q(4079),
         q(0),
         ],
      q(ltn) => [
         q(4080),
         q(0),
         ],
      q(lto) => [
         q(4081),
         q(0),
         ],
      q(lts) => [
         q(4082),
         q(0),
         ],
      q(ltu) => [
         q(4083),
         q(0),
         ],
      q(ltz) => [
         q(0254),
         q(0),
         ],
      q(lua) => [
         q(0255),
         q(0),
         ],
      q(lub) => [
         q(0256),
         q(0),
         ],
      q(luc) => [
         q(4084),
         q(0),
         ],
      q(lud) => [
         q(4085),
         q(0),
         ],
      q(lue) => [
         q(4086),
         q(0),
         ],
      q(luf) => [
         q(4087),
         q(0),
         ],
      q(lug) => [
         q(0257),
         q(0),
         ],
      q(lui) => [
         q(0258),
         q(0),
         ],
      q(luj) => [
         q(4088),
         q(0),
         ],
      q(luk) => [
         q(4089),
         q(0),
         ],
      q(lul) => [
         q(4090),
         q(0),
         ],
      q(lum) => [
         q(4091),
         q(0),
         ],
      q(lun) => [
         q(0259),
         q(0),
         ],
      q(luo) => [
         q(0260),
         q(0),
         ],
      q(lup) => [
         q(4092),
         q(0),
         ],
      q(luq) => [
         q(4093),
         q(0),
         ],
      q(lur) => [
         q(4094),
         q(0),
         ],
      q(lus) => [
         q(0261),
         q(0),
         ],
      q(lut) => [
         q(4095),
         q(0),
         ],
      q(luu) => [
         q(4096),
         q(0),
         ],
      q(luv) => [
         q(4097),
         q(0),
         ],
      q(luw) => [
         q(4098),
         q(0),
         ],
      q(luy) => [
         q(4099),
         q(0),
         ],
      q(luz) => [
         q(4100),
         q(0),
         ],
      q(lva) => [
         q(4101),
         q(0),
         ],
      q(lvk) => [
         q(4102),
         q(0),
         ],
      q(lvs) => [
         q(4103),
         q(0),
         ],
      q(lvu) => [
         q(4104),
         q(0),
         ],
      q(lwa) => [
         q(4105),
         q(0),
         ],
      q(lwe) => [
         q(4106),
         q(0),
         ],
      q(lwg) => [
         q(4107),
         q(0),
         ],
      q(lwh) => [
         q(4108),
         q(0),
         ],
      q(lwl) => [
         q(4109),
         q(0),
         ],
      q(lwm) => [
         q(4110),
         q(0),
         ],
      q(lwo) => [
         q(4111),
         q(0),
         ],
      q(lwt) => [
         q(4112),
         q(0),
         ],
      q(lwu) => [
         q(4113),
         q(0),
         ],
      q(lww) => [
         q(4114),
         q(0),
         ],
      q(lya) => [
         q(4115),
         q(0),
         ],
      q(lyg) => [
         q(4116),
         q(0),
         ],
      q(lyn) => [
         q(4117),
         q(0),
         ],
      q(lzh) => [
         q(4118),
         q(0),
         ],
      q(lzl) => [
         q(4119),
         q(0),
         ],
      q(lzn) => [
         q(4120),
         q(0),
         ],
      q(lzz) => [
         q(4121),
         q(0),
         ],
      q(maa) => [
         q(4122),
         q(0),
         ],
      q(mab) => [
         q(4123),
         q(0),
         ],
      q(mac) => [
         q(0262),
         q(0),
         ],
      q(mad) => [
         q(0263),
         q(0),
         ],
      q(mae) => [
         q(4124),
         q(0),
         ],
      q(maf) => [
         q(4125),
         q(0),
         ],
      q(mag) => [
         q(0264),
         q(0),
         ],
      q(mah) => [
         q(0265),
         q(0),
         ],
      q(mai) => [
         q(0266),
         q(0),
         ],
      q(maj) => [
         q(4126),
         q(0),
         ],
      q(mak) => [
         q(0267),
         q(0),
         ],
      q(mal) => [
         q(0268),
         q(0),
         ],
      q(mam) => [
         q(4127),
         q(0),
         ],
      q(man) => [
         q(0269),
         q(0),
         ],
      q(mao) => [
         q(0270),
         q(0),
         ],
      q(map) => [
         q(0271),
         q(0),
         ],
      q(maq) => [
         q(4128),
         q(0),
         ],
      q(mar) => [
         q(0272),
         q(0),
         ],
      q(mas) => [
         q(0273),
         q(0),
         ],
      q(mat) => [
         q(4129),
         q(0),
         ],
      q(mau) => [
         q(4130),
         q(0),
         ],
      q(mav) => [
         q(4131),
         q(0),
         ],
      q(maw) => [
         q(4132),
         q(0),
         ],
      q(max) => [
         q(4133),
         q(0),
         ],
      q(may) => [
         q(0274),
         q(0),
         ],
      q(maz) => [
         q(4134),
         q(0),
         ],
      q(mba) => [
         q(4135),
         q(0),
         ],
      q(mbb) => [
         q(4136),
         q(0),
         ],
      q(mbc) => [
         q(4137),
         q(0),
         ],
      q(mbd) => [
         q(4138),
         q(0),
         ],
      q(mbe) => [
         q(4139),
         q(0),
         ],
      q(mbf) => [
         q(4140),
         q(0),
         ],
      q(mbh) => [
         q(4141),
         q(0),
         ],
      q(mbi) => [
         q(4142),
         q(0),
         ],
      q(mbj) => [
         q(4143),
         q(0),
         ],
      q(mbk) => [
         q(4144),
         q(0),
         ],
      q(mbl) => [
         q(4145),
         q(0),
         ],
      q(mbm) => [
         q(4146),
         q(0),
         ],
      q(mbn) => [
         q(4147),
         q(0),
         ],
      q(mbo) => [
         q(4148),
         q(0),
         ],
      q(mbp) => [
         q(4149),
         q(0),
         ],
      q(mbq) => [
         q(4150),
         q(0),
         ],
      q(mbr) => [
         q(4151),
         q(0),
         ],
      q(mbs) => [
         q(4152),
         q(0),
         ],
      q(mbt) => [
         q(4153),
         q(0),
         ],
      q(mbu) => [
         q(4154),
         q(0),
         ],
      q(mbv) => [
         q(4155),
         q(0),
         ],
      q(mbw) => [
         q(4156),
         q(0),
         ],
      q(mbx) => [
         q(4157),
         q(0),
         ],
      q(mby) => [
         q(4158),
         q(0),
         ],
      q(mbz) => [
         q(4159),
         q(0),
         ],
      q(mca) => [
         q(4160),
         q(0),
         ],
      q(mcb) => [
         q(4161),
         q(0),
         ],
      q(mcc) => [
         q(4162),
         q(0),
         ],
      q(mcd) => [
         q(4163),
         q(0),
         ],
      q(mce) => [
         q(4164),
         q(0),
         ],
      q(mcf) => [
         q(4165),
         q(0),
         ],
      q(mcg) => [
         q(4166),
         q(0),
         ],
      q(mch) => [
         q(4167),
         q(0),
         ],
      q(mci) => [
         q(4168),
         q(0),
         ],
      q(mcj) => [
         q(4169),
         q(0),
         ],
      q(mck) => [
         q(4170),
         q(0),
         ],
      q(mcl) => [
         q(4171),
         q(0),
         ],
      q(mcm) => [
         q(4172),
         q(0),
         ],
      q(mcn) => [
         q(4173),
         q(0),
         ],
      q(mco) => [
         q(4174),
         q(0),
         ],
      q(mcp) => [
         q(4175),
         q(0),
         ],
      q(mcq) => [
         q(4176),
         q(0),
         ],
      q(mcr) => [
         q(4177),
         q(0),
         ],
      q(mcs) => [
         q(4178),
         q(0),
         ],
      q(mct) => [
         q(4179),
         q(0),
         ],
      q(mcu) => [
         q(4180),
         q(0),
         ],
      q(mcv) => [
         q(4181),
         q(0),
         ],
      q(mcw) => [
         q(4182),
         q(0),
         ],
      q(mcx) => [
         q(4183),
         q(0),
         ],
      q(mcy) => [
         q(4184),
         q(0),
         ],
      q(mcz) => [
         q(4185),
         q(0),
         ],
      q(mda) => [
         q(4186),
         q(0),
         ],
      q(mdb) => [
         q(4187),
         q(0),
         ],
      q(mdc) => [
         q(4188),
         q(0),
         ],
      q(mdd) => [
         q(4189),
         q(0),
         ],
      q(mde) => [
         q(4190),
         q(0),
         ],
      q(mdf) => [
         q(0275),
         q(0),
         ],
      q(mdg) => [
         q(4191),
         q(0),
         ],
      q(mdh) => [
         q(4192),
         q(0),
         ],
      q(mdi) => [
         q(4193),
         q(0),
         ],
      q(mdj) => [
         q(4194),
         q(0),
         ],
      q(mdk) => [
         q(4195),
         q(0),
         ],
      q(mdl) => [
         q(4196),
         q(0),
         ],
      q(mdm) => [
         q(4197),
         q(0),
         ],
      q(mdn) => [
         q(4198),
         q(0),
         ],
      q(mdp) => [
         q(4199),
         q(0),
         ],
      q(mdq) => [
         q(4200),
         q(0),
         ],
      q(mdr) => [
         q(0276),
         q(0),
         ],
      q(mds) => [
         q(4201),
         q(0),
         ],
      q(mdt) => [
         q(4202),
         q(0),
         ],
      q(mdu) => [
         q(4203),
         q(0),
         ],
      q(mdv) => [
         q(4204),
         q(0),
         ],
      q(mdw) => [
         q(4205),
         q(0),
         ],
      q(mdx) => [
         q(4206),
         q(0),
         ],
      q(mdy) => [
         q(4207),
         q(0),
         ],
      q(mdz) => [
         q(4208),
         q(0),
         ],
      q(mea) => [
         q(4209),
         q(0),
         ],
      q(meb) => [
         q(4210),
         q(0),
         ],
      q(mec) => [
         q(4211),
         q(0),
         ],
      q(med) => [
         q(4212),
         q(0),
         ],
      q(mee) => [
         q(4213),
         q(0),
         ],
      q(mef) => [
         q(4214),
         q(0),
         ],
      q(meh) => [
         q(4215),
         q(0),
         ],
      q(mei) => [
         q(4216),
         q(0),
         ],
      q(mej) => [
         q(4217),
         q(0),
         ],
      q(mek) => [
         q(4218),
         q(0),
         ],
      q(mel) => [
         q(4219),
         q(0),
         ],
      q(mem) => [
         q(4220),
         q(0),
         ],
      q(men) => [
         q(0277),
         q(1),
         ],
      q(meo) => [
         q(4221),
         q(0),
         ],
      q(mep) => [
         q(4222),
         q(0),
         ],
      q(meq) => [
         q(4223),
         q(0),
         ],
      q(mer) => [
         q(4224),
         q(0),
         ],
      q(mes) => [
         q(4225),
         q(0),
         ],
      q(met) => [
         q(4226),
         q(0),
         ],
      q(meu) => [
         q(4227),
         q(0),
         ],
      q(mev) => [
         q(4228),
         q(0),
         ],
      q(mew) => [
         q(4229),
         q(0),
         ],
      q(mey) => [
         q(4230),
         q(0),
         ],
      q(mez) => [
         q(4231),
         q(0),
         ],
      q(mfa) => [
         q(4232),
         q(0),
         ],
      q(mfb) => [
         q(4233),
         q(0),
         ],
      q(mfc) => [
         q(4234),
         q(0),
         ],
      q(mfd) => [
         q(4235),
         q(0),
         ],
      q(mfe) => [
         q(4236),
         q(0),
         ],
      q(mff) => [
         q(4237),
         q(0),
         ],
      q(mfg) => [
         q(4238),
         q(0),
         ],
      q(mfh) => [
         q(4239),
         q(0),
         ],
      q(mfi) => [
         q(4240),
         q(0),
         ],
      q(mfj) => [
         q(4241),
         q(0),
         ],
      q(mfk) => [
         q(4242),
         q(0),
         ],
      q(mfl) => [
         q(4243),
         q(0),
         ],
      q(mfm) => [
         q(4244),
         q(0),
         ],
      q(mfn) => [
         q(4245),
         q(0),
         ],
      q(mfo) => [
         q(4246),
         q(0),
         ],
      q(mfp) => [
         q(4247),
         q(0),
         ],
      q(mfq) => [
         q(4248),
         q(0),
         ],
      q(mfr) => [
         q(4249),
         q(0),
         ],
      q(mfs) => [
         q(4250),
         q(0),
         ],
      q(mft) => [
         q(4251),
         q(0),
         ],
      q(mfu) => [
         q(4252),
         q(0),
         ],
      q(mfv) => [
         q(4253),
         q(0),
         ],
      q(mfw) => [
         q(4254),
         q(0),
         ],
      q(mfx) => [
         q(4255),
         q(0),
         ],
      q(mfy) => [
         q(4256),
         q(0),
         ],
      q(mfz) => [
         q(4257),
         q(0),
         ],
      q(mga) => [
         q(0278),
         q(1),
         ],
      q(mgb) => [
         q(4258),
         q(0),
         ],
      q(mgc) => [
         q(4259),
         q(0),
         ],
      q(mgd) => [
         q(4260),
         q(0),
         ],
      q(mge) => [
         q(4261),
         q(0),
         ],
      q(mgf) => [
         q(4262),
         q(0),
         ],
      q(mgg) => [
         q(4263),
         q(0),
         ],
      q(mgh) => [
         q(4264),
         q(0),
         ],
      q(mgi) => [
         q(4265),
         q(0),
         ],
      q(mgj) => [
         q(4266),
         q(0),
         ],
      q(mgk) => [
         q(4267),
         q(0),
         ],
      q(mgl) => [
         q(4268),
         q(0),
         ],
      q(mgm) => [
         q(4269),
         q(0),
         ],
      q(mgn) => [
         q(4270),
         q(0),
         ],
      q(mgo) => [
         q(4271),
         q(0),
         ],
      q(mgp) => [
         q(4272),
         q(0),
         ],
      q(mgq) => [
         q(4273),
         q(0),
         ],
      q(mgr) => [
         q(4274),
         q(0),
         ],
      q(mgs) => [
         q(4275),
         q(0),
         ],
      q(mgt) => [
         q(4276),
         q(0),
         ],
      q(mgu) => [
         q(4277),
         q(0),
         ],
      q(mgv) => [
         q(4278),
         q(0),
         ],
      q(mgw) => [
         q(4279),
         q(0),
         ],
      q(mgy) => [
         q(4280),
         q(0),
         ],
      q(mgz) => [
         q(4281),
         q(0),
         ],
      q(mha) => [
         q(4282),
         q(0),
         ],
      q(mhb) => [
         q(4283),
         q(0),
         ],
      q(mhc) => [
         q(4284),
         q(0),
         ],
      q(mhd) => [
         q(4285),
         q(0),
         ],
      q(mhe) => [
         q(4286),
         q(0),
         ],
      q(mhf) => [
         q(4287),
         q(0),
         ],
      q(mhg) => [
         q(4288),
         q(0),
         ],
      q(mhh) => [
         q(4289),
         q(0),
         ],
      q(mhi) => [
         q(4290),
         q(0),
         ],
      q(mhj) => [
         q(4291),
         q(0),
         ],
      q(mhk) => [
         q(4292),
         q(0),
         ],
      q(mhl) => [
         q(4293),
         q(0),
         ],
      q(mhm) => [
         q(4294),
         q(0),
         ],
      q(mhn) => [
         q(4295),
         q(0),
         ],
      q(mho) => [
         q(4296),
         q(0),
         ],
      q(mhp) => [
         q(4297),
         q(0),
         ],
      q(mhq) => [
         q(4298),
         q(0),
         ],
      q(mhr) => [
         q(4299),
         q(0),
         ],
      q(mhs) => [
         q(4300),
         q(0),
         ],
      q(mht) => [
         q(4301),
         q(0),
         ],
      q(mhu) => [
         q(4302),
         q(0),
         ],
      q(mhw) => [
         q(4303),
         q(0),
         ],
      q(mhx) => [
         q(4304),
         q(0),
         ],
      q(mhy) => [
         q(4305),
         q(0),
         ],
      q(mhz) => [
         q(4306),
         q(0),
         ],
      q(mia) => [
         q(4307),
         q(0),
         ],
      q(mib) => [
         q(4308),
         q(0),
         ],
      q(mic) => [
         q(0279),
         q(0),
         ],
      q(mid) => [
         q(4309),
         q(0),
         ],
      q(mie) => [
         q(4310),
         q(0),
         ],
      q(mif) => [
         q(4311),
         q(0),
         ],
      q(mig) => [
         q(4312),
         q(0),
         ],
      q(mih) => [
         q(4313),
         q(0),
         ],
      q(mii) => [
         q(4314),
         q(0),
         ],
      q(mij) => [
         q(4315),
         q(0),
         ],
      q(mik) => [
         q(4316),
         q(0),
         ],
      q(mil) => [
         q(4317),
         q(0),
         ],
      q(mim) => [
         q(4318),
         q(0),
         ],
      q(min) => [
         q(0280),
         q(0),
         ],
      q(mio) => [
         q(4319),
         q(0),
         ],
      q(mip) => [
         q(4320),
         q(0),
         ],
      q(miq) => [
         q(4321),
         q(0),
         ],
      q(mir) => [
         q(4322),
         q(0),
         ],
      q(mis) => [
         q(0281),
         q(0),
         ],
      q(mit) => [
         q(4323),
         q(0),
         ],
      q(miu) => [
         q(4324),
         q(0),
         ],
      q(miw) => [
         q(4325),
         q(0),
         ],
      q(mix) => [
         q(4326),
         q(0),
         ],
      q(miy) => [
         q(4327),
         q(0),
         ],
      q(miz) => [
         q(4328),
         q(0),
         ],
      q(mjc) => [
         q(4329),
         q(0),
         ],
      q(mjd) => [
         q(4330),
         q(0),
         ],
      q(mje) => [
         q(4331),
         q(0),
         ],
      q(mjg) => [
         q(4332),
         q(0),
         ],
      q(mjh) => [
         q(4333),
         q(0),
         ],
      q(mji) => [
         q(4334),
         q(0),
         ],
      q(mjj) => [
         q(4335),
         q(0),
         ],
      q(mjk) => [
         q(4336),
         q(0),
         ],
      q(mjl) => [
         q(4337),
         q(0),
         ],
      q(mjm) => [
         q(4338),
         q(0),
         ],
      q(mjn) => [
         q(4339),
         q(0),
         ],
      q(mjo) => [
         q(4340),
         q(0),
         ],
      q(mjp) => [
         q(4341),
         q(0),
         ],
      q(mjq) => [
         q(4342),
         q(0),
         ],
      q(mjr) => [
         q(4343),
         q(0),
         ],
      q(mjs) => [
         q(4344),
         q(0),
         ],
      q(mjt) => [
         q(4345),
         q(0),
         ],
      q(mju) => [
         q(4346),
         q(0),
         ],
      q(mjv) => [
         q(4347),
         q(0),
         ],
      q(mjw) => [
         q(4348),
         q(0),
         ],
      q(mjx) => [
         q(4349),
         q(0),
         ],
      q(mjy) => [
         q(4350),
         q(0),
         ],
      q(mjz) => [
         q(4351),
         q(0),
         ],
      q(mka) => [
         q(4352),
         q(0),
         ],
      q(mkb) => [
         q(4353),
         q(0),
         ],
      q(mkc) => [
         q(4354),
         q(0),
         ],
      q(mke) => [
         q(4355),
         q(0),
         ],
      q(mkf) => [
         q(4356),
         q(0),
         ],
      q(mkg) => [
         q(4357),
         q(0),
         ],
      q(mkh) => [
         q(0282),
         q(0),
         ],
      q(mki) => [
         q(4358),
         q(0),
         ],
      q(mkj) => [
         q(4359),
         q(0),
         ],
      q(mkk) => [
         q(4360),
         q(0),
         ],
      q(mkl) => [
         q(4361),
         q(0),
         ],
      q(mkm) => [
         q(4362),
         q(0),
         ],
      q(mkn) => [
         q(4363),
         q(0),
         ],
      q(mko) => [
         q(4364),
         q(0),
         ],
      q(mkp) => [
         q(4365),
         q(0),
         ],
      q(mkq) => [
         q(4366),
         q(0),
         ],
      q(mkr) => [
         q(4367),
         q(0),
         ],
      q(mks) => [
         q(4368),
         q(0),
         ],
      q(mkt) => [
         q(4369),
         q(0),
         ],
      q(mku) => [
         q(4370),
         q(0),
         ],
      q(mkv) => [
         q(4371),
         q(0),
         ],
      q(mkw) => [
         q(4372),
         q(0),
         ],
      q(mkx) => [
         q(4373),
         q(0),
         ],
      q(mky) => [
         q(4374),
         q(0),
         ],
      q(mkz) => [
         q(4375),
         q(0),
         ],
      q(mla) => [
         q(4376),
         q(0),
         ],
      q(mlb) => [
         q(4377),
         q(0),
         ],
      q(mlc) => [
         q(4378),
         q(0),
         ],
      q(mle) => [
         q(4379),
         q(0),
         ],
      q(mlf) => [
         q(4380),
         q(0),
         ],
      q(mlg) => [
         q(0283),
         q(0),
         ],
      q(mlh) => [
         q(4381),
         q(0),
         ],
      q(mli) => [
         q(4382),
         q(0),
         ],
      q(mlj) => [
         q(4383),
         q(0),
         ],
      q(mlk) => [
         q(4384),
         q(0),
         ],
      q(mll) => [
         q(4385),
         q(0),
         ],
      q(mlm) => [
         q(4386),
         q(0),
         ],
      q(mln) => [
         q(4387),
         q(0),
         ],
      q(mlo) => [
         q(4388),
         q(0),
         ],
      q(mlp) => [
         q(4389),
         q(0),
         ],
      q(mlq) => [
         q(4390),
         q(0),
         ],
      q(mlr) => [
         q(4391),
         q(0),
         ],
      q(mls) => [
         q(4392),
         q(0),
         ],
      q(mlt) => [
         q(0284),
         q(0),
         ],
      q(mlu) => [
         q(4393),
         q(0),
         ],
      q(mlv) => [
         q(4394),
         q(0),
         ],
      q(mlw) => [
         q(4395),
         q(0),
         ],
      q(mlx) => [
         q(4396),
         q(0),
         ],
      q(mlz) => [
         q(4397),
         q(0),
         ],
      q(mma) => [
         q(4398),
         q(0),
         ],
      q(mmb) => [
         q(4399),
         q(0),
         ],
      q(mmc) => [
         q(4400),
         q(0),
         ],
      q(mmd) => [
         q(4401),
         q(0),
         ],
      q(mme) => [
         q(4402),
         q(0),
         ],
      q(mmf) => [
         q(4403),
         q(0),
         ],
      q(mmg) => [
         q(4404),
         q(0),
         ],
      q(mmh) => [
         q(4405),
         q(0),
         ],
      q(mmi) => [
         q(4406),
         q(0),
         ],
      q(mmj) => [
         q(4407),
         q(0),
         ],
      q(mmk) => [
         q(4408),
         q(0),
         ],
      q(mml) => [
         q(4409),
         q(0),
         ],
      q(mmm) => [
         q(4410),
         q(0),
         ],
      q(mmn) => [
         q(4411),
         q(0),
         ],
      q(mmo) => [
         q(4412),
         q(0),
         ],
      q(mmp) => [
         q(4413),
         q(0),
         ],
      q(mmq) => [
         q(4414),
         q(0),
         ],
      q(mmr) => [
         q(4415),
         q(0),
         ],
      q(mmt) => [
         q(4416),
         q(0),
         ],
      q(mmu) => [
         q(4417),
         q(0),
         ],
      q(mmv) => [
         q(4418),
         q(0),
         ],
      q(mmw) => [
         q(4419),
         q(0),
         ],
      q(mmx) => [
         q(4420),
         q(0),
         ],
      q(mmy) => [
         q(4421),
         q(0),
         ],
      q(mmz) => [
         q(4422),
         q(0),
         ],
      q(mna) => [
         q(4423),
         q(0),
         ],
      q(mnb) => [
         q(4424),
         q(0),
         ],
      q(mnc) => [
         q(0285),
         q(0),
         ],
      q(mnd) => [
         q(4425),
         q(0),
         ],
      q(mne) => [
         q(4426),
         q(0),
         ],
      q(mnf) => [
         q(4427),
         q(0),
         ],
      q(mng) => [
         q(4428),
         q(0),
         ],
      q(mnh) => [
         q(4429),
         q(0),
         ],
      q(mni) => [
         q(0286),
         q(0),
         ],
      q(mnj) => [
         q(4430),
         q(0),
         ],
      q(mnk) => [
         q(4431),
         q(0),
         ],
      q(mnl) => [
         q(4432),
         q(0),
         ],
      q(mnm) => [
         q(4433),
         q(0),
         ],
      q(mnn) => [
         q(4434),
         q(0),
         ],
      q(mno) => [
         q(0287),
         q(0),
         ],
      q(mnp) => [
         q(4435),
         q(0),
         ],
      q(mnq) => [
         q(4436),
         q(0),
         ],
      q(mnr) => [
         q(4437),
         q(0),
         ],
      q(mns) => [
         q(4438),
         q(0),
         ],
      q(mnu) => [
         q(4439),
         q(0),
         ],
      q(mnv) => [
         q(4440),
         q(0),
         ],
      q(mnw) => [
         q(4441),
         q(0),
         ],
      q(mnx) => [
         q(4442),
         q(0),
         ],
      q(mny) => [
         q(4443),
         q(0),
         ],
      q(mnz) => [
         q(4444),
         q(0),
         ],
      q(moa) => [
         q(4445),
         q(0),
         ],
      q(moc) => [
         q(4446),
         q(0),
         ],
      q(mod) => [
         q(4447),
         q(0),
         ],
      q(moe) => [
         q(4448),
         q(0),
         ],
      q(mog) => [
         q(4449),
         q(0),
         ],
      q(moh) => [
         q(0288),
         q(0),
         ],
      q(moi) => [
         q(4450),
         q(0),
         ],
      q(moj) => [
         q(4451),
         q(0),
         ],
      q(mok) => [
         q(4452),
         q(0),
         ],
      q(mom) => [
         q(4453),
         q(0),
         ],
      q(mon) => [
         q(0289),
         q(0),
         ],
      q(moo) => [
         q(4454),
         q(0),
         ],
      q(mop) => [
         q(4455),
         q(0),
         ],
      q(moq) => [
         q(4456),
         q(0),
         ],
      q(mor) => [
         q(4457),
         q(0),
         ],
      q(mos) => [
         q(0290),
         q(0),
         ],
      q(mot) => [
         q(1138),
         q(0),
         ],
      q(mou) => [
         q(4458),
         q(0),
         ],
      q(mov) => [
         q(4459),
         q(0),
         ],
      q(mow) => [
         q(4460),
         q(0),
         ],
      q(mox) => [
         q(4461),
         q(0),
         ],
      q(moy) => [
         q(4462),
         q(0),
         ],
      q(moz) => [
         q(4463),
         q(0),
         ],
      q(mpa) => [
         q(4464),
         q(0),
         ],
      q(mpb) => [
         q(4465),
         q(0),
         ],
      q(mpc) => [
         q(4466),
         q(0),
         ],
      q(mpd) => [
         q(4467),
         q(0),
         ],
      q(mpe) => [
         q(4468),
         q(0),
         ],
      q(mpg) => [
         q(4469),
         q(0),
         ],
      q(mph) => [
         q(4470),
         q(0),
         ],
      q(mpi) => [
         q(4471),
         q(0),
         ],
      q(mpj) => [
         q(4472),
         q(0),
         ],
      q(mpk) => [
         q(4473),
         q(0),
         ],
      q(mpl) => [
         q(4474),
         q(0),
         ],
      q(mpm) => [
         q(4475),
         q(0),
         ],
      q(mpn) => [
         q(4476),
         q(0),
         ],
      q(mpo) => [
         q(4477),
         q(0),
         ],
      q(mpp) => [
         q(4478),
         q(0),
         ],
      q(mpq) => [
         q(4479),
         q(0),
         ],
      q(mpr) => [
         q(4480),
         q(0),
         ],
      q(mps) => [
         q(4481),
         q(0),
         ],
      q(mpt) => [
         q(4482),
         q(0),
         ],
      q(mpu) => [
         q(4483),
         q(0),
         ],
      q(mpv) => [
         q(4484),
         q(0),
         ],
      q(mpw) => [
         q(4485),
         q(0),
         ],
      q(mpx) => [
         q(4486),
         q(0),
         ],
      q(mpy) => [
         q(4487),
         q(0),
         ],
      q(mpz) => [
         q(4488),
         q(0),
         ],
      q(mqa) => [
         q(4489),
         q(0),
         ],
      q(mqb) => [
         q(4490),
         q(0),
         ],
      q(mqc) => [
         q(4491),
         q(0),
         ],
      q(mqe) => [
         q(4492),
         q(0),
         ],
      q(mqf) => [
         q(4493),
         q(0),
         ],
      q(mqg) => [
         q(4494),
         q(0),
         ],
      q(mqh) => [
         q(4495),
         q(0),
         ],
      q(mqi) => [
         q(4496),
         q(0),
         ],
      q(mqj) => [
         q(4497),
         q(0),
         ],
      q(mqk) => [
         q(4498),
         q(0),
         ],
      q(mql) => [
         q(4499),
         q(0),
         ],
      q(mqm) => [
         q(4500),
         q(0),
         ],
      q(mqn) => [
         q(4501),
         q(0),
         ],
      q(mqo) => [
         q(4502),
         q(0),
         ],
      q(mqp) => [
         q(4503),
         q(0),
         ],
      q(mqq) => [
         q(4504),
         q(0),
         ],
      q(mqr) => [
         q(4505),
         q(0),
         ],
      q(mqs) => [
         q(4506),
         q(0),
         ],
      q(mqt) => [
         q(4507),
         q(0),
         ],
      q(mqu) => [
         q(4508),
         q(0),
         ],
      q(mqv) => [
         q(4509),
         q(0),
         ],
      q(mqw) => [
         q(4510),
         q(0),
         ],
      q(mqx) => [
         q(4511),
         q(0),
         ],
      q(mqy) => [
         q(4512),
         q(0),
         ],
      q(mqz) => [
         q(4513),
         q(0),
         ],
      q(mra) => [
         q(4514),
         q(0),
         ],
      q(mrb) => [
         q(4515),
         q(0),
         ],
      q(mrc) => [
         q(4516),
         q(0),
         ],
      q(mrd) => [
         q(4517),
         q(0),
         ],
      q(mre) => [
         q(4518),
         q(0),
         ],
      q(mrf) => [
         q(4519),
         q(0),
         ],
      q(mrg) => [
         q(4520),
         q(0),
         ],
      q(mrh) => [
         q(4521),
         q(0),
         ],
      q(mrj) => [
         q(4522),
         q(0),
         ],
      q(mrk) => [
         q(4523),
         q(0),
         ],
      q(mrl) => [
         q(4524),
         q(0),
         ],
      q(mrm) => [
         q(4525),
         q(0),
         ],
      q(mrn) => [
         q(4526),
         q(0),
         ],
      q(mro) => [
         q(4527),
         q(0),
         ],
      q(mrp) => [
         q(4528),
         q(0),
         ],
      q(mrq) => [
         q(4529),
         q(0),
         ],
      q(mrr) => [
         q(4530),
         q(0),
         ],
      q(mrs) => [
         q(4531),
         q(0),
         ],
      q(mrt) => [
         q(4532),
         q(0),
         ],
      q(mru) => [
         q(4533),
         q(0),
         ],
      q(mrv) => [
         q(4534),
         q(0),
         ],
      q(mrw) => [
         q(4535),
         q(0),
         ],
      q(mrx) => [
         q(4536),
         q(0),
         ],
      q(mry) => [
         q(4537),
         q(0),
         ],
      q(mrz) => [
         q(4538),
         q(0),
         ],
      q(msb) => [
         q(4539),
         q(0),
         ],
      q(msc) => [
         q(4540),
         q(0),
         ],
      q(msd) => [
         q(4541),
         q(0),
         ],
      q(mse) => [
         q(4542),
         q(0),
         ],
      q(msf) => [
         q(4543),
         q(0),
         ],
      q(msg) => [
         q(4544),
         q(0),
         ],
      q(msh) => [
         q(4545),
         q(0),
         ],
      q(msi) => [
         q(4546),
         q(0),
         ],
      q(msj) => [
         q(4547),
         q(0),
         ],
      q(msk) => [
         q(4548),
         q(0),
         ],
      q(msl) => [
         q(4549),
         q(0),
         ],
      q(msm) => [
         q(4550),
         q(0),
         ],
      q(msn) => [
         q(4551),
         q(0),
         ],
      q(mso) => [
         q(4552),
         q(0),
         ],
      q(msp) => [
         q(4553),
         q(0),
         ],
      q(msq) => [
         q(4554),
         q(0),
         ],
      q(msr) => [
         q(4555),
         q(0),
         ],
      q(mss) => [
         q(4556),
         q(0),
         ],
      q(msu) => [
         q(4557),
         q(0),
         ],
      q(msv) => [
         q(4558),
         q(0),
         ],
      q(msw) => [
         q(4559),
         q(0),
         ],
      q(msx) => [
         q(4560),
         q(0),
         ],
      q(msy) => [
         q(4561),
         q(0),
         ],
      q(msz) => [
         q(4562),
         q(0),
         ],
      q(mta) => [
         q(4563),
         q(0),
         ],
      q(mtb) => [
         q(4564),
         q(0),
         ],
      q(mtc) => [
         q(4565),
         q(0),
         ],
      q(mtd) => [
         q(4566),
         q(0),
         ],
      q(mte) => [
         q(4567),
         q(0),
         ],
      q(mtf) => [
         q(4568),
         q(0),
         ],
      q(mtg) => [
         q(4569),
         q(0),
         ],
      q(mth) => [
         q(4570),
         q(0),
         ],
      q(mti) => [
         q(4571),
         q(0),
         ],
      q(mtj) => [
         q(4572),
         q(0),
         ],
      q(mtk) => [
         q(4573),
         q(0),
         ],
      q(mtl) => [
         q(4574),
         q(0),
         ],
      q(mtm) => [
         q(4575),
         q(0),
         ],
      q(mtn) => [
         q(4576),
         q(0),
         ],
      q(mto) => [
         q(4577),
         q(0),
         ],
      q(mtp) => [
         q(4578),
         q(0),
         ],
      q(mtq) => [
         q(4579),
         q(0),
         ],
      q(mtr) => [
         q(4580),
         q(0),
         ],
      q(mts) => [
         q(4581),
         q(0),
         ],
      q(mtt) => [
         q(4582),
         q(0),
         ],
      q(mtu) => [
         q(4583),
         q(0),
         ],
      q(mtv) => [
         q(4584),
         q(0),
         ],
      q(mtw) => [
         q(4585),
         q(0),
         ],
      q(mtx) => [
         q(4586),
         q(0),
         ],
      q(mty) => [
         q(4587),
         q(0),
         ],
      q(mua) => [
         q(4588),
         q(0),
         ],
      q(mub) => [
         q(4589),
         q(0),
         ],
      q(muc) => [
         q(4590),
         q(0),
         ],
      q(mud) => [
         q(4591),
         q(0),
         ],
      q(mue) => [
         q(4592),
         q(0),
         ],
      q(mug) => [
         q(4593),
         q(0),
         ],
      q(muh) => [
         q(4594),
         q(0),
         ],
      q(mui) => [
         q(4595),
         q(0),
         ],
      q(muj) => [
         q(4596),
         q(0),
         ],
      q(muk) => [
         q(4597),
         q(0),
         ],
      q(mul) => [
         q(0291),
         q(0),
         ],
      q(mum) => [
         q(4598),
         q(0),
         ],
      q(mun) => [
         q(0292),
         q(0),
         ],
      q(muo) => [
         q(4599),
         q(0),
         ],
      q(mup) => [
         q(4600),
         q(0),
         ],
      q(muq) => [
         q(4601),
         q(0),
         ],
      q(mur) => [
         q(4602),
         q(0),
         ],
      q(mus) => [
         q(0293),
         q(0),
         ],
      q(mut) => [
         q(4603),
         q(0),
         ],
      q(muu) => [
         q(4604),
         q(0),
         ],
      q(muv) => [
         q(4605),
         q(0),
         ],
      q(mux) => [
         q(4606),
         q(0),
         ],
      q(muy) => [
         q(4607),
         q(0),
         ],
      q(muz) => [
         q(4608),
         q(0),
         ],
      q(mva) => [
         q(4609),
         q(0),
         ],
      q(mvb) => [
         q(4610),
         q(0),
         ],
      q(mvd) => [
         q(4611),
         q(0),
         ],
      q(mve) => [
         q(4612),
         q(0),
         ],
      q(mvf) => [
         q(4613),
         q(0),
         ],
      q(mvg) => [
         q(4614),
         q(0),
         ],
      q(mvh) => [
         q(4615),
         q(0),
         ],
      q(mvi) => [
         q(4616),
         q(0),
         ],
      q(mvk) => [
         q(4617),
         q(0),
         ],
      q(mvl) => [
         q(4618),
         q(0),
         ],
      q(mvm) => [
         q(4619),
         q(0),
         ],
      q(mvn) => [
         q(4620),
         q(0),
         ],
      q(mvo) => [
         q(4621),
         q(0),
         ],
      q(mvp) => [
         q(4622),
         q(0),
         ],
      q(mvq) => [
         q(4623),
         q(0),
         ],
      q(mvr) => [
         q(4624),
         q(0),
         ],
      q(mvs) => [
         q(4625),
         q(0),
         ],
      q(mvt) => [
         q(4626),
         q(0),
         ],
      q(mvu) => [
         q(4627),
         q(0),
         ],
      q(mvv) => [
         q(4628),
         q(0),
         ],
      q(mvw) => [
         q(4629),
         q(0),
         ],
      q(mvx) => [
         q(4630),
         q(0),
         ],
      q(mvy) => [
         q(4631),
         q(0),
         ],
      q(mvz) => [
         q(4632),
         q(0),
         ],
      q(mwa) => [
         q(4633),
         q(0),
         ],
      q(mwb) => [
         q(4634),
         q(0),
         ],
      q(mwc) => [
         q(4635),
         q(0),
         ],
      q(mwe) => [
         q(4636),
         q(0),
         ],
      q(mwf) => [
         q(4637),
         q(0),
         ],
      q(mwg) => [
         q(4638),
         q(0),
         ],
      q(mwh) => [
         q(4639),
         q(0),
         ],
      q(mwi) => [
         q(4640),
         q(0),
         ],
      q(mwj) => [
         q(4641),
         q(0),
         ],
      q(mwk) => [
         q(4642),
         q(0),
         ],
      q(mwl) => [
         q(0294),
         q(0),
         ],
      q(mwm) => [
         q(4643),
         q(0),
         ],
      q(mwn) => [
         q(4644),
         q(0),
         ],
      q(mwo) => [
         q(4645),
         q(0),
         ],
      q(mwp) => [
         q(4646),
         q(0),
         ],
      q(mwq) => [
         q(4647),
         q(0),
         ],
      q(mwr) => [
         q(0295),
         q(0),
         ],
      q(mws) => [
         q(4648),
         q(0),
         ],
      q(mwt) => [
         q(4649),
         q(0),
         ],
      q(mwu) => [
         q(4650),
         q(0),
         ],
      q(mwv) => [
         q(4651),
         q(0),
         ],
      q(mww) => [
         q(4652),
         q(0),
         ],
      q(mwx) => [
         q(4653),
         q(0),
         ],
      q(mwy) => [
         q(4654),
         q(0),
         ],
      q(mwz) => [
         q(4655),
         q(0),
         ],
      q(mxa) => [
         q(4656),
         q(0),
         ],
      q(mxb) => [
         q(4657),
         q(0),
         ],
      q(mxc) => [
         q(4658),
         q(0),
         ],
      q(mxd) => [
         q(4659),
         q(0),
         ],
      q(mxe) => [
         q(4660),
         q(0),
         ],
      q(mxf) => [
         q(4661),
         q(0),
         ],
      q(mxg) => [
         q(4662),
         q(0),
         ],
      q(mxh) => [
         q(4663),
         q(0),
         ],
      q(mxi) => [
         q(4664),
         q(0),
         ],
      q(mxj) => [
         q(4665),
         q(0),
         ],
      q(mxk) => [
         q(4666),
         q(0),
         ],
      q(mxl) => [
         q(4667),
         q(0),
         ],
      q(mxm) => [
         q(4668),
         q(0),
         ],
      q(mxn) => [
         q(4669),
         q(0),
         ],
      q(mxo) => [
         q(4670),
         q(0),
         ],
      q(mxp) => [
         q(4671),
         q(0),
         ],
      q(mxq) => [
         q(4672),
         q(0),
         ],
      q(mxr) => [
         q(4673),
         q(0),
         ],
      q(mxs) => [
         q(4674),
         q(0),
         ],
      q(mxt) => [
         q(4675),
         q(0),
         ],
      q(mxu) => [
         q(4676),
         q(0),
         ],
      q(mxv) => [
         q(4677),
         q(0),
         ],
      q(mxw) => [
         q(4678),
         q(0),
         ],
      q(mxx) => [
         q(4679),
         q(0),
         ],
      q(mxy) => [
         q(4680),
         q(0),
         ],
      q(mxz) => [
         q(4681),
         q(0),
         ],
      q(myb) => [
         q(4682),
         q(0),
         ],
      q(myc) => [
         q(4683),
         q(0),
         ],
      q(myd) => [
         q(4684),
         q(0),
         ],
      q(mye) => [
         q(4685),
         q(0),
         ],
      q(myf) => [
         q(4686),
         q(0),
         ],
      q(myg) => [
         q(4687),
         q(0),
         ],
      q(myh) => [
         q(4688),
         q(0),
         ],
      q(myi) => [
         q(4689),
         q(0),
         ],
      q(myj) => [
         q(4690),
         q(0),
         ],
      q(myk) => [
         q(4691),
         q(0),
         ],
      q(myl) => [
         q(4692),
         q(0),
         ],
      q(mym) => [
         q(4693),
         q(0),
         ],
      q(myn) => [
         q(0296),
         q(0),
         ],
      q(myo) => [
         q(4694),
         q(0),
         ],
      q(myp) => [
         q(4695),
         q(0),
         ],
      q(myr) => [
         q(4696),
         q(0),
         ],
      q(mys) => [
         q(4697),
         q(0),
         ],
      q(myu) => [
         q(4698),
         q(0),
         ],
      q(myv) => [
         q(0297),
         q(0),
         ],
      q(myw) => [
         q(4699),
         q(0),
         ],
      q(myx) => [
         q(4700),
         q(0),
         ],
      q(myy) => [
         q(4701),
         q(0),
         ],
      q(myz) => [
         q(4702),
         q(0),
         ],
      q(mza) => [
         q(4703),
         q(0),
         ],
      q(mzb) => [
         q(4704),
         q(0),
         ],
      q(mzc) => [
         q(4705),
         q(0),
         ],
      q(mzd) => [
         q(4706),
         q(0),
         ],
      q(mze) => [
         q(4707),
         q(0),
         ],
      q(mzg) => [
         q(4708),
         q(0),
         ],
      q(mzh) => [
         q(4709),
         q(0),
         ],
      q(mzi) => [
         q(4710),
         q(0),
         ],
      q(mzj) => [
         q(4711),
         q(0),
         ],
      q(mzk) => [
         q(4712),
         q(0),
         ],
      q(mzl) => [
         q(4713),
         q(0),
         ],
      q(mzm) => [
         q(4714),
         q(0),
         ],
      q(mzn) => [
         q(4715),
         q(0),
         ],
      q(mzo) => [
         q(4716),
         q(0),
         ],
      q(mzp) => [
         q(4717),
         q(0),
         ],
      q(mzq) => [
         q(4718),
         q(0),
         ],
      q(mzr) => [
         q(4719),
         q(0),
         ],
      q(mzs) => [
         q(4720),
         q(0),
         ],
      q(mzt) => [
         q(4721),
         q(0),
         ],
      q(mzu) => [
         q(4722),
         q(0),
         ],
      q(mzv) => [
         q(4723),
         q(0),
         ],
      q(mzw) => [
         q(4724),
         q(0),
         ],
      q(mzx) => [
         q(4725),
         q(0),
         ],
      q(mzy) => [
         q(4726),
         q(0),
         ],
      q(mzz) => [
         q(4727),
         q(0),
         ],
      q(naa) => [
         q(4728),
         q(0),
         ],
      q(nab) => [
         q(4729),
         q(0),
         ],
      q(nac) => [
         q(4730),
         q(0),
         ],
      q(nad) => [
         q(4731),
         q(0),
         ],
      q(nae) => [
         q(4732),
         q(0),
         ],
      q(naf) => [
         q(4733),
         q(0),
         ],
      q(nag) => [
         q(4734),
         q(0),
         ],
      q(nah) => [
         q(0298),
         q(0),
         ],
      q(nai) => [
         q(0299),
         q(0),
         ],
      q(naj) => [
         q(4735),
         q(0),
         ],
      q(nak) => [
         q(4736),
         q(0),
         ],
      q(nal) => [
         q(4737),
         q(0),
         ],
      q(nam) => [
         q(4738),
         q(0),
         ],
      q(nan) => [
         q(4739),
         q(0),
         ],
      q(nao) => [
         q(4740),
         q(0),
         ],
      q(nap) => [
         q(0300),
         q(0),
         ],
      q(naq) => [
         q(4741),
         q(0),
         ],
      q(nar) => [
         q(4742),
         q(0),
         ],
      q(nas) => [
         q(4743),
         q(0),
         ],
      q(nat) => [
         q(4744),
         q(0),
         ],
      q(nau) => [
         q(0301),
         q(0),
         ],
      q(nav) => [
         q(0302),
         q(0),
         ],
      q(naw) => [
         q(4745),
         q(0),
         ],
      q(nax) => [
         q(4746),
         q(0),
         ],
      q(nay) => [
         q(4747),
         q(0),
         ],
      q(naz) => [
         q(4748),
         q(0),
         ],
      q(nba) => [
         q(4749),
         q(0),
         ],
      q(nbb) => [
         q(4750),
         q(0),
         ],
      q(nbc) => [
         q(4751),
         q(0),
         ],
      q(nbd) => [
         q(4752),
         q(0),
         ],
      q(nbe) => [
         q(4753),
         q(0),
         ],
      q(nbg) => [
         q(4754),
         q(0),
         ],
      q(nbh) => [
         q(4755),
         q(0),
         ],
      q(nbi) => [
         q(4756),
         q(0),
         ],
      q(nbj) => [
         q(4757),
         q(0),
         ],
      q(nbk) => [
         q(4758),
         q(0),
         ],
      q(nbl) => [
         q(0303),
         q(0),
         ],
      q(nbm) => [
         q(4759),
         q(0),
         ],
      q(nbn) => [
         q(4760),
         q(0),
         ],
      q(nbo) => [
         q(4761),
         q(0),
         ],
      q(nbp) => [
         q(4762),
         q(0),
         ],
      q(nbq) => [
         q(4763),
         q(0),
         ],
      q(nbr) => [
         q(4764),
         q(0),
         ],
      q(nbs) => [
         q(4765),
         q(0),
         ],
      q(nbt) => [
         q(4766),
         q(0),
         ],
      q(nbu) => [
         q(4767),
         q(0),
         ],
      q(nbv) => [
         q(4768),
         q(0),
         ],
      q(nbw) => [
         q(4769),
         q(0),
         ],
      q(nby) => [
         q(4770),
         q(0),
         ],
      q(nca) => [
         q(4771),
         q(0),
         ],
      q(ncb) => [
         q(4772),
         q(0),
         ],
      q(ncc) => [
         q(4773),
         q(0),
         ],
      q(ncd) => [
         q(4774),
         q(0),
         ],
      q(nce) => [
         q(4775),
         q(0),
         ],
      q(ncf) => [
         q(4776),
         q(0),
         ],
      q(ncg) => [
         q(4777),
         q(0),
         ],
      q(nch) => [
         q(4778),
         q(0),
         ],
      q(nci) => [
         q(4779),
         q(0),
         ],
      q(ncj) => [
         q(4780),
         q(0),
         ],
      q(nck) => [
         q(4781),
         q(0),
         ],
      q(ncl) => [
         q(4782),
         q(0),
         ],
      q(ncm) => [
         q(4783),
         q(0),
         ],
      q(ncn) => [
         q(4784),
         q(0),
         ],
      q(nco) => [
         q(4785),
         q(0),
         ],
      q(ncp) => [
         q(4786),
         q(0),
         ],
      q(ncr) => [
         q(4787),
         q(0),
         ],
      q(ncs) => [
         q(4788),
         q(0),
         ],
      q(nct) => [
         q(4789),
         q(0),
         ],
      q(ncu) => [
         q(4790),
         q(0),
         ],
      q(ncx) => [
         q(4791),
         q(0),
         ],
      q(ncz) => [
         q(4792),
         q(0),
         ],
      q(nda) => [
         q(4793),
         q(0),
         ],
      q(ndb) => [
         q(4794),
         q(0),
         ],
      q(ndc) => [
         q(4795),
         q(0),
         ],
      q(ndd) => [
         q(4796),
         q(0),
         ],
      q(nde) => [
         q(0304),
         q(0),
         ],
      q(ndf) => [
         q(4797),
         q(0),
         ],
      q(ndg) => [
         q(4798),
         q(0),
         ],
      q(ndh) => [
         q(4799),
         q(0),
         ],
      q(ndi) => [
         q(4800),
         q(0),
         ],
      q(ndj) => [
         q(4801),
         q(0),
         ],
      q(ndk) => [
         q(4802),
         q(0),
         ],
      q(ndl) => [
         q(4803),
         q(0),
         ],
      q(ndm) => [
         q(4804),
         q(0),
         ],
      q(ndn) => [
         q(4805),
         q(0),
         ],
      q(ndo) => [
         q(0305),
         q(0),
         ],
      q(ndp) => [
         q(4806),
         q(0),
         ],
      q(ndq) => [
         q(4807),
         q(0),
         ],
      q(ndr) => [
         q(4808),
         q(0),
         ],
      q(nds) => [
         q(0306),
         q(0),
         ],
      q(ndt) => [
         q(4809),
         q(0),
         ],
      q(ndu) => [
         q(4810),
         q(0),
         ],
      q(ndv) => [
         q(4811),
         q(0),
         ],
      q(ndw) => [
         q(4812),
         q(0),
         ],
      q(ndx) => [
         q(4813),
         q(0),
         ],
      q(ndy) => [
         q(4814),
         q(0),
         ],
      q(ndz) => [
         q(4815),
         q(0),
         ],
      q(nea) => [
         q(4816),
         q(0),
         ],
      q(neb) => [
         q(4817),
         q(0),
         ],
      q(nec) => [
         q(4818),
         q(0),
         ],
      q(ned) => [
         q(4819),
         q(0),
         ],
      q(nee) => [
         q(4820),
         q(0),
         ],
      q(nef) => [
         q(4821),
         q(0),
         ],
      q(neg) => [
         q(4822),
         q(0),
         ],
      q(neh) => [
         q(4823),
         q(0),
         ],
      q(nei) => [
         q(4824),
         q(0),
         ],
      q(nej) => [
         q(4825),
         q(0),
         ],
      q(nek) => [
         q(4826),
         q(0),
         ],
      q(nem) => [
         q(4827),
         q(0),
         ],
      q(nen) => [
         q(4828),
         q(0),
         ],
      q(neo) => [
         q(4829),
         q(0),
         ],
      q(nep) => [
         q(0307),
         q(0),
         ],
      q(neq) => [
         q(4830),
         q(0),
         ],
      q(ner) => [
         q(4831),
         q(0),
         ],
      q(nes) => [
         q(4832),
         q(0),
         ],
      q(net) => [
         q(4833),
         q(0),
         ],
      q(neu) => [
         q(4834),
         q(0),
         ],
      q(nev) => [
         q(4835),
         q(0),
         ],
      q(new) => [
         q(0308),
         q(1),
         ],
      q(nex) => [
         q(4836),
         q(0),
         ],
      q(ney) => [
         q(4837),
         q(0),
         ],
      q(nez) => [
         q(4838),
         q(0),
         ],
      q(nfa) => [
         q(4839),
         q(0),
         ],
      q(nfd) => [
         q(4840),
         q(0),
         ],
      q(nfl) => [
         q(4841),
         q(0),
         ],
      q(nfr) => [
         q(4842),
         q(0),
         ],
      q(nfu) => [
         q(4843),
         q(0),
         ],
      q(nga) => [
         q(4844),
         q(0),
         ],
      q(ngb) => [
         q(4845),
         q(0),
         ],
      q(ngc) => [
         q(4846),
         q(0),
         ],
      q(ngd) => [
         q(4847),
         q(0),
         ],
      q(nge) => [
         q(4848),
         q(0),
         ],
      q(ngf) => [
         q(0516),
         q(0),
         ],
      q(ngg) => [
         q(4849),
         q(0),
         ],
      q(ngh) => [
         q(4850),
         q(0),
         ],
      q(ngi) => [
         q(4851),
         q(0),
         ],
      q(ngj) => [
         q(4852),
         q(0),
         ],
      q(ngk) => [
         q(4853),
         q(0),
         ],
      q(ngl) => [
         q(4854),
         q(0),
         ],
      q(ngm) => [
         q(4855),
         q(0),
         ],
      q(ngn) => [
         q(4856),
         q(0),
         ],
      q(ngo) => [
         q(4857),
         q(0),
         ],
      q(ngp) => [
         q(4858),
         q(0),
         ],
      q(ngq) => [
         q(4859),
         q(0),
         ],
      q(ngr) => [
         q(4860),
         q(0),
         ],
      q(ngs) => [
         q(4861),
         q(0),
         ],
      q(ngt) => [
         q(4862),
         q(0),
         ],
      q(ngu) => [
         q(4863),
         q(0),
         ],
      q(ngv) => [
         q(4864),
         q(0),
         ],
      q(ngw) => [
         q(4865),
         q(0),
         ],
      q(ngx) => [
         q(4866),
         q(0),
         ],
      q(ngy) => [
         q(4867),
         q(0),
         ],
      q(ngz) => [
         q(4868),
         q(0),
         ],
      q(nha) => [
         q(4869),
         q(0),
         ],
      q(nhb) => [
         q(4870),
         q(0),
         ],
      q(nhc) => [
         q(4871),
         q(0),
         ],
      q(nhd) => [
         q(4872),
         q(0),
         ],
      q(nhe) => [
         q(4873),
         q(0),
         ],
      q(nhf) => [
         q(4874),
         q(0),
         ],
      q(nhg) => [
         q(4875),
         q(0),
         ],
      q(nhh) => [
         q(4876),
         q(0),
         ],
      q(nhi) => [
         q(4877),
         q(0),
         ],
      q(nhk) => [
         q(4878),
         q(0),
         ],
      q(nhm) => [
         q(4879),
         q(0),
         ],
      q(nhn) => [
         q(4880),
         q(0),
         ],
      q(nho) => [
         q(4881),
         q(0),
         ],
      q(nhp) => [
         q(4882),
         q(0),
         ],
      q(nhq) => [
         q(4883),
         q(0),
         ],
      q(nhr) => [
         q(4884),
         q(0),
         ],
      q(nht) => [
         q(4885),
         q(0),
         ],
      q(nhu) => [
         q(4886),
         q(0),
         ],
      q(nhv) => [
         q(4887),
         q(0),
         ],
      q(nhw) => [
         q(4888),
         q(0),
         ],
      q(nhx) => [
         q(4889),
         q(0),
         ],
      q(nhy) => [
         q(4890),
         q(0),
         ],
      q(nhz) => [
         q(4891),
         q(0),
         ],
      q(nia) => [
         q(0309),
         q(0),
         ],
      q(nib) => [
         q(4892),
         q(0),
         ],
      q(nic) => [
         q(0310),
         q(0),
         ],
      q(nid) => [
         q(4893),
         q(0),
         ],
      q(nie) => [
         q(4894),
         q(0),
         ],
      q(nif) => [
         q(4895),
         q(0),
         ],
      q(nig) => [
         q(4896),
         q(0),
         ],
      q(nih) => [
         q(4897),
         q(0),
         ],
      q(nii) => [
         q(4898),
         q(0),
         ],
      q(nij) => [
         q(4899),
         q(0),
         ],
      q(nik) => [
         q(4900),
         q(0),
         ],
      q(nil) => [
         q(4901),
         q(0),
         ],
      q(nim) => [
         q(4902),
         q(0),
         ],
      q(nin) => [
         q(4903),
         q(0),
         ],
      q(nio) => [
         q(4904),
         q(0),
         ],
      q(niq) => [
         q(4905),
         q(0),
         ],
      q(nir) => [
         q(4906),
         q(0),
         ],
      q(nis) => [
         q(4907),
         q(0),
         ],
      q(nit) => [
         q(4908),
         q(0),
         ],
      q(niu) => [
         q(0311),
         q(0),
         ],
      q(niv) => [
         q(4909),
         q(0),
         ],
      q(niw) => [
         q(4910),
         q(0),
         ],
      q(nix) => [
         q(4911),
         q(0),
         ],
      q(niy) => [
         q(4912),
         q(0),
         ],
      q(niz) => [
         q(4913),
         q(0),
         ],
      q(nja) => [
         q(4914),
         q(0),
         ],
      q(njb) => [
         q(4915),
         q(0),
         ],
      q(njd) => [
         q(4916),
         q(0),
         ],
      q(njh) => [
         q(4917),
         q(0),
         ],
      q(nji) => [
         q(4918),
         q(0),
         ],
      q(njj) => [
         q(4919),
         q(0),
         ],
      q(njl) => [
         q(4920),
         q(0),
         ],
      q(njm) => [
         q(4921),
         q(0),
         ],
      q(njn) => [
         q(4922),
         q(0),
         ],
      q(njo) => [
         q(4923),
         q(0),
         ],
      q(njr) => [
         q(4924),
         q(0),
         ],
      q(njs) => [
         q(4925),
         q(0),
         ],
      q(njt) => [
         q(4926),
         q(0),
         ],
      q(nju) => [
         q(4927),
         q(0),
         ],
      q(njx) => [
         q(4928),
         q(0),
         ],
      q(njy) => [
         q(4929),
         q(0),
         ],
      q(njz) => [
         q(4930),
         q(0),
         ],
      q(nka) => [
         q(4931),
         q(0),
         ],
      q(nkb) => [
         q(4932),
         q(0),
         ],
      q(nkc) => [
         q(4933),
         q(0),
         ],
      q(nkd) => [
         q(4934),
         q(0),
         ],
      q(nke) => [
         q(4935),
         q(0),
         ],
      q(nkf) => [
         q(4936),
         q(0),
         ],
      q(nkg) => [
         q(4937),
         q(0),
         ],
      q(nkh) => [
         q(4938),
         q(0),
         ],
      q(nki) => [
         q(4939),
         q(0),
         ],
      q(nkj) => [
         q(4940),
         q(0),
         ],
      q(nkk) => [
         q(4941),
         q(0),
         ],
      q(nkm) => [
         q(4942),
         q(0),
         ],
      q(nkn) => [
         q(4943),
         q(0),
         ],
      q(nko) => [
         q(4944),
         q(0),
         ],
      q(nkp) => [
         q(4945),
         q(0),
         ],
      q(nkq) => [
         q(4946),
         q(0),
         ],
      q(nkr) => [
         q(4947),
         q(0),
         ],
      q(nks) => [
         q(4948),
         q(0),
         ],
      q(nkt) => [
         q(4949),
         q(0),
         ],
      q(nku) => [
         q(4950),
         q(0),
         ],
      q(nkv) => [
         q(4951),
         q(0),
         ],
      q(nkw) => [
         q(4952),
         q(0),
         ],
      q(nkx) => [
         q(4953),
         q(0),
         ],
      q(nkz) => [
         q(4954),
         q(0),
         ],
      q(nla) => [
         q(4955),
         q(0),
         ],
      q(nlc) => [
         q(4956),
         q(0),
         ],
      q(nle) => [
         q(4957),
         q(0),
         ],
      q(nlg) => [
         q(4958),
         q(0),
         ],
      q(nli) => [
         q(4959),
         q(0),
         ],
      q(nlj) => [
         q(4960),
         q(0),
         ],
      q(nlk) => [
         q(4961),
         q(0),
         ],
      q(nll) => [
         q(4962),
         q(0),
         ],
      q(nlo) => [
         q(4963),
         q(0),
         ],
      q(nlq) => [
         q(4964),
         q(0),
         ],
      q(nlu) => [
         q(4965),
         q(0),
         ],
      q(nlv) => [
         q(4966),
         q(0),
         ],
      q(nlw) => [
         q(4967),
         q(0),
         ],
      q(nlx) => [
         q(4968),
         q(0),
         ],
      q(nly) => [
         q(4969),
         q(0),
         ],
      q(nlz) => [
         q(4970),
         q(0),
         ],
      q(nma) => [
         q(4971),
         q(0),
         ],
      q(nmb) => [
         q(4972),
         q(0),
         ],
      q(nmc) => [
         q(4973),
         q(0),
         ],
      q(nmd) => [
         q(4974),
         q(0),
         ],
      q(nme) => [
         q(4975),
         q(0),
         ],
      q(nmf) => [
         q(4976),
         q(0),
         ],
      q(nmg) => [
         q(4977),
         q(0),
         ],
      q(nmh) => [
         q(4978),
         q(0),
         ],
      q(nmi) => [
         q(4979),
         q(0),
         ],
      q(nmj) => [
         q(4980),
         q(0),
         ],
      q(nmk) => [
         q(4981),
         q(0),
         ],
      q(nml) => [
         q(4982),
         q(0),
         ],
      q(nmm) => [
         q(4983),
         q(0),
         ],
      q(nmn) => [
         q(4984),
         q(0),
         ],
      q(nmo) => [
         q(4985),
         q(0),
         ],
      q(nmp) => [
         q(4986),
         q(0),
         ],
      q(nmq) => [
         q(4987),
         q(0),
         ],
      q(nmr) => [
         q(4988),
         q(0),
         ],
      q(nms) => [
         q(4989),
         q(0),
         ],
      q(nmt) => [
         q(4990),
         q(0),
         ],
      q(nmu) => [
         q(4991),
         q(0),
         ],
      q(nmv) => [
         q(4992),
         q(0),
         ],
      q(nmw) => [
         q(4993),
         q(0),
         ],
      q(nmx) => [
         q(4994),
         q(0),
         ],
      q(nmy) => [
         q(4995),
         q(0),
         ],
      q(nmz) => [
         q(4996),
         q(0),
         ],
      q(nna) => [
         q(4997),
         q(0),
         ],
      q(nnb) => [
         q(4998),
         q(0),
         ],
      q(nnc) => [
         q(4999),
         q(0),
         ],
      q(nnd) => [
         q(5000),
         q(0),
         ],
      q(nne) => [
         q(5001),
         q(0),
         ],
      q(nnf) => [
         q(5002),
         q(0),
         ],
      q(nng) => [
         q(5003),
         q(0),
         ],
      q(nnh) => [
         q(5004),
         q(0),
         ],
      q(nni) => [
         q(5005),
         q(0),
         ],
      q(nnj) => [
         q(5006),
         q(0),
         ],
      q(nnk) => [
         q(5007),
         q(0),
         ],
      q(nnl) => [
         q(5008),
         q(0),
         ],
      q(nnm) => [
         q(5009),
         q(0),
         ],
      q(nnn) => [
         q(5010),
         q(0),
         ],
      q(nno) => [
         q(0312),
         q(0),
         ],
      q(nnp) => [
         q(5011),
         q(0),
         ],
      q(nnq) => [
         q(5012),
         q(0),
         ],
      q(nnr) => [
         q(5013),
         q(0),
         ],
      q(nns) => [
         q(5014),
         q(0),
         ],
      q(nnt) => [
         q(5015),
         q(0),
         ],
      q(nnu) => [
         q(5016),
         q(0),
         ],
      q(nnv) => [
         q(5017),
         q(0),
         ],
      q(nnw) => [
         q(5018),
         q(0),
         ],
      q(nnx) => [
         q(5019),
         q(0),
         ],
      q(nny) => [
         q(5020),
         q(0),
         ],
      q(nnz) => [
         q(5021),
         q(0),
         ],
      q(noa) => [
         q(5022),
         q(0),
         ],
      q(nob) => [
         q(0313),
         q(0),
         ],
      q(noc) => [
         q(5023),
         q(0),
         ],
      q(nod) => [
         q(5024),
         q(0),
         ],
      q(noe) => [
         q(5025),
         q(0),
         ],
      q(nof) => [
         q(5026),
         q(0),
         ],
      q(nog) => [
         q(0314),
         q(0),
         ],
      q(noh) => [
         q(5027),
         q(0),
         ],
      q(noi) => [
         q(5028),
         q(0),
         ],
      q(noj) => [
         q(5029),
         q(0),
         ],
      q(nok) => [
         q(5030),
         q(0),
         ],
      q(nol) => [
         q(5031),
         q(0),
         ],
      q(nom) => [
         q(5032),
         q(0),
         ],
      q(non) => [
         q(0315),
         q(1),
         ],
      q(nop) => [
         q(5033),
         q(0),
         ],
      q(noq) => [
         q(5034),
         q(0),
         ],
      q(nor) => [
         q(0316),
         q(0),
         ],
      q(nos) => [
         q(5035),
         q(0),
         ],
      q(not) => [
         q(5036),
         q(0),
         ],
      q(nou) => [
         q(5037),
         q(0),
         ],
      q(nov) => [
         q(5038),
         q(0),
         ],
      q(now) => [
         q(5039),
         q(0),
         ],
      q(noy) => [
         q(5040),
         q(0),
         ],
      q(noz) => [
         q(5041),
         q(0),
         ],
      q(npa) => [
         q(5042),
         q(0),
         ],
      q(npb) => [
         q(5043),
         q(0),
         ],
      q(npg) => [
         q(5044),
         q(0),
         ],
      q(nph) => [
         q(5045),
         q(0),
         ],
      q(npi) => [
         q(5046),
         q(0),
         ],
      q(npl) => [
         q(5047),
         q(0),
         ],
      q(npn) => [
         q(5048),
         q(0),
         ],
      q(npo) => [
         q(5049),
         q(0),
         ],
      q(nps) => [
         q(5050),
         q(0),
         ],
      q(npu) => [
         q(5051),
         q(0),
         ],
      q(npy) => [
         q(5052),
         q(0),
         ],
      q(nqg) => [
         q(5053),
         q(0),
         ],
      q(nqk) => [
         q(5054),
         q(0),
         ],
      q(nqm) => [
         q(5055),
         q(0),
         ],
      q(nqn) => [
         q(5056),
         q(0),
         ],
      q(nqo) => [
         q(0317),
         q(0),
         ],
      q(nqq) => [
         q(5057),
         q(0),
         ],
      q(nqy) => [
         q(5058),
         q(0),
         ],
      q(nra) => [
         q(5059),
         q(0),
         ],
      q(nrb) => [
         q(5060),
         q(0),
         ],
      q(nrc) => [
         q(5061),
         q(0),
         ],
      q(nre) => [
         q(5062),
         q(0),
         ],
      q(nrg) => [
         q(5063),
         q(0),
         ],
      q(nri) => [
         q(5064),
         q(0),
         ],
      q(nrk) => [
         q(5065),
         q(0),
         ],
      q(nrl) => [
         q(5066),
         q(0),
         ],
      q(nrm) => [
         q(5067),
         q(0),
         ],
      q(nrn) => [
         q(5068),
         q(0),
         ],
      q(nrp) => [
         q(5069),
         q(0),
         ],
      q(nrr) => [
         q(5070),
         q(0),
         ],
      q(nrt) => [
         q(5071),
         q(0),
         ],
      q(nru) => [
         q(5072),
         q(0),
         ],
      q(nrx) => [
         q(5073),
         q(0),
         ],
      q(nrz) => [
         q(5074),
         q(0),
         ],
      q(nsa) => [
         q(5075),
         q(0),
         ],
      q(nsc) => [
         q(5076),
         q(0),
         ],
      q(nsd) => [
         q(5077),
         q(0),
         ],
      q(nse) => [
         q(5078),
         q(0),
         ],
      q(nsf) => [
         q(5079),
         q(0),
         ],
      q(nsg) => [
         q(5080),
         q(0),
         ],
      q(nsh) => [
         q(5081),
         q(0),
         ],
      q(nsi) => [
         q(5082),
         q(0),
         ],
      q(nsk) => [
         q(5083),
         q(0),
         ],
      q(nsl) => [
         q(5084),
         q(0),
         ],
      q(nsm) => [
         q(5085),
         q(0),
         ],
      q(nsn) => [
         q(5086),
         q(0),
         ],
      q(nso) => [
         q(0318),
         q(0),
         ],
      q(nsp) => [
         q(5087),
         q(0),
         ],
      q(nsq) => [
         q(5088),
         q(0),
         ],
      q(nsr) => [
         q(5089),
         q(0),
         ],
      q(nss) => [
         q(5090),
         q(0),
         ],
      q(nst) => [
         q(5091),
         q(0),
         ],
      q(nsu) => [
         q(5092),
         q(0),
         ],
      q(nsv) => [
         q(5093),
         q(0),
         ],
      q(nsw) => [
         q(5094),
         q(0),
         ],
      q(nsx) => [
         q(5095),
         q(0),
         ],
      q(nsy) => [
         q(5096),
         q(0),
         ],
      q(nsz) => [
         q(5097),
         q(0),
         ],
      q(nte) => [
         q(5098),
         q(0),
         ],
      q(ntg) => [
         q(5099),
         q(0),
         ],
      q(nti) => [
         q(5100),
         q(0),
         ],
      q(ntj) => [
         q(5101),
         q(0),
         ],
      q(ntk) => [
         q(5102),
         q(0),
         ],
      q(ntm) => [
         q(5103),
         q(0),
         ],
      q(nto) => [
         q(5104),
         q(0),
         ],
      q(ntp) => [
         q(5105),
         q(0),
         ],
      q(ntr) => [
         q(5106),
         q(0),
         ],
      q(nts) => [
         q(5107),
         q(0),
         ],
      q(ntu) => [
         q(5108),
         q(0),
         ],
      q(ntw) => [
         q(5109),
         q(0),
         ],
      q(ntx) => [
         q(5110),
         q(0),
         ],
      q(nty) => [
         q(5111),
         q(0),
         ],
      q(ntz) => [
         q(5112),
         q(0),
         ],
      q(nua) => [
         q(5113),
         q(0),
         ],
      q(nub) => [
         q(0319),
         q(0),
         ],
      q(nuc) => [
         q(5114),
         q(0),
         ],
      q(nud) => [
         q(5115),
         q(0),
         ],
      q(nue) => [
         q(5116),
         q(0),
         ],
      q(nuf) => [
         q(5117),
         q(0),
         ],
      q(nug) => [
         q(5118),
         q(0),
         ],
      q(nuh) => [
         q(5119),
         q(0),
         ],
      q(nui) => [
         q(5120),
         q(0),
         ],
      q(nuj) => [
         q(5121),
         q(0),
         ],
      q(nuk) => [
         q(5122),
         q(0),
         ],
      q(nul) => [
         q(5123),
         q(0),
         ],
      q(num) => [
         q(5124),
         q(0),
         ],
      q(nun) => [
         q(5125),
         q(0),
         ],
      q(nuo) => [
         q(5126),
         q(0),
         ],
      q(nup) => [
         q(5127),
         q(0),
         ],
      q(nuq) => [
         q(5128),
         q(0),
         ],
      q(nur) => [
         q(5129),
         q(0),
         ],
      q(nus) => [
         q(5130),
         q(0),
         ],
      q(nut) => [
         q(5131),
         q(0),
         ],
      q(nuu) => [
         q(5132),
         q(0),
         ],
      q(nuv) => [
         q(5133),
         q(0),
         ],
      q(nuw) => [
         q(5134),
         q(0),
         ],
      q(nux) => [
         q(5135),
         q(0),
         ],
      q(nuy) => [
         q(5136),
         q(0),
         ],
      q(nuz) => [
         q(5137),
         q(0),
         ],
      q(nvh) => [
         q(5138),
         q(0),
         ],
      q(nvm) => [
         q(5139),
         q(0),
         ],
      q(nvo) => [
         q(5140),
         q(0),
         ],
      q(nwa) => [
         q(5141),
         q(0),
         ],
      q(nwb) => [
         q(5142),
         q(0),
         ],
      q(nwc) => [
         q(0320),
         q(0),
         ],
      q(nwe) => [
         q(5143),
         q(0),
         ],
      q(nwg) => [
         q(5144),
         q(0),
         ],
      q(nwi) => [
         q(5145),
         q(0),
         ],
      q(nwm) => [
         q(5146),
         q(0),
         ],
      q(nwo) => [
         q(5147),
         q(0),
         ],
      q(nwr) => [
         q(5148),
         q(0),
         ],
      q(nwx) => [
         q(5149),
         q(0),
         ],
      q(nwy) => [
         q(5150),
         q(0),
         ],
      q(nxa) => [
         q(5151),
         q(0),
         ],
      q(nxd) => [
         q(5152),
         q(0),
         ],
      q(nxe) => [
         q(5153),
         q(0),
         ],
      q(nxg) => [
         q(5154),
         q(0),
         ],
      q(nxi) => [
         q(5155),
         q(0),
         ],
      q(nxk) => [
         q(5156),
         q(0),
         ],
      q(nxl) => [
         q(5157),
         q(0),
         ],
      q(nxm) => [
         q(5158),
         q(0),
         ],
      q(nxn) => [
         q(5159),
         q(0),
         ],
      q(nxq) => [
         q(5160),
         q(0),
         ],
      q(nxr) => [
         q(5161),
         q(0),
         ],
      q(nxu) => [
         q(5162),
         q(0),
         ],
      q(nxx) => [
         q(5163),
         q(0),
         ],
      q(nya) => [
         q(0321),
         q(0),
         ],
      q(nyb) => [
         q(5164),
         q(0),
         ],
      q(nyc) => [
         q(5165),
         q(0),
         ],
      q(nyd) => [
         q(5166),
         q(0),
         ],
      q(nye) => [
         q(5167),
         q(0),
         ],
      q(nyf) => [
         q(5168),
         q(0),
         ],
      q(nyg) => [
         q(5169),
         q(0),
         ],
      q(nyh) => [
         q(5170),
         q(0),
         ],
      q(nyi) => [
         q(5171),
         q(0),
         ],
      q(nyj) => [
         q(5172),
         q(0),
         ],
      q(nyk) => [
         q(5173),
         q(0),
         ],
      q(nyl) => [
         q(5174),
         q(0),
         ],
      q(nym) => [
         q(0322),
         q(0),
         ],
      q(nyn) => [
         q(0323),
         q(0),
         ],
      q(nyo) => [
         q(0324),
         q(0),
         ],
      q(nyp) => [
         q(5175),
         q(0),
         ],
      q(nyq) => [
         q(5176),
         q(0),
         ],
      q(nyr) => [
         q(5177),
         q(0),
         ],
      q(nys) => [
         q(5178),
         q(0),
         ],
      q(nyt) => [
         q(5179),
         q(0),
         ],
      q(nyu) => [
         q(5180),
         q(0),
         ],
      q(nyv) => [
         q(5181),
         q(0),
         ],
      q(nyw) => [
         q(5182),
         q(0),
         ],
      q(nyx) => [
         q(5183),
         q(0),
         ],
      q(nyy) => [
         q(5184),
         q(0),
         ],
      q(nza) => [
         q(5185),
         q(0),
         ],
      q(nzb) => [
         q(5186),
         q(0),
         ],
      q(nzi) => [
         q(0325),
         q(0),
         ],
      q(nzk) => [
         q(5187),
         q(0),
         ],
      q(nzm) => [
         q(5188),
         q(0),
         ],
      q(nzs) => [
         q(5189),
         q(0),
         ],
      q(nzu) => [
         q(5190),
         q(0),
         ],
      q(nzy) => [
         q(5191),
         q(0),
         ],
      q(nzz) => [
         q(5192),
         q(0),
         ],
      q(oaa) => [
         q(5193),
         q(0),
         ],
      q(oac) => [
         q(5194),
         q(0),
         ],
      q(oar) => [
         q(5195),
         q(0),
         ],
      q(oav) => [
         q(5196),
         q(0),
         ],
      q(obi) => [
         q(5197),
         q(0),
         ],
      q(obk) => [
         q(5198),
         q(0),
         ],
      q(obl) => [
         q(5199),
         q(0),
         ],
      q(obm) => [
         q(5200),
         q(0),
         ],
      q(obo) => [
         q(5201),
         q(0),
         ],
      q(obr) => [
         q(5202),
         q(0),
         ],
      q(obt) => [
         q(5203),
         q(0),
         ],
      q(obu) => [
         q(5204),
         q(0),
         ],
      q(oca) => [
         q(5205),
         q(0),
         ],
      q(och) => [
         q(5206),
         q(0),
         ],
      q(oci) => [
         q(0326),
         q(0),
         ],
      q(oco) => [
         q(5207),
         q(0),
         ],
      q(ocu) => [
         q(5208),
         q(0),
         ],
      q(oda) => [
         q(5209),
         q(0),
         ],
      q(odk) => [
         q(5210),
         q(0),
         ],
      q(odt) => [
         q(5211),
         q(0),
         ],
      q(odu) => [
         q(5212),
         q(0),
         ],
      q(ofo) => [
         q(5213),
         q(0),
         ],
      q(ofs) => [
         q(5214),
         q(0),
         ],
      q(ofu) => [
         q(5215),
         q(0),
         ],
      q(ogb) => [
         q(5216),
         q(0),
         ],
      q(ogc) => [
         q(5217),
         q(0),
         ],
      q(oge) => [
         q(5218),
         q(0),
         ],
      q(ogg) => [
         q(5219),
         q(0),
         ],
      q(ogo) => [
         q(5220),
         q(0),
         ],
      q(ogu) => [
         q(5221),
         q(0),
         ],
      q(oht) => [
         q(5222),
         q(0),
         ],
      q(ohu) => [
         q(5223),
         q(0),
         ],
      q(oia) => [
         q(5224),
         q(0),
         ],
      q(oin) => [
         q(5225),
         q(0),
         ],
      q(ojb) => [
         q(5226),
         q(0),
         ],
      q(ojc) => [
         q(5227),
         q(0),
         ],
      q(ojg) => [
         q(5228),
         q(0),
         ],
      q(oji) => [
         q(0327),
         q(0),
         ],
      q(ojp) => [
         q(5229),
         q(0),
         ],
      q(ojs) => [
         q(5230),
         q(0),
         ],
      q(ojv) => [
         q(5231),
         q(0),
         ],
      q(ojw) => [
         q(5232),
         q(0),
         ],
      q(oka) => [
         q(5233),
         q(0),
         ],
      q(okb) => [
         q(5234),
         q(0),
         ],
      q(okd) => [
         q(5235),
         q(0),
         ],
      q(oke) => [
         q(5236),
         q(0),
         ],
      q(okg) => [
         q(5237),
         q(0),
         ],
      q(okh) => [
         q(5238),
         q(0),
         ],
      q(oki) => [
         q(5239),
         q(0),
         ],
      q(okj) => [
         q(5240),
         q(0),
         ],
      q(okk) => [
         q(5241),
         q(0),
         ],
      q(okl) => [
         q(5242),
         q(0),
         ],
      q(okm) => [
         q(5243),
         q(0),
         ],
      q(okn) => [
         q(5244),
         q(0),
         ],
      q(oko) => [
         q(5245),
         q(0),
         ],
      q(okr) => [
         q(5246),
         q(0),
         ],
      q(oks) => [
         q(5247),
         q(0),
         ],
      q(oku) => [
         q(5248),
         q(0),
         ],
      q(okv) => [
         q(5249),
         q(0),
         ],
      q(okx) => [
         q(5250),
         q(0),
         ],
      q(ola) => [
         q(5251),
         q(0),
         ],
      q(old) => [
         q(5252),
         q(0),
         ],
      q(ole) => [
         q(5253),
         q(0),
         ],
      q(olk) => [
         q(5254),
         q(0),
         ],
      q(olm) => [
         q(5255),
         q(0),
         ],
      q(olo) => [
         q(5256),
         q(0),
         ],
      q(olr) => [
         q(5257),
         q(0),
         ],
      q(oma) => [
         q(5258),
         q(0),
         ],
      q(omb) => [
         q(5259),
         q(0),
         ],
      q(omc) => [
         q(5260),
         q(0),
         ],
      q(ome) => [
         q(5261),
         q(0),
         ],
      q(omg) => [
         q(5262),
         q(0),
         ],
      q(omi) => [
         q(5263),
         q(0),
         ],
      q(omk) => [
         q(5264),
         q(0),
         ],
      q(oml) => [
         q(5265),
         q(0),
         ],
      q(omn) => [
         q(5266),
         q(0),
         ],
      q(omo) => [
         q(5267),
         q(0),
         ],
      q(omp) => [
         q(5268),
         q(0),
         ],
      q(omq) => [
         q(0517),
         q(0),
         ],
      q(omr) => [
         q(5269),
         q(0),
         ],
      q(omt) => [
         q(5270),
         q(0),
         ],
      q(omu) => [
         q(5271),
         q(0),
         ],
      q(omv) => [
         q(0518),
         q(0),
         ],
      q(omw) => [
         q(5272),
         q(0),
         ],
      q(omx) => [
         q(5273),
         q(0),
         ],
      q(ona) => [
         q(5274),
         q(0),
         ],
      q(onb) => [
         q(5275),
         q(0),
         ],
      q(one) => [
         q(5276),
         q(0),
         ],
      q(ong) => [
         q(5277),
         q(0),
         ],
      q(oni) => [
         q(5278),
         q(0),
         ],
      q(onj) => [
         q(5279),
         q(0),
         ],
      q(onk) => [
         q(5280),
         q(0),
         ],
      q(onn) => [
         q(5281),
         q(0),
         ],
      q(ono) => [
         q(5282),
         q(0),
         ],
      q(onp) => [
         q(5283),
         q(0),
         ],
      q(onr) => [
         q(5284),
         q(0),
         ],
      q(ons) => [
         q(5285),
         q(0),
         ],
      q(ont) => [
         q(5286),
         q(0),
         ],
      q(onu) => [
         q(5287),
         q(0),
         ],
      q(onw) => [
         q(5288),
         q(0),
         ],
      q(onx) => [
         q(5289),
         q(0),
         ],
      q(ood) => [
         q(5290),
         q(0),
         ],
      q(oog) => [
         q(5291),
         q(0),
         ],
      q(oon) => [
         q(5292),
         q(0),
         ],
      q(oor) => [
         q(5293),
         q(0),
         ],
      q(oos) => [
         q(5294),
         q(0),
         ],
      q(opa) => [
         q(5295),
         q(0),
         ],
      q(opk) => [
         q(5296),
         q(0),
         ],
      q(opm) => [
         q(5297),
         q(0),
         ],
      q(opo) => [
         q(5298),
         q(0),
         ],
      q(opt) => [
         q(5299),
         q(0),
         ],
      q(opy) => [
         q(5300),
         q(0),
         ],
      q(ora) => [
         q(5301),
         q(0),
         ],
      q(orc) => [
         q(5302),
         q(0),
         ],
      q(ore) => [
         q(5303),
         q(0),
         ],
      q(org) => [
         q(5304),
         q(0),
         ],
      q(orh) => [
         q(5305),
         q(0),
         ],
      q(ori) => [
         q(0328),
         q(0),
         ],
      q(orm) => [
         q(0329),
         q(0),
         ],
      q(orn) => [
         q(5306),
         q(0),
         ],
      q(oro) => [
         q(5307),
         q(0),
         ],
      q(orr) => [
         q(5308),
         q(0),
         ],
      q(ors) => [
         q(5309),
         q(0),
         ],
      q(ort) => [
         q(5310),
         q(0),
         ],
      q(oru) => [
         q(5311),
         q(0),
         ],
      q(orv) => [
         q(5312),
         q(0),
         ],
      q(orw) => [
         q(5313),
         q(0),
         ],
      q(orx) => [
         q(5314),
         q(0),
         ],
      q(ory) => [
         q(5315),
         q(0),
         ],
      q(orz) => [
         q(5316),
         q(0),
         ],
      q(osa) => [
         q(0330),
         q(0),
         ],
      q(osc) => [
         q(5317),
         q(0),
         ],
      q(osi) => [
         q(5318),
         q(0),
         ],
      q(oso) => [
         q(5319),
         q(0),
         ],
      q(osp) => [
         q(5320),
         q(0),
         ],
      q(oss) => [
         q(0331),
         q(0),
         ],
      q(ost) => [
         q(5321),
         q(0),
         ],
      q(osu) => [
         q(5322),
         q(0),
         ],
      q(osx) => [
         q(5323),
         q(0),
         ],
      q(ota) => [
         q(0332),
         q(1),
         ],
      q(otb) => [
         q(5324),
         q(0),
         ],
      q(otd) => [
         q(5325),
         q(0),
         ],
      q(ote) => [
         q(5326),
         q(0),
         ],
      q(oti) => [
         q(5327),
         q(0),
         ],
      q(otk) => [
         q(5328),
         q(0),
         ],
      q(otl) => [
         q(5329),
         q(0),
         ],
      q(otm) => [
         q(5330),
         q(0),
         ],
      q(otn) => [
         q(5331),
         q(0),
         ],
      q(oto) => [
         q(0333),
         q(0),
         ],
      q(otq) => [
         q(5332),
         q(0),
         ],
      q(otr) => [
         q(5333),
         q(0),
         ],
      q(ots) => [
         q(5334),
         q(0),
         ],
      q(ott) => [
         q(5335),
         q(0),
         ],
      q(otu) => [
         q(5336),
         q(0),
         ],
      q(otw) => [
         q(5337),
         q(0),
         ],
      q(otx) => [
         q(5338),
         q(0),
         ],
      q(oty) => [
         q(5339),
         q(0),
         ],
      q(otz) => [
         q(5340),
         q(0),
         ],
      q(oua) => [
         q(5341),
         q(0),
         ],
      q(oub) => [
         q(5342),
         q(0),
         ],
      q(oue) => [
         q(5343),
         q(0),
         ],
      q(oui) => [
         q(5344),
         q(0),
         ],
      q(oum) => [
         q(5345),
         q(0),
         ],
      q(oun) => [
         q(5346),
         q(0),
         ],
      q(owi) => [
         q(5347),
         q(0),
         ],
      q(owl) => [
         q(5348),
         q(0),
         ],
      q(oyb) => [
         q(5349),
         q(0),
         ],
      q(oyd) => [
         q(5350),
         q(0),
         ],
      q(oym) => [
         q(5351),
         q(0),
         ],
      q(oyy) => [
         q(5352),
         q(0),
         ],
      q(ozm) => [
         q(5353),
         q(0),
         ],
      q(paa) => [
         q(0334),
         q(0),
         ],
      q(pab) => [
         q(5354),
         q(0),
         ],
      q(pac) => [
         q(5355),
         q(0),
         ],
      q(pad) => [
         q(5356),
         q(0),
         ],
      q(pae) => [
         q(5357),
         q(0),
         ],
      q(paf) => [
         q(5358),
         q(0),
         ],
      q(pag) => [
         q(0335),
         q(0),
         ],
      q(pah) => [
         q(5359),
         q(0),
         ],
      q(pai) => [
         q(5360),
         q(0),
         ],
      q(pak) => [
         q(5361),
         q(0),
         ],
      q(pal) => [
         q(0336),
         q(0),
         ],
      q(pam) => [
         q(0337),
         q(0),
         ],
      q(pan) => [
         q(0338),
         q(0),
         ],
      q(pao) => [
         q(5362),
         q(0),
         ],
      q(pap) => [
         q(0339),
         q(0),
         ],
      q(paq) => [
         q(5363),
         q(0),
         ],
      q(par) => [
         q(5364),
         q(0),
         ],
      q(pas) => [
         q(5365),
         q(0),
         ],
      q(pat) => [
         q(5366),
         q(0),
         ],
      q(pau) => [
         q(0340),
         q(0),
         ],
      q(pav) => [
         q(5367),
         q(0),
         ],
      q(paw) => [
         q(5368),
         q(0),
         ],
      q(pax) => [
         q(5369),
         q(0),
         ],
      q(pay) => [
         q(5370),
         q(0),
         ],
      q(paz) => [
         q(5371),
         q(0),
         ],
      q(pbb) => [
         q(5372),
         q(0),
         ],
      q(pbc) => [
         q(5373),
         q(0),
         ],
      q(pbe) => [
         q(5374),
         q(0),
         ],
      q(pbf) => [
         q(5375),
         q(0),
         ],
      q(pbg) => [
         q(5376),
         q(0),
         ],
      q(pbh) => [
         q(5377),
         q(0),
         ],
      q(pbi) => [
         q(5378),
         q(0),
         ],
      q(pbl) => [
         q(5379),
         q(0),
         ],
      q(pbn) => [
         q(5380),
         q(0),
         ],
      q(pbo) => [
         q(5381),
         q(0),
         ],
      q(pbp) => [
         q(5382),
         q(0),
         ],
      q(pbr) => [
         q(5383),
         q(0),
         ],
      q(pbs) => [
         q(5384),
         q(0),
         ],
      q(pbt) => [
         q(5385),
         q(0),
         ],
      q(pbu) => [
         q(5386),
         q(0),
         ],
      q(pbv) => [
         q(5387),
         q(0),
         ],
      q(pby) => [
         q(5388),
         q(0),
         ],
      q(pca) => [
         q(5389),
         q(0),
         ],
      q(pcb) => [
         q(5390),
         q(0),
         ],
      q(pcc) => [
         q(5391),
         q(0),
         ],
      q(pcd) => [
         q(5392),
         q(0),
         ],
      q(pce) => [
         q(5393),
         q(0),
         ],
      q(pcf) => [
         q(5394),
         q(0),
         ],
      q(pcg) => [
         q(5395),
         q(0),
         ],
      q(pch) => [
         q(5396),
         q(0),
         ],
      q(pci) => [
         q(5397),
         q(0),
         ],
      q(pcj) => [
         q(5398),
         q(0),
         ],
      q(pck) => [
         q(5399),
         q(0),
         ],
      q(pcl) => [
         q(5400),
         q(0),
         ],
      q(pcm) => [
         q(5401),
         q(0),
         ],
      q(pcn) => [
         q(5402),
         q(0),
         ],
      q(pcp) => [
         q(5403),
         q(0),
         ],
      q(pcw) => [
         q(5404),
         q(0),
         ],
      q(pda) => [
         q(5405),
         q(0),
         ],
      q(pdc) => [
         q(5406),
         q(0),
         ],
      q(pdi) => [
         q(5407),
         q(0),
         ],
      q(pdn) => [
         q(5408),
         q(0),
         ],
      q(pdo) => [
         q(5409),
         q(0),
         ],
      q(pdt) => [
         q(5410),
         q(0),
         ],
      q(pdu) => [
         q(5411),
         q(0),
         ],
      q(pea) => [
         q(5412),
         q(0),
         ],
      q(peb) => [
         q(5413),
         q(0),
         ],
      q(ped) => [
         q(5414),
         q(0),
         ],
      q(pee) => [
         q(5415),
         q(0),
         ],
      q(pef) => [
         q(5416),
         q(0),
         ],
      q(peg) => [
         q(5417),
         q(0),
         ],
      q(peh) => [
         q(5418),
         q(0),
         ],
      q(pei) => [
         q(5419),
         q(0),
         ],
      q(pej) => [
         q(5420),
         q(0),
         ],
      q(pek) => [
         q(5421),
         q(0),
         ],
      q(pel) => [
         q(5422),
         q(0),
         ],
      q(pem) => [
         q(5423),
         q(0),
         ],
      q(peo) => [
         q(0341),
         q(1),
         ],
      q(pep) => [
         q(5424),
         q(0),
         ],
      q(peq) => [
         q(5425),
         q(0),
         ],
      q(per) => [
         q(0342),
         q(0),
         ],
      q(pes) => [
         q(5426),
         q(0),
         ],
      q(pev) => [
         q(5427),
         q(0),
         ],
      q(pex) => [
         q(5428),
         q(0),
         ],
      q(pey) => [
         q(5429),
         q(0),
         ],
      q(pez) => [
         q(5430),
         q(0),
         ],
      q(pfa) => [
         q(5431),
         q(0),
         ],
      q(pfe) => [
         q(5432),
         q(0),
         ],
      q(pfl) => [
         q(5433),
         q(0),
         ],
      q(pga) => [
         q(5434),
         q(0),
         ],
      q(pgg) => [
         q(5435),
         q(0),
         ],
      q(pgi) => [
         q(5436),
         q(0),
         ],
      q(pgk) => [
         q(5437),
         q(0),
         ],
      q(pgl) => [
         q(5438),
         q(0),
         ],
      q(pgn) => [
         q(5439),
         q(0),
         ],
      q(pgs) => [
         q(5440),
         q(0),
         ],
      q(pgu) => [
         q(5441),
         q(0),
         ],
      q(pha) => [
         q(5442),
         q(0),
         ],
      q(phd) => [
         q(5443),
         q(0),
         ],
      q(phg) => [
         q(5444),
         q(0),
         ],
      q(phh) => [
         q(5445),
         q(0),
         ],
      q(phi) => [
         q(0343),
         q(0),
         ],
      q(phk) => [
         q(5446),
         q(0),
         ],
      q(phl) => [
         q(5447),
         q(0),
         ],
      q(phm) => [
         q(5448),
         q(0),
         ],
      q(phn) => [
         q(0344),
         q(0),
         ],
      q(pho) => [
         q(5449),
         q(0),
         ],
      q(phq) => [
         q(5450),
         q(0),
         ],
      q(phr) => [
         q(5451),
         q(0),
         ],
      q(pht) => [
         q(5452),
         q(0),
         ],
      q(phu) => [
         q(5453),
         q(0),
         ],
      q(phv) => [
         q(5454),
         q(0),
         ],
      q(phw) => [
         q(5455),
         q(0),
         ],
      q(pia) => [
         q(5456),
         q(0),
         ],
      q(pib) => [
         q(5457),
         q(0),
         ],
      q(pic) => [
         q(5458),
         q(0),
         ],
      q(pid) => [
         q(5459),
         q(0),
         ],
      q(pie) => [
         q(5460),
         q(0),
         ],
      q(pif) => [
         q(5461),
         q(0),
         ],
      q(pig) => [
         q(5462),
         q(0),
         ],
      q(pih) => [
         q(5463),
         q(0),
         ],
      q(pii) => [
         q(5464),
         q(0),
         ],
      q(pij) => [
         q(5465),
         q(0),
         ],
      q(pil) => [
         q(5466),
         q(0),
         ],
      q(pim) => [
         q(5467),
         q(0),
         ],
      q(pin) => [
         q(5468),
         q(0),
         ],
      q(pio) => [
         q(5469),
         q(0),
         ],
      q(pip) => [
         q(5470),
         q(0),
         ],
      q(pir) => [
         q(5471),
         q(0),
         ],
      q(pis) => [
         q(5472),
         q(0),
         ],
      q(pit) => [
         q(5473),
         q(0),
         ],
      q(piu) => [
         q(5474),
         q(0),
         ],
      q(piv) => [
         q(5475),
         q(0),
         ],
      q(piw) => [
         q(5476),
         q(0),
         ],
      q(pix) => [
         q(5477),
         q(0),
         ],
      q(piy) => [
         q(5478),
         q(0),
         ],
      q(piz) => [
         q(5479),
         q(0),
         ],
      q(pjt) => [
         q(5480),
         q(0),
         ],
      q(pka) => [
         q(5481),
         q(0),
         ],
      q(pkb) => [
         q(5482),
         q(0),
         ],
      q(pkc) => [
         q(5483),
         q(0),
         ],
      q(pkg) => [
         q(5484),
         q(0),
         ],
      q(pkh) => [
         q(5485),
         q(0),
         ],
      q(pkn) => [
         q(5486),
         q(0),
         ],
      q(pko) => [
         q(5487),
         q(0),
         ],
      q(pkp) => [
         q(5488),
         q(0),
         ],
      q(pkr) => [
         q(5489),
         q(0),
         ],
      q(pks) => [
         q(5490),
         q(0),
         ],
      q(pkt) => [
         q(5491),
         q(0),
         ],
      q(pku) => [
         q(5492),
         q(0),
         ],
      q(pla) => [
         q(5493),
         q(0),
         ],
      q(plb) => [
         q(5494),
         q(0),
         ],
      q(plc) => [
         q(5495),
         q(0),
         ],
      q(pld) => [
         q(5496),
         q(0),
         ],
      q(ple) => [
         q(5497),
         q(0),
         ],
      q(plf) => [
         q(0519),
         q(0),
         ],
      q(plg) => [
         q(5498),
         q(0),
         ],
      q(plh) => [
         q(5499),
         q(0),
         ],
      q(pli) => [
         q(0345),
         q(0),
         ],
      q(plj) => [
         q(5500),
         q(0),
         ],
      q(plk) => [
         q(5501),
         q(0),
         ],
      q(pll) => [
         q(5502),
         q(0),
         ],
      q(pln) => [
         q(5503),
         q(0),
         ],
      q(plo) => [
         q(5504),
         q(0),
         ],
      q(plp) => [
         q(5505),
         q(0),
         ],
      q(plq) => [
         q(5506),
         q(0),
         ],
      q(plr) => [
         q(5507),
         q(0),
         ],
      q(pls) => [
         q(5508),
         q(0),
         ],
      q(plt) => [
         q(5509),
         q(0),
         ],
      q(plu) => [
         q(5510),
         q(0),
         ],
      q(plv) => [
         q(5511),
         q(0),
         ],
      q(plw) => [
         q(5512),
         q(0),
         ],
      q(ply) => [
         q(5513),
         q(0),
         ],
      q(plz) => [
         q(5514),
         q(0),
         ],
      q(pma) => [
         q(5515),
         q(0),
         ],
      q(pmb) => [
         q(5516),
         q(0),
         ],
      q(pmc) => [
         q(5517),
         q(0),
         ],
      q(pmd) => [
         q(5518),
         q(0),
         ],
      q(pme) => [
         q(5519),
         q(0),
         ],
      q(pmf) => [
         q(5520),
         q(0),
         ],
      q(pmh) => [
         q(5521),
         q(0),
         ],
      q(pmi) => [
         q(5522),
         q(0),
         ],
      q(pmj) => [
         q(5523),
         q(0),
         ],
      q(pmk) => [
         q(5524),
         q(0),
         ],
      q(pml) => [
         q(5525),
         q(0),
         ],
      q(pmm) => [
         q(5526),
         q(0),
         ],
      q(pmn) => [
         q(5527),
         q(0),
         ],
      q(pmo) => [
         q(5528),
         q(0),
         ],
      q(pmq) => [
         q(5529),
         q(0),
         ],
      q(pmr) => [
         q(5530),
         q(0),
         ],
      q(pms) => [
         q(5531),
         q(0),
         ],
      q(pmt) => [
         q(5532),
         q(0),
         ],
      q(pmu) => [
         q(5533),
         q(0),
         ],
      q(pmw) => [
         q(5534),
         q(0),
         ],
      q(pmx) => [
         q(5535),
         q(0),
         ],
      q(pmy) => [
         q(5536),
         q(0),
         ],
      q(pmz) => [
         q(5537),
         q(0),
         ],
      q(pna) => [
         q(5538),
         q(0),
         ],
      q(pnb) => [
         q(5539),
         q(0),
         ],
      q(pnc) => [
         q(5540),
         q(0),
         ],
      q(pne) => [
         q(5541),
         q(0),
         ],
      q(png) => [
         q(5542),
         q(0),
         ],
      q(pnh) => [
         q(5543),
         q(0),
         ],
      q(pni) => [
         q(5544),
         q(0),
         ],
      q(pnj) => [
         q(5545),
         q(0),
         ],
      q(pnk) => [
         q(5546),
         q(0),
         ],
      q(pnl) => [
         q(5547),
         q(0),
         ],
      q(pnm) => [
         q(5548),
         q(0),
         ],
      q(pnn) => [
         q(5549),
         q(0),
         ],
      q(pno) => [
         q(5550),
         q(0),
         ],
      q(pnp) => [
         q(5551),
         q(0),
         ],
      q(pnq) => [
         q(5552),
         q(0),
         ],
      q(pnr) => [
         q(5553),
         q(0),
         ],
      q(pns) => [
         q(5554),
         q(0),
         ],
      q(pnt) => [
         q(5555),
         q(0),
         ],
      q(pnu) => [
         q(5556),
         q(0),
         ],
      q(pnv) => [
         q(5557),
         q(0),
         ],
      q(pnw) => [
         q(5558),
         q(0),
         ],
      q(pnx) => [
         q(5559),
         q(0),
         ],
      q(pny) => [
         q(5560),
         q(0),
         ],
      q(pnz) => [
         q(5561),
         q(0),
         ],
      q(poc) => [
         q(5562),
         q(0),
         ],
      q(pod) => [
         q(5563),
         q(0),
         ],
      q(poe) => [
         q(5564),
         q(0),
         ],
      q(pof) => [
         q(5565),
         q(0),
         ],
      q(pog) => [
         q(5566),
         q(0),
         ],
      q(poh) => [
         q(5567),
         q(0),
         ],
      q(poi) => [
         q(5568),
         q(0),
         ],
      q(pok) => [
         q(5569),
         q(0),
         ],
      q(pol) => [
         q(0346),
         q(0),
         ],
      q(pom) => [
         q(5570),
         q(0),
         ],
      q(pon) => [
         q(0347),
         q(0),
         ],
      q(poo) => [
         q(5571),
         q(0),
         ],
      q(pop) => [
         q(5572),
         q(0),
         ],
      q(poq) => [
         q(5573),
         q(0),
         ],
      q(por) => [
         q(0348),
         q(0),
         ],
      q(pos) => [
         q(5574),
         q(0),
         ],
      q(pot) => [
         q(5575),
         q(0),
         ],
      q(pov) => [
         q(5576),
         q(0),
         ],
      q(pow) => [
         q(5577),
         q(0),
         ],
      q(pox) => [
         q(5578),
         q(0),
         ],
      q(poy) => [
         q(5579),
         q(0),
         ],
      q(poz) => [
         q(0520),
         q(0),
         ],
      q(ppa) => [
         q(5580),
         q(0),
         ],
      q(ppe) => [
         q(5581),
         q(0),
         ],
      q(ppi) => [
         q(5582),
         q(0),
         ],
      q(ppk) => [
         q(5583),
         q(0),
         ],
      q(ppl) => [
         q(5584),
         q(0),
         ],
      q(ppm) => [
         q(5585),
         q(0),
         ],
      q(ppn) => [
         q(5586),
         q(0),
         ],
      q(ppo) => [
         q(5587),
         q(0),
         ],
      q(ppp) => [
         q(5588),
         q(0),
         ],
      q(ppq) => [
         q(5589),
         q(0),
         ],
      q(pps) => [
         q(5590),
         q(0),
         ],
      q(ppt) => [
         q(5591),
         q(0),
         ],
      q(ppu) => [
         q(5592),
         q(0),
         ],
      q(pqa) => [
         q(5593),
         q(0),
         ],
      q(pqe) => [
         q(0521),
         q(0),
         ],
      q(pqm) => [
         q(5594),
         q(0),
         ],
      q(pqw) => [
         q(0522),
         q(0),
         ],
      q(pra) => [
         q(0349),
         q(0),
         ],
      q(prb) => [
         q(5595),
         q(0),
         ],
      q(prc) => [
         q(5596),
         q(0),
         ],
      q(prd) => [
         q(5597),
         q(0),
         ],
      q(pre) => [
         q(5598),
         q(0),
         ],
      q(prf) => [
         q(5599),
         q(0),
         ],
      q(prg) => [
         q(5600),
         q(0),
         ],
      q(prh) => [
         q(5601),
         q(0),
         ],
      q(pri) => [
         q(5602),
         q(0),
         ],
      q(prk) => [
         q(5603),
         q(0),
         ],
      q(prl) => [
         q(5604),
         q(0),
         ],
      q(prm) => [
         q(5605),
         q(0),
         ],
      q(prn) => [
         q(5606),
         q(0),
         ],
      q(pro) => [
         q(0350),
         q(1),
         ],
      q(prp) => [
         q(5607),
         q(0),
         ],
      q(prq) => [
         q(5608),
         q(0),
         ],
      q(prr) => [
         q(5609),
         q(0),
         ],
      q(prs) => [
         q(5610),
         q(0),
         ],
      q(prt) => [
         q(5611),
         q(0),
         ],
      q(pru) => [
         q(5612),
         q(0),
         ],
      q(prw) => [
         q(5613),
         q(0),
         ],
      q(prx) => [
         q(5614),
         q(0),
         ],
      q(pry) => [
         q(5615),
         q(0),
         ],
      q(prz) => [
         q(5616),
         q(0),
         ],
      q(psa) => [
         q(5617),
         q(0),
         ],
      q(psc) => [
         q(5618),
         q(0),
         ],
      q(psd) => [
         q(5619),
         q(0),
         ],
      q(pse) => [
         q(5620),
         q(0),
         ],
      q(psg) => [
         q(5621),
         q(0),
         ],
      q(psh) => [
         q(5622),
         q(0),
         ],
      q(psi) => [
         q(5623),
         q(0),
         ],
      q(psl) => [
         q(5624),
         q(0),
         ],
      q(psm) => [
         q(5625),
         q(0),
         ],
      q(psn) => [
         q(5626),
         q(0),
         ],
      q(pso) => [
         q(5627),
         q(0),
         ],
      q(psp) => [
         q(5628),
         q(0),
         ],
      q(psq) => [
         q(5629),
         q(0),
         ],
      q(psr) => [
         q(5630),
         q(0),
         ],
      q(pss) => [
         q(5631),
         q(0),
         ],
      q(pst) => [
         q(5632),
         q(0),
         ],
      q(psu) => [
         q(5633),
         q(0),
         ],
      q(psw) => [
         q(5634),
         q(0),
         ],
      q(psy) => [
         q(5635),
         q(0),
         ],
      q(pta) => [
         q(5636),
         q(0),
         ],
      q(pth) => [
         q(5637),
         q(0),
         ],
      q(pti) => [
         q(5638),
         q(0),
         ],
      q(ptn) => [
         q(5639),
         q(0),
         ],
      q(pto) => [
         q(5640),
         q(0),
         ],
      q(ptp) => [
         q(5641),
         q(0),
         ],
      q(ptr) => [
         q(5642),
         q(0),
         ],
      q(ptt) => [
         q(5643),
         q(0),
         ],
      q(ptu) => [
         q(5644),
         q(0),
         ],
      q(ptv) => [
         q(5645),
         q(0),
         ],
      q(ptw) => [
         q(5646),
         q(0),
         ],
      q(pty) => [
         q(5647),
         q(0),
         ],
      q(pua) => [
         q(5648),
         q(0),
         ],
      q(pub) => [
         q(5649),
         q(0),
         ],
      q(puc) => [
         q(5650),
         q(0),
         ],
      q(pud) => [
         q(5651),
         q(0),
         ],
      q(pue) => [
         q(5652),
         q(0),
         ],
      q(puf) => [
         q(5653),
         q(0),
         ],
      q(pug) => [
         q(5654),
         q(0),
         ],
      q(pui) => [
         q(5655),
         q(0),
         ],
      q(puj) => [
         q(5656),
         q(0),
         ],
      q(puk) => [
         q(5657),
         q(0),
         ],
      q(pum) => [
         q(5658),
         q(0),
         ],
      q(puo) => [
         q(5659),
         q(0),
         ],
      q(pup) => [
         q(5660),
         q(0),
         ],
      q(puq) => [
         q(5661),
         q(0),
         ],
      q(pur) => [
         q(5662),
         q(0),
         ],
      q(pus) => [
         q(0351),
         q(0),
         ],
      q(put) => [
         q(5663),
         q(0),
         ],
      q(puu) => [
         q(5664),
         q(0),
         ],
      q(puw) => [
         q(5665),
         q(0),
         ],
      q(pux) => [
         q(5666),
         q(0),
         ],
      q(puy) => [
         q(5667),
         q(0),
         ],
      q(puz) => [
         q(5668),
         q(0),
         ],
      q(pwa) => [
         q(5669),
         q(0),
         ],
      q(pwb) => [
         q(5670),
         q(0),
         ],
      q(pwg) => [
         q(5671),
         q(0),
         ],
      q(pwi) => [
         q(5672),
         q(0),
         ],
      q(pwm) => [
         q(5673),
         q(0),
         ],
      q(pwn) => [
         q(5674),
         q(0),
         ],
      q(pwo) => [
         q(5675),
         q(0),
         ],
      q(pwr) => [
         q(5676),
         q(0),
         ],
      q(pww) => [
         q(5677),
         q(0),
         ],
      q(pxm) => [
         q(5678),
         q(0),
         ],
      q(pye) => [
         q(5679),
         q(0),
         ],
      q(pym) => [
         q(5680),
         q(0),
         ],
      q(pyn) => [
         q(5681),
         q(0),
         ],
      q(pys) => [
         q(5682),
         q(0),
         ],
      q(pyu) => [
         q(5683),
         q(0),
         ],
      q(pyx) => [
         q(5684),
         q(0),
         ],
      q(pyy) => [
         q(5685),
         q(0),
         ],
      q(pzn) => [
         q(5686),
         q(0),
         ],
      q(qtz) => [
         q(0352),
         q(0),
         ],
      q(qua) => [
         q(5687),
         q(0),
         ],
      q(qub) => [
         q(5688),
         q(0),
         ],
      q(quc) => [
         q(5689),
         q(0),
         ],
      q(qud) => [
         q(5690),
         q(0),
         ],
      q(que) => [
         q(0353),
         q(0),
         ],
      q(quf) => [
         q(5691),
         q(0),
         ],
      q(qug) => [
         q(5692),
         q(0),
         ],
      q(quh) => [
         q(5693),
         q(0),
         ],
      q(qui) => [
         q(5694),
         q(0),
         ],
      q(quk) => [
         q(5695),
         q(0),
         ],
      q(qul) => [
         q(5696),
         q(0),
         ],
      q(qum) => [
         q(5697),
         q(0),
         ],
      q(qun) => [
         q(5698),
         q(0),
         ],
      q(qup) => [
         q(5699),
         q(0),
         ],
      q(quq) => [
         q(5700),
         q(0),
         ],
      q(qur) => [
         q(5701),
         q(0),
         ],
      q(qus) => [
         q(5702),
         q(0),
         ],
      q(quv) => [
         q(5703),
         q(0),
         ],
      q(quw) => [
         q(5704),
         q(0),
         ],
      q(qux) => [
         q(5705),
         q(0),
         ],
      q(quy) => [
         q(5706),
         q(0),
         ],
      q(quz) => [
         q(5707),
         q(0),
         ],
      q(qva) => [
         q(5708),
         q(0),
         ],
      q(qvc) => [
         q(5709),
         q(0),
         ],
      q(qve) => [
         q(5710),
         q(0),
         ],
      q(qvh) => [
         q(5711),
         q(0),
         ],
      q(qvi) => [
         q(5712),
         q(0),
         ],
      q(qvj) => [
         q(5713),
         q(0),
         ],
      q(qvl) => [
         q(5714),
         q(0),
         ],
      q(qvm) => [
         q(5715),
         q(0),
         ],
      q(qvn) => [
         q(5716),
         q(0),
         ],
      q(qvo) => [
         q(5717),
         q(0),
         ],
      q(qvp) => [
         q(5718),
         q(0),
         ],
      q(qvs) => [
         q(5719),
         q(0),
         ],
      q(qvw) => [
         q(5720),
         q(0),
         ],
      q(qvy) => [
         q(5721),
         q(0),
         ],
      q(qvz) => [
         q(5722),
         q(0),
         ],
      q(qwa) => [
         q(5723),
         q(0),
         ],
      q(qwc) => [
         q(5724),
         q(0),
         ],
      q(qwe) => [
         q(0523),
         q(0),
         ],
      q(qwh) => [
         q(5725),
         q(0),
         ],
      q(qwm) => [
         q(5726),
         q(0),
         ],
      q(qws) => [
         q(5727),
         q(0),
         ],
      q(qwt) => [
         q(5728),
         q(0),
         ],
      q(qxa) => [
         q(5729),
         q(0),
         ],
      q(qxc) => [
         q(5730),
         q(0),
         ],
      q(qxh) => [
         q(5731),
         q(0),
         ],
      q(qxl) => [
         q(5732),
         q(0),
         ],
      q(qxn) => [
         q(5733),
         q(0),
         ],
      q(qxo) => [
         q(5734),
         q(0),
         ],
      q(qxp) => [
         q(5735),
         q(0),
         ],
      q(qxq) => [
         q(5736),
         q(0),
         ],
      q(qxr) => [
         q(5737),
         q(0),
         ],
      q(qxs) => [
         q(5738),
         q(0),
         ],
      q(qxt) => [
         q(5739),
         q(0),
         ],
      q(qxu) => [
         q(5740),
         q(0),
         ],
      q(qxw) => [
         q(5741),
         q(0),
         ],
      q(qya) => [
         q(5742),
         q(0),
         ],
      q(qyp) => [
         q(5743),
         q(0),
         ],
      q(raa) => [
         q(5744),
         q(0),
         ],
      q(rab) => [
         q(5745),
         q(0),
         ],
      q(rac) => [
         q(5746),
         q(0),
         ],
      q(rad) => [
         q(5747),
         q(0),
         ],
      q(raf) => [
         q(5748),
         q(0),
         ],
      q(rag) => [
         q(5749),
         q(0),
         ],
      q(rah) => [
         q(5750),
         q(0),
         ],
      q(rai) => [
         q(5751),
         q(0),
         ],
      q(raj) => [
         q(0354),
         q(0),
         ],
      q(rak) => [
         q(5752),
         q(0),
         ],
      q(ral) => [
         q(5753),
         q(0),
         ],
      q(ram) => [
         q(5754),
         q(0),
         ],
      q(ran) => [
         q(5755),
         q(0),
         ],
      q(rao) => [
         q(5756),
         q(0),
         ],
      q(rap) => [
         q(0355),
         q(0),
         ],
      q(raq) => [
         q(5757),
         q(0),
         ],
      q(rar) => [
         q(0356),
         q(0),
         ],
      q(ras) => [
         q(5758),
         q(0),
         ],
      q(rat) => [
         q(5759),
         q(0),
         ],
      q(rau) => [
         q(5760),
         q(0),
         ],
      q(rav) => [
         q(5761),
         q(0),
         ],
      q(raw) => [
         q(5762),
         q(0),
         ],
      q(rax) => [
         q(5763),
         q(0),
         ],
      q(ray) => [
         q(5764),
         q(0),
         ],
      q(raz) => [
         q(5765),
         q(0),
         ],
      q(rbb) => [
         q(5766),
         q(0),
         ],
      q(rbk) => [
         q(5767),
         q(0),
         ],
      q(rbl) => [
         q(5768),
         q(0),
         ],
      q(rbp) => [
         q(5769),
         q(0),
         ],
      q(rcf) => [
         q(5770),
         q(0),
         ],
      q(rdb) => [
         q(5771),
         q(0),
         ],
      q(rea) => [
         q(5772),
         q(0),
         ],
      q(reb) => [
         q(5773),
         q(0),
         ],
      q(ree) => [
         q(5774),
         q(0),
         ],
      q(reg) => [
         q(5775),
         q(0),
         ],
      q(rei) => [
         q(5776),
         q(0),
         ],
      q(rej) => [
         q(5777),
         q(0),
         ],
      q(rel) => [
         q(5778),
         q(0),
         ],
      q(rem) => [
         q(5779),
         q(0),
         ],
      q(ren) => [
         q(5780),
         q(0),
         ],
      q(rer) => [
         q(5781),
         q(0),
         ],
      q(res) => [
         q(5782),
         q(0),
         ],
      q(ret) => [
         q(5783),
         q(0),
         ],
      q(rey) => [
         q(5784),
         q(0),
         ],
      q(rga) => [
         q(5785),
         q(0),
         ],
      q(rge) => [
         q(5786),
         q(0),
         ],
      q(rgk) => [
         q(5787),
         q(0),
         ],
      q(rgn) => [
         q(5788),
         q(0),
         ],
      q(rgr) => [
         q(5789),
         q(0),
         ],
      q(rgs) => [
         q(5790),
         q(0),
         ],
      q(rgu) => [
         q(5791),
         q(0),
         ],
      q(rhg) => [
         q(5792),
         q(0),
         ],
      q(rhp) => [
         q(5793),
         q(0),
         ],
      q(ria) => [
         q(5794),
         q(0),
         ],
      q(rie) => [
         q(5795),
         q(0),
         ],
      q(rif) => [
         q(5796),
         q(0),
         ],
      q(ril) => [
         q(5797),
         q(0),
         ],
      q(rim) => [
         q(5798),
         q(0),
         ],
      q(rin) => [
         q(5799),
         q(0),
         ],
      q(rir) => [
         q(5800),
         q(0),
         ],
      q(rit) => [
         q(5801),
         q(0),
         ],
      q(riu) => [
         q(5802),
         q(0),
         ],
      q(rjg) => [
         q(5803),
         q(0),
         ],
      q(rji) => [
         q(5804),
         q(0),
         ],
      q(rjs) => [
         q(5805),
         q(0),
         ],
      q(rka) => [
         q(5806),
         q(0),
         ],
      q(rkb) => [
         q(5807),
         q(0),
         ],
      q(rkh) => [
         q(5808),
         q(0),
         ],
      q(rki) => [
         q(5809),
         q(0),
         ],
      q(rkm) => [
         q(5810),
         q(0),
         ],
      q(rkt) => [
         q(5811),
         q(0),
         ],
      q(rkw) => [
         q(5812),
         q(0),
         ],
      q(rma) => [
         q(5813),
         q(0),
         ],
      q(rmb) => [
         q(5814),
         q(0),
         ],
      q(rmc) => [
         q(5815),
         q(0),
         ],
      q(rmd) => [
         q(5816),
         q(0),
         ],
      q(rme) => [
         q(5817),
         q(0),
         ],
      q(rmf) => [
         q(5818),
         q(0),
         ],
      q(rmg) => [
         q(5819),
         q(0),
         ],
      q(rmh) => [
         q(5820),
         q(0),
         ],
      q(rmi) => [
         q(5821),
         q(0),
         ],
      q(rmk) => [
         q(5822),
         q(0),
         ],
      q(rml) => [
         q(5823),
         q(0),
         ],
      q(rmm) => [
         q(5824),
         q(0),
         ],
      q(rmn) => [
         q(5825),
         q(0),
         ],
      q(rmo) => [
         q(5826),
         q(0),
         ],
      q(rmp) => [
         q(5827),
         q(0),
         ],
      q(rmq) => [
         q(5828),
         q(0),
         ],
      q(rms) => [
         q(5829),
         q(0),
         ],
      q(rmt) => [
         q(5830),
         q(0),
         ],
      q(rmu) => [
         q(5831),
         q(0),
         ],
      q(rmv) => [
         q(5832),
         q(0),
         ],
      q(rmw) => [
         q(5833),
         q(0),
         ],
      q(rmx) => [
         q(5834),
         q(0),
         ],
      q(rmy) => [
         q(5835),
         q(0),
         ],
      q(rmz) => [
         q(5836),
         q(0),
         ],
      q(rna) => [
         q(5837),
         q(0),
         ],
      q(rnd) => [
         q(5838),
         q(0),
         ],
      q(rng) => [
         q(5839),
         q(0),
         ],
      q(rnl) => [
         q(5840),
         q(0),
         ],
      q(rnn) => [
         q(5841),
         q(0),
         ],
      q(rnp) => [
         q(5842),
         q(0),
         ],
      q(rnr) => [
         q(5843),
         q(0),
         ],
      q(rnw) => [
         q(5844),
         q(0),
         ],
      q(roa) => [
         q(0357),
         q(0),
         ],
      q(rob) => [
         q(5845),
         q(0),
         ],
      q(roc) => [
         q(5846),
         q(0),
         ],
      q(rod) => [
         q(5847),
         q(0),
         ],
      q(roe) => [
         q(5848),
         q(0),
         ],
      q(rof) => [
         q(5849),
         q(0),
         ],
      q(rog) => [
         q(5850),
         q(0),
         ],
      q(roh) => [
         q(0358),
         q(0),
         ],
      q(rol) => [
         q(5851),
         q(0),
         ],
      q(rom) => [
         q(0359),
         q(0),
         ],
      q(roo) => [
         q(5852),
         q(0),
         ],
      q(rop) => [
         q(5853),
         q(0),
         ],
      q(ror) => [
         q(5854),
         q(0),
         ],
      q(rou) => [
         q(5855),
         q(0),
         ],
      q(row) => [
         q(5856),
         q(0),
         ],
      q(rpn) => [
         q(5857),
         q(0),
         ],
      q(rpt) => [
         q(5858),
         q(0),
         ],
      q(rri) => [
         q(5859),
         q(0),
         ],
      q(rro) => [
         q(5860),
         q(0),
         ],
      q(rrt) => [
         q(5861),
         q(0),
         ],
      q(rsb) => [
         q(5862),
         q(0),
         ],
      q(rsi) => [
         q(5863),
         q(0),
         ],
      q(rsl) => [
         q(5864),
         q(0),
         ],
      q(rtc) => [
         q(5865),
         q(0),
         ],
      q(rth) => [
         q(5866),
         q(0),
         ],
      q(rtm) => [
         q(5867),
         q(0),
         ],
      q(rtw) => [
         q(5868),
         q(0),
         ],
      q(rub) => [
         q(5869),
         q(0),
         ],
      q(ruc) => [
         q(5870),
         q(0),
         ],
      q(rue) => [
         q(5871),
         q(0),
         ],
      q(ruf) => [
         q(5872),
         q(0),
         ],
      q(rug) => [
         q(5873),
         q(0),
         ],
      q(ruh) => [
         q(5874),
         q(0),
         ],
      q(rui) => [
         q(5875),
         q(0),
         ],
      q(ruk) => [
         q(5876),
         q(0),
         ],
      q(rum) => [
         q(0360),
         q(0),
         ],
      q(run) => [
         q(0361),
         q(0),
         ],
      q(ruo) => [
         q(5877),
         q(0),
         ],
      q(rup) => [
         q(0362),
         q(2),
         ],
      q(ruq) => [
         q(5878),
         q(0),
         ],
      q(rus) => [
         q(0363),
         q(0),
         ],
      q(rut) => [
         q(5879),
         q(0),
         ],
      q(ruu) => [
         q(5880),
         q(0),
         ],
      q(ruy) => [
         q(5881),
         q(0),
         ],
      q(ruz) => [
         q(5882),
         q(0),
         ],
      q(rwa) => [
         q(5883),
         q(0),
         ],
      q(rwk) => [
         q(5884),
         q(0),
         ],
      q(rwm) => [
         q(5885),
         q(0),
         ],
      q(rwo) => [
         q(5886),
         q(0),
         ],
      q(rwr) => [
         q(5887),
         q(0),
         ],
      q(rxd) => [
         q(5888),
         q(0),
         ],
      q(rxw) => [
         q(5889),
         q(0),
         ],
      q(ryn) => [
         q(5890),
         q(0),
         ],
      q(rys) => [
         q(5891),
         q(0),
         ],
      q(ryu) => [
         q(5892),
         q(0),
         ],
      q(saa) => [
         q(5893),
         q(0),
         ],
      q(sab) => [
         q(5894),
         q(0),
         ],
      q(sac) => [
         q(5895),
         q(0),
         ],
      q(sad) => [
         q(0364),
         q(0),
         ],
      q(sae) => [
         q(5896),
         q(0),
         ],
      q(saf) => [
         q(5897),
         q(0),
         ],
      q(sag) => [
         q(0365),
         q(0),
         ],
      q(sah) => [
         q(0366),
         q(0),
         ],
      q(sai) => [
         q(0367),
         q(1),
         ],
      q(saj) => [
         q(5898),
         q(0),
         ],
      q(sak) => [
         q(5899),
         q(0),
         ],
      q(sal) => [
         q(0368),
         q(0),
         ],
      q(sam) => [
         q(0369),
         q(0),
         ],
      q(san) => [
         q(0370),
         q(0),
         ],
      q(sao) => [
         q(5900),
         q(0),
         ],
      q(sap) => [
         q(5901),
         q(0),
         ],
      q(saq) => [
         q(5902),
         q(0),
         ],
      q(sar) => [
         q(5903),
         q(0),
         ],
      q(sas) => [
         q(0371),
         q(0),
         ],
      q(sat) => [
         q(0372),
         q(0),
         ],
      q(sau) => [
         q(5904),
         q(0),
         ],
      q(sav) => [
         q(5905),
         q(0),
         ],
      q(saw) => [
         q(5906),
         q(0),
         ],
      q(sax) => [
         q(5907),
         q(0),
         ],
      q(say) => [
         q(5908),
         q(0),
         ],
      q(saz) => [
         q(5909),
         q(0),
         ],
      q(sba) => [
         q(5910),
         q(0),
         ],
      q(sbb) => [
         q(5911),
         q(0),
         ],
      q(sbc) => [
         q(5912),
         q(0),
         ],
      q(sbd) => [
         q(5913),
         q(0),
         ],
      q(sbe) => [
         q(5914),
         q(0),
         ],
      q(sbf) => [
         q(5915),
         q(0),
         ],
      q(sbg) => [
         q(5916),
         q(0),
         ],
      q(sbh) => [
         q(5917),
         q(0),
         ],
      q(sbi) => [
         q(5918),
         q(0),
         ],
      q(sbj) => [
         q(5919),
         q(0),
         ],
      q(sbk) => [
         q(5920),
         q(0),
         ],
      q(sbl) => [
         q(5921),
         q(0),
         ],
      q(sbm) => [
         q(5922),
         q(0),
         ],
      q(sbn) => [
         q(5923),
         q(0),
         ],
      q(sbo) => [
         q(5924),
         q(0),
         ],
      q(sbp) => [
         q(5925),
         q(0),
         ],
      q(sbq) => [
         q(5926),
         q(0),
         ],
      q(sbr) => [
         q(5927),
         q(0),
         ],
      q(sbs) => [
         q(5928),
         q(0),
         ],
      q(sbt) => [
         q(5929),
         q(0),
         ],
      q(sbu) => [
         q(5930),
         q(0),
         ],
      q(sbv) => [
         q(5931),
         q(0),
         ],
      q(sbw) => [
         q(5932),
         q(0),
         ],
      q(sbx) => [
         q(5933),
         q(0),
         ],
      q(sby) => [
         q(5934),
         q(0),
         ],
      q(sbz) => [
         q(5935),
         q(0),
         ],
      q(scb) => [
         q(5936),
         q(0),
         ],
      q(sce) => [
         q(5937),
         q(0),
         ],
      q(scf) => [
         q(5938),
         q(0),
         ],
      q(scg) => [
         q(5939),
         q(0),
         ],
      q(sch) => [
         q(5940),
         q(0),
         ],
      q(sci) => [
         q(5941),
         q(0),
         ],
      q(sck) => [
         q(5942),
         q(0),
         ],
      q(scl) => [
         q(5943),
         q(0),
         ],
      q(scn) => [
         q(0373),
         q(0),
         ],
      q(sco) => [
         q(0374),
         q(0),
         ],
      q(scp) => [
         q(5944),
         q(0),
         ],
      q(scq) => [
         q(5945),
         q(0),
         ],
      q(scs) => [
         q(5946),
         q(0),
         ],
      q(scu) => [
         q(5947),
         q(0),
         ],
      q(scv) => [
         q(5948),
         q(0),
         ],
      q(scw) => [
         q(5949),
         q(0),
         ],
      q(scx) => [
         q(5950),
         q(0),
         ],
      q(sda) => [
         q(5951),
         q(0),
         ],
      q(sdb) => [
         q(5952),
         q(0),
         ],
      q(sdc) => [
         q(5953),
         q(0),
         ],
      q(sde) => [
         q(5954),
         q(0),
         ],
      q(sdf) => [
         q(5955),
         q(0),
         ],
      q(sdg) => [
         q(5956),
         q(0),
         ],
      q(sdh) => [
         q(5957),
         q(0),
         ],
      q(sdj) => [
         q(5958),
         q(0),
         ],
      q(sdk) => [
         q(5959),
         q(0),
         ],
      q(sdl) => [
         q(5960),
         q(0),
         ],
      q(sdm) => [
         q(5961),
         q(0),
         ],
      q(sdn) => [
         q(5962),
         q(0),
         ],
      q(sdo) => [
         q(5963),
         q(0),
         ],
      q(sdp) => [
         q(5964),
         q(0),
         ],
      q(sdr) => [
         q(5965),
         q(0),
         ],
      q(sds) => [
         q(5966),
         q(0),
         ],
      q(sdt) => [
         q(5967),
         q(0),
         ],
      q(sdu) => [
         q(5968),
         q(0),
         ],
      q(sdv) => [
         q(0524),
         q(0),
         ],
      q(sdx) => [
         q(5969),
         q(0),
         ],
      q(sdz) => [
         q(5970),
         q(0),
         ],
      q(sea) => [
         q(5971),
         q(0),
         ],
      q(seb) => [
         q(5972),
         q(0),
         ],
      q(sec) => [
         q(5973),
         q(0),
         ],
      q(sed) => [
         q(5974),
         q(0),
         ],
      q(see) => [
         q(5975),
         q(0),
         ],
      q(sef) => [
         q(5976),
         q(0),
         ],
      q(seg) => [
         q(5977),
         q(0),
         ],
      q(seh) => [
         q(5978),
         q(0),
         ],
      q(sei) => [
         q(5979),
         q(0),
         ],
      q(sej) => [
         q(5980),
         q(0),
         ],
      q(sek) => [
         q(5981),
         q(0),
         ],
      q(sel) => [
         q(0375),
         q(0),
         ],
      q(sem) => [
         q(0376),
         q(0),
         ],
      q(sen) => [
         q(5982),
         q(0),
         ],
      q(seo) => [
         q(5983),
         q(0),
         ],
      q(sep) => [
         q(5984),
         q(0),
         ],
      q(seq) => [
         q(5985),
         q(0),
         ],
      q(ser) => [
         q(5986),
         q(0),
         ],
      q(ses) => [
         q(5987),
         q(0),
         ],
      q(set) => [
         q(5988),
         q(0),
         ],
      q(seu) => [
         q(5989),
         q(0),
         ],
      q(sev) => [
         q(5990),
         q(0),
         ],
      q(sew) => [
         q(5991),
         q(0),
         ],
      q(sey) => [
         q(5992),
         q(0),
         ],
      q(sez) => [
         q(5993),
         q(0),
         ],
      q(sfb) => [
         q(5994),
         q(0),
         ],
      q(sfe) => [
         q(5995),
         q(0),
         ],
      q(sfm) => [
         q(5996),
         q(0),
         ],
      q(sfs) => [
         q(5997),
         q(0),
         ],
      q(sfw) => [
         q(5998),
         q(0),
         ],
      q(sga) => [
         q(0377),
         q(1),
         ],
      q(sgb) => [
         q(5999),
         q(0),
         ],
      q(sgc) => [
         q(6000),
         q(0),
         ],
      q(sgd) => [
         q(6001),
         q(0),
         ],
      q(sge) => [
         q(6002),
         q(0),
         ],
      q(sgg) => [
         q(6003),
         q(0),
         ],
      q(sgh) => [
         q(6004),
         q(0),
         ],
      q(sgi) => [
         q(6005),
         q(0),
         ],
      q(sgj) => [
         q(6006),
         q(0),
         ],
      q(sgk) => [
         q(6007),
         q(0),
         ],
      q(sgm) => [
         q(6008),
         q(0),
         ],
      q(sgn) => [
         q(0378),
         q(0),
         ],
      q(sgo) => [
         q(6009),
         q(0),
         ],
      q(sgp) => [
         q(6010),
         q(0),
         ],
      q(sgr) => [
         q(6011),
         q(0),
         ],
      q(sgs) => [
         q(6012),
         q(0),
         ],
      q(sgt) => [
         q(6013),
         q(0),
         ],
      q(sgu) => [
         q(6014),
         q(0),
         ],
      q(sgw) => [
         q(6015),
         q(0),
         ],
      q(sgx) => [
         q(6016),
         q(0),
         ],
      q(sgy) => [
         q(6017),
         q(0),
         ],
      q(sgz) => [
         q(6018),
         q(0),
         ],
      q(sha) => [
         q(6019),
         q(0),
         ],
      q(shb) => [
         q(6020),
         q(0),
         ],
      q(shc) => [
         q(6021),
         q(0),
         ],
      q(shd) => [
         q(6022),
         q(0),
         ],
      q(she) => [
         q(6023),
         q(0),
         ],
      q(shg) => [
         q(6024),
         q(0),
         ],
      q(shh) => [
         q(6025),
         q(0),
         ],
      q(shi) => [
         q(6026),
         q(0),
         ],
      q(shj) => [
         q(6027),
         q(0),
         ],
      q(shk) => [
         q(6028),
         q(0),
         ],
      q(shl) => [
         q(6029),
         q(0),
         ],
      q(shm) => [
         q(6030),
         q(0),
         ],
      q(shn) => [
         q(0379),
         q(0),
         ],
      q(sho) => [
         q(6031),
         q(0),
         ],
      q(shp) => [
         q(6032),
         q(0),
         ],
      q(shq) => [
         q(6033),
         q(0),
         ],
      q(shr) => [
         q(6034),
         q(0),
         ],
      q(shs) => [
         q(6035),
         q(0),
         ],
      q(sht) => [
         q(6036),
         q(0),
         ],
      q(shu) => [
         q(6037),
         q(0),
         ],
      q(shv) => [
         q(6038),
         q(0),
         ],
      q(shw) => [
         q(6039),
         q(0),
         ],
      q(shx) => [
         q(6040),
         q(0),
         ],
      q(shy) => [
         q(6041),
         q(0),
         ],
      q(shz) => [
         q(6042),
         q(0),
         ],
      q(sia) => [
         q(6043),
         q(0),
         ],
      q(sib) => [
         q(6044),
         q(0),
         ],
      q(sid) => [
         q(0380),
         q(0),
         ],
      q(sie) => [
         q(6045),
         q(0),
         ],
      q(sif) => [
         q(6046),
         q(0),
         ],
      q(sig) => [
         q(6047),
         q(0),
         ],
      q(sih) => [
         q(6048),
         q(0),
         ],
      q(sii) => [
         q(6049),
         q(0),
         ],
      q(sij) => [
         q(6050),
         q(0),
         ],
      q(sik) => [
         q(6051),
         q(0),
         ],
      q(sil) => [
         q(6052),
         q(0),
         ],
      q(sim) => [
         q(6053),
         q(0),
         ],
      q(sin) => [
         q(0381),
         q(0),
         ],
      q(sio) => [
         q(0382),
         q(0),
         ],
      q(sip) => [
         q(6054),
         q(0),
         ],
      q(siq) => [
         q(6055),
         q(0),
         ],
      q(sir) => [
         q(6056),
         q(0),
         ],
      q(sis) => [
         q(6057),
         q(0),
         ],
      q(sit) => [
         q(0383),
         q(0),
         ],
      q(siu) => [
         q(6058),
         q(0),
         ],
      q(siv) => [
         q(6059),
         q(0),
         ],
      q(siw) => [
         q(6060),
         q(0),
         ],
      q(six) => [
         q(6061),
         q(0),
         ],
      q(siy) => [
         q(6062),
         q(0),
         ],
      q(siz) => [
         q(6063),
         q(0),
         ],
      q(sja) => [
         q(6064),
         q(0),
         ],
      q(sjb) => [
         q(6065),
         q(0),
         ],
      q(sjd) => [
         q(6066),
         q(0),
         ],
      q(sje) => [
         q(6067),
         q(0),
         ],
      q(sjg) => [
         q(6068),
         q(0),
         ],
      q(sjk) => [
         q(6069),
         q(0),
         ],
      q(sjl) => [
         q(6070),
         q(0),
         ],
      q(sjm) => [
         q(6071),
         q(0),
         ],
      q(sjn) => [
         q(6072),
         q(0),
         ],
      q(sjo) => [
         q(6073),
         q(0),
         ],
      q(sjp) => [
         q(6074),
         q(0),
         ],
      q(sjr) => [
         q(6075),
         q(0),
         ],
      q(sjs) => [
         q(6076),
         q(0),
         ],
      q(sjt) => [
         q(6077),
         q(0),
         ],
      q(sju) => [
         q(6078),
         q(0),
         ],
      q(sjw) => [
         q(6079),
         q(0),
         ],
      q(ska) => [
         q(6080),
         q(0),
         ],
      q(skb) => [
         q(6081),
         q(0),
         ],
      q(skc) => [
         q(6082),
         q(0),
         ],
      q(skd) => [
         q(6083),
         q(0),
         ],
      q(ske) => [
         q(6084),
         q(0),
         ],
      q(skf) => [
         q(6085),
         q(0),
         ],
      q(skg) => [
         q(6086),
         q(0),
         ],
      q(skh) => [
         q(6087),
         q(0),
         ],
      q(ski) => [
         q(6088),
         q(0),
         ],
      q(skj) => [
         q(6089),
         q(0),
         ],
      q(skk) => [
         q(6090),
         q(0),
         ],
      q(skm) => [
         q(6091),
         q(0),
         ],
      q(skn) => [
         q(6092),
         q(0),
         ],
      q(sko) => [
         q(6093),
         q(0),
         ],
      q(skp) => [
         q(6094),
         q(0),
         ],
      q(skq) => [
         q(6095),
         q(0),
         ],
      q(skr) => [
         q(6096),
         q(0),
         ],
      q(sks) => [
         q(6097),
         q(0),
         ],
      q(skt) => [
         q(6098),
         q(0),
         ],
      q(sku) => [
         q(6099),
         q(0),
         ],
      q(skv) => [
         q(6100),
         q(0),
         ],
      q(skw) => [
         q(6101),
         q(0),
         ],
      q(skx) => [
         q(6102),
         q(0),
         ],
      q(sky) => [
         q(6103),
         q(0),
         ],
      q(skz) => [
         q(6104),
         q(0),
         ],
      q(sla) => [
         q(0384),
         q(0),
         ],
      q(slc) => [
         q(5914),
         q(0),
         ],
      q(sld) => [
         q(6105),
         q(0),
         ],
      q(sle) => [
         q(6106),
         q(0),
         ],
      q(slf) => [
         q(6107),
         q(0),
         ],
      q(slg) => [
         q(6108),
         q(0),
         ],
      q(slh) => [
         q(6109),
         q(0),
         ],
      q(sli) => [
         q(6110),
         q(0),
         ],
      q(slj) => [
         q(6111),
         q(0),
         ],
      q(sll) => [
         q(6112),
         q(0),
         ],
      q(slm) => [
         q(6113),
         q(0),
         ],
      q(sln) => [
         q(6114),
         q(0),
         ],
      q(slo) => [
         q(0385),
         q(0),
         ],
      q(slp) => [
         q(6115),
         q(0),
         ],
      q(slq) => [
         q(6116),
         q(0),
         ],
      q(slr) => [
         q(6117),
         q(0),
         ],
      q(sls) => [
         q(6118),
         q(0),
         ],
      q(slt) => [
         q(6119),
         q(0),
         ],
      q(slu) => [
         q(6120),
         q(0),
         ],
      q(slv) => [
         q(0386),
         q(0),
         ],
      q(slw) => [
         q(6121),
         q(0),
         ],
      q(slx) => [
         q(6122),
         q(0),
         ],
      q(sly) => [
         q(6123),
         q(0),
         ],
      q(slz) => [
         q(6124),
         q(0),
         ],
      q(sma) => [
         q(0387),
         q(0),
         ],
      q(smb) => [
         q(6125),
         q(0),
         ],
      q(smc) => [
         q(6126),
         q(0),
         ],
      q(smd) => [
         q(6127),
         q(0),
         ],
      q(sme) => [
         q(0388),
         q(0),
         ],
      q(smf) => [
         q(6128),
         q(0),
         ],
      q(smg) => [
         q(6129),
         q(0),
         ],
      q(smh) => [
         q(6130),
         q(0),
         ],
      q(smi) => [
         q(0389),
         q(0),
         ],
      q(smj) => [
         q(0390),
         q(0),
         ],
      q(smk) => [
         q(6131),
         q(0),
         ],
      q(sml) => [
         q(6132),
         q(0),
         ],
      q(smm) => [
         q(6133),
         q(0),
         ],
      q(smn) => [
         q(0391),
         q(0),
         ],
      q(smo) => [
         q(0392),
         q(0),
         ],
      q(smp) => [
         q(6134),
         q(0),
         ],
      q(smq) => [
         q(6135),
         q(0),
         ],
      q(smr) => [
         q(6136),
         q(0),
         ],
      q(sms) => [
         q(0393),
         q(0),
         ],
      q(smt) => [
         q(6137),
         q(0),
         ],
      q(smu) => [
         q(6138),
         q(0),
         ],
      q(smv) => [
         q(6139),
         q(0),
         ],
      q(smw) => [
         q(6140),
         q(0),
         ],
      q(smx) => [
         q(6141),
         q(0),
         ],
      q(smy) => [
         q(6142),
         q(0),
         ],
      q(smz) => [
         q(6143),
         q(0),
         ],
      q(sna) => [
         q(0394),
         q(0),
         ],
      q(snb) => [
         q(6144),
         q(0),
         ],
      q(snc) => [
         q(6145),
         q(0),
         ],
      q(snd) => [
         q(0395),
         q(0),
         ],
      q(sne) => [
         q(6146),
         q(0),
         ],
      q(snf) => [
         q(6147),
         q(0),
         ],
      q(sng) => [
         q(6148),
         q(0),
         ],
      q(snh) => [
         q(6149),
         q(0),
         ],
      q(sni) => [
         q(6150),
         q(0),
         ],
      q(snj) => [
         q(6151),
         q(0),
         ],
      q(snk) => [
         q(0396),
         q(0),
         ],
      q(snl) => [
         q(6152),
         q(0),
         ],
      q(snm) => [
         q(6153),
         q(0),
         ],
      q(snn) => [
         q(6154),
         q(0),
         ],
      q(sno) => [
         q(6155),
         q(0),
         ],
      q(snp) => [
         q(6156),
         q(0),
         ],
      q(snq) => [
         q(6157),
         q(0),
         ],
      q(snr) => [
         q(6158),
         q(0),
         ],
      q(sns) => [
         q(6159),
         q(0),
         ],
      q(snu) => [
         q(6160),
         q(0),
         ],
      q(snv) => [
         q(6161),
         q(0),
         ],
      q(snw) => [
         q(6162),
         q(0),
         ],
      q(snx) => [
         q(6163),
         q(0),
         ],
      q(sny) => [
         q(6164),
         q(0),
         ],
      q(snz) => [
         q(6165),
         q(0),
         ],
      q(soa) => [
         q(6166),
         q(0),
         ],
      q(sob) => [
         q(6167),
         q(0),
         ],
      q(soc) => [
         q(6168),
         q(0),
         ],
      q(sod) => [
         q(6169),
         q(0),
         ],
      q(soe) => [
         q(6170),
         q(0),
         ],
      q(sog) => [
         q(0397),
         q(0),
         ],
      q(soh) => [
         q(6171),
         q(0),
         ],
      q(soi) => [
         q(6172),
         q(0),
         ],
      q(soj) => [
         q(6173),
         q(0),
         ],
      q(sok) => [
         q(6174),
         q(0),
         ],
      q(sol) => [
         q(6175),
         q(0),
         ],
      q(som) => [
         q(0398),
         q(0),
         ],
      q(son) => [
         q(0399),
         q(0),
         ],
      q(soo) => [
         q(6176),
         q(0),
         ],
      q(sop) => [
         q(6177),
         q(0),
         ],
      q(soq) => [
         q(6178),
         q(0),
         ],
      q(sor) => [
         q(6179),
         q(0),
         ],
      q(sos) => [
         q(6180),
         q(0),
         ],
      q(sot) => [
         q(0400),
         q(0),
         ],
      q(sou) => [
         q(6181),
         q(0),
         ],
      q(sov) => [
         q(6182),
         q(0),
         ],
      q(sow) => [
         q(6183),
         q(0),
         ],
      q(sox) => [
         q(6184),
         q(0),
         ],
      q(soy) => [
         q(6185),
         q(0),
         ],
      q(soz) => [
         q(6186),
         q(0),
         ],
      q(spa) => [
         q(0401),
         q(0),
         ],
      q(spb) => [
         q(6187),
         q(0),
         ],
      q(spc) => [
         q(6188),
         q(0),
         ],
      q(spd) => [
         q(6189),
         q(0),
         ],
      q(spe) => [
         q(6190),
         q(0),
         ],
      q(spg) => [
         q(6191),
         q(0),
         ],
      q(spi) => [
         q(6192),
         q(0),
         ],
      q(spk) => [
         q(6193),
         q(0),
         ],
      q(spl) => [
         q(6194),
         q(0),
         ],
      q(spm) => [
         q(6195),
         q(0),
         ],
      q(spo) => [
         q(6196),
         q(0),
         ],
      q(spp) => [
         q(6197),
         q(0),
         ],
      q(spq) => [
         q(6198),
         q(0),
         ],
      q(spr) => [
         q(6199),
         q(0),
         ],
      q(sps) => [
         q(6200),
         q(0),
         ],
      q(spt) => [
         q(6201),
         q(0),
         ],
      q(spu) => [
         q(6202),
         q(0),
         ],
      q(spv) => [
         q(6203),
         q(0),
         ],
      q(spx) => [
         q(6204),
         q(0),
         ],
      q(spy) => [
         q(6205),
         q(0),
         ],
      q(sqa) => [
         q(6206),
         q(0),
         ],
      q(sqh) => [
         q(6207),
         q(0),
         ],
      q(sqj) => [
         q(0525),
         q(0),
         ],
      q(sqk) => [
         q(6208),
         q(0),
         ],
      q(sqm) => [
         q(6209),
         q(0),
         ],
      q(sqn) => [
         q(6210),
         q(0),
         ],
      q(sqo) => [
         q(6211),
         q(0),
         ],
      q(sqq) => [
         q(6212),
         q(0),
         ],
      q(sqr) => [
         q(6213),
         q(0),
         ],
      q(sqs) => [
         q(6214),
         q(0),
         ],
      q(sqt) => [
         q(6215),
         q(0),
         ],
      q(squ) => [
         q(6216),
         q(0),
         ],
      q(sra) => [
         q(6217),
         q(0),
         ],
      q(srb) => [
         q(6218),
         q(0),
         ],
      q(src) => [
         q(6219),
         q(0),
         ],
      q(srd) => [
         q(0402),
         q(0),
         ],
      q(sre) => [
         q(6220),
         q(0),
         ],
      q(srf) => [
         q(6221),
         q(0),
         ],
      q(srg) => [
         q(6222),
         q(0),
         ],
      q(srh) => [
         q(6223),
         q(0),
         ],
      q(sri) => [
         q(6224),
         q(0),
         ],
      q(srk) => [
         q(6225),
         q(0),
         ],
      q(srl) => [
         q(6226),
         q(0),
         ],
      q(srm) => [
         q(6227),
         q(0),
         ],
      q(srn) => [
         q(0403),
         q(0),
         ],
      q(sro) => [
         q(6228),
         q(0),
         ],
      q(srp) => [
         q(0404),
         q(0),
         ],
      q(srq) => [
         q(6229),
         q(0),
         ],
      q(srr) => [
         q(0405),
         q(0),
         ],
      q(srs) => [
         q(6230),
         q(0),
         ],
      q(srt) => [
         q(6231),
         q(0),
         ],
      q(sru) => [
         q(6232),
         q(0),
         ],
      q(srv) => [
         q(6233),
         q(0),
         ],
      q(srw) => [
         q(6234),
         q(0),
         ],
      q(srx) => [
         q(6235),
         q(0),
         ],
      q(sry) => [
         q(6236),
         q(0),
         ],
      q(srz) => [
         q(6237),
         q(0),
         ],
      q(ssa) => [
         q(0406),
         q(0),
         ],
      q(ssb) => [
         q(6238),
         q(0),
         ],
      q(ssc) => [
         q(6239),
         q(0),
         ],
      q(ssd) => [
         q(6240),
         q(0),
         ],
      q(sse) => [
         q(6241),
         q(0),
         ],
      q(ssf) => [
         q(6242),
         q(0),
         ],
      q(ssg) => [
         q(6243),
         q(0),
         ],
      q(ssh) => [
         q(6244),
         q(0),
         ],
      q(ssi) => [
         q(6245),
         q(0),
         ],
      q(ssj) => [
         q(6246),
         q(0),
         ],
      q(ssk) => [
         q(6247),
         q(0),
         ],
      q(ssl) => [
         q(6248),
         q(0),
         ],
      q(ssm) => [
         q(6249),
         q(0),
         ],
      q(ssn) => [
         q(6250),
         q(0),
         ],
      q(sso) => [
         q(6251),
         q(0),
         ],
      q(ssp) => [
         q(6252),
         q(0),
         ],
      q(ssq) => [
         q(6253),
         q(0),
         ],
      q(ssr) => [
         q(6254),
         q(0),
         ],
      q(sss) => [
         q(6255),
         q(0),
         ],
      q(sst) => [
         q(6256),
         q(0),
         ],
      q(ssu) => [
         q(6257),
         q(0),
         ],
      q(ssv) => [
         q(6258),
         q(0),
         ],
      q(ssw) => [
         q(0407),
         q(0),
         ],
      q(ssx) => [
         q(6259),
         q(0),
         ],
      q(ssy) => [
         q(6260),
         q(0),
         ],
      q(ssz) => [
         q(6261),
         q(0),
         ],
      q(sta) => [
         q(6262),
         q(0),
         ],
      q(stb) => [
         q(6263),
         q(0),
         ],
      q(std) => [
         q(6264),
         q(0),
         ],
      q(ste) => [
         q(6265),
         q(0),
         ],
      q(stf) => [
         q(6266),
         q(0),
         ],
      q(stg) => [
         q(6267),
         q(0),
         ],
      q(sth) => [
         q(6268),
         q(0),
         ],
      q(sti) => [
         q(6269),
         q(0),
         ],
      q(stj) => [
         q(6270),
         q(0),
         ],
      q(stk) => [
         q(6271),
         q(0),
         ],
      q(stl) => [
         q(6272),
         q(0),
         ],
      q(stm) => [
         q(6273),
         q(0),
         ],
      q(stn) => [
         q(6274),
         q(0),
         ],
      q(sto) => [
         q(6275),
         q(0),
         ],
      q(stp) => [
         q(6276),
         q(0),
         ],
      q(stq) => [
         q(6277),
         q(0),
         ],
      q(str) => [
         q(6278),
         q(0),
         ],
      q(sts) => [
         q(6279),
         q(0),
         ],
      q(stt) => [
         q(6280),
         q(0),
         ],
      q(stu) => [
         q(6281),
         q(0),
         ],
      q(stv) => [
         q(6282),
         q(0),
         ],
      q(stw) => [
         q(6283),
         q(0),
         ],
      q(sty) => [
         q(6284),
         q(0),
         ],
      q(sua) => [
         q(6285),
         q(0),
         ],
      q(sub) => [
         q(6286),
         q(0),
         ],
      q(suc) => [
         q(6287),
         q(0),
         ],
      q(sue) => [
         q(6288),
         q(0),
         ],
      q(sug) => [
         q(6289),
         q(0),
         ],
      q(sui) => [
         q(6290),
         q(0),
         ],
      q(suj) => [
         q(6291),
         q(0),
         ],
      q(suk) => [
         q(0408),
         q(0),
         ],
      q(sun) => [
         q(0409),
         q(0),
         ],
      q(suq) => [
         q(6292),
         q(0),
         ],
      q(sur) => [
         q(6293),
         q(0),
         ],
      q(sus) => [
         q(0410),
         q(0),
         ],
      q(sut) => [
         q(6294),
         q(0),
         ],
      q(suv) => [
         q(6295),
         q(0),
         ],
      q(suw) => [
         q(6296),
         q(0),
         ],
      q(sux) => [
         q(0411),
         q(0),
         ],
      q(suy) => [
         q(6297),
         q(0),
         ],
      q(suz) => [
         q(6298),
         q(0),
         ],
      q(sva) => [
         q(6299),
         q(0),
         ],
      q(svb) => [
         q(6300),
         q(0),
         ],
      q(svc) => [
         q(6301),
         q(0),
         ],
      q(sve) => [
         q(6302),
         q(0),
         ],
      q(svk) => [
         q(6303),
         q(0),
         ],
      q(svm) => [
         q(6304),
         q(0),
         ],
      q(svr) => [
         q(6305),
         q(0),
         ],
      q(svs) => [
         q(6306),
         q(0),
         ],
      q(svx) => [
         q(6307),
         q(0),
         ],
      q(swa) => [
         q(0412),
         q(0),
         ],
      q(swb) => [
         q(6308),
         q(0),
         ],
      q(swc) => [
         q(6309),
         q(0),
         ],
      q(swe) => [
         q(0413),
         q(0),
         ],
      q(swf) => [
         q(6310),
         q(0),
         ],
      q(swg) => [
         q(6311),
         q(0),
         ],
      q(swh) => [
         q(6312),
         q(0),
         ],
      q(swi) => [
         q(6313),
         q(0),
         ],
      q(swj) => [
         q(6314),
         q(0),
         ],
      q(swk) => [
         q(6315),
         q(0),
         ],
      q(swl) => [
         q(6316),
         q(0),
         ],
      q(swm) => [
         q(6317),
         q(0),
         ],
      q(swn) => [
         q(6318),
         q(0),
         ],
      q(swo) => [
         q(6319),
         q(0),
         ],
      q(swp) => [
         q(6320),
         q(0),
         ],
      q(swq) => [
         q(6321),
         q(0),
         ],
      q(swr) => [
         q(6322),
         q(0),
         ],
      q(sws) => [
         q(6323),
         q(0),
         ],
      q(swt) => [
         q(6324),
         q(0),
         ],
      q(swu) => [
         q(6325),
         q(0),
         ],
      q(swv) => [
         q(6326),
         q(0),
         ],
      q(sww) => [
         q(6327),
         q(0),
         ],
      q(swx) => [
         q(6328),
         q(0),
         ],
      q(swy) => [
         q(6329),
         q(0),
         ],
      q(sxb) => [
         q(6330),
         q(0),
         ],
      q(sxc) => [
         q(6331),
         q(0),
         ],
      q(sxe) => [
         q(6332),
         q(0),
         ],
      q(sxg) => [
         q(6333),
         q(0),
         ],
      q(sxk) => [
         q(6334),
         q(0),
         ],
      q(sxl) => [
         q(6335),
         q(0),
         ],
      q(sxm) => [
         q(6336),
         q(0),
         ],
      q(sxn) => [
         q(6337),
         q(0),
         ],
      q(sxo) => [
         q(6338),
         q(0),
         ],
      q(sxr) => [
         q(6339),
         q(0),
         ],
      q(sxs) => [
         q(6340),
         q(0),
         ],
      q(sxu) => [
         q(6341),
         q(0),
         ],
      q(sxw) => [
         q(6342),
         q(0),
         ],
      q(sya) => [
         q(6343),
         q(0),
         ],
      q(syb) => [
         q(6344),
         q(0),
         ],
      q(syc) => [
         q(0414),
         q(0),
         ],
      q(syd) => [
         q(0526),
         q(0),
         ],
      q(syi) => [
         q(6345),
         q(0),
         ],
      q(syk) => [
         q(6346),
         q(0),
         ],
      q(syl) => [
         q(6347),
         q(0),
         ],
      q(sym) => [
         q(6348),
         q(0),
         ],
      q(syn) => [
         q(6349),
         q(0),
         ],
      q(syo) => [
         q(6350),
         q(0),
         ],
      q(syr) => [
         q(0415),
         q(0),
         ],
      q(sys) => [
         q(6351),
         q(0),
         ],
      q(syw) => [
         q(6352),
         q(0),
         ],
      q(syy) => [
         q(6353),
         q(0),
         ],
      q(sza) => [
         q(6354),
         q(0),
         ],
      q(szb) => [
         q(6355),
         q(0),
         ],
      q(szc) => [
         q(6356),
         q(0),
         ],
      q(szd) => [
         q(6357),
         q(0),
         ],
      q(sze) => [
         q(6358),
         q(0),
         ],
      q(szg) => [
         q(6359),
         q(0),
         ],
      q(szl) => [
         q(6360),
         q(0),
         ],
      q(szn) => [
         q(6361),
         q(0),
         ],
      q(szp) => [
         q(6362),
         q(0),
         ],
      q(szv) => [
         q(6363),
         q(0),
         ],
      q(szw) => [
         q(6364),
         q(0),
         ],
      q(taa) => [
         q(6365),
         q(0),
         ],
      q(tab) => [
         q(6366),
         q(0),
         ],
      q(tac) => [
         q(6367),
         q(0),
         ],
      q(tad) => [
         q(6368),
         q(0),
         ],
      q(tae) => [
         q(6369),
         q(0),
         ],
      q(taf) => [
         q(6370),
         q(0),
         ],
      q(tag) => [
         q(6371),
         q(0),
         ],
      q(tah) => [
         q(0416),
         q(0),
         ],
      q(tai) => [
         q(0417),
         q(0),
         ],
      q(taj) => [
         q(6372),
         q(0),
         ],
      q(tak) => [
         q(6373),
         q(0),
         ],
      q(tal) => [
         q(6374),
         q(0),
         ],
      q(tam) => [
         q(0418),
         q(0),
         ],
      q(tan) => [
         q(6375),
         q(0),
         ],
      q(tao) => [
         q(6376),
         q(0),
         ],
      q(tap) => [
         q(6377),
         q(0),
         ],
      q(taq) => [
         q(6378),
         q(0),
         ],
      q(tar) => [
         q(6379),
         q(0),
         ],
      q(tas) => [
         q(6380),
         q(0),
         ],
      q(tat) => [
         q(0419),
         q(0),
         ],
      q(tau) => [
         q(6381),
         q(0),
         ],
      q(tav) => [
         q(6382),
         q(0),
         ],
      q(taw) => [
         q(6383),
         q(0),
         ],
      q(tax) => [
         q(6384),
         q(0),
         ],
      q(tay) => [
         q(6385),
         q(0),
         ],
      q(taz) => [
         q(6386),
         q(0),
         ],
      q(tba) => [
         q(6387),
         q(0),
         ],
      q(tbb) => [
         q(6388),
         q(0),
         ],
      q(tbc) => [
         q(6389),
         q(0),
         ],
      q(tbd) => [
         q(6390),
         q(0),
         ],
      q(tbe) => [
         q(6391),
         q(0),
         ],
      q(tbf) => [
         q(6392),
         q(0),
         ],
      q(tbg) => [
         q(6393),
         q(0),
         ],
      q(tbh) => [
         q(6394),
         q(0),
         ],
      q(tbi) => [
         q(6395),
         q(0),
         ],
      q(tbj) => [
         q(6396),
         q(0),
         ],
      q(tbk) => [
         q(6397),
         q(0),
         ],
      q(tbl) => [
         q(6398),
         q(0),
         ],
      q(tbm) => [
         q(6399),
         q(0),
         ],
      q(tbn) => [
         q(6400),
         q(0),
         ],
      q(tbo) => [
         q(6401),
         q(0),
         ],
      q(tbp) => [
         q(6402),
         q(0),
         ],
      q(tbq) => [
         q(0527),
         q(0),
         ],
      q(tbr) => [
         q(6403),
         q(0),
         ],
      q(tbs) => [
         q(6404),
         q(0),
         ],
      q(tbt) => [
         q(6405),
         q(0),
         ],
      q(tbu) => [
         q(6406),
         q(0),
         ],
      q(tbv) => [
         q(6407),
         q(0),
         ],
      q(tbw) => [
         q(6408),
         q(0),
         ],
      q(tbx) => [
         q(6409),
         q(0),
         ],
      q(tby) => [
         q(6410),
         q(0),
         ],
      q(tbz) => [
         q(6411),
         q(0),
         ],
      q(tca) => [
         q(6412),
         q(0),
         ],
      q(tcb) => [
         q(6413),
         q(0),
         ],
      q(tcc) => [
         q(6414),
         q(0),
         ],
      q(tcd) => [
         q(6415),
         q(0),
         ],
      q(tce) => [
         q(6416),
         q(0),
         ],
      q(tcf) => [
         q(6417),
         q(0),
         ],
      q(tcg) => [
         q(6418),
         q(0),
         ],
      q(tch) => [
         q(6419),
         q(0),
         ],
      q(tci) => [
         q(6420),
         q(0),
         ],
      q(tck) => [
         q(6421),
         q(0),
         ],
      q(tcl) => [
         q(6422),
         q(0),
         ],
      q(tcm) => [
         q(6423),
         q(0),
         ],
      q(tcn) => [
         q(6424),
         q(0),
         ],
      q(tco) => [
         q(6425),
         q(0),
         ],
      q(tcp) => [
         q(6426),
         q(0),
         ],
      q(tcq) => [
         q(6427),
         q(0),
         ],
      q(tcs) => [
         q(6428),
         q(0),
         ],
      q(tct) => [
         q(6429),
         q(0),
         ],
      q(tcu) => [
         q(6430),
         q(0),
         ],
      q(tcw) => [
         q(6431),
         q(0),
         ],
      q(tcx) => [
         q(6432),
         q(0),
         ],
      q(tcy) => [
         q(6433),
         q(0),
         ],
      q(tcz) => [
         q(6434),
         q(0),
         ],
      q(tda) => [
         q(6435),
         q(0),
         ],
      q(tdb) => [
         q(6436),
         q(0),
         ],
      q(tdc) => [
         q(6437),
         q(0),
         ],
      q(tdd) => [
         q(6438),
         q(0),
         ],
      q(tde) => [
         q(6439),
         q(0),
         ],
      q(tdf) => [
         q(6440),
         q(0),
         ],
      q(tdg) => [
         q(6441),
         q(0),
         ],
      q(tdh) => [
         q(6442),
         q(0),
         ],
      q(tdi) => [
         q(6443),
         q(0),
         ],
      q(tdj) => [
         q(6444),
         q(0),
         ],
      q(tdk) => [
         q(6445),
         q(0),
         ],
      q(tdl) => [
         q(6446),
         q(0),
         ],
      q(tdn) => [
         q(6447),
         q(0),
         ],
      q(tdo) => [
         q(6448),
         q(0),
         ],
      q(tdq) => [
         q(6449),
         q(0),
         ],
      q(tdr) => [
         q(6450),
         q(0),
         ],
      q(tds) => [
         q(6451),
         q(0),
         ],
      q(tdt) => [
         q(6452),
         q(0),
         ],
      q(tdu) => [
         q(6453),
         q(0),
         ],
      q(tdv) => [
         q(6454),
         q(0),
         ],
      q(tdx) => [
         q(6455),
         q(0),
         ],
      q(tdy) => [
         q(6456),
         q(0),
         ],
      q(tea) => [
         q(6457),
         q(0),
         ],
      q(teb) => [
         q(6458),
         q(0),
         ],
      q(tec) => [
         q(6459),
         q(0),
         ],
      q(ted) => [
         q(6460),
         q(0),
         ],
      q(tee) => [
         q(6461),
         q(0),
         ],
      q(tef) => [
         q(6462),
         q(0),
         ],
      q(teg) => [
         q(6463),
         q(0),
         ],
      q(teh) => [
         q(6464),
         q(0),
         ],
      q(tei) => [
         q(6465),
         q(0),
         ],
      q(tek) => [
         q(6466),
         q(0),
         ],
      q(tel) => [
         q(0420),
         q(0),
         ],
      q(tem) => [
         q(0421),
         q(0),
         ],
      q(ten) => [
         q(6467),
         q(0),
         ],
      q(teo) => [
         q(6468),
         q(0),
         ],
      q(tep) => [
         q(6469),
         q(0),
         ],
      q(teq) => [
         q(6470),
         q(0),
         ],
      q(ter) => [
         q(0422),
         q(0),
         ],
      q(tes) => [
         q(6471),
         q(0),
         ],
      q(tet) => [
         q(0423),
         q(0),
         ],
      q(teu) => [
         q(6472),
         q(0),
         ],
      q(tev) => [
         q(6473),
         q(0),
         ],
      q(tew) => [
         q(6474),
         q(0),
         ],
      q(tex) => [
         q(6475),
         q(0),
         ],
      q(tey) => [
         q(6476),
         q(0),
         ],
      q(tfi) => [
         q(6477),
         q(0),
         ],
      q(tfn) => [
         q(6478),
         q(0),
         ],
      q(tfo) => [
         q(6479),
         q(0),
         ],
      q(tfr) => [
         q(6480),
         q(0),
         ],
      q(tft) => [
         q(6481),
         q(0),
         ],
      q(tga) => [
         q(6482),
         q(0),
         ],
      q(tgb) => [
         q(6483),
         q(0),
         ],
      q(tgc) => [
         q(6484),
         q(0),
         ],
      q(tgd) => [
         q(6485),
         q(0),
         ],
      q(tge) => [
         q(6486),
         q(0),
         ],
      q(tgf) => [
         q(6487),
         q(0),
         ],
      q(tgh) => [
         q(6488),
         q(0),
         ],
      q(tgi) => [
         q(6489),
         q(0),
         ],
      q(tgj) => [
         q(6490),
         q(0),
         ],
      q(tgk) => [
         q(0424),
         q(0),
         ],
      q(tgl) => [
         q(0425),
         q(0),
         ],
      q(tgn) => [
         q(6491),
         q(0),
         ],
      q(tgo) => [
         q(6492),
         q(0),
         ],
      q(tgp) => [
         q(6493),
         q(0),
         ],
      q(tgq) => [
         q(6494),
         q(0),
         ],
      q(tgr) => [
         q(6495),
         q(0),
         ],
      q(tgs) => [
         q(6496),
         q(0),
         ],
      q(tgt) => [
         q(6497),
         q(0),
         ],
      q(tgu) => [
         q(6498),
         q(0),
         ],
      q(tgv) => [
         q(6499),
         q(0),
         ],
      q(tgw) => [
         q(6500),
         q(0),
         ],
      q(tgx) => [
         q(6501),
         q(0),
         ],
      q(tgy) => [
         q(6502),
         q(0),
         ],
      q(tgz) => [
         q(6503),
         q(0),
         ],
      q(tha) => [
         q(0426),
         q(0),
         ],
      q(thc) => [
         q(6504),
         q(0),
         ],
      q(thd) => [
         q(6505),
         q(0),
         ],
      q(the) => [
         q(6506),
         q(0),
         ],
      q(thf) => [
         q(6507),
         q(0),
         ],
      q(thh) => [
         q(6508),
         q(0),
         ],
      q(thi) => [
         q(6509),
         q(0),
         ],
      q(thk) => [
         q(6510),
         q(0),
         ],
      q(thl) => [
         q(6511),
         q(0),
         ],
      q(thm) => [
         q(6512),
         q(0),
         ],
      q(thn) => [
         q(6513),
         q(0),
         ],
      q(thp) => [
         q(6514),
         q(0),
         ],
      q(thq) => [
         q(6515),
         q(0),
         ],
      q(thr) => [
         q(6516),
         q(0),
         ],
      q(ths) => [
         q(6517),
         q(0),
         ],
      q(tht) => [
         q(6518),
         q(0),
         ],
      q(thu) => [
         q(6519),
         q(0),
         ],
      q(thv) => [
         q(6520),
         q(0),
         ],
      q(thw) => [
         q(6521),
         q(0),
         ],
      q(thx) => [
         q(6522),
         q(0),
         ],
      q(thy) => [
         q(6523),
         q(0),
         ],
      q(thz) => [
         q(6524),
         q(0),
         ],
      q(tia) => [
         q(6525),
         q(0),
         ],
      q(tib) => [
         q(0427),
         q(0),
         ],
      q(tic) => [
         q(6526),
         q(0),
         ],
      q(tid) => [
         q(6527),
         q(0),
         ],
      q(tif) => [
         q(6528),
         q(0),
         ],
      q(tig) => [
         q(0428),
         q(0),
         ],
      q(tih) => [
         q(6529),
         q(0),
         ],
      q(tii) => [
         q(6530),
         q(0),
         ],
      q(tij) => [
         q(6531),
         q(0),
         ],
      q(tik) => [
         q(6532),
         q(0),
         ],
      q(til) => [
         q(6533),
         q(0),
         ],
      q(tim) => [
         q(6534),
         q(0),
         ],
      q(tin) => [
         q(6535),
         q(0),
         ],
      q(tio) => [
         q(6536),
         q(0),
         ],
      q(tip) => [
         q(6537),
         q(0),
         ],
      q(tiq) => [
         q(6538),
         q(0),
         ],
      q(tir) => [
         q(0429),
         q(0),
         ],
      q(tis) => [
         q(6539),
         q(0),
         ],
      q(tit) => [
         q(6540),
         q(0),
         ],
      q(tiu) => [
         q(6541),
         q(0),
         ],
      q(tiv) => [
         q(0430),
         q(0),
         ],
      q(tiw) => [
         q(6542),
         q(0),
         ],
      q(tix) => [
         q(6543),
         q(0),
         ],
      q(tiy) => [
         q(6544),
         q(0),
         ],
      q(tiz) => [
         q(6545),
         q(0),
         ],
      q(tja) => [
         q(6546),
         q(0),
         ],
      q(tjg) => [
         q(6547),
         q(0),
         ],
      q(tji) => [
         q(6548),
         q(0),
         ],
      q(tjl) => [
         q(6549),
         q(0),
         ],
      q(tjm) => [
         q(6550),
         q(0),
         ],
      q(tjn) => [
         q(6551),
         q(0),
         ],
      q(tjo) => [
         q(6552),
         q(0),
         ],
      q(tjs) => [
         q(6553),
         q(0),
         ],
      q(tju) => [
         q(6554),
         q(0),
         ],
      q(tjw) => [
         q(6555),
         q(0),
         ],
      q(tka) => [
         q(6556),
         q(0),
         ],
      q(tkb) => [
         q(6557),
         q(0),
         ],
      q(tkd) => [
         q(6558),
         q(0),
         ],
      q(tke) => [
         q(6559),
         q(0),
         ],
      q(tkf) => [
         q(6560),
         q(0),
         ],
      q(tkg) => [
         q(6561),
         q(0),
         ],
      q(tkl) => [
         q(0431),
         q(0),
         ],
      q(tkm) => [
         q(6562),
         q(0),
         ],
      q(tkn) => [
         q(6563),
         q(0),
         ],
      q(tkp) => [
         q(6564),
         q(0),
         ],
      q(tkq) => [
         q(6565),
         q(0),
         ],
      q(tkr) => [
         q(6566),
         q(0),
         ],
      q(tks) => [
         q(6567),
         q(0),
         ],
      q(tkt) => [
         q(6568),
         q(0),
         ],
      q(tku) => [
         q(6569),
         q(0),
         ],
      q(tkw) => [
         q(6570),
         q(0),
         ],
      q(tkx) => [
         q(6571),
         q(0),
         ],
      q(tkz) => [
         q(6572),
         q(0),
         ],
      q(tla) => [
         q(6573),
         q(0),
         ],
      q(tlb) => [
         q(6574),
         q(0),
         ],
      q(tlc) => [
         q(6575),
         q(0),
         ],
      q(tld) => [
         q(6576),
         q(0),
         ],
      q(tlf) => [
         q(6577),
         q(0),
         ],
      q(tlg) => [
         q(6578),
         q(0),
         ],
      q(tlh) => [
         q(0432),
         q(0),
         ],
      q(tli) => [
         q(0433),
         q(0),
         ],
      q(tlj) => [
         q(6579),
         q(0),
         ],
      q(tlk) => [
         q(6580),
         q(0),
         ],
      q(tll) => [
         q(6581),
         q(0),
         ],
      q(tlm) => [
         q(6582),
         q(0),
         ],
      q(tln) => [
         q(6583),
         q(0),
         ],
      q(tlo) => [
         q(6584),
         q(0),
         ],
      q(tlp) => [
         q(6585),
         q(0),
         ],
      q(tlq) => [
         q(6586),
         q(0),
         ],
      q(tlr) => [
         q(6587),
         q(0),
         ],
      q(tls) => [
         q(6588),
         q(0),
         ],
      q(tlt) => [
         q(6589),
         q(0),
         ],
      q(tlu) => [
         q(6590),
         q(0),
         ],
      q(tlv) => [
         q(6591),
         q(0),
         ],
      q(tlx) => [
         q(6592),
         q(0),
         ],
      q(tly) => [
         q(6593),
         q(0),
         ],
      q(tma) => [
         q(6594),
         q(0),
         ],
      q(tmb) => [
         q(6595),
         q(0),
         ],
      q(tmc) => [
         q(6596),
         q(0),
         ],
      q(tmd) => [
         q(6597),
         q(0),
         ],
      q(tme) => [
         q(6598),
         q(0),
         ],
      q(tmf) => [
         q(6599),
         q(0),
         ],
      q(tmg) => [
         q(6600),
         q(0),
         ],
      q(tmh) => [
         q(0434),
         q(0),
         ],
      q(tmi) => [
         q(6601),
         q(0),
         ],
      q(tmj) => [
         q(6602),
         q(0),
         ],
      q(tmk) => [
         q(6603),
         q(0),
         ],
      q(tml) => [
         q(6604),
         q(0),
         ],
      q(tmm) => [
         q(6605),
         q(0),
         ],
      q(tmn) => [
         q(6606),
         q(0),
         ],
      q(tmo) => [
         q(6607),
         q(0),
         ],
      q(tmp) => [
         q(6608),
         q(0),
         ],
      q(tmq) => [
         q(6609),
         q(0),
         ],
      q(tmr) => [
         q(6610),
         q(0),
         ],
      q(tms) => [
         q(6611),
         q(0),
         ],
      q(tmt) => [
         q(6612),
         q(0),
         ],
      q(tmu) => [
         q(6613),
         q(0),
         ],
      q(tmv) => [
         q(6614),
         q(0),
         ],
      q(tmw) => [
         q(6615),
         q(0),
         ],
      q(tmy) => [
         q(6616),
         q(0),
         ],
      q(tmz) => [
         q(6617),
         q(0),
         ],
      q(tna) => [
         q(6618),
         q(0),
         ],
      q(tnb) => [
         q(6619),
         q(0),
         ],
      q(tnc) => [
         q(6620),
         q(0),
         ],
      q(tnd) => [
         q(6621),
         q(0),
         ],
      q(tne) => [
         q(6622),
         q(0),
         ],
      q(tng) => [
         q(6623),
         q(0),
         ],
      q(tnh) => [
         q(6624),
         q(0),
         ],
      q(tni) => [
         q(6625),
         q(0),
         ],
      q(tnk) => [
         q(6626),
         q(0),
         ],
      q(tnl) => [
         q(6627),
         q(0),
         ],
      q(tnm) => [
         q(6628),
         q(0),
         ],
      q(tnn) => [
         q(6629),
         q(0),
         ],
      q(tno) => [
         q(6630),
         q(0),
         ],
      q(tnp) => [
         q(6631),
         q(0),
         ],
      q(tnq) => [
         q(6632),
         q(0),
         ],
      q(tnr) => [
         q(6633),
         q(0),
         ],
      q(tns) => [
         q(6634),
         q(0),
         ],
      q(tnt) => [
         q(6635),
         q(0),
         ],
      q(tnu) => [
         q(6636),
         q(0),
         ],
      q(tnv) => [
         q(6637),
         q(0),
         ],
      q(tnw) => [
         q(6638),
         q(0),
         ],
      q(tnx) => [
         q(6639),
         q(0),
         ],
      q(tny) => [
         q(6640),
         q(0),
         ],
      q(tnz) => [
         q(6641),
         q(0),
         ],
      q(tob) => [
         q(6642),
         q(0),
         ],
      q(toc) => [
         q(6643),
         q(0),
         ],
      q(tod) => [
         q(6644),
         q(0),
         ],
      q(toe) => [
         q(6645),
         q(0),
         ],
      q(tof) => [
         q(6646),
         q(0),
         ],
      q(tog) => [
         q(0435),
         q(0),
         ],
      q(toh) => [
         q(6647),
         q(0),
         ],
      q(toi) => [
         q(6648),
         q(0),
         ],
      q(toj) => [
         q(6649),
         q(0),
         ],
      q(tol) => [
         q(6650),
         q(0),
         ],
      q(tom) => [
         q(6651),
         q(0),
         ],
      q(ton) => [
         q(0436),
         q(0),
         ],
      q(too) => [
         q(6652),
         q(0),
         ],
      q(top) => [
         q(6653),
         q(0),
         ],
      q(toq) => [
         q(6654),
         q(0),
         ],
      q(tor) => [
         q(6655),
         q(0),
         ],
      q(tos) => [
         q(6656),
         q(0),
         ],
      q(tou) => [
         q(6657),
         q(0),
         ],
      q(tov) => [
         q(6658),
         q(0),
         ],
      q(tow) => [
         q(6659),
         q(0),
         ],
      q(tox) => [
         q(6660),
         q(0),
         ],
      q(toy) => [
         q(6661),
         q(0),
         ],
      q(toz) => [
         q(6662),
         q(0),
         ],
      q(tpa) => [
         q(6663),
         q(0),
         ],
      q(tpc) => [
         q(6664),
         q(0),
         ],
      q(tpe) => [
         q(6665),
         q(0),
         ],
      q(tpf) => [
         q(6666),
         q(0),
         ],
      q(tpg) => [
         q(6667),
         q(0),
         ],
      q(tpi) => [
         q(0437),
         q(0),
         ],
      q(tpj) => [
         q(6668),
         q(0),
         ],
      q(tpk) => [
         q(6669),
         q(0),
         ],
      q(tpl) => [
         q(6670),
         q(0),
         ],
      q(tpm) => [
         q(6671),
         q(0),
         ],
      q(tpn) => [
         q(6672),
         q(0),
         ],
      q(tpo) => [
         q(6673),
         q(0),
         ],
      q(tpp) => [
         q(6674),
         q(0),
         ],
      q(tpq) => [
         q(6675),
         q(0),
         ],
      q(tpr) => [
         q(6676),
         q(0),
         ],
      q(tpt) => [
         q(6677),
         q(0),
         ],
      q(tpu) => [
         q(6678),
         q(0),
         ],
      q(tpv) => [
         q(6679),
         q(0),
         ],
      q(tpw) => [
         q(6680),
         q(0),
         ],
      q(tpx) => [
         q(6681),
         q(0),
         ],
      q(tpy) => [
         q(6682),
         q(0),
         ],
      q(tpz) => [
         q(6683),
         q(0),
         ],
      q(tqb) => [
         q(6684),
         q(0),
         ],
      q(tql) => [
         q(6685),
         q(0),
         ],
      q(tqm) => [
         q(6686),
         q(0),
         ],
      q(tqn) => [
         q(6687),
         q(0),
         ],
      q(tqo) => [
         q(6688),
         q(0),
         ],
      q(tqp) => [
         q(6689),
         q(0),
         ],
      q(tqq) => [
         q(6690),
         q(0),
         ],
      q(tqr) => [
         q(6691),
         q(0),
         ],
      q(tqt) => [
         q(6692),
         q(0),
         ],
      q(tqu) => [
         q(6693),
         q(0),
         ],
      q(tqw) => [
         q(6694),
         q(0),
         ],
      q(tra) => [
         q(6695),
         q(0),
         ],
      q(trb) => [
         q(6696),
         q(0),
         ],
      q(trc) => [
         q(6697),
         q(0),
         ],
      q(trd) => [
         q(6698),
         q(0),
         ],
      q(tre) => [
         q(6699),
         q(0),
         ],
      q(trf) => [
         q(6700),
         q(0),
         ],
      q(trg) => [
         q(6701),
         q(0),
         ],
      q(trh) => [
         q(6702),
         q(0),
         ],
      q(tri) => [
         q(6703),
         q(0),
         ],
      q(trj) => [
         q(6704),
         q(0),
         ],
      q(trk) => [
         q(0528),
         q(0),
         ],
      q(trl) => [
         q(6705),
         q(0),
         ],
      q(trm) => [
         q(6706),
         q(0),
         ],
      q(trn) => [
         q(6707),
         q(0),
         ],
      q(tro) => [
         q(6708),
         q(0),
         ],
      q(trp) => [
         q(6709),
         q(0),
         ],
      q(trq) => [
         q(6710),
         q(0),
         ],
      q(trr) => [
         q(6711),
         q(0),
         ],
      q(trs) => [
         q(6712),
         q(0),
         ],
      q(trt) => [
         q(6713),
         q(0),
         ],
      q(tru) => [
         q(6714),
         q(0),
         ],
      q(trv) => [
         q(6715),
         q(0),
         ],
      q(trw) => [
         q(6716),
         q(0),
         ],
      q(trx) => [
         q(6717),
         q(0),
         ],
      q(try) => [
         q(6718),
         q(0),
         ],
      q(trz) => [
         q(6719),
         q(0),
         ],
      q(tsa) => [
         q(6720),
         q(0),
         ],
      q(tsb) => [
         q(6721),
         q(0),
         ],
      q(tsc) => [
         q(6722),
         q(0),
         ],
      q(tsd) => [
         q(6723),
         q(0),
         ],
      q(tse) => [
         q(6724),
         q(0),
         ],
      q(tsf) => [
         q(6725),
         q(0),
         ],
      q(tsg) => [
         q(6726),
         q(0),
         ],
      q(tsh) => [
         q(6727),
         q(0),
         ],
      q(tsi) => [
         q(0438),
         q(0),
         ],
      q(tsj) => [
         q(6728),
         q(0),
         ],
      q(tsk) => [
         q(6729),
         q(0),
         ],
      q(tsl) => [
         q(6730),
         q(0),
         ],
      q(tsm) => [
         q(6731),
         q(0),
         ],
      q(tsn) => [
         q(0439),
         q(0),
         ],
      q(tso) => [
         q(0440),
         q(0),
         ],
      q(tsp) => [
         q(6732),
         q(0),
         ],
      q(tsq) => [
         q(6733),
         q(0),
         ],
      q(tsr) => [
         q(6734),
         q(0),
         ],
      q(tss) => [
         q(6735),
         q(0),
         ],
      q(tst) => [
         q(6736),
         q(0),
         ],
      q(tsu) => [
         q(6737),
         q(0),
         ],
      q(tsv) => [
         q(6738),
         q(0),
         ],
      q(tsw) => [
         q(6739),
         q(0),
         ],
      q(tsx) => [
         q(6740),
         q(0),
         ],
      q(tsy) => [
         q(6741),
         q(0),
         ],
      q(tsz) => [
         q(6742),
         q(0),
         ],
      q(tta) => [
         q(6743),
         q(0),
         ],
      q(ttb) => [
         q(6744),
         q(0),
         ],
      q(ttc) => [
         q(6745),
         q(0),
         ],
      q(ttd) => [
         q(6746),
         q(0),
         ],
      q(tte) => [
         q(6747),
         q(0),
         ],
      q(ttf) => [
         q(6748),
         q(0),
         ],
      q(ttg) => [
         q(6749),
         q(0),
         ],
      q(tth) => [
         q(6750),
         q(0),
         ],
      q(tti) => [
         q(6751),
         q(0),
         ],
      q(ttj) => [
         q(6752),
         q(0),
         ],
      q(ttk) => [
         q(6753),
         q(0),
         ],
      q(ttl) => [
         q(6754),
         q(0),
         ],
      q(ttm) => [
         q(6755),
         q(0),
         ],
      q(ttn) => [
         q(6756),
         q(0),
         ],
      q(tto) => [
         q(6757),
         q(0),
         ],
      q(ttp) => [
         q(6758),
         q(0),
         ],
      q(ttq) => [
         q(6759),
         q(0),
         ],
      q(ttr) => [
         q(6760),
         q(0),
         ],
      q(tts) => [
         q(6761),
         q(0),
         ],
      q(ttt) => [
         q(6762),
         q(0),
         ],
      q(ttu) => [
         q(6763),
         q(0),
         ],
      q(ttv) => [
         q(6764),
         q(0),
         ],
      q(ttw) => [
         q(6765),
         q(0),
         ],
      q(tty) => [
         q(6766),
         q(0),
         ],
      q(ttz) => [
         q(6767),
         q(0),
         ],
      q(tua) => [
         q(6768),
         q(0),
         ],
      q(tub) => [
         q(6769),
         q(0),
         ],
      q(tuc) => [
         q(6770),
         q(0),
         ],
      q(tud) => [
         q(6771),
         q(0),
         ],
      q(tue) => [
         q(6772),
         q(0),
         ],
      q(tuf) => [
         q(6773),
         q(0),
         ],
      q(tug) => [
         q(6774),
         q(0),
         ],
      q(tuh) => [
         q(6775),
         q(0),
         ],
      q(tui) => [
         q(6776),
         q(0),
         ],
      q(tuj) => [
         q(6777),
         q(0),
         ],
      q(tuk) => [
         q(0441),
         q(0),
         ],
      q(tul) => [
         q(6778),
         q(0),
         ],
      q(tum) => [
         q(0442),
         q(0),
         ],
      q(tun) => [
         q(6779),
         q(0),
         ],
      q(tuo) => [
         q(6780),
         q(0),
         ],
      q(tup) => [
         q(0443),
         q(0),
         ],
      q(tuq) => [
         q(6781),
         q(0),
         ],
      q(tur) => [
         q(0444),
         q(0),
         ],
      q(tus) => [
         q(6782),
         q(0),
         ],
      q(tut) => [
         q(0445),
         q(0),
         ],
      q(tuu) => [
         q(6783),
         q(0),
         ],
      q(tuv) => [
         q(6784),
         q(0),
         ],
      q(tuw) => [
         q(0529),
         q(0),
         ],
      q(tux) => [
         q(6785),
         q(0),
         ],
      q(tuy) => [
         q(6786),
         q(0),
         ],
      q(tuz) => [
         q(6787),
         q(0),
         ],
      q(tva) => [
         q(6788),
         q(0),
         ],
      q(tvd) => [
         q(6789),
         q(0),
         ],
      q(tve) => [
         q(6790),
         q(0),
         ],
      q(tvk) => [
         q(6791),
         q(0),
         ],
      q(tvl) => [
         q(0446),
         q(0),
         ],
      q(tvm) => [
         q(6792),
         q(0),
         ],
      q(tvn) => [
         q(6793),
         q(0),
         ],
      q(tvo) => [
         q(6794),
         q(0),
         ],
      q(tvs) => [
         q(6795),
         q(0),
         ],
      q(tvt) => [
         q(6796),
         q(0),
         ],
      q(tvu) => [
         q(6797),
         q(0),
         ],
      q(tvw) => [
         q(6798),
         q(0),
         ],
      q(tvy) => [
         q(6799),
         q(0),
         ],
      q(twa) => [
         q(6800),
         q(0),
         ],
      q(twb) => [
         q(6801),
         q(0),
         ],
      q(twc) => [
         q(6802),
         q(0),
         ],
      q(twd) => [
         q(6803),
         q(0),
         ],
      q(twe) => [
         q(6804),
         q(0),
         ],
      q(twf) => [
         q(6805),
         q(0),
         ],
      q(twg) => [
         q(6806),
         q(0),
         ],
      q(twh) => [
         q(6807),
         q(0),
         ],
      q(twi) => [
         q(0447),
         q(0),
         ],
      q(twl) => [
         q(6808),
         q(0),
         ],
      q(twm) => [
         q(6809),
         q(0),
         ],
      q(twn) => [
         q(6810),
         q(0),
         ],
      q(two) => [
         q(6811),
         q(0),
         ],
      q(twp) => [
         q(6812),
         q(0),
         ],
      q(twq) => [
         q(6813),
         q(0),
         ],
      q(twr) => [
         q(6814),
         q(0),
         ],
      q(twt) => [
         q(6815),
         q(0),
         ],
      q(twu) => [
         q(6816),
         q(0),
         ],
      q(tww) => [
         q(6817),
         q(0),
         ],
      q(twx) => [
         q(6818),
         q(0),
         ],
      q(twy) => [
         q(6819),
         q(0),
         ],
      q(txa) => [
         q(6820),
         q(0),
         ],
      q(txb) => [
         q(6821),
         q(0),
         ],
      q(txc) => [
         q(6822),
         q(0),
         ],
      q(txe) => [
         q(6823),
         q(0),
         ],
      q(txg) => [
         q(6824),
         q(0),
         ],
      q(txh) => [
         q(6825),
         q(0),
         ],
      q(txi) => [
         q(6826),
         q(0),
         ],
      q(txm) => [
         q(6827),
         q(0),
         ],
      q(txn) => [
         q(6828),
         q(0),
         ],
      q(txo) => [
         q(6829),
         q(0),
         ],
      q(txq) => [
         q(6830),
         q(0),
         ],
      q(txr) => [
         q(6831),
         q(0),
         ],
      q(txs) => [
         q(6832),
         q(0),
         ],
      q(txt) => [
         q(6833),
         q(0),
         ],
      q(txu) => [
         q(6834),
         q(0),
         ],
      q(txx) => [
         q(6835),
         q(0),
         ],
      q(txy) => [
         q(6836),
         q(0),
         ],
      q(tya) => [
         q(6837),
         q(0),
         ],
      q(tye) => [
         q(6838),
         q(0),
         ],
      q(tyh) => [
         q(6839),
         q(0),
         ],
      q(tyi) => [
         q(6840),
         q(0),
         ],
      q(tyj) => [
         q(6841),
         q(0),
         ],
      q(tyl) => [
         q(6842),
         q(0),
         ],
      q(tyn) => [
         q(6843),
         q(0),
         ],
      q(typ) => [
         q(6844),
         q(0),
         ],
      q(tyr) => [
         q(6845),
         q(0),
         ],
      q(tys) => [
         q(6846),
         q(0),
         ],
      q(tyt) => [
         q(6847),
         q(0),
         ],
      q(tyu) => [
         q(6848),
         q(0),
         ],
      q(tyv) => [
         q(0448),
         q(0),
         ],
      q(tyx) => [
         q(6849),
         q(0),
         ],
      q(tyz) => [
         q(6850),
         q(0),
         ],
      q(tza) => [
         q(6851),
         q(0),
         ],
      q(tzh) => [
         q(6852),
         q(0),
         ],
      q(tzj) => [
         q(6853),
         q(0),
         ],
      q(tzl) => [
         q(6854),
         q(0),
         ],
      q(tzm) => [
         q(6855),
         q(0),
         ],
      q(tzn) => [
         q(6856),
         q(0),
         ],
      q(tzo) => [
         q(6857),
         q(0),
         ],
      q(tzx) => [
         q(6858),
         q(0),
         ],
      q(uam) => [
         q(6859),
         q(0),
         ],
      q(uan) => [
         q(6860),
         q(0),
         ],
      q(uar) => [
         q(6861),
         q(0),
         ],
      q(uba) => [
         q(6862),
         q(0),
         ],
      q(ubi) => [
         q(6863),
         q(0),
         ],
      q(ubl) => [
         q(6864),
         q(0),
         ],
      q(ubr) => [
         q(6865),
         q(0),
         ],
      q(ubu) => [
         q(6866),
         q(0),
         ],
      q(uby) => [
         q(6867),
         q(0),
         ],
      q(uda) => [
         q(6868),
         q(0),
         ],
      q(ude) => [
         q(6869),
         q(0),
         ],
      q(udg) => [
         q(6870),
         q(0),
         ],
      q(udi) => [
         q(6871),
         q(0),
         ],
      q(udj) => [
         q(6872),
         q(0),
         ],
      q(udl) => [
         q(6873),
         q(0),
         ],
      q(udm) => [
         q(0449),
         q(0),
         ],
      q(udu) => [
         q(6874),
         q(0),
         ],
      q(ues) => [
         q(6875),
         q(0),
         ],
      q(ufi) => [
         q(6876),
         q(0),
         ],
      q(uga) => [
         q(0450),
         q(0),
         ],
      q(ugb) => [
         q(6877),
         q(0),
         ],
      q(uge) => [
         q(6878),
         q(0),
         ],
      q(ugn) => [
         q(6879),
         q(0),
         ],
      q(ugo) => [
         q(6880),
         q(0),
         ],
      q(ugy) => [
         q(6881),
         q(0),
         ],
      q(uha) => [
         q(6882),
         q(0),
         ],
      q(uhn) => [
         q(6883),
         q(0),
         ],
      q(uig) => [
         q(0451),
         q(0),
         ],
      q(uis) => [
         q(6884),
         q(0),
         ],
      q(uiv) => [
         q(6885),
         q(0),
         ],
      q(uji) => [
         q(6886),
         q(0),
         ],
      q(uka) => [
         q(6887),
         q(0),
         ],
      q(ukg) => [
         q(6888),
         q(0),
         ],
      q(ukh) => [
         q(6889),
         q(0),
         ],
      q(ukl) => [
         q(6890),
         q(0),
         ],
      q(ukp) => [
         q(6891),
         q(0),
         ],
      q(ukq) => [
         q(6892),
         q(0),
         ],
      q(ukr) => [
         q(0452),
         q(0),
         ],
      q(uks) => [
         q(6893),
         q(0),
         ],
      q(uku) => [
         q(6894),
         q(0),
         ],
      q(ukw) => [
         q(6895),
         q(0),
         ],
      q(uky) => [
         q(6896),
         q(0),
         ],
      q(ula) => [
         q(6897),
         q(0),
         ],
      q(ulb) => [
         q(6898),
         q(0),
         ],
      q(ulc) => [
         q(6899),
         q(0),
         ],
      q(ule) => [
         q(6900),
         q(0),
         ],
      q(ulf) => [
         q(6901),
         q(0),
         ],
      q(uli) => [
         q(6902),
         q(0),
         ],
      q(ulk) => [
         q(6903),
         q(0),
         ],
      q(ull) => [
         q(6904),
         q(0),
         ],
      q(ulm) => [
         q(6905),
         q(0),
         ],
      q(uln) => [
         q(6906),
         q(0),
         ],
      q(ulu) => [
         q(6907),
         q(0),
         ],
      q(ulw) => [
         q(6908),
         q(0),
         ],
      q(uma) => [
         q(6909),
         q(0),
         ],
      q(umb) => [
         q(0453),
         q(0),
         ],
      q(umc) => [
         q(6910),
         q(0),
         ],
      q(umd) => [
         q(6911),
         q(0),
         ],
      q(umg) => [
         q(6912),
         q(0),
         ],
      q(umi) => [
         q(6913),
         q(0),
         ],
      q(umm) => [
         q(6914),
         q(0),
         ],
      q(umn) => [
         q(6915),
         q(0),
         ],
      q(umo) => [
         q(6916),
         q(0),
         ],
      q(ump) => [
         q(6917),
         q(0),
         ],
      q(umr) => [
         q(6918),
         q(0),
         ],
      q(ums) => [
         q(6919),
         q(0),
         ],
      q(umu) => [
         q(6920),
         q(0),
         ],
      q(una) => [
         q(6921),
         q(0),
         ],
      q(und) => [
         q(0454),
         q(0),
         ],
      q(une) => [
         q(6922),
         q(0),
         ],
      q(ung) => [
         q(6923),
         q(0),
         ],
      q(unk) => [
         q(6924),
         q(0),
         ],
      q(unm) => [
         q(6925),
         q(0),
         ],
      q(unn) => [
         q(6926),
         q(0),
         ],
      q(unr) => [
         q(6927),
         q(0),
         ],
      q(unu) => [
         q(6928),
         q(0),
         ],
      q(unx) => [
         q(6929),
         q(0),
         ],
      q(unz) => [
         q(6930),
         q(0),
         ],
      q(uok) => [
         q(6931),
         q(0),
         ],
      q(upi) => [
         q(6932),
         q(0),
         ],
      q(upv) => [
         q(6933),
         q(0),
         ],
      q(ura) => [
         q(6934),
         q(0),
         ],
      q(urb) => [
         q(6935),
         q(0),
         ],
      q(urc) => [
         q(6936),
         q(0),
         ],
      q(urd) => [
         q(0455),
         q(0),
         ],
      q(ure) => [
         q(6937),
         q(0),
         ],
      q(urf) => [
         q(6938),
         q(0),
         ],
      q(urg) => [
         q(6939),
         q(0),
         ],
      q(urh) => [
         q(6940),
         q(0),
         ],
      q(uri) => [
         q(6941),
         q(0),
         ],
      q(urj) => [
         q(0530),
         q(0),
         ],
      q(urk) => [
         q(6942),
         q(0),
         ],
      q(url) => [
         q(6943),
         q(0),
         ],
      q(urm) => [
         q(6944),
         q(0),
         ],
      q(urn) => [
         q(6945),
         q(0),
         ],
      q(uro) => [
         q(6946),
         q(0),
         ],
      q(urp) => [
         q(6947),
         q(0),
         ],
      q(urr) => [
         q(6948),
         q(0),
         ],
      q(urt) => [
         q(6949),
         q(0),
         ],
      q(uru) => [
         q(6950),
         q(0),
         ],
      q(urv) => [
         q(6951),
         q(0),
         ],
      q(urw) => [
         q(6952),
         q(0),
         ],
      q(urx) => [
         q(6953),
         q(0),
         ],
      q(ury) => [
         q(6954),
         q(0),
         ],
      q(urz) => [
         q(6955),
         q(0),
         ],
      q(usa) => [
         q(6956),
         q(0),
         ],
      q(ush) => [
         q(6957),
         q(0),
         ],
      q(usi) => [
         q(6958),
         q(0),
         ],
      q(usk) => [
         q(6959),
         q(0),
         ],
      q(usp) => [
         q(6960),
         q(0),
         ],
      q(usu) => [
         q(6961),
         q(0),
         ],
      q(uta) => [
         q(6962),
         q(0),
         ],
      q(ute) => [
         q(6963),
         q(0),
         ],
      q(utp) => [
         q(6964),
         q(0),
         ],
      q(utr) => [
         q(6965),
         q(0),
         ],
      q(utu) => [
         q(6966),
         q(0),
         ],
      q(uum) => [
         q(6967),
         q(0),
         ],
      q(uun) => [
         q(6968),
         q(0),
         ],
      q(uur) => [
         q(6969),
         q(0),
         ],
      q(uuu) => [
         q(6970),
         q(0),
         ],
      q(uve) => [
         q(6971),
         q(0),
         ],
      q(uvh) => [
         q(6972),
         q(0),
         ],
      q(uvl) => [
         q(6973),
         q(0),
         ],
      q(uwa) => [
         q(6974),
         q(0),
         ],
      q(uya) => [
         q(6975),
         q(0),
         ],
      q(uzb) => [
         q(0456),
         q(0),
         ],
      q(uzn) => [
         q(6976),
         q(0),
         ],
      q(uzs) => [
         q(6977),
         q(0),
         ],
      q(vaa) => [
         q(6978),
         q(0),
         ],
      q(vae) => [
         q(6979),
         q(0),
         ],
      q(vaf) => [
         q(6980),
         q(0),
         ],
      q(vag) => [
         q(6981),
         q(0),
         ],
      q(vah) => [
         q(6982),
         q(0),
         ],
      q(vai) => [
         q(0457),
         q(0),
         ],
      q(vaj) => [
         q(6983),
         q(0),
         ],
      q(val) => [
         q(6984),
         q(0),
         ],
      q(vam) => [
         q(6985),
         q(0),
         ],
      q(van) => [
         q(6986),
         q(0),
         ],
      q(vao) => [
         q(6987),
         q(0),
         ],
      q(vap) => [
         q(6988),
         q(0),
         ],
      q(var) => [
         q(6989),
         q(0),
         ],
      q(vas) => [
         q(6990),
         q(0),
         ],
      q(vau) => [
         q(6991),
         q(0),
         ],
      q(vav) => [
         q(6992),
         q(0),
         ],
      q(vay) => [
         q(6993),
         q(0),
         ],
      q(vbb) => [
         q(6994),
         q(0),
         ],
      q(vbk) => [
         q(6995),
         q(0),
         ],
      q(vec) => [
         q(6996),
         q(0),
         ],
      q(ved) => [
         q(6997),
         q(0),
         ],
      q(vel) => [
         q(6998),
         q(0),
         ],
      q(vem) => [
         q(6999),
         q(0),
         ],
      q(ven) => [
         q(0458),
         q(0),
         ],
      q(veo) => [
         q(7000),
         q(0),
         ],
      q(vep) => [
         q(7001),
         q(0),
         ],
      q(ver) => [
         q(7002),
         q(0),
         ],
      q(vgr) => [
         q(7003),
         q(0),
         ],
      q(vgt) => [
         q(7004),
         q(0),
         ],
      q(vic) => [
         q(7005),
         q(0),
         ],
      q(vid) => [
         q(7006),
         q(0),
         ],
      q(vie) => [
         q(0459),
         q(0),
         ],
      q(vif) => [
         q(7007),
         q(0),
         ],
      q(vig) => [
         q(7008),
         q(0),
         ],
      q(vil) => [
         q(7009),
         q(0),
         ],
      q(vin) => [
         q(7010),
         q(0),
         ],
      q(vis) => [
         q(7011),
         q(0),
         ],
      q(vit) => [
         q(7012),
         q(0),
         ],
      q(viv) => [
         q(7013),
         q(0),
         ],
      q(vka) => [
         q(7014),
         q(0),
         ],
      q(vki) => [
         q(7015),
         q(0),
         ],
      q(vkj) => [
         q(7016),
         q(0),
         ],
      q(vkk) => [
         q(7017),
         q(0),
         ],
      q(vkl) => [
         q(7018),
         q(0),
         ],
      q(vkm) => [
         q(7019),
         q(0),
         ],
      q(vko) => [
         q(7020),
         q(0),
         ],
      q(vkp) => [
         q(7021),
         q(0),
         ],
      q(vkt) => [
         q(7022),
         q(0),
         ],
      q(vku) => [
         q(7023),
         q(0),
         ],
      q(vlp) => [
         q(7024),
         q(0),
         ],
      q(vls) => [
         q(7025),
         q(0),
         ],
      q(vma) => [
         q(7026),
         q(0),
         ],
      q(vmb) => [
         q(7027),
         q(0),
         ],
      q(vmc) => [
         q(7028),
         q(0),
         ],
      q(vmd) => [
         q(7029),
         q(0),
         ],
      q(vme) => [
         q(7030),
         q(0),
         ],
      q(vmf) => [
         q(7031),
         q(0),
         ],
      q(vmg) => [
         q(7032),
         q(0),
         ],
      q(vmh) => [
         q(7033),
         q(0),
         ],
      q(vmi) => [
         q(7034),
         q(0),
         ],
      q(vmj) => [
         q(7035),
         q(0),
         ],
      q(vmk) => [
         q(7036),
         q(0),
         ],
      q(vml) => [
         q(7037),
         q(0),
         ],
      q(vmm) => [
         q(7038),
         q(0),
         ],
      q(vmp) => [
         q(7039),
         q(0),
         ],
      q(vmq) => [
         q(7040),
         q(0),
         ],
      q(vmr) => [
         q(7041),
         q(0),
         ],
      q(vms) => [
         q(7042),
         q(0),
         ],
      q(vmu) => [
         q(7043),
         q(0),
         ],
      q(vmv) => [
         q(7044),
         q(0),
         ],
      q(vmw) => [
         q(7045),
         q(0),
         ],
      q(vmx) => [
         q(7046),
         q(0),
         ],
      q(vmy) => [
         q(7047),
         q(0),
         ],
      q(vmz) => [
         q(7048),
         q(0),
         ],
      q(vnk) => [
         q(7049),
         q(0),
         ],
      q(vnm) => [
         q(7050),
         q(0),
         ],
      q(vnp) => [
         q(7051),
         q(0),
         ],
      q(vol) => [
         q(0460),
         q(0),
         ],
      q(vor) => [
         q(7052),
         q(0),
         ],
      q(vot) => [
         q(0461),
         q(0),
         ],
      q(vra) => [
         q(7053),
         q(0),
         ],
      q(vro) => [
         q(7052),
         q(0),
         ],
      q(vrs) => [
         q(7054),
         q(0),
         ],
      q(vrt) => [
         q(7055),
         q(0),
         ],
      q(vsi) => [
         q(7056),
         q(0),
         ],
      q(vsl) => [
         q(7057),
         q(0),
         ],
      q(vsv) => [
         q(7058),
         q(0),
         ],
      q(vto) => [
         q(7059),
         q(0),
         ],
      q(vum) => [
         q(7060),
         q(0),
         ],
      q(vun) => [
         q(7061),
         q(0),
         ],
      q(vut) => [
         q(7062),
         q(0),
         ],
      q(vwa) => [
         q(7063),
         q(0),
         ],
      q(waa) => [
         q(7064),
         q(0),
         ],
      q(wab) => [
         q(7065),
         q(0),
         ],
      q(wac) => [
         q(7066),
         q(0),
         ],
      q(wad) => [
         q(7067),
         q(0),
         ],
      q(wae) => [
         q(7068),
         q(0),
         ],
      q(waf) => [
         q(7069),
         q(0),
         ],
      q(wag) => [
         q(7070),
         q(0),
         ],
      q(wah) => [
         q(7071),
         q(0),
         ],
      q(wai) => [
         q(7072),
         q(0),
         ],
      q(waj) => [
         q(7073),
         q(0),
         ],
      q(wak) => [
         q(0462),
         q(0),
         ],
      q(wal) => [
         q(0463),
         q(1),
         ],
      q(wam) => [
         q(7074),
         q(0),
         ],
      q(wan) => [
         q(7075),
         q(0),
         ],
      q(wao) => [
         q(7076),
         q(0),
         ],
      q(wap) => [
         q(7077),
         q(0),
         ],
      q(waq) => [
         q(7078),
         q(0),
         ],
      q(war) => [
         q(0464),
         q(1),
         ],
      q(was) => [
         q(0465),
         q(0),
         ],
      q(wat) => [
         q(7079),
         q(0),
         ],
      q(wau) => [
         q(7080),
         q(0),
         ],
      q(wav) => [
         q(7081),
         q(0),
         ],
      q(waw) => [
         q(7082),
         q(0),
         ],
      q(wax) => [
         q(7083),
         q(0),
         ],
      q(way) => [
         q(7084),
         q(0),
         ],
      q(waz) => [
         q(7085),
         q(0),
         ],
      q(wba) => [
         q(7086),
         q(0),
         ],
      q(wbb) => [
         q(7087),
         q(0),
         ],
      q(wbe) => [
         q(7088),
         q(0),
         ],
      q(wbf) => [
         q(6420),
         q(0),
         ],
      q(wbh) => [
         q(7089),
         q(0),
         ],
      q(wbi) => [
         q(7090),
         q(0),
         ],
      q(wbj) => [
         q(7091),
         q(0),
         ],
      q(wbk) => [
         q(7092),
         q(0),
         ],
      q(wbl) => [
         q(7093),
         q(0),
         ],
      q(wbm) => [
         q(7094),
         q(0),
         ],
      q(wbp) => [
         q(7095),
         q(0),
         ],
      q(wbq) => [
         q(7096),
         q(0),
         ],
      q(wbr) => [
         q(7097),
         q(0),
         ],
      q(wbt) => [
         q(7098),
         q(0),
         ],
      q(wbv) => [
         q(7099),
         q(0),
         ],
      q(wbw) => [
         q(7100),
         q(0),
         ],
      q(wca) => [
         q(7101),
         q(0),
         ],
      q(wci) => [
         q(7102),
         q(0),
         ],
      q(wdd) => [
         q(7103),
         q(0),
         ],
      q(wdg) => [
         q(7104),
         q(0),
         ],
      q(wdj) => [
         q(7105),
         q(0),
         ],
      q(wdk) => [
         q(7106),
         q(0),
         ],
      q(wdu) => [
         q(7107),
         q(0),
         ],
      q(wdy) => [
         q(7108),
         q(0),
         ],
      q(wea) => [
         q(7109),
         q(0),
         ],
      q(wec) => [
         q(7110),
         q(0),
         ],
      q(wed) => [
         q(7111),
         q(0),
         ],
      q(weg) => [
         q(7112),
         q(0),
         ],
      q(weh) => [
         q(7113),
         q(0),
         ],
      q(wei) => [
         q(7114),
         q(0),
         ],
      q(wel) => [
         q(0466),
         q(0),
         ],
      q(wem) => [
         q(7115),
         q(0),
         ],
      q(wen) => [
         q(0467),
         q(0),
         ],
      q(weo) => [
         q(7116),
         q(0),
         ],
      q(wep) => [
         q(7117),
         q(0),
         ],
      q(wer) => [
         q(7118),
         q(0),
         ],
      q(wes) => [
         q(7119),
         q(0),
         ],
      q(wet) => [
         q(7120),
         q(0),
         ],
      q(weu) => [
         q(7121),
         q(0),
         ],
      q(wew) => [
         q(7122),
         q(0),
         ],
      q(wfg) => [
         q(7123),
         q(0),
         ],
      q(wga) => [
         q(7124),
         q(0),
         ],
      q(wgb) => [
         q(7125),
         q(0),
         ],
      q(wgg) => [
         q(7126),
         q(0),
         ],
      q(wgi) => [
         q(7127),
         q(0),
         ],
      q(wgo) => [
         q(7128),
         q(0),
         ],
      q(wgu) => [
         q(7129),
         q(0),
         ],
      q(wgy) => [
         q(7130),
         q(0),
         ],
      q(wha) => [
         q(7131),
         q(0),
         ],
      q(whg) => [
         q(7132),
         q(0),
         ],
      q(whk) => [
         q(7133),
         q(0),
         ],
      q(whu) => [
         q(7134),
         q(0),
         ],
      q(wib) => [
         q(7135),
         q(0),
         ],
      q(wic) => [
         q(7136),
         q(0),
         ],
      q(wie) => [
         q(7137),
         q(0),
         ],
      q(wif) => [
         q(7138),
         q(0),
         ],
      q(wig) => [
         q(7139),
         q(0),
         ],
      q(wih) => [
         q(7140),
         q(0),
         ],
      q(wii) => [
         q(7141),
         q(0),
         ],
      q(wij) => [
         q(7142),
         q(0),
         ],
      q(wik) => [
         q(7143),
         q(0),
         ],
      q(wil) => [
         q(7144),
         q(0),
         ],
      q(wim) => [
         q(7145),
         q(0),
         ],
      q(win) => [
         q(7146),
         q(0),
         ],
      q(wir) => [
         q(7147),
         q(0),
         ],
      q(wiu) => [
         q(7148),
         q(0),
         ],
      q(wiv) => [
         q(7149),
         q(0),
         ],
      q(wiy) => [
         q(7150),
         q(0),
         ],
      q(wja) => [
         q(7151),
         q(0),
         ],
      q(wji) => [
         q(7152),
         q(0),
         ],
      q(wka) => [
         q(7153),
         q(0),
         ],
      q(wkb) => [
         q(7154),
         q(0),
         ],
      q(wkd) => [
         q(7155),
         q(0),
         ],
      q(wkl) => [
         q(7156),
         q(0),
         ],
      q(wku) => [
         q(7157),
         q(0),
         ],
      q(wkw) => [
         q(7158),
         q(0),
         ],
      q(wky) => [
         q(7159),
         q(0),
         ],
      q(wla) => [
         q(7160),
         q(0),
         ],
      q(wlc) => [
         q(7161),
         q(0),
         ],
      q(wle) => [
         q(7162),
         q(0),
         ],
      q(wlg) => [
         q(7163),
         q(0),
         ],
      q(wli) => [
         q(7164),
         q(0),
         ],
      q(wlk) => [
         q(7165),
         q(0),
         ],
      q(wll) => [
         q(7166),
         q(0),
         ],
      q(wlm) => [
         q(7167),
         q(0),
         ],
      q(wln) => [
         q(0468),
         q(0),
         ],
      q(wlo) => [
         q(7168),
         q(0),
         ],
      q(wlr) => [
         q(7169),
         q(0),
         ],
      q(wls) => [
         q(7170),
         q(0),
         ],
      q(wlu) => [
         q(7171),
         q(0),
         ],
      q(wlv) => [
         q(7172),
         q(0),
         ],
      q(wlw) => [
         q(7173),
         q(0),
         ],
      q(wlx) => [
         q(7174),
         q(0),
         ],
      q(wly) => [
         q(7175),
         q(0),
         ],
      q(wma) => [
         q(7176),
         q(0),
         ],
      q(wmb) => [
         q(7177),
         q(0),
         ],
      q(wmc) => [
         q(7178),
         q(0),
         ],
      q(wmd) => [
         q(7179),
         q(0),
         ],
      q(wme) => [
         q(7180),
         q(0),
         ],
      q(wmh) => [
         q(7181),
         q(0),
         ],
      q(wmi) => [
         q(7182),
         q(0),
         ],
      q(wmm) => [
         q(7183),
         q(0),
         ],
      q(wmn) => [
         q(7184),
         q(0),
         ],
      q(wmo) => [
         q(7185),
         q(0),
         ],
      q(wms) => [
         q(7186),
         q(0),
         ],
      q(wmt) => [
         q(7187),
         q(0),
         ],
      q(wmw) => [
         q(7188),
         q(0),
         ],
      q(wmx) => [
         q(7189),
         q(0),
         ],
      q(wnb) => [
         q(7190),
         q(0),
         ],
      q(wnc) => [
         q(7191),
         q(0),
         ],
      q(wnd) => [
         q(7192),
         q(0),
         ],
      q(wne) => [
         q(7193),
         q(0),
         ],
      q(wng) => [
         q(7194),
         q(0),
         ],
      q(wni) => [
         q(7195),
         q(0),
         ],
      q(wnk) => [
         q(7196),
         q(0),
         ],
      q(wnm) => [
         q(7197),
         q(0),
         ],
      q(wnn) => [
         q(7198),
         q(0),
         ],
      q(wno) => [
         q(7199),
         q(0),
         ],
      q(wnp) => [
         q(7200),
         q(0),
         ],
      q(wnu) => [
         q(7201),
         q(0),
         ],
      q(wnw) => [
         q(7202),
         q(0),
         ],
      q(wny) => [
         q(7203),
         q(0),
         ],
      q(woa) => [
         q(7204),
         q(0),
         ],
      q(wob) => [
         q(7205),
         q(0),
         ],
      q(woc) => [
         q(7206),
         q(0),
         ],
      q(wod) => [
         q(7207),
         q(0),
         ],
      q(woe) => [
         q(7208),
         q(0),
         ],
      q(wof) => [
         q(7209),
         q(0),
         ],
      q(wog) => [
         q(7210),
         q(0),
         ],
      q(woi) => [
         q(7211),
         q(0),
         ],
      q(wok) => [
         q(7212),
         q(0),
         ],
      q(wol) => [
         q(0469),
         q(0),
         ],
      q(wom) => [
         q(7213),
         q(0),
         ],
      q(won) => [
         q(7214),
         q(0),
         ],
      q(woo) => [
         q(7215),
         q(0),
         ],
      q(wor) => [
         q(7216),
         q(0),
         ],
      q(wos) => [
         q(7217),
         q(0),
         ],
      q(wow) => [
         q(7218),
         q(0),
         ],
      q(woy) => [
         q(7219),
         q(0),
         ],
      q(wpc) => [
         q(7220),
         q(0),
         ],
      q(wra) => [
         q(7221),
         q(0),
         ],
      q(wrb) => [
         q(7222),
         q(0),
         ],
      q(wrd) => [
         q(7223),
         q(0),
         ],
      q(wrg) => [
         q(7224),
         q(0),
         ],
      q(wrh) => [
         q(7225),
         q(0),
         ],
      q(wri) => [
         q(7226),
         q(0),
         ],
      q(wrk) => [
         q(7227),
         q(0),
         ],
      q(wrl) => [
         q(7228),
         q(0),
         ],
      q(wrm) => [
         q(7229),
         q(0),
         ],
      q(wrn) => [
         q(7230),
         q(0),
         ],
      q(wro) => [
         q(7231),
         q(0),
         ],
      q(wrp) => [
         q(7232),
         q(0),
         ],
      q(wrr) => [
         q(7233),
         q(0),
         ],
      q(wrs) => [
         q(7234),
         q(0),
         ],
      q(wru) => [
         q(7235),
         q(0),
         ],
      q(wrv) => [
         q(7236),
         q(0),
         ],
      q(wrw) => [
         q(7237),
         q(0),
         ],
      q(wrx) => [
         q(7238),
         q(0),
         ],
      q(wry) => [
         q(7239),
         q(0),
         ],
      q(wrz) => [
         q(7240),
         q(0),
         ],
      q(wsa) => [
         q(7241),
         q(0),
         ],
      q(wsi) => [
         q(7242),
         q(0),
         ],
      q(wsk) => [
         q(7243),
         q(0),
         ],
      q(wsr) => [
         q(7244),
         q(0),
         ],
      q(wss) => [
         q(7245),
         q(0),
         ],
      q(wsu) => [
         q(7246),
         q(0),
         ],
      q(wsv) => [
         q(7247),
         q(0),
         ],
      q(wtf) => [
         q(7248),
         q(0),
         ],
      q(wth) => [
         q(7249),
         q(0),
         ],
      q(wti) => [
         q(7250),
         q(0),
         ],
      q(wtk) => [
         q(7251),
         q(0),
         ],
      q(wtm) => [
         q(7252),
         q(0),
         ],
      q(wtw) => [
         q(7253),
         q(0),
         ],
      q(wua) => [
         q(7254),
         q(0),
         ],
      q(wub) => [
         q(7255),
         q(0),
         ],
      q(wud) => [
         q(7256),
         q(0),
         ],
      q(wuh) => [
         q(7257),
         q(0),
         ],
      q(wul) => [
         q(7258),
         q(0),
         ],
      q(wum) => [
         q(7259),
         q(0),
         ],
      q(wun) => [
         q(7260),
         q(0),
         ],
      q(wur) => [
         q(7261),
         q(0),
         ],
      q(wut) => [
         q(7262),
         q(0),
         ],
      q(wuu) => [
         q(7263),
         q(0),
         ],
      q(wuv) => [
         q(7264),
         q(0),
         ],
      q(wux) => [
         q(7265),
         q(0),
         ],
      q(wuy) => [
         q(7266),
         q(0),
         ],
      q(wwa) => [
         q(7267),
         q(0),
         ],
      q(wwb) => [
         q(7268),
         q(0),
         ],
      q(wwo) => [
         q(7269),
         q(0),
         ],
      q(wwr) => [
         q(7270),
         q(0),
         ],
      q(www) => [
         q(7271),
         q(0),
         ],
      q(wxa) => [
         q(7272),
         q(0),
         ],
      q(wxw) => [
         q(7273),
         q(0),
         ],
      q(wya) => [
         q(7274),
         q(0),
         ],
      q(wyb) => [
         q(7275),
         q(0),
         ],
      q(wyi) => [
         q(7276),
         q(0),
         ],
      q(wym) => [
         q(7277),
         q(0),
         ],
      q(wyr) => [
         q(7278),
         q(0),
         ],
      q(wyy) => [
         q(7279),
         q(0),
         ],
      q(xaa) => [
         q(7280),
         q(0),
         ],
      q(xab) => [
         q(7281),
         q(0),
         ],
      q(xac) => [
         q(7282),
         q(0),
         ],
      q(xad) => [
         q(7283),
         q(0),
         ],
      q(xae) => [
         q(7284),
         q(0),
         ],
      q(xag) => [
         q(7285),
         q(0),
         ],
      q(xai) => [
         q(7286),
         q(0),
         ],
      q(xal) => [
         q(0470),
         q(0),
         ],
      q(xam) => [
         q(7287),
         q(0),
         ],
      q(xan) => [
         q(7288),
         q(0),
         ],
      q(xao) => [
         q(7289),
         q(0),
         ],
      q(xap) => [
         q(7290),
         q(0),
         ],
      q(xaq) => [
         q(7291),
         q(0),
         ],
      q(xar) => [
         q(7292),
         q(0),
         ],
      q(xas) => [
         q(7293),
         q(0),
         ],
      q(xat) => [
         q(7294),
         q(0),
         ],
      q(xau) => [
         q(7295),
         q(0),
         ],
      q(xav) => [
         q(7296),
         q(0),
         ],
      q(xaw) => [
         q(7297),
         q(0),
         ],
      q(xay) => [
         q(7298),
         q(0),
         ],
      q(xba) => [
         q(7299),
         q(0),
         ],
      q(xbb) => [
         q(7300),
         q(0),
         ],
      q(xbc) => [
         q(7301),
         q(0),
         ],
      q(xbd) => [
         q(7302),
         q(0),
         ],
      q(xbe) => [
         q(7303),
         q(0),
         ],
      q(xbg) => [
         q(7304),
         q(0),
         ],
      q(xbi) => [
         q(7305),
         q(0),
         ],
      q(xbj) => [
         q(7306),
         q(0),
         ],
      q(xbm) => [
         q(7307),
         q(0),
         ],
      q(xbn) => [
         q(7308),
         q(0),
         ],
      q(xbo) => [
         q(7309),
         q(0),
         ],
      q(xbp) => [
         q(7310),
         q(0),
         ],
      q(xbr) => [
         q(7311),
         q(0),
         ],
      q(xbw) => [
         q(7312),
         q(0),
         ],
      q(xbx) => [
         q(7313),
         q(0),
         ],
      q(xby) => [
         q(7314),
         q(0),
         ],
      q(xcb) => [
         q(7315),
         q(0),
         ],
      q(xcc) => [
         q(7316),
         q(0),
         ],
      q(xce) => [
         q(7317),
         q(0),
         ],
      q(xcg) => [
         q(7318),
         q(0),
         ],
      q(xch) => [
         q(7319),
         q(0),
         ],
      q(xcl) => [
         q(7320),
         q(0),
         ],
      q(xcm) => [
         q(7321),
         q(0),
         ],
      q(xcn) => [
         q(7322),
         q(0),
         ],
      q(xco) => [
         q(7323),
         q(0),
         ],
      q(xcr) => [
         q(7324),
         q(0),
         ],
      q(xct) => [
         q(7325),
         q(0),
         ],
      q(xcu) => [
         q(7326),
         q(0),
         ],
      q(xcv) => [
         q(7327),
         q(0),
         ],
      q(xcw) => [
         q(7328),
         q(0),
         ],
      q(xcy) => [
         q(7329),
         q(0),
         ],
      q(xda) => [
         q(7330),
         q(0),
         ],
      q(xdc) => [
         q(7331),
         q(0),
         ],
      q(xdk) => [
         q(7332),
         q(0),
         ],
      q(xdm) => [
         q(7333),
         q(0),
         ],
      q(xdy) => [
         q(7334),
         q(0),
         ],
      q(xeb) => [
         q(7335),
         q(0),
         ],
      q(xed) => [
         q(7336),
         q(0),
         ],
      q(xeg) => [
         q(7337),
         q(0),
         ],
      q(xel) => [
         q(7338),
         q(0),
         ],
      q(xem) => [
         q(7339),
         q(0),
         ],
      q(xep) => [
         q(7340),
         q(0),
         ],
      q(xer) => [
         q(7341),
         q(0),
         ],
      q(xes) => [
         q(7342),
         q(0),
         ],
      q(xet) => [
         q(7343),
         q(0),
         ],
      q(xeu) => [
         q(7344),
         q(0),
         ],
      q(xfa) => [
         q(7345),
         q(0),
         ],
      q(xga) => [
         q(7346),
         q(0),
         ],
      q(xgb) => [
         q(7347),
         q(0),
         ],
      q(xgd) => [
         q(7348),
         q(0),
         ],
      q(xgf) => [
         q(7349),
         q(0),
         ],
      q(xgg) => [
         q(7350),
         q(0),
         ],
      q(xgi) => [
         q(7351),
         q(0),
         ],
      q(xgl) => [
         q(7352),
         q(0),
         ],
      q(xgm) => [
         q(7353),
         q(0),
         ],
      q(xgn) => [
         q(0531),
         q(0),
         ],
      q(xgr) => [
         q(7354),
         q(0),
         ],
      q(xgu) => [
         q(7355),
         q(0),
         ],
      q(xgw) => [
         q(7356),
         q(0),
         ],
      q(xha) => [
         q(7357),
         q(0),
         ],
      q(xhc) => [
         q(7358),
         q(0),
         ],
      q(xhd) => [
         q(7359),
         q(0),
         ],
      q(xhe) => [
         q(7360),
         q(0),
         ],
      q(xho) => [
         q(0471),
         q(0),
         ],
      q(xhr) => [
         q(7361),
         q(0),
         ],
      q(xht) => [
         q(7362),
         q(0),
         ],
      q(xhu) => [
         q(7363),
         q(0),
         ],
      q(xhv) => [
         q(7364),
         q(0),
         ],
      q(xib) => [
         q(7365),
         q(0),
         ],
      q(xii) => [
         q(7366),
         q(0),
         ],
      q(xil) => [
         q(7367),
         q(0),
         ],
      q(xin) => [
         q(7368),
         q(0),
         ],
      q(xip) => [
         q(7369),
         q(0),
         ],
      q(xir) => [
         q(7370),
         q(0),
         ],
      q(xiv) => [
         q(7371),
         q(0),
         ],
      q(xiy) => [
         q(7372),
         q(0),
         ],
      q(xjb) => [
         q(7373),
         q(0),
         ],
      q(xjt) => [
         q(7374),
         q(0),
         ],
      q(xka) => [
         q(7375),
         q(0),
         ],
      q(xkb) => [
         q(7376),
         q(0),
         ],
      q(xkc) => [
         q(7377),
         q(0),
         ],
      q(xkd) => [
         q(7378),
         q(0),
         ],
      q(xke) => [
         q(7379),
         q(0),
         ],
      q(xkf) => [
         q(7380),
         q(0),
         ],
      q(xkg) => [
         q(7381),
         q(0),
         ],
      q(xkh) => [
         q(7382),
         q(0),
         ],
      q(xki) => [
         q(7383),
         q(0),
         ],
      q(xkj) => [
         q(7384),
         q(0),
         ],
      q(xkk) => [
         q(7385),
         q(0),
         ],
      q(xkl) => [
         q(7386),
         q(0),
         ],
      q(xkn) => [
         q(7387),
         q(0),
         ],
      q(xko) => [
         q(7388),
         q(0),
         ],
      q(xkp) => [
         q(7389),
         q(0),
         ],
      q(xkq) => [
         q(7390),
         q(0),
         ],
      q(xkr) => [
         q(7391),
         q(0),
         ],
      q(xks) => [
         q(7392),
         q(0),
         ],
      q(xkt) => [
         q(7393),
         q(0),
         ],
      q(xku) => [
         q(7394),
         q(0),
         ],
      q(xkv) => [
         q(7395),
         q(0),
         ],
      q(xkw) => [
         q(7396),
         q(0),
         ],
      q(xkx) => [
         q(7397),
         q(0),
         ],
      q(xky) => [
         q(7398),
         q(0),
         ],
      q(xkz) => [
         q(7399),
         q(0),
         ],
      q(xla) => [
         q(7400),
         q(0),
         ],
      q(xlb) => [
         q(7401),
         q(0),
         ],
      q(xlc) => [
         q(7402),
         q(0),
         ],
      q(xld) => [
         q(7403),
         q(0),
         ],
      q(xle) => [
         q(7404),
         q(0),
         ],
      q(xlg) => [
         q(7405),
         q(0),
         ],
      q(xli) => [
         q(7406),
         q(0),
         ],
      q(xln) => [
         q(7407),
         q(0),
         ],
      q(xlo) => [
         q(7408),
         q(0),
         ],
      q(xlp) => [
         q(7409),
         q(0),
         ],
      q(xls) => [
         q(7410),
         q(0),
         ],
      q(xlu) => [
         q(7411),
         q(0),
         ],
      q(xly) => [
         q(7412),
         q(0),
         ],
      q(xma) => [
         q(7413),
         q(0),
         ],
      q(xmb) => [
         q(7414),
         q(0),
         ],
      q(xmc) => [
         q(7415),
         q(0),
         ],
      q(xmd) => [
         q(7416),
         q(0),
         ],
      q(xme) => [
         q(7417),
         q(0),
         ],
      q(xmf) => [
         q(7418),
         q(0),
         ],
      q(xmg) => [
         q(7419),
         q(0),
         ],
      q(xmh) => [
         q(7420),
         q(0),
         ],
      q(xmj) => [
         q(7421),
         q(0),
         ],
      q(xmk) => [
         q(7422),
         q(0),
         ],
      q(xml) => [
         q(7423),
         q(0),
         ],
      q(xmm) => [
         q(7424),
         q(0),
         ],
      q(xmn) => [
         q(7425),
         q(0),
         ],
      q(xmo) => [
         q(7426),
         q(0),
         ],
      q(xmp) => [
         q(7427),
         q(0),
         ],
      q(xmq) => [
         q(7428),
         q(0),
         ],
      q(xmr) => [
         q(7429),
         q(0),
         ],
      q(xms) => [
         q(7430),
         q(0),
         ],
      q(xmt) => [
         q(7431),
         q(0),
         ],
      q(xmu) => [
         q(7432),
         q(0),
         ],
      q(xmv) => [
         q(7433),
         q(0),
         ],
      q(xmw) => [
         q(7434),
         q(0),
         ],
      q(xmx) => [
         q(7435),
         q(0),
         ],
      q(xmy) => [
         q(7436),
         q(0),
         ],
      q(xmz) => [
         q(7437),
         q(0),
         ],
      q(xna) => [
         q(7438),
         q(0),
         ],
      q(xnb) => [
         q(7439),
         q(0),
         ],
      q(xnd) => [
         q(0532),
         q(0),
         ],
      q(xng) => [
         q(7440),
         q(0),
         ],
      q(xnh) => [
         q(7441),
         q(0),
         ],
      q(xni) => [
         q(7442),
         q(0),
         ],
      q(xnk) => [
         q(7443),
         q(0),
         ],
      q(xnn) => [
         q(7444),
         q(0),
         ],
      q(xno) => [
         q(7445),
         q(0),
         ],
      q(xnr) => [
         q(7446),
         q(0),
         ],
      q(xns) => [
         q(7447),
         q(0),
         ],
      q(xnt) => [
         q(7448),
         q(0),
         ],
      q(xnu) => [
         q(7449),
         q(0),
         ],
      q(xny) => [
         q(7450),
         q(0),
         ],
      q(xnz) => [
         q(7451),
         q(0),
         ],
      q(xoc) => [
         q(7452),
         q(0),
         ],
      q(xod) => [
         q(7453),
         q(0),
         ],
      q(xog) => [
         q(7454),
         q(0),
         ],
      q(xoi) => [
         q(7455),
         q(0),
         ],
      q(xok) => [
         q(7456),
         q(0),
         ],
      q(xom) => [
         q(7457),
         q(0),
         ],
      q(xon) => [
         q(7458),
         q(0),
         ],
      q(xoo) => [
         q(7459),
         q(0),
         ],
      q(xop) => [
         q(7460),
         q(0),
         ],
      q(xor) => [
         q(7461),
         q(0),
         ],
      q(xow) => [
         q(7462),
         q(0),
         ],
      q(xpa) => [
         q(7463),
         q(0),
         ],
      q(xpc) => [
         q(7464),
         q(0),
         ],
      q(xpe) => [
         q(7465),
         q(0),
         ],
      q(xpg) => [
         q(7466),
         q(0),
         ],
      q(xpi) => [
         q(7467),
         q(0),
         ],
      q(xpj) => [
         q(7468),
         q(0),
         ],
      q(xpk) => [
         q(7469),
         q(0),
         ],
      q(xpm) => [
         q(7470),
         q(0),
         ],
      q(xpn) => [
         q(7471),
         q(0),
         ],
      q(xpo) => [
         q(7472),
         q(0),
         ],
      q(xpp) => [
         q(7473),
         q(0),
         ],
      q(xpq) => [
         q(7474),
         q(0),
         ],
      q(xpr) => [
         q(7475),
         q(0),
         ],
      q(xps) => [
         q(7476),
         q(0),
         ],
      q(xpt) => [
         q(7477),
         q(0),
         ],
      q(xpu) => [
         q(7478),
         q(0),
         ],
      q(xpy) => [
         q(7479),
         q(0),
         ],
      q(xqa) => [
         q(7480),
         q(0),
         ],
      q(xqt) => [
         q(7481),
         q(0),
         ],
      q(xra) => [
         q(7482),
         q(0),
         ],
      q(xrb) => [
         q(7483),
         q(0),
         ],
      q(xrd) => [
         q(7484),
         q(0),
         ],
      q(xre) => [
         q(7485),
         q(0),
         ],
      q(xrg) => [
         q(7486),
         q(0),
         ],
      q(xri) => [
         q(7487),
         q(0),
         ],
      q(xrm) => [
         q(7488),
         q(0),
         ],
      q(xrn) => [
         q(7489),
         q(0),
         ],
      q(xrq) => [
         q(7490),
         q(0),
         ],
      q(xrr) => [
         q(7491),
         q(0),
         ],
      q(xrt) => [
         q(7492),
         q(0),
         ],
      q(xru) => [
         q(7493),
         q(0),
         ],
      q(xrw) => [
         q(7494),
         q(0),
         ],
      q(xsa) => [
         q(7495),
         q(0),
         ],
      q(xsb) => [
         q(7496),
         q(0),
         ],
      q(xsc) => [
         q(7497),
         q(0),
         ],
      q(xsd) => [
         q(7498),
         q(0),
         ],
      q(xse) => [
         q(7499),
         q(0),
         ],
      q(xsh) => [
         q(7500),
         q(0),
         ],
      q(xsi) => [
         q(7501),
         q(0),
         ],
      q(xsj) => [
         q(7502),
         q(0),
         ],
      q(xsl) => [
         q(7503),
         q(0),
         ],
      q(xsm) => [
         q(7504),
         q(0),
         ],
      q(xsn) => [
         q(7505),
         q(0),
         ],
      q(xso) => [
         q(7506),
         q(0),
         ],
      q(xsp) => [
         q(7507),
         q(0),
         ],
      q(xsq) => [
         q(7508),
         q(0),
         ],
      q(xsr) => [
         q(7509),
         q(0),
         ],
      q(xss) => [
         q(7510),
         q(0),
         ],
      q(xsu) => [
         q(7511),
         q(0),
         ],
      q(xsv) => [
         q(7512),
         q(0),
         ],
      q(xsy) => [
         q(7513),
         q(0),
         ],
      q(xta) => [
         q(7514),
         q(0),
         ],
      q(xtb) => [
         q(7515),
         q(0),
         ],
      q(xtc) => [
         q(7516),
         q(0),
         ],
      q(xtd) => [
         q(7517),
         q(0),
         ],
      q(xte) => [
         q(7518),
         q(0),
         ],
      q(xtg) => [
         q(7519),
         q(0),
         ],
      q(xth) => [
         q(7520),
         q(0),
         ],
      q(xti) => [
         q(7521),
         q(0),
         ],
      q(xtj) => [
         q(7522),
         q(0),
         ],
      q(xtl) => [
         q(7523),
         q(0),
         ],
      q(xtm) => [
         q(7524),
         q(0),
         ],
      q(xtn) => [
         q(7525),
         q(0),
         ],
      q(xto) => [
         q(7526),
         q(0),
         ],
      q(xtp) => [
         q(7527),
         q(0),
         ],
      q(xtq) => [
         q(7528),
         q(0),
         ],
      q(xtr) => [
         q(7529),
         q(0),
         ],
      q(xts) => [
         q(7530),
         q(0),
         ],
      q(xtt) => [
         q(7531),
         q(0),
         ],
      q(xtu) => [
         q(7532),
         q(0),
         ],
      q(xtv) => [
         q(7533),
         q(0),
         ],
      q(xtw) => [
         q(7534),
         q(0),
         ],
      q(xty) => [
         q(7535),
         q(0),
         ],
      q(xtz) => [
         q(7536),
         q(0),
         ],
      q(xua) => [
         q(7537),
         q(0),
         ],
      q(xub) => [
         q(7538),
         q(0),
         ],
      q(xud) => [
         q(7539),
         q(0),
         ],
      q(xug) => [
         q(7540),
         q(0),
         ],
      q(xuj) => [
         q(7541),
         q(0),
         ],
      q(xul) => [
         q(7542),
         q(0),
         ],
      q(xum) => [
         q(7543),
         q(0),
         ],
      q(xun) => [
         q(7544),
         q(0),
         ],
      q(xuo) => [
         q(7545),
         q(0),
         ],
      q(xup) => [
         q(7546),
         q(0),
         ],
      q(xur) => [
         q(7547),
         q(0),
         ],
      q(xut) => [
         q(7548),
         q(0),
         ],
      q(xuu) => [
         q(7549),
         q(0),
         ],
      q(xve) => [
         q(7550),
         q(0),
         ],
      q(xvi) => [
         q(7551),
         q(0),
         ],
      q(xvn) => [
         q(7552),
         q(0),
         ],
      q(xvo) => [
         q(7553),
         q(0),
         ],
      q(xvs) => [
         q(7554),
         q(0),
         ],
      q(xwa) => [
         q(7555),
         q(0),
         ],
      q(xwc) => [
         q(7556),
         q(0),
         ],
      q(xwd) => [
         q(7557),
         q(0),
         ],
      q(xwe) => [
         q(7558),
         q(0),
         ],
      q(xwg) => [
         q(7559),
         q(0),
         ],
      q(xwj) => [
         q(7560),
         q(0),
         ],
      q(xwk) => [
         q(7561),
         q(0),
         ],
      q(xwl) => [
         q(7562),
         q(0),
         ],
      q(xwo) => [
         q(7563),
         q(0),
         ],
      q(xwr) => [
         q(7564),
         q(0),
         ],
      q(xwt) => [
         q(7565),
         q(0),
         ],
      q(xww) => [
         q(7566),
         q(0),
         ],
      q(xxb) => [
         q(7567),
         q(0),
         ],
      q(xxk) => [
         q(7568),
         q(0),
         ],
      q(xxm) => [
         q(7569),
         q(0),
         ],
      q(xxr) => [
         q(7570),
         q(0),
         ],
      q(xxt) => [
         q(7571),
         q(0),
         ],
      q(xya) => [
         q(7572),
         q(0),
         ],
      q(xyb) => [
         q(7573),
         q(0),
         ],
      q(xyj) => [
         q(7574),
         q(0),
         ],
      q(xyk) => [
         q(7575),
         q(0),
         ],
      q(xyl) => [
         q(7576),
         q(0),
         ],
      q(xyt) => [
         q(7577),
         q(0),
         ],
      q(xyy) => [
         q(7578),
         q(0),
         ],
      q(xzh) => [
         q(7579),
         q(0),
         ],
      q(xzm) => [
         q(7580),
         q(0),
         ],
      q(xzp) => [
         q(7581),
         q(0),
         ],
      q(yaa) => [
         q(7582),
         q(0),
         ],
      q(yab) => [
         q(7583),
         q(0),
         ],
      q(yac) => [
         q(7584),
         q(0),
         ],
      q(yad) => [
         q(7585),
         q(0),
         ],
      q(yae) => [
         q(7586),
         q(0),
         ],
      q(yaf) => [
         q(7587),
         q(0),
         ],
      q(yag) => [
         q(7588),
         q(0),
         ],
      q(yah) => [
         q(7589),
         q(0),
         ],
      q(yai) => [
         q(7590),
         q(0),
         ],
      q(yaj) => [
         q(7591),
         q(0),
         ],
      q(yak) => [
         q(7592),
         q(0),
         ],
      q(yal) => [
         q(7593),
         q(0),
         ],
      q(yam) => [
         q(7594),
         q(0),
         ],
      q(yan) => [
         q(7595),
         q(0),
         ],
      q(yao) => [
         q(0472),
         q(0),
         ],
      q(yap) => [
         q(0473),
         q(0),
         ],
      q(yaq) => [
         q(7596),
         q(0),
         ],
      q(yar) => [
         q(7597),
         q(0),
         ],
      q(yas) => [
         q(7598),
         q(0),
         ],
      q(yat) => [
         q(7599),
         q(0),
         ],
      q(yau) => [
         q(7600),
         q(0),
         ],
      q(yav) => [
         q(7601),
         q(0),
         ],
      q(yaw) => [
         q(7602),
         q(0),
         ],
      q(yax) => [
         q(7603),
         q(0),
         ],
      q(yay) => [
         q(7604),
         q(0),
         ],
      q(yaz) => [
         q(7605),
         q(0),
         ],
      q(yba) => [
         q(7606),
         q(0),
         ],
      q(ybb) => [
         q(7607),
         q(0),
         ],
      q(ybe) => [
         q(7608),
         q(0),
         ],
      q(ybh) => [
         q(7609),
         q(0),
         ],
      q(ybi) => [
         q(7610),
         q(0),
         ],
      q(ybj) => [
         q(7611),
         q(0),
         ],
      q(ybk) => [
         q(7612),
         q(0),
         ],
      q(ybl) => [
         q(7613),
         q(0),
         ],
      q(ybm) => [
         q(7614),
         q(0),
         ],
      q(ybn) => [
         q(7615),
         q(0),
         ],
      q(ybo) => [
         q(7616),
         q(0),
         ],
      q(ybx) => [
         q(7617),
         q(0),
         ],
      q(yby) => [
         q(7618),
         q(0),
         ],
      q(ych) => [
         q(7619),
         q(0),
         ],
      q(ycl) => [
         q(7620),
         q(0),
         ],
      q(ycn) => [
         q(7621),
         q(0),
         ],
      q(ycp) => [
         q(7622),
         q(0),
         ],
      q(yda) => [
         q(7623),
         q(0),
         ],
      q(ydd) => [
         q(7624),
         q(0),
         ],
      q(yde) => [
         q(7625),
         q(0),
         ],
      q(ydg) => [
         q(7626),
         q(0),
         ],
      q(ydk) => [
         q(7627),
         q(0),
         ],
      q(yds) => [
         q(7628),
         q(0),
         ],
      q(yea) => [
         q(7629),
         q(0),
         ],
      q(yec) => [
         q(7630),
         q(0),
         ],
      q(yee) => [
         q(7631),
         q(0),
         ],
      q(yei) => [
         q(7632),
         q(0),
         ],
      q(yej) => [
         q(7633),
         q(0),
         ],
      q(yel) => [
         q(7634),
         q(0),
         ],
      q(yer) => [
         q(7635),
         q(0),
         ],
      q(yes) => [
         q(7636),
         q(0),
         ],
      q(yet) => [
         q(7637),
         q(0),
         ],
      q(yeu) => [
         q(7638),
         q(0),
         ],
      q(yev) => [
         q(7639),
         q(0),
         ],
      q(yey) => [
         q(7640),
         q(0),
         ],
      q(yga) => [
         q(7641),
         q(0),
         ],
      q(ygi) => [
         q(7642),
         q(0),
         ],
      q(ygl) => [
         q(7643),
         q(0),
         ],
      q(ygm) => [
         q(7644),
         q(0),
         ],
      q(ygp) => [
         q(7645),
         q(0),
         ],
      q(ygr) => [
         q(7646),
         q(0),
         ],
      q(ygu) => [
         q(7647),
         q(0),
         ],
      q(ygw) => [
         q(7648),
         q(0),
         ],
      q(yha) => [
         q(7649),
         q(0),
         ],
      q(yhd) => [
         q(7650),
         q(0),
         ],
      q(yhl) => [
         q(7651),
         q(0),
         ],
      q(yia) => [
         q(7652),
         q(0),
         ],
      q(yid) => [
         q(0474),
         q(0),
         ],
      q(yif) => [
         q(2660),
         q(0),
         ],
      q(yig) => [
         q(7653),
         q(0),
         ],
      q(yih) => [
         q(7654),
         q(0),
         ],
      q(yii) => [
         q(7655),
         q(0),
         ],
      q(yij) => [
         q(7656),
         q(0),
         ],
      q(yik) => [
         q(7657),
         q(0),
         ],
      q(yil) => [
         q(7658),
         q(0),
         ],
      q(yim) => [
         q(7659),
         q(0),
         ],
      q(yin) => [
         q(7660),
         q(0),
         ],
      q(yip) => [
         q(7661),
         q(0),
         ],
      q(yiq) => [
         q(7662),
         q(0),
         ],
      q(yir) => [
         q(7663),
         q(0),
         ],
      q(yis) => [
         q(7664),
         q(0),
         ],
      q(yit) => [
         q(7665),
         q(0),
         ],
      q(yiu) => [
         q(7666),
         q(0),
         ],
      q(yiv) => [
         q(7667),
         q(0),
         ],
      q(yix) => [
         q(7668),
         q(0),
         ],
      q(yiz) => [
         q(7669),
         q(0),
         ],
      q(yka) => [
         q(7670),
         q(0),
         ],
      q(ykg) => [
         q(7671),
         q(0),
         ],
      q(yki) => [
         q(7672),
         q(0),
         ],
      q(ykk) => [
         q(7673),
         q(0),
         ],
      q(ykl) => [
         q(7674),
         q(0),
         ],
      q(ykm) => [
         q(7675),
         q(0),
         ],
      q(ykn) => [
         q(7676),
         q(0),
         ],
      q(yko) => [
         q(7677),
         q(0),
         ],
      q(ykr) => [
         q(7678),
         q(0),
         ],
      q(ykt) => [
         q(7679),
         q(0),
         ],
      q(yku) => [
         q(7680),
         q(0),
         ],
      q(yky) => [
         q(7681),
         q(0),
         ],
      q(yla) => [
         q(7682),
         q(0),
         ],
      q(ylb) => [
         q(7683),
         q(0),
         ],
      q(yle) => [
         q(7684),
         q(0),
         ],
      q(ylg) => [
         q(7685),
         q(0),
         ],
      q(yli) => [
         q(7686),
         q(0),
         ],
      q(yll) => [
         q(7687),
         q(0),
         ],
      q(ylm) => [
         q(7688),
         q(0),
         ],
      q(yln) => [
         q(7689),
         q(0),
         ],
      q(ylo) => [
         q(7690),
         q(0),
         ],
      q(ylr) => [
         q(7691),
         q(0),
         ],
      q(ylu) => [
         q(7692),
         q(0),
         ],
      q(yly) => [
         q(7693),
         q(0),
         ],
      q(ymb) => [
         q(7694),
         q(0),
         ],
      q(ymc) => [
         q(7695),
         q(0),
         ],
      q(ymd) => [
         q(7696),
         q(0),
         ],
      q(yme) => [
         q(7697),
         q(0),
         ],
      q(ymg) => [
         q(7698),
         q(0),
         ],
      q(ymh) => [
         q(7699),
         q(0),
         ],
      q(ymi) => [
         q(7700),
         q(0),
         ],
      q(ymk) => [
         q(7701),
         q(0),
         ],
      q(yml) => [
         q(7702),
         q(0),
         ],
      q(ymm) => [
         q(7703),
         q(0),
         ],
      q(ymn) => [
         q(7704),
         q(0),
         ],
      q(ymo) => [
         q(7705),
         q(0),
         ],
      q(ymp) => [
         q(7706),
         q(0),
         ],
      q(ymq) => [
         q(7707),
         q(0),
         ],
      q(ymr) => [
         q(7708),
         q(0),
         ],
      q(yms) => [
         q(7709),
         q(0),
         ],
      q(ymt) => [
         q(7710),
         q(0),
         ],
      q(ymx) => [
         q(7711),
         q(0),
         ],
      q(ymz) => [
         q(7712),
         q(0),
         ],
      q(yna) => [
         q(7713),
         q(0),
         ],
      q(ynd) => [
         q(7714),
         q(0),
         ],
      q(yne) => [
         q(7715),
         q(0),
         ],
      q(yng) => [
         q(7716),
         q(0),
         ],
      q(ynh) => [
         q(7717),
         q(0),
         ],
      q(ynk) => [
         q(7718),
         q(0),
         ],
      q(ynl) => [
         q(7719),
         q(0),
         ],
      q(ynn) => [
         q(7720),
         q(0),
         ],
      q(yno) => [
         q(7721),
         q(0),
         ],
      q(ynq) => [
         q(7722),
         q(0),
         ],
      q(yns) => [
         q(7723),
         q(0),
         ],
      q(ynu) => [
         q(7724),
         q(0),
         ],
      q(yob) => [
         q(7725),
         q(0),
         ],
      q(yog) => [
         q(7726),
         q(0),
         ],
      q(yoi) => [
         q(7727),
         q(0),
         ],
      q(yok) => [
         q(7728),
         q(0),
         ],
      q(yol) => [
         q(7729),
         q(0),
         ],
      q(yom) => [
         q(7730),
         q(0),
         ],
      q(yon) => [
         q(7731),
         q(0),
         ],
      q(yor) => [
         q(0475),
         q(0),
         ],
      q(yot) => [
         q(7732),
         q(0),
         ],
      q(yox) => [
         q(7733),
         q(0),
         ],
      q(yoy) => [
         q(7734),
         q(0),
         ],
      q(ypa) => [
         q(7735),
         q(0),
         ],
      q(ypb) => [
         q(7736),
         q(0),
         ],
      q(ypg) => [
         q(7737),
         q(0),
         ],
      q(yph) => [
         q(7738),
         q(0),
         ],
      q(ypk) => [
         q(0476),
         q(0),
         ],
      q(ypm) => [
         q(7739),
         q(0),
         ],
      q(ypn) => [
         q(7740),
         q(0),
         ],
      q(ypo) => [
         q(7741),
         q(0),
         ],
      q(ypp) => [
         q(7742),
         q(0),
         ],
      q(ypz) => [
         q(7743),
         q(0),
         ],
      q(yra) => [
         q(7744),
         q(0),
         ],
      q(yrb) => [
         q(7745),
         q(0),
         ],
      q(yre) => [
         q(7746),
         q(0),
         ],
      q(yri) => [
         q(7747),
         q(0),
         ],
      q(yrk) => [
         q(7748),
         q(0),
         ],
      q(yrl) => [
         q(7749),
         q(0),
         ],
      q(yrm) => [
         q(7750),
         q(0),
         ],
      q(yrn) => [
         q(7751),
         q(0),
         ],
      q(yrs) => [
         q(7752),
         q(0),
         ],
      q(yrw) => [
         q(7753),
         q(0),
         ],
      q(yry) => [
         q(7754),
         q(0),
         ],
      q(ysc) => [
         q(7755),
         q(0),
         ],
      q(ysd) => [
         q(7756),
         q(0),
         ],
      q(ysg) => [
         q(7757),
         q(0),
         ],
      q(ysl) => [
         q(7758),
         q(0),
         ],
      q(ysn) => [
         q(7759),
         q(0),
         ],
      q(yso) => [
         q(7760),
         q(0),
         ],
      q(ysp) => [
         q(7761),
         q(0),
         ],
      q(ysr) => [
         q(7762),
         q(0),
         ],
      q(yss) => [
         q(7763),
         q(0),
         ],
      q(ysy) => [
         q(7764),
         q(0),
         ],
      q(yta) => [
         q(7765),
         q(0),
         ],
      q(ytl) => [
         q(7766),
         q(0),
         ],
      q(ytp) => [
         q(7767),
         q(0),
         ],
      q(ytw) => [
         q(7768),
         q(0),
         ],
      q(yty) => [
         q(7769),
         q(0),
         ],
      q(yua) => [
         q(7770),
         q(0),
         ],
      q(yub) => [
         q(7771),
         q(0),
         ],
      q(yuc) => [
         q(7772),
         q(0),
         ],
      q(yud) => [
         q(7773),
         q(0),
         ],
      q(yue) => [
         q(7774),
         q(0),
         ],
      q(yuf) => [
         q(7775),
         q(0),
         ],
      q(yug) => [
         q(7776),
         q(0),
         ],
      q(yui) => [
         q(7777),
         q(0),
         ],
      q(yuj) => [
         q(7778),
         q(0),
         ],
      q(yuk) => [
         q(7779),
         q(0),
         ],
      q(yul) => [
         q(7780),
         q(0),
         ],
      q(yum) => [
         q(7781),
         q(0),
         ],
      q(yun) => [
         q(7782),
         q(0),
         ],
      q(yup) => [
         q(7783),
         q(0),
         ],
      q(yuq) => [
         q(7784),
         q(0),
         ],
      q(yur) => [
         q(7785),
         q(0),
         ],
      q(yut) => [
         q(7786),
         q(0),
         ],
      q(yuu) => [
         q(7787),
         q(0),
         ],
      q(yuw) => [
         q(7788),
         q(0),
         ],
      q(yux) => [
         q(7789),
         q(0),
         ],
      q(yuy) => [
         q(7790),
         q(0),
         ],
      q(yuz) => [
         q(7791),
         q(0),
         ],
      q(yva) => [
         q(7792),
         q(0),
         ],
      q(yvt) => [
         q(7793),
         q(0),
         ],
      q(ywa) => [
         q(7794),
         q(0),
         ],
      q(ywg) => [
         q(7795),
         q(0),
         ],
      q(ywl) => [
         q(7796),
         q(0),
         ],
      q(ywn) => [
         q(7797),
         q(0),
         ],
      q(ywq) => [
         q(7798),
         q(0),
         ],
      q(ywr) => [
         q(7799),
         q(0),
         ],
      q(ywt) => [
         q(7800),
         q(0),
         ],
      q(ywu) => [
         q(7801),
         q(0),
         ],
      q(yww) => [
         q(7802),
         q(0),
         ],
      q(yxa) => [
         q(7803),
         q(0),
         ],
      q(yxg) => [
         q(7804),
         q(0),
         ],
      q(yxl) => [
         q(7805),
         q(0),
         ],
      q(yxm) => [
         q(7806),
         q(0),
         ],
      q(yxu) => [
         q(7807),
         q(0),
         ],
      q(yxy) => [
         q(7808),
         q(0),
         ],
      q(yyr) => [
         q(7809),
         q(0),
         ],
      q(yyu) => [
         q(7810),
         q(0),
         ],
      q(yyz) => [
         q(7811),
         q(0),
         ],
      q(yzg) => [
         q(7812),
         q(0),
         ],
      q(yzk) => [
         q(7813),
         q(0),
         ],
      q(zaa) => [
         q(7814),
         q(0),
         ],
      q(zab) => [
         q(7815),
         q(0),
         ],
      q(zac) => [
         q(7816),
         q(0),
         ],
      q(zad) => [
         q(7817),
         q(0),
         ],
      q(zae) => [
         q(7818),
         q(0),
         ],
      q(zaf) => [
         q(7819),
         q(0),
         ],
      q(zag) => [
         q(7820),
         q(0),
         ],
      q(zah) => [
         q(7821),
         q(0),
         ],
      q(zai) => [
         q(7822),
         q(0),
         ],
      q(zaj) => [
         q(7823),
         q(0),
         ],
      q(zak) => [
         q(7824),
         q(0),
         ],
      q(zal) => [
         q(7825),
         q(0),
         ],
      q(zam) => [
         q(7826),
         q(0),
         ],
      q(zao) => [
         q(7827),
         q(0),
         ],
      q(zap) => [
         q(0477),
         q(0),
         ],
      q(zaq) => [
         q(7828),
         q(0),
         ],
      q(zar) => [
         q(7829),
         q(0),
         ],
      q(zas) => [
         q(7830),
         q(0),
         ],
      q(zat) => [
         q(7831),
         q(0),
         ],
      q(zau) => [
         q(7832),
         q(0),
         ],
      q(zav) => [
         q(7833),
         q(0),
         ],
      q(zaw) => [
         q(7834),
         q(0),
         ],
      q(zax) => [
         q(7835),
         q(0),
         ],
      q(zay) => [
         q(7836),
         q(0),
         ],
      q(zaz) => [
         q(7837),
         q(0),
         ],
      q(zbc) => [
         q(7838),
         q(0),
         ],
      q(zbe) => [
         q(7839),
         q(0),
         ],
      q(zbl) => [
         q(0478),
         q(0),
         ],
      q(zbt) => [
         q(7840),
         q(0),
         ],
      q(zbw) => [
         q(7841),
         q(0),
         ],
      q(zca) => [
         q(7842),
         q(0),
         ],
      q(zch) => [
         q(7843),
         q(0),
         ],
      q(zdj) => [
         q(7844),
         q(0),
         ],
      q(zea) => [
         q(7845),
         q(0),
         ],
      q(zeg) => [
         q(7846),
         q(0),
         ],
      q(zeh) => [
         q(7847),
         q(0),
         ],
      q(zen) => [
         q(0479),
         q(0),
         ],
      q(zga) => [
         q(7848),
         q(0),
         ],
      q(zgb) => [
         q(7849),
         q(0),
         ],
      q(zgh) => [
         q(0480),
         q(0),
         ],
      q(zgm) => [
         q(7850),
         q(0),
         ],
      q(zgn) => [
         q(7851),
         q(0),
         ],
      q(zgr) => [
         q(7852),
         q(0),
         ],
      q(zha) => [
         q(0481),
         q(0),
         ],
      q(zhb) => [
         q(7853),
         q(0),
         ],
      q(zhd) => [
         q(7854),
         q(0),
         ],
      q(zhi) => [
         q(7855),
         q(0),
         ],
      q(zhn) => [
         q(7856),
         q(0),
         ],
      q(zhw) => [
         q(7857),
         q(0),
         ],
      q(zhx) => [
         q(0533),
         q(0),
         ],
      q(zia) => [
         q(7858),
         q(0),
         ],
      q(zib) => [
         q(7859),
         q(0),
         ],
      q(zik) => [
         q(7860),
         q(0),
         ],
      q(zil) => [
         q(7861),
         q(0),
         ],
      q(zim) => [
         q(7862),
         q(0),
         ],
      q(zin) => [
         q(7863),
         q(0),
         ],
      q(zir) => [
         q(7864),
         q(0),
         ],
      q(ziw) => [
         q(7865),
         q(0),
         ],
      q(ziz) => [
         q(7866),
         q(0),
         ],
      q(zka) => [
         q(7867),
         q(0),
         ],
      q(zkb) => [
         q(7868),
         q(0),
         ],
      q(zkd) => [
         q(7869),
         q(0),
         ],
      q(zkg) => [
         q(7870),
         q(0),
         ],
      q(zkh) => [
         q(7871),
         q(0),
         ],
      q(zkk) => [
         q(7872),
         q(0),
         ],
      q(zkn) => [
         q(7873),
         q(0),
         ],
      q(zko) => [
         q(7874),
         q(0),
         ],
      q(zkp) => [
         q(7875),
         q(0),
         ],
      q(zkr) => [
         q(7876),
         q(0),
         ],
      q(zkt) => [
         q(7877),
         q(0),
         ],
      q(zku) => [
         q(7878),
         q(0),
         ],
      q(zkv) => [
         q(7879),
         q(0),
         ],
      q(zkz) => [
         q(7880),
         q(0),
         ],
      q(zle) => [
         q(0534),
         q(0),
         ],
      q(zlj) => [
         q(7881),
         q(0),
         ],
      q(zlm) => [
         q(7882),
         q(0),
         ],
      q(zln) => [
         q(7883),
         q(0),
         ],
      q(zlq) => [
         q(7884),
         q(0),
         ],
      q(zls) => [
         q(0535),
         q(0),
         ],
      q(zlw) => [
         q(0536),
         q(0),
         ],
      q(zma) => [
         q(7885),
         q(0),
         ],
      q(zmb) => [
         q(7886),
         q(0),
         ],
      q(zmc) => [
         q(7887),
         q(0),
         ],
      q(zmd) => [
         q(7888),
         q(0),
         ],
      q(zme) => [
         q(7889),
         q(0),
         ],
      q(zmf) => [
         q(7890),
         q(0),
         ],
      q(zmg) => [
         q(7891),
         q(0),
         ],
      q(zmh) => [
         q(7892),
         q(0),
         ],
      q(zmi) => [
         q(7893),
         q(0),
         ],
      q(zmj) => [
         q(7894),
         q(0),
         ],
      q(zmk) => [
         q(7895),
         q(0),
         ],
      q(zml) => [
         q(7896),
         q(0),
         ],
      q(zmm) => [
         q(7897),
         q(0),
         ],
      q(zmn) => [
         q(7898),
         q(0),
         ],
      q(zmo) => [
         q(7899),
         q(0),
         ],
      q(zmp) => [
         q(7900),
         q(0),
         ],
      q(zmq) => [
         q(7901),
         q(0),
         ],
      q(zmr) => [
         q(7902),
         q(0),
         ],
      q(zms) => [
         q(7903),
         q(0),
         ],
      q(zmt) => [
         q(7904),
         q(0),
         ],
      q(zmu) => [
         q(7905),
         q(0),
         ],
      q(zmv) => [
         q(7906),
         q(0),
         ],
      q(zmw) => [
         q(7907),
         q(0),
         ],
      q(zmx) => [
         q(7908),
         q(0),
         ],
      q(zmy) => [
         q(7909),
         q(0),
         ],
      q(zmz) => [
         q(7910),
         q(0),
         ],
      q(zna) => [
         q(7911),
         q(0),
         ],
      q(znd) => [
         q(0482),
         q(0),
         ],
      q(zne) => [
         q(7912),
         q(0),
         ],
      q(zng) => [
         q(7913),
         q(0),
         ],
      q(znk) => [
         q(7914),
         q(0),
         ],
      q(zns) => [
         q(7915),
         q(0),
         ],
      q(zoc) => [
         q(7916),
         q(0),
         ],
      q(zoh) => [
         q(7917),
         q(0),
         ],
      q(zom) => [
         q(7918),
         q(0),
         ],
      q(zoo) => [
         q(7919),
         q(0),
         ],
      q(zoq) => [
         q(7920),
         q(0),
         ],
      q(zor) => [
         q(7921),
         q(0),
         ],
      q(zos) => [
         q(7922),
         q(0),
         ],
      q(zpa) => [
         q(7923),
         q(0),
         ],
      q(zpb) => [
         q(7924),
         q(0),
         ],
      q(zpc) => [
         q(7925),
         q(0),
         ],
      q(zpd) => [
         q(7926),
         q(0),
         ],
      q(zpe) => [
         q(7927),
         q(0),
         ],
      q(zpf) => [
         q(7928),
         q(0),
         ],
      q(zpg) => [
         q(7929),
         q(0),
         ],
      q(zph) => [
         q(7930),
         q(0),
         ],
      q(zpi) => [
         q(7931),
         q(0),
         ],
      q(zpj) => [
         q(7932),
         q(0),
         ],
      q(zpk) => [
         q(7933),
         q(0),
         ],
      q(zpl) => [
         q(7934),
         q(0),
         ],
      q(zpm) => [
         q(7935),
         q(0),
         ],
      q(zpn) => [
         q(7936),
         q(0),
         ],
      q(zpo) => [
         q(7937),
         q(0),
         ],
      q(zpp) => [
         q(7938),
         q(0),
         ],
      q(zpq) => [
         q(7939),
         q(0),
         ],
      q(zpr) => [
         q(7940),
         q(0),
         ],
      q(zps) => [
         q(7941),
         q(0),
         ],
      q(zpt) => [
         q(7942),
         q(0),
         ],
      q(zpu) => [
         q(7943),
         q(0),
         ],
      q(zpv) => [
         q(7944),
         q(0),
         ],
      q(zpw) => [
         q(7945),
         q(0),
         ],
      q(zpx) => [
         q(7946),
         q(0),
         ],
      q(zpy) => [
         q(7947),
         q(0),
         ],
      q(zpz) => [
         q(7948),
         q(0),
         ],
      q(zqe) => [
         q(7949),
         q(0),
         ],
      q(zra) => [
         q(7950),
         q(0),
         ],
      q(zrg) => [
         q(7951),
         q(0),
         ],
      q(zrn) => [
         q(7952),
         q(0),
         ],
      q(zro) => [
         q(7953),
         q(0),
         ],
      q(zrp) => [
         q(7954),
         q(0),
         ],
      q(zrs) => [
         q(7955),
         q(0),
         ],
      q(zsa) => [
         q(7956),
         q(0),
         ],
      q(zsk) => [
         q(7957),
         q(0),
         ],
      q(zsl) => [
         q(7958),
         q(0),
         ],
      q(zsm) => [
         q(7959),
         q(0),
         ],
      q(zsr) => [
         q(7960),
         q(0),
         ],
      q(zsu) => [
         q(7961),
         q(0),
         ],
      q(zte) => [
         q(7962),
         q(0),
         ],
      q(ztg) => [
         q(7963),
         q(0),
         ],
      q(ztl) => [
         q(7964),
         q(0),
         ],
      q(ztm) => [
         q(7965),
         q(0),
         ],
      q(ztn) => [
         q(7966),
         q(0),
         ],
      q(ztp) => [
         q(7967),
         q(0),
         ],
      q(ztq) => [
         q(7968),
         q(0),
         ],
      q(zts) => [
         q(7969),
         q(0),
         ],
      q(ztt) => [
         q(7970),
         q(0),
         ],
      q(ztu) => [
         q(7971),
         q(0),
         ],
      q(ztx) => [
         q(7972),
         q(0),
         ],
      q(zty) => [
         q(7973),
         q(0),
         ],
      q(zua) => [
         q(7974),
         q(0),
         ],
      q(zuh) => [
         q(7975),
         q(0),
         ],
      q(zul) => [
         q(0483),
         q(0),
         ],
      q(zum) => [
         q(7976),
         q(0),
         ],
      q(zun) => [
         q(0484),
         q(0),
         ],
      q(zuy) => [
         q(7977),
         q(0),
         ],
      q(zwa) => [
         q(7978),
         q(0),
         ],
      q(zxx) => [
         q(0485),
         q(0),
         ],
      q(zyb) => [
         q(7979),
         q(0),
         ],
      q(zyg) => [
         q(7980),
         q(0),
         ],
      q(zyj) => [
         q(7981),
         q(0),
         ],
      q(zyn) => [
         q(7982),
         q(0),
         ],
      q(zyp) => [
         q(7983),
         q(0),
         ],
      q(zza) => [
         q(0486),
         q(0),
         ],
      q(zzj) => [
         q(7984),
         q(0),
         ],
      },
   q(term) => {
      q(bod) => [
         q(0427),
         q(0),
         ],
      q(ces) => [
         q(0101),
         q(0),
         ],
      q(cym) => [
         q(0466),
         q(0),
         ],
      q(deu) => [
         q(0150),
         q(0),
         ],
      q(ell) => [
         q(0164),
         q(0),
         ],
      q(eus) => [
         q(0044),
         q(0),
         ],
      q(fas) => [
         q(0342),
         q(0),
         ],
      q(fra) => [
         q(0137),
         q(0),
         ],
      q(hye) => [
         q(0024),
         q(0),
         ],
      q(isl) => [
         q(0187),
         q(0),
         ],
      q(kat) => [
         q(0149),
         q(0),
         ],
      q(mkd) => [
         q(0262),
         q(0),
         ],
      q(mri) => [
         q(0270),
         q(0),
         ],
      q(msa) => [
         q(0274),
         q(0),
         ],
      q(mya) => [
         q(0066),
         q(0),
         ],
      q(nld) => [
         q(0116),
         q(0),
         ],
      q(ron) => [
         q(0360),
         q(0),
         ],
      q(slk) => [
         q(0385),
         q(0),
         ],
      q(sqi) => [
         q(0013),
         q(0),
         ],
      q(zho) => [
         q(0079),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'language'}{'id2code'} = {
   q(alpha-2) => {
      q(0001) => q(aa),
      q(0002) => q(ab),
      q(0009) => q(af),
      q(0011) => q(ak),
      q(0013) => q(sq),
      q(0017) => q(am),
      q(0021) => q(ar),
      q(0023) => q(an),
      q(0024) => q(hy),
      q(0029) => q(as),
      q(0033) => q(av),
      q(0034) => q(ae),
      q(0036) => q(ay),
      q(0037) => q(az),
      q(0040) => q(ba),
      q(0042) => q(bm),
      q(0044) => q(eu),
      q(0048) => q(be),
      q(0050) => q(bn),
      q(0053) => q(bh),
      q(0056) => q(bi),
      q(0059) => q(bs),
      q(0061) => q(br),
      q(0065) => q(bg),
      q(0066) => q(my),
      q(0071) => q(ca),
      q(0075) => q(ch),
      q(0077) => q(ce),
      q(0079) => q(zh),
      q(0086) => q(cu),
      q(0087) => q(cv),
      q(0091) => q(kw),
      q(0092) => q(co),
      q(0096) => q(cr),
      q(0101) => q(cs),
      q(0103) => q(da),
      q(0110) => q(dv),
      q(0116) => q(nl),
      q(0118) => q(dz),
      q(0123) => q(en),
      q(0125) => q(eo),
      q(0126) => q(et),
      q(0127) => q(ee),
      q(0130) => q(fo),
      q(0132) => q(fj),
      q(0134) => q(fi),
      q(0137) => q(fr),
      q(0142) => q(fy),
      q(0143) => q(ff),
      q(0149) => q(ka),
      q(0150) => q(de),
      q(0153) => q(gd),
      q(0154) => q(ga),
      q(0155) => q(gl),
      q(0156) => q(gv),
      q(0164) => q(el),
      q(0165) => q(gn),
      q(0167) => q(gu),
      q(0170) => q(ht),
      q(0171) => q(ha),
      q(0173) => q(he),
      q(0174) => q(hz),
      q(0177) => q(hi),
      q(0180) => q(ho),
      q(0181) => q(hr),
      q(0183) => q(hu),
      q(0186) => q(ig),
      q(0187) => q(is),
      q(0188) => q(io),
      q(0189) => q(ii),
      q(0191) => q(iu),
      q(0192) => q(ie),
      q(0194) => q(ia),
      q(0196) => q(id),
      q(0199) => q(ik),
      q(0202) => q(it),
      q(0203) => q(jv),
      q(0205) => q(ja),
      q(0211) => q(kl),
      q(0213) => q(kn),
      q(0215) => q(ks),
      q(0216) => q(kr),
      q(0218) => q(kk),
      q(0222) => q(km),
      q(0224) => q(ki),
      q(0225) => q(rw),
      q(0226) => q(ky),
      q(0229) => q(kv),
      q(0230) => q(kg),
      q(0231) => q(ko),
      q(0238) => q(kj),
      q(0240) => q(ku),
      q(0245) => q(lo),
      q(0246) => q(la),
      q(0247) => q(lv),
      q(0249) => q(li),
      q(0250) => q(ln),
      q(0251) => q(lt),
      q(0254) => q(lb),
      q(0256) => q(lu),
      q(0257) => q(lg),
      q(0262) => q(mk),
      q(0265) => q(mh),
      q(0268) => q(ml),
      q(0270) => q(mi),
      q(0272) => q(mr),
      q(0274) => q(ms),
      q(0283) => q(mg),
      q(0284) => q(mt),
      q(0289) => q(mn),
      q(0301) => q(na),
      q(0302) => q(nv),
      q(0303) => q(nr),
      q(0304) => q(nd),
      q(0305) => q(ng),
      q(0307) => q(ne),
      q(0312) => q(nn),
      q(0313) => q(nb),
      q(0316) => q(no),
      q(0321) => q(ny),
      q(0326) => q(oc),
      q(0327) => q(oj),
      q(0328) => q(or),
      q(0329) => q(om),
      q(0331) => q(os),
      q(0338) => q(pa),
      q(0342) => q(fa),
      q(0345) => q(pi),
      q(0346) => q(pl),
      q(0348) => q(pt),
      q(0351) => q(ps),
      q(0353) => q(qu),
      q(0358) => q(rm),
      q(0360) => q(ro),
      q(0361) => q(rn),
      q(0363) => q(ru),
      q(0365) => q(sg),
      q(0370) => q(sa),
      q(0381) => q(si),
      q(0385) => q(sk),
      q(0386) => q(sl),
      q(0388) => q(se),
      q(0392) => q(sm),
      q(0394) => q(sn),
      q(0395) => q(sd),
      q(0398) => q(so),
      q(0400) => q(st),
      q(0401) => q(es),
      q(0402) => q(sc),
      q(0404) => q(sr),
      q(0407) => q(ss),
      q(0409) => q(su),
      q(0412) => q(sw),
      q(0413) => q(sv),
      q(0416) => q(ty),
      q(0418) => q(ta),
      q(0419) => q(tt),
      q(0420) => q(te),
      q(0424) => q(tg),
      q(0425) => q(tl),
      q(0426) => q(th),
      q(0427) => q(bo),
      q(0429) => q(ti),
      q(0436) => q(to),
      q(0439) => q(tn),
      q(0440) => q(ts),
      q(0441) => q(tk),
      q(0444) => q(tr),
      q(0447) => q(tw),
      q(0451) => q(ug),
      q(0452) => q(uk),
      q(0455) => q(ur),
      q(0456) => q(uz),
      q(0458) => q(ve),
      q(0459) => q(vi),
      q(0460) => q(vo),
      q(0466) => q(cy),
      q(0468) => q(wa),
      q(0469) => q(wo),
      q(0471) => q(xh),
      q(0474) => q(yi),
      q(0475) => q(yo),
      q(0481) => q(za),
      q(0483) => q(zu),
      q(0537) => q(sh),
      },
   q(alpha-3) => {
      q(0001) => q(aar),
      q(0002) => q(abk),
      q(0003) => q(ace),
      q(0004) => q(ach),
      q(0005) => q(ada),
      q(0006) => q(ady),
      q(0007) => q(afa),
      q(0008) => q(afh),
      q(0009) => q(afr),
      q(0010) => q(ain),
      q(0011) => q(aka),
      q(0012) => q(akk),
      q(0013) => q(alb),
      q(0014) => q(ale),
      q(0015) => q(alg),
      q(0016) => q(alt),
      q(0017) => q(amh),
      q(0018) => q(ang),
      q(0019) => q(anp),
      q(0020) => q(apa),
      q(0021) => q(ara),
      q(0022) => q(arc),
      q(0023) => q(arg),
      q(0024) => q(arm),
      q(0025) => q(arn),
      q(0026) => q(arp),
      q(0027) => q(art),
      q(0028) => q(arw),
      q(0029) => q(asm),
      q(0030) => q(ast),
      q(0031) => q(ath),
      q(0032) => q(aus),
      q(0033) => q(ava),
      q(0034) => q(ave),
      q(0035) => q(awa),
      q(0036) => q(aym),
      q(0037) => q(aze),
      q(0038) => q(bad),
      q(0039) => q(bai),
      q(0040) => q(bak),
      q(0041) => q(bal),
      q(0042) => q(bam),
      q(0043) => q(ban),
      q(0044) => q(baq),
      q(0045) => q(bas),
      q(0046) => q(bat),
      q(0047) => q(bej),
      q(0048) => q(bel),
      q(0049) => q(bem),
      q(0050) => q(ben),
      q(0051) => q(ber),
      q(0052) => q(bho),
      q(0053) => q(bih),
      q(0054) => q(bik),
      q(0055) => q(bin),
      q(0056) => q(bis),
      q(0057) => q(bla),
      q(0058) => q(bnt),
      q(0059) => q(bos),
      q(0060) => q(bra),
      q(0061) => q(bre),
      q(0062) => q(btk),
      q(0063) => q(bua),
      q(0064) => q(bug),
      q(0065) => q(bul),
      q(0066) => q(bur),
      q(0067) => q(byn),
      q(0068) => q(cad),
      q(0069) => q(cai),
      q(0070) => q(car),
      q(0071) => q(cat),
      q(0072) => q(cau),
      q(0073) => q(ceb),
      q(0074) => q(cel),
      q(0075) => q(cha),
      q(0076) => q(chb),
      q(0077) => q(che),
      q(0078) => q(chg),
      q(0079) => q(chi),
      q(0080) => q(chk),
      q(0081) => q(chm),
      q(0082) => q(chn),
      q(0083) => q(cho),
      q(0084) => q(chp),
      q(0085) => q(chr),
      q(0086) => q(chu),
      q(0087) => q(chv),
      q(0088) => q(chy),
      q(0089) => q(cmc),
      q(0090) => q(cop),
      q(0091) => q(cor),
      q(0092) => q(cos),
      q(0093) => q(cpe),
      q(0094) => q(cpf),
      q(0095) => q(cpp),
      q(0096) => q(cre),
      q(0097) => q(crh),
      q(0098) => q(crp),
      q(0099) => q(csb),
      q(0100) => q(cus),
      q(0101) => q(cze),
      q(0102) => q(dak),
      q(0103) => q(dan),
      q(0104) => q(dar),
      q(0105) => q(day),
      q(0106) => q(del),
      q(0107) => q(den),
      q(0108) => q(dgr),
      q(0109) => q(din),
      q(0110) => q(div),
      q(0111) => q(doi),
      q(0112) => q(dra),
      q(0113) => q(dsb),
      q(0114) => q(dua),
      q(0115) => q(dum),
      q(0116) => q(dut),
      q(0117) => q(dyu),
      q(0118) => q(dzo),
      q(0119) => q(efi),
      q(0120) => q(egy),
      q(0121) => q(eka),
      q(0122) => q(elx),
      q(0123) => q(eng),
      q(0124) => q(enm),
      q(0125) => q(epo),
      q(0126) => q(est),
      q(0127) => q(ewe),
      q(0128) => q(ewo),
      q(0129) => q(fan),
      q(0130) => q(fao),
      q(0131) => q(fat),
      q(0132) => q(fij),
      q(0133) => q(fil),
      q(0134) => q(fin),
      q(0135) => q(fiu),
      q(0136) => q(fon),
      q(0137) => q(fre),
      q(0138) => q(frm),
      q(0139) => q(fro),
      q(0140) => q(frr),
      q(0141) => q(frs),
      q(0142) => q(fry),
      q(0143) => q(ful),
      q(0144) => q(fur),
      q(0145) => q(gaa),
      q(0146) => q(gay),
      q(0147) => q(gba),
      q(0148) => q(gem),
      q(0149) => q(geo),
      q(0150) => q(ger),
      q(0151) => q(gez),
      q(0152) => q(gil),
      q(0153) => q(gla),
      q(0154) => q(gle),
      q(0155) => q(glg),
      q(0156) => q(glv),
      q(0157) => q(gmh),
      q(0158) => q(goh),
      q(0159) => q(gon),
      q(0160) => q(gor),
      q(0161) => q(got),
      q(0162) => q(grb),
      q(0163) => q(grc),
      q(0164) => q(gre),
      q(0165) => q(grn),
      q(0166) => q(gsw),
      q(0167) => q(guj),
      q(0168) => q(gwi),
      q(0169) => q(hai),
      q(0170) => q(hat),
      q(0171) => q(hau),
      q(0172) => q(haw),
      q(0173) => q(heb),
      q(0174) => q(her),
      q(0175) => q(hil),
      q(0176) => q(him),
      q(0177) => q(hin),
      q(0178) => q(hit),
      q(0179) => q(hmn),
      q(0180) => q(hmo),
      q(0181) => q(hrv),
      q(0182) => q(hsb),
      q(0183) => q(hun),
      q(0184) => q(hup),
      q(0185) => q(iba),
      q(0186) => q(ibo),
      q(0187) => q(ice),
      q(0188) => q(ido),
      q(0189) => q(iii),
      q(0190) => q(ijo),
      q(0191) => q(iku),
      q(0192) => q(ile),
      q(0193) => q(ilo),
      q(0194) => q(ina),
      q(0195) => q(inc),
      q(0196) => q(ind),
      q(0197) => q(ine),
      q(0198) => q(inh),
      q(0199) => q(ipk),
      q(0200) => q(ira),
      q(0201) => q(iro),
      q(0202) => q(ita),
      q(0203) => q(jav),
      q(0204) => q(jbo),
      q(0205) => q(jpn),
      q(0206) => q(jpr),
      q(0207) => q(jrb),
      q(0208) => q(kaa),
      q(0209) => q(kab),
      q(0210) => q(kac),
      q(0211) => q(kal),
      q(0212) => q(kam),
      q(0213) => q(kan),
      q(0214) => q(kar),
      q(0215) => q(kas),
      q(0216) => q(kau),
      q(0217) => q(kaw),
      q(0218) => q(kaz),
      q(0219) => q(kbd),
      q(0220) => q(kha),
      q(0221) => q(khi),
      q(0222) => q(khm),
      q(0223) => q(kho),
      q(0224) => q(kik),
      q(0225) => q(kin),
      q(0226) => q(kir),
      q(0227) => q(kmb),
      q(0228) => q(kok),
      q(0229) => q(kom),
      q(0230) => q(kon),
      q(0231) => q(kor),
      q(0232) => q(kos),
      q(0233) => q(kpe),
      q(0234) => q(krc),
      q(0235) => q(krl),
      q(0236) => q(kro),
      q(0237) => q(kru),
      q(0238) => q(kua),
      q(0239) => q(kum),
      q(0240) => q(kur),
      q(0241) => q(kut),
      q(0242) => q(lad),
      q(0243) => q(lah),
      q(0244) => q(lam),
      q(0245) => q(lao),
      q(0246) => q(lat),
      q(0247) => q(lav),
      q(0248) => q(lez),
      q(0249) => q(lim),
      q(0250) => q(lin),
      q(0251) => q(lit),
      q(0252) => q(lol),
      q(0253) => q(loz),
      q(0254) => q(ltz),
      q(0255) => q(lua),
      q(0256) => q(lub),
      q(0257) => q(lug),
      q(0258) => q(lui),
      q(0259) => q(lun),
      q(0260) => q(luo),
      q(0261) => q(lus),
      q(0262) => q(mac),
      q(0263) => q(mad),
      q(0264) => q(mag),
      q(0265) => q(mah),
      q(0266) => q(mai),
      q(0267) => q(mak),
      q(0268) => q(mal),
      q(0269) => q(man),
      q(0270) => q(mao),
      q(0271) => q(map),
      q(0272) => q(mar),
      q(0273) => q(mas),
      q(0274) => q(may),
      q(0275) => q(mdf),
      q(0276) => q(mdr),
      q(0277) => q(men),
      q(0278) => q(mga),
      q(0279) => q(mic),
      q(0280) => q(min),
      q(0281) => q(mis),
      q(0282) => q(mkh),
      q(0283) => q(mlg),
      q(0284) => q(mlt),
      q(0285) => q(mnc),
      q(0286) => q(mni),
      q(0287) => q(mno),
      q(0288) => q(moh),
      q(0289) => q(mon),
      q(0290) => q(mos),
      q(0291) => q(mul),
      q(0292) => q(mun),
      q(0293) => q(mus),
      q(0294) => q(mwl),
      q(0295) => q(mwr),
      q(0296) => q(myn),
      q(0297) => q(myv),
      q(0298) => q(nah),
      q(0299) => q(nai),
      q(0300) => q(nap),
      q(0301) => q(nau),
      q(0302) => q(nav),
      q(0303) => q(nbl),
      q(0304) => q(nde),
      q(0305) => q(ndo),
      q(0306) => q(nds),
      q(0307) => q(nep),
      q(0308) => q(new),
      q(0309) => q(nia),
      q(0310) => q(nic),
      q(0311) => q(niu),
      q(0312) => q(nno),
      q(0313) => q(nob),
      q(0314) => q(nog),
      q(0315) => q(non),
      q(0316) => q(nor),
      q(0317) => q(nqo),
      q(0318) => q(nso),
      q(0319) => q(nub),
      q(0320) => q(nwc),
      q(0321) => q(nya),
      q(0322) => q(nym),
      q(0323) => q(nyn),
      q(0324) => q(nyo),
      q(0325) => q(nzi),
      q(0326) => q(oci),
      q(0327) => q(oji),
      q(0328) => q(ori),
      q(0329) => q(orm),
      q(0330) => q(osa),
      q(0331) => q(oss),
      q(0332) => q(ota),
      q(0333) => q(oto),
      q(0334) => q(paa),
      q(0335) => q(pag),
      q(0336) => q(pal),
      q(0337) => q(pam),
      q(0338) => q(pan),
      q(0339) => q(pap),
      q(0340) => q(pau),
      q(0341) => q(peo),
      q(0342) => q(per),
      q(0343) => q(phi),
      q(0344) => q(phn),
      q(0345) => q(pli),
      q(0346) => q(pol),
      q(0347) => q(pon),
      q(0348) => q(por),
      q(0349) => q(pra),
      q(0350) => q(pro),
      q(0351) => q(pus),
      q(0352) => q(qtz),
      q(0353) => q(que),
      q(0354) => q(raj),
      q(0355) => q(rap),
      q(0356) => q(rar),
      q(0357) => q(roa),
      q(0358) => q(roh),
      q(0359) => q(rom),
      q(0360) => q(rum),
      q(0361) => q(run),
      q(0362) => q(rup),
      q(0363) => q(rus),
      q(0364) => q(sad),
      q(0365) => q(sag),
      q(0366) => q(sah),
      q(0367) => q(sai),
      q(0368) => q(sal),
      q(0369) => q(sam),
      q(0370) => q(san),
      q(0371) => q(sas),
      q(0372) => q(sat),
      q(0373) => q(scn),
      q(0374) => q(sco),
      q(0375) => q(sel),
      q(0376) => q(sem),
      q(0377) => q(sga),
      q(0378) => q(sgn),
      q(0379) => q(shn),
      q(0380) => q(sid),
      q(0381) => q(sin),
      q(0382) => q(sio),
      q(0383) => q(sit),
      q(0384) => q(sla),
      q(0385) => q(slo),
      q(0386) => q(slv),
      q(0387) => q(sma),
      q(0388) => q(sme),
      q(0389) => q(smi),
      q(0390) => q(smj),
      q(0391) => q(smn),
      q(0392) => q(smo),
      q(0393) => q(sms),
      q(0394) => q(sna),
      q(0395) => q(snd),
      q(0396) => q(snk),
      q(0397) => q(sog),
      q(0398) => q(som),
      q(0399) => q(son),
      q(0400) => q(sot),
      q(0401) => q(spa),
      q(0402) => q(srd),
      q(0403) => q(srn),
      q(0404) => q(srp),
      q(0405) => q(srr),
      q(0406) => q(ssa),
      q(0407) => q(ssw),
      q(0408) => q(suk),
      q(0409) => q(sun),
      q(0410) => q(sus),
      q(0411) => q(sux),
      q(0412) => q(swa),
      q(0413) => q(swe),
      q(0414) => q(syc),
      q(0415) => q(syr),
      q(0416) => q(tah),
      q(0417) => q(tai),
      q(0418) => q(tam),
      q(0419) => q(tat),
      q(0420) => q(tel),
      q(0421) => q(tem),
      q(0422) => q(ter),
      q(0423) => q(tet),
      q(0424) => q(tgk),
      q(0425) => q(tgl),
      q(0426) => q(tha),
      q(0427) => q(tib),
      q(0428) => q(tig),
      q(0429) => q(tir),
      q(0430) => q(tiv),
      q(0431) => q(tkl),
      q(0432) => q(tlh),
      q(0433) => q(tli),
      q(0434) => q(tmh),
      q(0435) => q(tog),
      q(0436) => q(ton),
      q(0437) => q(tpi),
      q(0438) => q(tsi),
      q(0439) => q(tsn),
      q(0440) => q(tso),
      q(0441) => q(tuk),
      q(0442) => q(tum),
      q(0443) => q(tup),
      q(0444) => q(tur),
      q(0445) => q(tut),
      q(0446) => q(tvl),
      q(0447) => q(twi),
      q(0448) => q(tyv),
      q(0449) => q(udm),
      q(0450) => q(uga),
      q(0451) => q(uig),
      q(0452) => q(ukr),
      q(0453) => q(umb),
      q(0454) => q(und),
      q(0455) => q(urd),
      q(0456) => q(uzb),
      q(0457) => q(vai),
      q(0458) => q(ven),
      q(0459) => q(vie),
      q(0460) => q(vol),
      q(0461) => q(vot),
      q(0462) => q(wak),
      q(0463) => q(wal),
      q(0464) => q(war),
      q(0465) => q(was),
      q(0466) => q(wel),
      q(0467) => q(wen),
      q(0468) => q(wln),
      q(0469) => q(wol),
      q(0470) => q(xal),
      q(0471) => q(xho),
      q(0472) => q(yao),
      q(0473) => q(yap),
      q(0474) => q(yid),
      q(0475) => q(yor),
      q(0476) => q(ypk),
      q(0477) => q(zap),
      q(0478) => q(zbl),
      q(0479) => q(zen),
      q(0480) => q(zgh),
      q(0481) => q(zha),
      q(0482) => q(znd),
      q(0483) => q(zul),
      q(0484) => q(zun),
      q(0485) => q(zxx),
      q(0486) => q(zza),
      q(0487) => q(aav),
      q(0488) => q(alv),
      q(0489) => q(aqa),
      q(0490) => q(aql),
      q(0491) => q(auf),
      q(0492) => q(awd),
      q(0493) => q(azc),
      q(0494) => q(cba),
      q(0495) => q(ccn),
      q(0496) => q(ccs),
      q(0497) => q(cdc),
      q(0498) => q(cdd),
      q(0499) => q(csu),
      q(0500) => q(dmn),
      q(0501) => q(egx),
      q(0502) => q(esx),
      q(0503) => q(euq),
      q(0504) => q(fox),
      q(0505) => q(gme),
      q(0506) => q(gmq),
      q(0507) => q(gmw),
      q(0508) => q(grk),
      q(0509) => q(hmx),
      q(0510) => q(hok),
      q(0511) => q(hyx),
      q(0512) => q(iir),
      q(0513) => q(itc),
      q(0514) => q(jpx),
      q(0515) => q(kdo),
      q(0516) => q(ngf),
      q(0517) => q(omq),
      q(0518) => q(omv),
      q(0519) => q(plf),
      q(0520) => q(poz),
      q(0521) => q(pqe),
      q(0522) => q(pqw),
      q(0523) => q(qwe),
      q(0524) => q(sdv),
      q(0525) => q(sqj),
      q(0526) => q(syd),
      q(0527) => q(tbq),
      q(0528) => q(trk),
      q(0529) => q(tuw),
      q(0530) => q(urj),
      q(0531) => q(xgn),
      q(0532) => q(xnd),
      q(0533) => q(zhx),
      q(0534) => q(zle),
      q(0535) => q(zls),
      q(0536) => q(zlw),
      q(0538) => q(aaa),
      q(0539) => q(aab),
      q(0540) => q(aac),
      q(0541) => q(aad),
      q(0542) => q(aae),
      q(0543) => q(aaf),
      q(0544) => q(aag),
      q(0545) => q(aah),
      q(0546) => q(aai),
      q(0547) => q(aak),
      q(0548) => q(aal),
      q(0549) => q(aam),
      q(0550) => q(aan),
      q(0551) => q(aao),
      q(0552) => q(aap),
      q(0553) => q(aaq),
      q(0554) => q(aas),
      q(0555) => q(aat),
      q(0556) => q(aau),
      q(0557) => q(aaw),
      q(0558) => q(aax),
      q(0559) => q(aaz),
      q(0560) => q(aba),
      q(0561) => q(abb),
      q(0562) => q(abc),
      q(0563) => q(abd),
      q(0564) => q(abe),
      q(0565) => q(abf),
      q(0566) => q(abg),
      q(0567) => q(abh),
      q(0568) => q(abi),
      q(0569) => q(abj),
      q(0570) => q(abl),
      q(0571) => q(abm),
      q(0572) => q(abn),
      q(0573) => q(abo),
      q(0574) => q(abp),
      q(0575) => q(abq),
      q(0576) => q(abr),
      q(0577) => q(abs),
      q(0578) => q(abt),
      q(0579) => q(abu),
      q(0580) => q(abv),
      q(0581) => q(abw),
      q(0582) => q(abx),
      q(0583) => q(aby),
      q(0584) => q(abz),
      q(0585) => q(aca),
      q(0586) => q(acb),
      q(0587) => q(acd),
      q(0588) => q(acf),
      q(0589) => q(aci),
      q(0590) => q(ack),
      q(0591) => q(acl),
      q(0592) => q(acm),
      q(0593) => q(acn),
      q(0594) => q(acp),
      q(0595) => q(acq),
      q(0596) => q(acr),
      q(0597) => q(acs),
      q(0598) => q(act),
      q(0599) => q(acu),
      q(0600) => q(acv),
      q(0601) => q(acw),
      q(0602) => q(acx),
      q(0603) => q(acy),
      q(0604) => q(acz),
      q(0605) => q(adb),
      q(0606) => q(add),
      q(0607) => q(ade),
      q(0608) => q(adf),
      q(0609) => q(adg),
      q(0610) => q(adh),
      q(0611) => q(adi),
      q(0612) => q(adj),
      q(0613) => q(adl),
      q(0614) => q(adn),
      q(0615) => q(ado),
      q(0616) => q(adp),
      q(0617) => q(adq),
      q(0618) => q(adr),
      q(0619) => q(ads),
      q(0620) => q(adt),
      q(0621) => q(adu),
      q(0622) => q(adw),
      q(0623) => q(adx),
      q(0624) => q(adz),
      q(0625) => q(aea),
      q(0626) => q(aeb),
      q(0627) => q(aec),
      q(0628) => q(aed),
      q(0629) => q(aee),
      q(0630) => q(aek),
      q(0631) => q(ael),
      q(0632) => q(aem),
      q(0633) => q(aen),
      q(0634) => q(aeq),
      q(0635) => q(aer),
      q(0636) => q(aes),
      q(0637) => q(aeu),
      q(0638) => q(aew),
      q(0639) => q(aey),
      q(0640) => q(aez),
      q(0641) => q(afb),
      q(0642) => q(afd),
      q(0643) => q(afe),
      q(0644) => q(afg),
      q(0645) => q(afi),
      q(0646) => q(afk),
      q(0647) => q(afn),
      q(0648) => q(afo),
      q(0649) => q(afp),
      q(0650) => q(afs),
      q(0651) => q(aft),
      q(0652) => q(afu),
      q(0653) => q(afz),
      q(0654) => q(aga),
      q(0655) => q(agb),
      q(0656) => q(agc),
      q(0657) => q(agd),
      q(0658) => q(age),
      q(0659) => q(agf),
      q(0660) => q(agg),
      q(0661) => q(agh),
      q(0662) => q(agi),
      q(0663) => q(agj),
      q(0664) => q(agk),
      q(0665) => q(agl),
      q(0666) => q(agm),
      q(0667) => q(agn),
      q(0668) => q(ago),
      q(0669) => q(agq),
      q(0670) => q(agr),
      q(0671) => q(ags),
      q(0672) => q(agt),
      q(0673) => q(agu),
      q(0674) => q(agv),
      q(0675) => q(agw),
      q(0676) => q(agx),
      q(0677) => q(agy),
      q(0678) => q(agz),
      q(0679) => q(aha),
      q(0680) => q(ahb),
      q(0681) => q(ahg),
      q(0682) => q(ahh),
      q(0683) => q(ahi),
      q(0684) => q(ahk),
      q(0685) => q(ahl),
      q(0686) => q(ahm),
      q(0687) => q(ahn),
      q(0688) => q(aho),
      q(0689) => q(ahp),
      q(0690) => q(ahr),
      q(0691) => q(ahs),
      q(0692) => q(aht),
      q(0693) => q(aia),
      q(0694) => q(aib),
      q(0695) => q(aic),
      q(0696) => q(aid),
      q(0697) => q(aie),
      q(0698) => q(aif),
      q(0699) => q(aig),
      q(0700) => q(aih),
      q(0701) => q(aii),
      q(0702) => q(aij),
      q(0703) => q(aik),
      q(0704) => q(ail),
      q(0705) => q(aim),
      q(0706) => q(aio),
      q(0707) => q(aip),
      q(0708) => q(aiq),
      q(0709) => q(air),
      q(0710) => q(ais),
      q(0711) => q(ait),
      q(0712) => q(aiw),
      q(0713) => q(aix),
      q(0714) => q(aiy),
      q(0715) => q(aja),
      q(0716) => q(ajg),
      q(0717) => q(aji),
      q(0718) => q(ajn),
      q(0719) => q(ajp),
      q(0720) => q(ajt),
      q(0721) => q(aju),
      q(0722) => q(ajw),
      q(0723) => q(ajz),
      q(0724) => q(akb),
      q(0725) => q(akc),
      q(0726) => q(akd),
      q(0727) => q(ake),
      q(0728) => q(akf),
      q(0729) => q(akg),
      q(0730) => q(akh),
      q(0731) => q(aki),
      q(0732) => q(akj),
      q(0733) => q(akl),
      q(0734) => q(akm),
      q(0735) => q(ako),
      q(0736) => q(akp),
      q(0737) => q(akq),
      q(0738) => q(akr),
      q(0739) => q(aks),
      q(0740) => q(akt),
      q(0741) => q(aku),
      q(0742) => q(akv),
      q(0743) => q(akw),
      q(0744) => q(akx),
      q(0745) => q(aky),
      q(0746) => q(akz),
      q(0747) => q(ala),
      q(0748) => q(alc),
      q(0749) => q(ald),
      q(0750) => q(alf),
      q(0751) => q(alh),
      q(0752) => q(ali),
      q(0753) => q(alj),
      q(0754) => q(alk),
      q(0755) => q(all),
      q(0756) => q(alm),
      q(0757) => q(aln),
      q(0758) => q(alo),
      q(0759) => q(alp),
      q(0760) => q(alq),
      q(0761) => q(alr),
      q(0762) => q(als),
      q(0763) => q(alu),
      q(0764) => q(alw),
      q(0765) => q(alx),
      q(0766) => q(aly),
      q(0767) => q(alz),
      q(0768) => q(ama),
      q(0769) => q(amb),
      q(0770) => q(amc),
      q(0771) => q(ame),
      q(0772) => q(amf),
      q(0773) => q(amg),
      q(0774) => q(ami),
      q(0775) => q(amj),
      q(0776) => q(amk),
      q(0777) => q(aml),
      q(0778) => q(amm),
      q(0779) => q(amn),
      q(0780) => q(amo),
      q(0781) => q(amp),
      q(0782) => q(amq),
      q(0783) => q(amr),
      q(0784) => q(ams),
      q(0785) => q(amt),
      q(0786) => q(amu),
      q(0787) => q(amv),
      q(0788) => q(amw),
      q(0789) => q(amx),
      q(0790) => q(amy),
      q(0791) => q(amz),
      q(0792) => q(ana),
      q(0793) => q(anb),
      q(0794) => q(anc),
      q(0795) => q(and),
      q(0796) => q(ane),
      q(0797) => q(anf),
      q(0798) => q(anh),
      q(0799) => q(ani),
      q(0800) => q(anj),
      q(0801) => q(ank),
      q(0802) => q(anl),
      q(0803) => q(anm),
      q(0804) => q(ann),
      q(0805) => q(ano),
      q(0806) => q(anq),
      q(0807) => q(anr),
      q(0808) => q(ans),
      q(0809) => q(ant),
      q(0810) => q(anu),
      q(0811) => q(anv),
      q(0812) => q(anw),
      q(0813) => q(anx),
      q(0814) => q(any),
      q(0815) => q(anz),
      q(0816) => q(aoa),
      q(0817) => q(aob),
      q(0818) => q(aoc),
      q(0819) => q(aod),
      q(0820) => q(aoe),
      q(0821) => q(aof),
      q(0822) => q(aog),
      q(0823) => q(aoh),
      q(0824) => q(aoi),
      q(0825) => q(aoj),
      q(0826) => q(aok),
      q(0827) => q(aol),
      q(0828) => q(aom),
      q(0829) => q(aon),
      q(0830) => q(aor),
      q(0831) => q(aos),
      q(0832) => q(aot),
      q(0833) => q(aou),
      q(0834) => q(aox),
      q(0835) => q(aoz),
      q(0836) => q(apb),
      q(0837) => q(apc),
      q(0838) => q(apd),
      q(0839) => q(ape),
      q(0840) => q(apf),
      q(0841) => q(apg),
      q(0842) => q(aph),
      q(0843) => q(api),
      q(0844) => q(apj),
      q(0845) => q(apk),
      q(0846) => q(apl),
      q(0847) => q(apm),
      q(0848) => q(apn),
      q(0849) => q(apo),
      q(0850) => q(app),
      q(0851) => q(apq),
      q(0852) => q(apr),
      q(0853) => q(aps),
      q(0854) => q(apt),
      q(0855) => q(apu),
      q(0856) => q(apv),
      q(0857) => q(apw),
      q(0858) => q(apx),
      q(0859) => q(apy),
      q(0860) => q(apz),
      q(0861) => q(aqc),
      q(0862) => q(aqd),
      q(0863) => q(aqg),
      q(0864) => q(aqm),
      q(0865) => q(aqn),
      q(0866) => q(aqp),
      q(0867) => q(aqr),
      q(0868) => q(aqz),
      q(0869) => q(arb),
      q(0870) => q(ard),
      q(0871) => q(are),
      q(0872) => q(arh),
      q(0873) => q(ari),
      q(0874) => q(arj),
      q(0875) => q(ark),
      q(0876) => q(arl),
      q(0877) => q(aro),
      q(0878) => q(arq),
      q(0879) => q(arr),
      q(0880) => q(ars),
      q(0881) => q(aru),
      q(0882) => q(arv),
      q(0883) => q(arx),
      q(0884) => q(ary),
      q(0885) => q(arz),
      q(0886) => q(asa),
      q(0887) => q(asb),
      q(0888) => q(asc),
      q(0889) => q(asd),
      q(0890) => q(ase),
      q(0891) => q(asf),
      q(0892) => q(asg),
      q(0893) => q(ash),
      q(0894) => q(asi),
      q(0895) => q(asj),
      q(0896) => q(ask),
      q(0897) => q(asl),
      q(0898) => q(asn),
      q(0899) => q(aso),
      q(0900) => q(asp),
      q(0901) => q(asq),
      q(0902) => q(asr),
      q(0903) => q(ass),
      q(0904) => q(asu),
      q(0905) => q(asv),
      q(0906) => q(asw),
      q(0907) => q(asx),
      q(0908) => q(asy),
      q(0909) => q(asz),
      q(0910) => q(ata),
      q(0911) => q(atb),
      q(0912) => q(atc),
      q(0913) => q(atd),
      q(0914) => q(ate),
      q(0915) => q(atg),
      q(0916) => q(ati),
      q(0917) => q(atj),
      q(0918) => q(atk),
      q(0919) => q(atl),
      q(0920) => q(atm),
      q(0921) => q(atn),
      q(0922) => q(ato),
      q(0923) => q(atp),
      q(0924) => q(atq),
      q(0925) => q(atr),
      q(0926) => q(ats),
      q(0927) => q(att),
      q(0928) => q(atu),
      q(0929) => q(atv),
      q(0930) => q(atw),
      q(0931) => q(atx),
      q(0932) => q(aty),
      q(0933) => q(atz),
      q(0934) => q(aua),
      q(0935) => q(aub),
      q(0936) => q(auc),
      q(0937) => q(aud),
      q(0938) => q(aue),
      q(0939) => q(aug),
      q(0940) => q(auh),
      q(0941) => q(aui),
      q(0942) => q(auj),
      q(0943) => q(auk),
      q(0944) => q(aul),
      q(0945) => q(aum),
      q(0946) => q(aun),
      q(0947) => q(auo),
      q(0948) => q(aup),
      q(0949) => q(auq),
      q(0950) => q(aur),
      q(0951) => q(aut),
      q(0952) => q(auu),
      q(0953) => q(auw),
      q(0954) => q(aux),
      q(0955) => q(auy),
      q(0956) => q(auz),
      q(0957) => q(avb),
      q(0958) => q(avd),
      q(0959) => q(avi),
      q(0960) => q(avk),
      q(0961) => q(avl),
      q(0962) => q(avm),
      q(0963) => q(avn),
      q(0964) => q(avo),
      q(0965) => q(avs),
      q(0966) => q(avt),
      q(0967) => q(avu),
      q(0968) => q(avv),
      q(0969) => q(awb),
      q(0970) => q(awc),
      q(0971) => q(awe),
      q(0972) => q(awg),
      q(0973) => q(awh),
      q(0974) => q(awi),
      q(0975) => q(awk),
      q(0976) => q(awm),
      q(0977) => q(awn),
      q(0978) => q(awo),
      q(0979) => q(awr),
      q(0980) => q(aws),
      q(0981) => q(awt),
      q(0982) => q(awu),
      q(0983) => q(awv),
      q(0984) => q(aww),
      q(0985) => q(awx),
      q(0986) => q(awy),
      q(0987) => q(axb),
      q(0988) => q(axe),
      q(0989) => q(axg),
      q(0990) => q(axk),
      q(0991) => q(axl),
      q(0992) => q(axm),
      q(0993) => q(axx),
      q(0994) => q(aya),
      q(0995) => q(ayb),
      q(0996) => q(ayc),
      q(0997) => q(ayd),
      q(0998) => q(aye),
      q(0999) => q(ayg),
      q(1000) => q(ayh),
      q(1001) => q(ayi),
      q(1002) => q(ayk),
      q(1003) => q(ayl),
      q(1004) => q(ayn),
      q(1005) => q(ayo),
      q(1006) => q(ayp),
      q(1007) => q(ayq),
      q(1008) => q(ayr),
      q(1009) => q(ays),
      q(1010) => q(ayt),
      q(1011) => q(ayu),
      q(1012) => q(ayy),
      q(1013) => q(ayz),
      q(1014) => q(aza),
      q(1015) => q(azb),
      q(1016) => q(azd),
      q(1017) => q(azg),
      q(1018) => q(azj),
      q(1019) => q(azm),
      q(1020) => q(azn),
      q(1021) => q(azo),
      q(1022) => q(azt),
      q(1023) => q(azz),
      q(1024) => q(baa),
      q(1025) => q(bab),
      q(1026) => q(bac),
      q(1027) => q(bae),
      q(1028) => q(baf),
      q(1029) => q(bag),
      q(1030) => q(bah),
      q(1031) => q(baj),
      q(1032) => q(bao),
      q(1033) => q(bap),
      q(1034) => q(bar),
      q(1035) => q(bau),
      q(1036) => q(bav),
      q(1037) => q(baw),
      q(1038) => q(bax),
      q(1039) => q(bay),
      q(1040) => q(bba),
      q(1041) => q(bbb),
      q(1042) => q(bbc),
      q(1043) => q(bbd),
      q(1044) => q(bbe),
      q(1045) => q(bbf),
      q(1046) => q(bbg),
      q(1047) => q(bbh),
      q(1048) => q(bbi),
      q(1049) => q(bbj),
      q(1050) => q(bbk),
      q(1051) => q(bbl),
      q(1052) => q(bbm),
      q(1053) => q(bbn),
      q(1054) => q(bbo),
      q(1055) => q(bbp),
      q(1056) => q(bbq),
      q(1057) => q(bbr),
      q(1058) => q(bbs),
      q(1059) => q(bbt),
      q(1060) => q(bbu),
      q(1061) => q(bbv),
      q(1062) => q(bbw),
      q(1063) => q(bbx),
      q(1064) => q(bby),
      q(1065) => q(bbz),
      q(1066) => q(bca),
      q(1067) => q(bcb),
      q(1068) => q(bcc),
      q(1069) => q(bcd),
      q(1070) => q(bce),
      q(1071) => q(bcf),
      q(1072) => q(bcg),
      q(1073) => q(bch),
      q(1074) => q(bci),
      q(1075) => q(bcj),
      q(1076) => q(bck),
      q(1077) => q(bcl),
      q(1078) => q(bcm),
      q(1079) => q(bcn),
      q(1080) => q(bco),
      q(1081) => q(bcp),
      q(1082) => q(bcq),
      q(1083) => q(bcr),
      q(1084) => q(bcs),
      q(1085) => q(bct),
      q(1086) => q(bcu),
      q(1087) => q(bcv),
      q(1088) => q(bcw),
      q(1089) => q(bcy),
      q(1090) => q(bcz),
      q(1091) => q(bda),
      q(1092) => q(bdb),
      q(1093) => q(bdc),
      q(1094) => q(bdd),
      q(1095) => q(bde),
      q(1096) => q(bdf),
      q(1097) => q(bdg),
      q(1098) => q(bdh),
      q(1099) => q(bdi),
      q(1100) => q(bdj),
      q(1101) => q(bdk),
      q(1102) => q(bdl),
      q(1103) => q(bdm),
      q(1104) => q(bdn),
      q(1105) => q(bdo),
      q(1106) => q(bdp),
      q(1107) => q(bdq),
      q(1108) => q(bdr),
      q(1109) => q(bds),
      q(1110) => q(bdt),
      q(1111) => q(bdu),
      q(1112) => q(bdv),
      q(1113) => q(bdw),
      q(1114) => q(bdx),
      q(1115) => q(bdy),
      q(1116) => q(bdz),
      q(1117) => q(bea),
      q(1118) => q(beb),
      q(1119) => q(bec),
      q(1120) => q(bed),
      q(1121) => q(bee),
      q(1122) => q(bef),
      q(1123) => q(beg),
      q(1124) => q(beh),
      q(1125) => q(bei),
      q(1126) => q(bek),
      q(1127) => q(beo),
      q(1128) => q(bep),
      q(1129) => q(beq),
      q(1130) => q(bes),
      q(1131) => q(bet),
      q(1132) => q(beu),
      q(1133) => q(bev),
      q(1134) => q(bew),
      q(1135) => q(bex),
      q(1136) => q(bey),
      q(1137) => q(bez),
      q(1138) => q(mot),
      q(1139) => q(bfb),
      q(1140) => q(bfc),
      q(1141) => q(bfd),
      q(1142) => q(bfe),
      q(1143) => q(bff),
      q(1144) => q(bfg),
      q(1145) => q(bfh),
      q(1146) => q(bfi),
      q(1147) => q(bfj),
      q(1148) => q(bfk),
      q(1149) => q(bfl),
      q(1150) => q(bfm),
      q(1151) => q(bfn),
      q(1152) => q(bfo),
      q(1153) => q(bfp),
      q(1154) => q(bfq),
      q(1155) => q(bfr),
      q(1156) => q(bfs),
      q(1157) => q(bft),
      q(1158) => q(bfu),
      q(1159) => q(bfw),
      q(1160) => q(bfx),
      q(1161) => q(bfy),
      q(1162) => q(bfz),
      q(1163) => q(bga),
      q(1164) => q(bgb),
      q(1165) => q(bgc),
      q(1166) => q(bgd),
      q(1167) => q(bge),
      q(1168) => q(bgf),
      q(1169) => q(bgg),
      q(1170) => q(bgi),
      q(1171) => q(bgj),
      q(1172) => q(bgk),
      q(1173) => q(bgl),
      q(1174) => q(bgm),
      q(1175) => q(bgn),
      q(1176) => q(bgo),
      q(1177) => q(bgp),
      q(1178) => q(bgq),
      q(1179) => q(bgr),
      q(1180) => q(bgs),
      q(1181) => q(bgt),
      q(1182) => q(bgu),
      q(1183) => q(bgv),
      q(1184) => q(bgw),
      q(1185) => q(bgx),
      q(1186) => q(bgy),
      q(1187) => q(bgz),
      q(1188) => q(bha),
      q(1189) => q(bhb),
      q(1190) => q(bhc),
      q(1191) => q(bhd),
      q(1192) => q(bhe),
      q(1193) => q(bhf),
      q(1194) => q(bhg),
      q(1195) => q(bhh),
      q(1196) => q(bhi),
      q(1197) => q(bhj),
      q(1198) => q(bhl),
      q(1199) => q(bhm),
      q(1200) => q(bhn),
      q(1201) => q(bhp),
      q(1202) => q(bhq),
      q(1203) => q(bhr),
      q(1204) => q(bhs),
      q(1205) => q(bht),
      q(1206) => q(bhu),
      q(1207) => q(bhv),
      q(1208) => q(bhw),
      q(1209) => q(bhx),
      q(1210) => q(bhy),
      q(1211) => q(bhz),
      q(1212) => q(bia),
      q(1213) => q(bib),
      q(1214) => q(bic),
      q(1215) => q(bid),
      q(1216) => q(bie),
      q(1217) => q(bif),
      q(1218) => q(big),
      q(1219) => q(bij),
      q(1220) => q(bil),
      q(1221) => q(bim),
      q(1222) => q(bio),
      q(1223) => q(bip),
      q(1224) => q(biq),
      q(1225) => q(bir),
      q(1226) => q(bit),
      q(1227) => q(biu),
      q(1228) => q(biv),
      q(1229) => q(biw),
      q(1230) => q(bix),
      q(1231) => q(biy),
      q(1232) => q(biz),
      q(1233) => q(bja),
      q(1234) => q(bjb),
      q(1235) => q(bjc),
      q(1236) => q(bje),
      q(1237) => q(bjf),
      q(1238) => q(bjg),
      q(1239) => q(bjh),
      q(1240) => q(bji),
      q(1241) => q(bjj),
      q(1242) => q(bjk),
      q(1243) => q(bjl),
      q(1244) => q(bjm),
      q(1245) => q(bjn),
      q(1246) => q(bjo),
      q(1247) => q(bjp),
      q(1248) => q(bjr),
      q(1249) => q(bjs),
      q(1250) => q(bjt),
      q(1251) => q(bju),
      q(1252) => q(bjv),
      q(1253) => q(bjw),
      q(1254) => q(bjx),
      q(1255) => q(bjy),
      q(1256) => q(bjz),
      q(1257) => q(bka),
      q(1258) => q(bkc),
      q(1259) => q(bkd),
      q(1260) => q(bkf),
      q(1261) => q(bkg),
      q(1262) => q(bkh),
      q(1263) => q(bki),
      q(1264) => q(bkj),
      q(1265) => q(bkk),
      q(1266) => q(bkl),
      q(1267) => q(bkm),
      q(1268) => q(bkn),
      q(1269) => q(bko),
      q(1270) => q(bkp),
      q(1271) => q(bkq),
      q(1272) => q(bkr),
      q(1273) => q(bks),
      q(1274) => q(bkt),
      q(1275) => q(bku),
      q(1276) => q(bkv),
      q(1277) => q(bkw),
      q(1278) => q(bkx),
      q(1279) => q(bky),
      q(1280) => q(bkz),
      q(1281) => q(blb),
      q(1282) => q(blc),
      q(1283) => q(bld),
      q(1284) => q(ble),
      q(1285) => q(blf),
      q(1286) => q(blg),
      q(1287) => q(blh),
      q(1288) => q(bli),
      q(1289) => q(blj),
      q(1290) => q(blk),
      q(1291) => q(bll),
      q(1292) => q(blm),
      q(1293) => q(bln),
      q(1294) => q(blo),
      q(1295) => q(blp),
      q(1296) => q(blq),
      q(1297) => q(blr),
      q(1298) => q(bls),
      q(1299) => q(blt),
      q(1300) => q(blv),
      q(1301) => q(blw),
      q(1302) => q(blx),
      q(1303) => q(bly),
      q(1304) => q(blz),
      q(1305) => q(bma),
      q(1306) => q(bmb),
      q(1307) => q(bmc),
      q(1308) => q(bmd),
      q(1309) => q(bme),
      q(1310) => q(bmf),
      q(1311) => q(bmg),
      q(1312) => q(bmh),
      q(1313) => q(bmi),
      q(1314) => q(bmj),
      q(1315) => q(bmk),
      q(1316) => q(bml),
      q(1317) => q(bmm),
      q(1318) => q(bmn),
      q(1319) => q(bmo),
      q(1320) => q(bmp),
      q(1321) => q(bmq),
      q(1322) => q(bmr),
      q(1323) => q(bms),
      q(1324) => q(bmt),
      q(1325) => q(bmu),
      q(1326) => q(bmv),
      q(1327) => q(bmw),
      q(1328) => q(bmx),
      q(1329) => q(bmy),
      q(1330) => q(bmz),
      q(1331) => q(bna),
      q(1332) => q(bnb),
      q(1333) => q(bnc),
      q(1334) => q(bnd),
      q(1335) => q(bne),
      q(1336) => q(bnf),
      q(1337) => q(bng),
      q(1338) => q(bni),
      q(1339) => q(bnj),
      q(1340) => q(bnk),
      q(1341) => q(bnl),
      q(1342) => q(bnm),
      q(1343) => q(bnn),
      q(1344) => q(bno),
      q(1345) => q(bnp),
      q(1346) => q(bnq),
      q(1347) => q(bnr),
      q(1348) => q(bns),
      q(1349) => q(bnu),
      q(1350) => q(bnv),
      q(1351) => q(bnw),
      q(1352) => q(bnx),
      q(1353) => q(bny),
      q(1354) => q(bnz),
      q(1355) => q(boa),
      q(1356) => q(bob),
      q(1357) => q(boe),
      q(1358) => q(bof),
      q(1359) => q(bog),
      q(1360) => q(boh),
      q(1361) => q(boi),
      q(1362) => q(boj),
      q(1363) => q(bok),
      q(1364) => q(bol),
      q(1365) => q(bom),
      q(1366) => q(bon),
      q(1367) => q(boo),
      q(1368) => q(bop),
      q(1369) => q(boq),
      q(1370) => q(bor),
      q(1371) => q(bot),
      q(1372) => q(bou),
      q(1373) => q(bov),
      q(1374) => q(bow),
      q(1375) => q(box),
      q(1376) => q(boy),
      q(1377) => q(boz),
      q(1378) => q(bpa),
      q(1379) => q(bpb),
      q(1380) => q(bpd),
      q(1381) => q(bpg),
      q(1382) => q(bph),
      q(1383) => q(bpi),
      q(1384) => q(bpj),
      q(1385) => q(bpk),
      q(1386) => q(bpl),
      q(1387) => q(bpm),
      q(1388) => q(bpn),
      q(1389) => q(bpo),
      q(1390) => q(bpp),
      q(1391) => q(bpq),
      q(1392) => q(bpr),
      q(1393) => q(bps),
      q(1394) => q(bpt),
      q(1395) => q(bpu),
      q(1396) => q(bpv),
      q(1397) => q(bpw),
      q(1398) => q(bpx),
      q(1399) => q(bpy),
      q(1400) => q(bpz),
      q(1401) => q(bqa),
      q(1402) => q(bqb),
      q(1403) => q(bqc),
      q(1404) => q(bqd),
      q(1405) => q(bqf),
      q(1406) => q(bqg),
      q(1407) => q(bqh),
      q(1408) => q(bqi),
      q(1409) => q(bqj),
      q(1410) => q(bqk),
      q(1411) => q(bql),
      q(1412) => q(bqm),
      q(1413) => q(bqn),
      q(1414) => q(bqo),
      q(1415) => q(bqp),
      q(1416) => q(bqq),
      q(1417) => q(bqr),
      q(1418) => q(bqs),
      q(1419) => q(bqt),
      q(1420) => q(bqu),
      q(1421) => q(bqv),
      q(1422) => q(bqw),
      q(1423) => q(bqx),
      q(1424) => q(bqy),
      q(1425) => q(bqz),
      q(1426) => q(brb),
      q(1427) => q(brc),
      q(1428) => q(brd),
      q(1429) => q(brf),
      q(1430) => q(brg),
      q(1431) => q(brh),
      q(1432) => q(bri),
      q(1433) => q(brj),
      q(1434) => q(brk),
      q(1435) => q(brl),
      q(1436) => q(brm),
      q(1437) => q(brn),
      q(1438) => q(bro),
      q(1439) => q(brp),
      q(1440) => q(brq),
      q(1441) => q(brr),
      q(1442) => q(brs),
      q(1443) => q(brt),
      q(1444) => q(bru),
      q(1445) => q(brv),
      q(1446) => q(brw),
      q(1447) => q(brx),
      q(1448) => q(bry),
      q(1449) => q(brz),
      q(1450) => q(bsa),
      q(1451) => q(bsb),
      q(1452) => q(bsc),
      q(1453) => q(bse),
      q(1454) => q(bsf),
      q(1455) => q(bsg),
      q(1456) => q(bsh),
      q(1457) => q(bsi),
      q(1458) => q(bsj),
      q(1459) => q(bsk),
      q(1460) => q(bsl),
      q(1461) => q(bsm),
      q(1462) => q(bsn),
      q(1463) => q(bso),
      q(1464) => q(bsp),
      q(1465) => q(bsq),
      q(1466) => q(bsr),
      q(1467) => q(bss),
      q(1468) => q(bst),
      q(1469) => q(bsu),
      q(1470) => q(bsv),
      q(1471) => q(bsw),
      q(1472) => q(bsx),
      q(1473) => q(bsy),
      q(1474) => q(bta),
      q(1475) => q(btc),
      q(1476) => q(btd),
      q(1477) => q(bte),
      q(1478) => q(btf),
      q(1479) => q(btg),
      q(1480) => q(bth),
      q(1481) => q(bti),
      q(1482) => q(btj),
      q(1483) => q(btl),
      q(1484) => q(btm),
      q(1485) => q(btn),
      q(1486) => q(bto),
      q(1487) => q(btp),
      q(1488) => q(btq),
      q(1489) => q(btr),
      q(1490) => q(bts),
      q(1491) => q(btt),
      q(1492) => q(btu),
      q(1493) => q(btv),
      q(1494) => q(btw),
      q(1495) => q(btx),
      q(1496) => q(bty),
      q(1497) => q(btz),
      q(1498) => q(bub),
      q(1499) => q(buc),
      q(1500) => q(bud),
      q(1501) => q(bue),
      q(1502) => q(buf),
      q(1503) => q(buh),
      q(1504) => q(bui),
      q(1505) => q(buj),
      q(1506) => q(buk),
      q(1507) => q(bum),
      q(1508) => q(bun),
      q(1509) => q(buo),
      q(1510) => q(bup),
      q(1511) => q(buq),
      q(1512) => q(bus),
      q(1513) => q(but),
      q(1514) => q(buu),
      q(1515) => q(buv),
      q(1516) => q(buw),
      q(1517) => q(bux),
      q(1518) => q(buy),
      q(1519) => q(buz),
      q(1520) => q(bva),
      q(1521) => q(bvb),
      q(1522) => q(bvc),
      q(1523) => q(bvd),
      q(1524) => q(bve),
      q(1525) => q(bvf),
      q(1526) => q(bvg),
      q(1527) => q(bvh),
      q(1528) => q(bvi),
      q(1529) => q(bvj),
      q(1530) => q(bvk),
      q(1531) => q(bvl),
      q(1532) => q(bvm),
      q(1533) => q(bvn),
      q(1534) => q(bvo),
      q(1535) => q(bvp),
      q(1536) => q(bvq),
      q(1537) => q(bvr),
      q(1538) => q(bvt),
      q(1539) => q(bvu),
      q(1540) => q(bvv),
      q(1541) => q(bvw),
      q(1542) => q(bvx),
      q(1543) => q(bvy),
      q(1544) => q(bvz),
      q(1545) => q(bwa),
      q(1546) => q(bwb),
      q(1547) => q(bwc),
      q(1548) => q(bwd),
      q(1549) => q(bwe),
      q(1550) => q(bwf),
      q(1551) => q(bwg),
      q(1552) => q(bwh),
      q(1553) => q(bwi),
      q(1554) => q(bwj),
      q(1555) => q(bwk),
      q(1556) => q(bwl),
      q(1557) => q(bwm),
      q(1558) => q(bwn),
      q(1559) => q(bwo),
      q(1560) => q(bwp),
      q(1561) => q(bwq),
      q(1562) => q(bwr),
      q(1563) => q(bws),
      q(1564) => q(bwt),
      q(1565) => q(bwu),
      q(1566) => q(bww),
      q(1567) => q(bwx),
      q(1568) => q(bwy),
      q(1569) => q(bwz),
      q(1570) => q(bxa),
      q(1571) => q(bxb),
      q(1572) => q(bxc),
      q(1573) => q(bxd),
      q(1574) => q(bxe),
      q(1575) => q(bxf),
      q(1576) => q(bxg),
      q(1577) => q(bxh),
      q(1578) => q(bxi),
      q(1579) => q(bxj),
      q(1580) => q(bxk),
      q(1581) => q(bxl),
      q(1582) => q(bxm),
      q(1583) => q(bxn),
      q(1584) => q(bxo),
      q(1585) => q(bxp),
      q(1586) => q(bxq),
      q(1587) => q(bxr),
      q(1588) => q(bxs),
      q(1589) => q(bxu),
      q(1590) => q(bxv),
      q(1591) => q(bxw),
      q(1592) => q(bxx),
      q(1593) => q(bxz),
      q(1594) => q(bya),
      q(1595) => q(byb),
      q(1596) => q(byc),
      q(1597) => q(byd),
      q(1598) => q(bye),
      q(1599) => q(byf),
      q(1600) => q(byg),
      q(1601) => q(byh),
      q(1602) => q(byi),
      q(1603) => q(byj),
      q(1604) => q(byk),
      q(1605) => q(byl),
      q(1606) => q(bym),
      q(1607) => q(byo),
      q(1608) => q(byp),
      q(1609) => q(byq),
      q(1610) => q(byr),
      q(1611) => q(bys),
      q(1612) => q(byt),
      q(1613) => q(byv),
      q(1614) => q(byw),
      q(1615) => q(byx),
      q(1616) => q(byy),
      q(1617) => q(byz),
      q(1618) => q(bza),
      q(1619) => q(bzb),
      q(1620) => q(bzc),
      q(1621) => q(bzd),
      q(1622) => q(bze),
      q(1623) => q(bzf),
      q(1624) => q(bzg),
      q(1625) => q(bzh),
      q(1626) => q(bzi),
      q(1627) => q(bzj),
      q(1628) => q(bzk),
      q(1629) => q(bzl),
      q(1630) => q(bzm),
      q(1631) => q(bzn),
      q(1632) => q(bzo),
      q(1633) => q(bzp),
      q(1634) => q(bzq),
      q(1635) => q(bzr),
      q(1636) => q(bzs),
      q(1637) => q(bzt),
      q(1638) => q(bzu),
      q(1639) => q(bzv),
      q(1640) => q(bzw),
      q(1641) => q(bzx),
      q(1642) => q(bzy),
      q(1643) => q(bzz),
      q(1644) => q(caa),
      q(1645) => q(cab),
      q(1646) => q(cac),
      q(1647) => q(cae),
      q(1648) => q(caf),
      q(1649) => q(cag),
      q(1650) => q(cah),
      q(1651) => q(caj),
      q(1652) => q(cak),
      q(1653) => q(cal),
      q(1654) => q(cam),
      q(1655) => q(can),
      q(1656) => q(cao),
      q(1657) => q(cap),
      q(1658) => q(caq),
      q(1659) => q(cas),
      q(1660) => q(cav),
      q(1661) => q(caw),
      q(1662) => q(cax),
      q(1663) => q(cay),
      q(1664) => q(caz),
      q(1665) => q(cbb),
      q(1666) => q(cbc),
      q(1667) => q(cbd),
      q(1668) => q(cbe),
      q(1669) => q(cbg),
      q(1670) => q(cbh),
      q(1671) => q(cbi),
      q(1672) => q(cbj),
      q(1673) => q(cbk),
      q(1674) => q(cbl),
      q(1675) => q(cbn),
      q(1676) => q(cbo),
      q(1677) => q(cbr),
      q(1678) => q(cbs),
      q(1679) => q(cbt),
      q(1680) => q(cbu),
      q(1681) => q(cbv),
      q(1682) => q(cbw),
      q(1683) => q(cby),
      q(1684) => q(cca),
      q(1685) => q(ccc),
      q(1686) => q(ccd),
      q(1687) => q(cce),
      q(1688) => q(ccg),
      q(1689) => q(cch),
      q(1690) => q(ccj),
      q(1691) => q(ccl),
      q(1692) => q(ccm),
      q(1693) => q(cco),
      q(1694) => q(ccp),
      q(1695) => q(ccr),
      q(1696) => q(cda),
      q(1697) => q(cde),
      q(1698) => q(cdf),
      q(1699) => q(cdg),
      q(1700) => q(cdh),
      q(1701) => q(cdi),
      q(1702) => q(cdj),
      q(1703) => q(cdm),
      q(1704) => q(cdn),
      q(1705) => q(cdo),
      q(1706) => q(cdr),
      q(1707) => q(cds),
      q(1708) => q(cdy),
      q(1709) => q(cdz),
      q(1710) => q(cea),
      q(1711) => q(ceg),
      q(1712) => q(cek),
      q(1713) => q(cen),
      q(1714) => q(cet),
      q(1715) => q(cfa),
      q(1716) => q(cfd),
      q(1717) => q(cfg),
      q(1718) => q(cfm),
      q(1719) => q(cga),
      q(1720) => q(cgc),
      q(1721) => q(cgg),
      q(1722) => q(cgk),
      q(1723) => q(chc),
      q(1724) => q(chd),
      q(1725) => q(chf),
      q(1726) => q(chh),
      q(1727) => q(chj),
      q(1728) => q(chl),
      q(1729) => q(chq),
      q(1730) => q(cht),
      q(1731) => q(chw),
      q(1732) => q(chx),
      q(1733) => q(chz),
      q(1734) => q(cia),
      q(1735) => q(cib),
      q(1736) => q(cic),
      q(1737) => q(cid),
      q(1738) => q(cie),
      q(1739) => q(cih),
      q(1740) => q(cik),
      q(1741) => q(cim),
      q(1742) => q(cin),
      q(1743) => q(cip),
      q(1744) => q(cir),
      q(1745) => q(ciw),
      q(1746) => q(ciy),
      q(1747) => q(cja),
      q(1748) => q(cje),
      q(1749) => q(cjh),
      q(1750) => q(cji),
      q(1751) => q(cjk),
      q(1752) => q(cjm),
      q(1753) => q(cjn),
      q(1754) => q(cjo),
      q(1755) => q(cjp),
      q(1756) => q(cjs),
      q(1757) => q(cjv),
      q(1758) => q(cjy),
      q(1759) => q(ckb),
      q(1760) => q(ckh),
      q(1761) => q(ckl),
      q(1762) => q(ckn),
      q(1763) => q(cko),
      q(1764) => q(ckq),
      q(1765) => q(ckr),
      q(1766) => q(cks),
      q(1767) => q(ckt),
      q(1768) => q(cku),
      q(1769) => q(ckv),
      q(1770) => q(ckx),
      q(1771) => q(cky),
      q(1772) => q(ckz),
      q(1773) => q(cla),
      q(1774) => q(clc),
      q(1775) => q(cld),
      q(1776) => q(cle),
      q(1777) => q(clh),
      q(1778) => q(cli),
      q(1779) => q(clj),
      q(1780) => q(clk),
      q(1781) => q(cll),
      q(1782) => q(clm),
      q(1783) => q(clo),
      q(1784) => q(clt),
      q(1785) => q(clu),
      q(1786) => q(clw),
      q(1787) => q(cly),
      q(1788) => q(cma),
      q(1789) => q(cme),
      q(1790) => q(cmg),
      q(1791) => q(cmi),
      q(1792) => q(cml),
      q(1793) => q(cmm),
      q(1794) => q(cmn),
      q(1795) => q(cmo),
      q(1796) => q(cmr),
      q(1797) => q(cms),
      q(1798) => q(cmt),
      q(1799) => q(cna),
      q(1800) => q(cnb),
      q(1801) => q(cnc),
      q(1802) => q(cng),
      q(1803) => q(cnh),
      q(1804) => q(cni),
      q(1805) => q(cnk),
      q(1806) => q(cnl),
      q(1807) => q(cno),
      q(1808) => q(cns),
      q(1809) => q(cnt),
      q(1810) => q(cnu),
      q(1811) => q(cnw),
      q(1812) => q(cnx),
      q(1813) => q(coa),
      q(1814) => q(cob),
      q(1815) => q(coc),
      q(1816) => q(cod),
      q(1817) => q(coe),
      q(1818) => q(cof),
      q(1819) => q(cog),
      q(1820) => q(coh),
      q(1821) => q(coj),
      q(1822) => q(cok),
      q(1823) => q(col),
      q(1824) => q(com),
      q(1825) => q(con),
      q(1826) => q(coo),
      q(1827) => q(coq),
      q(1828) => q(cot),
      q(1829) => q(cou),
      q(1830) => q(cov),
      q(1831) => q(cow),
      q(1832) => q(cox),
      q(1833) => q(coy),
      q(1834) => q(coz),
      q(1835) => q(cpa),
      q(1836) => q(cpb),
      q(1837) => q(cpc),
      q(1838) => q(cpg),
      q(1839) => q(cpi),
      q(1840) => q(cpn),
      q(1841) => q(cpo),
      q(1842) => q(cps),
      q(1843) => q(cpu),
      q(1844) => q(cpx),
      q(1845) => q(cpy),
      q(1846) => q(cqd),
      q(1847) => q(cqu),
      q(1848) => q(cra),
      q(1849) => q(crb),
      q(1850) => q(crc),
      q(1851) => q(crd),
      q(1852) => q(crf),
      q(1853) => q(crg),
      q(1854) => q(cri),
      q(1855) => q(crj),
      q(1856) => q(crk),
      q(1857) => q(crl),
      q(1858) => q(crm),
      q(1859) => q(crn),
      q(1860) => q(cro),
      q(1861) => q(crq),
      q(1862) => q(crr),
      q(1863) => q(crs),
      q(1864) => q(crt),
      q(1865) => q(crv),
      q(1866) => q(crw),
      q(1867) => q(crx),
      q(1868) => q(cry),
      q(1869) => q(crz),
      q(1870) => q(csa),
      q(1871) => q(csc),
      q(1872) => q(csd),
      q(1873) => q(cse),
      q(1874) => q(csf),
      q(1875) => q(csg),
      q(1876) => q(csh),
      q(1877) => q(csi),
      q(1878) => q(csj),
      q(1879) => q(csk),
      q(1880) => q(csl),
      q(1881) => q(csm),
      q(1882) => q(csn),
      q(1883) => q(cso),
      q(1884) => q(csq),
      q(1885) => q(csr),
      q(1886) => q(css),
      q(1887) => q(cst),
      q(1888) => q(csv),
      q(1889) => q(csw),
      q(1890) => q(csy),
      q(1891) => q(csz),
      q(1892) => q(cta),
      q(1893) => q(ctc),
      q(1894) => q(ctd),
      q(1895) => q(cte),
      q(1896) => q(ctg),
      q(1897) => q(cth),
      q(1898) => q(ctl),
      q(1899) => q(ctm),
      q(1900) => q(ctn),
      q(1901) => q(cto),
      q(1902) => q(ctp),
      q(1903) => q(cts),
      q(1904) => q(ctt),
      q(1905) => q(ctu),
      q(1906) => q(ctz),
      q(1907) => q(cua),
      q(1908) => q(cub),
      q(1909) => q(cuc),
      q(1910) => q(cug),
      q(1911) => q(cuh),
      q(1912) => q(cui),
      q(1913) => q(cuj),
      q(1914) => q(cuk),
      q(1915) => q(cul),
      q(1916) => q(cum),
      q(1917) => q(cuo),
      q(1918) => q(cup),
      q(1919) => q(cuq),
      q(1920) => q(cur),
      q(1921) => q(cut),
      q(1922) => q(cuu),
      q(1923) => q(cuv),
      q(1924) => q(cuw),
      q(1925) => q(cux),
      q(1926) => q(cvg),
      q(1927) => q(cvn),
      q(1928) => q(cwa),
      q(1929) => q(cwb),
      q(1930) => q(cwd),
      q(1931) => q(cwe),
      q(1932) => q(cwg),
      q(1933) => q(cwt),
      q(1934) => q(cya),
      q(1935) => q(cyb),
      q(1936) => q(cyo),
      q(1937) => q(czh),
      q(1938) => q(czk),
      q(1939) => q(czn),
      q(1940) => q(czo),
      q(1941) => q(czt),
      q(1942) => q(daa),
      q(1943) => q(dac),
      q(1944) => q(dad),
      q(1945) => q(dae),
      q(1946) => q(dag),
      q(1947) => q(dah),
      q(1948) => q(dai),
      q(1949) => q(daj),
      q(1950) => q(dal),
      q(1951) => q(dam),
      q(1952) => q(dao),
      q(1953) => q(daq),
      q(1954) => q(das),
      q(1955) => q(dau),
      q(1956) => q(dav),
      q(1957) => q(daw),
      q(1958) => q(dax),
      q(1959) => q(daz),
      q(1960) => q(dba),
      q(1961) => q(dbb),
      q(1962) => q(dbd),
      q(1963) => q(dbe),
      q(1964) => q(dbf),
      q(1965) => q(dbg),
      q(1966) => q(dbi),
      q(1967) => q(dbj),
      q(1968) => q(dbl),
      q(1969) => q(dbm),
      q(1970) => q(dbn),
      q(1971) => q(dbo),
      q(1972) => q(dbp),
      q(1973) => q(dbq),
      q(1974) => q(dbr),
      q(1975) => q(dbt),
      q(1976) => q(dbu),
      q(1977) => q(dbv),
      q(1978) => q(dbw),
      q(1979) => q(dby),
      q(1980) => q(dcc),
      q(1981) => q(dcr),
      q(1982) => q(dda),
      q(1983) => q(ddd),
      q(1984) => q(dde),
      q(1985) => q(ddg),
      q(1986) => q(ddi),
      q(1987) => q(ddj),
      q(1988) => q(ddn),
      q(1989) => q(ddo),
      q(1990) => q(ddr),
      q(1991) => q(dds),
      q(1992) => q(ddw),
      q(1993) => q(dec),
      q(1994) => q(ded),
      q(1995) => q(dee),
      q(1996) => q(def),
      q(1997) => q(deg),
      q(1998) => q(deh),
      q(1999) => q(dei),
      q(2000) => q(dek),
      q(2001) => q(dem),
      q(2002) => q(dep),
      q(2003) => q(deq),
      q(2004) => q(der),
      q(2005) => q(des),
      q(2006) => q(dev),
      q(2007) => q(dez),
      q(2008) => q(dga),
      q(2009) => q(dgb),
      q(2010) => q(dgc),
      q(2011) => q(dgd),
      q(2012) => q(dge),
      q(2013) => q(dgg),
      q(2014) => q(dgh),
      q(2015) => q(dgi),
      q(2016) => q(dgk),
      q(2017) => q(dgl),
      q(2018) => q(dgn),
      q(2019) => q(dgo),
      q(2020) => q(dgs),
      q(2021) => q(dgt),
      q(2022) => q(dgu),
      q(2023) => q(dgw),
      q(2024) => q(dgx),
      q(2025) => q(dgz),
      q(2026) => q(dhd),
      q(2027) => q(dhg),
      q(2028) => q(dhi),
      q(2029) => q(dhl),
      q(2030) => q(dhm),
      q(2031) => q(dhn),
      q(2032) => q(dho),
      q(2033) => q(dhr),
      q(2034) => q(dhs),
      q(2035) => q(dhu),
      q(2036) => q(dhv),
      q(2037) => q(dhw),
      q(2038) => q(dhx),
      q(2039) => q(dia),
      q(2040) => q(dib),
      q(2041) => q(dic),
      q(2042) => q(did),
      q(2043) => q(dif),
      q(2044) => q(dig),
      q(2045) => q(dih),
      q(2046) => q(dii),
      q(2047) => q(dij),
      q(2048) => q(dik),
      q(2049) => q(dil),
      q(2050) => q(dim),
      q(2051) => q(dio),
      q(2052) => q(dip),
      q(2053) => q(diq),
      q(2054) => q(dir),
      q(2055) => q(dis),
      q(2056) => q(dit),
      q(2057) => q(diu),
      q(2058) => q(diw),
      q(2059) => q(dix),
      q(2060) => q(diy),
      q(2061) => q(diz),
      q(2062) => q(dja),
      q(2063) => q(djb),
      q(2064) => q(djc),
      q(2065) => q(djd),
      q(2066) => q(dje),
      q(2067) => q(djf),
      q(2068) => q(dji),
      q(2069) => q(djj),
      q(2070) => q(djk),
      q(2071) => q(djm),
      q(2072) => q(djn),
      q(2073) => q(djo),
      q(2074) => q(djr),
      q(2075) => q(dju),
      q(2076) => q(djw),
      q(2077) => q(dka),
      q(2078) => q(dkk),
      q(2079) => q(dkr),
      q(2080) => q(dks),
      q(2081) => q(dkx),
      q(2082) => q(dlg),
      q(2083) => q(dlk),
      q(2084) => q(dlm),
      q(2085) => q(dln),
      q(2086) => q(dma),
      q(2087) => q(dmb),
      q(2088) => q(dmc),
      q(2089) => q(dmd),
      q(2090) => q(dme),
      q(2091) => q(dmg),
      q(2092) => q(dmk),
      q(2093) => q(dml),
      q(2094) => q(dmm),
      q(2095) => q(dmo),
      q(2096) => q(dmr),
      q(2097) => q(dms),
      q(2098) => q(dmu),
      q(2099) => q(dmv),
      q(2100) => q(dmw),
      q(2101) => q(dmx),
      q(2102) => q(dmy),
      q(2103) => q(dna),
      q(2104) => q(dnd),
      q(2105) => q(dne),
      q(2106) => q(dng),
      q(2107) => q(dni),
      q(2108) => q(dnj),
      q(2109) => q(dnk),
      q(2110) => q(dnn),
      q(2111) => q(dnr),
      q(2112) => q(dnt),
      q(2113) => q(dnu),
      q(2114) => q(dnv),
      q(2115) => q(dnw),
      q(2116) => q(dny),
      q(2117) => q(doa),
      q(2118) => q(dob),
      q(2119) => q(doc),
      q(2120) => q(doe),
      q(2121) => q(dof),
      q(2122) => q(doh),
      q(2123) => q(dok),
      q(2124) => q(dol),
      q(2125) => q(don),
      q(2126) => q(doo),
      q(2127) => q(dop),
      q(2128) => q(doq),
      q(2129) => q(dor),
      q(2130) => q(dos),
      q(2131) => q(dot),
      q(2132) => q(dov),
      q(2133) => q(dow),
      q(2134) => q(dox),
      q(2135) => q(doy),
      q(2136) => q(doz),
      q(2137) => q(dpp),
      q(2138) => q(drb),
      q(2139) => q(drc),
      q(2140) => q(drd),
      q(2141) => q(dre),
      q(2142) => q(drg),
      q(2143) => q(dri),
      q(2144) => q(drl),
      q(2145) => q(drn),
      q(2146) => q(dro),
      q(2147) => q(drq),
      q(2148) => q(drr),
      q(2149) => q(drs),
      q(2150) => q(drt),
      q(2151) => q(dru),
      q(2152) => q(dry),
      q(2153) => q(dse),
      q(2154) => q(dsh),
      q(2155) => q(dsi),
      q(2156) => q(dsl),
      q(2157) => q(dsn),
      q(2158) => q(dso),
      q(2159) => q(dsq),
      q(2160) => q(dta),
      q(2161) => q(dtb),
      q(2162) => q(dtd),
      q(2163) => q(dth),
      q(2164) => q(dti),
      q(2165) => q(dtk),
      q(2166) => q(dtm),
      q(2167) => q(dto),
      q(2168) => q(dtp),
      q(2169) => q(dtr),
      q(2170) => q(dts),
      q(2171) => q(dtt),
      q(2172) => q(dtu),
      q(2173) => q(dty),
      q(2174) => q(dub),
      q(2175) => q(duc),
      q(2176) => q(dud),
      q(2177) => q(due),
      q(2178) => q(duf),
      q(2179) => q(dug),
      q(2180) => q(duh),
      q(2181) => q(dui),
      q(2182) => q(duj),
      q(2183) => q(duk),
      q(2184) => q(dul),
      q(2185) => q(dun),
      q(2186) => q(duo),
      q(2187) => q(dup),
      q(2188) => q(duq),
      q(2189) => q(dur),
      q(2190) => q(dus),
      q(2191) => q(duu),
      q(2192) => q(duv),
      q(2193) => q(duw),
      q(2194) => q(dux),
      q(2195) => q(duy),
      q(2196) => q(duz),
      q(2197) => q(dva),
      q(2198) => q(dwa),
      q(2199) => q(dwr),
      q(2200) => q(dws),
      q(2201) => q(dww),
      q(2202) => q(dya),
      q(2203) => q(dyb),
      q(2204) => q(dyd),
      q(2205) => q(dyg),
      q(2206) => q(dyi),
      q(2207) => q(dym),
      q(2208) => q(dyn),
      q(2209) => q(dyo),
      q(2210) => q(dyy),
      q(2211) => q(dza),
      q(2212) => q(dzd),
      q(2213) => q(dze),
      q(2214) => q(dzg),
      q(2215) => q(dzl),
      q(2216) => q(dzn),
      q(2217) => q(eaa),
      q(2218) => q(ebg),
      q(2219) => q(ebk),
      q(2220) => q(ebo),
      q(2221) => q(ebr),
      q(2222) => q(ebu),
      q(2223) => q(ecr),
      q(2224) => q(ecs),
      q(2225) => q(ecy),
      q(2226) => q(eee),
      q(2227) => q(efa),
      q(2228) => q(efe),
      q(2229) => q(ega),
      q(2230) => q(egl),
      q(2231) => q(ego),
      q(2232) => q(ehu),
      q(2233) => q(eip),
      q(2234) => q(eit),
      q(2235) => q(eiv),
      q(2236) => q(eja),
      q(2237) => q(ekc),
      q(2238) => q(eke),
      q(2239) => q(ekg),
      q(2240) => q(eki),
      q(2241) => q(ekk),
      q(2242) => q(ekl),
      q(2243) => q(ekm),
      q(2244) => q(eko),
      q(2245) => q(ekp),
      q(2246) => q(ekr),
      q(2247) => q(eky),
      q(2248) => q(ele),
      q(2249) => q(elh),
      q(2250) => q(eli),
      q(2251) => q(elk),
      q(2252) => q(elm),
      q(2253) => q(elo),
      q(2254) => q(elu),
      q(2255) => q(ema),
      q(2256) => q(emb),
      q(2257) => q(eme),
      q(2258) => q(emg),
      q(2259) => q(emi),
      q(2260) => q(emk),
      q(2261) => q(emm),
      q(2262) => q(emn),
      q(2263) => q(emo),
      q(2264) => q(emp),
      q(2265) => q(ems),
      q(2266) => q(emu),
      q(2267) => q(emw),
      q(2268) => q(emx),
      q(2269) => q(emy),
      q(2270) => q(ena),
      q(2271) => q(enb),
      q(2272) => q(enc),
      q(2273) => q(end),
      q(2274) => q(enf),
      q(2275) => q(enh),
      q(2276) => q(enn),
      q(2277) => q(eno),
      q(2278) => q(enq),
      q(2279) => q(enr),
      q(2280) => q(enu),
      q(2281) => q(env),
      q(2282) => q(enw),
      q(2283) => q(eot),
      q(2284) => q(epi),
      q(2285) => q(era),
      q(2286) => q(erg),
      q(2287) => q(erh),
      q(2288) => q(eri),
      q(2289) => q(erk),
      q(2290) => q(ero),
      q(2291) => q(err),
      q(2292) => q(ers),
      q(2293) => q(ert),
      q(2294) => q(erw),
      q(2295) => q(ese),
      q(2296) => q(esh),
      q(2297) => q(esi),
      q(2298) => q(esk),
      q(2299) => q(esl),
      q(2300) => q(esm),
      q(2301) => q(esn),
      q(2302) => q(eso),
      q(2303) => q(esq),
      q(2304) => q(ess),
      q(2305) => q(esu),
      q(2306) => q(etb),
      q(2307) => q(etc),
      q(2308) => q(eth),
      q(2309) => q(etn),
      q(2310) => q(eto),
      q(2311) => q(etr),
      q(2312) => q(ets),
      q(2313) => q(ett),
      q(2314) => q(etu),
      q(2315) => q(etx),
      q(2316) => q(etz),
      q(2317) => q(eve),
      q(2318) => q(evh),
      q(2319) => q(evn),
      q(2320) => q(ext),
      q(2321) => q(eya),
      q(2322) => q(eyo),
      q(2323) => q(eza),
      q(2324) => q(eze),
      q(2325) => q(faa),
      q(2326) => q(fab),
      q(2327) => q(fad),
      q(2328) => q(faf),
      q(2329) => q(fag),
      q(2330) => q(fah),
      q(2331) => q(fai),
      q(2332) => q(faj),
      q(2333) => q(fak),
      q(2334) => q(fal),
      q(2335) => q(fam),
      q(2336) => q(fap),
      q(2337) => q(far),
      q(2338) => q(fau),
      q(2339) => q(fax),
      q(2340) => q(fay),
      q(2341) => q(faz),
      q(2342) => q(fbl),
      q(2343) => q(fcs),
      q(2344) => q(fer),
      q(2345) => q(ffi),
      q(2346) => q(ffm),
      q(2347) => q(fgr),
      q(2348) => q(fia),
      q(2349) => q(fie),
      q(2350) => q(fip),
      q(2351) => q(fir),
      q(2352) => q(fit),
      q(2353) => q(fiw),
      q(2354) => q(fkk),
      q(2355) => q(fkv),
      q(2356) => q(fla),
      q(2357) => q(flh),
      q(2358) => q(fli),
      q(2359) => q(fll),
      q(2360) => q(fln),
      q(2361) => q(flr),
      q(2362) => q(fly),
      q(2363) => q(fmp),
      q(2364) => q(fmu),
      q(2365) => q(fng),
      q(2366) => q(fni),
      q(2367) => q(fod),
      q(2368) => q(foi),
      q(2369) => q(fom),
      q(2370) => q(for),
      q(2371) => q(fos),
      q(2372) => q(fpe),
      q(2373) => q(fqs),
      q(2374) => q(frc),
      q(2375) => q(frd),
      q(2376) => q(frk),
      q(2377) => q(frp),
      q(2378) => q(frq),
      q(2379) => q(frt),
      q(2380) => q(fse),
      q(2381) => q(fsl),
      q(2382) => q(fss),
      q(2383) => q(fub),
      q(2384) => q(fuc),
      q(2385) => q(fud),
      q(2386) => q(fue),
      q(2387) => q(fuf),
      q(2388) => q(fuh),
      q(2389) => q(fui),
      q(2390) => q(fuj),
      q(2391) => q(fum),
      q(2392) => q(fun),
      q(2393) => q(fuq),
      q(2394) => q(fut),
      q(2395) => q(fuu),
      q(2396) => q(fuv),
      q(2397) => q(fuy),
      q(2398) => q(fvr),
      q(2399) => q(fwa),
      q(2400) => q(fwe),
      q(2401) => q(gab),
      q(2402) => q(gac),
      q(2403) => q(gad),
      q(2404) => q(gae),
      q(2405) => q(gaf),
      q(2406) => q(gag),
      q(2407) => q(gah),
      q(2408) => q(gai),
      q(2409) => q(gaj),
      q(2410) => q(gak),
      q(2411) => q(gal),
      q(2412) => q(gam),
      q(2413) => q(gan),
      q(2414) => q(gao),
      q(2415) => q(gap),
      q(2416) => q(gaq),
      q(2417) => q(gar),
      q(2418) => q(gas),
      q(2419) => q(gat),
      q(2420) => q(gau),
      q(2421) => q(gaw),
      q(2422) => q(gax),
      q(2423) => q(gaz),
      q(2424) => q(gbb),
      q(2425) => q(gbd),
      q(2426) => q(gbe),
      q(2427) => q(gbf),
      q(2428) => q(gbg),
      q(2429) => q(gbh),
      q(2430) => q(gbi),
      q(2431) => q(gbj),
      q(2432) => q(gbk),
      q(2433) => q(gbl),
      q(2434) => q(gbm),
      q(2435) => q(gbn),
      q(2436) => q(gbo),
      q(2437) => q(gbp),
      q(2438) => q(gbq),
      q(2439) => q(gbr),
      q(2440) => q(gbs),
      q(2441) => q(gbu),
      q(2442) => q(gbv),
      q(2443) => q(gbw),
      q(2444) => q(gbx),
      q(2445) => q(gby),
      q(2446) => q(gbz),
      q(2447) => q(gcc),
      q(2448) => q(gcd),
      q(2449) => q(gce),
      q(2450) => q(gcf),
      q(2451) => q(gcl),
      q(2452) => q(gcn),
      q(2453) => q(gcr),
      q(2454) => q(gct),
      q(2455) => q(gda),
      q(2456) => q(gdb),
      q(2457) => q(gdc),
      q(2458) => q(gdd),
      q(2459) => q(gde),
      q(2460) => q(gdf),
      q(2461) => q(gdg),
      q(2462) => q(gdh),
      q(2463) => q(gdi),
      q(2464) => q(gdj),
      q(2465) => q(gdk),
      q(2466) => q(gdl),
      q(2467) => q(gdm),
      q(2468) => q(gdn),
      q(2469) => q(gdo),
      q(2470) => q(gdq),
      q(2471) => q(gdr),
      q(2472) => q(gds),
      q(2473) => q(gdt),
      q(2474) => q(gdu),
      q(2475) => q(gdx),
      q(2476) => q(gea),
      q(2477) => q(geb),
      q(2478) => q(gec),
      q(2479) => q(ged),
      q(2480) => q(geg),
      q(2481) => q(geh),
      q(2482) => q(gei),
      q(2483) => q(gej),
      q(2484) => q(gek),
      q(2485) => q(gel),
      q(2486) => q(geq),
      q(2487) => q(ges),
      q(2488) => q(gew),
      q(2489) => q(gex),
      q(2490) => q(gey),
      q(2491) => q(gfk),
      q(2492) => q(gft),
      q(2493) => q(gfx),
      q(2494) => q(gga),
      q(2495) => q(ggb),
      q(2496) => q(ggd),
      q(2497) => q(gge),
      q(2498) => q(ggg),
      q(2499) => q(ggk),
      q(2500) => q(ggl),
      q(2501) => q(ggn),
      q(2502) => q(ggo),
      q(2503) => q(ggt),
      q(2504) => q(ggu),
      q(2505) => q(ggw),
      q(2506) => q(gha),
      q(2507) => q(ghc),
      q(2508) => q(ghe),
      q(2509) => q(ghh),
      q(2510) => q(ghk),
      q(2511) => q(ghl),
      q(2512) => q(ghn),
      q(2513) => q(gho),
      q(2514) => q(ghr),
      q(2515) => q(ghs),
      q(2516) => q(ght),
      q(2517) => q(gia),
      q(2518) => q(gib),
      q(2519) => q(gic),
      q(2520) => q(gid),
      q(2521) => q(gig),
      q(2522) => q(gih),
      q(2523) => q(gim),
      q(2524) => q(gin),
      q(2525) => q(gip),
      q(2526) => q(giq),
      q(2527) => q(gir),
      q(2528) => q(gis),
      q(2529) => q(git),
      q(2530) => q(giu),
      q(2531) => q(giw),
      q(2532) => q(gix),
      q(2533) => q(giy),
      q(2534) => q(giz),
      q(2535) => q(gji),
      q(2536) => q(gjk),
      q(2537) => q(gjm),
      q(2538) => q(gjn),
      q(2539) => q(gju),
      q(2540) => q(gka),
      q(2541) => q(gke),
      q(2542) => q(gkn),
      q(2543) => q(gko),
      q(2544) => q(gkp),
      q(2545) => q(glc),
      q(2546) => q(gld),
      q(2547) => q(glh),
      q(2548) => q(gli),
      q(2549) => q(glj),
      q(2550) => q(glk),
      q(2551) => q(gll),
      q(2552) => q(glo),
      q(2553) => q(glr),
      q(2554) => q(glu),
      q(2555) => q(glw),
      q(2556) => q(gly),
      q(2557) => q(gma),
      q(2558) => q(gmb),
      q(2559) => q(gmd),
      q(2560) => q(gml),
      q(2561) => q(gmm),
      q(2562) => q(gmn),
      q(2563) => q(gmu),
      q(2564) => q(gmv),
      q(2565) => q(gmx),
      q(2566) => q(gmy),
      q(2567) => q(gmz),
      q(2568) => q(gna),
      q(2569) => q(gnb),
      q(2570) => q(gnc),
      q(2571) => q(gnd),
      q(2572) => q(gne),
      q(2573) => q(gng),
      q(2574) => q(gnh),
      q(2575) => q(gni),
      q(2576) => q(gnk),
      q(2577) => q(gnl),
      q(2578) => q(gnm),
      q(2579) => q(gnn),
      q(2580) => q(gno),
      q(2581) => q(gnq),
      q(2582) => q(gnr),
      q(2583) => q(gnt),
      q(2584) => q(gnu),
      q(2585) => q(gnw),
      q(2586) => q(gnz),
      q(2587) => q(goa),
      q(2588) => q(gob),
      q(2589) => q(goc),
      q(2590) => q(god),
      q(2591) => q(goe),
      q(2592) => q(gof),
      q(2593) => q(gog),
      q(2594) => q(goi),
      q(2595) => q(goj),
      q(2596) => q(gok),
      q(2597) => q(gol),
      q(2598) => q(gom),
      q(2599) => q(goo),
      q(2600) => q(gop),
      q(2601) => q(goq),
      q(2602) => q(gos),
      q(2603) => q(gou),
      q(2604) => q(gow),
      q(2605) => q(gox),
      q(2606) => q(goy),
      q(2607) => q(goz),
      q(2608) => q(gpa),
      q(2609) => q(gpe),
      q(2610) => q(gpn),
      q(2611) => q(gqa),
      q(2612) => q(gqi),
      q(2613) => q(gqn),
      q(2614) => q(gqr),
      q(2615) => q(gqu),
      q(2616) => q(gra),
      q(2617) => q(grd),
      q(2618) => q(grg),
      q(2619) => q(grh),
      q(2620) => q(gri),
      q(2621) => q(grj),
      q(2622) => q(grm),
      q(2623) => q(gro),
      q(2624) => q(grq),
      q(2625) => q(grr),
      q(2626) => q(grs),
      q(2627) => q(grt),
      q(2628) => q(gru),
      q(2629) => q(grv),
      q(2630) => q(grw),
      q(2631) => q(grx),
      q(2632) => q(gry),
      q(2633) => q(grz),
      q(2634) => q(gse),
      q(2635) => q(gsg),
      q(2636) => q(gsl),
      q(2637) => q(gsm),
      q(2638) => q(gsn),
      q(2639) => q(gso),
      q(2640) => q(gsp),
      q(2641) => q(gss),
      q(2642) => q(gta),
      q(2643) => q(gti),
      q(2644) => q(gtu),
      q(2645) => q(gua),
      q(2646) => q(gub),
      q(2647) => q(guc),
      q(2648) => q(gud),
      q(2649) => q(gue),
      q(2650) => q(guf),
      q(2651) => q(gug),
      q(2652) => q(guh),
      q(2653) => q(gui),
      q(2654) => q(guk),
      q(2655) => q(gul),
      q(2656) => q(gum),
      q(2657) => q(gun),
      q(2658) => q(guo),
      q(2659) => q(gup),
      q(2660) => q(yif),
      q(2661) => q(gur),
      q(2662) => q(gus),
      q(2663) => q(gut),
      q(2664) => q(guu),
      q(2665) => q(guv),
      q(2666) => q(guw),
      q(2667) => q(gux),
      q(2668) => q(guz),
      q(2669) => q(gva),
      q(2670) => q(gvc),
      q(2671) => q(gve),
      q(2672) => q(gvf),
      q(2673) => q(gvj),
      q(2674) => q(gvl),
      q(2675) => q(gvm),
      q(2676) => q(gvn),
      q(2677) => q(gvo),
      q(2678) => q(gvp),
      q(2679) => q(gvr),
      q(2680) => q(gvs),
      q(2681) => q(gvy),
      q(2682) => q(gwa),
      q(2683) => q(gwb),
      q(2684) => q(gwc),
      q(2685) => q(gwd),
      q(2686) => q(gwe),
      q(2687) => q(gwf),
      q(2688) => q(gwg),
      q(2689) => q(gwj),
      q(2690) => q(gwm),
      q(2691) => q(gwn),
      q(2692) => q(gwr),
      q(2693) => q(gwt),
      q(2694) => q(gwu),
      q(2695) => q(gww),
      q(2696) => q(gwx),
      q(2697) => q(gxx),
      q(2698) => q(gya),
      q(2699) => q(gyb),
      q(2700) => q(gyd),
      q(2701) => q(gye),
      q(2702) => q(gyf),
      q(2703) => q(gyg),
      q(2704) => q(gyi),
      q(2705) => q(gyl),
      q(2706) => q(gym),
      q(2707) => q(gyn),
      q(2708) => q(gyr),
      q(2709) => q(gyy),
      q(2710) => q(gza),
      q(2711) => q(gzi),
      q(2712) => q(gzn),
      q(2713) => q(haa),
      q(2714) => q(hab),
      q(2715) => q(hac),
      q(2716) => q(had),
      q(2717) => q(hae),
      q(2718) => q(haf),
      q(2719) => q(hag),
      q(2720) => q(hah),
      q(2721) => q(haj),
      q(2722) => q(hak),
      q(2723) => q(hal),
      q(2724) => q(ham),
      q(2725) => q(han),
      q(2726) => q(hao),
      q(2727) => q(hap),
      q(2728) => q(haq),
      q(2729) => q(har),
      q(2730) => q(has),
      q(2731) => q(hav),
      q(2732) => q(hax),
      q(2733) => q(hay),
      q(2734) => q(haz),
      q(2735) => q(hba),
      q(2736) => q(hbb),
      q(2737) => q(hbn),
      q(2738) => q(hbo),
      q(2739) => q(hbu),
      q(2740) => q(hca),
      q(2741) => q(hch),
      q(2742) => q(hdn),
      q(2743) => q(hds),
      q(2744) => q(hdy),
      q(2745) => q(hea),
      q(2746) => q(hed),
      q(2747) => q(heg),
      q(2748) => q(heh),
      q(2749) => q(hei),
      q(2750) => q(hem),
      q(2751) => q(hgm),
      q(2752) => q(hgw),
      q(2753) => q(hhi),
      q(2754) => q(hhr),
      q(2755) => q(hhy),
      q(2756) => q(hia),
      q(2757) => q(hib),
      q(2758) => q(hid),
      q(2759) => q(hif),
      q(2760) => q(hig),
      q(2761) => q(hih),
      q(2762) => q(hii),
      q(2763) => q(hij),
      q(2764) => q(hik),
      q(2765) => q(hio),
      q(2766) => q(hir),
      q(2767) => q(hiw),
      q(2768) => q(hix),
      q(2769) => q(hji),
      q(2770) => q(hka),
      q(2771) => q(hke),
      q(2772) => q(hkk),
      q(2773) => q(hks),
      q(2774) => q(hla),
      q(2775) => q(hlb),
      q(2776) => q(hld),
      q(2777) => q(hle),
      q(2778) => q(hlt),
      q(2779) => q(hlu),
      q(2780) => q(hma),
      q(2781) => q(hmb),
      q(2782) => q(hmc),
      q(2783) => q(hmd),
      q(2784) => q(hme),
      q(2785) => q(hmf),
      q(2786) => q(hmg),
      q(2787) => q(hmh),
      q(2788) => q(hmi),
      q(2789) => q(hmj),
      q(2790) => q(hmk),
      q(2791) => q(hml),
      q(2792) => q(hmm),
      q(2793) => q(hmp),
      q(2794) => q(hmq),
      q(2795) => q(hmr),
      q(2796) => q(hms),
      q(2797) => q(hmt),
      q(2798) => q(hmu),
      q(2799) => q(hmv),
      q(2800) => q(hmw),
      q(2801) => q(hmy),
      q(2802) => q(hmz),
      q(2803) => q(hna),
      q(2804) => q(hnd),
      q(2805) => q(hne),
      q(2806) => q(hnh),
      q(2807) => q(hni),
      q(2808) => q(hnj),
      q(2809) => q(hnn),
      q(2810) => q(hno),
      q(2811) => q(hns),
      q(2812) => q(hnu),
      q(2813) => q(hoa),
      q(2814) => q(hob),
      q(2815) => q(hoc),
      q(2816) => q(hod),
      q(2817) => q(hoe),
      q(2818) => q(hoh),
      q(2819) => q(hoi),
      q(2820) => q(hoj),
      q(2821) => q(hol),
      q(2822) => q(hom),
      q(2823) => q(hoo),
      q(2824) => q(hop),
      q(2825) => q(hor),
      q(2826) => q(hos),
      q(2827) => q(hot),
      q(2828) => q(hov),
      q(2829) => q(how),
      q(2830) => q(hoy),
      q(2831) => q(hoz),
      q(2832) => q(hpo),
      q(2833) => q(hps),
      q(2834) => q(hra),
      q(2835) => q(hrc),
      q(2836) => q(hre),
      q(2837) => q(hrk),
      q(2838) => q(hrm),
      q(2839) => q(hro),
      q(2840) => q(hrp),
      q(2841) => q(hrt),
      q(2842) => q(hru),
      q(2843) => q(hrw),
      q(2844) => q(hrx),
      q(2845) => q(hrz),
      q(2846) => q(hsh),
      q(2847) => q(hsl),
      q(2848) => q(hsn),
      q(2849) => q(hss),
      q(2850) => q(hti),
      q(2851) => q(hto),
      q(2852) => q(hts),
      q(2853) => q(htu),
      q(2854) => q(htx),
      q(2855) => q(hub),
      q(2856) => q(huc),
      q(2857) => q(hud),
      q(2858) => q(hue),
      q(2859) => q(huf),
      q(2860) => q(hug),
      q(2861) => q(huh),
      q(2862) => q(hui),
      q(2863) => q(huj),
      q(2864) => q(huk),
      q(2865) => q(hul),
      q(2866) => q(hum),
      q(2867) => q(huo),
      q(2868) => q(huq),
      q(2869) => q(hur),
      q(2870) => q(hus),
      q(2871) => q(hut),
      q(2872) => q(huu),
      q(2873) => q(huv),
      q(2874) => q(huw),
      q(2875) => q(hux),
      q(2876) => q(huy),
      q(2877) => q(huz),
      q(2878) => q(hvc),
      q(2879) => q(hve),
      q(2880) => q(hvk),
      q(2881) => q(hvn),
      q(2882) => q(hvv),
      q(2883) => q(hwa),
      q(2884) => q(hwc),
      q(2885) => q(hwo),
      q(2886) => q(hya),
      q(2887) => q(iai),
      q(2888) => q(ian),
      q(2889) => q(iap),
      q(2890) => q(iar),
      q(2891) => q(ibb),
      q(2892) => q(ibd),
      q(2893) => q(ibe),
      q(2894) => q(ibg),
      q(2895) => q(ibl),
      q(2896) => q(ibm),
      q(2897) => q(ibn),
      q(2898) => q(ibr),
      q(2899) => q(ibu),
      q(2900) => q(iby),
      q(2901) => q(ica),
      q(2902) => q(ich),
      q(2903) => q(icl),
      q(2904) => q(icr),
      q(2905) => q(ida),
      q(2906) => q(idb),
      q(2907) => q(idc),
      q(2908) => q(idd),
      q(2909) => q(ide),
      q(2910) => q(idi),
      q(2911) => q(idr),
      q(2912) => q(ids),
      q(2913) => q(idt),
      q(2914) => q(idu),
      q(2915) => q(ifa),
      q(2916) => q(ifb),
      q(2917) => q(ife),
      q(2918) => q(iff),
      q(2919) => q(ifk),
      q(2920) => q(ifm),
      q(2921) => q(ifu),
      q(2922) => q(ify),
      q(2923) => q(igb),
      q(2924) => q(ige),
      q(2925) => q(igg),
      q(2926) => q(igl),
      q(2927) => q(igm),
      q(2928) => q(ign),
      q(2929) => q(igo),
      q(2930) => q(igs),
      q(2931) => q(igw),
      q(2932) => q(ihb),
      q(2933) => q(ihi),
      q(2934) => q(ihp),
      q(2935) => q(ihw),
      q(2936) => q(iin),
      q(2937) => q(ijc),
      q(2938) => q(ije),
      q(2939) => q(ijj),
      q(2940) => q(ijn),
      q(2941) => q(ijs),
      q(2942) => q(ike),
      q(2943) => q(iki),
      q(2944) => q(ikk),
      q(2945) => q(ikl),
      q(2946) => q(iko),
      q(2947) => q(ikp),
      q(2948) => q(ikr),
      q(2949) => q(ikt),
      q(2950) => q(ikv),
      q(2951) => q(ikw),
      q(2952) => q(ikx),
      q(2953) => q(ikz),
      q(2954) => q(ila),
      q(2955) => q(ilb),
      q(2956) => q(ilg),
      q(2957) => q(ili),
      q(2958) => q(ilk),
      q(2959) => q(ill),
      q(2960) => q(ils),
      q(2961) => q(ilu),
      q(2962) => q(ilv),
      q(2963) => q(ima),
      q(2964) => q(ime),
      q(2965) => q(imi),
      q(2966) => q(iml),
      q(2967) => q(imn),
      q(2968) => q(imo),
      q(2969) => q(imr),
      q(2970) => q(ims),
      q(2971) => q(imy),
      q(2972) => q(inb),
      q(2973) => q(ing),
      q(2974) => q(inj),
      q(2975) => q(inl),
      q(2976) => q(inm),
      q(2977) => q(inn),
      q(2978) => q(ino),
      q(2979) => q(inp),
      q(2980) => q(ins),
      q(2981) => q(int),
      q(2982) => q(inz),
      q(2983) => q(ior),
      q(2984) => q(iou),
      q(2985) => q(iow),
      q(2986) => q(ipi),
      q(2987) => q(ipo),
      q(2988) => q(iqu),
      q(2989) => q(iqw),
      q(2990) => q(ire),
      q(2991) => q(irh),
      q(2992) => q(iri),
      q(2993) => q(irk),
      q(2994) => q(irn),
      q(2995) => q(irr),
      q(2996) => q(iru),
      q(2997) => q(irx),
      q(2998) => q(iry),
      q(2999) => q(isa),
      q(3000) => q(isc),
      q(3001) => q(isd),
      q(3002) => q(ise),
      q(3003) => q(isg),
      q(3004) => q(ish),
      q(3005) => q(isi),
      q(3006) => q(isk),
      q(3007) => q(ism),
      q(3008) => q(isn),
      q(3009) => q(iso),
      q(3010) => q(isr),
      q(3011) => q(ist),
      q(3012) => q(isu),
      q(3013) => q(itb),
      q(3014) => q(ite),
      q(3015) => q(iti),
      q(3016) => q(itk),
      q(3017) => q(itl),
      q(3018) => q(itm),
      q(3019) => q(ito),
      q(3020) => q(itr),
      q(3021) => q(its),
      q(3022) => q(itt),
      q(3023) => q(itv),
      q(3024) => q(itw),
      q(3025) => q(itx),
      q(3026) => q(ity),
      q(3027) => q(itz),
      q(3028) => q(ium),
      q(3029) => q(ivb),
      q(3030) => q(ivv),
      q(3031) => q(iwk),
      q(3032) => q(iwm),
      q(3033) => q(iwo),
      q(3034) => q(iws),
      q(3035) => q(ixc),
      q(3036) => q(ixl),
      q(3037) => q(iya),
      q(3038) => q(iyo),
      q(3039) => q(iyx),
      q(3040) => q(izh),
      q(3041) => q(izr),
      q(3042) => q(izz),
      q(3043) => q(jaa),
      q(3044) => q(jab),
      q(3045) => q(jac),
      q(3046) => q(jad),
      q(3047) => q(jae),
      q(3048) => q(jaf),
      q(3049) => q(jah),
      q(3050) => q(jaj),
      q(3051) => q(jak),
      q(3052) => q(jal),
      q(3053) => q(jam),
      q(3054) => q(jan),
      q(3055) => q(jao),
      q(3056) => q(jaq),
      q(3057) => q(jas),
      q(3058) => q(jat),
      q(3059) => q(jau),
      q(3060) => q(jax),
      q(3061) => q(jay),
      q(3062) => q(jaz),
      q(3063) => q(jbe),
      q(3064) => q(jbi),
      q(3065) => q(jbj),
      q(3066) => q(jbk),
      q(3067) => q(jbn),
      q(3068) => q(jbr),
      q(3069) => q(jbt),
      q(3070) => q(jbu),
      q(3071) => q(jbw),
      q(3072) => q(jcs),
      q(3073) => q(jct),
      q(3074) => q(jda),
      q(3075) => q(jdg),
      q(3076) => q(jdt),
      q(3077) => q(jeb),
      q(3078) => q(jee),
      q(3079) => q(jeg),
      q(3080) => q(jeh),
      q(3081) => q(jei),
      q(3082) => q(jek),
      q(3083) => q(jel),
      q(3084) => q(jen),
      q(3085) => q(jer),
      q(3086) => q(jet),
      q(3087) => q(jeu),
      q(3088) => q(jgb),
      q(3089) => q(jge),
      q(3090) => q(jgk),
      q(3091) => q(jgo),
      q(3092) => q(jhi),
      q(3093) => q(jhs),
      q(3094) => q(jia),
      q(3095) => q(jib),
      q(3096) => q(jic),
      q(3097) => q(jid),
      q(3098) => q(jie),
      q(3099) => q(jig),
      q(3100) => q(jih),
      q(3101) => q(jii),
      q(3102) => q(jil),
      q(3103) => q(jim),
      q(3104) => q(jio),
      q(3105) => q(jiq),
      q(3106) => q(jit),
      q(3107) => q(jiu),
      q(3108) => q(jiv),
      q(3109) => q(jiy),
      q(3110) => q(jjr),
      q(3111) => q(jkm),
      q(3112) => q(jko),
      q(3113) => q(jkp),
      q(3114) => q(jkr),
      q(3115) => q(jku),
      q(3116) => q(jle),
      q(3117) => q(jls),
      q(3118) => q(jma),
      q(3119) => q(jmb),
      q(3120) => q(jmc),
      q(3121) => q(jmd),
      q(3122) => q(jmi),
      q(3123) => q(jml),
      q(3124) => q(jmn),
      q(3125) => q(jmr),
      q(3126) => q(jms),
      q(3127) => q(jmw),
      q(3128) => q(jmx),
      q(3129) => q(jna),
      q(3130) => q(jnd),
      q(3131) => q(jng),
      q(3132) => q(jni),
      q(3133) => q(jnj),
      q(3134) => q(jnl),
      q(3135) => q(jns),
      q(3136) => q(job),
      q(3137) => q(jod),
      q(3138) => q(jor),
      q(3139) => q(jos),
      q(3140) => q(jow),
      q(3141) => q(jpa),
      q(3142) => q(jqr),
      q(3143) => q(jra),
      q(3144) => q(jrr),
      q(3145) => q(jrt),
      q(3146) => q(jru),
      q(3147) => q(jsl),
      q(3148) => q(jua),
      q(3149) => q(jub),
      q(3150) => q(juc),
      q(3151) => q(jud),
      q(3152) => q(juh),
      q(3153) => q(jui),
      q(3154) => q(juk),
      q(3155) => q(jul),
      q(3156) => q(jum),
      q(3157) => q(jun),
      q(3158) => q(juo),
      q(3159) => q(jup),
      q(3160) => q(jur),
      q(3161) => q(jus),
      q(3162) => q(jut),
      q(3163) => q(juu),
      q(3164) => q(juw),
      q(3165) => q(juy),
      q(3166) => q(jvd),
      q(3167) => q(jvn),
      q(3168) => q(jwi),
      q(3169) => q(jya),
      q(3170) => q(jye),
      q(3171) => q(jyy),
      q(3172) => q(kad),
      q(3173) => q(kae),
      q(3174) => q(kaf),
      q(3175) => q(kag),
      q(3176) => q(kah),
      q(3177) => q(kai),
      q(3178) => q(kaj),
      q(3179) => q(kak),
      q(3180) => q(kao),
      q(3181) => q(kap),
      q(3182) => q(kaq),
      q(3183) => q(kav),
      q(3184) => q(kax),
      q(3185) => q(kay),
      q(3186) => q(kba),
      q(3187) => q(kbb),
      q(3188) => q(kbc),
      q(3189) => q(kbe),
      q(3190) => q(kbf),
      q(3191) => q(kbg),
      q(3192) => q(kbh),
      q(3193) => q(kbi),
      q(3194) => q(kbj),
      q(3195) => q(kbk),
      q(3196) => q(kbl),
      q(3197) => q(kbm),
      q(3198) => q(kbn),
      q(3199) => q(kbo),
      q(3200) => q(kbp),
      q(3201) => q(kbq),
      q(3202) => q(kbr),
      q(3203) => q(kbs),
      q(3204) => q(kbt),
      q(3205) => q(kbu),
      q(3206) => q(kbv),
      q(3207) => q(kbw),
      q(3208) => q(kbx),
      q(3209) => q(kby),
      q(3210) => q(kbz),
      q(3211) => q(kca),
      q(3212) => q(kcb),
      q(3213) => q(kcc),
      q(3214) => q(kcd),
      q(3215) => q(kce),
      q(3216) => q(kcf),
      q(3217) => q(kcg),
      q(3218) => q(kch),
      q(3219) => q(kci),
      q(3220) => q(kcj),
      q(3221) => q(kck),
      q(3222) => q(kcl),
      q(3223) => q(kcm),
      q(3224) => q(kcn),
      q(3225) => q(kco),
      q(3226) => q(kcp),
      q(3227) => q(kcq),
      q(3228) => q(kcr),
      q(3229) => q(kcs),
      q(3230) => q(kct),
      q(3231) => q(kcu),
      q(3232) => q(kcv),
      q(3233) => q(kcw),
      q(3234) => q(kcx),
      q(3235) => q(kcy),
      q(3236) => q(kcz),
      q(3237) => q(kda),
      q(3238) => q(kdc),
      q(3239) => q(kdd),
      q(3240) => q(kde),
      q(3241) => q(kdf),
      q(3242) => q(kdg),
      q(3243) => q(kdh),
      q(3244) => q(kdi),
      q(3245) => q(kdj),
      q(3246) => q(kdk),
      q(3247) => q(kdl),
      q(3248) => q(kdm),
      q(3249) => q(kdn),
      q(3250) => q(kdp),
      q(3251) => q(kdq),
      q(3252) => q(kdr),
      q(3253) => q(kdt),
      q(3254) => q(kdu),
      q(3255) => q(kdw),
      q(3256) => q(kdx),
      q(3257) => q(kdy),
      q(3258) => q(kdz),
      q(3259) => q(kea),
      q(3260) => q(keb),
      q(3261) => q(kec),
      q(3262) => q(ked),
      q(3263) => q(kee),
      q(3264) => q(kef),
      q(3265) => q(keg),
      q(3266) => q(keh),
      q(3267) => q(kei),
      q(3268) => q(kej),
      q(3269) => q(kek),
      q(3270) => q(kel),
      q(3271) => q(kem),
      q(3272) => q(ken),
      q(3273) => q(keo),
      q(3274) => q(kep),
      q(3275) => q(keq),
      q(3276) => q(ker),
      q(3277) => q(kes),
      q(3278) => q(ket),
      q(3279) => q(keu),
      q(3280) => q(kev),
      q(3281) => q(kew),
      q(3282) => q(kex),
      q(3283) => q(key),
      q(3284) => q(kez),
      q(3285) => q(kfa),
      q(3286) => q(kfb),
      q(3287) => q(kfc),
      q(3288) => q(kfd),
      q(3289) => q(kfe),
      q(3290) => q(kff),
      q(3291) => q(kfg),
      q(3292) => q(kfh),
      q(3293) => q(kfi),
      q(3294) => q(kfj),
      q(3295) => q(kfk),
      q(3296) => q(kfl),
      q(3297) => q(kfm),
      q(3298) => q(kfn),
      q(3299) => q(kfo),
      q(3300) => q(kfp),
      q(3301) => q(kfq),
      q(3302) => q(kfr),
      q(3303) => q(kfs),
      q(3304) => q(kft),
      q(3305) => q(kfu),
      q(3306) => q(kfv),
      q(3307) => q(kfw),
      q(3308) => q(kfx),
      q(3309) => q(kfy),
      q(3310) => q(kfz),
      q(3311) => q(kga),
      q(3312) => q(kgb),
      q(3313) => q(kgc),
      q(3314) => q(kgd),
      q(3315) => q(kge),
      q(3316) => q(kgf),
      q(3317) => q(kgg),
      q(3318) => q(kgi),
      q(3319) => q(kgj),
      q(3320) => q(kgk),
      q(3321) => q(kgl),
      q(3322) => q(kuq),
      q(3323) => q(kgn),
      q(3324) => q(kgo),
      q(3325) => q(kgp),
      q(3326) => q(kgq),
      q(3327) => q(kgr),
      q(3328) => q(kgs),
      q(3329) => q(kgt),
      q(3330) => q(kgu),
      q(3331) => q(kgv),
      q(3332) => q(kgw),
      q(3333) => q(kgx),
      q(3334) => q(kgy),
      q(3335) => q(khb),
      q(3336) => q(khc),
      q(3337) => q(khd),
      q(3338) => q(khe),
      q(3339) => q(khf),
      q(3340) => q(khg),
      q(3341) => q(khh),
      q(3342) => q(khj),
      q(3343) => q(khk),
      q(3344) => q(khl),
      q(3345) => q(khn),
      q(3346) => q(khp),
      q(3347) => q(khq),
      q(3348) => q(khr),
      q(3349) => q(khs),
      q(3350) => q(kht),
      q(3351) => q(khu),
      q(3352) => q(khv),
      q(3353) => q(khw),
      q(3354) => q(khx),
      q(3355) => q(khy),
      q(3356) => q(khz),
      q(3357) => q(kia),
      q(3358) => q(kib),
      q(3359) => q(kic),
      q(3360) => q(kid),
      q(3361) => q(kie),
      q(3362) => q(kif),
      q(3363) => q(kig),
      q(3364) => q(kih),
      q(3365) => q(kii),
      q(3366) => q(kij),
      q(3367) => q(kil),
      q(3368) => q(kim),
      q(3369) => q(kio),
      q(3370) => q(kip),
      q(3371) => q(kiq),
      q(3372) => q(kis),
      q(3373) => q(kit),
      q(3374) => q(kiu),
      q(3375) => q(kiv),
      q(3376) => q(kiw),
      q(3377) => q(kix),
      q(3378) => q(kiy),
      q(3379) => q(kiz),
      q(3380) => q(kja),
      q(3381) => q(kjb),
      q(3382) => q(kjc),
      q(3383) => q(kjd),
      q(3384) => q(kje),
      q(3385) => q(kjf),
      q(3386) => q(kjg),
      q(3387) => q(kjh),
      q(3388) => q(kji),
      q(3389) => q(kjj),
      q(3390) => q(kjk),
      q(3391) => q(kjl),
      q(3392) => q(kjm),
      q(3393) => q(kjn),
      q(3394) => q(kjo),
      q(3395) => q(kjp),
      q(3396) => q(kjq),
      q(3397) => q(kjr),
      q(3398) => q(kjs),
      q(3399) => q(kjt),
      q(3400) => q(kju),
      q(3401) => q(kjx),
      q(3402) => q(kjy),
      q(3403) => q(kjz),
      q(3404) => q(kka),
      q(3405) => q(kkb),
      q(3406) => q(kkc),
      q(3407) => q(kkd),
      q(3408) => q(kke),
      q(3409) => q(kkf),
      q(3410) => q(kkg),
      q(3411) => q(kkh),
      q(3412) => q(kki),
      q(3413) => q(kkj),
      q(3414) => q(kkk),
      q(3415) => q(kkl),
      q(3416) => q(kkm),
      q(3417) => q(kkn),
      q(3418) => q(kko),
      q(3419) => q(kkp),
      q(3420) => q(kkq),
      q(3421) => q(kkr),
      q(3422) => q(kks),
      q(3423) => q(kkt),
      q(3424) => q(kku),
      q(3425) => q(kkv),
      q(3426) => q(kkw),
      q(3427) => q(kkx),
      q(3428) => q(kky),
      q(3429) => q(kkz),
      q(3430) => q(kla),
      q(3431) => q(klb),
      q(3432) => q(klc),
      q(3433) => q(kld),
      q(3434) => q(kle),
      q(3435) => q(klf),
      q(3436) => q(klg),
      q(3437) => q(klh),
      q(3438) => q(kli),
      q(3439) => q(klj),
      q(3440) => q(klk),
      q(3441) => q(kll),
      q(3442) => q(klm),
      q(3443) => q(kln),
      q(3444) => q(klo),
      q(3445) => q(klp),
      q(3446) => q(klq),
      q(3447) => q(klr),
      q(3448) => q(kls),
      q(3449) => q(klt),
      q(3450) => q(klu),
      q(3451) => q(klv),
      q(3452) => q(klw),
      q(3453) => q(klx),
      q(3454) => q(kly),
      q(3455) => q(klz),
      q(3456) => q(kma),
      q(3457) => q(kmc),
      q(3458) => q(kmd),
      q(3459) => q(kme),
      q(3460) => q(kmf),
      q(3461) => q(kmg),
      q(3462) => q(kmh),
      q(3463) => q(kmi),
      q(3464) => q(kmj),
      q(3465) => q(kmk),
      q(3466) => q(kml),
      q(3467) => q(kmm),
      q(3468) => q(kmn),
      q(3469) => q(kmo),
      q(3470) => q(kmp),
      q(3471) => q(kmq),
      q(3472) => q(kmr),
      q(3473) => q(kms),
      q(3474) => q(kmt),
      q(3475) => q(kmu),
      q(3476) => q(kmv),
      q(3477) => q(kmw),
      q(3478) => q(kmx),
      q(3479) => q(kmy),
      q(3480) => q(kmz),
      q(3481) => q(kna),
      q(3482) => q(knb),
      q(3483) => q(knc),
      q(3484) => q(knd),
      q(3485) => q(kne),
      q(3486) => q(knf),
      q(3487) => q(kng),
      q(3488) => q(kni),
      q(3489) => q(knj),
      q(3490) => q(knk),
      q(3491) => q(knl),
      q(3492) => q(knm),
      q(3493) => q(knn),
      q(3494) => q(kno),
      q(3495) => q(knp),
      q(3496) => q(knq),
      q(3497) => q(knr),
      q(3498) => q(kns),
      q(3499) => q(knt),
      q(3500) => q(knu),
      q(3501) => q(knv),
      q(3502) => q(knw),
      q(3503) => q(knx),
      q(3504) => q(kny),
      q(3505) => q(knz),
      q(3506) => q(koa),
      q(3507) => q(koc),
      q(3508) => q(kod),
      q(3509) => q(koe),
      q(3510) => q(kof),
      q(3511) => q(kog),
      q(3512) => q(koh),
      q(3513) => q(koi),
      q(3514) => q(koj),
      q(3515) => q(kol),
      q(3516) => q(koo),
      q(3517) => q(kop),
      q(3518) => q(koq),
      q(3519) => q(kot),
      q(3520) => q(kou),
      q(3521) => q(kov),
      q(3522) => q(kow),
      q(3523) => q(kox),
      q(3524) => q(koy),
      q(3525) => q(koz),
      q(3526) => q(kpa),
      q(3527) => q(kpb),
      q(3528) => q(kpc),
      q(3529) => q(kpd),
      q(3530) => q(kpf),
      q(3531) => q(kpg),
      q(3532) => q(kph),
      q(3533) => q(kpi),
      q(3534) => q(kpj),
      q(3535) => q(kpk),
      q(3536) => q(kpl),
      q(3537) => q(kpm),
      q(3538) => q(kpn),
      q(3539) => q(kpo),
      q(3540) => q(kpq),
      q(3541) => q(kpr),
      q(3542) => q(kps),
      q(3543) => q(kpt),
      q(3544) => q(kpu),
      q(3545) => q(kpv),
      q(3546) => q(kpw),
      q(3547) => q(kpx),
      q(3548) => q(kpy),
      q(3549) => q(kpz),
      q(3550) => q(kqa),
      q(3551) => q(kqb),
      q(3552) => q(kqc),
      q(3553) => q(kqd),
      q(3554) => q(kqe),
      q(3555) => q(kqf),
      q(3556) => q(kqg),
      q(3557) => q(kqh),
      q(3558) => q(kqi),
      q(3559) => q(kqj),
      q(3560) => q(kqk),
      q(3561) => q(kql),
      q(3562) => q(kqm),
      q(3563) => q(kqn),
      q(3564) => q(kqo),
      q(3565) => q(kqp),
      q(3566) => q(kqq),
      q(3567) => q(kqr),
      q(3568) => q(kqs),
      q(3569) => q(kqt),
      q(3570) => q(kqu),
      q(3571) => q(kqv),
      q(3572) => q(kqw),
      q(3573) => q(kqx),
      q(3574) => q(kqy),
      q(3575) => q(kqz),
      q(3576) => q(kra),
      q(3577) => q(krb),
      q(3578) => q(krd),
      q(3579) => q(kre),
      q(3580) => q(krf),
      q(3581) => q(krh),
      q(3582) => q(kri),
      q(3583) => q(krj),
      q(3584) => q(krk),
      q(3585) => q(krm),
      q(3586) => q(krn),
      q(3587) => q(krp),
      q(3588) => q(krr),
      q(3589) => q(krs),
      q(3590) => q(krt),
      q(3591) => q(krv),
      q(3592) => q(krw),
      q(3593) => q(krx),
      q(3594) => q(kry),
      q(3595) => q(krz),
      q(3596) => q(ksa),
      q(3597) => q(ksb),
      q(3598) => q(ksc),
      q(3599) => q(ksd),
      q(3600) => q(kse),
      q(3601) => q(ksf),
      q(3602) => q(ksg),
      q(3603) => q(ksh),
      q(3604) => q(ksi),
      q(3605) => q(ksj),
      q(3606) => q(ksk),
      q(3607) => q(ksl),
      q(3608) => q(ksm),
      q(3609) => q(ksn),
      q(3610) => q(kso),
      q(3611) => q(ksp),
      q(3612) => q(ksq),
      q(3613) => q(ksr),
      q(3614) => q(kss),
      q(3615) => q(kst),
      q(3616) => q(ksu),
      q(3617) => q(ksv),
      q(3618) => q(ksw),
      q(3619) => q(ksx),
      q(3620) => q(ksy),
      q(3621) => q(ksz),
      q(3622) => q(kta),
      q(3623) => q(ktb),
      q(3624) => q(ktc),
      q(3625) => q(ktd),
      q(3626) => q(kte),
      q(3627) => q(ktf),
      q(3628) => q(ktg),
      q(3629) => q(kth),
      q(3630) => q(kti),
      q(3631) => q(ktj),
      q(3632) => q(ktk),
      q(3633) => q(ktl),
      q(3634) => q(ktm),
      q(3635) => q(ktn),
      q(3636) => q(kto),
      q(3637) => q(ktp),
      q(3638) => q(ktq),
      q(3639) => q(ktr),
      q(3640) => q(kts),
      q(3641) => q(ktt),
      q(3642) => q(ktu),
      q(3643) => q(ktv),
      q(3644) => q(ktw),
      q(3645) => q(ktx),
      q(3646) => q(kty),
      q(3647) => q(ktz),
      q(3648) => q(kub),
      q(3649) => q(kuc),
      q(3650) => q(kud),
      q(3651) => q(kue),
      q(3652) => q(kuf),
      q(3653) => q(kug),
      q(3654) => q(kuh),
      q(3655) => q(kui),
      q(3656) => q(kuj),
      q(3657) => q(kuk),
      q(3658) => q(kul),
      q(3659) => q(kun),
      q(3660) => q(kuo),
      q(3661) => q(kup),
      q(3662) => q(kus),
      q(3663) => q(kuu),
      q(3664) => q(kuv),
      q(3665) => q(kuw),
      q(3666) => q(kux),
      q(3667) => q(kuy),
      q(3668) => q(kuz),
      q(3669) => q(kva),
      q(3670) => q(kvb),
      q(3671) => q(kvc),
      q(3672) => q(kvd),
      q(3673) => q(kve),
      q(3674) => q(kvf),
      q(3675) => q(kvg),
      q(3676) => q(kvh),
      q(3677) => q(kvi),
      q(3678) => q(kvj),
      q(3679) => q(kvk),
      q(3680) => q(kvl),
      q(3681) => q(kvm),
      q(3682) => q(kvn),
      q(3683) => q(kvo),
      q(3684) => q(kvp),
      q(3685) => q(kvq),
      q(3686) => q(kvr),
      q(3687) => q(kvs),
      q(3688) => q(kvt),
      q(3689) => q(kvu),
      q(3690) => q(kvv),
      q(3691) => q(kvw),
      q(3692) => q(kvx),
      q(3693) => q(kvy),
      q(3694) => q(kvz),
      q(3695) => q(kwa),
      q(3696) => q(kwb),
      q(3697) => q(kwc),
      q(3698) => q(kwd),
      q(3699) => q(kwe),
      q(3700) => q(kwf),
      q(3701) => q(kwg),
      q(3702) => q(kwh),
      q(3703) => q(kwi),
      q(3704) => q(kwj),
      q(3705) => q(kwk),
      q(3706) => q(kwl),
      q(3707) => q(kwm),
      q(3708) => q(kwn),
      q(3709) => q(kwo),
      q(3710) => q(kwp),
      q(3711) => q(kwq),
      q(3712) => q(kwr),
      q(3713) => q(kws),
      q(3714) => q(kwt),
      q(3715) => q(kwu),
      q(3716) => q(kwv),
      q(3717) => q(kww),
      q(3718) => q(kwx),
      q(3719) => q(kwy),
      q(3720) => q(kwz),
      q(3721) => q(kxa),
      q(3722) => q(kxb),
      q(3723) => q(kxc),
      q(3724) => q(kxd),
      q(3725) => q(kxe),
      q(3726) => q(kxf),
      q(3727) => q(kxh),
      q(3728) => q(kxi),
      q(3729) => q(kxj),
      q(3730) => q(kxk),
      q(3731) => q(kxl),
      q(3732) => q(kxm),
      q(3733) => q(kxn),
      q(3734) => q(kxo),
      q(3735) => q(kxp),
      q(3736) => q(kxq),
      q(3737) => q(kxr),
      q(3738) => q(kxs),
      q(3739) => q(kxt),
      q(3740) => q(kxu),
      q(3741) => q(kxv),
      q(3742) => q(kxw),
      q(3743) => q(kxx),
      q(3744) => q(kxy),
      q(3745) => q(kxz),
      q(3746) => q(kya),
      q(3747) => q(kyb),
      q(3748) => q(kyc),
      q(3749) => q(kyd),
      q(3750) => q(kye),
      q(3751) => q(kyf),
      q(3752) => q(kyg),
      q(3753) => q(kyh),
      q(3754) => q(kyi),
      q(3755) => q(kyj),
      q(3756) => q(kyk),
      q(3757) => q(kyl),
      q(3758) => q(kym),
      q(3759) => q(kyn),
      q(3760) => q(kyo),
      q(3761) => q(kyp),
      q(3762) => q(kyq),
      q(3763) => q(kyr),
      q(3764) => q(kys),
      q(3765) => q(kyt),
      q(3766) => q(kyu),
      q(3767) => q(kyv),
      q(3768) => q(kyw),
      q(3769) => q(kyx),
      q(3770) => q(kyy),
      q(3771) => q(kyz),
      q(3772) => q(kza),
      q(3773) => q(kzb),
      q(3774) => q(kzc),
      q(3775) => q(kzd),
      q(3776) => q(kze),
      q(3777) => q(kzf),
      q(3778) => q(kzg),
      q(3779) => q(kzi),
      q(3780) => q(kzj),
      q(3781) => q(kzk),
      q(3782) => q(kzl),
      q(3783) => q(kzm),
      q(3784) => q(kzn),
      q(3785) => q(kzo),
      q(3786) => q(kzp),
      q(3787) => q(kzq),
      q(3788) => q(kzr),
      q(3789) => q(kzs),
      q(3790) => q(kzt),
      q(3791) => q(kzu),
      q(3792) => q(kzv),
      q(3793) => q(kzw),
      q(3794) => q(kzx),
      q(3795) => q(kzy),
      q(3796) => q(kzz),
      q(3797) => q(laa),
      q(3798) => q(lab),
      q(3799) => q(lac),
      q(3800) => q(lae),
      q(3801) => q(laf),
      q(3802) => q(lag),
      q(3803) => q(lai),
      q(3804) => q(laj),
      q(3805) => q(lak),
      q(3806) => q(lal),
      q(3807) => q(lan),
      q(3808) => q(lap),
      q(3809) => q(laq),
      q(3810) => q(lar),
      q(3811) => q(las),
      q(3812) => q(lau),
      q(3813) => q(law),
      q(3814) => q(lax),
      q(3815) => q(lay),
      q(3816) => q(laz),
      q(3817) => q(lba),
      q(3818) => q(lbb),
      q(3819) => q(lbc),
      q(3820) => q(lbe),
      q(3821) => q(lbf),
      q(3822) => q(lbg),
      q(3823) => q(lbi),
      q(3824) => q(lbj),
      q(3825) => q(lbk),
      q(3826) => q(lbl),
      q(3827) => q(lbm),
      q(3828) => q(lbn),
      q(3829) => q(lbo),
      q(3830) => q(lbq),
      q(3831) => q(lbr),
      q(3832) => q(lbs),
      q(3833) => q(lbt),
      q(3834) => q(lbu),
      q(3835) => q(lbv),
      q(3836) => q(lbw),
      q(3837) => q(lbx),
      q(3838) => q(lby),
      q(3839) => q(lbz),
      q(3840) => q(lcc),
      q(3841) => q(lcd),
      q(3842) => q(lce),
      q(3843) => q(lcf),
      q(3844) => q(lch),
      q(3845) => q(lcl),
      q(3846) => q(lcm),
      q(3847) => q(lcp),
      q(3848) => q(lcq),
      q(3849) => q(lcs),
      q(3850) => q(lda),
      q(3851) => q(ldb),
      q(3852) => q(ldd),
      q(3853) => q(ldg),
      q(3854) => q(ldh),
      q(3855) => q(ldi),
      q(3856) => q(ldj),
      q(3857) => q(ldk),
      q(3858) => q(ldl),
      q(3859) => q(ldm),
      q(3860) => q(ldn),
      q(3861) => q(ldo),
      q(3862) => q(ldp),
      q(3863) => q(ldq),
      q(3864) => q(lea),
      q(3865) => q(leb),
      q(3866) => q(lec),
      q(3867) => q(led),
      q(3868) => q(lee),
      q(3869) => q(lef),
      q(3870) => q(leg),
      q(3871) => q(leh),
      q(3872) => q(lei),
      q(3873) => q(lej),
      q(3874) => q(lek),
      q(3875) => q(lel),
      q(3876) => q(lem),
      q(3877) => q(len),
      q(3878) => q(leo),
      q(3879) => q(lep),
      q(3880) => q(leq),
      q(3881) => q(ler),
      q(3882) => q(les),
      q(3883) => q(let),
      q(3884) => q(leu),
      q(3885) => q(lev),
      q(3886) => q(lew),
      q(3887) => q(lex),
      q(3888) => q(ley),
      q(3889) => q(lfa),
      q(3890) => q(lfn),
      q(3891) => q(lga),
      q(3892) => q(lgb),
      q(3893) => q(lgg),
      q(3894) => q(lgh),
      q(3895) => q(lgi),
      q(3896) => q(lgk),
      q(3897) => q(lgl),
      q(3898) => q(lgm),
      q(3899) => q(lgn),
      q(3900) => q(lgq),
      q(3901) => q(lgr),
      q(3902) => q(lgt),
      q(3903) => q(lgu),
      q(3904) => q(lgz),
      q(3905) => q(lha),
      q(3906) => q(lhh),
      q(3907) => q(lhi),
      q(3908) => q(lhl),
      q(3909) => q(lhm),
      q(3910) => q(lhn),
      q(3911) => q(lhp),
      q(3912) => q(lhs),
      q(3913) => q(lht),
      q(3914) => q(lhu),
      q(3915) => q(lia),
      q(3916) => q(lib),
      q(3917) => q(lic),
      q(3918) => q(lid),
      q(3919) => q(lie),
      q(3920) => q(lif),
      q(3921) => q(lig),
      q(3922) => q(lih),
      q(3923) => q(lii),
      q(3924) => q(lij),
      q(3925) => q(lik),
      q(3926) => q(lil),
      q(3927) => q(lio),
      q(3928) => q(lip),
      q(3929) => q(liq),
      q(3930) => q(lir),
      q(3931) => q(lis),
      q(3932) => q(liu),
      q(3933) => q(liv),
      q(3934) => q(liw),
      q(3935) => q(lix),
      q(3936) => q(liy),
      q(3937) => q(liz),
      q(3938) => q(lja),
      q(3939) => q(lje),
      q(3940) => q(lji),
      q(3941) => q(ljl),
      q(3942) => q(ljp),
      q(3943) => q(ljw),
      q(3944) => q(ljx),
      q(3945) => q(lka),
      q(3946) => q(lkb),
      q(3947) => q(lkc),
      q(3948) => q(lkd),
      q(3949) => q(lke),
      q(3950) => q(lkh),
      q(3951) => q(lki),
      q(3952) => q(lkj),
      q(3953) => q(lkl),
      q(3954) => q(lkm),
      q(3955) => q(lkn),
      q(3956) => q(lko),
      q(3957) => q(lkr),
      q(3958) => q(lks),
      q(3959) => q(lkt),
      q(3960) => q(lku),
      q(3961) => q(lky),
      q(3962) => q(lla),
      q(3963) => q(llb),
      q(3964) => q(llc),
      q(3965) => q(lld),
      q(3966) => q(lle),
      q(3967) => q(llf),
      q(3968) => q(llg),
      q(3969) => q(llh),
      q(3970) => q(lli),
      q(3971) => q(llj),
      q(3972) => q(llk),
      q(3973) => q(lll),
      q(3974) => q(llm),
      q(3975) => q(lln),
      q(3976) => q(llo),
      q(3977) => q(llp),
      q(3978) => q(llq),
      q(3979) => q(lls),
      q(3980) => q(llu),
      q(3981) => q(llx),
      q(3982) => q(lma),
      q(3983) => q(lmb),
      q(3984) => q(lmc),
      q(3985) => q(lmd),
      q(3986) => q(lme),
      q(3987) => q(lmf),
      q(3988) => q(lmg),
      q(3989) => q(lmh),
      q(3990) => q(lmi),
      q(3991) => q(lmj),
      q(3992) => q(lmk),
      q(3993) => q(lml),
      q(3994) => q(lmm),
      q(3995) => q(lmn),
      q(3996) => q(lmo),
      q(3997) => q(lmp),
      q(3998) => q(lmq),
      q(3999) => q(lmr),
      q(4000) => q(lmu),
      q(4001) => q(lmv),
      q(4002) => q(lmw),
      q(4003) => q(lmx),
      q(4004) => q(lmy),
      q(4005) => q(lmz),
      q(4006) => q(lna),
      q(4007) => q(lnb),
      q(4008) => q(lnd),
      q(4009) => q(lng),
      q(4010) => q(lnh),
      q(4011) => q(lni),
      q(4012) => q(lnj),
      q(4013) => q(lnl),
      q(4014) => q(lnm),
      q(4015) => q(lnn),
      q(4016) => q(lno),
      q(4017) => q(lns),
      q(4018) => q(lnu),
      q(4019) => q(lnw),
      q(4020) => q(lnz),
      q(4021) => q(loa),
      q(4022) => q(lob),
      q(4023) => q(loc),
      q(4024) => q(loe),
      q(4025) => q(lof),
      q(4026) => q(log),
      q(4027) => q(loh),
      q(4028) => q(loi),
      q(4029) => q(loj),
      q(4030) => q(lok),
      q(4031) => q(lom),
      q(4032) => q(lon),
      q(4033) => q(loo),
      q(4034) => q(lop),
      q(4035) => q(loq),
      q(4036) => q(lor),
      q(4037) => q(los),
      q(4038) => q(lot),
      q(4039) => q(lou),
      q(4040) => q(lov),
      q(4041) => q(low),
      q(4042) => q(lox),
      q(4043) => q(loy),
      q(4044) => q(lpa),
      q(4045) => q(lpe),
      q(4046) => q(lpn),
      q(4047) => q(lpo),
      q(4048) => q(lpx),
      q(4049) => q(lra),
      q(4050) => q(lrc),
      q(4051) => q(lre),
      q(4052) => q(lrg),
      q(4053) => q(lri),
      q(4054) => q(lrk),
      q(4055) => q(lrl),
      q(4056) => q(lrm),
      q(4057) => q(lrn),
      q(4058) => q(lro),
      q(4059) => q(lrr),
      q(4060) => q(lrt),
      q(4061) => q(lrv),
      q(4062) => q(lrz),
      q(4063) => q(lsa),
      q(4064) => q(lsd),
      q(4065) => q(lse),
      q(4066) => q(lsg),
      q(4067) => q(lsh),
      q(4068) => q(lsi),
      q(4069) => q(lsl),
      q(4070) => q(lsm),
      q(4071) => q(lso),
      q(4072) => q(lsp),
      q(4073) => q(lsr),
      q(4074) => q(lss),
      q(4075) => q(lst),
      q(4076) => q(lsy),
      q(4077) => q(ltc),
      q(4078) => q(ltg),
      q(4079) => q(lti),
      q(4080) => q(ltn),
      q(4081) => q(lto),
      q(4082) => q(lts),
      q(4083) => q(ltu),
      q(4084) => q(luc),
      q(4085) => q(lud),
      q(4086) => q(lue),
      q(4087) => q(luf),
      q(4088) => q(luj),
      q(4089) => q(luk),
      q(4090) => q(lul),
      q(4091) => q(lum),
      q(4092) => q(lup),
      q(4093) => q(luq),
      q(4094) => q(lur),
      q(4095) => q(lut),
      q(4096) => q(luu),
      q(4097) => q(luv),
      q(4098) => q(luw),
      q(4099) => q(luy),
      q(4100) => q(luz),
      q(4101) => q(lva),
      q(4102) => q(lvk),
      q(4103) => q(lvs),
      q(4104) => q(lvu),
      q(4105) => q(lwa),
      q(4106) => q(lwe),
      q(4107) => q(lwg),
      q(4108) => q(lwh),
      q(4109) => q(lwl),
      q(4110) => q(lwm),
      q(4111) => q(lwo),
      q(4112) => q(lwt),
      q(4113) => q(lwu),
      q(4114) => q(lww),
      q(4115) => q(lya),
      q(4116) => q(lyg),
      q(4117) => q(lyn),
      q(4118) => q(lzh),
      q(4119) => q(lzl),
      q(4120) => q(lzn),
      q(4121) => q(lzz),
      q(4122) => q(maa),
      q(4123) => q(mab),
      q(4124) => q(mae),
      q(4125) => q(maf),
      q(4126) => q(maj),
      q(4127) => q(mam),
      q(4128) => q(maq),
      q(4129) => q(mat),
      q(4130) => q(mau),
      q(4131) => q(mav),
      q(4132) => q(maw),
      q(4133) => q(max),
      q(4134) => q(maz),
      q(4135) => q(mba),
      q(4136) => q(mbb),
      q(4137) => q(mbc),
      q(4138) => q(mbd),
      q(4139) => q(mbe),
      q(4140) => q(mbf),
      q(4141) => q(mbh),
      q(4142) => q(mbi),
      q(4143) => q(mbj),
      q(4144) => q(mbk),
      q(4145) => q(mbl),
      q(4146) => q(mbm),
      q(4147) => q(mbn),
      q(4148) => q(mbo),
      q(4149) => q(mbp),
      q(4150) => q(mbq),
      q(4151) => q(mbr),
      q(4152) => q(mbs),
      q(4153) => q(mbt),
      q(4154) => q(mbu),
      q(4155) => q(mbv),
      q(4156) => q(mbw),
      q(4157) => q(mbx),
      q(4158) => q(mby),
      q(4159) => q(mbz),
      q(4160) => q(mca),
      q(4161) => q(mcb),
      q(4162) => q(mcc),
      q(4163) => q(mcd),
      q(4164) => q(mce),
      q(4165) => q(mcf),
      q(4166) => q(mcg),
      q(4167) => q(mch),
      q(4168) => q(mci),
      q(4169) => q(mcj),
      q(4170) => q(mck),
      q(4171) => q(mcl),
      q(4172) => q(mcm),
      q(4173) => q(mcn),
      q(4174) => q(mco),
      q(4175) => q(mcp),
      q(4176) => q(mcq),
      q(4177) => q(mcr),
      q(4178) => q(mcs),
      q(4179) => q(mct),
      q(4180) => q(mcu),
      q(4181) => q(mcv),
      q(4182) => q(mcw),
      q(4183) => q(mcx),
      q(4184) => q(mcy),
      q(4185) => q(mcz),
      q(4186) => q(mda),
      q(4187) => q(mdb),
      q(4188) => q(mdc),
      q(4189) => q(mdd),
      q(4190) => q(mde),
      q(4191) => q(mdg),
      q(4192) => q(mdh),
      q(4193) => q(mdi),
      q(4194) => q(mdj),
      q(4195) => q(mdk),
      q(4196) => q(mdl),
      q(4197) => q(mdm),
      q(4198) => q(mdn),
      q(4199) => q(mdp),
      q(4200) => q(mdq),
      q(4201) => q(mds),
      q(4202) => q(mdt),
      q(4203) => q(mdu),
      q(4204) => q(mdv),
      q(4205) => q(mdw),
      q(4206) => q(mdx),
      q(4207) => q(mdy),
      q(4208) => q(mdz),
      q(4209) => q(mea),
      q(4210) => q(meb),
      q(4211) => q(mec),
      q(4212) => q(med),
      q(4213) => q(mee),
      q(4214) => q(mef),
      q(4215) => q(meh),
      q(4216) => q(mei),
      q(4217) => q(mej),
      q(4218) => q(mek),
      q(4219) => q(mel),
      q(4220) => q(mem),
      q(4221) => q(meo),
      q(4222) => q(mep),
      q(4223) => q(meq),
      q(4224) => q(mer),
      q(4225) => q(mes),
      q(4226) => q(met),
      q(4227) => q(meu),
      q(4228) => q(mev),
      q(4229) => q(mew),
      q(4230) => q(mey),
      q(4231) => q(mez),
      q(4232) => q(mfa),
      q(4233) => q(mfb),
      q(4234) => q(mfc),
      q(4235) => q(mfd),
      q(4236) => q(mfe),
      q(4237) => q(mff),
      q(4238) => q(mfg),
      q(4239) => q(mfh),
      q(4240) => q(mfi),
      q(4241) => q(mfj),
      q(4242) => q(mfk),
      q(4243) => q(mfl),
      q(4244) => q(mfm),
      q(4245) => q(mfn),
      q(4246) => q(mfo),
      q(4247) => q(mfp),
      q(4248) => q(mfq),
      q(4249) => q(mfr),
      q(4250) => q(mfs),
      q(4251) => q(mft),
      q(4252) => q(mfu),
      q(4253) => q(mfv),
      q(4254) => q(mfw),
      q(4255) => q(mfx),
      q(4256) => q(mfy),
      q(4257) => q(mfz),
      q(4258) => q(mgb),
      q(4259) => q(mgc),
      q(4260) => q(mgd),
      q(4261) => q(mge),
      q(4262) => q(mgf),
      q(4263) => q(mgg),
      q(4264) => q(mgh),
      q(4265) => q(mgi),
      q(4266) => q(mgj),
      q(4267) => q(mgk),
      q(4268) => q(mgl),
      q(4269) => q(mgm),
      q(4270) => q(mgn),
      q(4271) => q(mgo),
      q(4272) => q(mgp),
      q(4273) => q(mgq),
      q(4274) => q(mgr),
      q(4275) => q(mgs),
      q(4276) => q(mgt),
      q(4277) => q(mgu),
      q(4278) => q(mgv),
      q(4279) => q(mgw),
      q(4280) => q(mgy),
      q(4281) => q(mgz),
      q(4282) => q(mha),
      q(4283) => q(mhb),
      q(4284) => q(mhc),
      q(4285) => q(mhd),
      q(4286) => q(mhe),
      q(4287) => q(mhf),
      q(4288) => q(mhg),
      q(4289) => q(mhh),
      q(4290) => q(mhi),
      q(4291) => q(mhj),
      q(4292) => q(mhk),
      q(4293) => q(mhl),
      q(4294) => q(mhm),
      q(4295) => q(mhn),
      q(4296) => q(mho),
      q(4297) => q(mhp),
      q(4298) => q(mhq),
      q(4299) => q(mhr),
      q(4300) => q(mhs),
      q(4301) => q(mht),
      q(4302) => q(mhu),
      q(4303) => q(mhw),
      q(4304) => q(mhx),
      q(4305) => q(mhy),
      q(4306) => q(mhz),
      q(4307) => q(mia),
      q(4308) => q(mib),
      q(4309) => q(mid),
      q(4310) => q(mie),
      q(4311) => q(mif),
      q(4312) => q(mig),
      q(4313) => q(mih),
      q(4314) => q(mii),
      q(4315) => q(mij),
      q(4316) => q(mik),
      q(4317) => q(mil),
      q(4318) => q(mim),
      q(4319) => q(mio),
      q(4320) => q(mip),
      q(4321) => q(miq),
      q(4322) => q(mir),
      q(4323) => q(mit),
      q(4324) => q(miu),
      q(4325) => q(miw),
      q(4326) => q(mix),
      q(4327) => q(miy),
      q(4328) => q(miz),
      q(4329) => q(mjc),
      q(4330) => q(mjd),
      q(4331) => q(mje),
      q(4332) => q(mjg),
      q(4333) => q(mjh),
      q(4334) => q(mji),
      q(4335) => q(mjj),
      q(4336) => q(mjk),
      q(4337) => q(mjl),
      q(4338) => q(mjm),
      q(4339) => q(mjn),
      q(4340) => q(mjo),
      q(4341) => q(mjp),
      q(4342) => q(mjq),
      q(4343) => q(mjr),
      q(4344) => q(mjs),
      q(4345) => q(mjt),
      q(4346) => q(mju),
      q(4347) => q(mjv),
      q(4348) => q(mjw),
      q(4349) => q(mjx),
      q(4350) => q(mjy),
      q(4351) => q(mjz),
      q(4352) => q(mka),
      q(4353) => q(mkb),
      q(4354) => q(mkc),
      q(4355) => q(mke),
      q(4356) => q(mkf),
      q(4357) => q(mkg),
      q(4358) => q(mki),
      q(4359) => q(mkj),
      q(4360) => q(mkk),
      q(4361) => q(mkl),
      q(4362) => q(mkm),
      q(4363) => q(mkn),
      q(4364) => q(mko),
      q(4365) => q(mkp),
      q(4366) => q(mkq),
      q(4367) => q(mkr),
      q(4368) => q(mks),
      q(4369) => q(mkt),
      q(4370) => q(mku),
      q(4371) => q(mkv),
      q(4372) => q(mkw),
      q(4373) => q(mkx),
      q(4374) => q(mky),
      q(4375) => q(mkz),
      q(4376) => q(mla),
      q(4377) => q(mlb),
      q(4378) => q(mlc),
      q(4379) => q(mle),
      q(4380) => q(mlf),
      q(4381) => q(mlh),
      q(4382) => q(mli),
      q(4383) => q(mlj),
      q(4384) => q(mlk),
      q(4385) => q(mll),
      q(4386) => q(mlm),
      q(4387) => q(mln),
      q(4388) => q(mlo),
      q(4389) => q(mlp),
      q(4390) => q(mlq),
      q(4391) => q(mlr),
      q(4392) => q(mls),
      q(4393) => q(mlu),
      q(4394) => q(mlv),
      q(4395) => q(mlw),
      q(4396) => q(mlx),
      q(4397) => q(mlz),
      q(4398) => q(mma),
      q(4399) => q(mmb),
      q(4400) => q(mmc),
      q(4401) => q(mmd),
      q(4402) => q(mme),
      q(4403) => q(mmf),
      q(4404) => q(mmg),
      q(4405) => q(mmh),
      q(4406) => q(mmi),
      q(4407) => q(mmj),
      q(4408) => q(mmk),
      q(4409) => q(mml),
      q(4410) => q(mmm),
      q(4411) => q(mmn),
      q(4412) => q(mmo),
      q(4413) => q(mmp),
      q(4414) => q(mmq),
      q(4415) => q(mmr),
      q(4416) => q(mmt),
      q(4417) => q(mmu),
      q(4418) => q(mmv),
      q(4419) => q(mmw),
      q(4420) => q(mmx),
      q(4421) => q(mmy),
      q(4422) => q(mmz),
      q(4423) => q(mna),
      q(4424) => q(mnb),
      q(4425) => q(mnd),
      q(4426) => q(mne),
      q(4427) => q(mnf),
      q(4428) => q(mng),
      q(4429) => q(mnh),
      q(4430) => q(mnj),
      q(4431) => q(mnk),
      q(4432) => q(mnl),
      q(4433) => q(mnm),
      q(4434) => q(mnn),
      q(4435) => q(mnp),
      q(4436) => q(mnq),
      q(4437) => q(mnr),
      q(4438) => q(mns),
      q(4439) => q(mnu),
      q(4440) => q(mnv),
      q(4441) => q(mnw),
      q(4442) => q(mnx),
      q(4443) => q(mny),
      q(4444) => q(mnz),
      q(4445) => q(moa),
      q(4446) => q(moc),
      q(4447) => q(mod),
      q(4448) => q(moe),
      q(4449) => q(mog),
      q(4450) => q(moi),
      q(4451) => q(moj),
      q(4452) => q(mok),
      q(4453) => q(mom),
      q(4454) => q(moo),
      q(4455) => q(mop),
      q(4456) => q(moq),
      q(4457) => q(mor),
      q(4458) => q(mou),
      q(4459) => q(mov),
      q(4460) => q(mow),
      q(4461) => q(mox),
      q(4462) => q(moy),
      q(4463) => q(moz),
      q(4464) => q(mpa),
      q(4465) => q(mpb),
      q(4466) => q(mpc),
      q(4467) => q(mpd),
      q(4468) => q(mpe),
      q(4469) => q(mpg),
      q(4470) => q(mph),
      q(4471) => q(mpi),
      q(4472) => q(mpj),
      q(4473) => q(mpk),
      q(4474) => q(mpl),
      q(4475) => q(mpm),
      q(4476) => q(mpn),
      q(4477) => q(mpo),
      q(4478) => q(mpp),
      q(4479) => q(mpq),
      q(4480) => q(mpr),
      q(4481) => q(mps),
      q(4482) => q(mpt),
      q(4483) => q(mpu),
      q(4484) => q(mpv),
      q(4485) => q(mpw),
      q(4486) => q(mpx),
      q(4487) => q(mpy),
      q(4488) => q(mpz),
      q(4489) => q(mqa),
      q(4490) => q(mqb),
      q(4491) => q(mqc),
      q(4492) => q(mqe),
      q(4493) => q(mqf),
      q(4494) => q(mqg),
      q(4495) => q(mqh),
      q(4496) => q(mqi),
      q(4497) => q(mqj),
      q(4498) => q(mqk),
      q(4499) => q(mql),
      q(4500) => q(mqm),
      q(4501) => q(mqn),
      q(4502) => q(mqo),
      q(4503) => q(mqp),
      q(4504) => q(mqq),
      q(4505) => q(mqr),
      q(4506) => q(mqs),
      q(4507) => q(mqt),
      q(4508) => q(mqu),
      q(4509) => q(mqv),
      q(4510) => q(mqw),
      q(4511) => q(mqx),
      q(4512) => q(mqy),
      q(4513) => q(mqz),
      q(4514) => q(mra),
      q(4515) => q(mrb),
      q(4516) => q(mrc),
      q(4517) => q(mrd),
      q(4518) => q(mre),
      q(4519) => q(mrf),
      q(4520) => q(mrg),
      q(4521) => q(mrh),
      q(4522) => q(mrj),
      q(4523) => q(mrk),
      q(4524) => q(mrl),
      q(4525) => q(mrm),
      q(4526) => q(mrn),
      q(4527) => q(mro),
      q(4528) => q(mrp),
      q(4529) => q(mrq),
      q(4530) => q(mrr),
      q(4531) => q(mrs),
      q(4532) => q(mrt),
      q(4533) => q(mru),
      q(4534) => q(mrv),
      q(4535) => q(mrw),
      q(4536) => q(mrx),
      q(4537) => q(mry),
      q(4538) => q(mrz),
      q(4539) => q(msb),
      q(4540) => q(msc),
      q(4541) => q(msd),
      q(4542) => q(mse),
      q(4543) => q(msf),
      q(4544) => q(msg),
      q(4545) => q(msh),
      q(4546) => q(msi),
      q(4547) => q(msj),
      q(4548) => q(msk),
      q(4549) => q(msl),
      q(4550) => q(msm),
      q(4551) => q(msn),
      q(4552) => q(mso),
      q(4553) => q(msp),
      q(4554) => q(msq),
      q(4555) => q(msr),
      q(4556) => q(mss),
      q(4557) => q(msu),
      q(4558) => q(msv),
      q(4559) => q(msw),
      q(4560) => q(msx),
      q(4561) => q(msy),
      q(4562) => q(msz),
      q(4563) => q(mta),
      q(4564) => q(mtb),
      q(4565) => q(mtc),
      q(4566) => q(mtd),
      q(4567) => q(mte),
      q(4568) => q(mtf),
      q(4569) => q(mtg),
      q(4570) => q(mth),
      q(4571) => q(mti),
      q(4572) => q(mtj),
      q(4573) => q(mtk),
      q(4574) => q(mtl),
      q(4575) => q(mtm),
      q(4576) => q(mtn),
      q(4577) => q(mto),
      q(4578) => q(mtp),
      q(4579) => q(mtq),
      q(4580) => q(mtr),
      q(4581) => q(mts),
      q(4582) => q(mtt),
      q(4583) => q(mtu),
      q(4584) => q(mtv),
      q(4585) => q(mtw),
      q(4586) => q(mtx),
      q(4587) => q(mty),
      q(4588) => q(mua),
      q(4589) => q(mub),
      q(4590) => q(muc),
      q(4591) => q(mud),
      q(4592) => q(mue),
      q(4593) => q(mug),
      q(4594) => q(muh),
      q(4595) => q(mui),
      q(4596) => q(muj),
      q(4597) => q(muk),
      q(4598) => q(mum),
      q(4599) => q(muo),
      q(4600) => q(mup),
      q(4601) => q(muq),
      q(4602) => q(mur),
      q(4603) => q(mut),
      q(4604) => q(muu),
      q(4605) => q(muv),
      q(4606) => q(mux),
      q(4607) => q(muy),
      q(4608) => q(muz),
      q(4609) => q(mva),
      q(4610) => q(mvb),
      q(4611) => q(mvd),
      q(4612) => q(mve),
      q(4613) => q(mvf),
      q(4614) => q(mvg),
      q(4615) => q(mvh),
      q(4616) => q(mvi),
      q(4617) => q(mvk),
      q(4618) => q(mvl),
      q(4619) => q(mvm),
      q(4620) => q(mvn),
      q(4621) => q(mvo),
      q(4622) => q(mvp),
      q(4623) => q(mvq),
      q(4624) => q(mvr),
      q(4625) => q(mvs),
      q(4626) => q(mvt),
      q(4627) => q(mvu),
      q(4628) => q(mvv),
      q(4629) => q(mvw),
      q(4630) => q(mvx),
      q(4631) => q(mvy),
      q(4632) => q(mvz),
      q(4633) => q(mwa),
      q(4634) => q(mwb),
      q(4635) => q(mwc),
      q(4636) => q(mwe),
      q(4637) => q(mwf),
      q(4638) => q(mwg),
      q(4639) => q(mwh),
      q(4640) => q(mwi),
      q(4641) => q(mwj),
      q(4642) => q(mwk),
      q(4643) => q(mwm),
      q(4644) => q(mwn),
      q(4645) => q(mwo),
      q(4646) => q(mwp),
      q(4647) => q(mwq),
      q(4648) => q(mws),
      q(4649) => q(mwt),
      q(4650) => q(mwu),
      q(4651) => q(mwv),
      q(4652) => q(mww),
      q(4653) => q(mwx),
      q(4654) => q(mwy),
      q(4655) => q(mwz),
      q(4656) => q(mxa),
      q(4657) => q(mxb),
      q(4658) => q(mxc),
      q(4659) => q(mxd),
      q(4660) => q(mxe),
      q(4661) => q(mxf),
      q(4662) => q(mxg),
      q(4663) => q(mxh),
      q(4664) => q(mxi),
      q(4665) => q(mxj),
      q(4666) => q(mxk),
      q(4667) => q(mxl),
      q(4668) => q(mxm),
      q(4669) => q(mxn),
      q(4670) => q(mxo),
      q(4671) => q(mxp),
      q(4672) => q(mxq),
      q(4673) => q(mxr),
      q(4674) => q(mxs),
      q(4675) => q(mxt),
      q(4676) => q(mxu),
      q(4677) => q(mxv),
      q(4678) => q(mxw),
      q(4679) => q(mxx),
      q(4680) => q(mxy),
      q(4681) => q(mxz),
      q(4682) => q(myb),
      q(4683) => q(myc),
      q(4684) => q(myd),
      q(4685) => q(mye),
      q(4686) => q(myf),
      q(4687) => q(myg),
      q(4688) => q(myh),
      q(4689) => q(myi),
      q(4690) => q(myj),
      q(4691) => q(myk),
      q(4692) => q(myl),
      q(4693) => q(mym),
      q(4694) => q(myo),
      q(4695) => q(myp),
      q(4696) => q(myr),
      q(4697) => q(mys),
      q(4698) => q(myu),
      q(4699) => q(myw),
      q(4700) => q(myx),
      q(4701) => q(myy),
      q(4702) => q(myz),
      q(4703) => q(mza),
      q(4704) => q(mzb),
      q(4705) => q(mzc),
      q(4706) => q(mzd),
      q(4707) => q(mze),
      q(4708) => q(mzg),
      q(4709) => q(mzh),
      q(4710) => q(mzi),
      q(4711) => q(mzj),
      q(4712) => q(mzk),
      q(4713) => q(mzl),
      q(4714) => q(mzm),
      q(4715) => q(mzn),
      q(4716) => q(mzo),
      q(4717) => q(mzp),
      q(4718) => q(mzq),
      q(4719) => q(mzr),
      q(4720) => q(mzs),
      q(4721) => q(mzt),
      q(4722) => q(mzu),
      q(4723) => q(mzv),
      q(4724) => q(mzw),
      q(4725) => q(mzx),
      q(4726) => q(mzy),
      q(4727) => q(mzz),
      q(4728) => q(naa),
      q(4729) => q(nab),
      q(4730) => q(nac),
      q(4731) => q(nad),
      q(4732) => q(nae),
      q(4733) => q(naf),
      q(4734) => q(nag),
      q(4735) => q(naj),
      q(4736) => q(nak),
      q(4737) => q(nal),
      q(4738) => q(nam),
      q(4739) => q(nan),
      q(4740) => q(nao),
      q(4741) => q(naq),
      q(4742) => q(nar),
      q(4743) => q(nas),
      q(4744) => q(nat),
      q(4745) => q(naw),
      q(4746) => q(nax),
      q(4747) => q(nay),
      q(4748) => q(naz),
      q(4749) => q(nba),
      q(4750) => q(nbb),
      q(4751) => q(nbc),
      q(4752) => q(nbd),
      q(4753) => q(nbe),
      q(4754) => q(nbg),
      q(4755) => q(nbh),
      q(4756) => q(nbi),
      q(4757) => q(nbj),
      q(4758) => q(nbk),
      q(4759) => q(nbm),
      q(4760) => q(nbn),
      q(4761) => q(nbo),
      q(4762) => q(nbp),
      q(4763) => q(nbq),
      q(4764) => q(nbr),
      q(4765) => q(nbs),
      q(4766) => q(nbt),
      q(4767) => q(nbu),
      q(4768) => q(nbv),
      q(4769) => q(nbw),
      q(4770) => q(nby),
      q(4771) => q(nca),
      q(4772) => q(ncb),
      q(4773) => q(ncc),
      q(4774) => q(ncd),
      q(4775) => q(nce),
      q(4776) => q(ncf),
      q(4777) => q(ncg),
      q(4778) => q(nch),
      q(4779) => q(nci),
      q(4780) => q(ncj),
      q(4781) => q(nck),
      q(4782) => q(ncl),
      q(4783) => q(ncm),
      q(4784) => q(ncn),
      q(4785) => q(nco),
      q(4786) => q(ncp),
      q(4787) => q(ncr),
      q(4788) => q(ncs),
      q(4789) => q(nct),
      q(4790) => q(ncu),
      q(4791) => q(ncx),
      q(4792) => q(ncz),
      q(4793) => q(nda),
      q(4794) => q(ndb),
      q(4795) => q(ndc),
      q(4796) => q(ndd),
      q(4797) => q(ndf),
      q(4798) => q(ndg),
      q(4799) => q(ndh),
      q(4800) => q(ndi),
      q(4801) => q(ndj),
      q(4802) => q(ndk),
      q(4803) => q(ndl),
      q(4804) => q(ndm),
      q(4805) => q(ndn),
      q(4806) => q(ndp),
      q(4807) => q(ndq),
      q(4808) => q(ndr),
      q(4809) => q(ndt),
      q(4810) => q(ndu),
      q(4811) => q(ndv),
      q(4812) => q(ndw),
      q(4813) => q(ndx),
      q(4814) => q(ndy),
      q(4815) => q(ndz),
      q(4816) => q(nea),
      q(4817) => q(neb),
      q(4818) => q(nec),
      q(4819) => q(ned),
      q(4820) => q(nee),
      q(4821) => q(nef),
      q(4822) => q(neg),
      q(4823) => q(neh),
      q(4824) => q(nei),
      q(4825) => q(nej),
      q(4826) => q(nek),
      q(4827) => q(nem),
      q(4828) => q(nen),
      q(4829) => q(neo),
      q(4830) => q(neq),
      q(4831) => q(ner),
      q(4832) => q(nes),
      q(4833) => q(net),
      q(4834) => q(neu),
      q(4835) => q(nev),
      q(4836) => q(nex),
      q(4837) => q(ney),
      q(4838) => q(nez),
      q(4839) => q(nfa),
      q(4840) => q(nfd),
      q(4841) => q(nfl),
      q(4842) => q(nfr),
      q(4843) => q(nfu),
      q(4844) => q(nga),
      q(4845) => q(ngb),
      q(4846) => q(ngc),
      q(4847) => q(ngd),
      q(4848) => q(nge),
      q(4849) => q(ngg),
      q(4850) => q(ngh),
      q(4851) => q(ngi),
      q(4852) => q(ngj),
      q(4853) => q(ngk),
      q(4854) => q(ngl),
      q(4855) => q(ngm),
      q(4856) => q(ngn),
      q(4857) => q(ngo),
      q(4858) => q(ngp),
      q(4859) => q(ngq),
      q(4860) => q(ngr),
      q(4861) => q(ngs),
      q(4862) => q(ngt),
      q(4863) => q(ngu),
      q(4864) => q(ngv),
      q(4865) => q(ngw),
      q(4866) => q(ngx),
      q(4867) => q(ngy),
      q(4868) => q(ngz),
      q(4869) => q(nha),
      q(4870) => q(nhb),
      q(4871) => q(nhc),
      q(4872) => q(nhd),
      q(4873) => q(nhe),
      q(4874) => q(nhf),
      q(4875) => q(nhg),
      q(4876) => q(nhh),
      q(4877) => q(nhi),
      q(4878) => q(nhk),
      q(4879) => q(nhm),
      q(4880) => q(nhn),
      q(4881) => q(nho),
      q(4882) => q(nhp),
      q(4883) => q(nhq),
      q(4884) => q(nhr),
      q(4885) => q(nht),
      q(4886) => q(nhu),
      q(4887) => q(nhv),
      q(4888) => q(nhw),
      q(4889) => q(nhx),
      q(4890) => q(nhy),
      q(4891) => q(nhz),
      q(4892) => q(nib),
      q(4893) => q(nid),
      q(4894) => q(nie),
      q(4895) => q(nif),
      q(4896) => q(nig),
      q(4897) => q(nih),
      q(4898) => q(nii),
      q(4899) => q(nij),
      q(4900) => q(nik),
      q(4901) => q(nil),
      q(4902) => q(nim),
      q(4903) => q(nin),
      q(4904) => q(nio),
      q(4905) => q(niq),
      q(4906) => q(nir),
      q(4907) => q(nis),
      q(4908) => q(nit),
      q(4909) => q(niv),
      q(4910) => q(niw),
      q(4911) => q(nix),
      q(4912) => q(niy),
      q(4913) => q(niz),
      q(4914) => q(nja),
      q(4915) => q(njb),
      q(4916) => q(njd),
      q(4917) => q(njh),
      q(4918) => q(nji),
      q(4919) => q(njj),
      q(4920) => q(njl),
      q(4921) => q(njm),
      q(4922) => q(njn),
      q(4923) => q(njo),
      q(4924) => q(njr),
      q(4925) => q(njs),
      q(4926) => q(njt),
      q(4927) => q(nju),
      q(4928) => q(njx),
      q(4929) => q(njy),
      q(4930) => q(njz),
      q(4931) => q(nka),
      q(4932) => q(nkb),
      q(4933) => q(nkc),
      q(4934) => q(nkd),
      q(4935) => q(nke),
      q(4936) => q(nkf),
      q(4937) => q(nkg),
      q(4938) => q(nkh),
      q(4939) => q(nki),
      q(4940) => q(nkj),
      q(4941) => q(nkk),
      q(4942) => q(nkm),
      q(4943) => q(nkn),
      q(4944) => q(nko),
      q(4945) => q(nkp),
      q(4946) => q(nkq),
      q(4947) => q(nkr),
      q(4948) => q(nks),
      q(4949) => q(nkt),
      q(4950) => q(nku),
      q(4951) => q(nkv),
      q(4952) => q(nkw),
      q(4953) => q(nkx),
      q(4954) => q(nkz),
      q(4955) => q(nla),
      q(4956) => q(nlc),
      q(4957) => q(nle),
      q(4958) => q(nlg),
      q(4959) => q(nli),
      q(4960) => q(nlj),
      q(4961) => q(nlk),
      q(4962) => q(nll),
      q(4963) => q(nlo),
      q(4964) => q(nlq),
      q(4965) => q(nlu),
      q(4966) => q(nlv),
      q(4967) => q(nlw),
      q(4968) => q(nlx),
      q(4969) => q(nly),
      q(4970) => q(nlz),
      q(4971) => q(nma),
      q(4972) => q(nmb),
      q(4973) => q(nmc),
      q(4974) => q(nmd),
      q(4975) => q(nme),
      q(4976) => q(nmf),
      q(4977) => q(nmg),
      q(4978) => q(nmh),
      q(4979) => q(nmi),
      q(4980) => q(nmj),
      q(4981) => q(nmk),
      q(4982) => q(nml),
      q(4983) => q(nmm),
      q(4984) => q(nmn),
      q(4985) => q(nmo),
      q(4986) => q(nmp),
      q(4987) => q(nmq),
      q(4988) => q(nmr),
      q(4989) => q(nms),
      q(4990) => q(nmt),
      q(4991) => q(nmu),
      q(4992) => q(nmv),
      q(4993) => q(nmw),
      q(4994) => q(nmx),
      q(4995) => q(nmy),
      q(4996) => q(nmz),
      q(4997) => q(nna),
      q(4998) => q(nnb),
      q(4999) => q(nnc),
      q(5000) => q(nnd),
      q(5001) => q(nne),
      q(5002) => q(nnf),
      q(5003) => q(nng),
      q(5004) => q(nnh),
      q(5005) => q(nni),
      q(5006) => q(nnj),
      q(5007) => q(nnk),
      q(5008) => q(nnl),
      q(5009) => q(nnm),
      q(5010) => q(nnn),
      q(5011) => q(nnp),
      q(5012) => q(nnq),
      q(5013) => q(nnr),
      q(5014) => q(nns),
      q(5015) => q(nnt),
      q(5016) => q(nnu),
      q(5017) => q(nnv),
      q(5018) => q(nnw),
      q(5019) => q(nnx),
      q(5020) => q(nny),
      q(5021) => q(nnz),
      q(5022) => q(noa),
      q(5023) => q(noc),
      q(5024) => q(nod),
      q(5025) => q(noe),
      q(5026) => q(nof),
      q(5027) => q(noh),
      q(5028) => q(noi),
      q(5029) => q(noj),
      q(5030) => q(nok),
      q(5031) => q(nol),
      q(5032) => q(nom),
      q(5033) => q(nop),
      q(5034) => q(noq),
      q(5035) => q(nos),
      q(5036) => q(not),
      q(5037) => q(nou),
      q(5038) => q(nov),
      q(5039) => q(now),
      q(5040) => q(noy),
      q(5041) => q(noz),
      q(5042) => q(npa),
      q(5043) => q(npb),
      q(5044) => q(npg),
      q(5045) => q(nph),
      q(5046) => q(npi),
      q(5047) => q(npl),
      q(5048) => q(npn),
      q(5049) => q(npo),
      q(5050) => q(nps),
      q(5051) => q(npu),
      q(5052) => q(npy),
      q(5053) => q(nqg),
      q(5054) => q(nqk),
      q(5055) => q(nqm),
      q(5056) => q(nqn),
      q(5057) => q(nqq),
      q(5058) => q(nqy),
      q(5059) => q(nra),
      q(5060) => q(nrb),
      q(5061) => q(nrc),
      q(5062) => q(nre),
      q(5063) => q(nrg),
      q(5064) => q(nri),
      q(5065) => q(nrk),
      q(5066) => q(nrl),
      q(5067) => q(nrm),
      q(5068) => q(nrn),
      q(5069) => q(nrp),
      q(5070) => q(nrr),
      q(5071) => q(nrt),
      q(5072) => q(nru),
      q(5073) => q(nrx),
      q(5074) => q(nrz),
      q(5075) => q(nsa),
      q(5076) => q(nsc),
      q(5077) => q(nsd),
      q(5078) => q(nse),
      q(5079) => q(nsf),
      q(5080) => q(nsg),
      q(5081) => q(nsh),
      q(5082) => q(nsi),
      q(5083) => q(nsk),
      q(5084) => q(nsl),
      q(5085) => q(nsm),
      q(5086) => q(nsn),
      q(5087) => q(nsp),
      q(5088) => q(nsq),
      q(5089) => q(nsr),
      q(5090) => q(nss),
      q(5091) => q(nst),
      q(5092) => q(nsu),
      q(5093) => q(nsv),
      q(5094) => q(nsw),
      q(5095) => q(nsx),
      q(5096) => q(nsy),
      q(5097) => q(nsz),
      q(5098) => q(nte),
      q(5099) => q(ntg),
      q(5100) => q(nti),
      q(5101) => q(ntj),
      q(5102) => q(ntk),
      q(5103) => q(ntm),
      q(5104) => q(nto),
      q(5105) => q(ntp),
      q(5106) => q(ntr),
      q(5107) => q(nts),
      q(5108) => q(ntu),
      q(5109) => q(ntw),
      q(5110) => q(ntx),
      q(5111) => q(nty),
      q(5112) => q(ntz),
      q(5113) => q(nua),
      q(5114) => q(nuc),
      q(5115) => q(nud),
      q(5116) => q(nue),
      q(5117) => q(nuf),
      q(5118) => q(nug),
      q(5119) => q(nuh),
      q(5120) => q(nui),
      q(5121) => q(nuj),
      q(5122) => q(nuk),
      q(5123) => q(nul),
      q(5124) => q(num),
      q(5125) => q(nun),
      q(5126) => q(nuo),
      q(5127) => q(nup),
      q(5128) => q(nuq),
      q(5129) => q(nur),
      q(5130) => q(nus),
      q(5131) => q(nut),
      q(5132) => q(nuu),
      q(5133) => q(nuv),
      q(5134) => q(nuw),
      q(5135) => q(nux),
      q(5136) => q(nuy),
      q(5137) => q(nuz),
      q(5138) => q(nvh),
      q(5139) => q(nvm),
      q(5140) => q(nvo),
      q(5141) => q(nwa),
      q(5142) => q(nwb),
      q(5143) => q(nwe),
      q(5144) => q(nwg),
      q(5145) => q(nwi),
      q(5146) => q(nwm),
      q(5147) => q(nwo),
      q(5148) => q(nwr),
      q(5149) => q(nwx),
      q(5150) => q(nwy),
      q(5151) => q(nxa),
      q(5152) => q(nxd),
      q(5153) => q(nxe),
      q(5154) => q(nxg),
      q(5155) => q(nxi),
      q(5156) => q(nxk),
      q(5157) => q(nxl),
      q(5158) => q(nxm),
      q(5159) => q(nxn),
      q(5160) => q(nxq),
      q(5161) => q(nxr),
      q(5162) => q(nxu),
      q(5163) => q(nxx),
      q(5164) => q(nyb),
      q(5165) => q(nyc),
      q(5166) => q(nyd),
      q(5167) => q(nye),
      q(5168) => q(nyf),
      q(5169) => q(nyg),
      q(5170) => q(nyh),
      q(5171) => q(nyi),
      q(5172) => q(nyj),
      q(5173) => q(nyk),
      q(5174) => q(nyl),
      q(5175) => q(nyp),
      q(5176) => q(nyq),
      q(5177) => q(nyr),
      q(5178) => q(nys),
      q(5179) => q(nyt),
      q(5180) => q(nyu),
      q(5181) => q(nyv),
      q(5182) => q(nyw),
      q(5183) => q(nyx),
      q(5184) => q(nyy),
      q(5185) => q(nza),
      q(5186) => q(nzb),
      q(5187) => q(nzk),
      q(5188) => q(nzm),
      q(5189) => q(nzs),
      q(5190) => q(nzu),
      q(5191) => q(nzy),
      q(5192) => q(nzz),
      q(5193) => q(oaa),
      q(5194) => q(oac),
      q(5195) => q(oar),
      q(5196) => q(oav),
      q(5197) => q(obi),
      q(5198) => q(obk),
      q(5199) => q(obl),
      q(5200) => q(obm),
      q(5201) => q(obo),
      q(5202) => q(obr),
      q(5203) => q(obt),
      q(5204) => q(obu),
      q(5205) => q(oca),
      q(5206) => q(och),
      q(5207) => q(oco),
      q(5208) => q(ocu),
      q(5209) => q(oda),
      q(5210) => q(odk),
      q(5211) => q(odt),
      q(5212) => q(odu),
      q(5213) => q(ofo),
      q(5214) => q(ofs),
      q(5215) => q(ofu),
      q(5216) => q(ogb),
      q(5217) => q(ogc),
      q(5218) => q(oge),
      q(5219) => q(ogg),
      q(5220) => q(ogo),
      q(5221) => q(ogu),
      q(5222) => q(oht),
      q(5223) => q(ohu),
      q(5224) => q(oia),
      q(5225) => q(oin),
      q(5226) => q(ojb),
      q(5227) => q(ojc),
      q(5228) => q(ojg),
      q(5229) => q(ojp),
      q(5230) => q(ojs),
      q(5231) => q(ojv),
      q(5232) => q(ojw),
      q(5233) => q(oka),
      q(5234) => q(okb),
      q(5235) => q(okd),
      q(5236) => q(oke),
      q(5237) => q(okg),
      q(5238) => q(okh),
      q(5239) => q(oki),
      q(5240) => q(okj),
      q(5241) => q(okk),
      q(5242) => q(okl),
      q(5243) => q(okm),
      q(5244) => q(okn),
      q(5245) => q(oko),
      q(5246) => q(okr),
      q(5247) => q(oks),
      q(5248) => q(oku),
      q(5249) => q(okv),
      q(5250) => q(okx),
      q(5251) => q(ola),
      q(5252) => q(old),
      q(5253) => q(ole),
      q(5254) => q(olk),
      q(5255) => q(olm),
      q(5256) => q(olo),
      q(5257) => q(olr),
      q(5258) => q(oma),
      q(5259) => q(omb),
      q(5260) => q(omc),
      q(5261) => q(ome),
      q(5262) => q(omg),
      q(5263) => q(omi),
      q(5264) => q(omk),
      q(5265) => q(oml),
      q(5266) => q(omn),
      q(5267) => q(omo),
      q(5268) => q(omp),
      q(5269) => q(omr),
      q(5270) => q(omt),
      q(5271) => q(omu),
      q(5272) => q(omw),
      q(5273) => q(omx),
      q(5274) => q(ona),
      q(5275) => q(onb),
      q(5276) => q(one),
      q(5277) => q(ong),
      q(5278) => q(oni),
      q(5279) => q(onj),
      q(5280) => q(onk),
      q(5281) => q(onn),
      q(5282) => q(ono),
      q(5283) => q(onp),
      q(5284) => q(onr),
      q(5285) => q(ons),
      q(5286) => q(ont),
      q(5287) => q(onu),
      q(5288) => q(onw),
      q(5289) => q(onx),
      q(5290) => q(ood),
      q(5291) => q(oog),
      q(5292) => q(oon),
      q(5293) => q(oor),
      q(5294) => q(oos),
      q(5295) => q(opa),
      q(5296) => q(opk),
      q(5297) => q(opm),
      q(5298) => q(opo),
      q(5299) => q(opt),
      q(5300) => q(opy),
      q(5301) => q(ora),
      q(5302) => q(orc),
      q(5303) => q(ore),
      q(5304) => q(org),
      q(5305) => q(orh),
      q(5306) => q(orn),
      q(5307) => q(oro),
      q(5308) => q(orr),
      q(5309) => q(ors),
      q(5310) => q(ort),
      q(5311) => q(oru),
      q(5312) => q(orv),
      q(5313) => q(orw),
      q(5314) => q(orx),
      q(5315) => q(ory),
      q(5316) => q(orz),
      q(5317) => q(osc),
      q(5318) => q(osi),
      q(5319) => q(oso),
      q(5320) => q(osp),
      q(5321) => q(ost),
      q(5322) => q(osu),
      q(5323) => q(osx),
      q(5324) => q(otb),
      q(5325) => q(otd),
      q(5326) => q(ote),
      q(5327) => q(oti),
      q(5328) => q(otk),
      q(5329) => q(otl),
      q(5330) => q(otm),
      q(5331) => q(otn),
      q(5332) => q(otq),
      q(5333) => q(otr),
      q(5334) => q(ots),
      q(5335) => q(ott),
      q(5336) => q(otu),
      q(5337) => q(otw),
      q(5338) => q(otx),
      q(5339) => q(oty),
      q(5340) => q(otz),
      q(5341) => q(oua),
      q(5342) => q(oub),
      q(5343) => q(oue),
      q(5344) => q(oui),
      q(5345) => q(oum),
      q(5346) => q(oun),
      q(5347) => q(owi),
      q(5348) => q(owl),
      q(5349) => q(oyb),
      q(5350) => q(oyd),
      q(5351) => q(oym),
      q(5352) => q(oyy),
      q(5353) => q(ozm),
      q(5354) => q(pab),
      q(5355) => q(pac),
      q(5356) => q(pad),
      q(5357) => q(pae),
      q(5358) => q(paf),
      q(5359) => q(pah),
      q(5360) => q(pai),
      q(5361) => q(pak),
      q(5362) => q(pao),
      q(5363) => q(paq),
      q(5364) => q(par),
      q(5365) => q(pas),
      q(5366) => q(pat),
      q(5367) => q(pav),
      q(5368) => q(paw),
      q(5369) => q(pax),
      q(5370) => q(pay),
      q(5371) => q(paz),
      q(5372) => q(pbb),
      q(5373) => q(pbc),
      q(5374) => q(pbe),
      q(5375) => q(pbf),
      q(5376) => q(pbg),
      q(5377) => q(pbh),
      q(5378) => q(pbi),
      q(5379) => q(pbl),
      q(5380) => q(pbn),
      q(5381) => q(pbo),
      q(5382) => q(pbp),
      q(5383) => q(pbr),
      q(5384) => q(pbs),
      q(5385) => q(pbt),
      q(5386) => q(pbu),
      q(5387) => q(pbv),
      q(5388) => q(pby),
      q(5389) => q(pca),
      q(5390) => q(pcb),
      q(5391) => q(pcc),
      q(5392) => q(pcd),
      q(5393) => q(pce),
      q(5394) => q(pcf),
      q(5395) => q(pcg),
      q(5396) => q(pch),
      q(5397) => q(pci),
      q(5398) => q(pcj),
      q(5399) => q(pck),
      q(5400) => q(pcl),
      q(5401) => q(pcm),
      q(5402) => q(pcn),
      q(5403) => q(pcp),
      q(5404) => q(pcw),
      q(5405) => q(pda),
      q(5406) => q(pdc),
      q(5407) => q(pdi),
      q(5408) => q(pdn),
      q(5409) => q(pdo),
      q(5410) => q(pdt),
      q(5411) => q(pdu),
      q(5412) => q(pea),
      q(5413) => q(peb),
      q(5414) => q(ped),
      q(5415) => q(pee),
      q(5416) => q(pef),
      q(5417) => q(peg),
      q(5418) => q(peh),
      q(5419) => q(pei),
      q(5420) => q(pej),
      q(5421) => q(pek),
      q(5422) => q(pel),
      q(5423) => q(pem),
      q(5424) => q(pep),
      q(5425) => q(peq),
      q(5426) => q(pes),
      q(5427) => q(pev),
      q(5428) => q(pex),
      q(5429) => q(pey),
      q(5430) => q(pez),
      q(5431) => q(pfa),
      q(5432) => q(pfe),
      q(5433) => q(pfl),
      q(5434) => q(pga),
      q(5435) => q(pgg),
      q(5436) => q(pgi),
      q(5437) => q(pgk),
      q(5438) => q(pgl),
      q(5439) => q(pgn),
      q(5440) => q(pgs),
      q(5441) => q(pgu),
      q(5442) => q(pha),
      q(5443) => q(phd),
      q(5444) => q(phg),
      q(5445) => q(phh),
      q(5446) => q(phk),
      q(5447) => q(phl),
      q(5448) => q(phm),
      q(5449) => q(pho),
      q(5450) => q(phq),
      q(5451) => q(phr),
      q(5452) => q(pht),
      q(5453) => q(phu),
      q(5454) => q(phv),
      q(5455) => q(phw),
      q(5456) => q(pia),
      q(5457) => q(pib),
      q(5458) => q(pic),
      q(5459) => q(pid),
      q(5460) => q(pie),
      q(5461) => q(pif),
      q(5462) => q(pig),
      q(5463) => q(pih),
      q(5464) => q(pii),
      q(5465) => q(pij),
      q(5466) => q(pil),
      q(5467) => q(pim),
      q(5468) => q(pin),
      q(5469) => q(pio),
      q(5470) => q(pip),
      q(5471) => q(pir),
      q(5472) => q(pis),
      q(5473) => q(pit),
      q(5474) => q(piu),
      q(5475) => q(piv),
      q(5476) => q(piw),
      q(5477) => q(pix),
      q(5478) => q(piy),
      q(5479) => q(piz),
      q(5480) => q(pjt),
      q(5481) => q(pka),
      q(5482) => q(pkb),
      q(5483) => q(pkc),
      q(5484) => q(pkg),
      q(5485) => q(pkh),
      q(5486) => q(pkn),
      q(5487) => q(pko),
      q(5488) => q(pkp),
      q(5489) => q(pkr),
      q(5490) => q(pks),
      q(5491) => q(pkt),
      q(5492) => q(pku),
      q(5493) => q(pla),
      q(5494) => q(plb),
      q(5495) => q(plc),
      q(5496) => q(pld),
      q(5497) => q(ple),
      q(5498) => q(plg),
      q(5499) => q(plh),
      q(5500) => q(plj),
      q(5501) => q(plk),
      q(5502) => q(pll),
      q(5503) => q(pln),
      q(5504) => q(plo),
      q(5505) => q(plp),
      q(5506) => q(plq),
      q(5507) => q(plr),
      q(5508) => q(pls),
      q(5509) => q(plt),
      q(5510) => q(plu),
      q(5511) => q(plv),
      q(5512) => q(plw),
      q(5513) => q(ply),
      q(5514) => q(plz),
      q(5515) => q(pma),
      q(5516) => q(pmb),
      q(5517) => q(pmc),
      q(5518) => q(pmd),
      q(5519) => q(pme),
      q(5520) => q(pmf),
      q(5521) => q(pmh),
      q(5522) => q(pmi),
      q(5523) => q(pmj),
      q(5524) => q(pmk),
      q(5525) => q(pml),
      q(5526) => q(pmm),
      q(5527) => q(pmn),
      q(5528) => q(pmo),
      q(5529) => q(pmq),
      q(5530) => q(pmr),
      q(5531) => q(pms),
      q(5532) => q(pmt),
      q(5533) => q(pmu),
      q(5534) => q(pmw),
      q(5535) => q(pmx),
      q(5536) => q(pmy),
      q(5537) => q(pmz),
      q(5538) => q(pna),
      q(5539) => q(pnb),
      q(5540) => q(pnc),
      q(5541) => q(pne),
      q(5542) => q(png),
      q(5543) => q(pnh),
      q(5544) => q(pni),
      q(5545) => q(pnj),
      q(5546) => q(pnk),
      q(5547) => q(pnl),
      q(5548) => q(pnm),
      q(5549) => q(pnn),
      q(5550) => q(pno),
      q(5551) => q(pnp),
      q(5552) => q(pnq),
      q(5553) => q(pnr),
      q(5554) => q(pns),
      q(5555) => q(pnt),
      q(5556) => q(pnu),
      q(5557) => q(pnv),
      q(5558) => q(pnw),
      q(5559) => q(pnx),
      q(5560) => q(pny),
      q(5561) => q(pnz),
      q(5562) => q(poc),
      q(5563) => q(pod),
      q(5564) => q(poe),
      q(5565) => q(pof),
      q(5566) => q(pog),
      q(5567) => q(poh),
      q(5568) => q(poi),
      q(5569) => q(pok),
      q(5570) => q(pom),
      q(5571) => q(poo),
      q(5572) => q(pop),
      q(5573) => q(poq),
      q(5574) => q(pos),
      q(5575) => q(pot),
      q(5576) => q(pov),
      q(5577) => q(pow),
      q(5578) => q(pox),
      q(5579) => q(poy),
      q(5580) => q(ppa),
      q(5581) => q(ppe),
      q(5582) => q(ppi),
      q(5583) => q(ppk),
      q(5584) => q(ppl),
      q(5585) => q(ppm),
      q(5586) => q(ppn),
      q(5587) => q(ppo),
      q(5588) => q(ppp),
      q(5589) => q(ppq),
      q(5590) => q(pps),
      q(5591) => q(ppt),
      q(5592) => q(ppu),
      q(5593) => q(pqa),
      q(5594) => q(pqm),
      q(5595) => q(prb),
      q(5596) => q(prc),
      q(5597) => q(prd),
      q(5598) => q(pre),
      q(5599) => q(prf),
      q(5600) => q(prg),
      q(5601) => q(prh),
      q(5602) => q(pri),
      q(5603) => q(prk),
      q(5604) => q(prl),
      q(5605) => q(prm),
      q(5606) => q(prn),
      q(5607) => q(prp),
      q(5608) => q(prq),
      q(5609) => q(prr),
      q(5610) => q(prs),
      q(5611) => q(prt),
      q(5612) => q(pru),
      q(5613) => q(prw),
      q(5614) => q(prx),
      q(5615) => q(pry),
      q(5616) => q(prz),
      q(5617) => q(psa),
      q(5618) => q(psc),
      q(5619) => q(psd),
      q(5620) => q(pse),
      q(5621) => q(psg),
      q(5622) => q(psh),
      q(5623) => q(psi),
      q(5624) => q(psl),
      q(5625) => q(psm),
      q(5626) => q(psn),
      q(5627) => q(pso),
      q(5628) => q(psp),
      q(5629) => q(psq),
      q(5630) => q(psr),
      q(5631) => q(pss),
      q(5632) => q(pst),
      q(5633) => q(psu),
      q(5634) => q(psw),
      q(5635) => q(psy),
      q(5636) => q(pta),
      q(5637) => q(pth),
      q(5638) => q(pti),
      q(5639) => q(ptn),
      q(5640) => q(pto),
      q(5641) => q(ptp),
      q(5642) => q(ptr),
      q(5643) => q(ptt),
      q(5644) => q(ptu),
      q(5645) => q(ptv),
      q(5646) => q(ptw),
      q(5647) => q(pty),
      q(5648) => q(pua),
      q(5649) => q(pub),
      q(5650) => q(puc),
      q(5651) => q(pud),
      q(5652) => q(pue),
      q(5653) => q(puf),
      q(5654) => q(pug),
      q(5655) => q(pui),
      q(5656) => q(puj),
      q(5657) => q(puk),
      q(5658) => q(pum),
      q(5659) => q(puo),
      q(5660) => q(pup),
      q(5661) => q(puq),
      q(5662) => q(pur),
      q(5663) => q(put),
      q(5664) => q(puu),
      q(5665) => q(puw),
      q(5666) => q(pux),
      q(5667) => q(puy),
      q(5668) => q(puz),
      q(5669) => q(pwa),
      q(5670) => q(pwb),
      q(5671) => q(pwg),
      q(5672) => q(pwi),
      q(5673) => q(pwm),
      q(5674) => q(pwn),
      q(5675) => q(pwo),
      q(5676) => q(pwr),
      q(5677) => q(pww),
      q(5678) => q(pxm),
      q(5679) => q(pye),
      q(5680) => q(pym),
      q(5681) => q(pyn),
      q(5682) => q(pys),
      q(5683) => q(pyu),
      q(5684) => q(pyx),
      q(5685) => q(pyy),
      q(5686) => q(pzn),
      q(5687) => q(qua),
      q(5688) => q(qub),
      q(5689) => q(quc),
      q(5690) => q(qud),
      q(5691) => q(quf),
      q(5692) => q(qug),
      q(5693) => q(quh),
      q(5694) => q(qui),
      q(5695) => q(quk),
      q(5696) => q(qul),
      q(5697) => q(qum),
      q(5698) => q(qun),
      q(5699) => q(qup),
      q(5700) => q(quq),
      q(5701) => q(qur),
      q(5702) => q(qus),
      q(5703) => q(quv),
      q(5704) => q(quw),
      q(5705) => q(qux),
      q(5706) => q(quy),
      q(5707) => q(quz),
      q(5708) => q(qva),
      q(5709) => q(qvc),
      q(5710) => q(qve),
      q(5711) => q(qvh),
      q(5712) => q(qvi),
      q(5713) => q(qvj),
      q(5714) => q(qvl),
      q(5715) => q(qvm),
      q(5716) => q(qvn),
      q(5717) => q(qvo),
      q(5718) => q(qvp),
      q(5719) => q(qvs),
      q(5720) => q(qvw),
      q(5721) => q(qvy),
      q(5722) => q(qvz),
      q(5723) => q(qwa),
      q(5724) => q(qwc),
      q(5725) => q(qwh),
      q(5726) => q(qwm),
      q(5727) => q(qws),
      q(5728) => q(qwt),
      q(5729) => q(qxa),
      q(5730) => q(qxc),
      q(5731) => q(qxh),
      q(5732) => q(qxl),
      q(5733) => q(qxn),
      q(5734) => q(qxo),
      q(5735) => q(qxp),
      q(5736) => q(qxq),
      q(5737) => q(qxr),
      q(5738) => q(qxs),
      q(5739) => q(qxt),
      q(5740) => q(qxu),
      q(5741) => q(qxw),
      q(5742) => q(qya),
      q(5743) => q(qyp),
      q(5744) => q(raa),
      q(5745) => q(rab),
      q(5746) => q(rac),
      q(5747) => q(rad),
      q(5748) => q(raf),
      q(5749) => q(rag),
      q(5750) => q(rah),
      q(5751) => q(rai),
      q(5752) => q(rak),
      q(5753) => q(ral),
      q(5754) => q(ram),
      q(5755) => q(ran),
      q(5756) => q(rao),
      q(5757) => q(raq),
      q(5758) => q(ras),
      q(5759) => q(rat),
      q(5760) => q(rau),
      q(5761) => q(rav),
      q(5762) => q(raw),
      q(5763) => q(rax),
      q(5764) => q(ray),
      q(5765) => q(raz),
      q(5766) => q(rbb),
      q(5767) => q(rbk),
      q(5768) => q(rbl),
      q(5769) => q(rbp),
      q(5770) => q(rcf),
      q(5771) => q(rdb),
      q(5772) => q(rea),
      q(5773) => q(reb),
      q(5774) => q(ree),
      q(5775) => q(reg),
      q(5776) => q(rei),
      q(5777) => q(rej),
      q(5778) => q(rel),
      q(5779) => q(rem),
      q(5780) => q(ren),
      q(5781) => q(rer),
      q(5782) => q(res),
      q(5783) => q(ret),
      q(5784) => q(rey),
      q(5785) => q(rga),
      q(5786) => q(rge),
      q(5787) => q(rgk),
      q(5788) => q(rgn),
      q(5789) => q(rgr),
      q(5790) => q(rgs),
      q(5791) => q(rgu),
      q(5792) => q(rhg),
      q(5793) => q(rhp),
      q(5794) => q(ria),
      q(5795) => q(rie),
      q(5796) => q(rif),
      q(5797) => q(ril),
      q(5798) => q(rim),
      q(5799) => q(rin),
      q(5800) => q(rir),
      q(5801) => q(rit),
      q(5802) => q(riu),
      q(5803) => q(rjg),
      q(5804) => q(rji),
      q(5805) => q(rjs),
      q(5806) => q(rka),
      q(5807) => q(rkb),
      q(5808) => q(rkh),
      q(5809) => q(rki),
      q(5810) => q(rkm),
      q(5811) => q(rkt),
      q(5812) => q(rkw),
      q(5813) => q(rma),
      q(5814) => q(rmb),
      q(5815) => q(rmc),
      q(5816) => q(rmd),
      q(5817) => q(rme),
      q(5818) => q(rmf),
      q(5819) => q(rmg),
      q(5820) => q(rmh),
      q(5821) => q(rmi),
      q(5822) => q(rmk),
      q(5823) => q(rml),
      q(5824) => q(rmm),
      q(5825) => q(rmn),
      q(5826) => q(rmo),
      q(5827) => q(rmp),
      q(5828) => q(rmq),
      q(5829) => q(rms),
      q(5830) => q(rmt),
      q(5831) => q(rmu),
      q(5832) => q(rmv),
      q(5833) => q(rmw),
      q(5834) => q(rmx),
      q(5835) => q(rmy),
      q(5836) => q(rmz),
      q(5837) => q(rna),
      q(5838) => q(rnd),
      q(5839) => q(rng),
      q(5840) => q(rnl),
      q(5841) => q(rnn),
      q(5842) => q(rnp),
      q(5843) => q(rnr),
      q(5844) => q(rnw),
      q(5845) => q(rob),
      q(5846) => q(roc),
      q(5847) => q(rod),
      q(5848) => q(roe),
      q(5849) => q(rof),
      q(5850) => q(rog),
      q(5851) => q(rol),
      q(5852) => q(roo),
      q(5853) => q(rop),
      q(5854) => q(ror),
      q(5855) => q(rou),
      q(5856) => q(row),
      q(5857) => q(rpn),
      q(5858) => q(rpt),
      q(5859) => q(rri),
      q(5860) => q(rro),
      q(5861) => q(rrt),
      q(5862) => q(rsb),
      q(5863) => q(rsi),
      q(5864) => q(rsl),
      q(5865) => q(rtc),
      q(5866) => q(rth),
      q(5867) => q(rtm),
      q(5868) => q(rtw),
      q(5869) => q(rub),
      q(5870) => q(ruc),
      q(5871) => q(rue),
      q(5872) => q(ruf),
      q(5873) => q(rug),
      q(5874) => q(ruh),
      q(5875) => q(rui),
      q(5876) => q(ruk),
      q(5877) => q(ruo),
      q(5878) => q(ruq),
      q(5879) => q(rut),
      q(5880) => q(ruu),
      q(5881) => q(ruy),
      q(5882) => q(ruz),
      q(5883) => q(rwa),
      q(5884) => q(rwk),
      q(5885) => q(rwm),
      q(5886) => q(rwo),
      q(5887) => q(rwr),
      q(5888) => q(rxd),
      q(5889) => q(rxw),
      q(5890) => q(ryn),
      q(5891) => q(rys),
      q(5892) => q(ryu),
      q(5893) => q(saa),
      q(5894) => q(sab),
      q(5895) => q(sac),
      q(5896) => q(sae),
      q(5897) => q(saf),
      q(5898) => q(saj),
      q(5899) => q(sak),
      q(5900) => q(sao),
      q(5901) => q(sap),
      q(5902) => q(saq),
      q(5903) => q(sar),
      q(5904) => q(sau),
      q(5905) => q(sav),
      q(5906) => q(saw),
      q(5907) => q(sax),
      q(5908) => q(say),
      q(5909) => q(saz),
      q(5910) => q(sba),
      q(5911) => q(sbb),
      q(5912) => q(sbc),
      q(5913) => q(sbd),
      q(5914) => q(slc),
      q(5915) => q(sbf),
      q(5916) => q(sbg),
      q(5917) => q(sbh),
      q(5918) => q(sbi),
      q(5919) => q(sbj),
      q(5920) => q(sbk),
      q(5921) => q(sbl),
      q(5922) => q(sbm),
      q(5923) => q(sbn),
      q(5924) => q(sbo),
      q(5925) => q(sbp),
      q(5926) => q(sbq),
      q(5927) => q(sbr),
      q(5928) => q(sbs),
      q(5929) => q(sbt),
      q(5930) => q(sbu),
      q(5931) => q(sbv),
      q(5932) => q(sbw),
      q(5933) => q(sbx),
      q(5934) => q(sby),
      q(5935) => q(sbz),
      q(5936) => q(scb),
      q(5937) => q(sce),
      q(5938) => q(scf),
      q(5939) => q(scg),
      q(5940) => q(sch),
      q(5941) => q(sci),
      q(5942) => q(sck),
      q(5943) => q(scl),
      q(5944) => q(scp),
      q(5945) => q(scq),
      q(5946) => q(scs),
      q(5947) => q(scu),
      q(5948) => q(scv),
      q(5949) => q(scw),
      q(5950) => q(scx),
      q(5951) => q(sda),
      q(5952) => q(sdb),
      q(5953) => q(sdc),
      q(5954) => q(sde),
      q(5955) => q(sdf),
      q(5956) => q(sdg),
      q(5957) => q(sdh),
      q(5958) => q(sdj),
      q(5959) => q(sdk),
      q(5960) => q(sdl),
      q(5961) => q(sdm),
      q(5962) => q(sdn),
      q(5963) => q(sdo),
      q(5964) => q(sdp),
      q(5965) => q(sdr),
      q(5966) => q(sds),
      q(5967) => q(sdt),
      q(5968) => q(sdu),
      q(5969) => q(sdx),
      q(5970) => q(sdz),
      q(5971) => q(sea),
      q(5972) => q(seb),
      q(5973) => q(sec),
      q(5974) => q(sed),
      q(5975) => q(see),
      q(5976) => q(sef),
      q(5977) => q(seg),
      q(5978) => q(seh),
      q(5979) => q(sei),
      q(5980) => q(sej),
      q(5981) => q(sek),
      q(5982) => q(sen),
      q(5983) => q(seo),
      q(5984) => q(sep),
      q(5985) => q(seq),
      q(5986) => q(ser),
      q(5987) => q(ses),
      q(5988) => q(set),
      q(5989) => q(seu),
      q(5990) => q(sev),
      q(5991) => q(sew),
      q(5992) => q(sey),
      q(5993) => q(sez),
      q(5994) => q(sfb),
      q(5995) => q(sfe),
      q(5996) => q(sfm),
      q(5997) => q(sfs),
      q(5998) => q(sfw),
      q(5999) => q(sgb),
      q(6000) => q(sgc),
      q(6001) => q(sgd),
      q(6002) => q(sge),
      q(6003) => q(sgg),
      q(6004) => q(sgh),
      q(6005) => q(sgi),
      q(6006) => q(sgj),
      q(6007) => q(sgk),
      q(6008) => q(sgm),
      q(6009) => q(sgo),
      q(6010) => q(sgp),
      q(6011) => q(sgr),
      q(6012) => q(sgs),
      q(6013) => q(sgt),
      q(6014) => q(sgu),
      q(6015) => q(sgw),
      q(6016) => q(sgx),
      q(6017) => q(sgy),
      q(6018) => q(sgz),
      q(6019) => q(sha),
      q(6020) => q(shb),
      q(6021) => q(shc),
      q(6022) => q(shd),
      q(6023) => q(she),
      q(6024) => q(shg),
      q(6025) => q(shh),
      q(6026) => q(shi),
      q(6027) => q(shj),
      q(6028) => q(shk),
      q(6029) => q(shl),
      q(6030) => q(shm),
      q(6031) => q(sho),
      q(6032) => q(shp),
      q(6033) => q(shq),
      q(6034) => q(shr),
      q(6035) => q(shs),
      q(6036) => q(sht),
      q(6037) => q(shu),
      q(6038) => q(shv),
      q(6039) => q(shw),
      q(6040) => q(shx),
      q(6041) => q(shy),
      q(6042) => q(shz),
      q(6043) => q(sia),
      q(6044) => q(sib),
      q(6045) => q(sie),
      q(6046) => q(sif),
      q(6047) => q(sig),
      q(6048) => q(sih),
      q(6049) => q(sii),
      q(6050) => q(sij),
      q(6051) => q(sik),
      q(6052) => q(sil),
      q(6053) => q(sim),
      q(6054) => q(sip),
      q(6055) => q(siq),
      q(6056) => q(sir),
      q(6057) => q(sis),
      q(6058) => q(siu),
      q(6059) => q(siv),
      q(6060) => q(siw),
      q(6061) => q(six),
      q(6062) => q(siy),
      q(6063) => q(siz),
      q(6064) => q(sja),
      q(6065) => q(sjb),
      q(6066) => q(sjd),
      q(6067) => q(sje),
      q(6068) => q(sjg),
      q(6069) => q(sjk),
      q(6070) => q(sjl),
      q(6071) => q(sjm),
      q(6072) => q(sjn),
      q(6073) => q(sjo),
      q(6074) => q(sjp),
      q(6075) => q(sjr),
      q(6076) => q(sjs),
      q(6077) => q(sjt),
      q(6078) => q(sju),
      q(6079) => q(sjw),
      q(6080) => q(ska),
      q(6081) => q(skb),
      q(6082) => q(skc),
      q(6083) => q(skd),
      q(6084) => q(ske),
      q(6085) => q(skf),
      q(6086) => q(skg),
      q(6087) => q(skh),
      q(6088) => q(ski),
      q(6089) => q(skj),
      q(6090) => q(skk),
      q(6091) => q(skm),
      q(6092) => q(skn),
      q(6093) => q(sko),
      q(6094) => q(skp),
      q(6095) => q(skq),
      q(6096) => q(skr),
      q(6097) => q(sks),
      q(6098) => q(skt),
      q(6099) => q(sku),
      q(6100) => q(skv),
      q(6101) => q(skw),
      q(6102) => q(skx),
      q(6103) => q(sky),
      q(6104) => q(skz),
      q(6105) => q(sld),
      q(6106) => q(sle),
      q(6107) => q(slf),
      q(6108) => q(slg),
      q(6109) => q(slh),
      q(6110) => q(sli),
      q(6111) => q(slj),
      q(6112) => q(sll),
      q(6113) => q(slm),
      q(6114) => q(sln),
      q(6115) => q(slp),
      q(6116) => q(slq),
      q(6117) => q(slr),
      q(6118) => q(sls),
      q(6119) => q(slt),
      q(6120) => q(slu),
      q(6121) => q(slw),
      q(6122) => q(slx),
      q(6123) => q(sly),
      q(6124) => q(slz),
      q(6125) => q(smb),
      q(6126) => q(smc),
      q(6127) => q(smd),
      q(6128) => q(smf),
      q(6129) => q(smg),
      q(6130) => q(smh),
      q(6131) => q(smk),
      q(6132) => q(sml),
      q(6133) => q(smm),
      q(6134) => q(smp),
      q(6135) => q(smq),
      q(6136) => q(smr),
      q(6137) => q(smt),
      q(6138) => q(smu),
      q(6139) => q(smv),
      q(6140) => q(smw),
      q(6141) => q(smx),
      q(6142) => q(smy),
      q(6143) => q(smz),
      q(6144) => q(snb),
      q(6145) => q(snc),
      q(6146) => q(sne),
      q(6147) => q(snf),
      q(6148) => q(sng),
      q(6149) => q(snh),
      q(6150) => q(sni),
      q(6151) => q(snj),
      q(6152) => q(snl),
      q(6153) => q(snm),
      q(6154) => q(snn),
      q(6155) => q(sno),
      q(6156) => q(snp),
      q(6157) => q(snq),
      q(6158) => q(snr),
      q(6159) => q(sns),
      q(6160) => q(snu),
      q(6161) => q(snv),
      q(6162) => q(snw),
      q(6163) => q(snx),
      q(6164) => q(sny),
      q(6165) => q(snz),
      q(6166) => q(soa),
      q(6167) => q(sob),
      q(6168) => q(soc),
      q(6169) => q(sod),
      q(6170) => q(soe),
      q(6171) => q(soh),
      q(6172) => q(soi),
      q(6173) => q(soj),
      q(6174) => q(sok),
      q(6175) => q(sol),
      q(6176) => q(soo),
      q(6177) => q(sop),
      q(6178) => q(soq),
      q(6179) => q(sor),
      q(6180) => q(sos),
      q(6181) => q(sou),
      q(6182) => q(sov),
      q(6183) => q(sow),
      q(6184) => q(sox),
      q(6185) => q(soy),
      q(6186) => q(soz),
      q(6187) => q(spb),
      q(6188) => q(spc),
      q(6189) => q(spd),
      q(6190) => q(spe),
      q(6191) => q(spg),
      q(6192) => q(spi),
      q(6193) => q(spk),
      q(6194) => q(spl),
      q(6195) => q(spm),
      q(6196) => q(spo),
      q(6197) => q(spp),
      q(6198) => q(spq),
      q(6199) => q(spr),
      q(6200) => q(sps),
      q(6201) => q(spt),
      q(6202) => q(spu),
      q(6203) => q(spv),
      q(6204) => q(spx),
      q(6205) => q(spy),
      q(6206) => q(sqa),
      q(6207) => q(sqh),
      q(6208) => q(sqk),
      q(6209) => q(sqm),
      q(6210) => q(sqn),
      q(6211) => q(sqo),
      q(6212) => q(sqq),
      q(6213) => q(sqr),
      q(6214) => q(sqs),
      q(6215) => q(sqt),
      q(6216) => q(squ),
      q(6217) => q(sra),
      q(6218) => q(srb),
      q(6219) => q(src),
      q(6220) => q(sre),
      q(6221) => q(srf),
      q(6222) => q(srg),
      q(6223) => q(srh),
      q(6224) => q(sri),
      q(6225) => q(srk),
      q(6226) => q(srl),
      q(6227) => q(srm),
      q(6228) => q(sro),
      q(6229) => q(srq),
      q(6230) => q(srs),
      q(6231) => q(srt),
      q(6232) => q(sru),
      q(6233) => q(srv),
      q(6234) => q(srw),
      q(6235) => q(srx),
      q(6236) => q(sry),
      q(6237) => q(srz),
      q(6238) => q(ssb),
      q(6239) => q(ssc),
      q(6240) => q(ssd),
      q(6241) => q(sse),
      q(6242) => q(ssf),
      q(6243) => q(ssg),
      q(6244) => q(ssh),
      q(6245) => q(ssi),
      q(6246) => q(ssj),
      q(6247) => q(ssk),
      q(6248) => q(ssl),
      q(6249) => q(ssm),
      q(6250) => q(ssn),
      q(6251) => q(sso),
      q(6252) => q(ssp),
      q(6253) => q(ssq),
      q(6254) => q(ssr),
      q(6255) => q(sss),
      q(6256) => q(sst),
      q(6257) => q(ssu),
      q(6258) => q(ssv),
      q(6259) => q(ssx),
      q(6260) => q(ssy),
      q(6261) => q(ssz),
      q(6262) => q(sta),
      q(6263) => q(stb),
      q(6264) => q(std),
      q(6265) => q(ste),
      q(6266) => q(stf),
      q(6267) => q(stg),
      q(6268) => q(sth),
      q(6269) => q(sti),
      q(6270) => q(stj),
      q(6271) => q(stk),
      q(6272) => q(stl),
      q(6273) => q(stm),
      q(6274) => q(stn),
      q(6275) => q(sto),
      q(6276) => q(stp),
      q(6277) => q(stq),
      q(6278) => q(str),
      q(6279) => q(sts),
      q(6280) => q(stt),
      q(6281) => q(stu),
      q(6282) => q(stv),
      q(6283) => q(stw),
      q(6284) => q(sty),
      q(6285) => q(sua),
      q(6286) => q(sub),
      q(6287) => q(suc),
      q(6288) => q(sue),
      q(6289) => q(sug),
      q(6290) => q(sui),
      q(6291) => q(suj),
      q(6292) => q(suq),
      q(6293) => q(sur),
      q(6294) => q(sut),
      q(6295) => q(suv),
      q(6296) => q(suw),
      q(6297) => q(suy),
      q(6298) => q(suz),
      q(6299) => q(sva),
      q(6300) => q(svb),
      q(6301) => q(svc),
      q(6302) => q(sve),
      q(6303) => q(svk),
      q(6304) => q(svm),
      q(6305) => q(svr),
      q(6306) => q(svs),
      q(6307) => q(svx),
      q(6308) => q(swb),
      q(6309) => q(swc),
      q(6310) => q(swf),
      q(6311) => q(swg),
      q(6312) => q(swh),
      q(6313) => q(swi),
      q(6314) => q(swj),
      q(6315) => q(swk),
      q(6316) => q(swl),
      q(6317) => q(swm),
      q(6318) => q(swn),
      q(6319) => q(swo),
      q(6320) => q(swp),
      q(6321) => q(swq),
      q(6322) => q(swr),
      q(6323) => q(sws),
      q(6324) => q(swt),
      q(6325) => q(swu),
      q(6326) => q(swv),
      q(6327) => q(sww),
      q(6328) => q(swx),
      q(6329) => q(swy),
      q(6330) => q(sxb),
      q(6331) => q(sxc),
      q(6332) => q(sxe),
      q(6333) => q(sxg),
      q(6334) => q(sxk),
      q(6335) => q(sxl),
      q(6336) => q(sxm),
      q(6337) => q(sxn),
      q(6338) => q(sxo),
      q(6339) => q(sxr),
      q(6340) => q(sxs),
      q(6341) => q(sxu),
      q(6342) => q(sxw),
      q(6343) => q(sya),
      q(6344) => q(syb),
      q(6345) => q(syi),
      q(6346) => q(syk),
      q(6347) => q(syl),
      q(6348) => q(sym),
      q(6349) => q(syn),
      q(6350) => q(syo),
      q(6351) => q(sys),
      q(6352) => q(syw),
      q(6353) => q(syy),
      q(6354) => q(sza),
      q(6355) => q(szb),
      q(6356) => q(szc),
      q(6357) => q(szd),
      q(6358) => q(sze),
      q(6359) => q(szg),
      q(6360) => q(szl),
      q(6361) => q(szn),
      q(6362) => q(szp),
      q(6363) => q(szv),
      q(6364) => q(szw),
      q(6365) => q(taa),
      q(6366) => q(tab),
      q(6367) => q(tac),
      q(6368) => q(tad),
      q(6369) => q(tae),
      q(6370) => q(taf),
      q(6371) => q(tag),
      q(6372) => q(taj),
      q(6373) => q(tak),
      q(6374) => q(tal),
      q(6375) => q(tan),
      q(6376) => q(tao),
      q(6377) => q(tap),
      q(6378) => q(taq),
      q(6379) => q(tar),
      q(6380) => q(tas),
      q(6381) => q(tau),
      q(6382) => q(tav),
      q(6383) => q(taw),
      q(6384) => q(tax),
      q(6385) => q(tay),
      q(6386) => q(taz),
      q(6387) => q(tba),
      q(6388) => q(tbb),
      q(6389) => q(tbc),
      q(6390) => q(tbd),
      q(6391) => q(tbe),
      q(6392) => q(tbf),
      q(6393) => q(tbg),
      q(6394) => q(tbh),
      q(6395) => q(tbi),
      q(6396) => q(tbj),
      q(6397) => q(tbk),
      q(6398) => q(tbl),
      q(6399) => q(tbm),
      q(6400) => q(tbn),
      q(6401) => q(tbo),
      q(6402) => q(tbp),
      q(6403) => q(tbr),
      q(6404) => q(tbs),
      q(6405) => q(tbt),
      q(6406) => q(tbu),
      q(6407) => q(tbv),
      q(6408) => q(tbw),
      q(6409) => q(tbx),
      q(6410) => q(tby),
      q(6411) => q(tbz),
      q(6412) => q(tca),
      q(6413) => q(tcb),
      q(6414) => q(tcc),
      q(6415) => q(tcd),
      q(6416) => q(tce),
      q(6417) => q(tcf),
      q(6418) => q(tcg),
      q(6419) => q(tch),
      q(6420) => q(wbf),
      q(6421) => q(tck),
      q(6422) => q(tcl),
      q(6423) => q(tcm),
      q(6424) => q(tcn),
      q(6425) => q(tco),
      q(6426) => q(tcp),
      q(6427) => q(tcq),
      q(6428) => q(tcs),
      q(6429) => q(tct),
      q(6430) => q(tcu),
      q(6431) => q(tcw),
      q(6432) => q(tcx),
      q(6433) => q(tcy),
      q(6434) => q(tcz),
      q(6435) => q(tda),
      q(6436) => q(tdb),
      q(6437) => q(tdc),
      q(6438) => q(tdd),
      q(6439) => q(tde),
      q(6440) => q(tdf),
      q(6441) => q(tdg),
      q(6442) => q(tdh),
      q(6443) => q(tdi),
      q(6444) => q(tdj),
      q(6445) => q(tdk),
      q(6446) => q(tdl),
      q(6447) => q(tdn),
      q(6448) => q(tdo),
      q(6449) => q(tdq),
      q(6450) => q(tdr),
      q(6451) => q(tds),
      q(6452) => q(tdt),
      q(6453) => q(tdu),
      q(6454) => q(tdv),
      q(6455) => q(tdx),
      q(6456) => q(tdy),
      q(6457) => q(tea),
      q(6458) => q(teb),
      q(6459) => q(tec),
      q(6460) => q(ted),
      q(6461) => q(tee),
      q(6462) => q(tef),
      q(6463) => q(teg),
      q(6464) => q(teh),
      q(6465) => q(tei),
      q(6466) => q(tek),
      q(6467) => q(ten),
      q(6468) => q(teo),
      q(6469) => q(tep),
      q(6470) => q(teq),
      q(6471) => q(tes),
      q(6472) => q(teu),
      q(6473) => q(tev),
      q(6474) => q(tew),
      q(6475) => q(tex),
      q(6476) => q(tey),
      q(6477) => q(tfi),
      q(6478) => q(tfn),
      q(6479) => q(tfo),
      q(6480) => q(tfr),
      q(6481) => q(tft),
      q(6482) => q(tga),
      q(6483) => q(tgb),
      q(6484) => q(tgc),
      q(6485) => q(tgd),
      q(6486) => q(tge),
      q(6487) => q(tgf),
      q(6488) => q(tgh),
      q(6489) => q(tgi),
      q(6490) => q(tgj),
      q(6491) => q(tgn),
      q(6492) => q(tgo),
      q(6493) => q(tgp),
      q(6494) => q(tgq),
      q(6495) => q(tgr),
      q(6496) => q(tgs),
      q(6497) => q(tgt),
      q(6498) => q(tgu),
      q(6499) => q(tgv),
      q(6500) => q(tgw),
      q(6501) => q(tgx),
      q(6502) => q(tgy),
      q(6503) => q(tgz),
      q(6504) => q(thc),
      q(6505) => q(thd),
      q(6506) => q(the),
      q(6507) => q(thf),
      q(6508) => q(thh),
      q(6509) => q(thi),
      q(6510) => q(thk),
      q(6511) => q(thl),
      q(6512) => q(thm),
      q(6513) => q(thn),
      q(6514) => q(thp),
      q(6515) => q(thq),
      q(6516) => q(thr),
      q(6517) => q(ths),
      q(6518) => q(tht),
      q(6519) => q(thu),
      q(6520) => q(thv),
      q(6521) => q(thw),
      q(6522) => q(thx),
      q(6523) => q(thy),
      q(6524) => q(thz),
      q(6525) => q(tia),
      q(6526) => q(tic),
      q(6527) => q(tid),
      q(6528) => q(tif),
      q(6529) => q(tih),
      q(6530) => q(tii),
      q(6531) => q(tij),
      q(6532) => q(tik),
      q(6533) => q(til),
      q(6534) => q(tim),
      q(6535) => q(tin),
      q(6536) => q(tio),
      q(6537) => q(tip),
      q(6538) => q(tiq),
      q(6539) => q(tis),
      q(6540) => q(tit),
      q(6541) => q(tiu),
      q(6542) => q(tiw),
      q(6543) => q(tix),
      q(6544) => q(tiy),
      q(6545) => q(tiz),
      q(6546) => q(tja),
      q(6547) => q(tjg),
      q(6548) => q(tji),
      q(6549) => q(tjl),
      q(6550) => q(tjm),
      q(6551) => q(tjn),
      q(6552) => q(tjo),
      q(6553) => q(tjs),
      q(6554) => q(tju),
      q(6555) => q(tjw),
      q(6556) => q(tka),
      q(6557) => q(tkb),
      q(6558) => q(tkd),
      q(6559) => q(tke),
      q(6560) => q(tkf),
      q(6561) => q(tkg),
      q(6562) => q(tkm),
      q(6563) => q(tkn),
      q(6564) => q(tkp),
      q(6565) => q(tkq),
      q(6566) => q(tkr),
      q(6567) => q(tks),
      q(6568) => q(tkt),
      q(6569) => q(tku),
      q(6570) => q(tkw),
      q(6571) => q(tkx),
      q(6572) => q(tkz),
      q(6573) => q(tla),
      q(6574) => q(tlb),
      q(6575) => q(tlc),
      q(6576) => q(tld),
      q(6577) => q(tlf),
      q(6578) => q(tlg),
      q(6579) => q(tlj),
      q(6580) => q(tlk),
      q(6581) => q(tll),
      q(6582) => q(tlm),
      q(6583) => q(tln),
      q(6584) => q(tlo),
      q(6585) => q(tlp),
      q(6586) => q(tlq),
      q(6587) => q(tlr),
      q(6588) => q(tls),
      q(6589) => q(tlt),
      q(6590) => q(tlu),
      q(6591) => q(tlv),
      q(6592) => q(tlx),
      q(6593) => q(tly),
      q(6594) => q(tma),
      q(6595) => q(tmb),
      q(6596) => q(tmc),
      q(6597) => q(tmd),
      q(6598) => q(tme),
      q(6599) => q(tmf),
      q(6600) => q(tmg),
      q(6601) => q(tmi),
      q(6602) => q(tmj),
      q(6603) => q(tmk),
      q(6604) => q(tml),
      q(6605) => q(tmm),
      q(6606) => q(tmn),
      q(6607) => q(tmo),
      q(6608) => q(tmp),
      q(6609) => q(tmq),
      q(6610) => q(tmr),
      q(6611) => q(tms),
      q(6612) => q(tmt),
      q(6613) => q(tmu),
      q(6614) => q(tmv),
      q(6615) => q(tmw),
      q(6616) => q(tmy),
      q(6617) => q(tmz),
      q(6618) => q(tna),
      q(6619) => q(tnb),
      q(6620) => q(tnc),
      q(6621) => q(tnd),
      q(6622) => q(tne),
      q(6623) => q(tng),
      q(6624) => q(tnh),
      q(6625) => q(tni),
      q(6626) => q(tnk),
      q(6627) => q(tnl),
      q(6628) => q(tnm),
      q(6629) => q(tnn),
      q(6630) => q(tno),
      q(6631) => q(tnp),
      q(6632) => q(tnq),
      q(6633) => q(tnr),
      q(6634) => q(tns),
      q(6635) => q(tnt),
      q(6636) => q(tnu),
      q(6637) => q(tnv),
      q(6638) => q(tnw),
      q(6639) => q(tnx),
      q(6640) => q(tny),
      q(6641) => q(tnz),
      q(6642) => q(tob),
      q(6643) => q(toc),
      q(6644) => q(tod),
      q(6645) => q(toe),
      q(6646) => q(tof),
      q(6647) => q(toh),
      q(6648) => q(toi),
      q(6649) => q(toj),
      q(6650) => q(tol),
      q(6651) => q(tom),
      q(6652) => q(too),
      q(6653) => q(top),
      q(6654) => q(toq),
      q(6655) => q(tor),
      q(6656) => q(tos),
      q(6657) => q(tou),
      q(6658) => q(tov),
      q(6659) => q(tow),
      q(6660) => q(tox),
      q(6661) => q(toy),
      q(6662) => q(toz),
      q(6663) => q(tpa),
      q(6664) => q(tpc),
      q(6665) => q(tpe),
      q(6666) => q(tpf),
      q(6667) => q(tpg),
      q(6668) => q(tpj),
      q(6669) => q(tpk),
      q(6670) => q(tpl),
      q(6671) => q(tpm),
      q(6672) => q(tpn),
      q(6673) => q(tpo),
      q(6674) => q(tpp),
      q(6675) => q(tpq),
      q(6676) => q(tpr),
      q(6677) => q(tpt),
      q(6678) => q(tpu),
      q(6679) => q(tpv),
      q(6680) => q(tpw),
      q(6681) => q(tpx),
      q(6682) => q(tpy),
      q(6683) => q(tpz),
      q(6684) => q(tqb),
      q(6685) => q(tql),
      q(6686) => q(tqm),
      q(6687) => q(tqn),
      q(6688) => q(tqo),
      q(6689) => q(tqp),
      q(6690) => q(tqq),
      q(6691) => q(tqr),
      q(6692) => q(tqt),
      q(6693) => q(tqu),
      q(6694) => q(tqw),
      q(6695) => q(tra),
      q(6696) => q(trb),
      q(6697) => q(trc),
      q(6698) => q(trd),
      q(6699) => q(tre),
      q(6700) => q(trf),
      q(6701) => q(trg),
      q(6702) => q(trh),
      q(6703) => q(tri),
      q(6704) => q(trj),
      q(6705) => q(trl),
      q(6706) => q(trm),
      q(6707) => q(trn),
      q(6708) => q(tro),
      q(6709) => q(trp),
      q(6710) => q(trq),
      q(6711) => q(trr),
      q(6712) => q(trs),
      q(6713) => q(trt),
      q(6714) => q(tru),
      q(6715) => q(trv),
      q(6716) => q(trw),
      q(6717) => q(trx),
      q(6718) => q(try),
      q(6719) => q(trz),
      q(6720) => q(tsa),
      q(6721) => q(tsb),
      q(6722) => q(tsc),
      q(6723) => q(tsd),
      q(6724) => q(tse),
      q(6725) => q(tsf),
      q(6726) => q(tsg),
      q(6727) => q(tsh),
      q(6728) => q(tsj),
      q(6729) => q(tsk),
      q(6730) => q(tsl),
      q(6731) => q(tsm),
      q(6732) => q(tsp),
      q(6733) => q(tsq),
      q(6734) => q(tsr),
      q(6735) => q(tss),
      q(6736) => q(tst),
      q(6737) => q(tsu),
      q(6738) => q(tsv),
      q(6739) => q(tsw),
      q(6740) => q(tsx),
      q(6741) => q(tsy),
      q(6742) => q(tsz),
      q(6743) => q(tta),
      q(6744) => q(ttb),
      q(6745) => q(ttc),
      q(6746) => q(ttd),
      q(6747) => q(tte),
      q(6748) => q(ttf),
      q(6749) => q(ttg),
      q(6750) => q(tth),
      q(6751) => q(tti),
      q(6752) => q(ttj),
      q(6753) => q(ttk),
      q(6754) => q(ttl),
      q(6755) => q(ttm),
      q(6756) => q(ttn),
      q(6757) => q(tto),
      q(6758) => q(ttp),
      q(6759) => q(ttq),
      q(6760) => q(ttr),
      q(6761) => q(tts),
      q(6762) => q(ttt),
      q(6763) => q(ttu),
      q(6764) => q(ttv),
      q(6765) => q(ttw),
      q(6766) => q(tty),
      q(6767) => q(ttz),
      q(6768) => q(tua),
      q(6769) => q(tub),
      q(6770) => q(tuc),
      q(6771) => q(tud),
      q(6772) => q(tue),
      q(6773) => q(tuf),
      q(6774) => q(tug),
      q(6775) => q(tuh),
      q(6776) => q(tui),
      q(6777) => q(tuj),
      q(6778) => q(tul),
      q(6779) => q(tun),
      q(6780) => q(tuo),
      q(6781) => q(tuq),
      q(6782) => q(tus),
      q(6783) => q(tuu),
      q(6784) => q(tuv),
      q(6785) => q(tux),
      q(6786) => q(tuy),
      q(6787) => q(tuz),
      q(6788) => q(tva),
      q(6789) => q(tvd),
      q(6790) => q(tve),
      q(6791) => q(tvk),
      q(6792) => q(tvm),
      q(6793) => q(tvn),
      q(6794) => q(tvo),
      q(6795) => q(tvs),
      q(6796) => q(tvt),
      q(6797) => q(tvu),
      q(6798) => q(tvw),
      q(6799) => q(tvy),
      q(6800) => q(twa),
      q(6801) => q(twb),
      q(6802) => q(twc),
      q(6803) => q(twd),
      q(6804) => q(twe),
      q(6805) => q(twf),
      q(6806) => q(twg),
      q(6807) => q(twh),
      q(6808) => q(twl),
      q(6809) => q(twm),
      q(6810) => q(twn),
      q(6811) => q(two),
      q(6812) => q(twp),
      q(6813) => q(twq),
      q(6814) => q(twr),
      q(6815) => q(twt),
      q(6816) => q(twu),
      q(6817) => q(tww),
      q(6818) => q(twx),
      q(6819) => q(twy),
      q(6820) => q(txa),
      q(6821) => q(txb),
      q(6822) => q(txc),
      q(6823) => q(txe),
      q(6824) => q(txg),
      q(6825) => q(txh),
      q(6826) => q(txi),
      q(6827) => q(txm),
      q(6828) => q(txn),
      q(6829) => q(txo),
      q(6830) => q(txq),
      q(6831) => q(txr),
      q(6832) => q(txs),
      q(6833) => q(txt),
      q(6834) => q(txu),
      q(6835) => q(txx),
      q(6836) => q(txy),
      q(6837) => q(tya),
      q(6838) => q(tye),
      q(6839) => q(tyh),
      q(6840) => q(tyi),
      q(6841) => q(tyj),
      q(6842) => q(tyl),
      q(6843) => q(tyn),
      q(6844) => q(typ),
      q(6845) => q(tyr),
      q(6846) => q(tys),
      q(6847) => q(tyt),
      q(6848) => q(tyu),
      q(6849) => q(tyx),
      q(6850) => q(tyz),
      q(6851) => q(tza),
      q(6852) => q(tzh),
      q(6853) => q(tzj),
      q(6854) => q(tzl),
      q(6855) => q(tzm),
      q(6856) => q(tzn),
      q(6857) => q(tzo),
      q(6858) => q(tzx),
      q(6859) => q(uam),
      q(6860) => q(uan),
      q(6861) => q(uar),
      q(6862) => q(uba),
      q(6863) => q(ubi),
      q(6864) => q(ubl),
      q(6865) => q(ubr),
      q(6866) => q(ubu),
      q(6867) => q(uby),
      q(6868) => q(uda),
      q(6869) => q(ude),
      q(6870) => q(udg),
      q(6871) => q(udi),
      q(6872) => q(udj),
      q(6873) => q(udl),
      q(6874) => q(udu),
      q(6875) => q(ues),
      q(6876) => q(ufi),
      q(6877) => q(ugb),
      q(6878) => q(uge),
      q(6879) => q(ugn),
      q(6880) => q(ugo),
      q(6881) => q(ugy),
      q(6882) => q(uha),
      q(6883) => q(uhn),
      q(6884) => q(uis),
      q(6885) => q(uiv),
      q(6886) => q(uji),
      q(6887) => q(uka),
      q(6888) => q(ukg),
      q(6889) => q(ukh),
      q(6890) => q(ukl),
      q(6891) => q(ukp),
      q(6892) => q(ukq),
      q(6893) => q(uks),
      q(6894) => q(uku),
      q(6895) => q(ukw),
      q(6896) => q(uky),
      q(6897) => q(ula),
      q(6898) => q(ulb),
      q(6899) => q(ulc),
      q(6900) => q(ule),
      q(6901) => q(ulf),
      q(6902) => q(uli),
      q(6903) => q(ulk),
      q(6904) => q(ull),
      q(6905) => q(ulm),
      q(6906) => q(uln),
      q(6907) => q(ulu),
      q(6908) => q(ulw),
      q(6909) => q(uma),
      q(6910) => q(umc),
      q(6911) => q(umd),
      q(6912) => q(umg),
      q(6913) => q(umi),
      q(6914) => q(umm),
      q(6915) => q(umn),
      q(6916) => q(umo),
      q(6917) => q(ump),
      q(6918) => q(umr),
      q(6919) => q(ums),
      q(6920) => q(umu),
      q(6921) => q(una),
      q(6922) => q(une),
      q(6923) => q(ung),
      q(6924) => q(unk),
      q(6925) => q(unm),
      q(6926) => q(unn),
      q(6927) => q(unr),
      q(6928) => q(unu),
      q(6929) => q(unx),
      q(6930) => q(unz),
      q(6931) => q(uok),
      q(6932) => q(upi),
      q(6933) => q(upv),
      q(6934) => q(ura),
      q(6935) => q(urb),
      q(6936) => q(urc),
      q(6937) => q(ure),
      q(6938) => q(urf),
      q(6939) => q(urg),
      q(6940) => q(urh),
      q(6941) => q(uri),
      q(6942) => q(urk),
      q(6943) => q(url),
      q(6944) => q(urm),
      q(6945) => q(urn),
      q(6946) => q(uro),
      q(6947) => q(urp),
      q(6948) => q(urr),
      q(6949) => q(urt),
      q(6950) => q(uru),
      q(6951) => q(urv),
      q(6952) => q(urw),
      q(6953) => q(urx),
      q(6954) => q(ury),
      q(6955) => q(urz),
      q(6956) => q(usa),
      q(6957) => q(ush),
      q(6958) => q(usi),
      q(6959) => q(usk),
      q(6960) => q(usp),
      q(6961) => q(usu),
      q(6962) => q(uta),
      q(6963) => q(ute),
      q(6964) => q(utp),
      q(6965) => q(utr),
      q(6966) => q(utu),
      q(6967) => q(uum),
      q(6968) => q(uun),
      q(6969) => q(uur),
      q(6970) => q(uuu),
      q(6971) => q(uve),
      q(6972) => q(uvh),
      q(6973) => q(uvl),
      q(6974) => q(uwa),
      q(6975) => q(uya),
      q(6976) => q(uzn),
      q(6977) => q(uzs),
      q(6978) => q(vaa),
      q(6979) => q(vae),
      q(6980) => q(vaf),
      q(6981) => q(vag),
      q(6982) => q(vah),
      q(6983) => q(vaj),
      q(6984) => q(val),
      q(6985) => q(vam),
      q(6986) => q(van),
      q(6987) => q(vao),
      q(6988) => q(vap),
      q(6989) => q(var),
      q(6990) => q(vas),
      q(6991) => q(vau),
      q(6992) => q(vav),
      q(6993) => q(vay),
      q(6994) => q(vbb),
      q(6995) => q(vbk),
      q(6996) => q(vec),
      q(6997) => q(ved),
      q(6998) => q(vel),
      q(6999) => q(vem),
      q(7000) => q(veo),
      q(7001) => q(vep),
      q(7002) => q(ver),
      q(7003) => q(vgr),
      q(7004) => q(vgt),
      q(7005) => q(vic),
      q(7006) => q(vid),
      q(7007) => q(vif),
      q(7008) => q(vig),
      q(7009) => q(vil),
      q(7010) => q(vin),
      q(7011) => q(vis),
      q(7012) => q(vit),
      q(7013) => q(viv),
      q(7014) => q(vka),
      q(7015) => q(vki),
      q(7016) => q(vkj),
      q(7017) => q(vkk),
      q(7018) => q(vkl),
      q(7019) => q(vkm),
      q(7020) => q(vko),
      q(7021) => q(vkp),
      q(7022) => q(vkt),
      q(7023) => q(vku),
      q(7024) => q(vlp),
      q(7025) => q(vls),
      q(7026) => q(vma),
      q(7027) => q(vmb),
      q(7028) => q(vmc),
      q(7029) => q(vmd),
      q(7030) => q(vme),
      q(7031) => q(vmf),
      q(7032) => q(vmg),
      q(7033) => q(vmh),
      q(7034) => q(vmi),
      q(7035) => q(vmj),
      q(7036) => q(vmk),
      q(7037) => q(vml),
      q(7038) => q(vmm),
      q(7039) => q(vmp),
      q(7040) => q(vmq),
      q(7041) => q(vmr),
      q(7042) => q(vms),
      q(7043) => q(vmu),
      q(7044) => q(vmv),
      q(7045) => q(vmw),
      q(7046) => q(vmx),
      q(7047) => q(vmy),
      q(7048) => q(vmz),
      q(7049) => q(vnk),
      q(7050) => q(vnm),
      q(7051) => q(vnp),
      q(7052) => q(vro),
      q(7053) => q(vra),
      q(7054) => q(vrs),
      q(7055) => q(vrt),
      q(7056) => q(vsi),
      q(7057) => q(vsl),
      q(7058) => q(vsv),
      q(7059) => q(vto),
      q(7060) => q(vum),
      q(7061) => q(vun),
      q(7062) => q(vut),
      q(7063) => q(vwa),
      q(7064) => q(waa),
      q(7065) => q(wab),
      q(7066) => q(wac),
      q(7067) => q(wad),
      q(7068) => q(wae),
      q(7069) => q(waf),
      q(7070) => q(wag),
      q(7071) => q(wah),
      q(7072) => q(wai),
      q(7073) => q(waj),
      q(7074) => q(wam),
      q(7075) => q(wan),
      q(7076) => q(wao),
      q(7077) => q(wap),
      q(7078) => q(waq),
      q(7079) => q(wat),
      q(7080) => q(wau),
      q(7081) => q(wav),
      q(7082) => q(waw),
      q(7083) => q(wax),
      q(7084) => q(way),
      q(7085) => q(waz),
      q(7086) => q(wba),
      q(7087) => q(wbb),
      q(7088) => q(wbe),
      q(7089) => q(wbh),
      q(7090) => q(wbi),
      q(7091) => q(wbj),
      q(7092) => q(wbk),
      q(7093) => q(wbl),
      q(7094) => q(wbm),
      q(7095) => q(wbp),
      q(7096) => q(wbq),
      q(7097) => q(wbr),
      q(7098) => q(wbt),
      q(7099) => q(wbv),
      q(7100) => q(wbw),
      q(7101) => q(wca),
      q(7102) => q(wci),
      q(7103) => q(wdd),
      q(7104) => q(wdg),
      q(7105) => q(wdj),
      q(7106) => q(wdk),
      q(7107) => q(wdu),
      q(7108) => q(wdy),
      q(7109) => q(wea),
      q(7110) => q(wec),
      q(7111) => q(wed),
      q(7112) => q(weg),
      q(7113) => q(weh),
      q(7114) => q(wei),
      q(7115) => q(wem),
      q(7116) => q(weo),
      q(7117) => q(wep),
      q(7118) => q(wer),
      q(7119) => q(wes),
      q(7120) => q(wet),
      q(7121) => q(weu),
      q(7122) => q(wew),
      q(7123) => q(wfg),
      q(7124) => q(wga),
      q(7125) => q(wgb),
      q(7126) => q(wgg),
      q(7127) => q(wgi),
      q(7128) => q(wgo),
      q(7129) => q(wgu),
      q(7130) => q(wgy),
      q(7131) => q(wha),
      q(7132) => q(whg),
      q(7133) => q(whk),
      q(7134) => q(whu),
      q(7135) => q(wib),
      q(7136) => q(wic),
      q(7137) => q(wie),
      q(7138) => q(wif),
      q(7139) => q(wig),
      q(7140) => q(wih),
      q(7141) => q(wii),
      q(7142) => q(wij),
      q(7143) => q(wik),
      q(7144) => q(wil),
      q(7145) => q(wim),
      q(7146) => q(win),
      q(7147) => q(wir),
      q(7148) => q(wiu),
      q(7149) => q(wiv),
      q(7150) => q(wiy),
      q(7151) => q(wja),
      q(7152) => q(wji),
      q(7153) => q(wka),
      q(7154) => q(wkb),
      q(7155) => q(wkd),
      q(7156) => q(wkl),
      q(7157) => q(wku),
      q(7158) => q(wkw),
      q(7159) => q(wky),
      q(7160) => q(wla),
      q(7161) => q(wlc),
      q(7162) => q(wle),
      q(7163) => q(wlg),
      q(7164) => q(wli),
      q(7165) => q(wlk),
      q(7166) => q(wll),
      q(7167) => q(wlm),
      q(7168) => q(wlo),
      q(7169) => q(wlr),
      q(7170) => q(wls),
      q(7171) => q(wlu),
      q(7172) => q(wlv),
      q(7173) => q(wlw),
      q(7174) => q(wlx),
      q(7175) => q(wly),
      q(7176) => q(wma),
      q(7177) => q(wmb),
      q(7178) => q(wmc),
      q(7179) => q(wmd),
      q(7180) => q(wme),
      q(7181) => q(wmh),
      q(7182) => q(wmi),
      q(7183) => q(wmm),
      q(7184) => q(wmn),
      q(7185) => q(wmo),
      q(7186) => q(wms),
      q(7187) => q(wmt),
      q(7188) => q(wmw),
      q(7189) => q(wmx),
      q(7190) => q(wnb),
      q(7191) => q(wnc),
      q(7192) => q(wnd),
      q(7193) => q(wne),
      q(7194) => q(wng),
      q(7195) => q(wni),
      q(7196) => q(wnk),
      q(7197) => q(wnm),
      q(7198) => q(wnn),
      q(7199) => q(wno),
      q(7200) => q(wnp),
      q(7201) => q(wnu),
      q(7202) => q(wnw),
      q(7203) => q(wny),
      q(7204) => q(woa),
      q(7205) => q(wob),
      q(7206) => q(woc),
      q(7207) => q(wod),
      q(7208) => q(woe),
      q(7209) => q(wof),
      q(7210) => q(wog),
      q(7211) => q(woi),
      q(7212) => q(wok),
      q(7213) => q(wom),
      q(7214) => q(won),
      q(7215) => q(woo),
      q(7216) => q(wor),
      q(7217) => q(wos),
      q(7218) => q(wow),
      q(7219) => q(woy),
      q(7220) => q(wpc),
      q(7221) => q(wra),
      q(7222) => q(wrb),
      q(7223) => q(wrd),
      q(7224) => q(wrg),
      q(7225) => q(wrh),
      q(7226) => q(wri),
      q(7227) => q(wrk),
      q(7228) => q(wrl),
      q(7229) => q(wrm),
      q(7230) => q(wrn),
      q(7231) => q(wro),
      q(7232) => q(wrp),
      q(7233) => q(wrr),
      q(7234) => q(wrs),
      q(7235) => q(wru),
      q(7236) => q(wrv),
      q(7237) => q(wrw),
      q(7238) => q(wrx),
      q(7239) => q(wry),
      q(7240) => q(wrz),
      q(7241) => q(wsa),
      q(7242) => q(wsi),
      q(7243) => q(wsk),
      q(7244) => q(wsr),
      q(7245) => q(wss),
      q(7246) => q(wsu),
      q(7247) => q(wsv),
      q(7248) => q(wtf),
      q(7249) => q(wth),
      q(7250) => q(wti),
      q(7251) => q(wtk),
      q(7252) => q(wtm),
      q(7253) => q(wtw),
      q(7254) => q(wua),
      q(7255) => q(wub),
      q(7256) => q(wud),
      q(7257) => q(wuh),
      q(7258) => q(wul),
      q(7259) => q(wum),
      q(7260) => q(wun),
      q(7261) => q(wur),
      q(7262) => q(wut),
      q(7263) => q(wuu),
      q(7264) => q(wuv),
      q(7265) => q(wux),
      q(7266) => q(wuy),
      q(7267) => q(wwa),
      q(7268) => q(wwb),
      q(7269) => q(wwo),
      q(7270) => q(wwr),
      q(7271) => q(www),
      q(7272) => q(wxa),
      q(7273) => q(wxw),
      q(7274) => q(wya),
      q(7275) => q(wyb),
      q(7276) => q(wyi),
      q(7277) => q(wym),
      q(7278) => q(wyr),
      q(7279) => q(wyy),
      q(7280) => q(xaa),
      q(7281) => q(xab),
      q(7282) => q(xac),
      q(7283) => q(xad),
      q(7284) => q(xae),
      q(7285) => q(xag),
      q(7286) => q(xai),
      q(7287) => q(xam),
      q(7288) => q(xan),
      q(7289) => q(xao),
      q(7290) => q(xap),
      q(7291) => q(xaq),
      q(7292) => q(xar),
      q(7293) => q(xas),
      q(7294) => q(xat),
      q(7295) => q(xau),
      q(7296) => q(xav),
      q(7297) => q(xaw),
      q(7298) => q(xay),
      q(7299) => q(xba),
      q(7300) => q(xbb),
      q(7301) => q(xbc),
      q(7302) => q(xbd),
      q(7303) => q(xbe),
      q(7304) => q(xbg),
      q(7305) => q(xbi),
      q(7306) => q(xbj),
      q(7307) => q(xbm),
      q(7308) => q(xbn),
      q(7309) => q(xbo),
      q(7310) => q(xbp),
      q(7311) => q(xbr),
      q(7312) => q(xbw),
      q(7313) => q(xbx),
      q(7314) => q(xby),
      q(7315) => q(xcb),
      q(7316) => q(xcc),
      q(7317) => q(xce),
      q(7318) => q(xcg),
      q(7319) => q(xch),
      q(7320) => q(xcl),
      q(7321) => q(xcm),
      q(7322) => q(xcn),
      q(7323) => q(xco),
      q(7324) => q(xcr),
      q(7325) => q(xct),
      q(7326) => q(xcu),
      q(7327) => q(xcv),
      q(7328) => q(xcw),
      q(7329) => q(xcy),
      q(7330) => q(xda),
      q(7331) => q(xdc),
      q(7332) => q(xdk),
      q(7333) => q(xdm),
      q(7334) => q(xdy),
      q(7335) => q(xeb),
      q(7336) => q(xed),
      q(7337) => q(xeg),
      q(7338) => q(xel),
      q(7339) => q(xem),
      q(7340) => q(xep),
      q(7341) => q(xer),
      q(7342) => q(xes),
      q(7343) => q(xet),
      q(7344) => q(xeu),
      q(7345) => q(xfa),
      q(7346) => q(xga),
      q(7347) => q(xgb),
      q(7348) => q(xgd),
      q(7349) => q(xgf),
      q(7350) => q(xgg),
      q(7351) => q(xgi),
      q(7352) => q(xgl),
      q(7353) => q(xgm),
      q(7354) => q(xgr),
      q(7355) => q(xgu),
      q(7356) => q(xgw),
      q(7357) => q(xha),
      q(7358) => q(xhc),
      q(7359) => q(xhd),
      q(7360) => q(xhe),
      q(7361) => q(xhr),
      q(7362) => q(xht),
      q(7363) => q(xhu),
      q(7364) => q(xhv),
      q(7365) => q(xib),
      q(7366) => q(xii),
      q(7367) => q(xil),
      q(7368) => q(xin),
      q(7369) => q(xip),
      q(7370) => q(xir),
      q(7371) => q(xiv),
      q(7372) => q(xiy),
      q(7373) => q(xjb),
      q(7374) => q(xjt),
      q(7375) => q(xka),
      q(7376) => q(xkb),
      q(7377) => q(xkc),
      q(7378) => q(xkd),
      q(7379) => q(xke),
      q(7380) => q(xkf),
      q(7381) => q(xkg),
      q(7382) => q(xkh),
      q(7383) => q(xki),
      q(7384) => q(xkj),
      q(7385) => q(xkk),
      q(7386) => q(xkl),
      q(7387) => q(xkn),
      q(7388) => q(xko),
      q(7389) => q(xkp),
      q(7390) => q(xkq),
      q(7391) => q(xkr),
      q(7392) => q(xks),
      q(7393) => q(xkt),
      q(7394) => q(xku),
      q(7395) => q(xkv),
      q(7396) => q(xkw),
      q(7397) => q(xkx),
      q(7398) => q(xky),
      q(7399) => q(xkz),
      q(7400) => q(xla),
      q(7401) => q(xlb),
      q(7402) => q(xlc),
      q(7403) => q(xld),
      q(7404) => q(xle),
      q(7405) => q(xlg),
      q(7406) => q(xli),
      q(7407) => q(xln),
      q(7408) => q(xlo),
      q(7409) => q(xlp),
      q(7410) => q(xls),
      q(7411) => q(xlu),
      q(7412) => q(xly),
      q(7413) => q(xma),
      q(7414) => q(xmb),
      q(7415) => q(xmc),
      q(7416) => q(xmd),
      q(7417) => q(xme),
      q(7418) => q(xmf),
      q(7419) => q(xmg),
      q(7420) => q(xmh),
      q(7421) => q(xmj),
      q(7422) => q(xmk),
      q(7423) => q(xml),
      q(7424) => q(xmm),
      q(7425) => q(xmn),
      q(7426) => q(xmo),
      q(7427) => q(xmp),
      q(7428) => q(xmq),
      q(7429) => q(xmr),
      q(7430) => q(xms),
      q(7431) => q(xmt),
      q(7432) => q(xmu),
      q(7433) => q(xmv),
      q(7434) => q(xmw),
      q(7435) => q(xmx),
      q(7436) => q(xmy),
      q(7437) => q(xmz),
      q(7438) => q(xna),
      q(7439) => q(xnb),
      q(7440) => q(xng),
      q(7441) => q(xnh),
      q(7442) => q(xni),
      q(7443) => q(xnk),
      q(7444) => q(xnn),
      q(7445) => q(xno),
      q(7446) => q(xnr),
      q(7447) => q(xns),
      q(7448) => q(xnt),
      q(7449) => q(xnu),
      q(7450) => q(xny),
      q(7451) => q(xnz),
      q(7452) => q(xoc),
      q(7453) => q(xod),
      q(7454) => q(xog),
      q(7455) => q(xoi),
      q(7456) => q(xok),
      q(7457) => q(xom),
      q(7458) => q(xon),
      q(7459) => q(xoo),
      q(7460) => q(xop),
      q(7461) => q(xor),
      q(7462) => q(xow),
      q(7463) => q(xpa),
      q(7464) => q(xpc),
      q(7465) => q(xpe),
      q(7466) => q(xpg),
      q(7467) => q(xpi),
      q(7468) => q(xpj),
      q(7469) => q(xpk),
      q(7470) => q(xpm),
      q(7471) => q(xpn),
      q(7472) => q(xpo),
      q(7473) => q(xpp),
      q(7474) => q(xpq),
      q(7475) => q(xpr),
      q(7476) => q(xps),
      q(7477) => q(xpt),
      q(7478) => q(xpu),
      q(7479) => q(xpy),
      q(7480) => q(xqa),
      q(7481) => q(xqt),
      q(7482) => q(xra),
      q(7483) => q(xrb),
      q(7484) => q(xrd),
      q(7485) => q(xre),
      q(7486) => q(xrg),
      q(7487) => q(xri),
      q(7488) => q(xrm),
      q(7489) => q(xrn),
      q(7490) => q(xrq),
      q(7491) => q(xrr),
      q(7492) => q(xrt),
      q(7493) => q(xru),
      q(7494) => q(xrw),
      q(7495) => q(xsa),
      q(7496) => q(xsb),
      q(7497) => q(xsc),
      q(7498) => q(xsd),
      q(7499) => q(xse),
      q(7500) => q(xsh),
      q(7501) => q(xsi),
      q(7502) => q(xsj),
      q(7503) => q(xsl),
      q(7504) => q(xsm),
      q(7505) => q(xsn),
      q(7506) => q(xso),
      q(7507) => q(xsp),
      q(7508) => q(xsq),
      q(7509) => q(xsr),
      q(7510) => q(xss),
      q(7511) => q(xsu),
      q(7512) => q(xsv),
      q(7513) => q(xsy),
      q(7514) => q(xta),
      q(7515) => q(xtb),
      q(7516) => q(xtc),
      q(7517) => q(xtd),
      q(7518) => q(xte),
      q(7519) => q(xtg),
      q(7520) => q(xth),
      q(7521) => q(xti),
      q(7522) => q(xtj),
      q(7523) => q(xtl),
      q(7524) => q(xtm),
      q(7525) => q(xtn),
      q(7526) => q(xto),
      q(7527) => q(xtp),
      q(7528) => q(xtq),
      q(7529) => q(xtr),
      q(7530) => q(xts),
      q(7531) => q(xtt),
      q(7532) => q(xtu),
      q(7533) => q(xtv),
      q(7534) => q(xtw),
      q(7535) => q(xty),
      q(7536) => q(xtz),
      q(7537) => q(xua),
      q(7538) => q(xub),
      q(7539) => q(xud),
      q(7540) => q(xug),
      q(7541) => q(xuj),
      q(7542) => q(xul),
      q(7543) => q(xum),
      q(7544) => q(xun),
      q(7545) => q(xuo),
      q(7546) => q(xup),
      q(7547) => q(xur),
      q(7548) => q(xut),
      q(7549) => q(xuu),
      q(7550) => q(xve),
      q(7551) => q(xvi),
      q(7552) => q(xvn),
      q(7553) => q(xvo),
      q(7554) => q(xvs),
      q(7555) => q(xwa),
      q(7556) => q(xwc),
      q(7557) => q(xwd),
      q(7558) => q(xwe),
      q(7559) => q(xwg),
      q(7560) => q(xwj),
      q(7561) => q(xwk),
      q(7562) => q(xwl),
      q(7563) => q(xwo),
      q(7564) => q(xwr),
      q(7565) => q(xwt),
      q(7566) => q(xww),
      q(7567) => q(xxb),
      q(7568) => q(xxk),
      q(7569) => q(xxm),
      q(7570) => q(xxr),
      q(7571) => q(xxt),
      q(7572) => q(xya),
      q(7573) => q(xyb),
      q(7574) => q(xyj),
      q(7575) => q(xyk),
      q(7576) => q(xyl),
      q(7577) => q(xyt),
      q(7578) => q(xyy),
      q(7579) => q(xzh),
      q(7580) => q(xzm),
      q(7581) => q(xzp),
      q(7582) => q(yaa),
      q(7583) => q(yab),
      q(7584) => q(yac),
      q(7585) => q(yad),
      q(7586) => q(yae),
      q(7587) => q(yaf),
      q(7588) => q(yag),
      q(7589) => q(yah),
      q(7590) => q(yai),
      q(7591) => q(yaj),
      q(7592) => q(yak),
      q(7593) => q(yal),
      q(7594) => q(yam),
      q(7595) => q(yan),
      q(7596) => q(yaq),
      q(7597) => q(yar),
      q(7598) => q(yas),
      q(7599) => q(yat),
      q(7600) => q(yau),
      q(7601) => q(yav),
      q(7602) => q(yaw),
      q(7603) => q(yax),
      q(7604) => q(yay),
      q(7605) => q(yaz),
      q(7606) => q(yba),
      q(7607) => q(ybb),
      q(7608) => q(ybe),
      q(7609) => q(ybh),
      q(7610) => q(ybi),
      q(7611) => q(ybj),
      q(7612) => q(ybk),
      q(7613) => q(ybl),
      q(7614) => q(ybm),
      q(7615) => q(ybn),
      q(7616) => q(ybo),
      q(7617) => q(ybx),
      q(7618) => q(yby),
      q(7619) => q(ych),
      q(7620) => q(ycl),
      q(7621) => q(ycn),
      q(7622) => q(ycp),
      q(7623) => q(yda),
      q(7624) => q(ydd),
      q(7625) => q(yde),
      q(7626) => q(ydg),
      q(7627) => q(ydk),
      q(7628) => q(yds),
      q(7629) => q(yea),
      q(7630) => q(yec),
      q(7631) => q(yee),
      q(7632) => q(yei),
      q(7633) => q(yej),
      q(7634) => q(yel),
      q(7635) => q(yer),
      q(7636) => q(yes),
      q(7637) => q(yet),
      q(7638) => q(yeu),
      q(7639) => q(yev),
      q(7640) => q(yey),
      q(7641) => q(yga),
      q(7642) => q(ygi),
      q(7643) => q(ygl),
      q(7644) => q(ygm),
      q(7645) => q(ygp),
      q(7646) => q(ygr),
      q(7647) => q(ygu),
      q(7648) => q(ygw),
      q(7649) => q(yha),
      q(7650) => q(yhd),
      q(7651) => q(yhl),
      q(7652) => q(yia),
      q(7653) => q(yig),
      q(7654) => q(yih),
      q(7655) => q(yii),
      q(7656) => q(yij),
      q(7657) => q(yik),
      q(7658) => q(yil),
      q(7659) => q(yim),
      q(7660) => q(yin),
      q(7661) => q(yip),
      q(7662) => q(yiq),
      q(7663) => q(yir),
      q(7664) => q(yis),
      q(7665) => q(yit),
      q(7666) => q(yiu),
      q(7667) => q(yiv),
      q(7668) => q(yix),
      q(7669) => q(yiz),
      q(7670) => q(yka),
      q(7671) => q(ykg),
      q(7672) => q(yki),
      q(7673) => q(ykk),
      q(7674) => q(ykl),
      q(7675) => q(ykm),
      q(7676) => q(ykn),
      q(7677) => q(yko),
      q(7678) => q(ykr),
      q(7679) => q(ykt),
      q(7680) => q(yku),
      q(7681) => q(yky),
      q(7682) => q(yla),
      q(7683) => q(ylb),
      q(7684) => q(yle),
      q(7685) => q(ylg),
      q(7686) => q(yli),
      q(7687) => q(yll),
      q(7688) => q(ylm),
      q(7689) => q(yln),
      q(7690) => q(ylo),
      q(7691) => q(ylr),
      q(7692) => q(ylu),
      q(7693) => q(yly),
      q(7694) => q(ymb),
      q(7695) => q(ymc),
      q(7696) => q(ymd),
      q(7697) => q(yme),
      q(7698) => q(ymg),
      q(7699) => q(ymh),
      q(7700) => q(ymi),
      q(7701) => q(ymk),
      q(7702) => q(yml),
      q(7703) => q(ymm),
      q(7704) => q(ymn),
      q(7705) => q(ymo),
      q(7706) => q(ymp),
      q(7707) => q(ymq),
      q(7708) => q(ymr),
      q(7709) => q(yms),
      q(7710) => q(ymt),
      q(7711) => q(ymx),
      q(7712) => q(ymz),
      q(7713) => q(yna),
      q(7714) => q(ynd),
      q(7715) => q(yne),
      q(7716) => q(yng),
      q(7717) => q(ynh),
      q(7718) => q(ynk),
      q(7719) => q(ynl),
      q(7720) => q(ynn),
      q(7721) => q(yno),
      q(7722) => q(ynq),
      q(7723) => q(yns),
      q(7724) => q(ynu),
      q(7725) => q(yob),
      q(7726) => q(yog),
      q(7727) => q(yoi),
      q(7728) => q(yok),
      q(7729) => q(yol),
      q(7730) => q(yom),
      q(7731) => q(yon),
      q(7732) => q(yot),
      q(7733) => q(yox),
      q(7734) => q(yoy),
      q(7735) => q(ypa),
      q(7736) => q(ypb),
      q(7737) => q(ypg),
      q(7738) => q(yph),
      q(7739) => q(ypm),
      q(7740) => q(ypn),
      q(7741) => q(ypo),
      q(7742) => q(ypp),
      q(7743) => q(ypz),
      q(7744) => q(yra),
      q(7745) => q(yrb),
      q(7746) => q(yre),
      q(7747) => q(yri),
      q(7748) => q(yrk),
      q(7749) => q(yrl),
      q(7750) => q(yrm),
      q(7751) => q(yrn),
      q(7752) => q(yrs),
      q(7753) => q(yrw),
      q(7754) => q(yry),
      q(7755) => q(ysc),
      q(7756) => q(ysd),
      q(7757) => q(ysg),
      q(7758) => q(ysl),
      q(7759) => q(ysn),
      q(7760) => q(yso),
      q(7761) => q(ysp),
      q(7762) => q(ysr),
      q(7763) => q(yss),
      q(7764) => q(ysy),
      q(7765) => q(yta),
      q(7766) => q(ytl),
      q(7767) => q(ytp),
      q(7768) => q(ytw),
      q(7769) => q(yty),
      q(7770) => q(yua),
      q(7771) => q(yub),
      q(7772) => q(yuc),
      q(7773) => q(yud),
      q(7774) => q(yue),
      q(7775) => q(yuf),
      q(7776) => q(yug),
      q(7777) => q(yui),
      q(7778) => q(yuj),
      q(7779) => q(yuk),
      q(7780) => q(yul),
      q(7781) => q(yum),
      q(7782) => q(yun),
      q(7783) => q(yup),
      q(7784) => q(yuq),
      q(7785) => q(yur),
      q(7786) => q(yut),
      q(7787) => q(yuu),
      q(7788) => q(yuw),
      q(7789) => q(yux),
      q(7790) => q(yuy),
      q(7791) => q(yuz),
      q(7792) => q(yva),
      q(7793) => q(yvt),
      q(7794) => q(ywa),
      q(7795) => q(ywg),
      q(7796) => q(ywl),
      q(7797) => q(ywn),
      q(7798) => q(ywq),
      q(7799) => q(ywr),
      q(7800) => q(ywt),
      q(7801) => q(ywu),
      q(7802) => q(yww),
      q(7803) => q(yxa),
      q(7804) => q(yxg),
      q(7805) => q(yxl),
      q(7806) => q(yxm),
      q(7807) => q(yxu),
      q(7808) => q(yxy),
      q(7809) => q(yyr),
      q(7810) => q(yyu),
      q(7811) => q(yyz),
      q(7812) => q(yzg),
      q(7813) => q(yzk),
      q(7814) => q(zaa),
      q(7815) => q(zab),
      q(7816) => q(zac),
      q(7817) => q(zad),
      q(7818) => q(zae),
      q(7819) => q(zaf),
      q(7820) => q(zag),
      q(7821) => q(zah),
      q(7822) => q(zai),
      q(7823) => q(zaj),
      q(7824) => q(zak),
      q(7825) => q(zal),
      q(7826) => q(zam),
      q(7827) => q(zao),
      q(7828) => q(zaq),
      q(7829) => q(zar),
      q(7830) => q(zas),
      q(7831) => q(zat),
      q(7832) => q(zau),
      q(7833) => q(zav),
      q(7834) => q(zaw),
      q(7835) => q(zax),
      q(7836) => q(zay),
      q(7837) => q(zaz),
      q(7838) => q(zbc),
      q(7839) => q(zbe),
      q(7840) => q(zbt),
      q(7841) => q(zbw),
      q(7842) => q(zca),
      q(7843) => q(zch),
      q(7844) => q(zdj),
      q(7845) => q(zea),
      q(7846) => q(zeg),
      q(7847) => q(zeh),
      q(7848) => q(zga),
      q(7849) => q(zgb),
      q(7850) => q(zgm),
      q(7851) => q(zgn),
      q(7852) => q(zgr),
      q(7853) => q(zhb),
      q(7854) => q(zhd),
      q(7855) => q(zhi),
      q(7856) => q(zhn),
      q(7857) => q(zhw),
      q(7858) => q(zia),
      q(7859) => q(zib),
      q(7860) => q(zik),
      q(7861) => q(zil),
      q(7862) => q(zim),
      q(7863) => q(zin),
      q(7864) => q(zir),
      q(7865) => q(ziw),
      q(7866) => q(ziz),
      q(7867) => q(zka),
      q(7868) => q(zkb),
      q(7869) => q(zkd),
      q(7870) => q(zkg),
      q(7871) => q(zkh),
      q(7872) => q(zkk),
      q(7873) => q(zkn),
      q(7874) => q(zko),
      q(7875) => q(zkp),
      q(7876) => q(zkr),
      q(7877) => q(zkt),
      q(7878) => q(zku),
      q(7879) => q(zkv),
      q(7880) => q(zkz),
      q(7881) => q(zlj),
      q(7882) => q(zlm),
      q(7883) => q(zln),
      q(7884) => q(zlq),
      q(7885) => q(zma),
      q(7886) => q(zmb),
      q(7887) => q(zmc),
      q(7888) => q(zmd),
      q(7889) => q(zme),
      q(7890) => q(zmf),
      q(7891) => q(zmg),
      q(7892) => q(zmh),
      q(7893) => q(zmi),
      q(7894) => q(zmj),
      q(7895) => q(zmk),
      q(7896) => q(zml),
      q(7897) => q(zmm),
      q(7898) => q(zmn),
      q(7899) => q(zmo),
      q(7900) => q(zmp),
      q(7901) => q(zmq),
      q(7902) => q(zmr),
      q(7903) => q(zms),
      q(7904) => q(zmt),
      q(7905) => q(zmu),
      q(7906) => q(zmv),
      q(7907) => q(zmw),
      q(7908) => q(zmx),
      q(7909) => q(zmy),
      q(7910) => q(zmz),
      q(7911) => q(zna),
      q(7912) => q(zne),
      q(7913) => q(zng),
      q(7914) => q(znk),
      q(7915) => q(zns),
      q(7916) => q(zoc),
      q(7917) => q(zoh),
      q(7918) => q(zom),
      q(7919) => q(zoo),
      q(7920) => q(zoq),
      q(7921) => q(zor),
      q(7922) => q(zos),
      q(7923) => q(zpa),
      q(7924) => q(zpb),
      q(7925) => q(zpc),
      q(7926) => q(zpd),
      q(7927) => q(zpe),
      q(7928) => q(zpf),
      q(7929) => q(zpg),
      q(7930) => q(zph),
      q(7931) => q(zpi),
      q(7932) => q(zpj),
      q(7933) => q(zpk),
      q(7934) => q(zpl),
      q(7935) => q(zpm),
      q(7936) => q(zpn),
      q(7937) => q(zpo),
      q(7938) => q(zpp),
      q(7939) => q(zpq),
      q(7940) => q(zpr),
      q(7941) => q(zps),
      q(7942) => q(zpt),
      q(7943) => q(zpu),
      q(7944) => q(zpv),
      q(7945) => q(zpw),
      q(7946) => q(zpx),
      q(7947) => q(zpy),
      q(7948) => q(zpz),
      q(7949) => q(zqe),
      q(7950) => q(zra),
      q(7951) => q(zrg),
      q(7952) => q(zrn),
      q(7953) => q(zro),
      q(7954) => q(zrp),
      q(7955) => q(zrs),
      q(7956) => q(zsa),
      q(7957) => q(zsk),
      q(7958) => q(zsl),
      q(7959) => q(zsm),
      q(7960) => q(zsr),
      q(7961) => q(zsu),
      q(7962) => q(zte),
      q(7963) => q(ztg),
      q(7964) => q(ztl),
      q(7965) => q(ztm),
      q(7966) => q(ztn),
      q(7967) => q(ztp),
      q(7968) => q(ztq),
      q(7969) => q(zts),
      q(7970) => q(ztt),
      q(7971) => q(ztu),
      q(7972) => q(ztx),
      q(7973) => q(zty),
      q(7974) => q(zua),
      q(7975) => q(zuh),
      q(7976) => q(zum),
      q(7977) => q(zuy),
      q(7978) => q(zwa),
      q(7979) => q(zyb),
      q(7980) => q(zyg),
      q(7981) => q(zyj),
      q(7982) => q(zyn),
      q(7983) => q(zyp),
      q(7984) => q(zzj),
      },
   q(term) => {
      q(0013) => q(sqi),
      q(0024) => q(hye),
      q(0044) => q(eus),
      q(0066) => q(mya),
      q(0079) => q(zho),
      q(0101) => q(ces),
      q(0116) => q(nld),
      q(0137) => q(fra),
      q(0149) => q(kat),
      q(0150) => q(deu),
      q(0164) => q(ell),
      q(0187) => q(isl),
      q(0262) => q(mkd),
      q(0270) => q(mri),
      q(0274) => q(msa),
      q(0342) => q(fas),
      q(0360) => q(ron),
      q(0385) => q(slk),
      q(0427) => q(bod),
      q(0466) => q(cym),
      },
};

1;
          usr/share/perl/5.20.2/Locale/Codes/Language_Retired.pm                                              0100644 0000000 0000000 00000027654 12744441327 020667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Language_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Mar  4 13:19:40 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Retired{'language'}{'alpha-2'}{'code'} = {
   q(in) => q(Indonesian),
   q(iw) => q(Hebrew),
   q(ji) => q(Yiddish),
   q(jw) => q(Javanese),
   q(mo) => q(Moldavian),
};

$Locale::Codes::Retired{'language'}{'alpha-3'}{'code'} = {
   q(ayx) => q(Ayi (China)),
   q(baz) => q(Tunen),
   q(bjd) => q(Bandjigali),
   q(bjq) => q(Southern Betsimisaraka Malagasy),
   q(ccq) => q(Chaungtha),
   q(cka) => q(Khumi Awa Chin),
   q(daf) => q(Dan),
   q(dap) => q(Nisi (India)),
   q(dha) => q(Dhanwar (India)),
   q(djl) => q(Djiwarli),
   q(dkl) => q(Kolum So Dogon),
   q(dwl) => q(Walo Kumbe Dogon),
   q(elp) => q(Elpaputih),
   q(gbc) => q(Garawa),
   q(ggr) => q(Aghu Tharnggalu),
   q(gio) => q(Gelao),
   q(hrr) => q(Horuru),
   q(ibi) => q(Ibilo),
   q(ilw) => q(Talur),
   q(izi) => q(Izi-Ezaa-Ikwo-Mgbo),
   q(jar) => q(Jarawa (Nigeria)),
   q(kdv) => q(Kado),
   q(kgh) => q(Upper Tanudan Kalinga),
   q(kpp) => q(Paku Karen),
   q(kzh) => q(Kenuzi-Dongola),
   q(lcq) => q(Luhu),
   q(meg) => q(Mea),
   q(mgx) => q(Omati),
   q(mja) => q(Mahei),
   q(mld) => q(Malakhel),
   q(mnt) => q(Maykulan),
   q(mwd) => q(Mudbura),
   q(myq) => q(Forest Maninka),
   q(nbf) => q(Naxi),
   q(nbx) => q(Ngura),
   q(nln) => q(Durango Nahuatl),
   q(nlr) => q(Ngarla),
   q(noo) => q(Nootka),
   q(pbz) => q(Palu),
   q(pcr) => q(Panang),
   q(pgy) => q(Pongyong),
   q(ppr) => q(Piru),
   q(sca) => q(Sansu),
   q(tgg) => q(Tangga),
   q(tie) => q(Tingal),
   q(tkk) => q(Takpa),
   q(tlw) => q(South Wemale),
   q(unp) => q(Worora),
   q(wit) => q(Wintu),
   q(wiw) => q(Wirangu),
   q(xia) => q(Xiandao),
   q(ybd) => q(Yangbye),
   q(yen) => q(Yendang),
   q(yiy) => q(Yir Yoront),
   q(yma) => q(Yamphe),
   q(yos) => q(Yos),
};

$Locale::Codes::Retired{'language'}{'term'}{'code'} = {
};

$Locale::Codes::Retired{'language'}{'alpha-2'}{'name'} = {
   q((afan) oromo) => [ q(om), q((Afan) Oromo) ],
   q(bengali; bangla) => [ q(bn), q(Bengali; Bangla) ],
   q(bhutani) => [ q(dz), q(Bhutani) ],
   q(bihari) => [ q(bh), q(Bihari) ],
   q(bokmal, norwegian) => [ q(nb), q(Bokmal, Norwegian) ],
   q(byelorussian) => [ q(be), q(Byelorussian) ],
   q(cambodian) => [ q(km), q(Cambodian) ],
   q(chichewa) => [ q(ny), q(Chichewa) ],
   q(chichewa; nyanja) => [ q(ny), q(Chichewa; Nyanja) ],
   q(divehi) => [ q(dv), q(Divehi) ],
   q(faeroese) => [ q(fo), q(Faeroese) ],
   q(fiji) => [ q(fj), q(Fiji) ],
   q(frisian) => [ q(fy), q(Frisian) ],
   q(gaelic) => [ q(gd), q(Gaelic) ],
   q(gaelic (scots)) => [ q(gd), q(Gaelic (Scots)) ],
   q(gallegan) => [ q(gl), q(Gallegan) ],
   q(greek) => [ q(el), q(Greek) ],
   q(greek, modern (1453-)) => [ q(el), q(Greek, Modern (1453-)) ],
   q(greenlandic) => [ q(kl), q(Greenlandic) ],
   q(interlingua) => [ q(ia), q(Interlingua) ],
   q(inupiak) => [ q(ik), q(Inupiak) ],
   q(khmer) => [ q(km), q(Khmer) ],
   q(kirundi) => [ q(rn), q(Kirundi) ],
   q(laothian) => [ q(lo), q(Laothian) ],
   q(latvian, lettish) => [ q(lv), q(Latvian, Lettish) ],
   q(letzeburgesch) => [ q(lb), q(Letzeburgesch) ],
   q(malay) => [ q(ms), q(Malay) ],
   q(marshall) => [ q(mh), q(Marshall) ],
   q(moldavian) => [ q(mo), q(Moldavian) ],
   q(ndebele, north) => [ q(nd), q(Ndebele, North) ],
   q(ndebele, south) => [ q(nr), q(Ndebele, South) ],
   q(nepali) => [ q(ne), q(Nepali) ],
   q(norwegian bokmal) => [ q(nb), q(Norwegian Bokmal) ],
   q(occitan) => [ q(oc), q(Occitan) ],
   q(oriya) => [ q(or), q(Oriya) ],
   q(ossetian; ossetic) => [ q(os), q(Ossetian; Ossetic) ],
   q(pashto, pushto) => [ q(ps), q(Pashto, Pushto) ],
   q(punjabi) => [ q(pa), q(Punjabi) ],
   q(rhaeto-romance) => [ q(rm), q(Rhaeto-Romance) ],
   q(sami) => [ q(se), q(Sami) ],
   q(sangro) => [ q(sg), q(Sangro) ],
   q(scots gaelic) => [ q(gd), q(Scots Gaelic) ],
   q(sesotho) => [ q(st), q(Sesotho) ],
   q(setswana) => [ q(tn), q(Setswana) ],
   q(singhalese) => [ q(si), q(Singhalese) ],
   q(sinhalese) => [ q(si), q(Sinhalese) ],
   q(siswati) => [ q(ss), q(Siswati) ],
   q(sotho) => [ q(st), q(Sotho) ],
   q(sotho, southern) => [ q(st), q(Sotho, Southern) ],
   q(swahili) => [ q(sw), q(Swahili) ],
   q(tegulu) => [ q(te), q(Tegulu) ],
   q(tonga) => [ q(to), q(Tonga) ],
   q(volapuk) => [ q(vo), q(Volapuk) ],
};

$Locale::Codes::Retired{'language'}{'alpha-3'}{'name'} = {
   q(aghu tharnggalu) => [ q(ggr), q(Aghu Tharnggalu) ],
   q(ainu) => [ q(ain), q(Ainu) ],
   q(amarag) => [ q(amg), q(Amarag) ],
   q(anu) => [ q(anl), q(Anu) ],
   q(apalik) => [ q(apo), q(Apalik) ],
   q(aromanian) => [ q(rup), q(Aromanian) ],
   q(ayi (china)) => [ q(ayx), q(Ayi (China)) ],
   q(bandjigali) => [ q(bjd), q(Bandjigali) ],
   q(bangi me) => [ q(dba), q(Bangi Me) ],
   q(bantu (other)) => [ q(bnt), q(Bantu (Other)) ],
   q(basa) => [ q(bas), q(Basa) ],
   q(bauro) => [ q(bxa), q(Bauro) ],
   q(bebe) => [ q(bzv), q(Bebe) ],
   q(bedik) => [ q(tnr), q(Bedik) ],
   q(begbere-ejar) => [ q(bqv), q(Begbere-Ejar) ],
   q(bekwil) => [ q(bkw), q(Bekwil) ],
   q(bemba) => [ q(bem), q(Bemba) ],
   q(blin) => [ q(byn), q(Blin) ],
   q(brek karen) => [ q(kvl), q(Brek Karen) ],
   q(burum-mindik) => [ q(bmu), q(Burum-Mindik) ],
   q(central bicolano) => [ q(bcl), q(Central Bicolano) ],
   q(chaungtha) => [ q(ccq), q(Chaungtha) ],
   q(creoles and pidgins ) => [ q(crp), q(Creoles and pidgins ) ],
   q(creoles and pidgins, english based) => [ q(cpe), q(Creoles and pidgins, English based) ],
   q(creoles and pidgins, french-based ) => [ q(cpf), q(Creoles and pidgins, French-based ) ],
   q(creoles and pidgins, portuguese-based ) => [ q(cpp), q(Creoles and pidgins, Portuguese-based ) ],
   q(dakaka) => [ q(bpa), q(Dakaka) ],
   q(darling) => [ q(drl), q(Darling) ],
   q(dhangu) => [ q(dhg), q(Dhangu) ],
   q(dhanwar (india)) => [ q(dha), q(Dhanwar (India)) ],
   q(dimir) => [ q(dmc), q(Dimir) ],
   q(dogri) => [ q(doi), q(Dogri) ],
   q(duduela) => [ q(duk), q(Duduela) ],
   q(dumpu) => [ q(wtf), q(Dumpu) ],
   q(durango nahuatl) => [ q(nln), q(Durango Nahuatl) ],
   q(dutch, middle (ca.1050-1350)) => [ q(dum), q(Dutch, Middle (ca.1050-1350)) ],
   q(elpaputih) => [ q(elp), q(Elpaputih) ],
   q(english, middle (1100-1500)) => [ q(enm), q(English, Middle (1100-1500)) ],
   q(english, old (ca.450-1100)) => [ q(ang), q(English, Old (ca.450-1100)) ],
   q(fang) => [ q(fan), q(Fang) ],
   q(forest maninka) => [ q(myq), q(Forest Maninka) ],
   q(french, middle (ca.1400-1600)) => [ q(frm), q(French, Middle (ca.1400-1600)) ],
   q(french, old (842-ca.1400)) => [ q(fro), q(French, Old (842-ca.1400)) ],
   q(galoli) => [ q(gal), q(Galoli) ],
   q(garawa) => [ q(gbc), q(Garawa) ],
   q(gbaya) => [ q(gba), q(Gbaya) ],
   q(gelao) => [ q(gio), q(Gelao) ],
   q(german, middle high (ca.1050-1500)) => [ q(gmh), q(German, Middle High (ca.1050-1500)) ],
   q(german, old high (ca.750-1050)) => [ q(goh), q(German, Old High (ca.750-1050)) ],
   q(greek, ancient (to 1453)) => [ q(grc), q(Greek, Ancient (to 1453)) ],
   q(hainyaxo bozo) => [ q(bzx), q(Hainyaxo Bozo) ],
   q(horuru) => [ q(hrr), q(Horuru) ],
   q(ibilo) => [ q(ibi), q(Ibilo) ],
   q(idun) => [ q(ldb), q(Idun) ],
   q(ikobi-mena) => [ q(meb), q(Ikobi-Mena) ],
   q(irish, middle (900-1200)) => [ q(mga), q(Irish, Middle (900-1200)) ],
   q(irish, old (to 900)) => [ q(sga), q(Irish, Old (to 900)) ],
   q(izi-ezaa-ikwo-mgbo) => [ q(izi), q(Izi-Ezaa-Ikwo-Mgbo) ],
   q(jarawa (nigeria)) => [ q(jar), q(Jarawa (Nigeria)) ],
   q(kadara) => [ q(kad), q(Kadara) ],
   q(kado) => [ q(kdv), q(Kado) ],
   q(kag-fer-jiir-koor-ror-us-zuksun) => [ q(gel), q(Kag-Fer-Jiir-Koor-Ror-Us-Zuksun) ],
   q(kamba) => [ q(kam), q(Kamba) ],
   q(kemezung) => [ q(dmo), q(Kemezung) ],
   q(kenuzi-dongola) => [ q(kzh), q(Kenuzi-Dongola) ],
   q(khumi awa chin) => [ q(cka), q(Khumi Awa Chin) ],
   q(kol) => [ q(ekl), q(Kol) ],
   q(kolum so dogon) => [ q(dkl), q(Kolum So Dogon) ],
   q(konkani) => [ q(kok), q(Konkani) ],
   q(kumak) => [ q(nee), q(Kumak) ],
   q(kutang ghale) => [ q(ght), q(Kutang Ghale) ],
   q(kwato) => [ q(kop), q(Kwato) ],
   q(kyenga) => [ q(tye), q(Kyenga) ],
   q(lowa) => [ q(loy), q(Lowa) ],
   q(lower tanudan kalinga) => [ q(kml), q(Lower Tanudan Kalinga) ],
   q(luhu) => [ q(lcq), q(Luhu) ],
   q(mahei) => [ q(mja), q(Mahei) ],
   q(malakhel) => [ q(mld), q(Malakhel) ],
   q(malasanga) => [ q(mqz), q(Malasanga) ],
   q(mann) => [ q(mev), q(Mann) ],
   q(mari) => [ q(chm), q(Mari) ],
   q(maykulan) => [ q(mnt), q(Maykulan) ],
   q(mbabaram) => [ q(vmb), q(Mbabaram) ],
   q(mbedam) => [ q(xmd), q(Mbedam) ],
   q(mbu') => [ q(muc), q(Mbu') ],
   q(mea) => [ q(meg), q(Mea) ],
   q(mende) => [ q(men), q(Mende) ],
   q(minigir) => [ q(vmg), q(Minigir) ],
   q(mire) => [ q(mvh), q(Mire) ],
   q(miri) => [ q(mrg), q(Miri) ],
   q(misima-paneati) => [ q(mpx), q(Misima-Paneati) ],
   q(mixifore) => [ q(mfg), q(Mixifore) ],
   q(mpongmpong) => [ q(mgg), q(Mpongmpong) ],
   q(mro chin) => [ q(cmr), q(Mro Chin) ],
   q(mudbura) => [ q(mwd), q(Mudbura) ],
   q(muduapa) => [ q(wiv), q(Muduapa) ],
   q(nakama) => [ q(nib), q(Nakama) ],
   q(nanggu) => [ q(ngr), q(Nanggu) ],
   q(nangikurrunggurr) => [ q(nam), q(Nangikurrunggurr) ],
   q(ndrag'ngith) => [ q(dgt), q(Ndrag'ngith) ],
   q(nepal bhasa) => [ q(new), q(Nepal Bhasa) ],
   q(nga la) => [ q(hlt), q(Nga La) ],
   q(ngalkbun) => [ q(ngk), q(Ngalkbun) ],
   q(ngura) => [ q(nbx), q(Ngura) ],
   q(nisi (india)) => [ q(dap), q(Nisi (India)) ],
   q(nootka) => [ q(noo), q(Nootka) ],
   q(norse, old) => [ q(non), q(Norse, Old) ],
   q(north wemale) => [ q(weo), q(North Wemale) ],
   q(northern catanduanes bicolano) => [ q(cts), q(Northern Catanduanes Bicolano) ],
   q(northern lorung) => [ q(lbr), q(Northern Lorung) ],
   q(nsari) => [ q(asj), q(Nsari) ],
   q(nung (myanmar)) => [ q(nun), q(Nung (Myanmar)) ],
   q(omati) => [ q(mgx), q(Omati) ],
   q(ounge) => [ q(oue), q(Ounge) ],
   q(palu) => [ q(pbz), q(Palu) ],
   q(panang) => [ q(pcr), q(Panang) ],
   q(persian, old (ca.600-400 b.c.)) => [ q(peo), q(Persian, Old (ca.600-400 B.C.)) ],
   q(piru) => [ q(ppr), q(Piru) ],
   q(pongyong) => [ q(pgy), q(Pongyong) ],
   q(provencal, old (to 1500)) => [ q(pro), q(Provencal, Old (to 1500)) ],
   q(sakam) => [ q(skm), q(Sakam) ],
   q(sansu) => [ q(sca), q(Sansu) ],
   q(sauk) => [ q(skc), q(Sauk) ],
   q(sepen) => [ q(spm), q(Sepen) ],
   q(shangzhai) => [ q(jih), q(Shangzhai) ],
   q(so (cameroon)) => [ q(sox), q(So (Cameroon)) ],
   q(south american indian (other)) => [ q(sai), q(South American Indian (Other)) ],
   q(south wemale) => [ q(tlw), q(South Wemale) ],
   q(southern catanduanes bicolano) => [ q(bln), q(Southern Catanduanes Bicolano) ],
   q(southern lorung) => [ q(lrr), q(Southern Lorung) ],
   q(sulung) => [ q(suv), q(Sulung) ],
   q(takpa) => [ q(tkk), q(Takpa) ],
   q(talur) => [ q(ilw), q(Talur) ],
   q(tangga) => [ q(tgg), q(Tangga) ],
   q(tangkhul naga) => [ q(nmf), q(Tangkhul Naga) ],
   q(tina sambal) => [ q(xsb), q(Tina Sambal) ],
   q(tingal) => [ q(tie), q(Tingal) ],
   q(turkish, ottoman (1500-1928)) => [ q(ota), q(Turkish, Ottoman (1500-1928)) ],
   q(unggarranggu) => [ q(xun), q(Unggarranggu) ],
   q(upper tanudan kalinga) => [ q(kgh), q(Upper Tanudan Kalinga) ],
   q(walamo) => [ q(wal), q(Walamo) ],
   q(walo kumbe dogon) => [ q(dwl), q(Walo Kumbe Dogon) ],
   q(waray) => [ q(war), q(Waray) ],
   q(welaung) => [ q(weu), q(Welaung) ],
   q(were) => [ q(wei), q(Were) ],
   q(western canadian inuktitut) => [ q(ikt), q(Western Canadian Inuktitut) ],
   q(worora) => [ q(unp), q(Worora) ],
   q(xiandao) => [ q(xia), q(Xiandao) ],
   q(yamphe) => [ q(yma), q(Yamphe) ],
   q(yangbye) => [ q(ybd), q(Yangbye) ],
   q(yeskwa) => [ q(yes), q(Yeskwa) ],
   q(yonggom) => [ q(yon), q(Yonggom) ],
   q(yos) => [ q(yos), q(Yos) ],
   q(yuaga) => [ q(nua), q(Yuaga) ],
   q(zyphe) => [ q(zyp), q(Zyphe) ],
};

$Locale::Codes::Retired{'language'}{'term'}{'name'} = {
};


1;
                                                                                    usr/share/perl/5.20.2/Locale/Codes/Script.pm                                                        0100644 0000000 0000000 00000004266 12744441327 016724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::Script;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

require Exporter;
use Carp;
use Locale::Codes;
use Locale::Codes::Constants;
use Locale::Codes::Script_Codes;
use Locale::Codes::Script_Retired;

#=======================================================================
#       Public Global Variables
#=======================================================================

our($VERSION,@ISA,@EXPORT,@EXPORT_OK);

$VERSION='3.30';
@ISA       = qw(Exporter);
@EXPORT    = qw(code2script
                script2code
                all_script_codes
                all_script_names
                script_code2code
                LOCALE_SCRIPT_ALPHA
                LOCALE_SCRIPT_NUMERIC
               );

sub code2script {
   return Locale::Codes::_code2name('script',@_);
}

sub script2code {
   return Locale::Codes::_name2code('script',@_);
}

sub script_code2code {
   return Locale::Codes::_code2code('script',@_);
}

sub all_script_codes {
   return Locale::Codes::_all_codes('script',@_);
}

sub all_script_names {
   return Locale::Codes::_all_names('script',@_);
}

sub rename_script {
   return Locale::Codes::_rename('script',@_);
}

sub add_script {
   return Locale::Codes::_add_code('script',@_);
}

sub delete_script {
   return Locale::Codes::_delete_code('script',@_);
}

sub add_script_alias {
   return Locale::Codes::_add_alias('script',@_);
}

sub delete_script_alias {
   return Locale::Codes::_delete_alias('script',@_);
}

sub rename_script_code {
   return Locale::Codes::_rename_code('script',@_);
}

sub add_script_code_alias {
   return Locale::Codes::_add_code_alias('script',@_);
}

sub delete_script_code_alias {
   return Locale::Codes::_delete_code_alias('script',@_);
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                          usr/share/perl/5.20.2/Locale/Codes/Script.pod                                                       0100644 0000000 0000000 00000006244 12744441327 017070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::Script - standard codes for script identification

=head1 SYNOPSIS

   use Locale::Codes::Script;

   $script  = code2script('phnx');                     # 'Phoenician'
   $code    = script2code('Phoenician');               # 'Phnx'
   $code    = script2code('Phoenician',
                          LOCALE_CODE_NUMERIC);        # 115

   @codes   = all_script_codes();
   @scripts = all_script_names();

=head1 DESCRIPTION

The C<Locale::Codes::Script> module provides access to standards codes used
for identifying scripts, such as those defined in ISO 15924.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
15924 four-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
scripts. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $script = code2script('phnx','alpha');
   $script = code2script('phnx',LOCALE_SCRIPT_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha, LOCALE_SCRIPT_ALPHA>

This is a set of four-letter (capitalized) codes from ISO 15924
such as 'Phnx' for Phoenician.  It also includes additions to this
set included in the IANA language registry.

The Zxxx, Zyyy, and Zzzz codes are not used.

This is the default code set.

=item B<num, LOCALE_SCRIPT_NUMERIC>

This is a set of three-digit numeric codes from ISO 15924 such as 115
for Phoenician.

=back

=head1 ROUTINES

=over 4

=item B<code2script ( CODE [,CODESET] )>

=item B<script2code ( NAME [,CODESET] )>

=item B<script_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_script_codes ( [CODESET] )>

=item B<all_script_names ( [CODESET] )>

=item B<Locale::Codes::Script::rename_script  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Codes::Script::add_script  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Codes::Script::delete_script  ( CODE [,CODESET] )>

=item B<Locale::Codes::Script::add_script_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Codes::Script::delete_script_alias  ( NAME )>

=item B<Locale::Codes::Script::rename_script_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::Script::add_script_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::Script::delete_script_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.unicode.org/iso15924/>

Home page for ISO 15924.

=item B<http://www.iana.org/assignments/language-subtag-registry>

The IANA language subtag registry.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Locale/Codes/Script_Codes.pm                                                  0100644 0000000 0000000 00000152616 12744441327 020044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Script_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Thu Feb 27 15:45:43 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Data{'script'}{'id'} = '0166';

$Locale::Codes::Data{'script'}{'id2names'} = {
   q(0001) => [
      q(Afaka),
      ],
   q(0002) => [
      q(Caucasian Albanian),
      ],
   q(0003) => [
      q(Ahom, Tai Ahom),
      q(Ahom),
      q(Tai Ahom),
      ],
   q(0004) => [
      q(Arabic),
      ],
   q(0005) => [
      q(Imperial Aramaic),
      ],
   q(0006) => [
      q(Armenian),
      ],
   q(0007) => [
      q(Avestan),
      ],
   q(0008) => [
      q(Balinese),
      ],
   q(0009) => [
      q(Bamum),
      ],
   q(0010) => [
      q(Bassa Vah),
      ],
   q(0011) => [
      q(Batak),
      ],
   q(0012) => [
      q(Bengali),
      ],
   q(0013) => [
      q(Blissymbols),
      ],
   q(0014) => [
      q(Bopomofo),
      ],
   q(0015) => [
      q(Brahmi),
      ],
   q(0016) => [
      q(Braille),
      ],
   q(0017) => [
      q(Buginese),
      ],
   q(0018) => [
      q(Buhid),
      ],
   q(0019) => [
      q(Chakma),
      ],
   q(0020) => [
      q(Unified Canadian Aboriginal Syllabics),
      ],
   q(0021) => [
      q(Carian),
      ],
   q(0022) => [
      q(Cham),
      ],
   q(0023) => [
      q(Cherokee),
      ],
   q(0024) => [
      q(Cirth),
      ],
   q(0025) => [
      q(Coptic),
      ],
   q(0026) => [
      q(Cypriot),
      ],
   q(0027) => [
      q(Cyrillic),
      ],
   q(0028) => [
      q(Cyrillic (Old Church Slavonic variant)),
      ],
   q(0029) => [
      q(Devanagari (Nagari)),
      q(Devanagari),
      q(Nagari),
      ],
   q(0030) => [
      q(Deseret (Mormon)),
      q(Deseret),
      q(Mormon),
      ],
   q(0031) => [
      q(Duployan shorthand, Duployan stenography),
      q(Duployan shorthand),
      q(Duployan stenography),
      ],
   q(0032) => [
      q(Egyptian demotic),
      ],
   q(0033) => [
      q(Egyptian hieratic),
      ],
   q(0034) => [
      q(Egyptian hieroglyphs),
      ],
   q(0035) => [
      q(Elbasan),
      ],
   q(0036) => [
      q(Ethiopic (Geez)),
      q(Ethiopic),
      q(Ge'ez),
      ],
   q(0037) => [
      q(Georgian (Mkhedruli)),
      ],
   q(0038) => [
      q(Khutsuri (Asomtavruli and Nuskhuri)),
      ],
   q(0039) => [
      q(Glagolitic),
      ],
   q(0040) => [
      q(Gothic),
      ],
   q(0041) => [
      q(Grantha),
      ],
   q(0042) => [
      q(Greek),
      ],
   q(0043) => [
      q(Gujarati),
      ],
   q(0044) => [
      q(Gurmukhi),
      ],
   q(0045) => [
      q(Hangul (Hangul, Hangeul)),
      q(Hangul),
      q(Hangeul),
      ],
   q(0046) => [
      q(Han (Hanzi, Kanji, Hanja)),
      q(Han),
      q(Hanzi),
      q(Kanji),
      q(Hanja),
      ],
   q(0047) => [
      q(Hanunoo (Hanunoo)),
      q(Hanunoo),
      ],
   q(0048) => [
      q(Han (Simplified variant)),
      ],
   q(0049) => [
      q(Han (Traditional variant)),
      ],
   q(0050) => [
      q(Hatran),
      ],
   q(0051) => [
      q(Hebrew),
      ],
   q(0052) => [
      q(Hiragana),
      ],
   q(0053) => [
      q(Anatolian Hieroglyphs (Luwian Hieroglyphs, Hittite Hieroglyphs)),
      q(Anatolian Hieroglyphs),
      q(Luwian Hieroglyphs),
      q(Hittite Hieroglyphs),
      ],
   q(0054) => [
      q(Pahawh Hmong),
      ],
   q(0055) => [
      q(Japanese syllabaries (alias for Hiragana + Katakana)),
      ],
   q(0056) => [
      q(Old Hungarian (Hungarian Runic)),
      q(Old Hungarian),
      q(Hungarian Runic),
      ],
   q(0057) => [
      q(Indus (Harappan)),
      q(Indus),
      q(Harappan),
      ],
   q(0058) => [
      q(Old Italic (Etruscan, Oscan, etc.)),
      ],
   q(0059) => [
      q(Javanese),
      ],
   q(0060) => [
      q(Japanese (alias for Han + Hiragana + Katakana)),
      ],
   q(0061) => [
      q(Jurchen),
      ],
   q(0062) => [
      q(Kayah Li),
      ],
   q(0063) => [
      q(Katakana),
      ],
   q(0064) => [
      q(Kharoshthi),
      ],
   q(0065) => [
      q(Khmer),
      ],
   q(0066) => [
      q(Khojki),
      ],
   q(0067) => [
      q(Kannada),
      ],
   q(0068) => [
      q(Korean (alias for Hangul + Han)),
      ],
   q(0069) => [
      q(Kpelle),
      ],
   q(0070) => [
      q(Kaithi),
      ],
   q(0071) => [
      q(Tai Tham (Lanna)),
      q(Tai Tham),
      q(Lanna),
      ],
   q(0072) => [
      q(Lao),
      ],
   q(0073) => [
      q(Latin (Fraktur variant)),
      ],
   q(0074) => [
      q(Latin (Gaelic variant)),
      ],
   q(0075) => [
      q(Latin),
      ],
   q(0076) => [
      q(Lepcha (Rong)),
      q(Lepcha),
      q(Rong),
      ],
   q(0077) => [
      q(Limbu),
      ],
   q(0078) => [
      q(Linear A),
      ],
   q(0079) => [
      q(Linear B),
      ],
   q(0080) => [
      q(Lisu (Fraser)),
      q(Lisu),
      q(Fraser),
      ],
   q(0081) => [
      q(Loma),
      ],
   q(0082) => [
      q(Lycian),
      ],
   q(0083) => [
      q(Lydian),
      ],
   q(0084) => [
      q(Mahajani),
      ],
   q(0085) => [
      q(Mandaic, Mandaean),
      q(Mandaic),
      q(Mandaean),
      ],
   q(0086) => [
      q(Manichaean),
      ],
   q(0087) => [
      q(Mayan hieroglyphs),
      ],
   q(0088) => [
      q(Mende Kikakui),
      ],
   q(0089) => [
      q(Meroitic Cursive),
      ],
   q(0090) => [
      q(Meroitic Hieroglyphs),
      ],
   q(0091) => [
      q(Malayalam),
      ],
   q(0092) => [
      q(Modi, Modi),
      q( Multani),
      q(Modi),
      q(Multani),
      ],
   q(0093) => [
      q(Moon (Moon code, Moon script, Moon type)),
      q(Moon),
      q(Moon code),
      q(Moon script),
      q(Moon type),
      ],
   q(0094) => [
      q(Mongolian),
      ],
   q(0095) => [
      q(Mro, Mru),
      q(Mro),
      q(Mru),
      ],
   q(0096) => [
      q(Meitei Mayek (Meithei, Meetei)),
      q(Meitei Mayek),
      q(Meithei),
      q(Meetei),
      ],
   q(0097) => [
      q(Myanmar (Burmese)),
      q(Myanmar),
      q(Burmese),
      ],
   q(0098) => [
      q(Old North Arabian (Ancient North Arabian)),
      q(Old North Arabian),
      q(Ancient North Arabian),
      ],
   q(0099) => [
      q(Nabataean),
      ],
   q(0100) => [
      q(Nakhi Geba ('Na-'Khi Ggo-baw, Naxi Geba)),
      q(Nakhi Geba),
      q('Na-'Khi Ggo-baw),
      q(Naxi Geba),
      ],
   q(0101) => [
      q(N'Ko),
      ],
   q(0102) => [
      q(Nushu),
      ],
   q(0103) => [
      q(Ogham),
      ],
   q(0104) => [
      q(Ol Chiki (Ol Cemet, Ol, Santali)),
      q(Ol Chiki),
      q(Ol Cemet'),
      q(Ol),
      q(Santali),
      ],
   q(0105) => [
      q(Old Turkic, Orkhon Runic),
      q(Old Turkic),
      q(Orkhon Runic),
      ],
   q(0106) => [
      q(Oriya),
      ],
   q(0107) => [
      q(Osmanya),
      ],
   q(0108) => [
      q(Palmyrene),
      ],
   q(0109) => [
      q(Pau Cin Hau),
      ],
   q(0110) => [
      q(Old Permic),
      ],
   q(0111) => [
      q(Phags-pa),
      ],
   q(0112) => [
      q(Inscriptional Pahlavi),
      ],
   q(0113) => [
      q(Psalter Pahlavi),
      ],
   q(0114) => [
      q(Book Pahlavi),
      ],
   q(0115) => [
      q(Phoenician),
      ],
   q(0116) => [
      q(Miao (Pollard)),
      q(Miao),
      q(Pollard),
      ],
   q(0117) => [
      q(Inscriptional Parthian),
      ],
   q(0118) => [
      q(Reserved for private use (start)),
      ],
   q(0119) => [
      q(Reserved for private use (end)),
      ],
   q(0120) => [
      q(Rejang (Redjang, Kaganga)),
      q(Rejang),
      q(Redjang),
      q(Kaganga),
      ],
   q(0121) => [
      q(Rongorongo),
      ],
   q(0122) => [
      q(Runic),
      ],
   q(0123) => [
      q(Samaritan),
      ],
   q(0124) => [
      q(Sarati),
      ],
   q(0125) => [
      q(Old South Arabian),
      ],
   q(0126) => [
      q(Saurashtra),
      ],
   q(0127) => [
      q(SignWriting),
      ],
   q(0128) => [
      q(Shavian (Shaw)),
      q(Shavian),
      q(Shaw),
      ],
   q(0129) => [
      q(Sharada, Sarada),
      q(Sharada),
      q(Sarada),
      ],
   q(0130) => [
      q(Siddham, Siddham, Siddhamatrka),
      q(Siddham),
      q(Siddhamatrka),
      ],
   q(0131) => [
      q(Khudawadi, Sindhi),
      q(Khudawadi),
      q(Sindhi),
      ],
   q(0132) => [
      q(Sinhala),
      ],
   q(0133) => [
      q(Sora Sompeng),
      ],
   q(0134) => [
      q(Sundanese),
      ],
   q(0135) => [
      q(Syloti Nagri),
      ],
   q(0136) => [
      q(Syriac),
      ],
   q(0137) => [
      q(Syriac (Estrangelo variant)),
      ],
   q(0138) => [
      q(Syriac (Western variant)),
      ],
   q(0139) => [
      q(Syriac (Eastern variant)),
      ],
   q(0140) => [
      q(Tagbanwa),
      ],
   q(0141) => [
      q(Takri, Takri, Tankri),
      q(Takri),
      q(Tankri),
      ],
   q(0142) => [
      q(Tai Le),
      ],
   q(0143) => [
      q(New Tai Lue),
      ],
   q(0144) => [
      q(Tamil),
      ],
   q(0145) => [
      q(Tangut),
      ],
   q(0146) => [
      q(Tai Viet),
      ],
   q(0147) => [
      q(Telugu),
      ],
   q(0148) => [
      q(Tengwar),
      ],
   q(0149) => [
      q(Tifinagh (Berber)),
      q(Tifinagh),
      q(Berber),
      ],
   q(0150) => [
      q(Tagalog (Baybayin, Alibata)),
      q(Tagalog),
      q(Baybayin),
      q(Alibata),
      ],
   q(0151) => [
      q(Thaana),
      ],
   q(0152) => [
      q(Thai),
      ],
   q(0153) => [
      q(Tibetan),
      ],
   q(0154) => [
      q(Tirhuta),
      ],
   q(0155) => [
      q(Ugaritic),
      ],
   q(0156) => [
      q(Vai),
      ],
   q(0157) => [
      q(Visible Speech),
      ],
   q(0158) => [
      q(Warang Citi (Varang Kshiti)),
      q(Warang Citi),
      q(Varang Kshiti),
      ],
   q(0159) => [
      q(Woleai),
      ],
   q(0160) => [
      q(Old Persian),
      ],
   q(0161) => [
      q(Cuneiform, Sumero-Akkadian),
      q(Sumero-Akkadian cuneiform),
      ],
   q(0162) => [
      q(Yi),
      ],
   q(0163) => [
      q(Code for inherited script),
      ],
   q(0164) => [
      q(Mathematical notation),
      ],
   q(0165) => [
      q(Symbols),
      ],
};

$Locale::Codes::Data{'script'}{'alias2id'} = {
   q( multani) => [
      q(0092),
      q(1),
      ],
   q('na-'khi ggo-baw) => [
      q(0100),
      q(2),
      ],
   q(afaka) => [
      q(0001),
      q(0),
      ],
   q(ahom) => [
      q(0003),
      q(1),
      ],
   q(ahom, tai ahom) => [
      q(0003),
      q(0),
      ],
   q(alibata) => [
      q(0150),
      q(3),
      ],
   q(anatolian hieroglyphs) => [
      q(0053),
      q(1),
      ],
   q(anatolian hieroglyphs (luwian hieroglyphs, hittite hieroglyphs)) => [
      q(0053),
      q(0),
      ],
   q(ancient north arabian) => [
      q(0098),
      q(2),
      ],
   q(arabic) => [
      q(0004),
      q(0),
      ],
   q(armenian) => [
      q(0006),
      q(0),
      ],
   q(avestan) => [
      q(0007),
      q(0),
      ],
   q(balinese) => [
      q(0008),
      q(0),
      ],
   q(bamum) => [
      q(0009),
      q(0),
      ],
   q(bassa vah) => [
      q(0010),
      q(0),
      ],
   q(batak) => [
      q(0011),
      q(0),
      ],
   q(baybayin) => [
      q(0150),
      q(2),
      ],
   q(bengali) => [
      q(0012),
      q(0),
      ],
   q(berber) => [
      q(0149),
      q(2),
      ],
   q(blissymbols) => [
      q(0013),
      q(0),
      ],
   q(book pahlavi) => [
      q(0114),
      q(0),
      ],
   q(bopomofo) => [
      q(0014),
      q(0),
      ],
   q(brahmi) => [
      q(0015),
      q(0),
      ],
   q(braille) => [
      q(0016),
      q(0),
      ],
   q(buginese) => [
      q(0017),
      q(0),
      ],
   q(buhid) => [
      q(0018),
      q(0),
      ],
   q(burmese) => [
      q(0097),
      q(2),
      ],
   q(carian) => [
      q(0021),
      q(0),
      ],
   q(caucasian albanian) => [
      q(0002),
      q(0),
      ],
   q(chakma) => [
      q(0019),
      q(0),
      ],
   q(cham) => [
      q(0022),
      q(0),
      ],
   q(cherokee) => [
      q(0023),
      q(0),
      ],
   q(cirth) => [
      q(0024),
      q(0),
      ],
   q(code for inherited script) => [
      q(0163),
      q(0),
      ],
   q(coptic) => [
      q(0025),
      q(0),
      ],
   q(cuneiform, sumero-akkadian) => [
      q(0161),
      q(0),
      ],
   q(cypriot) => [
      q(0026),
      q(0),
      ],
   q(cyrillic) => [
      q(0027),
      q(0),
      ],
   q(cyrillic (old church slavonic variant)) => [
      q(0028),
      q(0),
      ],
   q(deseret) => [
      q(0030),
      q(1),
      ],
   q(deseret (mormon)) => [
      q(0030),
      q(0),
      ],
   q(devanagari) => [
      q(0029),
      q(1),
      ],
   q(devanagari (nagari)) => [
      q(0029),
      q(0),
      ],
   q(duployan shorthand) => [
      q(0031),
      q(1),
      ],
   q(duployan shorthand, duployan stenography) => [
      q(0031),
      q(0),
      ],
   q(duployan stenography) => [
      q(0031),
      q(2),
      ],
   q(egyptian demotic) => [
      q(0032),
      q(0),
      ],
   q(egyptian hieratic) => [
      q(0033),
      q(0),
      ],
   q(egyptian hieroglyphs) => [
      q(0034),
      q(0),
      ],
   q(elbasan) => [
      q(0035),
      q(0),
      ],
   q(ethiopic) => [
      q(0036),
      q(1),
      ],
   q(ethiopic (geez)) => [
      q(0036),
      q(0),
      ],
   q(fraser) => [
      q(0080),
      q(2),
      ],
   q(ge'ez) => [
      q(0036),
      q(2),
      ],
   q(georgian (mkhedruli)) => [
      q(0037),
      q(0),
      ],
   q(glagolitic) => [
      q(0039),
      q(0),
      ],
   q(gothic) => [
      q(0040),
      q(0),
      ],
   q(grantha) => [
      q(0041),
      q(0),
      ],
   q(greek) => [
      q(0042),
      q(0),
      ],
   q(gujarati) => [
      q(0043),
      q(0),
      ],
   q(gurmukhi) => [
      q(0044),
      q(0),
      ],
   q(han) => [
      q(0046),
      q(1),
      ],
   q(han (hanzi, kanji, hanja)) => [
      q(0046),
      q(0),
      ],
   q(han (simplified variant)) => [
      q(0048),
      q(0),
      ],
   q(han (traditional variant)) => [
      q(0049),
      q(0),
      ],
   q(hangeul) => [
      q(0045),
      q(2),
      ],
   q(hangul) => [
      q(0045),
      q(1),
      ],
   q(hangul (hangul, hangeul)) => [
      q(0045),
      q(0),
      ],
   q(hanja) => [
      q(0046),
      q(4),
      ],
   q(hanunoo) => [
      q(0047),
      q(1),
      ],
   q(hanunoo (hanunoo)) => [
      q(0047),
      q(0),
      ],
   q(hanzi) => [
      q(0046),
      q(2),
      ],
   q(harappan) => [
      q(0057),
      q(2),
      ],
   q(hatran) => [
      q(0050),
      q(0),
      ],
   q(hebrew) => [
      q(0051),
      q(0),
      ],
   q(hiragana) => [
      q(0052),
      q(0),
      ],
   q(hittite hieroglyphs) => [
      q(0053),
      q(3),
      ],
   q(hungarian runic) => [
      q(0056),
      q(2),
      ],
   q(imperial aramaic) => [
      q(0005),
      q(0),
      ],
   q(indus) => [
      q(0057),
      q(1),
      ],
   q(indus (harappan)) => [
      q(0057),
      q(0),
      ],
   q(inscriptional pahlavi) => [
      q(0112),
      q(0),
      ],
   q(inscriptional parthian) => [
      q(0117),
      q(0),
      ],
   q(japanese (alias for han + hiragana + katakana)) => [
      q(0060),
      q(0),
      ],
   q(japanese syllabaries (alias for hiragana + katakana)) => [
      q(0055),
      q(0),
      ],
   q(javanese) => [
      q(0059),
      q(0),
      ],
   q(jurchen) => [
      q(0061),
      q(0),
      ],
   q(kaganga) => [
      q(0120),
      q(3),
      ],
   q(kaithi) => [
      q(0070),
      q(0),
      ],
   q(kanji) => [
      q(0046),
      q(3),
      ],
   q(kannada) => [
      q(0067),
      q(0),
      ],
   q(katakana) => [
      q(0063),
      q(0),
      ],
   q(kayah li) => [
      q(0062),
      q(0),
      ],
   q(kharoshthi) => [
      q(0064),
      q(0),
      ],
   q(khmer) => [
      q(0065),
      q(0),
      ],
   q(khojki) => [
      q(0066),
      q(0),
      ],
   q(khudawadi) => [
      q(0131),
      q(1),
      ],
   q(khudawadi, sindhi) => [
      q(0131),
      q(0),
      ],
   q(khutsuri (asomtavruli and nuskhuri)) => [
      q(0038),
      q(0),
      ],
   q(korean (alias for hangul + han)) => [
      q(0068),
      q(0),
      ],
   q(kpelle) => [
      q(0069),
      q(0),
      ],
   q(lanna) => [
      q(0071),
      q(2),
      ],
   q(lao) => [
      q(0072),
      q(0),
      ],
   q(latin) => [
      q(0075),
      q(0),
      ],
   q(latin (fraktur variant)) => [
      q(0073),
      q(0),
      ],
   q(latin (gaelic variant)) => [
      q(0074),
      q(0),
      ],
   q(lepcha) => [
      q(0076),
      q(1),
      ],
   q(lepcha (rong)) => [
      q(0076),
      q(0),
      ],
   q(limbu) => [
      q(0077),
      q(0),
      ],
   q(linear a) => [
      q(0078),
      q(0),
      ],
   q(linear b) => [
      q(0079),
      q(0),
      ],
   q(lisu) => [
      q(0080),
      q(1),
      ],
   q(lisu (fraser)) => [
      q(0080),
      q(0),
      ],
   q(loma) => [
      q(0081),
      q(0),
      ],
   q(luwian hieroglyphs) => [
      q(0053),
      q(2),
      ],
   q(lycian) => [
      q(0082),
      q(0),
      ],
   q(lydian) => [
      q(0083),
      q(0),
      ],
   q(mahajani) => [
      q(0084),
      q(0),
      ],
   q(malayalam) => [
      q(0091),
      q(0),
      ],
   q(mandaean) => [
      q(0085),
      q(2),
      ],
   q(mandaic) => [
      q(0085),
      q(1),
      ],
   q(mandaic, mandaean) => [
      q(0085),
      q(0),
      ],
   q(manichaean) => [
      q(0086),
      q(0),
      ],
   q(mathematical notation) => [
      q(0164),
      q(0),
      ],
   q(mayan hieroglyphs) => [
      q(0087),
      q(0),
      ],
   q(meetei) => [
      q(0096),
      q(3),
      ],
   q(meitei mayek) => [
      q(0096),
      q(1),
      ],
   q(meitei mayek (meithei, meetei)) => [
      q(0096),
      q(0),
      ],
   q(meithei) => [
      q(0096),
      q(2),
      ],
   q(mende kikakui) => [
      q(0088),
      q(0),
      ],
   q(meroitic cursive) => [
      q(0089),
      q(0),
      ],
   q(meroitic hieroglyphs) => [
      q(0090),
      q(0),
      ],
   q(miao) => [
      q(0116),
      q(1),
      ],
   q(miao (pollard)) => [
      q(0116),
      q(0),
      ],
   q(modi) => [
      q(0092),
      q(2),
      ],
   q(modi, modi) => [
      q(0092),
      q(0),
      ],
   q(mongolian) => [
      q(0094),
      q(0),
      ],
   q(moon) => [
      q(0093),
      q(1),
      ],
   q(moon (moon code, moon script, moon type)) => [
      q(0093),
      q(0),
      ],
   q(moon code) => [
      q(0093),
      q(2),
      ],
   q(moon script) => [
      q(0093),
      q(3),
      ],
   q(moon type) => [
      q(0093),
      q(4),
      ],
   q(mormon) => [
      q(0030),
      q(2),
      ],
   q(mro) => [
      q(0095),
      q(1),
      ],
   q(mro, mru) => [
      q(0095),
      q(0),
      ],
   q(mru) => [
      q(0095),
      q(2),
      ],
   q(multani) => [
      q(0092),
      q(3),
      ],
   q(myanmar) => [
      q(0097),
      q(1),
      ],
   q(myanmar (burmese)) => [
      q(0097),
      q(0),
      ],
   q(n'ko) => [
      q(0101),
      q(0),
      ],
   q(nabataean) => [
      q(0099),
      q(0),
      ],
   q(nagari) => [
      q(0029),
      q(2),
      ],
   q(nakhi geba) => [
      q(0100),
      q(1),
      ],
   q(nakhi geba ('na-'khi ggo-baw, naxi geba)) => [
      q(0100),
      q(0),
      ],
   q(naxi geba) => [
      q(0100),
      q(3),
      ],
   q(new tai lue) => [
      q(0143),
      q(0),
      ],
   q(nushu) => [
      q(0102),
      q(0),
      ],
   q(ogham) => [
      q(0103),
      q(0),
      ],
   q(ol) => [
      q(0104),
      q(3),
      ],
   q(ol cemet') => [
      q(0104),
      q(2),
      ],
   q(ol chiki) => [
      q(0104),
      q(1),
      ],
   q(ol chiki (ol cemet, ol, santali)) => [
      q(0104),
      q(0),
      ],
   q(old hungarian) => [
      q(0056),
      q(1),
      ],
   q(old hungarian (hungarian runic)) => [
      q(0056),
      q(0),
      ],
   q(old italic (etruscan, oscan, etc.)) => [
      q(0058),
      q(0),
      ],
   q(old north arabian) => [
      q(0098),
      q(1),
      ],
   q(old north arabian (ancient north arabian)) => [
      q(0098),
      q(0),
      ],
   q(old permic) => [
      q(0110),
      q(0),
      ],
   q(old persian) => [
      q(0160),
      q(0),
      ],
   q(old south arabian) => [
      q(0125),
      q(0),
      ],
   q(old turkic) => [
      q(0105),
      q(1),
      ],
   q(old turkic, orkhon runic) => [
      q(0105),
      q(0),
      ],
   q(oriya) => [
      q(0106),
      q(0),
      ],
   q(orkhon runic) => [
      q(0105),
      q(2),
      ],
   q(osmanya) => [
      q(0107),
      q(0),
      ],
   q(pahawh hmong) => [
      q(0054),
      q(0),
      ],
   q(palmyrene) => [
      q(0108),
      q(0),
      ],
   q(pau cin hau) => [
      q(0109),
      q(0),
      ],
   q(phags-pa) => [
      q(0111),
      q(0),
      ],
   q(phoenician) => [
      q(0115),
      q(0),
      ],
   q(pollard) => [
      q(0116),
      q(2),
      ],
   q(psalter pahlavi) => [
      q(0113),
      q(0),
      ],
   q(redjang) => [
      q(0120),
      q(2),
      ],
   q(rejang) => [
      q(0120),
      q(1),
      ],
   q(rejang (redjang, kaganga)) => [
      q(0120),
      q(0),
      ],
   q(reserved for private use (end)) => [
      q(0119),
      q(0),
      ],
   q(reserved for private use (start)) => [
      q(0118),
      q(0),
      ],
   q(rong) => [
      q(0076),
      q(2),
      ],
   q(rongorongo) => [
      q(0121),
      q(0),
      ],
   q(runic) => [
      q(0122),
      q(0),
      ],
   q(samaritan) => [
      q(0123),
      q(0),
      ],
   q(santali) => [
      q(0104),
      q(4),
      ],
   q(sarada) => [
      q(0129),
      q(2),
      ],
   q(sarati) => [
      q(0124),
      q(0),
      ],
   q(saurashtra) => [
      q(0126),
      q(0),
      ],
   q(sharada) => [
      q(0129),
      q(1),
      ],
   q(sharada, sarada) => [
      q(0129),
      q(0),
      ],
   q(shavian) => [
      q(0128),
      q(1),
      ],
   q(shavian (shaw)) => [
      q(0128),
      q(0),
      ],
   q(shaw) => [
      q(0128),
      q(2),
      ],
   q(siddham) => [
      q(0130),
      q(1),
      ],
   q(siddham, siddham, siddhamatrka) => [
      q(0130),
      q(0),
      ],
   q(siddhamatrka) => [
      q(0130),
      q(2),
      ],
   q(signwriting) => [
      q(0127),
      q(0),
      ],
   q(sindhi) => [
      q(0131),
      q(2),
      ],
   q(sinhala) => [
      q(0132),
      q(0),
      ],
   q(sora sompeng) => [
      q(0133),
      q(0),
      ],
   q(sumero-akkadian cuneiform) => [
      q(0161),
      q(1),
      ],
   q(sundanese) => [
      q(0134),
      q(0),
      ],
   q(syloti nagri) => [
      q(0135),
      q(0),
      ],
   q(symbols) => [
      q(0165),
      q(0),
      ],
   q(syriac) => [
      q(0136),
      q(0),
      ],
   q(syriac (eastern variant)) => [
      q(0139),
      q(0),
      ],
   q(syriac (estrangelo variant)) => [
      q(0137),
      q(0),
      ],
   q(syriac (western variant)) => [
      q(0138),
      q(0),
      ],
   q(tagalog) => [
      q(0150),
      q(1),
      ],
   q(tagalog (baybayin, alibata)) => [
      q(0150),
      q(0),
      ],
   q(tagbanwa) => [
      q(0140),
      q(0),
      ],
   q(tai ahom) => [
      q(0003),
      q(2),
      ],
   q(tai le) => [
      q(0142),
      q(0),
      ],
   q(tai tham) => [
      q(0071),
      q(1),
      ],
   q(tai tham (lanna)) => [
      q(0071),
      q(0),
      ],
   q(tai viet) => [
      q(0146),
      q(0),
      ],
   q(takri) => [
      q(0141),
      q(1),
      ],
   q(takri, takri, tankri) => [
      q(0141),
      q(0),
      ],
   q(tamil) => [
      q(0144),
      q(0),
      ],
   q(tangut) => [
      q(0145),
      q(0),
      ],
   q(tankri) => [
      q(0141),
      q(2),
      ],
   q(telugu) => [
      q(0147),
      q(0),
      ],
   q(tengwar) => [
      q(0148),
      q(0),
      ],
   q(thaana) => [
      q(0151),
      q(0),
      ],
   q(thai) => [
      q(0152),
      q(0),
      ],
   q(tibetan) => [
      q(0153),
      q(0),
      ],
   q(tifinagh) => [
      q(0149),
      q(1),
      ],
   q(tifinagh (berber)) => [
      q(0149),
      q(0),
      ],
   q(tirhuta) => [
      q(0154),
      q(0),
      ],
   q(ugaritic) => [
      q(0155),
      q(0),
      ],
   q(unified canadian aboriginal syllabics) => [
      q(0020),
      q(0),
      ],
   q(vai) => [
      q(0156),
      q(0),
      ],
   q(varang kshiti) => [
      q(0158),
      q(2),
      ],
   q(visible speech) => [
      q(0157),
      q(0),
      ],
   q(warang citi) => [
      q(0158),
      q(1),
      ],
   q(warang citi (varang kshiti)) => [
      q(0158),
      q(0),
      ],
   q(woleai) => [
      q(0159),
      q(0),
      ],
   q(yi) => [
      q(0162),
      q(0),
      ],
};

$Locale::Codes::Data{'script'}{'code2id'} = {
   q(alpha) => {
      q(Afak) => [
         q(0001),
         q(0),
         ],
      q(Aghb) => [
         q(0002),
         q(0),
         ],
      q(Ahom) => [
         q(0003),
         q(1),
         ],
      q(Arab) => [
         q(0004),
         q(0),
         ],
      q(Armi) => [
         q(0005),
         q(0),
         ],
      q(Armn) => [
         q(0006),
         q(0),
         ],
      q(Avst) => [
         q(0007),
         q(0),
         ],
      q(Bali) => [
         q(0008),
         q(0),
         ],
      q(Bamu) => [
         q(0009),
         q(0),
         ],
      q(Bass) => [
         q(0010),
         q(0),
         ],
      q(Batk) => [
         q(0011),
         q(0),
         ],
      q(Beng) => [
         q(0012),
         q(0),
         ],
      q(Blis) => [
         q(0013),
         q(0),
         ],
      q(Bopo) => [
         q(0014),
         q(0),
         ],
      q(Brah) => [
         q(0015),
         q(0),
         ],
      q(Brai) => [
         q(0016),
         q(0),
         ],
      q(Bugi) => [
         q(0017),
         q(0),
         ],
      q(Buhd) => [
         q(0018),
         q(0),
         ],
      q(Cakm) => [
         q(0019),
         q(0),
         ],
      q(Cans) => [
         q(0020),
         q(0),
         ],
      q(Cari) => [
         q(0021),
         q(0),
         ],
      q(Cham) => [
         q(0022),
         q(0),
         ],
      q(Cher) => [
         q(0023),
         q(0),
         ],
      q(Cirt) => [
         q(0024),
         q(0),
         ],
      q(Copt) => [
         q(0025),
         q(0),
         ],
      q(Cprt) => [
         q(0026),
         q(0),
         ],
      q(Cyrl) => [
         q(0027),
         q(0),
         ],
      q(Cyrs) => [
         q(0028),
         q(0),
         ],
      q(Deva) => [
         q(0029),
         q(1),
         ],
      q(Dsrt) => [
         q(0030),
         q(1),
         ],
      q(Dupl) => [
         q(0031),
         q(1),
         ],
      q(Egyd) => [
         q(0032),
         q(0),
         ],
      q(Egyh) => [
         q(0033),
         q(0),
         ],
      q(Egyp) => [
         q(0034),
         q(0),
         ],
      q(Elba) => [
         q(0035),
         q(0),
         ],
      q(Ethi) => [
         q(0036),
         q(1),
         ],
      q(Geok) => [
         q(0038),
         q(0),
         ],
      q(Geor) => [
         q(0037),
         q(0),
         ],
      q(Glag) => [
         q(0039),
         q(0),
         ],
      q(Goth) => [
         q(0040),
         q(0),
         ],
      q(Gran) => [
         q(0041),
         q(0),
         ],
      q(Grek) => [
         q(0042),
         q(0),
         ],
      q(Gujr) => [
         q(0043),
         q(0),
         ],
      q(Guru) => [
         q(0044),
         q(0),
         ],
      q(Hang) => [
         q(0045),
         q(1),
         ],
      q(Hani) => [
         q(0046),
         q(1),
         ],
      q(Hano) => [
         q(0047),
         q(1),
         ],
      q(Hans) => [
         q(0048),
         q(0),
         ],
      q(Hant) => [
         q(0049),
         q(0),
         ],
      q(Hatr) => [
         q(0050),
         q(0),
         ],
      q(Hebr) => [
         q(0051),
         q(0),
         ],
      q(Hira) => [
         q(0052),
         q(0),
         ],
      q(Hluw) => [
         q(0053),
         q(1),
         ],
      q(Hmng) => [
         q(0054),
         q(0),
         ],
      q(Hrkt) => [
         q(0055),
         q(0),
         ],
      q(Hung) => [
         q(0056),
         q(1),
         ],
      q(Inds) => [
         q(0057),
         q(1),
         ],
      q(Ital) => [
         q(0058),
         q(0),
         ],
      q(Java) => [
         q(0059),
         q(0),
         ],
      q(Jpan) => [
         q(0060),
         q(0),
         ],
      q(Jurc) => [
         q(0061),
         q(0),
         ],
      q(Kali) => [
         q(0062),
         q(0),
         ],
      q(Kana) => [
         q(0063),
         q(0),
         ],
      q(Khar) => [
         q(0064),
         q(0),
         ],
      q(Khmr) => [
         q(0065),
         q(0),
         ],
      q(Khoj) => [
         q(0066),
         q(0),
         ],
      q(Knda) => [
         q(0067),
         q(0),
         ],
      q(Kore) => [
         q(0068),
         q(0),
         ],
      q(Kpel) => [
         q(0069),
         q(0),
         ],
      q(Kthi) => [
         q(0070),
         q(0),
         ],
      q(Lana) => [
         q(0071),
         q(1),
         ],
      q(Laoo) => [
         q(0072),
         q(0),
         ],
      q(Latf) => [
         q(0073),
         q(0),
         ],
      q(Latg) => [
         q(0074),
         q(0),
         ],
      q(Latn) => [
         q(0075),
         q(0),
         ],
      q(Lepc) => [
         q(0076),
         q(1),
         ],
      q(Limb) => [
         q(0077),
         q(0),
         ],
      q(Lina) => [
         q(0078),
         q(0),
         ],
      q(Linb) => [
         q(0079),
         q(0),
         ],
      q(Lisu) => [
         q(0080),
         q(1),
         ],
      q(Loma) => [
         q(0081),
         q(0),
         ],
      q(Lyci) => [
         q(0082),
         q(0),
         ],
      q(Lydi) => [
         q(0083),
         q(0),
         ],
      q(Mahj) => [
         q(0084),
         q(0),
         ],
      q(Mand) => [
         q(0085),
         q(1),
         ],
      q(Mani) => [
         q(0086),
         q(0),
         ],
      q(Maya) => [
         q(0087),
         q(0),
         ],
      q(Mend) => [
         q(0088),
         q(0),
         ],
      q(Merc) => [
         q(0089),
         q(0),
         ],
      q(Mero) => [
         q(0090),
         q(0),
         ],
      q(Mlym) => [
         q(0091),
         q(0),
         ],
      q(Modi) => [
         q(0092),
         q(2),
         ],
      q(Mong) => [
         q(0094),
         q(0),
         ],
      q(Moon) => [
         q(0093),
         q(1),
         ],
      q(Mroo) => [
         q(0095),
         q(1),
         ],
      q(Mtei) => [
         q(0096),
         q(1),
         ],
      q(Mult) => [
         q(0092),
         q(3),
         ],
      q(Mymr) => [
         q(0097),
         q(1),
         ],
      q(Narb) => [
         q(0098),
         q(1),
         ],
      q(Nbat) => [
         q(0099),
         q(0),
         ],
      q(Nkgb) => [
         q(0100),
         q(1),
         ],
      q(Nkoo) => [
         q(0101),
         q(0),
         ],
      q(Nshu) => [
         q(0102),
         q(0),
         ],
      q(Ogam) => [
         q(0103),
         q(0),
         ],
      q(Olck) => [
         q(0104),
         q(1),
         ],
      q(Orkh) => [
         q(0105),
         q(1),
         ],
      q(Orya) => [
         q(0106),
         q(0),
         ],
      q(Osma) => [
         q(0107),
         q(0),
         ],
      q(Palm) => [
         q(0108),
         q(0),
         ],
      q(Pauc) => [
         q(0109),
         q(0),
         ],
      q(Perm) => [
         q(0110),
         q(0),
         ],
      q(Phag) => [
         q(0111),
         q(0),
         ],
      q(Phli) => [
         q(0112),
         q(0),
         ],
      q(Phlp) => [
         q(0113),
         q(0),
         ],
      q(Phlv) => [
         q(0114),
         q(0),
         ],
      q(Phnx) => [
         q(0115),
         q(0),
         ],
      q(Plrd) => [
         q(0116),
         q(1),
         ],
      q(Prti) => [
         q(0117),
         q(0),
         ],
      q(Qaaa) => [
         q(0118),
         q(0),
         ],
      q(Qabx) => [
         q(0119),
         q(0),
         ],
      q(Rjng) => [
         q(0120),
         q(1),
         ],
      q(Roro) => [
         q(0121),
         q(0),
         ],
      q(Runr) => [
         q(0122),
         q(0),
         ],
      q(Samr) => [
         q(0123),
         q(0),
         ],
      q(Sara) => [
         q(0124),
         q(0),
         ],
      q(Sarb) => [
         q(0125),
         q(0),
         ],
      q(Saur) => [
         q(0126),
         q(0),
         ],
      q(Sgnw) => [
         q(0127),
         q(0),
         ],
      q(Shaw) => [
         q(0128),
         q(1),
         ],
      q(Shrd) => [
         q(0129),
         q(1),
         ],
      q(Sidd) => [
         q(0130),
         q(1),
         ],
      q(Sind) => [
         q(0131),
         q(1),
         ],
      q(Sinh) => [
         q(0132),
         q(0),
         ],
      q(Sora) => [
         q(0133),
         q(0),
         ],
      q(Sund) => [
         q(0134),
         q(0),
         ],
      q(Sylo) => [
         q(0135),
         q(0),
         ],
      q(Syrc) => [
         q(0136),
         q(0),
         ],
      q(Syre) => [
         q(0137),
         q(0),
         ],
      q(Syrj) => [
         q(0138),
         q(0),
         ],
      q(Syrn) => [
         q(0139),
         q(0),
         ],
      q(Tagb) => [
         q(0140),
         q(0),
         ],
      q(Takr) => [
         q(0141),
         q(1),
         ],
      q(Tale) => [
         q(0142),
         q(0),
         ],
      q(Talu) => [
         q(0143),
         q(0),
         ],
      q(Taml) => [
         q(0144),
         q(0),
         ],
      q(Tang) => [
         q(0145),
         q(0),
         ],
      q(Tavt) => [
         q(0146),
         q(0),
         ],
      q(Telu) => [
         q(0147),
         q(0),
         ],
      q(Teng) => [
         q(0148),
         q(0),
         ],
      q(Tfng) => [
         q(0149),
         q(1),
         ],
      q(Tglg) => [
         q(0150),
         q(1),
         ],
      q(Thaa) => [
         q(0151),
         q(0),
         ],
      q(Thai) => [
         q(0152),
         q(0),
         ],
      q(Tibt) => [
         q(0153),
         q(0),
         ],
      q(Tirh) => [
         q(0154),
         q(0),
         ],
      q(Ugar) => [
         q(0155),
         q(0),
         ],
      q(Vaii) => [
         q(0156),
         q(0),
         ],
      q(Visp) => [
         q(0157),
         q(0),
         ],
      q(Wara) => [
         q(0158),
         q(1),
         ],
      q(Wole) => [
         q(0159),
         q(0),
         ],
      q(Xpeo) => [
         q(0160),
         q(0),
         ],
      q(Xsux) => [
         q(0161),
         q(1),
         ],
      q(Yiii) => [
         q(0162),
         q(0),
         ],
      q(Zinh) => [
         q(0163),
         q(0),
         ],
      q(Zmth) => [
         q(0164),
         q(0),
         ],
      q(Zsym) => [
         q(0165),
         q(0),
         ],
      },
   q(num) => {
      q(020) => [
         q(0161),
         q(0),
         ],
      q(030) => [
         q(0160),
         q(0),
         ],
      q(040) => [
         q(0155),
         q(0),
         ],
      q(050) => [
         q(0034),
         q(0),
         ],
      q(060) => [
         q(0033),
         q(0),
         ],
      q(070) => [
         q(0032),
         q(0),
         ],
      q(080) => [
         q(0053),
         q(0),
         ],
      q(090) => [
         q(0087),
         q(0),
         ],
      q(095) => [
         q(0127),
         q(0),
         ],
      q(100) => [
         q(0090),
         q(0),
         ],
      q(101) => [
         q(0089),
         q(0),
         ],
      q(105) => [
         q(0125),
         q(0),
         ],
      q(106) => [
         q(0098),
         q(0),
         ],
      q(115) => [
         q(0115),
         q(0),
         ],
      q(116) => [
         q(0083),
         q(0),
         ],
      q(120) => [
         q(0149),
         q(0),
         ],
      q(123) => [
         q(0123),
         q(0),
         ],
      q(124) => [
         q(0005),
         q(0),
         ],
      q(125) => [
         q(0051),
         q(0),
         ],
      q(126) => [
         q(0108),
         q(0),
         ],
      q(127) => [
         q(0050),
         q(0),
         ],
      q(130) => [
         q(0117),
         q(0),
         ],
      q(131) => [
         q(0112),
         q(0),
         ],
      q(132) => [
         q(0113),
         q(0),
         ],
      q(133) => [
         q(0114),
         q(0),
         ],
      q(134) => [
         q(0007),
         q(0),
         ],
      q(135) => [
         q(0136),
         q(0),
         ],
      q(136) => [
         q(0139),
         q(0),
         ],
      q(137) => [
         q(0138),
         q(0),
         ],
      q(138) => [
         q(0137),
         q(0),
         ],
      q(139) => [
         q(0086),
         q(0),
         ],
      q(140) => [
         q(0085),
         q(0),
         ],
      q(145) => [
         q(0094),
         q(0),
         ],
      q(159) => [
         q(0099),
         q(0),
         ],
      q(160) => [
         q(0004),
         q(0),
         ],
      q(165) => [
         q(0101),
         q(0),
         ],
      q(170) => [
         q(0151),
         q(0),
         ],
      q(175) => [
         q(0105),
         q(0),
         ],
      q(176) => [
         q(0056),
         q(0),
         ],
      q(199) => [
         q(0095),
         q(0),
         ],
      q(200) => [
         q(0042),
         q(0),
         ],
      q(201) => [
         q(0021),
         q(0),
         ],
      q(202) => [
         q(0082),
         q(0),
         ],
      q(204) => [
         q(0025),
         q(0),
         ],
      q(206) => [
         q(0040),
         q(0),
         ],
      q(210) => [
         q(0058),
         q(0),
         ],
      q(211) => [
         q(0122),
         q(0),
         ],
      q(212) => [
         q(0103),
         q(0),
         ],
      q(215) => [
         q(0075),
         q(0),
         ],
      q(216) => [
         q(0074),
         q(0),
         ],
      q(217) => [
         q(0073),
         q(0),
         ],
      q(218) => [
         q(0093),
         q(0),
         ],
      q(220) => [
         q(0027),
         q(0),
         ],
      q(221) => [
         q(0028),
         q(0),
         ],
      q(225) => [
         q(0039),
         q(0),
         ],
      q(226) => [
         q(0035),
         q(0),
         ],
      q(227) => [
         q(0110),
         q(0),
         ],
      q(230) => [
         q(0006),
         q(0),
         ],
      q(239) => [
         q(0002),
         q(0),
         ],
      q(240) => [
         q(0037),
         q(0),
         ],
      q(241) => [
         q(0038),
         q(0),
         ],
      q(250) => [
         q(0030),
         q(0),
         ],
      q(259) => [
         q(0010),
         q(0),
         ],
      q(260) => [
         q(0107),
         q(0),
         ],
      q(261) => [
         q(0104),
         q(0),
         ],
      q(262) => [
         q(0158),
         q(0),
         ],
      q(263) => [
         q(0109),
         q(0),
         ],
      q(280) => [
         q(0157),
         q(0),
         ],
      q(281) => [
         q(0128),
         q(0),
         ],
      q(282) => [
         q(0116),
         q(0),
         ],
      q(285) => [
         q(0014),
         q(0),
         ],
      q(286) => [
         q(0045),
         q(0),
         ],
      q(287) => [
         q(0068),
         q(0),
         ],
      q(290) => [
         q(0148),
         q(0),
         ],
      q(291) => [
         q(0024),
         q(0),
         ],
      q(292) => [
         q(0124),
         q(0),
         ],
      q(300) => [
         q(0015),
         q(0),
         ],
      q(302) => [
         q(0130),
         q(0),
         ],
      q(305) => [
         q(0064),
         q(0),
         ],
      q(310) => [
         q(0044),
         q(0),
         ],
      q(314) => [
         q(0084),
         q(0),
         ],
      q(315) => [
         q(0029),
         q(0),
         ],
      q(316) => [
         q(0135),
         q(0),
         ],
      q(317) => [
         q(0070),
         q(0),
         ],
      q(318) => [
         q(0131),
         q(0),
         ],
      q(319) => [
         q(0129),
         q(0),
         ],
      q(320) => [
         q(0043),
         q(0),
         ],
      q(321) => [
         q(0141),
         q(0),
         ],
      q(322) => [
         q(0066),
         q(0),
         ],
      q(323) => [
         q(0092),
         q(1),
         ],
      q(325) => [
         q(0012),
         q(0),
         ],
      q(326) => [
         q(0154),
         q(0),
         ],
      q(327) => [
         q(0106),
         q(0),
         ],
      q(330) => [
         q(0153),
         q(0),
         ],
      q(331) => [
         q(0111),
         q(0),
         ],
      q(335) => [
         q(0076),
         q(0),
         ],
      q(336) => [
         q(0077),
         q(0),
         ],
      q(337) => [
         q(0096),
         q(0),
         ],
      q(338) => [
         q(0003),
         q(0),
         ],
      q(340) => [
         q(0147),
         q(0),
         ],
      q(343) => [
         q(0041),
         q(0),
         ],
      q(344) => [
         q(0126),
         q(0),
         ],
      q(345) => [
         q(0067),
         q(0),
         ],
      q(346) => [
         q(0144),
         q(0),
         ],
      q(347) => [
         q(0091),
         q(0),
         ],
      q(348) => [
         q(0132),
         q(0),
         ],
      q(349) => [
         q(0019),
         q(0),
         ],
      q(350) => [
         q(0097),
         q(0),
         ],
      q(351) => [
         q(0071),
         q(0),
         ],
      q(352) => [
         q(0152),
         q(0),
         ],
      q(353) => [
         q(0142),
         q(0),
         ],
      q(354) => [
         q(0143),
         q(0),
         ],
      q(355) => [
         q(0065),
         q(0),
         ],
      q(356) => [
         q(0072),
         q(0),
         ],
      q(357) => [
         q(0062),
         q(0),
         ],
      q(358) => [
         q(0022),
         q(0),
         ],
      q(359) => [
         q(0146),
         q(0),
         ],
      q(360) => [
         q(0008),
         q(0),
         ],
      q(361) => [
         q(0059),
         q(0),
         ],
      q(362) => [
         q(0134),
         q(0),
         ],
      q(363) => [
         q(0120),
         q(0),
         ],
      q(365) => [
         q(0011),
         q(0),
         ],
      q(367) => [
         q(0017),
         q(0),
         ],
      q(370) => [
         q(0150),
         q(0),
         ],
      q(371) => [
         q(0047),
         q(0),
         ],
      q(372) => [
         q(0018),
         q(0),
         ],
      q(373) => [
         q(0140),
         q(0),
         ],
      q(398) => [
         q(0133),
         q(0),
         ],
      q(399) => [
         q(0080),
         q(0),
         ],
      q(400) => [
         q(0078),
         q(0),
         ],
      q(401) => [
         q(0079),
         q(0),
         ],
      q(403) => [
         q(0026),
         q(0),
         ],
      q(410) => [
         q(0052),
         q(0),
         ],
      q(411) => [
         q(0063),
         q(0),
         ],
      q(412) => [
         q(0055),
         q(0),
         ],
      q(413) => [
         q(0060),
         q(0),
         ],
      q(420) => [
         q(0100),
         q(0),
         ],
      q(430) => [
         q(0036),
         q(0),
         ],
      q(435) => [
         q(0009),
         q(0),
         ],
      q(436) => [
         q(0069),
         q(0),
         ],
      q(437) => [
         q(0081),
         q(0),
         ],
      q(438) => [
         q(0088),
         q(0),
         ],
      q(439) => [
         q(0001),
         q(0),
         ],
      q(440) => [
         q(0020),
         q(0),
         ],
      q(445) => [
         q(0023),
         q(0),
         ],
      q(450) => [
         q(0054),
         q(0),
         ],
      q(460) => [
         q(0162),
         q(0),
         ],
      q(470) => [
         q(0156),
         q(0),
         ],
      q(480) => [
         q(0159),
         q(0),
         ],
      q(499) => [
         q(0102),
         q(0),
         ],
      q(500) => [
         q(0046),
         q(0),
         ],
      q(501) => [
         q(0048),
         q(0),
         ],
      q(502) => [
         q(0049),
         q(0),
         ],
      q(510) => [
         q(0061),
         q(0),
         ],
      q(520) => [
         q(0145),
         q(0),
         ],
      q(550) => [
         q(0013),
         q(0),
         ],
      q(570) => [
         q(0016),
         q(0),
         ],
      q(610) => [
         q(0057),
         q(0),
         ],
      q(620) => [
         q(0121),
         q(0),
         ],
      q(755) => [
         q(0031),
         q(0),
         ],
      q(900) => [
         q(0118),
         q(0),
         ],
      q(949) => [
         q(0119),
         q(0),
         ],
      q(994) => [
         q(0163),
         q(0),
         ],
      q(995) => [
         q(0164),
         q(0),
         ],
      q(996) => [
         q(0165),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'script'}{'id2code'} = {
   q(alpha) => {
      q(0001) => q(Afak),
      q(0002) => q(Aghb),
      q(0003) => q(Ahom),
      q(0004) => q(Arab),
      q(0005) => q(Armi),
      q(0006) => q(Armn),
      q(0007) => q(Avst),
      q(0008) => q(Bali),
      q(0009) => q(Bamu),
      q(0010) => q(Bass),
      q(0011) => q(Batk),
      q(0012) => q(Beng),
      q(0013) => q(Blis),
      q(0014) => q(Bopo),
      q(0015) => q(Brah),
      q(0016) => q(Brai),
      q(0017) => q(Bugi),
      q(0018) => q(Buhd),
      q(0019) => q(Cakm),
      q(0020) => q(Cans),
      q(0021) => q(Cari),
      q(0022) => q(Cham),
      q(0023) => q(Cher),
      q(0024) => q(Cirt),
      q(0025) => q(Copt),
      q(0026) => q(Cprt),
      q(0027) => q(Cyrl),
      q(0028) => q(Cyrs),
      q(0029) => q(Deva),
      q(0030) => q(Dsrt),
      q(0031) => q(Dupl),
      q(0032) => q(Egyd),
      q(0033) => q(Egyh),
      q(0034) => q(Egyp),
      q(0035) => q(Elba),
      q(0036) => q(Ethi),
      q(0037) => q(Geor),
      q(0038) => q(Geok),
      q(0039) => q(Glag),
      q(0040) => q(Goth),
      q(0041) => q(Gran),
      q(0042) => q(Grek),
      q(0043) => q(Gujr),
      q(0044) => q(Guru),
      q(0045) => q(Hang),
      q(0046) => q(Hani),
      q(0047) => q(Hano),
      q(0048) => q(Hans),
      q(0049) => q(Hant),
      q(0050) => q(Hatr),
      q(0051) => q(Hebr),
      q(0052) => q(Hira),
      q(0053) => q(Hluw),
      q(0054) => q(Hmng),
      q(0055) => q(Hrkt),
      q(0056) => q(Hung),
      q(0057) => q(Inds),
      q(0058) => q(Ital),
      q(0059) => q(Java),
      q(0060) => q(Jpan),
      q(0061) => q(Jurc),
      q(0062) => q(Kali),
      q(0063) => q(Kana),
      q(0064) => q(Khar),
      q(0065) => q(Khmr),
      q(0066) => q(Khoj),
      q(0067) => q(Knda),
      q(0068) => q(Kore),
      q(0069) => q(Kpel),
      q(0070) => q(Kthi),
      q(0071) => q(Lana),
      q(0072) => q(Laoo),
      q(0073) => q(Latf),
      q(0074) => q(Latg),
      q(0075) => q(Latn),
      q(0076) => q(Lepc),
      q(0077) => q(Limb),
      q(0078) => q(Lina),
      q(0079) => q(Linb),
      q(0080) => q(Lisu),
      q(0081) => q(Loma),
      q(0082) => q(Lyci),
      q(0083) => q(Lydi),
      q(0084) => q(Mahj),
      q(0085) => q(Mand),
      q(0086) => q(Mani),
      q(0087) => q(Maya),
      q(0088) => q(Mend),
      q(0089) => q(Merc),
      q(0090) => q(Mero),
      q(0091) => q(Mlym),
      q(0092) => q(Mult),
      q(0093) => q(Moon),
      q(0094) => q(Mong),
      q(0095) => q(Mroo),
      q(0096) => q(Mtei),
      q(0097) => q(Mymr),
      q(0098) => q(Narb),
      q(0099) => q(Nbat),
      q(0100) => q(Nkgb),
      q(0101) => q(Nkoo),
      q(0102) => q(Nshu),
      q(0103) => q(Ogam),
      q(0104) => q(Olck),
      q(0105) => q(Orkh),
      q(0106) => q(Orya),
      q(0107) => q(Osma),
      q(0108) => q(Palm),
      q(0109) => q(Pauc),
      q(0110) => q(Perm),
      q(0111) => q(Phag),
      q(0112) => q(Phli),
      q(0113) => q(Phlp),
      q(0114) => q(Phlv),
      q(0115) => q(Phnx),
      q(0116) => q(Plrd),
      q(0117) => q(Prti),
      q(0118) => q(Qaaa),
      q(0119) => q(Qabx),
      q(0120) => q(Rjng),
      q(0121) => q(Roro),
      q(0122) => q(Runr),
      q(0123) => q(Samr),
      q(0124) => q(Sara),
      q(0125) => q(Sarb),
      q(0126) => q(Saur),
      q(0127) => q(Sgnw),
      q(0128) => q(Shaw),
      q(0129) => q(Shrd),
      q(0130) => q(Sidd),
      q(0131) => q(Sind),
      q(0132) => q(Sinh),
      q(0133) => q(Sora),
      q(0134) => q(Sund),
      q(0135) => q(Sylo),
      q(0136) => q(Syrc),
      q(0137) => q(Syre),
      q(0138) => q(Syrj),
      q(0139) => q(Syrn),
      q(0140) => q(Tagb),
      q(0141) => q(Takr),
      q(0142) => q(Tale),
      q(0143) => q(Talu),
      q(0144) => q(Taml),
      q(0145) => q(Tang),
      q(0146) => q(Tavt),
      q(0147) => q(Telu),
      q(0148) => q(Teng),
      q(0149) => q(Tfng),
      q(0150) => q(Tglg),
      q(0151) => q(Thaa),
      q(0152) => q(Thai),
      q(0153) => q(Tibt),
      q(0154) => q(Tirh),
      q(0155) => q(Ugar),
      q(0156) => q(Vaii),
      q(0157) => q(Visp),
      q(0158) => q(Wara),
      q(0159) => q(Wole),
      q(0160) => q(Xpeo),
      q(0161) => q(Xsux),
      q(0162) => q(Yiii),
      q(0163) => q(Zinh),
      q(0164) => q(Zmth),
      q(0165) => q(Zsym),
      },
   q(num) => {
      q(0001) => q(439),
      q(0002) => q(239),
      q(0003) => q(338),
      q(0004) => q(160),
      q(0005) => q(124),
      q(0006) => q(230),
      q(0007) => q(134),
      q(0008) => q(360),
      q(0009) => q(435),
      q(0010) => q(259),
      q(0011) => q(365),
      q(0012) => q(325),
      q(0013) => q(550),
      q(0014) => q(285),
      q(0015) => q(300),
      q(0016) => q(570),
      q(0017) => q(367),
      q(0018) => q(372),
      q(0019) => q(349),
      q(0020) => q(440),
      q(0021) => q(201),
      q(0022) => q(358),
      q(0023) => q(445),
      q(0024) => q(291),
      q(0025) => q(204),
      q(0026) => q(403),
      q(0027) => q(220),
      q(0028) => q(221),
      q(0029) => q(315),
      q(0030) => q(250),
      q(0031) => q(755),
      q(0032) => q(070),
      q(0033) => q(060),
      q(0034) => q(050),
      q(0035) => q(226),
      q(0036) => q(430),
      q(0037) => q(240),
      q(0038) => q(241),
      q(0039) => q(225),
      q(0040) => q(206),
      q(0041) => q(343),
      q(0042) => q(200),
      q(0043) => q(320),
      q(0044) => q(310),
      q(0045) => q(286),
      q(0046) => q(500),
      q(0047) => q(371),
      q(0048) => q(501),
      q(0049) => q(502),
      q(0050) => q(127),
      q(0051) => q(125),
      q(0052) => q(410),
      q(0053) => q(080),
      q(0054) => q(450),
      q(0055) => q(412),
      q(0056) => q(176),
      q(0057) => q(610),
      q(0058) => q(210),
      q(0059) => q(361),
      q(0060) => q(413),
      q(0061) => q(510),
      q(0062) => q(357),
      q(0063) => q(411),
      q(0064) => q(305),
      q(0065) => q(355),
      q(0066) => q(322),
      q(0067) => q(345),
      q(0068) => q(287),
      q(0069) => q(436),
      q(0070) => q(317),
      q(0071) => q(351),
      q(0072) => q(356),
      q(0073) => q(217),
      q(0074) => q(216),
      q(0075) => q(215),
      q(0076) => q(335),
      q(0077) => q(336),
      q(0078) => q(400),
      q(0079) => q(401),
      q(0080) => q(399),
      q(0081) => q(437),
      q(0082) => q(202),
      q(0083) => q(116),
      q(0084) => q(314),
      q(0085) => q(140),
      q(0086) => q(139),
      q(0087) => q(090),
      q(0088) => q(438),
      q(0089) => q(101),
      q(0090) => q(100),
      q(0091) => q(347),
      q(0092) => q(323),
      q(0093) => q(218),
      q(0094) => q(145),
      q(0095) => q(199),
      q(0096) => q(337),
      q(0097) => q(350),
      q(0098) => q(106),
      q(0099) => q(159),
      q(0100) => q(420),
      q(0101) => q(165),
      q(0102) => q(499),
      q(0103) => q(212),
      q(0104) => q(261),
      q(0105) => q(175),
      q(0106) => q(327),
      q(0107) => q(260),
      q(0108) => q(126),
      q(0109) => q(263),
      q(0110) => q(227),
      q(0111) => q(331),
      q(0112) => q(131),
      q(0113) => q(132),
      q(0114) => q(133),
      q(0115) => q(115),
      q(0116) => q(282),
      q(0117) => q(130),
      q(0118) => q(900),
      q(0119) => q(949),
      q(0120) => q(363),
      q(0121) => q(620),
      q(0122) => q(211),
      q(0123) => q(123),
      q(0124) => q(292),
      q(0125) => q(105),
      q(0126) => q(344),
      q(0127) => q(095),
      q(0128) => q(281),
      q(0129) => q(319),
      q(0130) => q(302),
      q(0131) => q(318),
      q(0132) => q(348),
      q(0133) => q(398),
      q(0134) => q(362),
      q(0135) => q(316),
      q(0136) => q(135),
      q(0137) => q(138),
      q(0138) => q(137),
      q(0139) => q(136),
      q(0140) => q(373),
      q(0141) => q(321),
      q(0142) => q(353),
      q(0143) => q(354),
      q(0144) => q(346),
      q(0145) => q(520),
      q(0146) => q(359),
      q(0147) => q(340),
      q(0148) => q(290),
      q(0149) => q(120),
      q(0150) => q(370),
      q(0151) => q(170),
      q(0152) => q(352),
      q(0153) => q(330),
      q(0154) => q(326),
      q(0155) => q(040),
      q(0156) => q(470),
      q(0157) => q(280),
      q(0158) => q(262),
      q(0159) => q(480),
      q(0160) => q(030),
      q(0161) => q(020),
      q(0162) => q(460),
      q(0163) => q(994),
      q(0164) => q(995),
      q(0165) => q(996),
      },
};

1;
                                                                                                                  usr/share/perl/5.20.2/Locale/Codes/Script_Retired.pm                                                0100644 0000000 0000000 00000006315 12744441327 020377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Script_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Mar  4 13:19:40 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Retired{'script'}{'alpha'}{'code'} = {
};

$Locale::Codes::Retired{'script'}{'num'}{'code'} = {
};

$Locale::Codes::Retired{'script'}{'alpha'}{'name'} = {
   q( multani) => [ q(Mult), q( Multani) ],
   q((alias for hiragana + katakana)) => [ q(Hrkt), q((alias for Hiragana + Katakana)) ],
   q(ahom, tai ahom) => [ q(Ahom), q(Ahom, Tai Ahom) ],
   q(cuneiform, sumero-akkadian) => [ q(Xsux), q(Cuneiform, Sumero-Akkadian) ],
   q(deseret (mormon)) => [ q(Dsrt), q(Deseret (Mormon)) ],
   q(devanagari (nagari)) => [ q(Deva), q(Devanagari (Nagari)) ],
   q(duployan shorthand, duployan stenography) => [ q(Dupl), q(Duployan shorthand, Duployan stenography) ],
   q(ethiopic (geez)) => [ q(Ethi), q(Ethiopic (Geez)) ],
   q(han (hanzi, kanji, hanja)) => [ q(Hani), q(Han (Hanzi, Kanji, Hanja)) ],
   q(hangul (hangul, hangeul)) => [ q(Hang), q(Hangul (Hangul, Hangeul)) ],
   q(hanunoo (hanunoo)) => [ q(Hano), q(Hanunoo (Hanunoo)) ],
   q(indus (harappan)) => [ q(Inds), q(Indus (Harappan)) ],
   q(khudawadi, sindhi) => [ q(Sind), q(Khudawadi, Sindhi) ],
   q(lepcha (rong)) => [ q(Lepc), q(Lepcha (Rong)) ],
   q(lisu (fraser)) => [ q(Lisu), q(Lisu (Fraser)) ],
   q(mandaic, mandaean) => [ q(Mand), q(Mandaic, Mandaean) ],
   q(meitei mayek (meithei, meetei)) => [ q(Mtei), q(Meitei Mayek (Meithei, Meetei)) ],
   q(mende) => [ q(Mend), q(Mende) ],
   q(miao (pollard)) => [ q(Plrd), q(Miao (Pollard)) ],
   q(modi, modi) => [ q(Mult), q(Modi, Modi) ],
   q(moon (moon code, moon script, moon type)) => [ q(Moon), q(Moon (Moon code, Moon script, Moon type)) ],
   q(mro, mru) => [ q(Mroo), q(Mro, Mru) ],
   q(myanmar (burmese)) => [ q(Mymr), q(Myanmar (Burmese)) ],
   q(nakhi geba ('na-'khi ggo-baw, naxi geba)) => [ q(Nkgb), q(Nakhi Geba ('Na-'Khi Ggo-baw, Naxi Geba)) ],
   q(ol chiki (ol cemet, ol, santali)) => [ q(Olck), q(Ol Chiki (Ol Cemet, Ol, Santali)) ],
   q(old north arabian (ancient north arabian)) => [ q(Narb), q(Old North Arabian (Ancient North Arabian)) ],
   q(old turkic, orkhon runic) => [ q(Orkh), q(Old Turkic, Orkhon Runic) ],
   q(rejang (redjang, kaganga)) => [ q(Rjng), q(Rejang (Redjang, Kaganga)) ],
   q(sharada, sarada) => [ q(Shrd), q(Sharada, Sarada) ],
   q(shavian (shaw)) => [ q(Shaw), q(Shavian (Shaw)) ],
   q(siddham, siddham, siddhamatrka) => [ q(Sidd), q(Siddham, Siddham, Siddhamatrka) ],
   q(sindhi) => [ q(Sind), q(Sindhi) ],
   q(tagalog (baybayin, alibata)) => [ q(Tglg), q(Tagalog (Baybayin, Alibata)) ],
   q(tai tham (lanna)) => [ q(Lana), q(Tai Tham (Lanna)) ],
   q(takri, takri, tankri) => [ q(Takr), q(Takri, Takri, Tankri) ],
   q(tifinagh (berber)) => [ q(Tfng), q(Tifinagh (Berber)) ],
   q(tiruta) => [ q(Tirh), q(Tiruta) ],
   q(warang citi (varang kshiti)) => [ q(Wara), q(Warang Citi (Varang Kshiti)) ],
};

$Locale::Codes::Retired{'script'}{'num'}{'name'} = {
   q(mende) => [ q(438), q(Mende) ],
   q(old hungarian) => [ q(176), q(Old Hungarian) ],
   q(tiruta) => [ q(326), q(Tiruta) ],
};


1;
                                                                                                                                                                                                                                                                                                                   usr/share/perl/5.20.2/Locale/Codes.pm                                                               0100644 0000000 0000000 00000046512 12744441327 015460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

use Carp;
use Locale::Codes::Constants;

#=======================================================================
#       Public Global Variables
#=======================================================================

# This module is not called directly... %Data is filled in by the
# calling modules.

our($VERSION,%Data,%Retired);

# $Data{ TYPE }{ code2id   }{ CODESET } { CODE }  = [ ID, I ]
#              { id2code   }{ CODESET } { ID }    = CODE
#              { id2names  }{ ID }                = [ NAME, NAME, ... ]
#              { alias2id  }{ NAME }              = [ ID, I ]
#              { id        }                      = FIRST_UNUSED_ID
#              { codealias }{ CODESET } { ALIAS } = CODE
#
# $Retired{ TYPE }{ CODESET }{ code }{ CODE } = NAME
#                            { name }{ NAME } = [CODE,NAME]  (the key is lowercase)

$VERSION='3.30';

#=======================================================================
#
# _code ( TYPE,CODE,CODESET )
#
#=======================================================================

sub _code {
   return 1  if (@_ > 3);

   my($type,$code,$codeset) = @_;
   $code = ''  if (! $code);

   # Determine the codeset

   $codeset = $ALL_CODESETS{$type}{'default'}
     if (! defined($codeset)  ||  $codeset eq '');
   $codeset = lc($codeset);
   return 1  if (! exists $ALL_CODESETS{$type}{'codesets'}{$codeset});
   return (0,$code,$codeset)  if (! $code);

   # Determine the properties of the codeset

   my($op,@args) = @{ $ALL_CODESETS{$type}{'codesets'}{$codeset} };

   if      ($op eq 'lc') {
      $code = lc($code);

   } elsif ($op eq 'uc') {
      $code = uc($code);

   } elsif ($op eq 'ucfirst') {
      $code = ucfirst(lc($code));

   } elsif ($op eq 'numeric') {
      return (1)  unless ($code =~ /^\d+$/);
      my $l = $args[0];
      $code    = sprintf("%.${l}d", $code);
   }

   return (0,$code,$codeset);
}

#=======================================================================
#
# _code2name ( TYPE,CODE [,CODESET] [,'retired'] )
#
#=======================================================================

sub _code2name {
   my($type,@args)         = @_;
   my $retired             = 0;
   if (@args > 0  &&  $args[$#args]  &&  $args[$#args] eq 'retired') {
      pop(@args);
      $retired             = 1;
   }

   my($err,$code,$codeset) = _code($type,@args);
   return undef  if ($err  ||
                     ! defined $code);

   $code = $Data{$type}{'codealias'}{$codeset}{$code}
     if (exists $Data{$type}{'codealias'}{$codeset}{$code});

   if (exists $Data{$type}{'code2id'}{$codeset}  &&
       exists $Data{$type}{'code2id'}{$codeset}{$code}) {
      my ($id,$i) = @{ $Data{$type}{'code2id'}{$codeset}{$code} };
      my $name    = $Data{$type}{'id2names'}{$id}[$i];
      return $name;

   } elsif ($retired  &&  exists $Retired{$type}{$codeset}{'code'}{$code}) {
      return $Retired{$type}{$codeset}{'code'}{$code};

   } else {
      return undef;
   }
}

#=======================================================================
#
# _name2code ( TYPE,NAME [,CODESET] [,'retired'] )
#
#=======================================================================

sub _name2code {
   my($type,$name,@args)   = @_;
   return undef  if (! $name);
   $name                   = lc($name);

   my $retired             = 0;
   if (@args > 0  &&  $args[$#args]  &&  $args[$#args] eq 'retired') {
      pop(@args);
      $retired             = 1;
   }

   my($err,$tmp,$codeset) = _code($type,'',@args);
   return undef  if ($err);

   if (exists $Data{$type}{'alias2id'}{$name}) {
      my $id = $Data{$type}{'alias2id'}{$name}[0];
      if (exists $Data{$type}{'id2code'}{$codeset}{$id}) {
         return $Data{$type}{'id2code'}{$codeset}{$id};
      }

   } elsif ($retired  &&  exists $Retired{$type}{$codeset}{'name'}{$name}) {
      return $Retired{$type}{$codeset}{'name'}{$name}[0];
   }

   return undef;
}

#=======================================================================
#
# _code2code ( TYPE,CODE,CODESET )
#
#=======================================================================

sub _code2code {
   my($type,@args) = @_;
   (@args == 3) or croak "${type}_code2code() takes 3 arguments!";

   my($code,$inset,$outset) = @args;
   my($err,$tmp);
   ($err,$code,$inset) = _code($type,$code,$inset);
   return undef  if ($err);
   ($err,$tmp,$outset) = _code($type,'',$outset);
   return undef  if ($err);

   my $name    = _code2name($type,$code,$inset);
   my $outcode = _name2code($type,$name,$outset);
   return $outcode;
}

#=======================================================================
#
# _all_codes ( TYPE [,CODESET] [,'retired'] )
#
#=======================================================================

sub _all_codes {
   my($type,@args)         = @_;
   my $retired             = 0;
   if (@args > 0  &&  $args[$#args]  &&  $args[$#args] eq 'retired') {
      pop(@args);
      $retired             = 1;
   }

   my ($err,$tmp,$codeset) = _code($type,'',@args);
   return ()  if ($err);

   if (! exists $Data{$type}{'code2id'}{$codeset}) {
      return ();
   }
   my @codes = keys %{ $Data{$type}{'code2id'}{$codeset} };
   push(@codes,keys %{ $Retired{$type}{$codeset}{'code'} })  if ($retired);
   return (sort @codes);
}

#=======================================================================
#
# _all_names ( TYPE [,CODESET] [,'retired'] )
#
#=======================================================================

sub _all_names {
   my($type,@args)         = @_;
   my $retired             = 0;
   if (@args > 0  &&  $args[$#args]  &&  $args[$#args] eq 'retired') {
      pop(@args);
      $retired             = 1;
   }

   my ($err,$tmp,$codeset) = _code($type,'',@args);
   return ()  if ($err);

   my @codes = _all_codes($type,$codeset);
   my @names;

   foreach my $code (@codes) {
      my($id,$i) = @{ $Data{$type}{'code2id'}{$codeset}{$code} };
      my $name   = $Data{$type}{'id2names'}{$id}[$i];
      push(@names,$name);
   }
   if ($retired) {
      foreach my $lc (keys %{ $Retired{$type}{$codeset}{'name'} }) {
         my $name = $Retired{$type}{$codeset}{'name'}{$lc}[1];
         push @names,$name;
      }
   }
   return (sort @names);
}

#=======================================================================
#
# _rename ( TYPE,CODE,NAME,CODESET )
#
# Change the official name for a code. The original is retained
# as an alias, but the new name will be returned if you lookup the
# name from code.
#
#=======================================================================

sub _rename {
   my($type,$code,$new_name,@args) = @_;

   my $nowarn   = 0;
   $nowarn      = 1, pop(@args)  if (@args  &&  $args[$#args] eq "nowarn");

   my $codeset  = shift(@args);
   my $err;
   ($err,$code,$codeset) = _code($type,$code,$codeset);

   if (! $codeset) {
      carp "rename_$type(): unknown codeset\n"  unless ($nowarn);
      return 0;
   }

   $code = $Data{$type}{'codealias'}{$codeset}{$code}
     if (exists $Data{$type}{'codealias'}{$codeset}{$code});

   # Check that $code exists in the codeset.

   my $id;
   if (exists $Data{$type}{'code2id'}{$codeset}{$code}) {
      $id = $Data{$type}{'code2id'}{$codeset}{$code}[0];
   } else {
      carp "rename_$type(): unknown code: $code\n"  unless ($nowarn);
      return 0;
   }

   # Cases:
   #   1. Renaming to a name which exists with a different ID
   #      Error
   #
   #   2. Renaming to a name which exists with the same ID
   #      Just change code2id (I value)
   #
   #   3. Renaming to a new name
   #      Create a new alias
   #      Change code2id (I value)

   if (exists $Data{$type}{'alias2id'}{lc($new_name)}) {
      # Existing name (case 1 and 2)

      my ($new_id,$i) = @{ $Data{$type}{'alias2id'}{lc($new_name)} };
      if ($new_id != $id) {
         # Case 1
         carp "rename_$type(): rename to an existing $type not allowed\n"
           unless ($nowarn);
         return 0;
      }

      # Case 2

      $Data{$type}{'code2id'}{$codeset}{$code}[1] = $i;

   } else {

      # Case 3

      push @{ $Data{$type}{'id2names'}{$id} },$new_name;
      my $i = $#{ $Data{$type}{'id2names'}{$id} };
      $Data{$type}{'alias2id'}{lc($new_name)} = [ $id,$i ];
      $Data{$type}{'code2id'}{$codeset}{$code}[1] = $i;
   }

   return 1;
}

#=======================================================================
#
# _add_code ( TYPE,CODE,NAME,CODESET )
#
# Add a new code to the codeset. Both CODE and NAME must be
# unused in the code set.
#
#=======================================================================

sub _add_code {
   my($type,$code,$name,@args) = @_;

   my $nowarn   = 0;
   $nowarn      = 1, pop(@args)  if (@args  &&  $args[$#args] eq "nowarn");

   my $codeset  = shift(@args);
   my $err;
   ($err,$code,$codeset) = _code($type,$code,$codeset);

   if (! $codeset) {
      carp "add_$type(): unknown codeset\n"  unless ($nowarn);
      return 0;
   }

   # Check that $code is unused.

   if (exists $Data{$type}{'code2id'}{$codeset}{$code}  ||
       exists $Data{$type}{'codealias'}{$codeset}{$code}) {
      carp "add_$type(): code already in use: $code\n"  unless ($nowarn);
      return 0;
   }

   # Check to see that $name is unused in this code set.  If it is
   # used (but not in this code set), we'll use that ID.  Otherwise,
   # we'll need to get the next available ID.

   my ($id,$i);
   if (exists $Data{$type}{'alias2id'}{lc($name)}) {
      ($id,$i) = @{ $Data{$type}{'alias2id'}{lc($name)} };
      if (exists $Data{$type}{'id2code'}{$codeset}{$id}) {
         carp "add_$type(): name already in use: $name\n"  unless ($nowarn);
         return 0;
      }

   } else {
      $id = $Data{$type}{'id'}++;
      $i  = 0;
      $Data{$type}{'alias2id'}{lc($name)} = [ $id,$i ];
      $Data{$type}{'id2names'}{$id}       = [ $name ];
   }

   # Add the new code

   $Data{$type}{'code2id'}{$codeset}{$code} = [ $id,$i ];
   $Data{$type}{'id2code'}{$codeset}{$id}   = $code;

   return 1;
}

#=======================================================================
#
# _delete_code ( TYPE,CODE,CODESET )
#
# Delete a code from the codeset.
#
#=======================================================================

sub _delete_code {
   my($type,$code,@args) = @_;

   my $nowarn   = 0;
   $nowarn      = 1, pop(@args)  if (@args  &&  $args[$#args] eq "nowarn");

   my $codeset  = shift(@args);
   my $err;
   ($err,$code,$codeset) = _code($type,$code,$codeset);

   if (! $codeset) {
      carp "delete_$type(): unknown codeset\n"  unless ($nowarn);
      return 0;
   }

   $code = $Data{$type}{'codealias'}{$codeset}{$code}
     if (exists $Data{$type}{'codealias'}{$codeset}{$code});

   # Check that $code is valid.

   if (! exists $Data{$type}{'code2id'}{$codeset}{$code}) {
      carp "delete_$type(): code does not exist: $code\n"  unless ($nowarn);
      return 0;
   }

   # Delete the code

   my $id = $Data{$type}{'code2id'}{$codeset}{$code}[0];
   delete $Data{$type}{'code2id'}{$codeset}{$code};
   delete $Data{$type}{'id2code'}{$codeset}{$id};

   # Delete any aliases that are linked to this code

   foreach my $alias (keys %{ $Data{$type}{'codealias'}{$codeset} }) {
      next  if ($Data{$type}{'codealias'}{$codeset}{$alias} ne $code);
      delete $Data{$type}{'codealias'}{$codeset}{$alias};
   }

   # If this ID is not used in any other codeset, delete it completely.

   foreach my $c (keys %{ $Data{$type}{'id2code'} }) {
      return 1  if (exists $Data{$type}{'id2code'}{$c}{$id});
   }

   my @names = @{ $Data{$type}{'id2names'}{$id} };
   delete $Data{$type}{'id2names'}{$id};

   foreach my $name (@names) {
      delete $Data{$type}{'alias2id'}{lc($name)};
   }

   return 1;
}

#=======================================================================
#
# _add_alias ( TYPE,NAME,NEW_NAME )
#
# Add a new alias. NAME must exist, and NEW_NAME must be unused.
#
#=======================================================================

sub _add_alias {
   my($type,$name,$new_name,$nowarn) = @_;

   $nowarn   = (defined($nowarn)  &&  $nowarn eq "nowarn" ? 1 : 0);

   # Check that $name is used and $new_name is new.

   my($id);
   if (exists $Data{$type}{'alias2id'}{lc($name)}) {
      $id = $Data{$type}{'alias2id'}{lc($name)}[0];
   } else {
      carp "add_${type}_alias(): name does not exist: $name\n"  unless ($nowarn);
      return 0;
   }

   if (exists $Data{$type}{'alias2id'}{lc($new_name)}) {
      carp "add_${type}_alias(): alias already in use: $new_name\n"  unless ($nowarn);
      return 0;
   }

   # Add the new alias

   push @{ $Data{$type}{'id2names'}{$id} },$new_name;
   my $i = $#{ $Data{$type}{'id2names'}{$id} };
   $Data{$type}{'alias2id'}{lc($new_name)} = [ $id,$i ];

   return 1;
}

#=======================================================================
#
# _delete_alias ( TYPE,NAME )
#
# This deletes a name from the list of names used by an element.
# NAME must be used, but must NOT be the only name in the list.
#
# Any id2name that references this name will be changed to
# refer to the first name in the list.
#
#=======================================================================

sub _delete_alias {
   my($type,$name,$nowarn) = @_;

   $nowarn   = (defined($nowarn)  &&  $nowarn eq "nowarn" ? 1 : 0);

   # Check that $name is used.

   my($id,$i);
   if (exists $Data{$type}{'alias2id'}{lc($name)}) {
      ($id,$i) = @{ $Data{$type}{'alias2id'}{lc($name)} };
   } else {
      carp "delete_${type}_alias(): name does not exist: $name\n"  unless ($nowarn);
      return 0;
   }

   my $n = $#{ $Data{$type}{'id2names'}{$id} } + 1;
   if ($n == 1) {
      carp "delete_${type}_alias(): only one name defined (use _delete_${type} instead)\n"
        unless ($nowarn);
      return 0;
   }

   # Delete the alias.

   splice (@{ $Data{$type}{'id2names'}{$id} },$i,1);
   delete $Data{$type}{'alias2id'}{lc($name)};

   # Every element that refers to this ID:
   #   Ignore     if I < $i
   #   Set to 0   if I = $i
   #   Decrement  if I > $i

   foreach my $codeset (keys %{ $Data{'code2id'} }) {
      foreach my $code (keys %{ $Data{'code2id'}{$codeset} }) {
         my($jd,$j) = @{ $Data{'code2id'}{$codeset}{$code} };
         next  if ($jd ne $id  ||
                   $j < $i);
         if ($i == $j) {
            $Data{'code2id'}{$codeset}{$code}[1] = 0;
         } else {
            $Data{'code2id'}{$codeset}{$code}[1]--;
         }
      }
   }

   return 1;
}

#=======================================================================
#
# _rename_code ( TYPE,CODE,NEW_CODE,CODESET )
#
# Change the official code. The original is retained as an alias, but
# the new name will be returned if you lookup the code from name.
#
#=======================================================================

sub _rename_code {
   my($type,$code,$new_code,@args) = @_;

   my $nowarn   = 0;
   $nowarn      = 1, pop(@args)  if (@args  &&  $args[$#args] eq "nowarn");

   my $codeset  = shift(@args);
   my $err;
   ($err,$code,$codeset)     = _code($type,$code,$codeset);
   ($err,$new_code,$codeset) = _code($type,$new_code,$codeset)
     if (! $err);

   if (! $codeset) {
      carp "rename_$type(): unknown codeset\n"  unless ($nowarn);
      return 0;
   }

   $code = $Data{$type}{'codealias'}{$codeset}{$code}
     if (exists $Data{$type}{'codealias'}{$codeset}{$code});

   # Check that $code exists in the codeset.

   if (! exists $Data{$type}{'code2id'}{$codeset}{$code}) {
      carp "rename_$type(): unknown code: $code\n"  unless ($nowarn);
      return 0;
   }

   # Cases:
   #   1. Renaming code to an existing alias of this code:
   #      Make the alias real and the code an alias
   #
   #   2. Renaming code to some other existing alias:
   #      Error
   #
   #   3. Renaming code to some other code:
   #      Error (
   #
   #   4. Renaming code to a new code:
   #      Make code into an alias
   #      Replace code with new_code.

   if (exists $Data{$type}{'codealias'}{$codeset}{$new_code}) {
      # Cases 1 and 2
      if ($Data{$type}{'codealias'}{$codeset}{$new_code} eq $code) {
         # Case 1

         delete $Data{$type}{'codealias'}{$codeset}{$new_code};

      } else {
         # Case 2
         carp "rename_$type(): new code already in use: $new_code\n"  unless ($nowarn);
         return 0;
      }

   } elsif (exists $Data{$type}{'code2id'}{$codeset}{$new_code}) {
      # Case 3
      carp "rename_$type(): new code already in use: $new_code\n"  unless ($nowarn);
      return 0;
   }

   # Cases 1 and 4

   $Data{$type}{'codealias'}{$codeset}{$code} = $new_code;

   my $id = $Data{$type}{'code2id'}{$codeset}{$code}[0];
   $Data{$type}{'code2id'}{$codeset}{$new_code} = $Data{$type}{'code2id'}{$codeset}{$code};
   delete $Data{$type}{'code2id'}{$codeset}{$code};

   $Data{$type}{'id2code'}{$codeset}{$id} = $new_code;

   return 1;
}

#=======================================================================
#
# _add_code_alias ( TYPE,CODE,NEW_CODE,CODESET )
#
# Adds an alias for the code.
#
#=======================================================================

sub _add_code_alias {
   my($type,$code,$new_code,@args) = @_;

   my $nowarn   = 0;
   $nowarn      = 1, pop(@args)  if (@args  &&  $args[$#args] eq "nowarn");

   my $codeset  = shift(@args);
   my $err;
   ($err,$code,$codeset)     = _code($type,$code,$codeset);
   ($err,$new_code,$codeset) = _code($type,$new_code,$codeset)
     if (! $err);

   if (! $codeset) {
      carp "add_${type}_code_alias(): unknown codeset\n"  unless ($nowarn);
      return 0;
   }

   $code = $Data{$type}{'codealias'}{$codeset}{$code}
     if (exists $Data{$type}{'codealias'}{$codeset}{$code});

   # Check that $code exists in the codeset and that $new_code
   # does not exist.

   if (! exists $Data{$type}{'code2id'}{$codeset}{$code}) {
      carp "add_${type}_code_alias(): unknown code: $code\n"  unless ($nowarn);
      return 0;
   }

   if (exists $Data{$type}{'code2id'}{$codeset}{$new_code}  ||
       exists $Data{$type}{'codealias'}{$codeset}{$new_code}) {
      carp "add_${type}_code_alias(): code already in use: $new_code\n"  unless ($nowarn);
      return 0;
   }

   # Add the alias

   $Data{$type}{'codealias'}{$codeset}{$new_code} = $code;

   return 1;
}

#=======================================================================
#
# _delete_code_alias ( TYPE,CODE,CODESET )
#
# Deletes an alias for the code.
#
#=======================================================================

sub _delete_code_alias {
   my($type,$code,@args) = @_;

   my $nowarn   = 0;
   $nowarn      = 1, pop(@args)  if (@args  &&  $args[$#args] eq "nowarn");

   my $codeset  = shift(@args);
   my $err;
   ($err,$code,$codeset)     = Locale::Codes::_code($type,$code,$codeset);

   if (! $codeset) {
      carp "delete_${type}_code_alias(): unknown codeset\n"  unless ($nowarn);
      return 0;
   }

   # Check that $code exists in the codeset as an alias.

   if (! exists $Data{$type}{'codealias'}{$codeset}{$code}) {
      carp "delete_${type}_code_alias(): no alias defined: $code\n"  unless ($nowarn);
      return 0;
   }

   # Delete the alias

   delete $Data{$type}{'codealias'}{$codeset}{$code};

   return 1;
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                      usr/share/perl/5.20.2/Locale/Codes.pod                                                              0100644 0000000 0000000 00000022714 12744441327 015624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes - a distribution of modules to handle locale codes

=head1 DESCRIPTION

B<Locale-Codes> is a distribution containing a set of modules.  The
modules each deal with different types of codes which identify parts
of the locale including languages, countries, currency, etc.

Currently, the following modules are included:

=over 4

=item B<Locale::Codes::Country, Locale::Country>

This includes support for country codes (such as those listed in ISO-3166)
to specify the country.

Because this module was originally distributed as Locale::Country, it is
also available under that name.

=item B<Locale::Codes::Language, Locale::Language>

This includes support for language codes (such as those listed in ISO-639)
to specify the language.

Because this module was originally distributed as Locale::Language, it is
also available under that name.

=item B<Locale::Codes::Currency, Locale::Currency>

This includes support for currency codes (such as those listed in ISO-4217)
to specify the currency.

Because this module was originally distributed as Locale::Currency, it is
also available under that name.

=item B<Locale::Codes::Script, Locale::Script>

This includes support for script codes (such as those listed in ISO-15924)
to specify the script.

Because this module was originally distributed as Locale::Script, it is
also available under that name.

=item B<Locale::Codes::LangExt>

This includes support for language extension codes (such as those listed
in the IANA language registry) to specify the language extension.

=item B<Locale::Codes::LangVar>

This includes support for language variation codes (such as those listed
in the IANA language registry) to specify the language variation.

=item B<Locale::Codes::LangFam>

This includes support for language family codes (such as those listed
in ISO 639-5) to specify families of languages.

=back

Each module can support an arbitrary number of code sets, and it is
not required that the relationship between these code sets be
one-to-one.  For example, the Locale::Codes::Country module supports
code sets from ISO-3166 and the IANA standard, and they do not
break the world down into exactly the same sets of countries. This
does not cause any problem (though converting codes from ISO-3166 to
IANA or back will not work except for countries that are one-to-one).

All data in all of these modules comes directly from the original
standards (or as close to direct as possible), so it should be
up-to-date at the time of release.

I plan on releasing a new version several times a year to incorporate
any changes made in the standards. However, I don't always know about
changes that occur, so if any of the standards change, and you want a
new release sooner, just email me and I'll get one out.

In addition to the modules above, there are a number of support modules included
in the distribution including:

=over 4

=item B<Locale::Codes>

=item B<Locale::Codes::Constants>

=item B<Locale::Codes::Country_codes>

=item B<Locale::Codes::Language_codes>

=item B<Locale::Codes::Currency_codes>

=item B<Locale::Codes::Script_codes>

=item B<Locale::Codes::LangExt_codes>

=item B<Locale::Codes::LangVar_codes>

=item B<Locale::Codes::LangFam_codes>

=back

These modules are not intended to be used by programmers. They contain functions
or data that are used by the modules listed above.

=head1 NEW CODE SETS

I'm always open to suggestions for new code sets.

In order for me to add a code set, I want the following criteria
to be met:

=over 4

=item B<General-use code set>

If a code set is not general use, I'm not likely to spend the time
to add and support it.

=item B<An official source of data>

I require an official (or at least, a NEARLY official) source where I
can get the data on a regular basis.

Ideally, I'd only get data from an official source, but sometimes that
is not possible. For example the ISO standards are not typically
available for free, so I may have to get some of that data from
alternate sources that I'm confident are getting their data from the
official source.  However, I will always be hesitant to accept a
non-official source.

As an example, I used to get some country data from the CIA World
Factbook. Given the nature of the source, I'm sure they're updating
data from the official sources and I consider it "nearly" official.
However, even in this case, I found that they were adding codes that
were not part of the standard, so I have stopped using them as a
source.

There are many 3rd party sites which maintain lists (many of which are
actually in a more convenient form than the official sites).
Unfortunately, I will reject most of them since I have no feel for how
"official" they are.

=item B<A free source of the data>

Obviously, the data must be free-of-charge. I'm not interested in
paying for the data (and I'm not interested in the overhead of having
someone else pay for the data for me).

=item B<A reliable source of data>

The source of data must come from a source that I can reasonably expect
to exist for the foreseeable future since I will be extremely reluctant
to drop support for a data set once it's included.

I am also reluctant to accept data sent to me by an individual.
Although I appreciate the offer, it is simply not practical to consider
an individual contribution as a reliable source of data. The source
should be an official agency of some sort.

=back

These requirements are open to discussion. If you have a code set
you'd like to see added, but which may not meet all of the above
requirements, feel free to email me and we'll discuss it.  Depending
on circumstances, I may be willing to waive some of these criteria.

=head1 COMMON ALIASES

As of version 2.00, the modules supported common variants of names.

For example, Locale::Country supports variant names for countries, and
a few of the most common ones are included in the data. The country
code for "United States" is "us", so:

   country2code('United States');
      => "us"

Now the following will also return 'us':

   country2code('United States of America');
   country2code('USA');

Any number of common aliases may be included in the data, in addition
to the names that come directly from the standards.  If you have a
common alias for a country, language, or any other of the types of
codes, let me know and I'll add it, with some restrictions.

For example, the country name "North Korea" never appeared in any of
the official sources (instead, it was "Korea, North" or "Korea,
Democratic People's Republic of". I would honor a request to add an
alias "North Korea" since that's a very common way to specify the
country (please don't request this... I've already added it).

On the other hand, a request to add Zaire as an alias for "Congo, The
Democratic Republic of" will not be honored. The country's official
name is no longer Zaire, so adding it as an alias violates the standard.
Zaire was kept as an alias in versions prior to 3.00, but it has been
removed. Other aliases (if any) which no longer appear in any standard
(and which are not common variations of the name in the standards)
have also been removed.

=head1 DEPRECATED CODES

Occasionally, a code is deprecated, but it may still be desirable to
have access to it.

Although there is no way to see every code that has ever existed and
been deprecated (since most codesets do not have that information
available), as of version 3.20, every code which has ever been included
in these modules can be referenced.

For more information, refer to the documentation on the code2XXX, XXX2code,
all_XXX_codes, and all_XXX_names function in the B<Locale::Codes::API>
documentation.

=head1 SEE ALSO

=over 4

=item B<Locale::Codes::API>

The list of functions available in each of the modules listed below.
The APIs for each module are exactly identical.

=item B<Locale::Codes::Country>

Codes for identification of countries.

=item B<Locale::Codes::Language>

Codes for identification of languages.

=item B<Locale::Codes::Script>

Codes for identification of scripts.

=item B<Locale::Codes::Currency>

Codes for identification of currencies and funds.

=item B<Locale::Codes::LangExt>

Codes for identification of language extensions.

=item B<Locale::Codes::LangVar>

Codes for identification of language variations.

=item B<Locale::Codes::LangFam>

Codes for identification of language families.

=item B<Locale::Codes::Changes>

A history of changes made to this distribution.

=back

=head1 AUTHOR

Locale::Country and Locale::Language were originally written by Neil
Bowers at the Canon Research Centre Europe (CRE). They maintained the
distribution from 1997 to 2001.

Locale::Currency was originally written by Michael Hennecke and was
modified by Neil Bowers for inclusion in the distribution.

From 2001 to 2004, maintenance was continued by Neil Bowers.  He
modified Locale::Currency for inclusion in the distribution. He also
added Locale::Constants and Locale::Script.

From 2004-2009, the module was unmaintained.

In 2010, maintenance was taken over by Sullivan Beck (sbeck@cpan.org)
with Neil Bower's permission.  All problems or comments should be
sent there.  Alternately, problems can be reported using the
perl problem tracker at:

   https://rt.cpan.org/Dist/Display.html?Queue=Locale-Codes

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001      Michael Hennecke (Locale::Currency)
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                    usr/share/perl/5.20.2/Locale/Country.pm                                                             0100644 0000000 0000000 00000003040 12744441327 016053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Country;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;
use Exporter;

our $VERSION;
$VERSION='3.30';

our (@ISA,@EXPORT);

my $backend     = 'Locale::Codes::Country';
my $backend_exp = $backend . "::EXPORT";

eval "require $backend; $backend->import(); return 1;";

{
   no strict 'refs';
   @EXPORT = @{ $backend_exp };
}

unshift (@ISA, $backend);

sub alias_code                { Locale::Codes::Country::alias_code(@_) }

sub rename_country            { Locale::Codes::Country::rename_country(@_) }
sub add_country               { Locale::Codes::Country::add_country(@_) }
sub delete_country            { Locale::Codes::Country::delete_country(@_) }
sub add_country_alias         { Locale::Codes::Country::add_country_alias(@_) }
sub delete_country_alias      { Locale::Codes::Country::delete_country_alias(@_) }
sub rename_country_code       { Locale::Codes::Country::rename_country_code(@_) }
sub add_country_code_alias    { Locale::Codes::Country::add_country_code_alias(@_) }
sub delete_country_code_alias { Locale::Codes::Country::delete_country_code_alias(@_) }

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Locale/Country.pod                                                            0100644 0000000 0000000 00000013454 12744441327 016233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Country - standard codes for country identification

=head1 SYNOPSIS

   use Locale::Country;

   $country = code2country('jp' [,CODESET]);        # $country gets 'Japan'
   $code    = country2code('Norway' [,CODESET]);    # $code gets 'no'

   @codes   = all_country_codes( [CODESET]);
   @names   = all_country_names();

   # semi-private routines
   Locale::Country::alias_code('uk' => 'gb');
   Locale::Country::rename_country('gb' => 'Great Britain');

=head1 DESCRIPTION

The C<Locale::Country> module provides access to several code sets
that can be used for identifying countries, such as those defined in
ISO 3166-1.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
3166-1 two-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $country = code2country('jp','alpha-2');
   $country = code2country('jp',LOCALE_CODE_ALPHA_2);

The codesets currently supported are:

=over 4

=item B<alpha-2, LOCALE_CODE_ALPHA_2>

This is the set of two-letter (lowercase) codes from ISO 3166-1, such
as 'tv' for Tuvalu.

This is the default code set.

=item B<alpha-3, LOCALE_CODE_ALPHA_3>

This is the set of three-letter (lowercase) codes from ISO 3166-1,
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.

=item B<numeric, LOCALE_CODE_NUMERIC>

This is the set of three-digit numeric codes from ISO 3166-1, such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.

If a 2-digit code is entered, it is converted to 3 digits by prepending
a 0.

=item B<dom, LOCALE_CODE_DOM>

The IANA is responsible for delegating management of the top level country
domains.  The country domains are the two-letter (lowercase) codes from ISO 3166
with a few other additions.

=back

NOTE: As of version 3.27, the FIPS code set is no longer supported.  See the
Locale::Codes::Changes document for details.

=head1 ROUTINES

=over 4

=item B<code2country ( CODE [,CODESET] )>

=item B<country2code ( NAME [,CODESET] )>

=item B<country_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_country_codes ( [CODESET] )>

=item B<all_country_names ( [CODESET] )>

=item B<Locale::Country::rename_country  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Country::add_country  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Country::delete_country  ( CODE [,CODESET] )>

=item B<Locale::Country::add_country_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Country::delete_country_alias  ( NAME )>

=item B<Locale::Country::rename_country_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Country::add_country_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Country::delete_country_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=item B<alias_code ( ALIAS, CODE [,CODESET] )>

Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.

As of 3.10, the internal data for all types of codes can be modified.

The alias_code function is preserved for backwards compatibility, but
the following two are identical:

   alias_code(ALIAS,CODE [,CODESET]);
   rename_country_code(CODE,ALIAS [,CODESET]);

and the latter should be used for consistency.

The alias_code function is deprecated and will be removed in the December
2014 release.

B<Note:> this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<Locale::SubCountry>

ISO codes for country sub-divisions (states, counties, provinces,
etc), as defined in ISO 3166-2.  This module is not part of the
Locale-Codes distribution, but is available from CPAN in
CPAN/modules/by-module/Locale/

=item B<http://www.iso.org/iso/home/standards/country_codes.htm>

Official home page for the ISO 3166 maintenance agency.

=item B<http://www.iso.org/iso/home/standards/country_codes/iso-3166-1_decoding_table.htm>

The source of ISO 3166-1 two-letter codes used by this
module.

=item B<http://www.iana.org/domains/root/db/>

Official source of the top-level domain names.

=item B<http://unstats.un.org/unsd/methods/m49/m49alpha.htm>

The source of the official ISO 3166-1 three-letter codes and
three-digit codes.

For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the UN site.  I
no longer use this as a source of data.

=item B<https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html>

The World Factbook maintained by the CIA is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.

=item B<http://www.statoids.com/wab.html>

Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                    usr/share/perl/5.20.2/Locale/Currency.pm                                                            0100644 0000000 0000000 00000002760 12744441327 016212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Currency;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;
use Exporter;

our $VERSION;
$VERSION='3.30';

our (@ISA,@EXPORT);

my $backend     = 'Locale::Codes::Currency';
my $backend_exp = $backend . "::EXPORT";

eval "require $backend; $backend->import(); return 1;";

{
   no strict 'refs';
   @EXPORT = @{ $backend_exp };
}

unshift (@ISA, $backend);

sub rename_currency            { Locale::Codes::Currency::rename_currency(@_) }
sub add_currency               { Locale::Codes::Currency::add_currency(@_) }
sub delete_currency            { Locale::Codes::Currency::delete_currency(@_) }
sub add_currency_alias         { Locale::Codes::Currency::add_currency_alias(@_) }
sub delete_currency_alias      { Locale::Codes::Currency::delete_currency_alias(@_) }
sub rename_currency_code       { Locale::Codes::Currency::rename_currency_code(@_) }
sub add_currency_code_alias    { Locale::Codes::Currency::add_currency_code_alias(@_) }
sub delete_currency_code_alias { Locale::Codes::Currency::delete_currency_code_alias(@_) }

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                usr/share/perl/5.20.2/Locale/Currency.pod                                                           0100644 0000000 0000000 00000005776 12744441327 016372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Currency - standard codes for currency identification

=head1 SYNOPSIS

    use Locale::Currency;

    $curr = code2currency('usd');     # $curr gets 'US Dollar'
    $code = currency2code('Euro');    # $code gets 'eur'

    @codes   = all_currency_codes();
    @names   = all_currency_names();


=head1 DESCRIPTION

The C<Locale::Currency> module provides access to standard codes used
for identifying currencies and funds, such as those defined in ISO 4217.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
4217 three-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $curr = code2currency('usd','alpha');
   $curr = code2currency('usd',LOCALE_CURR_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha, LOCALE_CURR_ALPHA>

This is a set of three-letter (uppercase) codes from ISO 4217 such
as EUR for Euro.

Two of the codes specified by the standard (XTS which is reserved
for testing purposes and XXX which is for transactions where no
currency is involved) are omitted.

This is the default code set.

=item B<num, LOCALE_CURR_NUMERIC>

This is the set of three-digit numeric codes from ISO 4217.

=back

=head1 ROUTINES

=over 4

=item B<code2currency ( CODE [,CODESET] )>

=item B<currency2code ( NAME [,CODESET] )>

=item B<currency_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_currency_codes ( [CODESET] )>

=item B<all_currency_names ( [CODESET] )>

=item B<Locale::Currency::rename_currency  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Currency::add_currency  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Currency::delete_currency  ( CODE [,CODESET] )>

=item B<Locale::Currency::add_currency_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Currency::delete_currency_alias  ( NAME )>

=item B<Locale::Currency::rename_currency_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Currency::add_currency_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Currency::delete_currency_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.iso.org/iso/support/currency_codes_list-1.htm>

The ISO 4217 data.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001      Michael Hennecke
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
  usr/share/perl/5.20.2/Locale/Language.pm                                                            0100644 0000000 0000000 00000002760 12744441327 016143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Language;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;
use Exporter;

our $VERSION;
$VERSION='3.30';

our (@ISA,@EXPORT);

my $backend     = 'Locale::Codes::Language';
my $backend_exp = $backend . "::EXPORT";

eval "require $backend; $backend->import(); return 1;";

{
   no strict 'refs';
   @EXPORT = @{ $backend_exp };
}

unshift (@ISA, $backend);

sub rename_language            { Locale::Codes::Language::rename_language(@_) }
sub add_language               { Locale::Codes::Language::add_language(@_) }
sub delete_language            { Locale::Codes::Language::delete_language(@_) }
sub add_language_alias         { Locale::Codes::Language::add_language_alias(@_) }
sub delete_language_alias      { Locale::Codes::Language::delete_language_alias(@_) }
sub rename_language_code       { Locale::Codes::Language::rename_language_code(@_) }
sub add_language_code_alias    { Locale::Codes::Language::add_language_code_alias(@_) }
sub delete_language_code_alias { Locale::Codes::Language::delete_language_code_alias(@_) }

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                usr/share/perl/5.20.2/Locale/Language.pod                                                           0100644 0000000 0000000 00000006442 12744441327 016312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Language - standard codes for language identification

=head1 SYNOPSIS

   use Locale::Language;

   $lang = code2language('en');        # $lang gets 'English'
   $code = language2code('French');    # $code gets 'fr'

   @codes   = all_language_codes();
   @names   = all_language_names();

=head1 DESCRIPTION

The C<Locale::Language> module provides access to standard codes used
for identifying languages, such as those as defined in ISO 639.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
639 two-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
languages. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $lang = code2language('en','alpha-2');
   $lang = code2language('en',LOCALE_LANG_ALPHA_2);

The codesets currently supported are:

=over 4

=item B<alpha-2, LOCALE_LANG_ALPHA_2>

This is the set of two-letter (lowercase) codes from ISO 639-1, such
as 'he' for Hebrew.  It also includes additions to this set included
in the IANA language registry.

This is the default code set.

=item B<alpha-3, LOCALE_LANG_ALPHA_3>

This is the set of three-letter (lowercase) bibliographic codes from
ISO 639-2 and 639-5, such as 'heb' for Hebrew.  It also includes
additions to this set included in the IANA language registry.

=item B<term, LOCALE_LANG_TERM>

This is the set of three-letter (lowercase) terminologic codes from
ISO 639.

=back

=head1 ROUTINES

=over 4

=item B<code2language ( CODE [,CODESET] )>

=item B<language2code ( NAME [,CODESET] )>

=item B<language_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_language_codes ( [CODESET] )>

=item B<all_language_names ( [CODESET] )>

=item B<Locale::Language::rename_language  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Language::add_language  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Language::delete_language  ( CODE [,CODESET] )>

=item B<Locale::Language::add_language_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Language::delete_language_alias  ( NAME )>

=item B<Locale::Language::rename_language_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Language::add_language_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Language::delete_language_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.loc.gov/standards/iso639-2/>

Source of the ISO 639-2 codes.

=item B<http://www.loc.gov/standards/iso639-5/>

Source of the ISO 639-5 codes.

=item B<http://www.iana.org/assignments/language-subtag-registry>

The IANA language subtag registry.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                              usr/share/perl/5.20.2/Locale/Maketext/                                                              0040755 0000000 0000000 00000000000 13077704254 015643  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Locale/Maketext/Cookbook.pod                                                  0100644 0000000 0000000 00000007536 12744441327 020124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # This document contains text in Perl "POD" format.
# Use a POD viewer like perldoc or perlman to render it.

=encoding utf-8

=head1 NAME

Locale::Maketext::Cookbook - recipes for using Locale::Maketext

=head1 INTRODUCTION

This is a work in progress. Not much progress by now :-)

=head1 ONESIDED LEXICONS

I<Adapted from a suggestion by Dan Muey>

It may be common (for example at your main lexicon) that
the hash keys and values coincide. Like that

    q{Hello, tell me your name} 
      => q{Hello, tell me your name}

It would be nice to just write:

    q{Hello, tell me your name} => ''

and have this magically inflated to the first form.
Among the advantages of such representation, that would
lead to  
smaller files, less prone to mistyping or mispasting, 
and handy to someone translating it which can simply 
copy the main lexicon and enter the translation 
instead of having to remove the value first.

That can be achieved by overriding C<init>
in your class and working on the main lexicon
with code like that:

    package My::I18N;
    ...

    sub init {
        my $lh = shift; # a newborn handle
        $lh->SUPER::init();
        inflate_lexicon(\%My::I18N::en::Lexicon);
        return;
    }

    sub inflate_lexicon {
        my $lex = shift;
        while (my ($k, $v) = each %$lex) {
            $v = $k if !defined $v || $v eq '';
        }
    }

Here we are assuming C<My::I18N::en> to own the
main lexicon.

There are some downsides here: the size economy
will not stand at runtime after this C<init()>
runs. But it should not be that critical, since
if you don't have space for that, you won't have
space for any other language besides the main one
as well. You could do that too with ties,
expanding the value at lookup time which
should be more time expensive as an option.

=head1 DECIMAL PLACES IN NUMBER FORMATTING

I<After CPAN RT #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)>

The documentation of L<Locale::Maketext> advises that 
the standard bracket method C<numf> is limited and that
you must override that for better results. It even
suggests the use of L<Number::Format>.

One such defect of standard C<numf> is to not be
able to use a certain decimal precision.
For example, 

    $lh->maketext('pi is [numf,_1]', 355/113);

outputs

    pi is 3.14159292035398 

Since pi  355/116 is only accurate 
to 6 decimal places, you would want to say:

    $lh->maketext('pi is [numf,_1,6]', 355/113); 

and get "pi is 3.141592".

One solution for that could use C<Number::Format>
like that:

    package Wuu;

    use base qw(Locale::Maketext);

    use Number::Format;

    # can be overridden according to language conventions
    sub _numf_params {
        return (
            -thousands_sep  => '.',
            -decimal_point  => ',',
            -decimal_digits => 2,
        );
    }

    # builds a Number::Format
    sub _numf_formatter {
        my ($lh, $scale) = @_;
        my @params = $lh->_numf_params;
        if ($scale) { # use explicit scale rather than default
            push @params, (-decimal_digits => $scale);
        }
        return Number::Format->new(@params);
    }

    sub numf {
        my ($lh, $n, $scale) = @_;
        # get the (cached) formatter
        my $nf = $lh->{__nf}{$scale} ||= $lh->_numf_formatter($scale);
        # format the number itself
        return $nf->format_number($n);
    }

    package Wuu::pt;

    use base qw(Wuu);

and then 

    my $lh = Wuu->get_handle('pt');
    $lh->maketext('A [numf,_1,3] km de distncia', 1550.2222);

would return "A 1.550,222 km de distncia".

Notice that the standard utility methods of 
C<Locale::Maketext> are irremediably limited
because they could not aim to do everything
that could be expected from them in different languages,
cultures and applications. So extending C<numf>,
C<quant>, and C<sprintf> is natural as soon
as your needs exceed what the standard ones do.


                                                                                                                                                                  usr/share/perl/5.20.2/Locale/Maketext/Guts.pm                                                       0100644 0000000 0000000 00000000703 12744441327 017117  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Maketext::Guts;

use Locale::Maketext;

our $VERSION = '1.20';

=head1 NAME

Locale::Maketext::Guts - Deprecated module to load Locale::Maketext utf8 code

=head1 SYNOPSIS

  # Do this instead please
  use Locale::Maketext

=head1 DESCRIPTION

Previously Local::Maketext::GutsLoader performed some magic to load
Locale::Maketext when utf8 was unavailable. The subs this module provided
were merged back into Locale::Maketext

=cut

1;
                                                             usr/share/perl/5.20.2/Locale/Maketext/GutsLoader.pm                                                 0100644 0000000 0000000 00000000752 12744441327 020252  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Maketext::GutsLoader;

use Locale::Maketext;

our $VERSION = '1.20';

sub zorp { return scalar @_ }

=head1 NAME

Locale::Maketext::GutsLoader - Deprecated module to load Locale::Maketext utf8 code

=head1 SYNOPSIS

  # Do this instead please
  use Locale::Maketext

=head1 DESCRIPTION

Previously Locale::Maketext::Guts performed some magic to load
Locale::Maketext when utf8 was unavailable. The subs this module provided
were merged back into Locale::Maketext.

=cut

1;
                      usr/share/perl/5.20.2/Locale/Maketext/Simple.pm                                                     0100644 0000000 0000000 00000023075 12744441327 017435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Maketext::Simple;
$Locale::Maketext::Simple::VERSION = '0.21';

use strict;
use 5.005;

=head1 NAME

Locale::Maketext::Simple - Simple interface to Locale::Maketext::Lexicon

=head1 VERSION

This document describes version 0.18 of Locale::Maketext::Simple,
released Septermber 8, 2006.

=head1 SYNOPSIS

Minimal setup (looks for F<auto/Foo/*.po> and F<auto/Foo/*.mo>):

    package Foo;
    use Locale::Maketext::Simple;	# exports 'loc'
    loc_lang('fr');			# set language to French
    sub hello {
	print loc("Hello, [_1]!", "World");
    }

More sophisticated example:

    package Foo::Bar;
    use Locale::Maketext::Simple (
	Class	    => 'Foo',	    # search in auto/Foo/
	Style	    => 'gettext',   # %1 instead of [_1]
	Export	    => 'maketext',  # maketext() instead of loc()
	Subclass    => 'L10N',	    # Foo::L10N instead of Foo::I18N
	Decode	    => 1,	    # decode entries to unicode-strings
	Encoding    => 'locale',    # but encode lexicons in current locale
				    # (needs Locale::Maketext::Lexicon 0.36)
    );
    sub japh {
	print maketext("Just another %1 hacker", "Perl");
    }

=head1 DESCRIPTION

This module is a simple wrapper around B<Locale::Maketext::Lexicon>,
designed to alleviate the need of creating I<Language Classes> for
module authors.

The language used is chosen from the loc_lang call. If a lookup is not
possible, the i-default language will be used. If the lookup is not in the
i-default language, then the key will be returned.

If B<Locale::Maketext::Lexicon> is not present, it implements a
minimal localization function by simply interpolating C<[_1]> with
the first argument, C<[_2]> with the second, etc.  Interpolated
function like C<[quant,_1]> are treated as C<[_1]>, with the sole
exception of C<[tense,_1,X]>, which will append C<ing> to C<_1> when
X is C<present>, or appending C<ed> to <_1> otherwise.

=head1 OPTIONS

All options are passed either via the C<use> statement, or via an
explicit C<import>.

=head2 Class

By default, B<Locale::Maketext::Simple> draws its source from the
calling package's F<auto/> directory; you can override this behaviour
by explicitly specifying another package as C<Class>.

=head2 Path

If your PO and MO files are under a path elsewhere than C<auto/>,
you may specify it using the C<Path> option.

=head2 Style

By default, this module uses the C<maketext> style of C<[_1]> and
C<[quant,_1]> for interpolation.  Alternatively, you can specify the
C<gettext> style, which uses C<%1> and C<%quant(%1)> for interpolation.

This option is case-insensitive.

=head2 Export

By default, this module exports a single function, C<loc>, into its
caller's namespace.  You can set it to another name, or set it to
an empty string to disable exporting.

=head2 Subclass

By default, this module creates an C<::I18N> subclass under the
caller's package (or the package specified by C<Class>), and stores
lexicon data in its subclasses.  You can assign a name other than
C<I18N> via this option.

=head2 Decode

If set to a true value, source entries will be converted into
utf8-strings (available in Perl 5.6.1 or later).  This feature
needs the B<Encode> or B<Encode::compat> module.

=head2 Encoding

Specifies an encoding to store lexicon entries, instead of
utf8-strings.  If set to C<locale>, the encoding from the current
locale setting is used.  Implies a true value for C<Decode>.

=cut

sub import {
    my ($class, %args) = @_;

    $args{Class}    ||= caller;
    $args{Style}    ||= 'maketext';
    $args{Export}   ||= 'loc';
    $args{Subclass} ||= 'I18N';

    my ($loc, $loc_lang) = $class->load_loc(%args);
    $loc ||= $class->default_loc(%args);

    no strict 'refs';
    *{caller(0) . "::$args{Export}"} = $loc if $args{Export};
    *{caller(0) . "::$args{Export}_lang"} = $loc_lang || sub { 1 };
}

my %Loc;

sub reload_loc { %Loc = () }

sub load_loc {
    my ($class, %args) = @_;

    my $pkg = join('::', grep { defined and length } $args{Class}, $args{Subclass});
    return $Loc{$pkg} if exists $Loc{$pkg};

    eval {
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Locale::Maketext::Lexicon;
        1
    } or return;
    $Locale::Maketext::Lexicon::VERSION > 0.20	    or return;
    eval { require File::Spec; 1 }		    or return;

    my $path = $args{Path} || $class->auto_path($args{Class}) or return;
    my $pattern = File::Spec->catfile($path, '*.[pm]o');
    my $decode = $args{Decode} || 0;
    my $encoding = $args{Encoding} || undef;

    $decode = 1 if $encoding;

    $pattern =~ s{\\}{/}g; # to counter win32 paths

    eval "
	package $pkg;
	use base 'Locale::Maketext';
	Locale::Maketext::Lexicon->import({
	    'i-default' => [ 'Auto' ],
	    '*'	=> [ Gettext => \$pattern ],
	    _decode => \$decode,
	    _encoding => \$encoding,
	});
	*${pkg}::Lexicon = \\%${pkg}::i_default::Lexicon;
	*tense = sub { \$_[1] . ((\$_[2] eq 'present') ? 'ing' : 'ed') }
	    unless defined &tense;

	1;
    " or die $@;

    my $lh = eval { $pkg->get_handle } or return;
    my $style = lc($args{Style});
    if ($style eq 'maketext') {
	$Loc{$pkg} = sub {
	    $lh->maketext(@_)
	};
    }
    elsif ($style eq 'gettext') {
	$Loc{$pkg} = sub {
	    my $str = shift;
            $str =~ s{([\~\[\]])}{~$1}g;
            $str =~ s{
                ([%\\]%)                        # 1 - escaped sequence
            |
                %   (?:
                        ([A-Za-z#*]\w*)         # 2 - function call
                            \(([^\)]*)\)        # 3 - arguments
                    |
                        ([1-9]\d*|\*)           # 4 - variable
                    )
            }{
                $1 ? $1
                   : $2 ? "\[$2,"._unescape($3)."]"
                        : "[_$4]"
            }egx;
	    return $lh->maketext($str, @_);
	};
    }
    else {
	die "Unknown Style: $style";
    }

    return $Loc{$pkg}, sub {
	$lh = $pkg->get_handle(@_);
    };
}

sub default_loc {
    my ($self, %args) = @_;
    my $style = lc($args{Style});
    if ($style eq 'maketext') {
	return sub {
	    my $str = shift;
            $str =~ s{((?<!~)(?:~~)*)\[_([1-9]\d*|\*)\]}
                     {$1%$2}g;
            $str =~ s{((?<!~)(?:~~)*)\[([A-Za-z#*]\w*),([^\]]+)\]}
                     {"$1%$2(" . _escape($3) . ')'}eg;
	    _default_gettext($str, @_);
	};
    }
    elsif ($style eq 'gettext') {
	return \&_default_gettext;
    }
    else {
	die "Unknown Style: $style";
    }
}

sub _default_gettext {
    my $str = shift;
    $str =~ s{
	%			# leading symbol
	(?:			# either one of
	    \d+			#   a digit, like %1
	    |			#     or
	    (\w+)\(		#   a function call -- 1
		(?:		#     either
		    %\d+	#	an interpolation
		    |		#     or
		    ([^,]*)	#	some string -- 2
		)		#     end either
		(?:		#     maybe followed
		    ,		#       by a comma
		    ([^),]*)	#       and a param -- 3
		)?		#     end maybe
		(?:		#     maybe followed
		    ,		#       by another comma
		    ([^),]*)	#       and a param -- 4
		)?		#     end maybe
		[^)]*		#     and other ignorable params
	    \)			#   closing function call
	)			# closing either one of
    }{
	my $digit = $2 || shift;
	$digit . (
	    $1 ? (
		($1 eq 'tense') ? (($3 eq 'present') ? 'ing' : 'ed') :
		($1 eq 'quant') ? ' ' . (($digit > 1) ? ($4 || "$3s") : $3) :
		''
	    ) : ''
	);
    }egx;
    return $str;
};

sub _escape {
    my $text = shift;
    $text =~ s/\b_([1-9]\d*)/%$1/g;
    return $text;
}

sub _unescape {
    join(',', map {
        /\A(\s*)%([1-9]\d*|\*)(\s*)\z/ ? "$1_$2$3" : $_
    } split(/,/, $_[0]));
}

sub auto_path {
    my ($self, $calldir) = @_;
    $calldir =~ s#::#/#g;
    my $path = $INC{$calldir . '.pm'} or return;

    # Try absolute path name.
    if ($^O eq 'MacOS') {
	(my $malldir = $calldir) =~ tr#/#:#;
	$path =~ s#^(.*)$malldir\.pm\z#$1auto:$malldir:#s;
    } else {
	$path =~ s#^(.*)$calldir\.pm\z#$1auto/$calldir/#;
    }

    return $path if -d $path;

    # If that failed, try relative path with normal @INC searching.
    $path = "auto/$calldir/";
    foreach my $inc (@INC) {
	return "$inc/$path" if -d "$inc/$path";
    }

    return;
}

1;

=head1 ACKNOWLEDGMENTS

Thanks to Jos I. Boumans for suggesting this module to be written.

Thanks to Chia-Liang Kao for suggesting C<Path> and C<loc_lang>.

=head1 SEE ALSO

L<Locale::Maketext>, L<Locale::Maketext::Lexicon>

=head1 AUTHORS

Audrey Tang E<lt>cpan@audreyt.orgE<gt>

=head1 COPYRIGHT

Copyright 2003, 2004, 2005, 2006 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.

This software is released under the MIT license cited below.  Additionally,
when this software is distributed with B<Perl Kit, Version 5>, you may also
redistribute it and/or modify it under the same terms as Perl itself.

=head2 The "MIT" License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/perl/5.20.2/Locale/Maketext/TPJ13.pod                                                     0100644 0000000 0000000 00000106420 12744441327 017147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # This document contains text in Perl "POD" format.
# Use a POD viewer like perldoc or perlman to render it.

=head1 NAME

Locale::Maketext::TPJ13 -- article about software localization

=head1 SYNOPSIS

  # This an article, not a module.

=head1 DESCRIPTION

The following article by Sean M. Burke and Jordan Lachler
first appeared in I<The Perl Journal> #13
and is copyright 1999 The Perl Journal. It appears
courtesy of Jon Orwant and The Perl Journal.  This document may be
distributed under the same terms as Perl itself.

=head1 Localization and Perl: gettext breaks, Maketext fixes

by Sean M. Burke and Jordan Lachler

This article points out cases where gettext (a common system for
localizing software interfaces -- i.e., making them work in the user's
language of choice) fails because of basic differences between human
languages.  This article then describes Maketext, a new system capable
of correctly treating these differences.

=head2 A Localization Horror Story: It Could Happen To You

=over

"There are a number of languages spoken by human beings in this
world."

-- Harald Tveit Alvestrand, in RFC 1766, "Tags for the
Identification of Languages"

=back

Imagine that your task for the day is to localize a piece of software
-- and luckily for you, the only output the program emits is two
messages, like this:

  I scanned 12 directories.

  Your query matched 10 files in 4 directories.

So how hard could that be?  You look at the code that
produces the first item, and it reads:

  printf("I scanned %g directories.",
         $directory_count);

You think about that, and realize that it doesn't even work right for
English, as it can produce this output:

  I scanned 1 directories.

So you rewrite it to read:

  printf("I scanned %g %s.",
         $directory_count,
         $directory_count == 1 ?
           "directory" : "directories",
  );

...which does the Right Thing.  (In case you don't recall, "%g" is for
locale-specific number interpolation, and "%s" is for string
interpolation.)

But you still have to localize it for all the languages you're
producing this software for, so you pull Locale::gettext off of CPAN
so you can access the C<gettext> C functions you've heard are standard
for localization tasks.

And you write:

  printf(gettext("I scanned %g %s."),
         $dir_scan_count,
         $dir_scan_count == 1 ?
           gettext("directory") : gettext("directories"),
  );

But you then read in the gettext manual (Drepper, Miller, and Pinard 1995)
that this is not a good idea, since how a single word like "directory"
or "directories" is translated may depend on context -- and this is
true, since in a case language like German or Russian, you'd may need
these words with a different case ending in the first instance (where the
word is the object of a verb) than in the second instance, which you haven't even
gotten to yet (where the word is the object of a preposition, "in %g
directories") -- assuming these keep the same syntax when translated
into those languages.

So, on the advice of the gettext manual, you rewrite:

  printf( $dir_scan_count == 1 ?
           gettext("I scanned %g directory.") :
           gettext("I scanned %g directories."),
         $dir_scan_count );

So, you email your various translators (the boss decides that the
languages du jour are Chinese, Arabic, Russian, and Italian, so you
have one translator for each), asking for translations for "I scanned
%g directory." and "I scanned %g directories.".  When they reply,
you'll put that in the lexicons for gettext to use when it localizes
your software, so that when the user is running under the "zh"
(Chinese) locale, gettext("I scanned %g directory.") will return the
appropriate Chinese text, with a "%g" in there where printf can then
interpolate $dir_scan.

Your Chinese translator emails right back -- he says both of these
phrases translate to the same thing in Chinese, because, in linguistic
jargon, Chinese "doesn't have number as a grammatical category" --
whereas English does.  That is, English has grammatical rules that
refer to "number", i.e., whether something is grammatically singular
or plural; and one of these rules is the one that forces nouns to take
a plural suffix (generally "s") when in a plural context, as they are when
they follow a number other than "one" (including, oddly enough, "zero").
Chinese has no such rules, and so has just the one phrase where English
has two.  But, no problem, you can have this one Chinese phrase appear
as the translation for the two English phrases in the "zh" gettext
lexicon for your program.

Emboldened by this, you dive into the second phrase that your software
needs to output: "Your query matched 10 files in 4 directories.".  You notice
that if you want to treat phrases as indivisible, as the gettext
manual wisely advises, you need four cases now, instead of two, to
cover the permutations of singular and plural on the two items,
$dir_count and $file_count.  So you try this:

  printf( $file_count == 1 ?
    ( $directory_count == 1 ?
     gettext("Your query matched %g file in %g directory.") :
     gettext("Your query matched %g file in %g directories.") ) :
    ( $directory_count == 1 ?
     gettext("Your query matched %g files in %g directory.") :
     gettext("Your query matched %g files in %g directories.") ),
   $file_count, $directory_count,
  );

(The case of "1 file in 2 [or more] directories" could, I suppose,
occur in the case of symlinking or something of the sort.)

It occurs to you that this is not the prettiest code you've ever
written, but this seems the way to go.  You mail off to the
translators asking for translations for these four cases.  The
Chinese guy replies with the one phrase that these all translate to in
Chinese, and that phrase has two "%g"s in it, as it should -- but
there's a problem.  He translates it word-for-word back: "In %g
directories contains %g files match your query."  The %g
slots are in an order reverse to what they are in English.  You wonder
how you'll get gettext to handle that.

But you put it aside for the moment, and optimistically hope that the
other translators won't have this problem, and that their languages
will be better behaved -- i.e., that they will be just like English.

But the Arabic translator is the next to write back.  First off, your
code for "I scanned %g directory." or "I scanned %g directories."
assumes there's only singular or plural.  But, to use linguistic
jargon again, Arabic has grammatical number, like English (but unlike
Chinese), but it's a three-term category: singular, dual, and plural.
In other words, the way you say "directory" depends on whether there's
one directory, or I<two> of them, or I<more than two> of them.  Your
test of C<($directory == 1)> no longer does the job.  And it means
that where English's grammatical category of number necessitates
only the two permutations of the first sentence based on "directory
[singular]" and "directories [plural]", Arabic has three -- and,
worse, in the second sentence ("Your query matched %g file in %g
directory."), where English has four, Arabic has nine.  You sense
an unwelcome, exponential trend taking shape.

Your Italian translator emails you back and says that "I searched 0
directories" (a possible English output of your program) is stilted,
and if you think that's fine English, that's your problem, but that
I<just will not do> in the language of Dante.  He insists that where
$directory_count is 0, your program should produce the Italian text
for "I I<didn't> scan I<any> directories.".  And ditto for "I didn't
match any files in any directories", although he says the last part
about "in any directories" should probably just be left off.

You wonder how you'll get gettext to handle this; to accommodate the
ways Arabic, Chinese, and Italian deal with numbers in just these few
very simple phrases, you need to write code that will ask gettext for
different queries depending on whether the numerical values in
question are 1, 2, more than 2, or in some cases 0, and you still haven't
figured out the problem with the different word order in Chinese.

Then your Russian translator calls on the phone, to I<personally> tell
you the bad news about how really unpleasant your life is about to
become:

Russian, like German or Latin, is an inflectional language; that is, nouns
and adjectives have to take endings that depend on their case
(i.e., nominative, accusative, genitive, etc...) -- which is roughly a matter of
what role they have in syntax of the sentence --
as well as on the grammatical gender (i.e., masculine, feminine, neuter)
and number (i.e., singular or plural) of the noun, as well as on the
declension class of the noun.  But unlike with most other inflected languages,
putting a number-phrase (like "ten" or "forty-three", or their Arabic
numeral equivalents) in front of noun in Russian can change the case and
number that noun is, and therefore the endings you have to put on it.

He elaborates:  In "I scanned %g directories", you'd I<expect>
"directories" to be in the accusative case (since it is the direct
object in the sentence) and the plural number,
except where $directory_count is 1, then you'd expect the singular, of
course.  Just like Latin or German.  I<But!>  Where $directory_count %
10 is 1 ("%" for modulo, remember), assuming $directory count is an
integer, and except where $directory_count % 100 is 11, "directories"
is forced to become grammatically singular, which means it gets the
ending for the accusative singular...  You begin to visualize the code
it'd take to test for the problem so far, I<and still work for Chinese
and Arabic and Italian>, and how many gettext items that'd take, but
he keeps going...  But where $directory_count % 10 is 2, 3, or 4
(except where $directory_count % 100 is 12, 13, or 14), the word for
"directories" is forced to be genitive singular -- which means another
ending... The room begins to spin around you, slowly at first...  But
with I<all other> integer values, since "directory" is an inanimate
noun, when preceded by a number and in the nominative or accusative
cases (as it is here, just your luck!), it does stay plural, but it is
forced into the genitive case -- yet another ending...  And
you never hear him get to the part about how you're going to run into
similar (but maybe subtly different) problems with other Slavic
languages like Polish, because the floor comes up to meet you, and you
fade into unconsciousness.


The above cautionary tale relates how an attempt at localization can
lead from programmer consternation, to program obfuscation, to a need
for sedation.  But careful evaluation shows that your choice of tools
merely needed further consideration.

=head2 The Linguistic View

=over

"It is more complicated than you think." 

-- The Eighth Networking Truth, from RFC 1925

=back

The field of Linguistics has expended a great deal of effort over the
past century trying to find grammatical patterns which hold across
languages; it's been a constant process
of people making generalizations that should apply to all languages,
only to find out that, all too often, these generalizations fail --
sometimes failing for just a few languages, sometimes whole classes of
languages, and sometimes nearly every language in the world except
English.  Broad statistical trends are evident in what the "average
language" is like as far as what its rules can look like, must look
like, and cannot look like.  But the "average language" is just as
unreal a concept as the "average person" -- it runs up against the
fact no language (or person) is, in fact, average.  The wisdom of past
experience leads us to believe that any given language can do whatever
it wants, in any order, with appeal to any kind of grammatical
categories wants -- case, number, tense, real or metaphoric
characteristics of the things that words refer to, arbitrary or
predictable classifications of words based on what endings or prefixes
they can take, degree or means of certainty about the truth of
statements expressed, and so on, ad infinitum.

Mercifully, most localization tasks are a matter of finding ways to
translate whole phrases, generally sentences, where the context is
relatively set, and where the only variation in content is I<usually>
in a number being expressed -- as in the example sentences above.
Translating specific, fully-formed sentences is, in practice, fairly
foolproof -- which is good, because that's what's in the phrasebooks
that so many tourists rely on.  Now, a given phrase (whether in a
phrasebook or in a gettext lexicon) in one language I<might> have a
greater or lesser applicability than that phrase's translation into
another language -- for example, strictly speaking, in Arabic, the
"your" in "Your query matched..." would take a different form
depending on whether the user is male or female; so the Arabic
translation "your[feminine] query" is applicable in fewer cases than
the corresponding English phrase, which doesn't distinguish the user's
gender.  (In practice, it's not feasible to have a program know the
user's gender, so the masculine "you" in Arabic is usually used, by
default.)

But in general, such surprises are rare when entire sentences are
being translated, especially when the functional context is restricted
to that of a computer interacting with a user either to convey a fact
or to prompt for a piece of information.  So, for purposes of
localization, translation by phrase (generally by sentence) is both the
simplest and the least problematic.

=head2 Breaking gettext

=over

"It Has To Work."

-- First Networking Truth, RFC 1925

=back

Consider that sentences in a tourist phrasebook are of two types: ones
like "How do I get to the marketplace?" that don't have any blanks to
fill in, and ones like "How much do these ___ cost?", where there's
one or more blanks to fill in (and these are usually linked to a
list of words that you can put in that blank: "fish", "potatoes",
"tomatoes", etc.)  The ones with no blanks are no problem, but the
fill-in-the-blank ones may not be really straightforward. If it's a
Swahili phrasebook, for example, the authors probably didn't bother to
tell you the complicated ways that the verb "cost" changes its
inflectional prefix depending on the noun you're putting in the blank.
The trader in the marketplace will still understand what you're saying if
you say "how much do these potatoes cost?" with the wrong
inflectional prefix on "cost".  After all, I<you> can't speak proper Swahili,
I<you're> just a tourist.  But while tourists can be stupid, computers
are supposed to be smart; the computer should be able to fill in the
blank, and still have the results be grammatical.

In other words, a phrasebook entry takes some values as parameters
(the things that you fill in the blank or blanks), and provides a value
based on these parameters, where the way you get that final value from
the given values can, properly speaking, involve an arbitrarily
complex series of operations.  (In the case of Chinese, it'd be not at
all complex, at least in cases like the examples at the beginning of
this article; whereas in the case of Russian it'd be a rather complex
series of operations.  And in some languages, the
complexity could be spread around differently: while the act of
putting a number-expression in front of a noun phrase might not be
complex by itself, it may change how you have to, for example, inflect
a verb elsewhere in the sentence.  This is what in syntax is called
"long-distance dependencies".)

This talk of parameters and arbitrary complexity is just another way
to say that an entry in a phrasebook is what in a programming language
would be called a "function".  Just so you don't miss it, this is the
crux of this article: I<A phrase is a function; a phrasebook is a
bunch of functions.>

The reason that using gettext runs into walls (as in the above
second-person horror story) is that you're trying to use a string (or
worse, a choice among a bunch of strings) to do what you really need a
function for -- which is futile.  Preforming (s)printf interpolation
on the strings which you get back from gettext does allow you to do I<some>
common things passably well... sometimes... sort of; but, to paraphrase
what some people say about C<csh> script programming, "it fools you
into thinking you can use it for real things, but you can't, and you
don't discover this until you've already spent too much time trying,
and by then it's too late."

=head2 Replacing gettext

So, what needs to replace gettext is a system that supports lexicons
of functions instead of lexicons of strings.  An entry in a lexicon
from such a system should I<not> look like this:

  "J'ai trouv\xE9 %g fichiers dans %g r\xE9pertoires"

[\xE9 is e-acute in Latin-1.  Some pod renderers would
scream if I used the actual character here. -- SB]

but instead like this, bearing in mind that this is just a first stab:

  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = sprintf("%g %s", $files,
      $files == 1 ? 'fichier' : 'fichiers');
    $dirs = sprintf("%g %s", $dirs,
      $dirs == 1 ? "r\xE9pertoire" : "r\xE9pertoires");
    return "J'ai trouv\xE9 $files dans $dirs.";
  }

Now, there's no particularly obvious way to store anything but strings
in a gettext lexicon; so it looks like we just have to start over and
make something better, from scratch.  I call my shot at a
gettext-replacement system "Maketext", or, in CPAN terms,
Locale::Maketext.

When designing Maketext, I chose to plan its main features in terms of
"buzzword compliance".  And here are the buzzwords:

=head2 Buzzwords: Abstraction and Encapsulation

The complexity of the language you're trying to output a phrase in is
entirely abstracted inside (and encapsulated within) the Maketext module
for that interface.  When you call:

  print $lang->maketext("You have [quant,_1,piece] of new mail.",
                       scalar(@messages));

you don't know (and in fact can't easily find out) whether this will
involve lots of figuring, as in Russian (if $lang is a handle to the
Russian module), or relatively little, as in Chinese.  That kind of
abstraction and encapsulation may encourage other pleasant buzzwords
like modularization and stratification, depending on what design
decisions you make.

=head2 Buzzword: Isomorphism

"Isomorphism" means "having the same structure or form"; in discussions
of program design, the word takes on the special, specific meaning that
your implementation of a solution to a problem I<has the same
structure> as, say, an informal verbal description of the solution, or
maybe of the problem itself.  Isomorphism is, all things considered,
a good thing -- it's what problem-solving (and solution-implementing)
should look like.

What's wrong the with gettext-using code like this...

  printf( $file_count == 1 ?
    ( $directory_count == 1 ?
     "Your query matched %g file in %g directory." :
     "Your query matched %g file in %g directories." ) :
    ( $directory_count == 1 ?
     "Your query matched %g files in %g directory." :
     "Your query matched %g files in %g directories." ),
   $file_count, $directory_count,
  );

is first off that it's not well abstracted -- these ways of testing
for grammatical number (as in the expressions like C<foo == 1 ?
singular_form : plural_form>) should be abstracted to each language
module, since how you get grammatical number is language-specific.

But second off, it's not isomorphic -- the "solution" (i.e., the
phrasebook entries) for Chinese maps from these four English phrases to
the one Chinese phrase that fits for all of them.  In other words, the
informal solution would be "The way to say what you want in Chinese is
with the one phrase 'For your question, in Y directories you would
find X files'" -- and so the implemented solution should be,
isomorphically, just a straightforward way to spit out that one
phrase, with numerals properly interpolated.  It shouldn't have to map
from the complexity of other languages to the simplicity of this one.

=head2 Buzzword: Inheritance

There's a great deal of reuse possible for sharing of phrases between
modules for related dialects, or for sharing of auxiliary functions
between related languages.  (By "auxiliary functions", I mean
functions that don't produce phrase-text, but which, say, return an
answer to "does this number require a plural noun after it?".  Such
auxiliary functions would be used in the internal logic of functions
that actually do produce phrase-text.)

In the case of sharing phrases, consider that you have an interface
already localized for American English (probably by having been
written with that as the native locale, but that's incidental).
Localizing it for UK English should, in practical terms, be just a
matter of running it past a British person with the instructions to
indicate what few phrases would benefit from a change in spelling or
possibly minor rewording.  In that case, you should be able to put in
the UK English localization module I<only> those phrases that are
UK-specific, and for all the rest, I<inherit> from the American
English module.  (And I expect this same situation would apply with
Brazilian and Continental Portugese, possibly with some I<very>
closely related languages like Czech and Slovak, and possibly with the
slightly different "versions" of written Mandarin Chinese, as I hear exist in
Taiwan and mainland China.)

As to sharing of auxiliary functions, consider the problem of Russian
numbers from the beginning of this article; obviously, you'd want to
write only once the hairy code that, given a numeric value, would
return some specification of which case and number a given quantified
noun should use.  But suppose that you discover, while localizing an
interface for, say, Ukranian (a Slavic language related to Russian,
spoken by several million people, many of whom would be relieved to
find that your Web site's or software's interface is available in
their language), that the rules in Ukranian are the same as in Russian
for quantification, and probably for many other grammatical functions.
While there may well be no phrases in common between Russian and
Ukranian, you could still choose to have the Ukranian module inherit
from the Russian module, just for the sake of inheriting all the
various grammatical methods.  Or, probably better organizationally,
you could move those functions to a module called C<_E_Slavic> or
something, which Russian and Ukrainian could inherit useful functions
from, but which would (presumably) provide no lexicon.

=head2 Buzzword: Concision

Okay, concision isn't a buzzword.  But it should be, so I decree that
as a new buzzword, "concision" means that simple common things should
be expressible in very few lines (or maybe even just a few characters)
of code -- call it a special case of "making simple things easy and
hard things possible", and see also the role it played in the
MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].

Consider our first stab at an entry in our "phrasebook of functions":

  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = sprintf("%g %s", $files,
      $files == 1 ? 'fichier' : 'fichiers');
    $dirs = sprintf("%g %s", $dirs,
      $dirs == 1 ? "r\xE9pertoire" : "r\xE9pertoires");
    return "J'ai trouv\xE9 $files dans $dirs.";
  }

You may sense that a lexicon (to use a non-committal catch-all term for a
collection of things you know how to say, regardless of whether they're
phrases or words) consisting of functions I<expressed> as above would
make for rather long-winded and repetitive code -- even if you wisely
rewrote this to have quantification (as we call adding a number
expression to a noun phrase) be a function called like:

  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = quant($files, "fichier");
    $dirs =  quant($dirs,  "r\xE9pertoire");
    return "J'ai trouv\xE9 $files dans $dirs.";
  }

And you may also sense that you do not want to bother your translators
with having to write Perl code -- you'd much rather that they spend
their I<very costly time> on just translation.  And this is to say
nothing of the near impossibility of finding a commercial translator
who would know even simple Perl.

In a first-hack implementation of Maketext, each language-module's
lexicon looked like this:

 %Lexicon = (
   "I found %g files in %g directories"
   => sub {
      my( $files, $dirs ) = @_[0,1];
      $files = quant($files, "fichier");
      $dirs =  quant($dirs,  "r\xE9pertoire");
      return "J'ai trouv\xE9 $files dans $dirs.";
    },
  ... and so on with other phrase => sub mappings ...
 );

but I immediately went looking for some more concise way to basically
denote the same phrase-function -- a way that would also serve to
concisely denote I<most> phrase-functions in the lexicon for I<most>
languages.  After much time and even some actual thought, I decided on
this system:

* Where a value in a %Lexicon hash is a contentful string instead of
an anonymous sub (or, conceivably, a coderef), it would be interpreted
as a sort of shorthand expression of what the sub does.  When accessed
for the first time in a session, it is parsed, turned into Perl code,
and then eval'd into an anonymous sub; then that sub replaces the
original string in that lexicon.  (That way, the work of parsing and
evaling the shorthand form for a given phrase is done no more than
once per session.)

* Calls to C<maketext> (as Maketext's main function is called) happen
thru a "language session handle", notionally very much like an IO
handle, in that you open one at the start of the session, and use it
for "sending signals" to an object in order to have it return the text
you want.

So, this:

  $lang->maketext("You have [quant,_1,piece] of new mail.",
                 scalar(@messages));

basically means this: look in the lexicon for $lang (which may inherit
from any number of other lexicons), and find the function that we
happen to associate with the string "You have [quant,_1,piece] of new
mail" (which is, and should be, a functioning "shorthand" for this
function in the native locale -- English in this case).  If you find
such a function, call it with $lang as its first parameter (as if it
were a method), and then a copy of scalar(@messages) as its second,
and then return that value.  If that function was found, but was in
string shorthand instead of being a fully specified function, parse it
and make it into a function before calling it the first time.

* The shorthand uses code in brackets to indicate method calls that
should be performed.  A full explanation is not in order here, but a
few examples will suffice:

  "You have [quant,_1,piece] of new mail."

The above code is shorthand for, and will be interpreted as,
this:

  sub {
    my $handle = $_[0];
    my(@params) = @_;
    return join '',
      "You have ",
      $handle->quant($params[1], 'piece'),
      "of new mail.";
  }

where "quant" is the name of a method you're using to quantify the
noun "piece" with the number $params[0].

A string with no brackety calls, like this:

  "Your search expression was malformed."

is somewhat of a degenerate case, and just gets turned into:

  sub { return "Your search expression was malformed." }

However, not everything you can write in Perl code can be written in
the above shorthand system -- not by a long shot.  For example, consider
the Italian translator from the beginning of this article, who wanted
the Italian for "I didn't find any files" as a special case, instead
of "I found 0 files".  That couldn't be specified (at least not easily
or simply) in our shorthand system, and it would have to be written
out in full, like this:

  sub {  # pretend the English strings are in Italian
    my($handle, $files, $dirs) = @_[0,1,2];
    return "I didn't find any files" unless $files;
    return join '',
      "I found ",
      $handle->quant($files, 'file'),
      " in ",
      $handle->quant($dirs,  'directory'),
      ".";
  }

Next to a lexicon full of shorthand code, that sort of sticks out like a
sore thumb -- but this I<is> a special case, after all; and at least
it's possible, if not as concise as usual.

As to how you'd implement the Russian example from the beginning of
the article, well, There's More Than One Way To Do It, but it could be
something like this (using English words for Russian, just so you know
what's going on):

  "I [quant,_1,directory,accusative] scanned."

This shifts the burden of complexity off to the quant method.  That
method's parameters are: the numeric value it's going to use to
quantify something; the Russian word it's going to quantify; and the
parameter "accusative", which you're using to mean that this
sentence's syntax wants a noun in the accusative case there, although
that quantification method may have to overrule, for grammatical
reasons you may recall from the beginning of this article.

Now, the Russian quant method here is responsible not only for
implementing the strange logic necessary for figuring out how Russian
number-phrases impose case and number on their noun-phrases, but also
for inflecting the Russian word for "directory".  How that inflection
is to be carried out is no small issue, and among the solutions I've
seen, some (like variations on a simple lookup in a hash where all
possible forms are provided for all necessary words) are
straightforward but I<can> become cumbersome when you need to inflect
more than a few dozen words; and other solutions (like using
algorithms to model the inflections, storing only root forms and
irregularities) I<can> involve more overhead than is justifiable for
all but the largest lexicons.

Mercifully, this design decision becomes crucial only in the hairiest
of inflected languages, of which Russian is by no means the I<worst> case
scenario, but is worse than most.  Most languages have simpler
inflection systems; for example, in English or Swahili, there are
generally no more than two possible inflected forms for a given noun
("error/errors"; "kosa/makosa"), and the
rules for producing these forms are fairly simple -- or at least,
simple rules can be formulated that work for most words, and you can
then treat the exceptions as just "irregular", at least relative to
your ad hoc rules.  A simpler inflection system (simpler rules, fewer
forms) means that design decisions are less crucial to maintaining
sanity, whereas the same decisions could incur
overhead-versus-scalability problems in languages like Russian.  It
may I<also> be likely that code (possibly in Perl, as with
Lingua::EN::Inflect, for English nouns) has already
been written for the language in question, whether simple or complex.

Moreover, a third possibility may even be simpler than anything
discussed above: "Just require that all possible (or at least
applicable) forms be provided in the call to the given language's quant
method, as in:"

  "I found [quant,_1,file,files]."

That way, quant just has to chose which form it needs, without having
to look up or generate anything.  While possibly not optimal for
Russian, this should work well for most other languages, where
quantification is not as complicated an operation.

=head2 The Devil in the Details

There's plenty more to Maketext than described above -- for example,
there's the details of how language tags ("en-US", "i-pwn", "fi",
etc.) or locale IDs ("en_US") interact with actual module naming
("BogoQuery/Locale/en_us.pm"), and what magic can ensue; there's the
details of how to record (and possibly negotiate) what character
encoding Maketext will return text in (UTF8? Latin-1? KOI8?).  There's
the interesting fact that Maketext is for localization, but nowhere
actually has a "C<use locale;>" anywhere in it.  For the curious,
there's the somewhat frightening details of how I actually
implement something like data inheritance so that searches across
modules' %Lexicon hashes can parallel how Perl implements method
inheritance.

And, most importantly, there's all the practical details of how to
actually go about deriving from Maketext so you can use it for your
interfaces, and the various tools and conventions for starting out and
maintaining individual language modules.

That is all covered in the documentation for Locale::Maketext and the
modules that come with it, available in CPAN.  After having read this
article, which covers the why's of Maketext, the documentation,
which covers the how's of it, should be quite straightforward.

=head2 The Proof in the Pudding: Localizing Web Sites

Maketext and gettext have a notable difference: gettext is in C,
accessible thru C library calls, whereas Maketext is in Perl, and
really can't work without a Perl interpreter (although I suppose
something like it could be written for C).  Accidents of history (and
not necessarily lucky ones) have made C++ the most common language for
the implementation of applications like word processors, Web browsers,
and even many in-house applications like custom query systems.  Current
conditions make it somewhat unlikely that the next one of any of these
kinds of applications will be written in Perl, albeit clearly more for
reasons of custom and inertia than out of consideration of what is the
right tool for the job.

However, other accidents of history have made Perl a well-accepted
language for design of server-side programs (generally in CGI form)
for Web site interfaces.  Localization of static pages in Web sites is
trivial, feasible either with simple language-negotiation features in
servers like Apache, or with some kind of server-side inclusions of
language-appropriate text into layout templates.  However, I think
that the localization of Perl-based search systems (or other kinds of
dynamic content) in Web sites, be they public or access-restricted,
is where Maketext will see the greatest use.

I presume that it would be only the exceptional Web site that gets
localized for English I<and> Chinese I<and> Italian I<and> Arabic
I<and> Russian, to recall the languages from the beginning of this
article -- to say nothing of German, Spanish, French, Japanese,
Finnish, and Hindi, to name a few languages that benefit from large
numbers of programmers or Web viewers or both.

However, the ever-increasing internationalization of the Web (whether
measured in terms of amount of content, of numbers of content writers
or programmers, or of size of content audiences) makes it increasingly
likely that the interface to the average Web-based dynamic content
service will be localized for two or maybe three languages.  It is my
hope that Maketext will make that task as simple as possible, and will
remove previous barriers to localization for languages dissimilar to
English.

 __END__

Sean M. Burke (sburkeE<64>cpan.org) has a Master's in linguistics
from Northwestern University; he specializes in language technology.
Jordan Lachler (lachlerE<64>unm.edu) is a PhD student in the Department of
Linguistics at the University of New Mexico; he specializes in
morphology and pedagogy of North American native languages.

=head2 References

Alvestrand, Harald Tveit.  1995.  I<RFC 1766: Tags for the
Identification of Languages.>
C<http://www.ietf.org/rfc/rfc1766.txt>
[Now see RFC 3066.]

Callon, Ross, editor.  1996.  I<RFC 1925: The Twelve
Networking Truths.>
C<http://www.ietf.org/rfc/rfc1925.txt>

Drepper, Ulrich, Peter Miller,
and FranE<ccedil>ois Pinard.  1995-2001.  GNU
C<gettext>.  Available in C<ftp://prep.ai.mit.edu/pub/gnu/>, with
extensive docs in the distribution tarball.  [Since
I wrote this article in 1998, I now see that the
gettext docs are now trying more to come to terms with
plurality.  Whether useful conclusions have come from it
is another question altogether. -- SMB, May 2001]

Forbes, Nevill.  1964.  I<Russian Grammar.>  Third Edition, revised
by J. C. Dumbreck.  Oxford University Press.

=cut

#End

                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Locale/Maketext.pm                                                            0100644 0000000 0000000 00000070146 12744441327 016205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package Locale::Maketext;
use strict;
use vars qw( @ISA $VERSION $MATCH_SUPERS $USING_LANGUAGE_TAGS
$USE_LITERALS $MATCH_SUPERS_TIGHTLY);
use Carp ();
use I18N::LangTags ();
use I18N::LangTags::Detect ();

#--------------------------------------------------------------------------

BEGIN { unless(defined &DEBUG) { *DEBUG = sub () {0} } }
# define the constant 'DEBUG' at compile-time

# turn on utf8 if we have it (this is what GutsLoader.pm used to do essentially )
#    use if (exists $INC{'utf8.pm'} || eval 'use utf8'), 'utf8';
BEGIN {

    # if we have it || we can load it
    if ( exists $INC{'utf8.pm'} || eval { local $SIG{'__DIE__'};require utf8; } ) {
        utf8->import();
        DEBUG and warn " utf8 on for _compile()\n";
    }
    else {
        DEBUG and warn " utf8 not available for _compile() ($INC{'utf8.pm'})\n$@\n";
    }
}


$VERSION = '1.25';
@ISA = ();

$MATCH_SUPERS = 1;
$MATCH_SUPERS_TIGHTLY = 1;
$USING_LANGUAGE_TAGS  = 1;
# Turning this off is somewhat of a security risk in that little or no
# checking will be done on the legality of tokens passed to the
# eval("use $module_name") in _try_use.  If you turn this off, you have
# to do your own taint checking.

$USE_LITERALS = 1 unless defined $USE_LITERALS;
# a hint for compiling bracket-notation things.

my %isa_scan = ();

###########################################################################

sub quant {
    my($handle, $num, @forms) = @_;

    return $num if @forms == 0; # what should this mean?
    return $forms[2] if @forms > 2 and $num == 0; # special zeroth case

    # Normal case:
    # Note that the formatting of $num is preserved.
    return( $handle->numf($num) . ' ' . $handle->numerate($num, @forms) );
    # Most human languages put the number phrase before the qualified phrase.
}


sub numerate {
    # return this lexical item in a form appropriate to this number
    my($handle, $num, @forms) = @_;
    my $s = ($num == 1);

    return '' unless @forms;
    if(@forms == 1) { # only the headword form specified
        return $s ? $forms[0] : ($forms[0] . 's'); # very cheap hack.
    }
    else { # sing and plural were specified
        return $s ? $forms[0] : $forms[1];
    }
}

#--------------------------------------------------------------------------

sub numf {
    my($handle, $num) = @_[0,1];
    if($num < 10_000_000_000 and $num > -10_000_000_000 and $num == int($num)) {
        $num += 0;  # Just use normal integer stringification.
        # Specifically, don't let %G turn ten million into 1E+007
    }
    else {
        $num = CORE::sprintf('%G', $num);
        # "CORE::" is there to avoid confusion with the above sub sprintf.
    }
    while( $num =~ s/^([-+]?\d+)(\d{3})/$1,$2/s ) {1}  # right from perlfaq5
    # The initial \d+ gobbles as many digits as it can, and then we
    #  backtrack so it un-eats the rightmost three, and then we
    #  insert the comma there.

    $num =~ tr<.,><,.> if ref($handle) and $handle->{'numf_comma'};
    # This is just a lame hack instead of using Number::Format
    return $num;
}

sub sprintf {
    no integer;
    my($handle, $format, @params) = @_;
    return CORE::sprintf($format, @params);
    # "CORE::" is there to avoid confusion with myself!
}

#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#

use integer; # vroom vroom... applies to the whole rest of the module

sub language_tag {
    my $it = ref($_[0]) || $_[0];
    return undef unless $it =~ m/([^':]+)(?:::)?$/s;
    $it = lc($1);
    $it =~ tr<_><->;
    return $it;
}

sub encoding {
    my $it = $_[0];
    return(
        (ref($it) && $it->{'encoding'})
        || 'iso-8859-1'   # Latin-1
    );
}

#--------------------------------------------------------------------------

sub fallback_languages { return('i-default', 'en', 'en-US') }

sub fallback_language_classes { return () }

#--------------------------------------------------------------------------

sub fail_with { # an actual attribute method!
    my($handle, @params) = @_;
    return unless ref($handle);
    $handle->{'fail'} = $params[0] if @params;
    return $handle->{'fail'};
}

#--------------------------------------------------------------------------

sub failure_handler_auto {
    # Meant to be used like:
    #  $handle->fail_with('failure_handler_auto')

    my $handle = shift;
    my $phrase = shift;

    $handle->{'failure_lex'} ||= {};
    my $lex = $handle->{'failure_lex'};

    my $value ||= ($lex->{$phrase} ||= $handle->_compile($phrase));

    # Dumbly copied from sub maketext:
    return ${$value} if ref($value) eq 'SCALAR';
    return $value    if ref($value) ne 'CODE';
    {
        local $SIG{'__DIE__'};
        eval { $value = &$value($handle, @_) };
    }
    # If we make it here, there was an exception thrown in the
    #  call to $value, and so scream:
    if($@) {
        # pretty up the error message
        $@ =~ s{\s+at\s+\(eval\s+\d+\)\s+line\s+(\d+)\.?\n?}
                 {\n in bracket code [compiled line $1],}s;
        #$err =~ s/\n?$/\n/s;
        Carp::croak "Error in maketexting \"$phrase\":\n$@ as used";
        # Rather unexpected, but suppose that the sub tried calling
        # a method that didn't exist.
    }
    else {
        return $value;
    }
}

#==========================================================================

sub new {
    # Nothing fancy!
    my $class = ref($_[0]) || $_[0];
    my $handle = bless {}, $class;
    $handle->init;
    return $handle;
}

sub init { return } # no-op

###########################################################################

sub maketext {
    # Remember, this can fail.  Failure is controllable many ways.
    Carp::croak 'maketext requires at least one parameter' unless @_ > 1;

    my($handle, $phrase) = splice(@_,0,2);
    Carp::confess('No handle/phrase') unless (defined($handle) && defined($phrase));

    # backup $@ in case it's still being used in the calling code.
    # If no failures, we'll re-set it back to what it was later.
    my $at = $@;

    # Copy @_ case one of its elements is $@.
    @_ = @_;

    # Look up the value:

    my $value;
    if (exists $handle->{'_external_lex_cache'}{$phrase}) {
        DEBUG and warn "* Using external lex cache version of \"$phrase\"\n";
        $value = $handle->{'_external_lex_cache'}{$phrase};
    }
    else {
        foreach my $h_r (
            @{  $isa_scan{ref($handle) || $handle} || $handle->_lex_refs  }
        ) {
            DEBUG and warn "* Looking up \"$phrase\" in $h_r\n";
            if(exists $h_r->{$phrase}) {
                DEBUG and warn "  Found \"$phrase\" in $h_r\n";
                unless(ref($value = $h_r->{$phrase})) {
                    # Nonref means it's not yet compiled.  Compile and replace.
                    if ($handle->{'use_external_lex_cache'}) {
                        $value = $handle->{'_external_lex_cache'}{$phrase} = $handle->_compile($value);
                    }
                    else {
                        $value = $h_r->{$phrase} = $handle->_compile($value);
                    }
                }
                last;
            }
            # extending packages need to be able to localize _AUTO and if readonly can't "local $h_r->{'_AUTO'} = 1;"
            # but they can "local $handle->{'_external_lex_cache'}{'_AUTO'} = 1;"
            elsif($phrase !~ m/^_/s and ($handle->{'use_external_lex_cache'} ? ( exists $handle->{'_external_lex_cache'}{'_AUTO'} ? $handle->{'_external_lex_cache'}{'_AUTO'} : $h_r->{'_AUTO'} ) : $h_r->{'_AUTO'})) {
                # it's an auto lex, and this is an autoable key!
                DEBUG and warn "  Automaking \"$phrase\" into $h_r\n";
                if ($handle->{'use_external_lex_cache'}) {
                    $value = $handle->{'_external_lex_cache'}{$phrase} = $handle->_compile($phrase);
                }
                else {
                    $value = $h_r->{$phrase} = $handle->_compile($phrase);
                }
                last;
            }
            DEBUG>1 and print "  Not found in $h_r, nor automakable\n";
            # else keep looking
        }
    }

    unless(defined($value)) {
        DEBUG and warn "! Lookup of \"$phrase\" in/under ", ref($handle) || $handle, " fails.\n";
        if(ref($handle) and $handle->{'fail'}) {
            DEBUG and warn "WARNING0: maketext fails looking for <$phrase>\n";
            my $fail;
            if(ref($fail = $handle->{'fail'}) eq 'CODE') { # it's a sub reference
                $@ = $at; # Put $@ back in case we altered it along the way.
                return &{$fail}($handle, $phrase, @_);
                # If it ever returns, it should return a good value.
            }
            else { # It's a method name
                $@ = $at; # Put $@ back in case we altered it along the way.
                return $handle->$fail($phrase, @_);
                # If it ever returns, it should return a good value.
            }
        }
        else {
            # All we know how to do is this;
            Carp::croak("maketext doesn't know how to say:\n$phrase\nas needed");
        }
    }

    if(ref($value) eq 'SCALAR'){
        $@ = $at; # Put $@ back in case we altered it along the way.
        return $$value ;
    }
    if(ref($value) ne 'CODE'){
        $@ = $at; # Put $@ back in case we altered it along the way.
        return $value ;
    }

    {
        local $SIG{'__DIE__'};
        eval { $value = &$value($handle, @_) };
    }
    # If we make it here, there was an exception thrown in the
    #  call to $value, and so scream:
    if ($@) {
        # pretty up the error message
        $@ =~ s{\s+at\s+\(eval\s+\d+\)\s+line\s+(\d+)\.?\n?}
                 {\n in bracket code [compiled line $1],}s;
        #$err =~ s/\n?$/\n/s;
        Carp::croak "Error in maketexting \"$phrase\":\n$@ as used";
        # Rather unexpected, but suppose that the sub tried calling
        # a method that didn't exist.
    }
    else {
        $@ = $at; # Put $@ back in case we altered it along the way.
        return $value;
    }
    $@ = $at; # Put $@ back in case we altered it along the way.
}

###########################################################################

sub get_handle {  # This is a constructor and, yes, it CAN FAIL.
    # Its class argument has to be the base class for the current
    # application's l10n files.

    my($base_class, @languages) = @_;
    $base_class = ref($base_class) || $base_class;
    # Complain if they use __PACKAGE__ as a project base class?

    if( @languages ) {
        DEBUG and warn 'Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
        if($USING_LANGUAGE_TAGS) {   # An explicit language-list was given!
            @languages =
            map {; $_, I18N::LangTags::alternate_language_tags($_) }
            # Catch alternation
            map I18N::LangTags::locale2language_tag($_),
            # If it's a lg tag, fine, pass thru (untainted)
            # If it's a locale ID, try converting to a lg tag (untainted),
            # otherwise nix it.
            @languages;
            DEBUG and warn 'Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
        }
    }
    else {
        @languages = $base_class->_ambient_langprefs;
    }

    @languages = $base_class->_langtag_munging(@languages);

    my %seen;
    foreach my $module_name ( map { $base_class . '::' . $_ }  @languages ) {
        next unless length $module_name; # sanity
        next if $seen{$module_name}++        # Already been here, and it was no-go
        || !&_try_use($module_name); # Try to use() it, but can't it.
        return($module_name->new); # Make it!
    }

    return undef; # Fail!
}

###########################################################################

sub _langtag_munging {
    my($base_class, @languages) = @_;

    # We have all these DEBUG statements because otherwise it's hard as hell
    # to diagnose if/when something goes wrong.

    DEBUG and warn 'Lgs1: ', map("<$_>", @languages), "\n";

    if($USING_LANGUAGE_TAGS) {
        DEBUG and warn 'Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
        @languages     = $base_class->_add_supers( @languages );

        push @languages, I18N::LangTags::panic_languages(@languages);
        DEBUG and warn "After adding panic languages:\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";

        push @languages, $base_class->fallback_languages;
        # You are free to override fallback_languages to return empty-list!
        DEBUG and warn 'Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";

        @languages =  # final bit of processing to turn them into classname things
        map {
            my $it = $_;  # copy
            $it =~ tr<-A-Z><_a-z>; # lc, and turn - to _
            $it =~ tr<_a-z0-9><>cd;  # remove all but a-z0-9_
            $it;
        } @languages
        ;
        DEBUG and warn "Nearing end of munging:\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
    }
    else {
        DEBUG and warn "Bypassing language-tags.\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
    }

    DEBUG and warn "Before adding fallback classes:\n",
    ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";

    push @languages, $base_class->fallback_language_classes;
    # You are free to override that to return whatever.

    DEBUG and warn "Finally:\n",
    ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";

    return @languages;
}

###########################################################################

sub _ambient_langprefs {
    return  I18N::LangTags::Detect::detect();
}

###########################################################################

sub _add_supers {
    my($base_class, @languages) = @_;

    if (!$MATCH_SUPERS) {
        # Nothing
        DEBUG and warn "Bypassing any super-matching.\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";

    }
    elsif( $MATCH_SUPERS_TIGHTLY ) {
        DEBUG and warn "Before adding new supers tightly:\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
        @languages = I18N::LangTags::implicate_supers( @languages );
        DEBUG and warn "After adding new supers tightly:\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";

    }
    else {
        DEBUG and warn "Before adding supers to end:\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
        @languages = I18N::LangTags::implicate_supers_strictly( @languages );
        DEBUG and warn "After adding supers to end:\n",
        ' Lgs@', __LINE__, ': ', map("<$_>", @languages), "\n";
    }

    return @languages;
}

###########################################################################
#
# This is where most people should stop reading.
#
###########################################################################

my %tried = ();
# memoization of whether we've used this module, or found it unusable.

sub _try_use {   # Basically a wrapper around "require Modulename"
    # "Many men have tried..."  "They tried and failed?"  "They tried and died."
    return $tried{$_[0]} if exists $tried{$_[0]};  # memoization

    my $module = $_[0];   # ASSUME sane module name!
    { no strict 'refs';
        no warnings 'once';
        return($tried{$module} = 1)
        if %{$module . '::Lexicon'} or @{$module . '::ISA'};
        # weird case: we never use'd it, but there it is!
    }

    DEBUG and warn " About to use $module ...\n";

    local $SIG{'__DIE__'};
    local $@;
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    eval "require $module"; # used to be "use $module", but no point in that.

    if($@) {
        DEBUG and warn "Error using $module \: $@\n";
        return $tried{$module} = 0;
    }
    else {
        DEBUG and warn " OK, $module is used\n";
        return $tried{$module} = 1;
    }
}

#--------------------------------------------------------------------------

sub _lex_refs {  # report the lexicon references for this handle's class
    # returns an arrayREF!
    no strict 'refs';
    no warnings 'once';
    my $class = ref($_[0]) || $_[0];
    DEBUG and warn "Lex refs lookup on $class\n";
    return $isa_scan{$class} if exists $isa_scan{$class};  # memoization!

    my @lex_refs;
    my $seen_r = ref($_[1]) ? $_[1] : {};

    if( defined( *{$class . '::Lexicon'}{'HASH'} )) {
        push @lex_refs, *{$class . '::Lexicon'}{'HASH'};
        DEBUG and warn '%' . $class . '::Lexicon contains ',
            scalar(keys %{$class . '::Lexicon'}), " entries\n";
    }

    # Implements depth(height?)-first recursive searching of superclasses.
    # In hindsight, I suppose I could have just used Class::ISA!
    foreach my $superclass (@{$class . '::ISA'}) {
        DEBUG and warn " Super-class search into $superclass\n";
        next if $seen_r->{$superclass}++;
        push @lex_refs, @{&_lex_refs($superclass, $seen_r)};  # call myself
    }

    $isa_scan{$class} = \@lex_refs; # save for next time
    return \@lex_refs;
}

sub clear_isa_scan { %isa_scan = (); return; } # end on a note of simplicity!

#--------------------------------------------------------------------------

sub _compile {
    # This big scary routine compiles an entry.
    # It returns either a coderef if there's brackety bits in this, or
    #  otherwise a ref to a scalar.

    my $string_to_compile = $_[1]; # There are taint issues using regex on @_ - perlbug 60378,27344

    # The while() regex is more expensive than this check on strings that don't need a compile.
    # this op causes a ~2% speed hit for strings that need compile and a 250% speed improvement
    # on strings that don't need compiling.
    return \"$string_to_compile" if($string_to_compile !~ m/[\[~\]]/ms); # return a string ref if chars [~] are not in the string

    my $target = ref($_[0]) || $_[0];

    my(@code);
    my(@c) = (''); # "chunks" -- scratch.
    my $call_count = 0;
    my $big_pile = '';
    {
        my $in_group = 0; # start out outside a group
        my($m, @params); # scratch

        while($string_to_compile =~  # Iterate over chunks.
            m/(
                [^\~\[\]]+  # non-~[] stuff (Capture everything else here)
                |
                ~.       # ~[, ~], ~~, ~other
                |
                \[          # [ presumably opening a group
                |
                \]          # ] presumably closing a group
                |
                ~           # terminal ~ ?
                |
                $
            )/xgs
        ) {
            DEBUG>2 and warn qq{  "$1"\n};

            if($1 eq '[' or $1 eq '') {       # "[" or end
                # Whether this is "[" or end, force processing of any
                #  preceding literal.
                if($in_group) {
                    if($1 eq '') {
                        $target->_die_pointing($string_to_compile, 'Unterminated bracket group');
                    }
                    else {
                        $target->_die_pointing($string_to_compile, 'You can\'t nest bracket groups');
                    }
                }
                else {
                    if ($1 eq '') {
                        DEBUG>2 and warn "   [end-string]\n";
                    }
                    else {
                        $in_group = 1;
                    }
                    die "How come \@c is empty?? in <$string_to_compile>" unless @c; # sanity
                    if(length $c[-1]) {
                        # Now actually processing the preceding literal
                        $big_pile .= $c[-1];
                        if($USE_LITERALS and (
                                (ord('A') == 65)
                                ? $c[-1] !~ m/[^\x20-\x7E]/s
                                # ASCII very safe chars
                                : $c[-1] !~ m/[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~\x07]/s
                                # EBCDIC very safe chars
                            )) {
                            # normal case -- all very safe chars
                            $c[-1] =~ s/'/\\'/g;
                            push @code, q{ '} . $c[-1] . "',\n";
                            $c[-1] = ''; # reuse this slot
                        }
                        else {
                            $c[-1] =~ s/\\\\/\\/g;
                            push @code, ' $c[' . $#c . "],\n";
                            push @c, ''; # new chunk
                        }
                    }
                    # else just ignore the empty string.
                }

            }
            elsif($1 eq ']') {  # "]"
                # close group -- go back in-band
                if($in_group) {
                    $in_group = 0;

                    DEBUG>2 and warn "   --Closing group [$c[-1]]\n";

                    # And now process the group...

                    if(!length($c[-1]) or $c[-1] =~ m/^\s+$/s) {
                        DEBUG>2 and warn "   -- (Ignoring)\n";
                        $c[-1] = ''; # reset out chink
                        next;
                    }

                    #$c[-1] =~ s/^\s+//s;
                    #$c[-1] =~ s/\s+$//s;
                    ($m,@params) = split(/,/, $c[-1], -1);  # was /\s*,\s*/

                    # A bit of a hack -- we've turned "~,"'s into DELs, so turn
                    #  'em into real commas here.
                    if (ord('A') == 65) { # ASCII, etc
                        foreach($m, @params) { tr/\x7F/,/ }
                    }
                    else {              # EBCDIC (1047, 0037, POSIX-BC)
                        # Thanks to Peter Prymmer for the EBCDIC handling
                        foreach($m, @params) { tr/\x07/,/ }
                    }

                    # Special-case handling of some method names:
                    if($m eq '_*' or $m =~ m/^_(-?\d+)$/s) {
                        # Treat [_1,...] as [,_1,...], etc.
                        unshift @params, $m;
                        $m = '';
                    }
                    elsif($m eq '*') {
                        $m = 'quant'; # "*" for "times": "4 cars" is 4 times "cars"
                    }
                    elsif($m eq '#') {
                        $m = 'numf';  # "#" for "number": [#,_1] for "the number _1"
                    }

                    # Most common case: a simple, legal-looking method name
                    if($m eq '') {
                        # 0-length method name means to just interpolate:
                        push @code, ' (';
                    }
                    elsif($m =~ /^\w+$/s
                        # exclude anything fancy, especially fully-qualified module names
                    ) {
                        push @code, ' $_[0]->' . $m . '(';
                    }
                    else {
                        # TODO: implement something?  or just too icky to consider?
                        $target->_die_pointing(
                            $string_to_compile,
                            "Can't use \"$m\" as a method name in bracket group",
                            2 + length($c[-1])
                        );
                    }

                    pop @c; # we don't need that chunk anymore
                    ++$call_count;

                    foreach my $p (@params) {
                        if($p eq '_*') {
                            # Meaning: all parameters except $_[0]
                            $code[-1] .= ' @_[1 .. $#_], ';
                            # and yes, that does the right thing for all @_ < 3
                        }
                        elsif($p =~ m/^_(-?\d+)$/s) {
                            # _3 meaning $_[3]
                            $code[-1] .= '$_[' . (0 + $1) . '], ';
                        }
                        elsif($USE_LITERALS and (
                                (ord('A') == 65)
                                ? $p !~ m/[^\x20-\x7E]/s
                                # ASCII very safe chars
                                : $p !~ m/[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~\x07]/s
                                # EBCDIC very safe chars
                            )) {
                            # Normal case: a literal containing only safe characters
                            $p =~ s/'/\\'/g;
                            $code[-1] .= q{'} . $p . q{', };
                        }
                        else {
                            # Stow it on the chunk-stack, and just refer to that.
                            push @c, $p;
                            push @code, ' $c[' . $#c . '], ';
                        }
                    }
                    $code[-1] .= "),\n";

                    push @c, '';
                }
                else {
                    $target->_die_pointing($string_to_compile, q{Unbalanced ']'});
                }

            }
            elsif(substr($1,0,1) ne '~') {
                # it's stuff not containing "~" or "[" or "]"
                # i.e., a literal blob
                my $text = $1;
                $text =~ s/\\/\\\\/g;
                $c[-1] .= $text;

            }
            elsif($1 eq '~~') { # "~~"
                $c[-1] .= '~';

            }
            elsif($1 eq '~[') { # "~["
                $c[-1] .= '[';

            }
            elsif($1 eq '~]') { # "~]"
                $c[-1] .= ']';

            }
            elsif($1 eq '~,') { # "~,"
                if($in_group) {
                    # This is a hack, based on the assumption that no-one will actually
                    # want a DEL inside a bracket group.  Let's hope that's it's true.
                    if (ord('A') == 65) { # ASCII etc
                        $c[-1] .= "\x7F";
                    }
                    else {              # EBCDIC (cp 1047, 0037, POSIX-BC)
                        $c[-1] .= "\x07";
                    }
                }
                else {
                    $c[-1] .= '~,';
                }

            }
            elsif($1 eq '~') { # possible only at string-end, it seems.
                $c[-1] .= '~';

            }
            else {
                # It's a "~X" where X is not a special character.
                # Consider it a literal ~ and X.
                my $text = $1;
                $text =~ s/\\/\\\\/g;
                $c[-1] .= $text;
            }
        }
    }

    if($call_count) {
        undef $big_pile; # Well, nevermind that.
    }
    else {
        # It's all literals!  Ahwell, that can happen.
        # So don't bother with the eval.  Return a SCALAR reference.
        return \$big_pile;
    }

    die q{Last chunk isn't null??} if @c and length $c[-1]; # sanity
    DEBUG and warn scalar(@c), " chunks under closure\n";
    if(@code == 0) { # not possible?
        DEBUG and warn "Empty code\n";
        return \'';
    }
    elsif(@code > 1) { # most cases, presumably!
        unshift @code, "join '',\n";
    }
    unshift @code, "use strict; sub {\n";
    push @code, "}\n";

    DEBUG and warn @code;
    my $sub = eval(join '', @code);
    die "$@ while evalling" . join('', @code) if $@; # Should be impossible.
    return $sub;
}

#--------------------------------------------------------------------------

sub _die_pointing {
    # This is used by _compile to throw a fatal error
    my $target = shift; # class name
    # ...leaving $_[0] the error-causing text, and $_[1] the error message

    my $i = index($_[0], "\n");

    my $pointy;
    my $pos = pos($_[0]) - (defined($_[2]) ? $_[2] : 0) - 1;
    if($pos < 1) {
        $pointy = "^=== near there\n";
    }
    else { # we need to space over
        my $first_tab = index($_[0], "\t");
        if($pos > 2 and ( -1 == $first_tab  or  $first_tab > pos($_[0]))) {
            # No tabs, or the first tab is harmlessly after where we will point to,
            # AND we're far enough from the margin that we can draw a proper arrow.
            $pointy = ('=' x $pos) . "^ near there\n";
        }
        else {
            # tabs screw everything up!
            $pointy = substr($_[0],0,$pos);
            $pointy =~ tr/\t //cd;
            # make everything into whitespace, but preserving tabs
            $pointy .= "^=== near there\n";
        }
    }

    my $errmsg = "$_[1], in\:\n$_[0]";

    if($i == -1) {
        # No newline.
        $errmsg .= "\n" . $pointy;
    }
    elsif($i == (length($_[0]) - 1)  ) {
        # Already has a newline at end.
        $errmsg .= $pointy;
    }
    else {
        # don't bother with the pointy bit, I guess.
    }
    Carp::croak( "$errmsg via $target, as used" );
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/perl/5.20.2/Locale/Maketext.pod                                                           0100644 0000000 0000000 00000140400 12744441327 016342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
# Time-stamp: "2004-01-11 18:35:34 AST"

=head1 NAME

Locale::Maketext - framework for localization

=head1 SYNOPSIS

  package MyProgram;
  use strict;
  use MyProgram::L10N;
   # ...which inherits from Locale::Maketext
  my $lh = MyProgram::L10N->get_handle() || die "What language?";
  ...
  # And then any messages your program emits, like:
  warn $lh->maketext( "Can't open file [_1]: [_2]\n", $f, $! );
  ...

=head1 DESCRIPTION

It is a common feature of applications (whether run directly,
or via the Web) for them to be "localized" -- i.e., for them
to a present an English interface to an English-speaker, a German
interface to a German-speaker, and so on for all languages it's
programmed with.  Locale::Maketext
is a framework for software localization; it provides you with the
tools for organizing and accessing the bits of text and text-processing
code that you need for producing localized applications.

In order to make sense of Maketext and how all its
components fit together, you should probably
go read L<Locale::Maketext::TPJ13|Locale::Maketext::TPJ13>, and
I<then> read the following documentation.

You may also want to read over the source for C<File::Findgrep>
and its constituent modules -- they are a complete (if small)
example application that uses Maketext.

=head1 QUICK OVERVIEW

The basic design of Locale::Maketext is object-oriented, and
Locale::Maketext is an abstract base class, from which you
derive a "project class".
The project class (with a name like "TkBocciBall::Localize",
which you then use in your module) is in turn the base class
for all the "language classes" for your project
(with names "TkBocciBall::Localize::it", 
"TkBocciBall::Localize::en",
"TkBocciBall::Localize::fr", etc.).

A language class is
a class containing a lexicon of phrases as class data,
and possibly also some methods that are of use in interpreting
phrases in the lexicon, or otherwise dealing with text in that
language.

An object belonging to a language class is called a "language
handle"; it's typically a flyweight object.

The normal course of action is to call:

  use TkBocciBall::Localize;  # the localization project class
  $lh = TkBocciBall::Localize->get_handle();
   # Depending on the user's locale, etc., this will
   # make a language handle from among the classes available,
   # and any defaults that you declare.
  die "Couldn't make a language handle??" unless $lh;

From then on, you use the C<maketext> function to access
entries in whatever lexicon(s) belong to the language handle
you got.  So, this:

  print $lh->maketext("You won!"), "\n";

...emits the right text for this language.  If the object
in C<$lh> belongs to class "TkBocciBall::Localize::fr" and
%TkBocciBall::Localize::fr::Lexicon contains C<("You won!"
=E<gt> "Tu as gagnE<eacute>!")>, then the above
code happily tells the user "Tu as gagnE<eacute>!".

=head1 METHODS

Locale::Maketext offers a variety of methods, which fall
into three categories:

=over

=item *

Methods to do with constructing language handles.

=item *

C<maketext> and other methods to do with accessing %Lexicon data
for a given language handle.

=item *

Methods that you may find it handy to use, from routines of
yours that you put in %Lexicon entries.

=back

These are covered in the following section.

=head2 Construction Methods

These are to do with constructing a language handle:

=over

=item *

$lh = YourProjClass->get_handle( ...langtags... ) || die "lg-handle?";

This tries loading classes based on the language-tags you give (like
C<("en-US", "sk", "kon", "es-MX", "ja", "i-klingon")>, and for the first class
that succeeds, returns YourProjClass::I<language>->new().

If it runs thru the entire given list of language-tags, and finds no classes
for those exact terms, it then tries "superordinate" language classes.
So if no "en-US" class (i.e., YourProjClass::en_us)
was found, nor classes for anything else in that list, we then try
its superordinate, "en" (i.e., YourProjClass::en), and so on thru 
the other language-tags in the given list: "es".
(The other language-tags in our example list: 
happen to have no superordinates.)

If none of those language-tags leads to loadable classes, we then
try classes derived from YourProjClass->fallback_languages() and
then if nothing comes of that, we use classes named by
YourProjClass->fallback_language_classes().  Then in the (probably
quite unlikely) event that that fails, we just return undef.

=item *

$lh = YourProjClass->get_handleB<()> || die "lg-handle?";

When C<get_handle> is called with an empty parameter list, magic happens:

If C<get_handle> senses that it's running in program that was
invoked as a CGI, then it tries to get language-tags out of the
environment variable "HTTP_ACCEPT_LANGUAGE", and it pretends that
those were the languages passed as parameters to C<get_handle>.

Otherwise (i.e., if not a CGI), this tries various OS-specific ways
to get the language-tags for the current locale/language, and then
pretends that those were the value(s) passed to C<get_handle>.

Currently this OS-specific stuff consists of looking in the environment
variables "LANG" and "LANGUAGE"; and on MSWin machines (where those
variables are typically unused), this also tries using
the module Win32::Locale to get a language-tag for whatever language/locale
is currently selected in the "Regional Settings" (or "International"?)
Control Panel.  I welcome further
suggestions for making this do the Right Thing under other operating
systems that support localization.

If you're using localization in an application that keeps a configuration
file, you might consider something like this in your project class:

  sub get_handle_via_config {
    my $class = $_[0];
    my $chosen_language = $Config_settings{'language'};
    my $lh;
    if($chosen_language) {
      $lh = $class->get_handle($chosen_language)
       || die "No language handle for \"$chosen_language\""
            . " or the like";
    } else {
      # Config file missing, maybe?
      $lh = $class->get_handle()
       || die "Can't get a language handle";
    }
    return $lh;
  }

=item *

$lh = YourProjClass::langname->new();

This constructs a language handle.  You usually B<don't> call this
directly, but instead let C<get_handle> find a language class to C<use>
and to then call ->new on.

=item *

$lh->init();

This is called by ->new to initialize newly-constructed language handles.
If you define an init method in your class, remember that it's usually
considered a good idea to call $lh->SUPER::init in it (presumably at the
beginning), so that all classes get a chance to initialize a new object
however they see fit.

=item *

YourProjClass->fallback_languages()

C<get_handle> appends the return value of this to the end of
whatever list of languages you pass C<get_handle>.  Unless
you override this method, your project class
will inherit Locale::Maketext's C<fallback_languages>, which
currently returns C<('i-default', 'en', 'en-US')>.
("i-default" is defined in RFC 2277).

This method (by having it return the name
of a language-tag that has an existing language class)
can be used for making sure that
C<get_handle> will always manage to construct a language
handle (assuming your language classes are in an appropriate
@INC directory).  Or you can use the next method:

=item *

YourProjClass->fallback_language_classes()

C<get_handle> appends the return value of this to the end
of the list of classes it will try using.  Unless
you override this method, your project class
will inherit Locale::Maketext's C<fallback_language_classes>,
which currently returns an empty list, C<()>.
By setting this to some value (namely, the name of a loadable
language class), you can be sure that
C<get_handle> will always manage to construct a language
handle.

=back

=head2 The "maketext" Method

This is the most important method in Locale::Maketext:

    $text = $lh->maketext(I<key>, ...parameters for this phrase...);

This looks in the %Lexicon of the language handle
$lh and all its superclasses, looking
for an entry whose key is the string I<key>.  Assuming such
an entry is found, various things then happen, depending on the
value found:

If the value is a scalarref, the scalar is dereferenced and returned
(and any parameters are ignored).

If the value is a coderef, we return &$value($lh, ...parameters...).

If the value is a string that I<doesn't> look like it's in Bracket Notation,
we return it (after replacing it with a scalarref, in its %Lexicon).

If the value I<does> look like it's in Bracket Notation, then we compile
it into a sub, replace the string in the %Lexicon with the new coderef,
and then we return &$new_sub($lh, ...parameters...).

Bracket Notation is discussed in a later section.  Note
that trying to compile a string into Bracket Notation can throw
an exception if the string is not syntactically valid (say, by not
balancing brackets right.)

Also, calling &$coderef($lh, ...parameters...) can throw any sort of
exception (if, say, code in that sub tries to divide by zero).  But
a very common exception occurs when you have Bracket
Notation text that says to call a method "foo", but there is no such
method.  (E.g., "You have [quaB<tn>,_1,ball]." will throw an exception
on trying to call $lh->quaB<tn>($_[1],'ball') -- you presumably meant
"quant".)  C<maketext> catches these exceptions, but only to make the
error message more readable, at which point it rethrows the exception.

An exception I<may> be thrown if I<key> is not found in any
of $lh's %Lexicon hashes.  What happens if a key is not found,
is discussed in a later section, "Controlling Lookup Failure".

Note that you might find it useful in some cases to override
the C<maketext> method with an "after method", if you want to
translate encodings, or even scripts:

    package YrProj::zh_cn; # Chinese with PRC-style glyphs
    use base ('YrProj::zh_tw');  # Taiwan-style
    sub maketext {
      my $self = shift(@_);
      my $value = $self->maketext(@_);
      return Chineeze::taiwan2mainland($value);
    }

Or you may want to override it with something that traps
any exceptions, if that's critical to your program:

  sub maketext {
    my($lh, @stuff) = @_;
    my $out;
    eval { $out = $lh->SUPER::maketext(@stuff) };
    return $out unless $@;
    ...otherwise deal with the exception...
  }

Other than those two situations, I don't imagine that
it's useful to override the C<maketext> method.  (If
you run into a situation where it is useful, I'd be
interested in hearing about it.)

=over

=item $lh->fail_with I<or> $lh->fail_with(I<PARAM>)

=item $lh->failure_handler_auto

These two methods are discussed in the section "Controlling
Lookup Failure".

=back

=head2 Utility Methods

These are methods that you may find it handy to use, generally
from %Lexicon routines of yours (whether expressed as
Bracket Notation or not).

=over

=item $language->quant($number, $singular)

=item $language->quant($number, $singular, $plural)

=item $language->quant($number, $singular, $plural, $negative)

This is generally meant to be called from inside Bracket Notation
(which is discussed later), as in 

     "Your search matched [quant,_1,document]!"

It's for I<quantifying> a noun (i.e., saying how much of it there is,
while giving the correct form of it).  The behavior of this method is
handy for English and a few other Western European languages, and you
should override it for languages where it's not suitable.  You can feel
free to read the source, but the current implementation is basically
as this pseudocode describes:

     if $number is 0 and there's a $negative,
        return $negative;
     elsif $number is 1,
        return "1 $singular";
     elsif there's a $plural,
        return "$number $plural";
     else
        return "$number " . $singular . "s";
     #
     # ...except that we actually call numf to
     #  stringify $number before returning it.

So for English (with Bracket Notation)
C<"...[quant,_1,file]..."> is fine (for 0 it returns "0 files",
for 1 it returns "1 file", and for more it returns "2 files", etc.)

But for "directory", you'd want C<"[quant,_1,directory,directories]">
so that our elementary C<quant> method doesn't think that the
plural of "directory" is "directorys".  And you might find that the
output may sound better if you specify a negative form, as in:

     "[quant,_1,file,files,No files] matched your query.\n"

Remember to keep in mind verb agreement (or adjectives too, in
other languages), as in:

     "[quant,_1,document] were matched.\n"

Because if _1 is one, you get "1 document B<were> matched".
An acceptable hack here is to do something like this:

     "[quant,_1,document was, documents were] matched.\n"

=item $language->numf($number)

This returns the given number formatted nicely according to
this language's conventions.  Maketext's default method is
mostly to just take the normal string form of the number
(applying sprintf "%G" for only very large numbers), and then
to add commas as necessary.  (Except that
we apply C<tr/,./.,/> if $language->{'numf_comma'} is true;
that's a bit of a hack that's useful for languages that express
two million as "2.000.000" and not as "2,000,000").

If you want anything fancier, consider overriding this with something
that uses L<Number::Format|Number::Format>, or does something else
entirely.

Note that numf is called by quant for stringifying all quantifying
numbers.

=item $language->numerate($number, $singular, $plural, $negative)

This returns the given noun form which is appropriate for the quantity
C<$number> according to this language's conventions.  C<numerate> is
used internally by C<quant> to quantify nouns.  Use it directly --
usually from bracket notation -- to avoid C<quant>'s implicit call to
C<numf> and output of a numeric quantity.

=item $language->sprintf($format, @items)

This is just a wrapper around Perl's normal C<sprintf> function.
It's provided so that you can use "sprintf" in Bracket Notation:

     "Couldn't access datanode [sprintf,%10x=~[%s~],_1,_2]!\n"

returning...

     Couldn't access datanode      Stuff=[thangamabob]!

=item $language->language_tag()

Currently this just takes the last bit of C<ref($language)>, turns
underscores to dashes, and returns it.  So if $language is
an object of class Hee::HOO::Haw::en_us, $language->language_tag()
returns "en-us".  (Yes, the usual representation for that language
tag is "en-US", but case is I<never> considered meaningful in
language-tag comparison.)

You may override this as you like; Maketext doesn't use it for
anything.

=item $language->encoding()

Currently this isn't used for anything, but it's provided
(with default value of
C<(ref($language) && $language-E<gt>{'encoding'})) or "iso-8859-1">
) as a sort of suggestion that it may be useful/necessary to
associate encodings with your language handles (whether on a
per-class or even per-handle basis.)

=back

=head2 Language Handle Attributes and Internals

A language handle is a flyweight object -- i.e., it doesn't (necessarily)
carry any data of interest, other than just being a member of
whatever class it belongs to.

A language handle is implemented as a blessed hash.  Subclasses of yours
can store whatever data you want in the hash.  Currently the only hash
entry used by any crucial Maketext method is "fail", so feel free to
use anything else as you like.

B<Remember: Don't be afraid to read the Maketext source if there's
any point on which this documentation is unclear.>  This documentation
is vastly longer than the module source itself.

=head1 LANGUAGE CLASS HIERARCHIES

These are Locale::Maketext's assumptions about the class
hierarchy formed by all your language classes:

=over

=item *

You must have a project base class, which you load, and
which you then use as the first argument in
the call to YourProjClass->get_handle(...).  It should derive
(whether directly or indirectly) from Locale::Maketext.
It B<doesn't matter> how you name this class, although assuming this
is the localization component of your Super Mega Program,
good names for your project class might be
SuperMegaProgram::Localization, SuperMegaProgram::L10N,
SuperMegaProgram::I18N, SuperMegaProgram::International,
or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.

=item *

Language classes are what YourProjClass->get_handle will try to load.
It will look for them by taking each language-tag (B<skipping> it
if it doesn't look like a language-tag or locale-tag!), turning it to
all lowercase, turning dashes to underscores, and appending it
to YourProjClass . "::".  So this:

  $lh = YourProjClass->get_handle(
    'en-US', 'fr', 'kon', 'i-klingon', 'i-klingon-romanized'
  );

will try loading the classes 
YourProjClass::en_us (note lowercase!), YourProjClass::fr, 
YourProjClass::kon,
YourProjClass::i_klingon
and YourProjClass::i_klingon_romanized.  (And it'll stop at the
first one that actually loads.)

=item *

I assume that each language class derives (directly or indirectly)
from your project class, and also defines its @ISA, its %Lexicon,
or both.  But I anticipate no dire consequences if these assumptions
do not hold.

=item *

Language classes may derive from other language classes (although they
should have "use I<Thatclassname>" or "use base qw(I<...classes...>)").
They may derive from the project
class.  They may derive from some other class altogether.  Or via
multiple inheritance, it may derive from any mixture of these.

=item *

I foresee no problems with having multiple inheritance in
your hierarchy of language classes.  (As usual, however, Perl will
complain bitterly if you have a cycle in the hierarchy: i.e., if
any class is its own ancestor.)

=back

=head1 ENTRIES IN EACH LEXICON

A typical %Lexicon entry is meant to signify a phrase,
taking some number (0 or more) of parameters.  An entry
is meant to be accessed by via
a string I<key> in $lh->maketext(I<key>, ...parameters...),
which should return a string that is generally meant for
be used for "output" to the user -- regardless of whether
this actually means printing to STDOUT, writing to a file,
or putting into a GUI widget.

While the key must be a string value (since that's a basic
restriction that Perl places on hash keys), the value in
the lexicon can currently be of several types:
a defined scalar, scalarref, or coderef.  The use of these is
explained above, in the section 'The "maketext" Method', and
Bracket Notation for strings is discussed in the next section.

While you can use arbitrary unique IDs for lexicon keys
(like "_min_larger_max_error"), it is often
useful for if an entry's key is itself a valid value, like
this example error message:

  "Minimum ([_1]) is larger than maximum ([_2])!\n",

Compare this code that uses an arbitrary ID...

  die $lh->maketext( "_min_larger_max_error", $min, $max )
   if $min > $max;

...to this code that uses a key-as-value:

  die $lh->maketext(
   "Minimum ([_1]) is larger than maximum ([_2])!\n",
   $min, $max
  ) if $min > $max;

The second is, in short, more readable.  In particular, it's obvious
that the number of parameters you're feeding to that phrase (two) is
the number of parameters that it I<wants> to be fed.  (Since you see
_1 and a _2 being used in the key there.)

Also, once a project is otherwise
complete and you start to localize it, you can scrape together
all the various keys you use, and pass it to a translator; and then
the translator's work will go faster if what he's presented is this:

 "Minimum ([_1]) is larger than maximum ([_2])!\n",
  => "",   # fill in something here, Jacques!

rather than this more cryptic mess:

 "_min_larger_max_error"
  => "",   # fill in something here, Jacques

I think that keys as lexicon values makes the completed lexicon
entries more readable:

 "Minimum ([_1]) is larger than maximum ([_2])!\n",
  => "Le minimum ([_1]) est plus grand que le maximum ([_2])!\n",

Also, having valid values as keys becomes very useful if you set
up an _AUTO lexicon.  _AUTO lexicons are discussed in a later
section.

I almost always use keys that are themselves
valid lexicon values.  One notable exception is when the value is
quite long.  For example, to get the screenful of data that
a command-line program might return when given an unknown switch,
I often just use a brief, self-explanatory key such as "_USAGE_MESSAGE".  At that point I then go
and immediately to define that lexicon entry in the
ProjectClass::L10N::en lexicon (since English is always my "project
language"):

  '_USAGE_MESSAGE' => <<'EOSTUFF',
  ...long long message...
  EOSTUFF

and then I can use it as:

  getopt('oDI', \%opts) or die $lh->maketext('_USAGE_MESSAGE');

Incidentally,
note that each class's C<%Lexicon> inherits-and-extends
the lexicons in its superclasses.  This is not because these are
special hashes I<per se>, but because you access them via the
C<maketext> method, which looks for entries across all the
C<%Lexicon> hashes in a language class I<and> all its ancestor classes.
(This is because the idea of "class data" isn't directly implemented
in Perl, but is instead left to individual class-systems to implement
as they see fit..)

Note that you may have things stored in a lexicon
besides just phrases for output:  for example, if your program
takes input from the keyboard, asking a "(Y/N)" question,
you probably need to know what the equivalent of "Y[es]/N[o]" is
in whatever language.  You probably also need to know what
the equivalents of the answers "y" and "n" are.  You can
store that information in the lexicon (say, under the keys
"~answer_y" and "~answer_n", and the long forms as
"~answer_yes" and "~answer_no", where "~" is just an ad-hoc
character meant to indicate to programmers/translators that
these are not phrases for output).

Or instead of storing this in the language class's lexicon,
you can (and, in some cases, really should) represent the same bit
of knowledge as code in a method in the language class.  (That
leaves a tidy distinction between the lexicon as the things we
know how to I<say>, and the rest of the things in the lexicon class
as things that we know how to I<do>.)  Consider
this example of a processor for responses to French "oui/non"
questions:

  sub y_or_n {
    return undef unless defined $_[1] and length $_[1];
    my $answer = lc $_[1];  # smash case
    return 1 if $answer eq 'o' or $answer eq 'oui';
    return 0 if $answer eq 'n' or $answer eq 'non';
    return undef;
  }

...which you'd then call in a construct like this:

  my $response;
  until(defined $response) {
    print $lh->maketext("Open the pod bay door (y/n)? ");
    $response = $lh->y_or_n( get_input_from_keyboard_somehow() );
  }
  if($response) { $pod_bay_door->open()         }
  else          { $pod_bay_door->leave_closed() }

Other data worth storing in a lexicon might be things like
filenames for language-targetted resources:

  ...
  "_main_splash_png"
    => "/styles/en_us/main_splash.png",
  "_main_splash_imagemap"
    => "/styles/en_us/main_splash.incl",
  "_general_graphics_path"
    => "/styles/en_us/",
  "_alert_sound"
    => "/styles/en_us/hey_there.wav",
  "_forward_icon"
   => "left_arrow.png",
  "_backward_icon"
   => "right_arrow.png",
  # In some other languages, left equals
  #  BACKwards, and right is FOREwards.
  ...

You might want to do the same thing for expressing key bindings
or the like (since hardwiring "q" as the binding for the function
that quits a screen/menu/program is useful only if your language
happens to associate "q" with "quit"!)

=head1 BRACKET NOTATION

Bracket Notation is a crucial feature of Locale::Maketext.  I mean
Bracket Notation to provide a replacement for the use of sprintf formatting.
Everything you do with Bracket Notation could be done with a sub block,
but bracket notation is meant to be much more concise.

Bracket Notation is a like a miniature "template" system (in the sense
of L<Text::Template|Text::Template>, not in the sense of C++ templates),
where normal text is passed thru basically as is, but text in special
regions is specially interpreted.  In Bracket Notation, you use square brackets ("[...]"),
not curly braces ("{...}") to note sections that are specially interpreted.

For example, here all the areas that are taken literally are underlined with
a "^", and all the in-bracket special regions are underlined with an X:

  "Minimum ([_1]) is larger than maximum ([_2])!\n",
   ^^^^^^^^^ XX ^^^^^^^^^^^^^^^^^^^^^^^^^^ XX ^^^^

When that string is compiled from bracket notation into a real Perl sub,
it's basically turned into:

  sub {
    my $lh = $_[0];
    my @params = @_;
    return join '',
      "Minimum (",
      ...some code here...
      ") is larger than maximum (",
      ...some code here...
      ")!\n",
  }
  # to be called by $lh->maketext(KEY, params...)

In other words, text outside bracket groups is turned into string
literals.  Text in brackets is rather more complex, and currently follows
these rules:

=over

=item *

Bracket groups that are empty, or which consist only of whitespace,
are ignored.  (Examples: "[]", "[    ]", or a [ and a ] with returns
and/or tabs and/or spaces between them.

Otherwise, each group is taken to be a comma-separated group of items,
and each item is interpreted as follows:

=item *

An item that is "_I<digits>" or "_-I<digits>" is interpreted as
$_[I<value>].  I.e., "_1" becomes with $_[1], and "_-3" is interpreted
as $_[-3] (in which case @_ should have at least three elements in it).
Note that $_[0] is the language handle, and is typically not named
directly.

=item *

An item "_*" is interpreted to mean "all of @_ except $_[0]".
I.e., C<@_[1..$#_]>.  Note that this is an empty list in the case
of calls like $lh->maketext(I<key>) where there are no
parameters (except $_[0], the language handle).

=item *

Otherwise, each item is interpreted as a string literal.

=back

The group as a whole is interpreted as follows:

=over

=item *

If the first item in a bracket group looks like a method name,
then that group is interpreted like this:

  $lh->that_method_name(
    ...rest of items in this group...
  ),

=item *

If the first item in a bracket group is "*", it's taken as shorthand
for the so commonly called "quant" method.  Similarly, if the first
item in a bracket group is "#", it's taken to be shorthand for
"numf".

=item *

If the first item in a bracket group is the empty-string, or "_*"
or "_I<digits>" or "_-I<digits>", then that group is interpreted
as just the interpolation of all its items:

  join('',
    ...rest of items in this group...
  ),

Examples:  "[_1]" and "[,_1]", which are synonymous; and
"C<[,ID-(,_4,-,_2,)]>", which compiles as
C<join "", "ID-(", $_[4], "-", $_[2], ")">.

=item *

Otherwise this bracket group is invalid.  For example, in the group
"[!@#,whatever]", the first item C<"!@#"> is neither the empty-string,
"_I<number>", "_-I<number>", "_*", nor a valid method name; and so
Locale::Maketext will throw an exception of you try compiling an
expression containing this bracket group.

=back

Note, incidentally, that items in each group are comma-separated,
not C</\s*,\s*/>-separated.  That is, you might expect that this
bracket group:

  "Hoohah [foo, _1 , bar ,baz]!"

would compile to this:

  sub {
    my $lh = $_[0];
    return join '',
      "Hoohah ",
      $lh->foo( $_[1], "bar", "baz"),
      "!",
  }

But it actually compiles as this:

  sub {
    my $lh = $_[0];
    return join '',
      "Hoohah ",
      $lh->foo(" _1 ", " bar ", "baz"),  # note the <space> in " bar "
      "!",
  }

In the notation discussed so far, the characters "[" and "]" are given
special meaning, for opening and closing bracket groups, and "," has
a special meaning inside bracket groups, where it separates items in the
group.  This begs the question of how you'd express a literal "[" or
"]" in a Bracket Notation string, and how you'd express a literal
comma inside a bracket group.  For this purpose I've adopted "~" (tilde)
as an escape character:  "~[" means a literal '[' character anywhere
in Bracket Notation (i.e., regardless of whether you're in a bracket
group or not), and ditto for "~]" meaning a literal ']', and "~," meaning
a literal comma.  (Altho "," means a literal comma outside of
bracket groups -- it's only inside bracket groups that commas are special.)

And on the off chance you need a literal tilde in a bracket expression,
you get it with "~~".

Currently, an unescaped "~" before a character
other than a bracket or a comma is taken to mean just a "~" and that
character.  I.e., "~X" means the same as "~~X" -- i.e., one literal tilde,
and then one literal "X".  However, by using "~X", you are assuming that
no future version of Maketext will use "~X" as a magic escape sequence.
In practice this is not a great problem, since first off you can just
write "~~X" and not worry about it; second off, I doubt I'll add lots
of new magic characters to bracket notation; and third off, you
aren't likely to want literal "~" characters in your messages anyway,
since it's not a character with wide use in natural language text.

Brackets must be balanced -- every openbracket must have
one matching closebracket, and vice versa.  So these are all B<invalid>:

  "I ate [quant,_1,rhubarb pie."
  "I ate [quant,_1,rhubarb pie[."
  "I ate quant,_1,rhubarb pie]."
  "I ate quant,_1,rhubarb pie[."

Currently, bracket groups do not nest.  That is, you B<cannot> say:

  "Foo [bar,baz,[quux,quuux]]\n";

If you need a notation that's that powerful, use normal Perl:

  %Lexicon = (
    ...
    "some_key" => sub {
      my $lh = $_[0];
      join '',
        "Foo ",
        $lh->bar('baz', $lh->quux('quuux')),
        "\n",
    },
    ...
  );

Or write the "bar" method so you don't need to pass it the
output from calling quux.

I do not anticipate that you will need (or particularly want)
to nest bracket groups, but you are welcome to email me with
convincing (real-life) arguments to the contrary.

=head1 AUTO LEXICONS

If maketext goes to look in an individual %Lexicon for an entry
for I<key> (where I<key> does not start with an underscore), and
sees none, B<but does see> an entry of "_AUTO" => I<some_true_value>,
then we actually define $Lexicon{I<key>} = I<key> right then and there,
and then use that value as if it had been there all
along.  This happens before we even look in any superclass %Lexicons!

(This is meant to be somewhat like the AUTOLOAD mechanism in
Perl's function call system -- or, looked at another way,
like the L<AutoLoader|AutoLoader> module.)

I can picture all sorts of circumstances where you just
do not want lookup to be able to fail (since failing
normally means that maketext throws a C<die>, although
see the next section for greater control over that).  But
here's one circumstance where _AUTO lexicons are meant to
be I<especially> useful:

As you're writing an application, you decide as you go what messages
you need to emit.  Normally you'd go to write this:

  if(-e $filename) {
    go_process_file($filename)
  } else {
    print qq{Couldn't find file "$filename"!\n};
  }

but since you anticipate localizing this, you write:

  use ThisProject::I18N;
  my $lh = ThisProject::I18N->get_handle();
   # For the moment, assume that things are set up so
   # that we load class ThisProject::I18N::en
   # and that that's the class that $lh belongs to.
  ...
  if(-e $filename) {
    go_process_file($filename)
  } else {
    print $lh->maketext(
      qq{Couldn't find file "[_1]"!\n}, $filename
    );
  }

Now, right after you've just written the above lines, you'd
normally have to go open the file 
ThisProject/I18N/en.pm, and immediately add an entry:

  "Couldn't find file \"[_1]\"!\n"
  => "Couldn't find file \"[_1]\"!\n",

But I consider that somewhat of a distraction from the work
of getting the main code working -- to say nothing of the fact
that I often have to play with the program a few times before
I can decide exactly what wording I want in the messages (which
in this case would require me to go changing three lines of code:
the call to maketext with that key, and then the two lines in
ThisProject/I18N/en.pm).

However, if you set "_AUTO => 1" in the %Lexicon in,
ThisProject/I18N/en.pm (assuming that English (en) is
the language that all your programmers will be using for this
project's internal message keys), then you don't ever have to
go adding lines like this

  "Couldn't find file \"[_1]\"!\n"
  => "Couldn't find file \"[_1]\"!\n",

to ThisProject/I18N/en.pm, because if _AUTO is true there,
then just looking for an entry with the key "Couldn't find
file \"[_1]\"!\n" in that lexicon will cause it to be added,
with that value!

Note that the reason that keys that start with "_"
are immune to _AUTO isn't anything generally magical about
the underscore character -- I just wanted a way to have most
lexicon keys be autoable, except for possibly a few, and I
arbitrarily decided to use a leading underscore as a signal
to distinguish those few.

=head1 READONLY LEXICONS

If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.

For example a L<GDBM_File> GDBM_READER tied hash will die with something like:

   gdbm store returned -1, errno 2, key "..." at ...

All you need to do is turn on caching outside of the lexicon hash itself like so:

   sub init {
       my ($lh) = @_;
       ...
       $lh->{'use_external_lex_cache'} = 1;
       ...
   }

And then instead of storing the compiled value in the lexicon hash it will store it in $lh->{'_external_lex_cache'}

=head1 CONTROLLING LOOKUP FAILURE

If you call $lh->maketext(I<key>, ...parameters...),
and there's no entry I<key> in $lh's class's %Lexicon, nor
in the superclass %Lexicon hash, I<and> if we can't auto-make
I<key> (because either it starts with a "_", or because none
of its lexicons have C<_AUTO =E<gt> 1,>), then we have
failed to find a normal way to maketext I<key>.  What then
happens in these failure conditions, depends on the $lh object's
"fail" attribute.

If the language handle has no "fail" attribute, maketext
will simply throw an exception (i.e., it calls C<die>, mentioning
the I<key> whose lookup failed, and naming the line number where
the calling $lh->maketext(I<key>,...) was.

If the language handle has a "fail" attribute whose value is a
coderef, then $lh->maketext(I<key>,...params...) gives up and calls:

  return $that_subref->($lh, $key, @params);

Otherwise, the "fail" attribute's value should be a string denoting
a method name, so that $lh->maketext(I<key>,...params...) can
give up with:

  return $lh->$that_method_name($phrase, @params);

The "fail" attribute can be accessed with the C<fail_with> method:

  # Set to a coderef:
  $lh->fail_with( \&failure_handler );

  # Set to a method name:
  $lh->fail_with( 'failure_method' );

  # Set to nothing (i.e., so failure throws a plain exception)
  $lh->fail_with( undef );

  # Get the current value
  $handler = $lh->fail_with();

Now, as to what you may want to do with these handlers:  Maybe you'd
want to log what key failed for what class, and then die.  Maybe
you don't like C<die> and instead you want to send the error message
to STDOUT (or wherever) and then merely C<exit()>.

Or maybe you don't want to C<die> at all!  Maybe you could use a
handler like this:

  # Make all lookups fall back onto an English value,
  #  but only after we log it for later fingerpointing.
  my $lh_backup = ThisProject->get_handle('en');
  open(LEX_FAIL_LOG, ">>wherever/lex.log") || die "GNAARGH $!";
  sub lex_fail {
    my($failing_lh, $key, $params) = @_;
    print LEX_FAIL_LOG scalar(localtime), "\t",
       ref($failing_lh), "\t", $key, "\n";
    return $lh_backup->maketext($key,@params);
  }

Some users have expressed that they think this whole mechanism of
having a "fail" attribute at all, seems a rather pointless complication.
But I want Locale::Maketext to be usable for software projects of I<any>
scale and type; and different software projects have different ideas
of what the right thing is to do in failure conditions.  I could simply
say that failure always throws an exception, and that if you want to be
careful, you'll just have to wrap every call to $lh->maketext in an
S<eval { }>.  However, I want programmers to reserve the right (via
the "fail" attribute) to treat lookup failure as something other than
an exception of the same level of severity as a config file being
unreadable, or some essential resource being inaccessible.

One possibly useful value for the "fail" attribute is the method name
"failure_handler_auto".  This is a method defined in the class
Locale::Maketext itself.  You set it with:

  $lh->fail_with('failure_handler_auto');

Then when you call $lh->maketext(I<key>, ...parameters...) and
there's no I<key> in any of those lexicons, maketext gives up with

  return $lh->failure_handler_auto($key, @params);

But failure_handler_auto, instead of dying or anything, compiles
$key, caching it in

    $lh->{'failure_lex'}{$key} = $compiled

and then calls the compiled value, and returns that.  (I.e., if
$key looks like bracket notation, $compiled is a sub, and we return
&{$compiled}(@params); but if $key is just a plain string, we just
return that.)

The effect of using "failure_auto_handler"
is like an AUTO lexicon, except that it 1) compiles $key even if
it starts with "_", and 2) you have a record in the new hashref
$lh->{'failure_lex'} of all the keys that have failed for
this object.  This should avoid your program dying -- as long
as your keys aren't actually invalid as bracket code, and as
long as they don't try calling methods that don't exist.

"failure_auto_handler" may not be exactly what you want, but I
hope it at least shows you that maketext failure can be mitigated
in any number of very flexible ways.  If you can formalize exactly
what you want, you should be able to express that as a failure
handler.  You can even make it default for every object of a given
class, by setting it in that class's init:

  sub init {
    my $lh = $_[0];  # a newborn handle
    $lh->SUPER::init();
    $lh->fail_with('my_clever_failure_handler');
    return;
  }
  sub my_clever_failure_handler {
    ...you clever things here...
  }

=head1 HOW TO USE MAKETEXT

Here is a brief checklist on how to use Maketext to localize
applications:

=over

=item *

Decide what system you'll use for lexicon keys.  If you insist,
you can use opaque IDs (if you're nostalgic for C<catgets>),
but I have better suggestions in the
section "Entries in Each Lexicon", above.  Assuming you opt for
meaningful keys that double as values (like "Minimum ([_1]) is
larger than maximum ([_2])!\n"), you'll have to settle on what
language those should be in.  For the sake of argument, I'll
call this English, specifically American English, "en-US".

=item *

Create a class for your localization project.  This is
the name of the class that you'll use in the idiom:

  use Projname::L10N;
  my $lh = Projname::L10N->get_handle(...) || die "Language?";

Assuming you call your class Projname::L10N, create a class
consisting minimally of:

  package Projname::L10N;
  use base qw(Locale::Maketext);
  ...any methods you might want all your languages to share...

  # And, assuming you want the base class to be an _AUTO lexicon,
  # as is discussed a few sections up:

  1;

=item *

Create a class for the language your internal keys are in.  Name
the class after the language-tag for that language, in lowercase,
with dashes changed to underscores.  Assuming your project's first
language is US English, you should call this Projname::L10N::en_us.
It should consist minimally of:

  package Projname::L10N::en_us;
  use base qw(Projname::L10N);
  %Lexicon = (
    '_AUTO' => 1,
  );
  1;

(For the rest of this section, I'll assume that this "first
language class" of Projname::L10N::en_us has
_AUTO lexicon.)

=item *

Go and write your program.  Everywhere in your program where 
you would say:

  print "Foobar $thing stuff\n";

instead do it thru maketext, using no variable interpolation in
the key:

  print $lh->maketext("Foobar [_1] stuff\n", $thing);

If you get tired of constantly saying C<print $lh-E<gt>maketext>,
consider making a functional wrapper for it, like so:

  use Projname::L10N;
  use vars qw($lh);
  $lh = Projname::L10N->get_handle(...) || die "Language?";
  sub pmt (@) { print( $lh->maketext(@_)) }
   # "pmt" is short for "Print MakeText"
  $Carp::Verbose = 1;
   # so if maketext fails, we see made the call to pmt

Besides whole phrases meant for output, anything language-dependent
should be put into the class Projname::L10N::en_us,
whether as methods, or as lexicon entries -- this is discussed
in the section "Entries in Each Lexicon", above.

=item *

Once the program is otherwise done, and once its localization for
the first language works right (via the data and methods in
Projname::L10N::en_us), you can get together the data for translation.
If your first language lexicon isn't an _AUTO lexicon, then you already
have all the messages explicitly in the lexicon (or else you'd be
getting exceptions thrown when you call $lh->maketext to get
messages that aren't in there).  But if you were (advisedly) lazy and are
using an _AUTO lexicon, then you've got to make a list of all the phrases
that you've so far been letting _AUTO generate for you.  There are very
many ways to assemble such a list.  The most straightforward is to simply
grep the source for every occurrence of "maketext" (or calls
to wrappers around it, like the above C<pmt> function), and to log the
following phrase.

=item *

You may at this point want to consider whether your base class 
(Projname::L10N), from which all lexicons inherit from (Projname::L10N::en,
Projname::L10N::es, etc.), should be an _AUTO lexicon.  It may be true
that in theory, all needed messages will be in each language class;
but in the presumably unlikely or "impossible" case of lookup failure,
you should consider whether your program should throw an exception,
emit text in English (or whatever your project's first language is),
or some more complex solution as described in the section
"Controlling Lookup Failure", above.

=item *

Submit all messages/phrases/etc. to translators.

(You may, in fact, want to start with localizing to I<one> other language
at first, if you're not sure that you've properly abstracted the
language-dependent parts of your code.)

Translators may request clarification of the situation in which a
particular phrase is found.  For example, in English we are entirely happy
saying "I<n> files found", regardless of whether we mean "I looked for files,
and found I<n> of them" or the rather distinct situation of "I looked for
something else (like lines in files), and along the way I saw I<n>
files."  This may involve rethinking things that you thought quite clear:
should "Edit" on a toolbar be a noun ("editing") or a verb ("to edit")?  Is
there already a conventionalized way to express that menu option, separate
from the target language's normal word for "to edit"?

In all cases where the very common phenomenon of quantification
(saying "I<N> files", for B<any> value of N)
is involved, each translator should make clear what dependencies the
number causes in the sentence.  In many cases, dependency is
limited to words adjacent to the number, in places where you might
expect them ("I found the-?PLURAL I<N>
empty-?PLURAL directory-?PLURAL"), but in some cases there are
unexpected dependencies ("I found-?PLURAL ..."!) as well as long-distance
dependencies "The I<N> directory-?PLURAL could not be deleted-?PLURAL"!).

Remind the translators to consider the case where N is 0:
"0 files found" isn't exactly natural-sounding in any language, but it
may be unacceptable in many -- or it may condition special
kinds of agreement (similar to English "I didN'T find ANY files").

Remember to ask your translators about numeral formatting in their
language, so that you can override the C<numf> method as
appropriate.  Typical variables in number formatting are:  what to
use as a decimal point (comma? period?); what to use as a thousands
separator (space? nonbreaking space? comma? period? small
middot? prime? apostrophe?); and even whether the so-called "thousands
separator" is actually for every third digit -- I've heard reports of
two hundred thousand being expressible as "2,00,000" for some Indian
(Subcontinental) languages, besides the less surprising "S<200 000>",
"200.000", "200,000", and "200'000".  Also, using a set of numeral
glyphs other than the usual ASCII "0"-"9" might be appreciated, as via
C<tr/0-9/\x{0966}-\x{096F}/> for getting digits in Devanagari script
(for Hindi, Konkani, others).

The basic C<quant> method that Locale::Maketext provides should be
good for many languages.  For some languages, it might be useful
to modify it (or its constituent C<numerate> method)
to take a plural form in the two-argument call to C<quant>
(as in "[quant,_1,files]") if
it's all-around easier to infer the singular form from the plural, than
to infer the plural form from the singular.

But for other languages (as is discussed at length
in L<Locale::Maketext::TPJ13|Locale::Maketext::TPJ13>), simple
C<quant>/C<numf> is not enough.  For the particularly problematic
Slavic languages, what you may need is a method which you provide
with the number, the citation form of the noun to quantify, and
the case and gender that the sentence's syntax projects onto that
noun slot.  The method would then be responsible for determining
what grammatical number that numeral projects onto its noun phrase,
and what case and gender it may override the normal case and gender
with; and then it would look up the noun in a lexicon providing
all needed inflected forms.

=item *

You may also wish to discuss with the translators the question of
how to relate different subforms of the same language tag,
considering how this reacts with C<get_handle>'s treatment of
these.  For example, if a user accepts interfaces in "en, fr", and
you have interfaces available in "en-US" and "fr", what should
they get?  You may wish to resolve this by establishing that "en"
and "en-US" are effectively synonymous, by having one class
zero-derive from the other.

For some languages this issue may never come up (Danish is rarely
expressed as "da-DK", but instead is just "da").  And for other
languages, the whole concept of a "generic" form may verge on
being uselessly vague, particularly for interfaces involving voice
media in forms of Arabic or Chinese.

=item *

Once you've localized your program/site/etc. for all desired
languages, be sure to show the result (whether live, or via
screenshots) to the translators.  Once they approve, make every
effort to have it then checked by at least one other speaker of
that language.  This holds true even when (or especially when) the
translation is done by one of your own programmers.  Some
kinds of systems may be harder to find testers for than others,
depending on the amount of domain-specific jargon and concepts
involved -- it's easier to find people who can tell you whether
they approve of your translation for "delete this message" in an
email-via-Web interface, than to find people who can give you
an informed opinion on your translation for "attribute value"
in an XML query tool's interface.

=back

=head1 SEE ALSO

I recommend reading all of these:

L<Locale::Maketext::TPJ13|Locale::Maketext::TPJ13> -- my I<The Perl
Journal> article about Maketext.  It explains many important concepts
underlying Locale::Maketext's design, and some insight into why
Maketext is better than the plain old approach of having 
message catalogs that are just databases of sprintf formats.

L<File::Findgrep|File::Findgrep> is a sample application/module
that uses Locale::Maketext to localize its messages.  For a larger
internationalized system, see also L<Apache::MP3>.

L<I18N::LangTags|I18N::LangTags>.

L<Win32::Locale|Win32::Locale>.

RFC 3066, I<Tags for the Identification of Languages>,
as at http://sunsite.dk/RFC/rfc/rfc3066.html

RFC 2277, I<IETF Policy on Character Sets and Languages>
is at http://sunsite.dk/RFC/rfc/rfc2277.html -- much of it is
just things of interest to protocol designers, but it explains
some basic concepts, like the distinction between locales and
language-tags.

The manual for GNU C<gettext>.  The gettext dist is available in
C<ftp://prep.ai.mit.edu/pub/gnu/> -- get
a recent gettext tarball and look in its "doc/" directory, there's
an easily browsable HTML version in there.  The
gettext documentation asks lots of questions worth thinking
about, even if some of their answers are sometimes wonky,
particularly where they start talking about pluralization.

The Locale/Maketext.pm source.  Observe that the module is much
shorter than its documentation!

=head1 COPYRIGHT AND DISCLAIMER

Copyright (c) 1999-2004 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Sean M. Burke C<sburke@cpan.org>

=cut
                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Locale/Script.pm                                                              0100644 0000000 0000000 00000002674 12744441327 015670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Script;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;
use Exporter;

our $VERSION;
$VERSION='3.30';

our (@ISA,@EXPORT);

my $backend     = 'Locale::Codes::Script';
my $backend_exp = $backend . "::EXPORT";

eval "require $backend; $backend->import(); return 1;";

{
   no strict 'refs';
   @EXPORT = @{ $backend_exp };
}

unshift (@ISA, $backend);

sub rename_script            { Locale::Codes::Script::rename_script(@_) }
sub add_script               { Locale::Codes::Script::add_script(@_) }
sub delete_script            { Locale::Codes::Script::delete_script(@_) }
sub add_script_alias         { Locale::Codes::Script::add_script_alias(@_) }
sub delete_script_alias      { Locale::Codes::Script::delete_script_alias(@_) }
sub rename_script_code       { Locale::Codes::Script::rename_script_code(@_) }
sub add_script_code_alias    { Locale::Codes::Script::add_script_code_alias(@_) }
sub delete_script_code_alias { Locale::Codes::Script::delete_script_code_alias(@_) }

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                    usr/share/perl/5.20.2/Locale/Script.pod                                                             0100644 0000000 0000000 00000006127 12744441327 016033  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Script - standard codes for script identification

=head1 SYNOPSIS

   use Locale::Script;

   $script  = code2script('phnx');                     # 'Phoenician'
   $code    = script2code('Phoenician');               # 'Phnx'
   $code    = script2code('Phoenician',
                          LOCALE_CODE_NUMERIC);        # 115

   @codes   = all_script_codes();
   @scripts = all_script_names();

=head1 DESCRIPTION

The C<Locale::Script> module provides access to standards codes used
for identifying scripts, such as those defined in ISO 15924.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
15924 four-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
scripts. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $script = code2script('phnx','alpha');
   $script = code2script('phnx',LOCALE_SCRIPT_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha, LOCALE_SCRIPT_ALPHA>

This is a set of four-letter (capitalized) codes from ISO 15924
such as 'Phnx' for Phoenician.  It also includes additions to this
set included in the IANA language registry.

The Zxxx, Zyyy, and Zzzz codes are not used.

This is the default code set.

=item B<num, LOCALE_SCRIPT_NUMERIC>

This is a set of three-digit numeric codes from ISO 15924 such as 115
for Phoenician.

=back

=head1 ROUTINES

=over 4

=item B<code2script ( CODE [,CODESET] )>

=item B<script2code ( NAME [,CODESET] )>

=item B<script_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_script_codes ( [CODESET] )>

=item B<all_script_names ( [CODESET] )>

=item B<Locale::Script::rename_script  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Script::add_script  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Script::delete_script  ( CODE [,CODESET] )>

=item B<Locale::Script::add_script_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Script::delete_script_alias  ( NAME )>

=item B<Locale::Script::rename_script_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Script::add_script_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Script::delete_script_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.unicode.org/iso15924/>

Home page for ISO 15924.

=item B<http://www.iana.org/assignments/language-subtag-registry>

The IANA language subtag registry.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/perl/5.20.2/Math/                                                                         0040755 0000000 0000000 00000000000 13077704254 013553  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Math/BigFloat/                                                                0040755 0000000 0000000 00000000000 13077704254 015242  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Math/BigFloat/Trace.pm                                                        0100644 0000000 0000000 00000002342 12744441327 016633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl -w

package Math::BigFloat::Trace;

require 5.005_02;
use strict;

use Exporter;
use Math::BigFloat;
use vars qw($VERSION @ISA $PACKAGE @EXPORT_OK
            $accuracy $precision $round_mode $div_scale);

@ISA = qw(Exporter Math::BigFloat);

$VERSION = '0.36';

use overload;	# inherit overload from BigFloat

# Globals
$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;

sub new
{
        my $proto  = shift;
        my $class  = ref($proto) || $proto;

        my $value       = shift;
	my $a = $accuracy; $a = $_[0] if defined $_[0];
	my $p = $precision; $p = $_[1] if defined $_[1];
        my $self = Math::BigFloat->new($value,$a,$p,$round_mode);

#	remember, downgrading may return a BigInt, so don't meddle with class	
#	bless $self,$class;

	print "MBF new '$value' => '$self' (",ref($self),")";
        return $self;
}

sub import
  {
  print "MBF import ",join(' ',@_);
  my $self = shift;

  # we catch the constants, the rest goes go BigFloat
  my @a = ();
  foreach (@_)
    {
    push @a, $_ if $_ ne ':constant';
    }
  overload::constant float => sub { $self->new(shift); }; 

  Math::BigFloat->import(@a);		# need it for subclasses
#  $self->export_to_level(1,$self,@_);		# need this ?
  }

1;
                                                                                                                                                                                                                                                                                              usr/share/perl/5.20.2/Math/BigFloat.pm                                                              0100644 0000000 0000000 00000406132 12744441327 015602  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Math::BigFloat;

# 
# Mike grinned. 'Two down, infinity to go' - Mike Nostrus in 'Before and After'
#

# The following hash values are internally used:
#   _e	: exponent (ref to $CALC object)
#   _m	: mantissa (ref to $CALC object)
#   _es	: sign of _e
# sign	: +,-,+inf,-inf, or "NaN" if not a number
#   _a	: accuracy
#   _p	: precision

$VERSION = '1.9991';
require 5.006002;

require Exporter;
@ISA		= qw/Math::BigInt/;
@EXPORT_OK	= qw/bpi/;

use strict;
# $_trap_inf/$_trap_nan are internal and should never be accessed from outside
use vars qw/$AUTOLOAD $accuracy $precision $div_scale $round_mode $rnd_mode
	    $upgrade $downgrade $_trap_nan $_trap_inf/;
my $class = "Math::BigFloat";

use overload
'<=>'	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      ref($_[0])->bcmp($_[0],$_[1]); 
		      $rc = 1 unless defined $rc;
		      $rc <=> 0;
		},
# we need '>=' to get things like "1 >= NaN" right:
'>='	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      ref($_[0])->bcmp($_[0],$_[1]);
		      # if there was a NaN involved, return false
		      return '' unless defined $rc;
		      $rc >= 0;
		},
'int'	=>	sub { $_[0]->as_number() },		# 'trunc' to bigint
;

##############################################################################
# global constants, flags and assorted stuff

# the following are public, but their usage is not recommended. Use the
# accessor methods instead.

# class constants, use Class->constant_name() to access
# one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
$round_mode = 'even';
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;
$downgrade = undef;
# the package we are using for our private parts, defaults to:
# Math::BigInt->config()->{lib}
my $MBI = 'Math::BigInt::Calc';

# are NaNs ok? (otherwise it dies when encountering an NaN) set w/ config()
$_trap_nan = 0;
# the same for infinity
$_trap_inf = 0;

# constant for easier life
my $nan = 'NaN'; 

my $IMPORT = 0;	# was import() called yet? used to make require work

# some digits of accuracy for blog(undef,10); which we use in blog() for speed
my $LOG_10 = 
 '2.3025850929940456840179914546843642076011014886287729760333279009675726097';
my $LOG_10_A = length($LOG_10)-1;
# ditto for log(2)
my $LOG_2 = 
 '0.6931471805599453094172321214581765680755001343602552541206800094933936220';
my $LOG_2_A = length($LOG_2)-1;
my $HALF = '0.5';			# made into an object if nec.

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

sub TIESCALAR   { my ($class) = @_; bless \$round_mode, $class; }
sub FETCH       { return $round_mode; }
sub STORE       { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN
  {
  # when someone sets $rnd_mode, we catch this and check the value to see
  # whether it is valid or not. 
  $rnd_mode   = 'even'; tie $rnd_mode, 'Math::BigFloat';

  # we need both of them in this package:
  *as_int = \&as_number;
  }
 
##############################################################################

{
  # valid method aliases for AUTOLOAD
  my %methods = map { $_ => 1 }  
   qw / fadd fsub fmul fdiv fround ffround fsqrt fmod fstr fsstr fpow fnorm
        fint facmp fcmp fzero fnan finf finc fdec ffac fneg
	fceil ffloor frsft flsft fone flog froot fexp
      /;
  # valid methods that can be handed up (for AUTOLOAD)
  my %hand_ups = map { $_ => 1 }  
   qw / is_nan is_inf is_negative is_positive is_pos is_neg
        accuracy precision div_scale round_mode fabs fnot
        objectify upgrade downgrade
	bone binf bnan bzero
	bsub
      /;

  sub _method_alias { exists $methods{$_[0]||''}; } 
  sub _method_hand_up { exists $hand_ups{$_[0]||''}; } 
}

##############################################################################
# constructors

sub new 
  {
  # create a new BigFloat object from a string or another bigfloat object. 
  # _e: exponent
  # _m: mantissa
  # sign  => sign (+/-), or "NaN"

  my ($class,$wanted,@r) = @_;

  # avoid numify-calls by not using || on $wanted!
  return $class->bzero() if !defined $wanted;	# default to 0
  return $wanted->copy() if UNIVERSAL::isa($wanted,'Math::BigFloat');

  $class->import() if $IMPORT == 0;             # make require work

  my $self = {}; bless $self, $class;
  # shortcut for bigints and its subclasses
  if ((ref($wanted)) && UNIVERSAL::can( $wanted, "as_number"))
    {
    $self->{_m} = $wanted->as_number()->{value}; # get us a bigint copy
    $self->{_e} = $MBI->_zero();
    $self->{_es} = '+';
    $self->{sign} = $wanted->sign();
    return $self->bnorm();
    }
  # else: got a string or something masquerading as number (with overload)

  # handle '+inf', '-inf' first
  if ($wanted =~ /^[+-]?inf\z/)
    {
    return $downgrade->new($wanted) if $downgrade;

    $self->{sign} = $wanted;		# set a default sign for bstr()
    return $self->binf($wanted);
    }

  # shortcut for simple forms like '12' that neither have trailing nor leading
  # zeros
  if ($wanted =~ /^([+-]?)([1-9][0-9]*[1-9])$/)
    {
    $self->{_e} = $MBI->_zero();
    $self->{_es} = '+';
    $self->{sign} = $1 || '+';
    $self->{_m} = $MBI->_new($2);
    return $self->round(@r) if !$downgrade;
    }

  my ($mis,$miv,$mfv,$es,$ev) = Math::BigInt::_split($wanted);
  if (!ref $mis)
    {
    if ($_trap_nan)
      {
      require Carp;
      Carp::croak ("$wanted is not a number initialized to $class");
      }
    
    return $downgrade->bnan() if $downgrade;
    
    $self->{_e} = $MBI->_zero();
    $self->{_es} = '+';
    $self->{_m} = $MBI->_zero();
    $self->{sign} = $nan;
    }
  else
    {
    # make integer from mantissa by adjusting exp, then convert to int
    $self->{_e} = $MBI->_new($$ev);		# exponent
    $self->{_es} = $$es || '+';
    my $mantissa = "$$miv$$mfv"; 		# create mant.
    $mantissa =~ s/^0+(\d)/$1/;			# strip leading zeros
    $self->{_m} = $MBI->_new($mantissa); 	# create mant.

    # 3.123E0 = 3123E-3, and 3.123E-2 => 3123E-5
    if (CORE::length($$mfv) != 0)
      {
      my $len = $MBI->_new( CORE::length($$mfv));
      ($self->{_e}, $self->{_es}) =
	_e_sub ($self->{_e}, $len, $self->{_es}, '+');
      }
    # we can only have trailing zeros on the mantissa if $$mfv eq ''
    else
      {
      # Use a regexp to count the trailing zeros in $$miv instead of _zeros()
      # because that is faster, especially when _m is not stored in base 10.
      my $zeros = 0; $zeros = CORE::length($1) if $$miv =~ /[1-9](0*)$/; 
      if ($zeros != 0)
        {
        my $z = $MBI->_new($zeros);
        # turn '120e2' into '12e3'
        $MBI->_rsft ( $self->{_m}, $z, 10);
        ($self->{_e}, $self->{_es}) =
	  _e_add ( $self->{_e}, $z, $self->{_es}, '+');
        }
      }
    $self->{sign} = $$mis;

    # for something like 0Ey, set y to 1, and -0 => +0
    # Check $$miv for being '0' and $$mfv eq '', because otherwise _m could not
    # have become 0. That's faster than to call $MBI->_is_zero().
    $self->{sign} = '+', $self->{_e} = $MBI->_one()
     if $$miv eq '0' and $$mfv eq '';

    return $self->round(@r) if !$downgrade;
    }
  # if downgrade, inf, NaN or integers go down

  if ($downgrade && $self->{_es} eq '+')
    {
    if ($MBI->_is_zero( $self->{_e} ))
      {
      return $downgrade->new($$mis . $MBI->_str( $self->{_m} ));
      }
    return $downgrade->new($self->bsstr()); 
    }
  $self->bnorm()->round(@r);			# first normalize, then round
  }

sub copy
  {
  # if two arguments, the first one is the class to "swallow" subclasses
  if (@_ > 1)
    {
    my  $self = bless {
	sign => $_[1]->{sign}, 
	_es => $_[1]->{_es}, 
	_m => $MBI->_copy($_[1]->{_m}),
	_e => $MBI->_copy($_[1]->{_e}),
    }, $_[0] if @_ > 1;

    $self->{_a} = $_[1]->{_a} if defined $_[1]->{_a};
    $self->{_p} = $_[1]->{_p} if defined $_[1]->{_p};
    return $self;
    }

  my $self = bless {
	sign => $_[0]->{sign}, 
	_es => $_[0]->{_es}, 
	_m => $MBI->_copy($_[0]->{_m}),
	_e => $MBI->_copy($_[0]->{_e}),
	}, ref($_[0]);

  $self->{_a} = $_[0]->{_a} if defined $_[0]->{_a};
  $self->{_p} = $_[0]->{_p} if defined $_[0]->{_p};
  $self;
  }

sub _bnan
  {
  # used by parent class bone() to initialize number to NaN
  my $self = shift;
  
  if ($_trap_nan)
    {
    require Carp;
    my $class = ref($self);
    Carp::croak ("Tried to set $self to NaN in $class\::_bnan()");
    }

  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_zero();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub _binf
  {
  # used by parent class bone() to initialize number to +-inf
  my $self = shift;
  
  if ($_trap_inf)
    {
    require Carp;
    my $class = ref($self);
    Carp::croak ("Tried to set $self to +-inf in $class\::_binf()");
    }

  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_zero();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub _bone
  {
  # used by parent class bone() to initialize number to 1
  my $self = shift;
  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_one();
  $self->{_e} = $MBI->_zero();
  $self->{_es} = '+';
  }

sub _bzero
  {
  # used by parent class bone() to initialize number to 0
  my $self = shift;
  $IMPORT=1;					# call our import only once
  $self->{_m} = $MBI->_zero();
  $self->{_e} = $MBI->_one();
  $self->{_es} = '+';
  }

sub isa
  {
  my ($self,$class) = @_;
  return if $class =~ /^Math::BigInt/;		# we aren't one of these
  UNIVERSAL::isa($self,$class);
  }

sub config
  {
  # return (later set?) configuration data as hash ref
  my $class = shift || 'Math::BigFloat';

  if (@_ == 1 && ref($_[0]) ne 'HASH')
    {
    my $cfg = $class->SUPER::config();
    return $cfg->{$_[0]};
    }

  my $cfg = $class->SUPER::config(@_);

  # now we need only to override the ones that are different from our parent
  $cfg->{class} = $class;
  $cfg->{with} = $MBI;
  $cfg;
  }

##############################################################################
# string conversion

sub bstr 
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to (non-scientific) string format.
  # internal format is always normalized (no leading zeros, "-0" => "+0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }

  my $es = '0'; my $len = 1; my $cad = 0; my $dot = '.';

  # $x is zero?
  my $not_zero = !($x->{sign} eq '+' && $MBI->_is_zero($x->{_m}));
  if ($not_zero)
    {
    $es = $MBI->_str($x->{_m});
    $len = CORE::length($es);
    my $e = $MBI->_num($x->{_e});	
    $e = -$e if $x->{_es} eq '-';
    if ($e < 0)
      {
      $dot = '';
      # if _e is bigger than a scalar, the following will blow your memory
      if ($e <= -$len)
        {
        my $r = abs($e) - $len;
        $es = '0.'. ('0' x $r) . $es; $cad = -($len+$r);
        }
      else
        {
        substr($es,$e,0) = '.'; $cad = $MBI->_num($x->{_e});
        $cad = -$cad if $x->{_es} eq '-';
        }
      }
    elsif ($e > 0)
      {
      # expand with zeros
      $es .= '0' x $e; $len += $e; $cad = 0;
      }
    } # if not zero

  $es = '-'.$es if $x->{sign} eq '-';
  # if set accuracy or precision, pad with zeros on the right side
  if ((defined $x->{_a}) && ($not_zero))
    {
    # 123400 => 6, 0.1234 => 4, 0.001234 => 4
    my $zeros = $x->{_a} - $cad;		# cad == 0 => 12340
    $zeros = $x->{_a} - $len if $cad != $len;
    $es .= $dot.'0' x $zeros if $zeros > 0;
    }
  elsif ((($x->{_p} || 0) < 0))
    {
    # 123400 => 6, 0.1234 => 4, 0.001234 => 6
    my $zeros = -$x->{_p} + $cad;
    $es .= $dot.'0' x $zeros if $zeros > 0;
    }
  $es;
  }

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';      # -inf, NaN
    return 'inf';                                       # +inf
    }
  my $sep = 'e'.$x->{_es};
  my $sign = $x->{sign}; $sign = '' if $sign eq '+';
  $sign . $MBI->_str($x->{_m}) . $sep . $MBI->_str($x->{_e});
  }
    
sub numify 
  {
  # Convert a Perl scalar number from a BigFloat object.
  # Create a string and let Perl's atoi()/atof() handle the rest.
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  return 0 + $x->bsstr(); 
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub bneg
  {
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->modify('bneg');

  # for +0 do not negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $MBI->_is_zero($x->{_m}));
  $x;
  }

# tels 2001-08-04 
# XXX TODO this must be overwritten and return NaN for non-integer values
# band(), bior(), bxor(), too
#sub bnot
#  {
#  $class->SUPER::bnot($class,@_);
#  }

sub bcmp 
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)

  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  # Handle all 'nan' cases.

  return undef if ($x->{sign} eq $nan) || ($y->{sign} eq $nan);

  # Handle all '+inf' and '-inf' cases.

  return  0 if ($x->{sign} eq '+inf' && $y->{sign} eq '+inf' ||
                $x->{sign} eq '-inf' && $y->{sign} eq '-inf');
  return +1 if $x->{sign} eq '+inf';    # x = +inf and y < +inf
  return -1 if $x->{sign} eq '-inf';    # x = -inf and y > -inf
  return -1 if $y->{sign} eq '+inf';    # x < +inf and y = +inf
  return +1 if $y->{sign} eq '-inf';    # x > -inf and y = -inf

  # Handle all cases with opposite signs.

  return +1 if $x->{sign} eq '+' && $y->{sign} eq '-';  # also does 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # also does -x <=> 0

  # Handle all remaining zero cases.

  my $xz = $x->is_zero();
  my $yz = $y->is_zero();
  return  0 if $xz && $yz;                              # 0 <=> 0
  return -1 if $xz && $y->{sign} eq '+';                # 0 <=> +y
  return +1 if $yz && $x->{sign} eq '+';                # +x <=> 0

  # Both arguments are now finite, non-zero numbers with the same sign.

  my $cmp;

  # The next step is to compare the exponents, but since each mantissa is an
  # integer of arbitrary value, the exponents must be normalized by the length
  # of the mantissas before we can compare them.

  my $mxl = $MBI->_len($x->{_m});
  my $myl = $MBI->_len($y->{_m});

  # If the mantissas have the same length, there is no point in normalizing the
  # exponents by the length of the mantissas, so treat that as a special case.

  if ($mxl == $myl) {

      # First handle the two cases where the exponents have different signs.

      if ($x->{_es} eq '+' && $y->{_es} eq '-') {
          $cmp = +1;
      }

      elsif ($x->{_es} eq '-' && $y->{_es} eq '+') {
          $cmp = -1;
      }

      # Then handle the case where the exponents have the same sign.

      else {
          $cmp = $MBI->_acmp($x->{_e}, $y->{_e});
          $cmp = -$cmp if $x->{_es} eq '-';
      }

      # Adjust for the sign, which is the same for x and y, and bail out if
      # we're done.

      $cmp = -$cmp if $x->{sign} eq '-';        # 124 > 123, but -124 < -123
      return $cmp if $cmp;

  }

  # We must normalize each exponent by the length of the corresponding
  # mantissa. Life is a lot easier if we first make both exponents
  # non-negative. We do this by adding the same positive value to both
  # exponent. This is safe, because when comparing the exponents, only the
  # relative difference is important.

  my $ex;
  my $ey;

  if ($x->{_es} eq '+') {

      # If the exponent of x is >= 0 and the exponent of y is >= 0, there is no
      # need to do anything special.

      if ($y->{_es} eq '+') {
          $ex = $MBI->_copy($x->{_e});
          $ey = $MBI->_copy($y->{_e});
      }

      # If the exponent of x is >= 0 and the exponent of y is < 0, add the
      # absolute value of the exponent of y to both.

      else {
          $ex = $MBI->_copy($x->{_e});
          $ex = $MBI->_add($ex, $y->{_e});      # ex + |ey|
          $ey = $MBI->_zero();                  # -ex + |ey| = 0
      }

  } else {

      # If the exponent of x is < 0 and the exponent of y is >= 0, add the
      # absolute value of the exponent of x to both.

      if ($y->{_es} eq '+') {
          $ex = $MBI->_zero();                  # -ex + |ex| = 0
          $ey = $MBI->_copy($y->{_e});
          $ey = $MBI->_add($ey, $x->{_e});      # ey + |ex|
      }

      # If the exponent of x is < 0 and the exponent of y is < 0, add the
      # absolute values of both exponents to both exponents.

      else {
          $ex = $MBI->_copy($y->{_e});          # -ex + |ey| + |ex| = |ey|
          $ey = $MBI->_copy($x->{_e});          # -ey + |ex| + |ey| = |ex|
      }

  }

  # Now we can normalize the exponents by adding lengths of the mantissas.

  $MBI->_add($ex, $MBI->_new($mxl));
  $MBI->_add($ey, $MBI->_new($myl));

  # We're done if the exponents are different.

  $cmp = $MBI->_acmp($ex, $ey);
  $cmp = -$cmp if $x->{sign} eq '-';            # 124 > 123, but -124 < -123
  return $cmp if $cmp;

  # Compare the mantissas, but first normalize them by padding the shorter
  # mantissa with zeros (shift left) until it has the same length as the longer
  # mantissa.

  my $mx = $x->{_m};
  my $my = $y->{_m};

  if ($mxl > $myl) {
      $my = $MBI->_lsft($MBI->_copy($my), $MBI->_new($mxl - $myl), 10);
  } elsif ($mxl < $myl) {
      $mx = $MBI->_lsft($MBI->_copy($mx), $MBI->_new($myl - $mxl), 10);
  }

  $cmp = $MBI->_acmp($mx, $my);
  $cmp = -$cmp if $x->{sign} eq '-';            # 124 > 123, but -124 < -123
  return $cmp;

  }

sub bacmp 
  {
  # Compares 2 values, ignoring their signs. 
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@_);
    }

  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  # handle +-inf and NaN's
  if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/)
    {
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if ($x->is_inf() && $y->is_inf());
    return 1 if ($x->is_inf() && !$y->is_inf());
    return -1;
    }

  # shortcut 
  my $xz = $x->is_zero();
  my $yz = $y->is_zero();
  return 0 if $xz && $yz;				# 0 <=> 0
  return -1 if $xz && !$yz;				# 0 <=> +y
  return 1 if $yz && !$xz;				# +x <=> 0

  # adjust so that exponents are equal
  my $lxm = $MBI->_len($x->{_m});
  my $lym = $MBI->_len($y->{_m});
  my ($xes,$yes) = (1,1);
  $xes = -1 if $x->{_es} ne '+';
  $yes = -1 if $y->{_es} ne '+';
  # the numify somewhat limits our length, but makes it much faster
  my $lx = $lxm + $xes * $MBI->_num($x->{_e});
  my $ly = $lym + $yes * $MBI->_num($y->{_e});
  my $l = $lx - $ly;
  return $l <=> 0 if $l != 0;
  
  # lengths (corrected by exponent) are equal
  # so make mantissa equal-length by padding with zero (shift left)
  my $diff = $lxm - $lym;
  my $xm = $x->{_m};		# not yet copy it
  my $ym = $y->{_m};
  if ($diff > 0)
    {
    $ym = $MBI->_copy($y->{_m});
    $ym = $MBI->_lsft($ym, $MBI->_new($diff), 10);
    }
  elsif ($diff < 0)
    {
    $xm = $MBI->_copy($x->{_m});
    $xm = $MBI->_lsft($xm, $MBI->_new(-$diff), 10);
    }
  $MBI->_acmp($xm,$ym);
  }

sub badd 
  {
  # add second arg (BFLOAT or string) to first (BFLOAT) (modifies first)
  # return result as BFLOAT

  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }
 
  return $x if $x->modify('badd');

  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf; something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }

  return $upgrade->badd($x,$y,@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;						# no push!

  # speed: no add for 0+y or x+0
  return $x->bround(@r) if $y->is_zero();		# x+0
  if ($x->is_zero())					# 0+y
    {
    # make copy, clobbering up x (modify in place!)
    $x->{_e} = $MBI->_copy($y->{_e});
    $x->{_es} = $y->{_es};
    $x->{_m} = $MBI->_copy($y->{_m});
    $x->{sign} = $y->{sign} || $nan;
    return $x->round(@r);
    }
 
  # take lower of the two e's and adapt m1 to it to match m2
  my $e = $y->{_e};
  $e = $MBI->_zero() if !defined $e;		# if no BFLOAT?
  $e = $MBI->_copy($e);				# make copy (didn't do it yet)

  my $es;

  ($e,$es) = _e_sub($e, $x->{_e}, $y->{_es} || '+', $x->{_es});

  my $add = $MBI->_copy($y->{_m});

  if ($es eq '-')				# < 0
    {
    $MBI->_lsft( $x->{_m}, $e, 10);
    ($x->{_e},$x->{_es}) = _e_add($x->{_e}, $e, $x->{_es}, $es);
    }
  elsif (!$MBI->_is_zero($e))			# > 0
    {
    $MBI->_lsft($add, $e, 10);
    }
  # else: both e are the same, so just leave them

  if ($x->{sign} eq $y->{sign})
    {
    # add
    $x->{_m} = $MBI->_add($x->{_m}, $add);
    }
  else
    {
    ($x->{_m}, $x->{sign}) = 
     _e_add($x->{_m}, $add, $x->{sign}, $y->{sign});
    }

  # delete trailing zeros, then round
  $x->bnorm()->round(@r);
  }

# sub bsub is inherited from Math::BigInt!

sub binc
  {
  # increment arg by one
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('binc');

  if ($x->{_es} eq '-')
    {
    return $x->badd($self->bone(),@r);	#  digits after dot
    }

  if (!$MBI->_is_zero($x->{_e}))		# _e == 0 for NaN, inf, -inf
    {
    # 1e2 => 100, so after the shift below _m has a '0' as last digit
    $x->{_m} = $MBI->_lsft($x->{_m}, $x->{_e},10);	# 1e2 => 100
    $x->{_e} = $MBI->_zero();				# normalize
    $x->{_es} = '+';
    # we know that the last digit of $x will be '1' or '9', depending on the
    # sign
    }
  # now $x->{_e} == 0
  if ($x->{sign} eq '+')
    {
    $MBI->_inc($x->{_m});
    return $x->bnorm()->bround(@r);
    }
  elsif ($x->{sign} eq '-')
    {
    $MBI->_dec($x->{_m});
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m}); # -1 +1 => -0 => +0
    return $x->bnorm()->bround(@r);
    }
  # inf, nan handling etc
  $x->badd($self->bone(),@r);			# badd() does round 
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bdec');

  if ($x->{_es} eq '-')
    {
    return $x->badd($self->bone('-'),@r);	#  digits after dot
    }

  if (!$MBI->_is_zero($x->{_e}))
    {
    $x->{_m} = $MBI->_lsft($x->{_m}, $x->{_e},10);	# 1e2 => 100
    $x->{_e} = $MBI->_zero();				# normalize
    $x->{_es} = '+';
    }
  # now $x->{_e} == 0
  my $zero = $x->is_zero();
  # <= 0
  if (($x->{sign} eq '-') || $zero)
    {
    $MBI->_inc($x->{_m});
    $x->{sign} = '-' if $zero;				# 0 => 1 => -1
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m});	# -1 +1 => -0 => +0
    return $x->bnorm()->round(@r);
    }
  # > 0
  elsif ($x->{sign} eq '+')
    {
    $MBI->_dec($x->{_m});
    return $x->bnorm()->round(@r);
    }
  # inf, nan handling etc
  $x->badd($self->bone('-'),@r);		# does round
  } 

sub DEBUG () { 0; }

sub blog
  {
  my ($self,$x,$base,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('blog');

  # $base > 0, $base != 1; if $base == undef default to $base == e
  # $x >= 0

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  # also takes care of the "error in _find_round_parameters?" case
  return $x->bnan() if $x->{sign} ne '+' || $x->is_zero();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4;	# take whatever is defined
    }

  return $x->bzero(@params) if $x->is_one();
  # base not defined => base == Euler's number e
  if (defined $base)
    {
    # make object, since we don't feed it through objectify() to still get the
    # case of $base == undef
    $base = $self->new($base) unless ref($base);
    # $base > 0; $base != 1
    return $x->bnan() if $base->is_zero() || $base->is_one() ||
      $base->{sign} ne '+';
    # if $x == $base, we know the result must be 1.0
    if ($x->bcmp($base) == 0)
      {
      $x->bone('+',@params);
      if ($fallback)
        {
        # clear a/p after round, since user did not request it
        delete $x->{_a}; delete $x->{_p};
        }
      return $x;
      }
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;

  # upgrade $x if $x is not a BigFloat (handle BigInt input)
  # XXX TODO: rebless!
  if (!$x->isa('Math::BigFloat'))
    {
    $x = Math::BigFloat->new($x);
    $self = ref($x);
    }
  
  my $done = 0;

  # If the base is defined and an integer, try to calculate integer result
  # first. This is very fast, and in case the real result was found, we can
  # stop right here.
  if (defined $base && $base->is_int() && $x->is_int())
    {
    my $i = $MBI->_copy( $x->{_m} );
    $MBI->_lsft( $i, $x->{_e}, 10 ) unless $MBI->_is_zero($x->{_e});
    my $int = Math::BigInt->bzero();
    $int->{value} = $i;
    $int->blog($base->as_number());
    # if ($exact)
    if ($base->as_number()->bpow($int) == $x)
      {
      # found result, return it
      $x->{_m} = $int->{value};
      $x->{_e} = $MBI->_zero();
      $x->{_es} = '+';
      $x->bnorm();
      $done = 1;
      }
    }

  if ($done == 0)
    {
    # base is undef, so base should be e (Euler's number), so first calculate the
    # log to base e (using reduction by 10 (and probably 2)):
    $self->_log_10($x,$scale);

    # and if a different base was requested, convert it
    if (defined $base)
      {
      $base = Math::BigFloat->new($base) unless $base->isa('Math::BigFloat');
      # not ln, but some other base (don't modify $base)
      $x->bdiv( $base->copy()->blog(undef,$scale), $scale );
      }
    }
 
  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;

  $x;
  }

sub _len_to_steps
  {
  # Given D (digits in decimal), compute N so that N! (N factorial) is
  # at least D digits long. D should be at least 50.
  my $d = shift;

  # two constants for the Ramanujan estimate of ln(N!)
  my $lg2 = log(2 * 3.14159265) / 2;
  my $lg10 = log(10);

  # D = 50 => N => 42, so L = 40 and R = 50
  my $l = 40; my $r = $d;

  # Otherwise this does not work under -Mbignum and we do not yet have "no bignum;" :(
  $l = $l->numify if ref($l);
  $r = $r->numify if ref($r);
  $lg2 = $lg2->numify if ref($lg2);
  $lg10 = $lg10->numify if ref($lg10);

  # binary search for the right value (could this be written as the reverse of lg(n!)?)
  while ($r - $l > 1)
    {
    my $n = int(($r - $l) / 2) + $l;
    my $ramanujan = 
      int(($n * log($n) - $n + log( $n * (1 + 4*$n*(1+2*$n)) ) / 6 + $lg2) / $lg10);
    $ramanujan > $d ? $r = $n : $l = $n;
    }
  $l;
  }

sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bnok');

  return $x->bnan() if $x->is_nan() || $y->is_nan();
  return $x->binf() if $x->is_inf();

  my $u = $x->as_int();
  $u->bnok($y->as_int());

  $x->{_m} = $u->{value};
  $x->{_e} = $MBI->_zero();
  $x->{_es} = '+';
  $x->{sign} = '+';
  $x->bnorm(@r);
  }

sub bexp
  {
  # Calculate e ** X (Euler's number to the power of X)
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bexp');

  return $x->binf() if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  # also takes care of the "error in _find_round_parameters?" case
  return $x if $x->{sign} eq 'NaN';

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it's not enough...
    $scale = abs($params[0] || $params[1]) + 4;	# take whatever is defined
    }

  return $x->bone(@params) if $x->is_zero();

  if (!$x->isa('Math::BigFloat'))
    {
    $x = Math::BigFloat->new($x);
    $self = ref($x);
    }
  
  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;

  my $x_org = $x->copy();

  # We use the following Taylor series:

  #           x    x^2   x^3   x^4
  #  e = 1 + --- + --- + --- + --- ...
  #           1!    2!    3!    4!

  # The difference for each term is X and N, which would result in:
  # 2 copy, 2 mul, 2 add, 1 inc, 1 div operations per term

  # But it is faster to compute exp(1) and then raising it to the
  # given power, esp. if $x is really big and an integer because:

  #  * The numerator is always 1, making the computation faster
  #  * the series converges faster in the case of x == 1
  #  * We can also easily check when we have reached our limit: when the
  #    term to be added is smaller than "1E$scale", we can stop - f.i.
  #    scale == 5, and we have 1/40320, then we stop since 1/40320 < 1E-5.
  #  * we can compute the *exact* result by simulating bigrat math:

  #  1   1    gcd(3,4) = 1    1*24 + 1*6    5
  #  - + -                  = ---------- =  --                 
  #  6   24                      6*24       24

  # We do not compute the gcd() here, but simple do:
  #  1   1    1*24 + 1*6   30
  #  - + -  = --------- =  --                 
  #  6   24       6*24     144

  # In general:
  #  a   c    a*d + c*b 	and note that c is always 1 and d = (b*f)
  #  - + -  = ---------
  #  b   d       b*d

  # This leads to:         which can be reduced by b to:
  #  a   1     a*b*f + b    a*f + 1
  #  - + -   = --------- =  -------
  #  b   b*f     b*b*f        b*f

  # The first terms in the series are:

  # 1     1    1    1    1    1     1     1     13700
  # -- + -- + -- + -- + -- + --- + --- + ---- = -----
  # 1     1    2    6   24   120   720   5040   5040

  # Note that we cannot simple reduce 13700/5040 to 685/252, but must keep A and B!

  if ($scale <= 75)
    {
    # set $x directly from a cached string form
    $x->{_m} = $MBI->_new(
    "27182818284590452353602874713526624977572470936999595749669676277240766303535476");
    $x->{sign} = '+';
    $x->{_es} = '-';
    $x->{_e} = $MBI->_new(79);
    }
  else
    {
    # compute A and B so that e = A / B.
 
    # After some terms we end up with this, so we use it as a starting point:
    my $A = $MBI->_new("90933395208605785401971970164779391644753259799242");
    my $F = $MBI->_new(42); my $step = 42;

    # Compute how many steps we need to take to get $A and $B sufficiently big
    my $steps = _len_to_steps($scale - 4);
#    print STDERR "# Doing $steps steps for ", $scale-4, " digits\n";
    while ($step++ <= $steps)
      {
      # calculate $a * $f + 1
      $A = $MBI->_mul($A, $F);
      $A = $MBI->_inc($A);
      # increment f
      $F = $MBI->_inc($F);
      }
    # compute $B as factorial of $steps (this is faster than doing it manually)
    my $B = $MBI->_fac($MBI->_new($steps));
    
#  print "A ", $MBI->_str($A), "\nB ", $MBI->_str($B), "\n";

    # compute A/B with $scale digits in the result (truncate, not round)
    $A = $MBI->_lsft( $A, $MBI->_new($scale), 10);
    $A = $MBI->_div( $A, $B );

    $x->{_m} = $A;
    $x->{sign} = '+';
    $x->{_es} = '-';
    $x->{_e} = $MBI->_new($scale);
    }

  # $x contains now an estimate of e, with some surplus digits, so we can round
  if (!$x_org->is_one())
    {
    # raise $x to the wanted power and round it in one step:
    $x->bpow($x_org, @params);
    }
  else
    {
    # else just round the already computed result
    delete $x->{_a}; delete $x->{_p};
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);		# then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);		# then round accordingly
      }
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;

  $x;						# return modified $x
  }

sub _log
  {
  # internal log function to calculate ln() based on Taylor series.
  # Modifies $x in place.
  my ($self,$x,$scale) = @_;

  # in case of $x == 1, result is 0
  return $x->bzero() if $x->is_one();

  # XXX TODO: rewrite this in a similar manner to bexp()

  # http://www.efunda.com/math/taylor_series/logarithmic.cfm?search_string=log

  # u = x-1, v = x+1
  #              _                               _
  # Taylor:     |    u    1   u^3   1   u^5       |
  # ln (x)  = 2 |   --- + - * --- + - * --- + ... |  x > 0
  #             |_   v    3   v^3   5   v^5      _|

  # This takes much more steps to calculate the result and is thus not used
  # u = x-1
  #              _                               _
  # Taylor:     |    u    1   u^2   1   u^3       |
  # ln (x)  = 2 |   --- + - * --- + - * --- + ... |  x > 1/2
  #             |_   x    2   x^2   3   x^3      _|

  my ($limit,$v,$u,$below,$factor,$two,$next,$over,$f);

  $v = $x->copy(); $v->binc();		# v = x+1
  $x->bdec(); $u = $x->copy();		# u = x-1; x = x-1
  $x->bdiv($v,$scale);			# first term: u/v
  $below = $v->copy();
  $over = $u->copy();
  $u *= $u; $v *= $v;				# u^2, v^2
  $below->bmul($v);				# u^3, v^3
  $over->bmul($u);
  $factor = $self->new(3); $f = $self->new(2);

  my $steps = 0 if DEBUG;  
  $limit = $self->new("1E-". ($scale-1));
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop

    # calculating the next term simple from over/below will result in quite
    # a time hog if the input has many digits, since over and below will
    # accumulate more and more digits, and the result will also have many
    # digits, but in the end it is rounded to $scale digits anyway. So if we
    # round $over and $below first, we save a lot of time for the division
    # (not with log(1.2345), but try log (123**123) to see what I mean. This
    # can introduce a rounding error if the division result would be f.i.
    # 0.1234500000001 and we round it to 5 digits it would become 0.12346, but
    # if we truncated $over and $below we might get 0.12345. Does this matter
    # for the end result? So we give $over and $below 4 more digits to be
    # on the safe side (unscientific error handling as usual... :+D

    $next = $over->copy->bround($scale+4)->bdiv(
      $below->copy->bmul($factor)->bround($scale+4), 
      $scale);

## old version:    
##    $next = $over->copy()->bdiv($below->copy()->bmul($factor),$scale);

    last if $next->bacmp($limit) <= 0;

    delete $next->{_a}; delete $next->{_p};
    $x->badd($next);
    # calculate things for the next term
    $over *= $u; $below *= $v; $factor->badd($f);
    if (DEBUG)
      {
      $steps++; print "step $steps = $x\n" if $steps % 10 == 0;
      }
    }
  print "took $steps steps\n" if DEBUG;
  $x->bmul($f);					# $x *= 2
  }

sub _log_10
  {
  # Internal log function based on reducing input to the range of 0.1 .. 9.99
  # and then "correcting" the result to the proper one. Modifies $x in place.
  my ($self,$x,$scale) = @_;

  # Taking blog() from numbers greater than 10 takes a *very long* time, so we
  # break the computation down into parts based on the observation that:
  #  blog(X*Y) = blog(X) + blog(Y)
  # We set Y here to multiples of 10 so that $x becomes below 1 - the smaller
  # $x is the faster it gets. Since 2*$x takes about 10 times as
  # long, we make it faster by about a factor of 100 by dividing $x by 10.

  # The same observation is valid for numbers smaller than 0.1, e.g. computing
  # log(1) is fastest, and the further away we get from 1, the longer it takes.
  # So we also 'break' this down by multiplying $x with 10 and subtract the
  # log(10) afterwards to get the correct result.

  # To get $x even closer to 1, we also divide by 2 and then use log(2) to
  # correct for this. For instance if $x is 2.4, we use the formula:
  #  blog(2.4 * 2) == blog (1.2) + blog(2)
  # and thus calculate only blog(1.2) and blog(2), which is faster in total
  # than calculating blog(2.4).

  # In addition, the values for blog(2) and blog(10) are cached.

  # Calculate nr of digits before dot:
  my $dbd = $MBI->_num($x->{_e});
  $dbd = -$dbd if $x->{_es} eq '-';
  $dbd += $MBI->_len($x->{_m});

  # more than one digit (e.g. at least 10), but *not* exactly 10 to avoid
  # infinite recursion

  my $calc = 1;					# do some calculation?

  # disable the shortcut for 10, since we need log(10) and this would recurse
  # infinitely deep
  if ($x->{_es} eq '+' && $MBI->_is_one($x->{_e}) && $MBI->_is_one($x->{_m}))
    {
    $dbd = 0;					# disable shortcut
    # we can use the cached value in these cases
    if ($scale <= $LOG_10_A)
      {
      $x->bzero(); $x->badd($LOG_10);		# modify $x in place
      $calc = 0; 				# no need to calc, but round
      }
    # if we can't use the shortcut, we continue normally
    }
  else
    {
    # disable the shortcut for 2, since we maybe have it cached
    if (($MBI->_is_zero($x->{_e}) && $MBI->_is_two($x->{_m})))
      {
      $dbd = 0;					# disable shortcut
      # we can use the cached value in these cases
      if ($scale <= $LOG_2_A)
        {
        $x->bzero(); $x->badd($LOG_2);		# modify $x in place
        $calc = 0; 				# no need to calc, but round
        }
      # if we can't use the shortcut, we continue normally
      }
    }

  # if $x = 0.1, we know the result must be 0-log(10)
  if ($calc != 0 && $x->{_es} eq '-' && $MBI->_is_one($x->{_e}) &&
      $MBI->_is_one($x->{_m}))
    {
    $dbd = 0;					# disable shortcut
    # we can use the cached value in these cases
    if ($scale <= $LOG_10_A)
      {
      $x->bzero(); $x->bsub($LOG_10);
      $calc = 0; 				# no need to calc, but round
      }
    }

  return if $calc == 0;				# already have the result

  # default: these correction factors are undef and thus not used
  my $l_10;				# value of ln(10) to A of $scale
  my $l_2;				# value of ln(2) to A of $scale

  my $two = $self->new(2);

  # $x == 2 => 1, $x == 13 => 2, $x == 0.1 => 0, $x == 0.01 => -1
  # so don't do this shortcut for 1 or 0
  if (($dbd > 1) || ($dbd < 0))
    {
    # convert our cached value to an object if not already (avoid doing this
    # at import() time, since not everybody needs this)
    $LOG_10 = $self->new($LOG_10,undef,undef) unless ref $LOG_10;

    #print "x = $x, dbd = $dbd, calc = $calc\n";
    # got more than one digit before the dot, or more than one zero after the
    # dot, so do:
    #  log(123)    == log(1.23) + log(10) * 2
    #  log(0.0123) == log(1.23) - log(10) * 2
  
    if ($scale <= $LOG_10_A)
      {
      # use cached value
      $l_10 = $LOG_10->copy();		# copy for mul
      }
    else
      {
      # else: slower, compute and cache result
      # also disable downgrade for this code path
      local $Math::BigFloat::downgrade = undef;

      # shorten the time to calculate log(10) based on the following:
      # log(1.25 * 8) = log(1.25) + log(8)
      #               = log(1.25) + log(2) + log(2) + log(2)

      # first get $l_2 (and possible compute and cache log(2))
      $LOG_2 = $self->new($LOG_2,undef,undef) unless ref $LOG_2;
      if ($scale <= $LOG_2_A)
        {
        # use cached value
        $l_2 = $LOG_2->copy();			# copy() for the mul below
        }
      else
        {
        # else: slower, compute and cache result
        $l_2 = $two->copy(); $self->_log($l_2, $scale); # scale+4, actually
        $LOG_2 = $l_2->copy();			# cache the result for later
						# the copy() is for mul below
        $LOG_2_A = $scale;
        }

      # now calculate log(1.25):
      $l_10 = $self->new('1.25'); $self->_log($l_10, $scale); # scale+4, actually

      # log(1.25) + log(2) + log(2) + log(2):
      $l_10->badd($l_2);
      $l_10->badd($l_2);
      $l_10->badd($l_2);
      $LOG_10 = $l_10->copy();		# cache the result for later
					# the copy() is for mul below
      $LOG_10_A = $scale;
      }
    $dbd-- if ($dbd > 1); 		# 20 => dbd=2, so make it dbd=1	
    $l_10->bmul( $self->new($dbd));	# log(10) * (digits_before_dot-1)
    my $dbd_sign = '+';
    if ($dbd < 0)
      {
      $dbd = -$dbd;
      $dbd_sign = '-';
      }
    ($x->{_e}, $x->{_es}) = 
	_e_sub( $x->{_e}, $MBI->_new($dbd), $x->{_es}, $dbd_sign); # 123 => 1.23
 
    }

  # Now: 0.1 <= $x < 10 (and possible correction in l_10)

  ### Since $x in the range 0.5 .. 1.5 is MUCH faster, we do a repeated div
  ### or mul by 2 (maximum times 3, since x < 10 and x > 0.1)

  $HALF = $self->new($HALF) unless ref($HALF);

  my $twos = 0;				# default: none (0 times)	
  while ($x->bacmp($HALF) <= 0)		# X <= 0.5
    {
    $twos--; $x->bmul($two);
    }
  while ($x->bacmp($two) >= 0)		# X >= 2
    {
    $twos++; $x->bdiv($two,$scale+4);		# keep all digits
    }
  # $twos > 0 => did mul 2, < 0 => did div 2 (but we never did both)
  # So calculate correction factor based on ln(2):
  if ($twos != 0)
    {
    $LOG_2 = $self->new($LOG_2,undef,undef) unless ref $LOG_2;
    if ($scale <= $LOG_2_A)
      {
      # use cached value
      $l_2 = $LOG_2->copy();			# copy() for the mul below
      }
    else
      {
      # else: slower, compute and cache result
      # also disable downgrade for this code path
      local $Math::BigFloat::downgrade = undef;
      $l_2 = $two->copy(); $self->_log($l_2, $scale); # scale+4, actually
      $LOG_2 = $l_2->copy();			# cache the result for later
						# the copy() is for mul below
      $LOG_2_A = $scale;
      }
    $l_2->bmul($twos);		# * -2 => subtract, * 2 => add
    }
  
  $self->_log($x,$scale);			# need to do the "normal" way
  $x->badd($l_10) if defined $l_10; 		# correct it by ln(10)
  $x->badd($l_2) if defined $l_2;		# and maybe by ln(2)

  # all done, $x contains now the result
  $x;
  }

sub blcm 
  { 
  # (BFLOAT or num_str, BFLOAT or num_str) return BFLOAT
  # does not modify arguments, but returns new object
  # Lowest Common Multiplicator

  my ($self,@arg) = objectify(0,@_);
  my $x = $self->new(shift @arg);
  while (@arg) { $x = Math::BigInt::__lcm($x,shift @arg); } 
  $x;
  }

sub bgcd
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object

  my $y = shift;
  $y = __PACKAGE__->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy()->babs();			# keep arguments

  return $x->bnan() if $x->{sign} !~ /^[+-]$/	# x NaN?
	|| !$x->is_int();			# only for integers now

  while (@_)
    {
    my $t = shift; $t = $self->new($t) if !ref($t);
    $y = $t->copy()->babs();
    
    return $x->bnan() if $y->{sign} !~ /^[+-]$/	# y NaN?
     	|| !$y->is_int();			# only for integers now

    # greatest common divisor
    while (! $y->is_zero())
      {
      ($x,$y) = ($y->copy(), $x->copy()->bmod($y));
      }

    last if $x->is_one();
    }
  $x;
  }

##############################################################################

sub _e_add
  {
  # Internal helper sub to take two positive integers and their signs and
  # then add them. Input ($CALC,$CALC,('+'|'-'),('+'|'-')), 
  # output ($CALC,('+'|'-'))
  my ($x,$y,$xs,$ys) = @_;

  # if the signs are equal we can add them (-5 + -3 => -(5 + 3) => -8)
  if ($xs eq $ys)
    {
    $x = $MBI->_add ($x, $y );		# a+b
    # the sign follows $xs
    return ($x, $xs);
    }

  my $a = $MBI->_acmp($x,$y);
  if ($a > 0)
    {
    $x = $MBI->_sub ($x , $y);				# abs sub
    }
  elsif ($a == 0)
    {
    $x = $MBI->_zero();					# result is 0
    $xs = '+';
    }
  else # a < 0
    {
    $x = $MBI->_sub ( $y, $x, 1 );			# abs sub
    $xs = $ys;
    }
  ($x,$xs);
  }

sub _e_sub
  {
  # Internal helper sub to take two positive integers and their signs and
  # then subtract them. Input ($CALC,$CALC,('+'|'-'),('+'|'-')), 
  # output ($CALC,('+'|'-'))
  my ($x,$y,$xs,$ys) = @_;

  # flip sign
  $ys =~ tr/+-/-+/;
  _e_add($x,$y,$xs,$ys);		# call add (does subtract now)
  }

###############################################################################
# is_foo methods (is_negative, is_positive are inherited from BigInt)

sub is_int
  {
  # return true if arg (BFLOAT or num_str) is an integer
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  (($x->{sign} =~ /^[+-]$/) &&			# NaN and +-inf aren't
   ($x->{_es} eq '+')) ? 1 : 0;			# 1e-1 => no integer
  }

sub is_zero
  {
  # return true if arg (BFLOAT or num_str) is zero
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  ($x->{sign} eq '+' && $MBI->_is_zero($x->{_m})) ? 1 : 0;
  }

sub is_one
  {
  # return true if arg (BFLOAT or num_str) is +1 or -1 if signis given
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@_) : objectify(1,@_);

  $sign = '+' if !defined $sign || $sign ne '-';

  ($x->{sign} eq $sign && 
   $MBI->_is_zero($x->{_e}) &&
   $MBI->_is_one($x->{_m}) ) ? 1 : 0; 
  }

sub is_odd
  {
  # return true if arg (BFLOAT or num_str) is odd or false if even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);
  
  (($x->{sign} =~ /^[+-]$/) &&		# NaN & +-inf aren't
   ($MBI->_is_zero($x->{_e})) &&
   ($MBI->_is_odd($x->{_m}))) ? 1 : 0; 
  }

sub is_even
  {
  # return true if arg (BINT or num_str) is even or false if odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  (($x->{sign} =~ /^[+-]$/) &&			# NaN & +-inf aren't
   ($x->{_es} eq '+') &&	 		# 123.45 isn't
   ($MBI->_is_even($x->{_m}))) ? 1 : 0;		# but 1200 is
  }

sub bmul
  { 
  # multiply two numbers
  
  # set up parameters
  my ($self,$x,$y,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@r) = objectify(2,@_);
    }

  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero(); 
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }
  
  return $upgrade->bmul($x,$y,@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  # aEb * cEd = (a*c)E(b+d)
  $MBI->_mul($x->{_m},$y->{_m});
  ($x->{_e}, $x->{_es}) = _e_add($x->{_e}, $y->{_e}, $x->{_es}, $y->{_es});

  $r[3] = $y;				# no push!

  # adjust sign:
  $x->{sign} = $x->{sign} ne $y->{sign} ? '-' : '+';
  $x->bnorm->round(@r);
  }

sub bmuladd
  { 
  # multiply two numbers and add the third to the result
  
  # set up parameters
  my ($self,$x,$y,$z,@r) = objectify(3,@_);

  return $x if $x->modify('bmuladd');

  return $x->bnan() if (($x->{sign} eq $nan) ||
			($y->{sign} eq $nan) ||
			($z->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero(); 
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  return $upgrade->bmul($x,$y,@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  # aEb * cEd = (a*c)E(b+d)
  $MBI->_mul($x->{_m},$y->{_m});
  ($x->{_e}, $x->{_es}) = _e_add($x->{_e}, $y->{_e}, $x->{_es}, $y->{_es});

  $r[3] = $y;				# no push!

  # adjust sign:
  $x->{sign} = $x->{sign} ne $y->{sign} ? '-' : '+';

  # z=inf handling (z=NaN handled above)
  $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;

  # take lower of the two e's and adapt m1 to it to match m2
  my $e = $z->{_e};
  $e = $MBI->_zero() if !defined $e;		# if no BFLOAT?
  $e = $MBI->_copy($e);				# make copy (didn't do it yet)

  my $es;

  ($e,$es) = _e_sub($e, $x->{_e}, $z->{_es} || '+', $x->{_es});

  my $add = $MBI->_copy($z->{_m});

  if ($es eq '-')				# < 0
    {
    $MBI->_lsft( $x->{_m}, $e, 10);
    ($x->{_e},$x->{_es}) = _e_add($x->{_e}, $e, $x->{_es}, $es);
    }
  elsif (!$MBI->_is_zero($e))			# > 0
    {
    $MBI->_lsft($add, $e, 10);
    }
  # else: both e are the same, so just leave them

  if ($x->{sign} eq $z->{sign})
    {
    # add
    $x->{_m} = $MBI->_add($x->{_m}, $add);
    }
  else
    {
    ($x->{_m}, $x->{sign}) = 
     _e_add($x->{_m}, $add, $x->{sign}, $z->{sign});
    }

  # delete trailing zeros, then round
  $x->bnorm()->round(@r);
  }

sub bdiv 
  {
  # (dividend: BFLOAT or num_str, divisor: BFLOAT or num_str) return 
  # (BFLOAT,BFLOAT) (quo,rem) or BFLOAT (only rem)

  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('bdiv');

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  # x== 0 # also: or y == 1 or y == -1
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # upgrade ?
  return $upgrade->bdiv($upgrade->new($x),$y,$a,$p,$r) if defined $upgrade;

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my (@params,$scale);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r,$y);

  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4;	# take whatever is defined
    }

  my $rem; $rem = $self->bzero() if wantarray;

  $y = $self->new($y) unless $y->isa('Math::BigFloat');

  my $lx = $MBI->_len($x->{_m}); my $ly = $MBI->_len($y->{_m});
  $scale = $lx if $lx > $scale;
  $scale = $ly if $ly > $scale;
  my $diff = $ly - $lx;
  $scale += $diff if $diff > 0;		# if lx << ly, but not if ly << lx!

  # already handled inf/NaN/-inf above:

  # check that $y is not 1 nor -1 and cache the result:
  my $y_not_one = !($MBI->_is_zero($y->{_e}) && $MBI->_is_one($y->{_m}));

  # flipping the sign of $y will also flip the sign of $x for the special
  # case of $x->bsub($x); so we can catch it below:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+-/-+/;

  if ($xsign ne $x->{sign})
    {
    # special case of $x /= $x results in 1
    $x->bone();			# "fixes" also sign of $y, since $x is $y
    }
  else
    {
    # correct $y's sign again
    $y->{sign} =~ tr/+-/-+/;
    # continue with normal div code:

    # make copy of $x in case of list context for later remainder calculation
    if (wantarray && $y_not_one)
      {
      $rem = $x->copy();
      }

    $x->{sign} = $x->{sign} ne $y->sign() ? '-' : '+'; 

    # check for / +-1 ( +/- 1E0)
    if ($y_not_one)
      {
      # promote BigInts and it's subclasses (except when already a BigFloat)
      $y = $self->new($y) unless $y->isa('Math::BigFloat'); 

      # calculate the result to $scale digits and then round it
      # a * 10 ** b / c * 10 ** d => a/c * 10 ** (b-d)
      $MBI->_lsft($x->{_m},$MBI->_new($scale),10);
      $MBI->_div ($x->{_m},$y->{_m});	# a/c

      # correct exponent of $x
      ($x->{_e},$x->{_es}) = _e_sub($x->{_e}, $y->{_e}, $x->{_es}, $y->{_es});
      # correct for 10**scale
      ($x->{_e},$x->{_es}) = _e_sub($x->{_e}, $MBI->_new($scale), $x->{_es}, '+');
      $x->bnorm();		# remove trailing 0's
      }
    } # end else $x != $y

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    delete $x->{_a}; 				# clear before round
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    delete $x->{_p}; 				# clear before round
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }

  if (wantarray)
    {
    if ($y_not_one)
      {
      $rem->bmod($y,@params);			# copy already done
      }
    if ($fallback)
      {
      # clear a/p after round, since user did not request it
      delete $rem->{_a}; delete $rem->{_p};
      }
    return ($x,$rem);
    }
  $x;
  }

sub bmod 
  {
  # (dividend: BFLOAT or num_str, divisor: BFLOAT or num_str) return remainder

  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('bmod');

  # handle NaN, inf, -inf
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    my ($d,$re) = $self->SUPER::_div_inf($x,$y);
    $x->{sign} = $re->{sign};
    $x->{_e} = $re->{_e};
    $x->{_m} = $re->{_m};
    return $x->round($a,$p,$r,$y);
    } 
  if ($y->is_zero())
    {
    return $x->bnan() if $x->is_zero();
    return $x;
    }

  return $x->bzero() if $x->is_zero()
 || ($x->is_int() &&
  # check that $y == +1 or $y == -1:
    ($MBI->_is_zero($y->{_e}) && $MBI->_is_one($y->{_m})));

  my $cmp = $x->bacmp($y);			# equal or $x < $y?
  return $x->bzero($a,$p) if $cmp == 0;		# $x == $y => result 0

  # only $y of the operands negative? 
  my $neg = 0; $neg = 1 if $x->{sign} ne $y->{sign};

  $x->{sign} = $y->{sign};				# calc sign first
  return $x->round($a,$p,$r) if $cmp < 0 && $neg == 0;	# $x < $y => result $x
  
  my $ym = $MBI->_copy($y->{_m});
  
  # 2e1 => 20
  $MBI->_lsft( $ym, $y->{_e}, 10) 
   if $y->{_es} eq '+' && !$MBI->_is_zero($y->{_e});
 
  # if $y has digits after dot
  my $shifty = 0;			# correct _e of $x by this
  if ($y->{_es} eq '-')			# has digits after dot
    {
    # 123 % 2.5 => 1230 % 25 => 5 => 0.5
    $shifty = $MBI->_num($y->{_e}); 	# no more digits after dot
    $MBI->_lsft($x->{_m}, $y->{_e}, 10);# 123 => 1230, $y->{_m} is already 25
    }
  # $ym is now mantissa of $y based on exponent 0

  my $shiftx = 0;			# correct _e of $x by this
  if ($x->{_es} eq '-')			# has digits after dot
    {
    # 123.4 % 20 => 1234 % 200
    $shiftx = $MBI->_num($x->{_e});	# no more digits after dot
    $MBI->_lsft($ym, $x->{_e}, 10);	# 123 => 1230
    }
  # 123e1 % 20 => 1230 % 20
  if ($x->{_es} eq '+' && !$MBI->_is_zero($x->{_e}))
    {
    $MBI->_lsft( $x->{_m}, $x->{_e},10);	# es => '+' here
    }

  $x->{_e} = $MBI->_new($shiftx);
  $x->{_es} = '+'; 
  $x->{_es} = '-' if $shiftx != 0 || $shifty != 0;
  $MBI->_add( $x->{_e}, $MBI->_new($shifty)) if $shifty != 0;
  
  # now mantissas are equalized, exponent of $x is adjusted, so calc result

  $x->{_m} = $MBI->_mod( $x->{_m}, $ym);

  $x->{sign} = '+' if $MBI->_is_zero($x->{_m});		# fix sign for -0
  $x->bnorm();

  if ($neg != 0)	# one of them negative => correct in place
    {
    my $r = $y - $x;
    $x->{_m} = $r->{_m};
    $x->{_e} = $r->{_e};
    $x->{_es} = $r->{_es};
    $x->{sign} = '+' if $MBI->_is_zero($x->{_m});	# fix sign for -0
    $x->bnorm();
    }

  $x->round($a,$p,$r,$y);	# round and return
  }

sub broot
  {
  # calculate $y'th root of $x
  
  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();
  
  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my (@params,$scale);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0) 
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;	# should be really parent class vs MBI

  # remember sign and make $x positive, since -4 ** (1/2) => -2
  my $sign = 0; $sign = 1 if $x->{sign} eq '-'; $x->{sign} = '+';

  my $is_two = 0;
  if ($y->isa('Math::BigFloat'))
    {
    $is_two = ($y->{sign} eq '+' && $MBI->_is_two($y->{_m}) && $MBI->_is_zero($y->{_e}));
    }
  else
    {
    $is_two = ($y == 2);
    }

  # normal square root if $y == 2:
  if ($is_two)
    {
    $x->bsqrt($scale+4);
    }
  elsif ($y->is_one('-'))
    {
    # $x ** -1 => 1/$x
    my $u = $self->bone()->bdiv($x,$scale);
    # copy private parts over
    $x->{_m} = $u->{_m};
    $x->{_e} = $u->{_e};
    $x->{_es} = $u->{_es};
    }
  else
    {
    # calculate the broot() as integer result first, and if it fits, return
    # it rightaway (but only if $x and $y are integer):

    my $done = 0;				# not yet
    if ($y->is_int() && $x->is_int())
      {
      my $i = $MBI->_copy( $x->{_m} );
      $MBI->_lsft( $i, $x->{_e}, 10 ) unless $MBI->_is_zero($x->{_e});
      my $int = Math::BigInt->bzero();
      $int->{value} = $i;
      $int->broot($y->as_number());
      # if ($exact)
      if ($int->copy()->bpow($y) == $x)
        {
        # found result, return it
        $x->{_m} = $int->{value};
        $x->{_e} = $MBI->_zero();
        $x->{_es} = '+';
        $x->bnorm();
        $done = 1;
        }
      }
    if ($done == 0)
      {
      my $u = $self->bone()->bdiv($y,$scale+4);
      delete $u->{_a}; delete $u->{_p};         # otherwise it conflicts
      $x->bpow($u,$scale+4);                    # el cheapo
      }
    }
  $x->bneg() if $sign == 1;
  
  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bsqrt
  { 
  # calculate square root
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} !~ /^[+]/;	# NaN, -inf or < 0
  return $x if $x->{sign} eq '+inf';		# sqrt(inf) == inf
  return $x->round($a,$p,$r) if $x->is_zero() || $x->is_one();

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my (@params,$scale);
  ($x,@params) = $x->_find_round_parameters($a,$p,$r);

  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0) 
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r;			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;	# should be really parent class vs MBI

  my $i = $MBI->_copy( $x->{_m} );
  $MBI->_lsft( $i, $x->{_e}, 10 ) unless $MBI->_is_zero($x->{_e});
  my $xas = Math::BigInt->bzero();
  $xas->{value} = $i;

  my $gs = $xas->copy()->bsqrt();	# some guess

  if (($x->{_es} ne '-')		# guess can't be accurate if there are
					# digits after the dot
   && ($xas->bacmp($gs * $gs) == 0))	# guess hit the nail on the head?
    {
    # exact result, copy result over to keep $x
    $x->{_m} = $gs->{value}; $x->{_e} = $MBI->_zero(); $x->{_es} = '+';
    $x->bnorm();
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);	# then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);	# then round accordingly
      }
    if ($fallback)
      {
      # clear a/p after round, since user did not request it
      delete $x->{_a}; delete $x->{_p};
      }
    # re-enable A and P, upgrade is taken care of by "local"
    ${"$self\::accuracy"} = $ab; ${"$self\::precision"} = $pb;
    return $x;
    }
 
  # sqrt(2) = 1.4 because sqrt(2*100) = 1.4*10; so we can increase the accuracy
  # of the result by multiplying the input by 100 and then divide the integer
  # result of sqrt(input) by 10. Rounding afterwards returns the real result.

  # The following steps will transform 123.456 (in $x) into 123456 (in $y1)
  my $y1 = $MBI->_copy($x->{_m});

  my $length = $MBI->_len($y1);
  
  # Now calculate how many digits the result of sqrt(y1) would have
  my $digits = int($length / 2);

  # But we need at least $scale digits, so calculate how many are missing
  my $shift = $scale - $digits;

  # This happens if the input had enough digits
  # (we take care of integer guesses above)
  $shift = 0 if $shift < 0; 

  # Multiply in steps of 100, by shifting left two times the "missing" digits
  my $s2 = $shift * 2;

  # We now make sure that $y1 has the same odd or even number of digits than
  # $x had. So when _e of $x is odd, we must shift $y1 by one digit left,
  # because we always must multiply by steps of 100 (sqrt(100) is 10) and not
  # steps of 10. The length of $x does not count, since an even or odd number
  # of digits before the dot is not changed by adding an even number of digits
  # after the dot (the result is still odd or even digits long).
  $s2++ if $MBI->_is_odd($x->{_e});

  $MBI->_lsft( $y1, $MBI->_new($s2), 10);

  # now take the square root and truncate to integer
  $y1 = $MBI->_sqrt($y1);

  # By "shifting" $y1 right (by creating a negative _e) we calculate the final
  # result, which is than later rounded to the desired scale.

  # calculate how many zeros $x had after the '.' (or before it, depending
  # on sign of $dat, the result should have half as many:
  my $dat = $MBI->_num($x->{_e});
  $dat = -$dat if $x->{_es} eq '-';
  $dat += $length;

  if ($dat > 0)
    {
    # no zeros after the dot (e.g. 1.23, 0.49 etc)
    # preserve half as many digits before the dot than the input had 
    # (but round this "up")
    $dat = int(($dat+1)/2);
    }
  else
    {
    $dat = int(($dat)/2);
    }
  $dat -= $MBI->_len($y1);
  if ($dat < 0)
    {
    $dat = abs($dat);
    $x->{_e} = $MBI->_new( $dat );
    $x->{_es} = '-';
    }
  else
    {    
    $x->{_e} = $MBI->_new( $dat );
    $x->{_es} = '+';
    }
  $x->{_m} = $y1;
  $x->bnorm();

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bfac
  {
  # (BFLOAT or num_str, BFLOAT or num_str) return BFLOAT
  # compute factorial number, modifies first argument

  # set up parameters
  my ($self,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  ($self,$x,@r) = objectify(1,@_) if !ref($x);

  # inf => inf
  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';	

  return $x->bnan() 
    if (($x->{sign} ne '+') ||		# inf, NaN, <0 etc => NaN
     ($x->{_es} ne '+'));		# digits after dot?

  # use BigInt's bfac() for faster calc
  if (! $MBI->_is_zero($x->{_e}))
    {
    $MBI->_lsft($x->{_m}, $x->{_e},10);	# change 12e1 to 120e0
    $x->{_e} = $MBI->_zero();		# normalize
    $x->{_es} = '+';
    }
  $MBI->_fac($x->{_m});			# calculate factorial
  $x->bnorm()->round(@r); 		# norm again and round result
  }

sub _pow
  {
  # Calculate a power where $y is a non-integer, like 2 ** 0.3
  my ($x,$y,@r) = @_;
  my $self = ref($x);

  # if $y == 0.5, it is sqrt($x)
  $HALF = $self->new($HALF) unless ref($HALF);
  return $x->bsqrt(@r,$y) if $y->bcmp($HALF) == 0;

  # Using:
  # a ** x == e ** (x * ln a)

  # u = y * ln x
  #                _                         _
  # Taylor:       |   u    u^2    u^3         |
  # x ** y  = 1 + |  --- + --- + ----- + ...  |
  #               |_  1    1*2   1*2*3       _|

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  return $x if $x->is_nan();		# error in _find_round_parameters?

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my ($limit,$v,$u,$below,$factor,$next,$over);

  $u = $x->copy()->blog(undef,$scale)->bmul($y);
  $v = $self->bone();				# 1
  $factor = $self->new(2);			# 2
  $x->bone();					# first term: 1

  $below = $v->copy();
  $over = $u->copy();

  $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;
    $x->badd($next);
    # calculate things for the next term
    $over *= $u; $below *= $factor; $factor->binc();

    last if $x->{sign} !~ /^[-+]$/;

    #$steps++;
    }
  
  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bpow 
  {
  # (BFLOAT or num_str, BFLOAT or num_str) return BFLOAT
  # compute power of two numbers, second arg is used as integer
  # modifies first argument

  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('bpow');

  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
  return $x if $x->{sign} =~ /^[+-]inf$/;
  
  # cache the result of is_zero
  my $y_is_zero = $y->is_zero();
  return $x->bone() if $y_is_zero;
  return $x         if $x->is_one() || $y->is_one();

  my $x_is_zero = $x->is_zero();
  return $x->_pow($y,$a,$p,$r) if !$x_is_zero && !$y->is_int();		# non-integer power

  my $y1 = $y->as_number()->{value};			# make MBI part

  # if ($x == -1)
  if ($x->{sign} eq '-' && $MBI->_is_one($x->{_m}) && $MBI->_is_zero($x->{_e}))
    {
    # if $x == -1 and odd/even y => +1/-1  because +-1 ^ (+-1) => +-1
    return $MBI->_is_odd($y1) ? $x : $x->babs(1);
    }
  if ($x_is_zero)
    {
    return $x if $y->{sign} eq '+'; 	# 0**y => 0 (if not y <= 0)
    # 0 ** -y => 1 / (0 ** y) => 1 / 0! (1 / 0 => +inf)
    return $x->binf();
    }

  my $new_sign = '+';
  $new_sign = $MBI->_is_odd($y1) ? '-' : '+' if $x->{sign} ne '+';

  # calculate $x->{_m} ** $y and $x->{_e} * $y separately (faster)
  $x->{_m} = $MBI->_pow( $x->{_m}, $y1);
  $x->{_e} = $MBI->_mul ($x->{_e}, $y1);

  $x->{sign} = $new_sign;
  $x->bnorm();
  if ($y->{sign} eq '-')
    {
    # modify $x in place!
    my $z = $x->copy(); $x->bone();
    return scalar $x->bdiv($z,$a,$p,$r);	# round in one go (might ignore y's A!)
    }
  $x->round($a,$p,$r,$y);
  }

sub bmodpow
  {
  # takes a very large number to a very large exponent in a given very
  # large modulus, quickly, thanks to binary exponentiation. Supports
  # negative exponents.
  my ($self,$num,$exp,$mod,@r) = objectify(3,@_);

  return $num if $num->modify('bmodpow');

  # check modulus for valid values
  return $num->bnan() if ($mod->{sign} ne '+'           # NaN, - , -inf, +inf
                       || $mod->is_zero());

  # check exponent for valid values
  if ($exp->{sign} =~ /\w/)
    {
    # i.e., if it's NaN, +inf, or -inf...
    return $num->bnan();
    }

  $num->bmodinv ($mod) if ($exp->{sign} eq '-');

  # check num for valid values (also NaN if there was no inverse but $exp < 0)
  return $num->bnan() if $num->{sign} !~ /^[+-]$/;

  # $mod is positive, sign on $exp is ignored, result also positive

  # XXX TODO: speed it up when all three numbers are integers
  $num->bpow($exp)->bmod($mod);
  }

###############################################################################
# trigonometric functions

# helper function for bpi() and batan2(), calculates arcus tanges (1/x)

sub _atan_inv
  {
  # return a/b so that a/b approximates atan(1/x) to at least limit digits
  my ($self, $x, $limit) = @_;

  # Taylor:       x^3   x^5   x^7   x^9
  #    atan = x - --- + --- - --- + --- - ...
  #                3     5     7     9 

  #               1      1         1        1
  #    atan 1/x = - - ------- + ------- - ------- + ...
  #               x   x^3 * 3   x^5 * 5   x^7 * 7 

  #               1      1         1            1
  #    atan 1/x = - - --------- + ---------- - ----------- + ... 
  #               5    3 * 125     5 * 3125     7 * 78125

  # Subtraction/addition of a rational:

  #  5    7    5*3 +- 7*4
  #  - +- -  = ----------
  #  4    3       4*3

  # Term:  N        N+1
  #
  #        a             1                  a * d * c +- b
  #        ----- +- ------------------  =  ----------------
  #        b           d * c                b * d * c

  #  since b1 = b0 * (d-2) * c

  #        a             1                  a * d +- b / c
  #        ----- +- ------------------  =  ----------------
  #        b           d * c                b * d 

  # and  d = d + 2
  # and  c = c * x * x

  #        u = d * c
  #        stop if length($u) > limit 
  #        a = a * u +- b
  #        b = b * u
  #        d = d + 2
  #        c = c * x * x
  #        sign = 1 - sign

  my $a = $MBI->_one();
  my $b = $MBI->_copy($x);
 
  my $x2  = $MBI->_mul( $MBI->_copy($x), $b);		# x2 = x * x
  my $d   = $MBI->_new( 3 );				# d = 3
  my $c   = $MBI->_mul( $MBI->_copy($x), $x2);		# c = x ^ 3
  my $two = $MBI->_new( 2 );

  # run the first step unconditionally
  my $u = $MBI->_mul( $MBI->_copy($d), $c);
  $a = $MBI->_mul($a, $u);
  $a = $MBI->_sub($a, $b);
  $b = $MBI->_mul($b, $u);
  $d = $MBI->_add($d, $two);
  $c = $MBI->_mul($c, $x2);

  # a is now a * (d-3) * c
  # b is now b * (d-2) * c

  # run the second step unconditionally
  $u = $MBI->_mul( $MBI->_copy($d), $c);
  $a = $MBI->_mul($a, $u);
  $a = $MBI->_add($a, $b);
  $b = $MBI->_mul($b, $u);
  $d = $MBI->_add($d, $two);
  $c = $MBI->_mul($c, $x2);

  # a is now a * (d-3) * (d-5) * c * c  
  # b is now b * (d-2) * (d-4) * c * c

  # so we can remove c * c from both a and b to shorten the numbers involved:
  $a = $MBI->_div($a, $x2);
  $b = $MBI->_div($b, $x2);
  $a = $MBI->_div($a, $x2);
  $b = $MBI->_div($b, $x2);

#  my $step = 0; 
  my $sign = 0;						# 0 => -, 1 => +
  while (3 < 5)
    {
#    $step++;
#    if (($i++ % 100) == 0)
#      {
#    print "a=",$MBI->_str($a),"\n";
#    print "b=",$MBI->_str($b),"\n";
#      }
#    print "d=",$MBI->_str($d),"\n";
#    print "x2=",$MBI->_str($x2),"\n";
#    print "c=",$MBI->_str($c),"\n";

    my $u = $MBI->_mul( $MBI->_copy($d), $c);
    # use _alen() for libs like GMP where _len() would be O(N^2)
    last if $MBI->_alen($u) > $limit;
    my ($bc,$r) = $MBI->_div( $MBI->_copy($b), $c);
    if ($MBI->_is_zero($r))
      {
      # b / c is an integer, so we can remove c from all terms
      # this happens almost every time:
      $a = $MBI->_mul($a, $d);
      $a = $MBI->_sub($a, $bc) if $sign == 0;
      $a = $MBI->_add($a, $bc) if $sign == 1;
      $b = $MBI->_mul($b, $d);
      }
    else
      {
      # b / c is not an integer, so we keep c in the terms
      # this happens very rarely, for instance for x = 5, this happens only
      # at the following steps:
      # 1, 5, 14, 32, 72, 157, 340, ...
      $a = $MBI->_mul($a, $u);
      $a = $MBI->_sub($a, $b) if $sign == 0;
      $a = $MBI->_add($a, $b) if $sign == 1;
      $b = $MBI->_mul($b, $u);
      }
    $d = $MBI->_add($d, $two);
    $c = $MBI->_mul($c, $x2);
    $sign = 1 - $sign;

    }

#  print "Took $step steps for ", $MBI->_str($x),"\n";
#  print "a=",$MBI->_str($a),"\n"; print "b=",$MBI->_str($b),"\n";
  # return a/b so that a/b approximates atan(1/x)
  ($a,$b);
  }

sub bpi
  {
  my ($self,$n) = @_;
  if (@_ == 0)
    {
    $self = $class;
    }
  if (@_ == 1)
    {
    # called like Math::BigFloat::bpi(10);
    $n = $self; $self = $class;
    # called like Math::BigFloat->bpi();
    $n = undef if $n eq 'Math::BigFloat';
    }
  $self = ref($self) if ref($self);
  my $fallback = defined $n ? 0 : 1;
  $n = 40 if !defined $n || $n < 1;

  # after  (Hwang Chien-Lih) (1997)
  # pi/4 = 183 * atan(1/239) + 32 * atan(1/1023)  68 * atan(1/5832)
  #	 + 12 * atan(1/110443) - 12 * atan(1/4841182) - 100 * atan(1/6826318)

  # a few more to prevent rounding errors
  $n += 4;

  my ($a,$b) = $self->_atan_inv( $MBI->_new(239),$n);
  my ($c,$d) = $self->_atan_inv( $MBI->_new(1023),$n);
  my ($e,$f) = $self->_atan_inv( $MBI->_new(5832),$n);
  my ($g,$h) = $self->_atan_inv( $MBI->_new(110443),$n);
  my ($i,$j) = $self->_atan_inv( $MBI->_new(4841182),$n);
  my ($k,$l) = $self->_atan_inv( $MBI->_new(6826318),$n);

  $MBI->_mul($a, $MBI->_new(732));
  $MBI->_mul($c, $MBI->_new(128));
  $MBI->_mul($e, $MBI->_new(272));
  $MBI->_mul($g, $MBI->_new(48));
  $MBI->_mul($i, $MBI->_new(48));
  $MBI->_mul($k, $MBI->_new(400));

  my $x = $self->bone(); $x->{_m} = $a; my $x_d = $self->bone(); $x_d->{_m} = $b;
  my $y = $self->bone(); $y->{_m} = $c; my $y_d = $self->bone(); $y_d->{_m} = $d;
  my $z = $self->bone(); $z->{_m} = $e; my $z_d = $self->bone(); $z_d->{_m} = $f;
  my $u = $self->bone(); $u->{_m} = $g; my $u_d = $self->bone(); $u_d->{_m} = $h;
  my $v = $self->bone(); $v->{_m} = $i; my $v_d = $self->bone(); $v_d->{_m} = $j;
  my $w = $self->bone(); $w->{_m} = $k; my $w_d = $self->bone(); $w_d->{_m} = $l;
  $x->bdiv($x_d, $n);
  $y->bdiv($y_d, $n);
  $z->bdiv($z_d, $n);
  $u->bdiv($u_d, $n);
  $v->bdiv($v_d, $n);
  $w->bdiv($w_d, $n);

  delete $x->{_a}; delete $y->{_a}; delete $z->{_a};
  delete $u->{_a}; delete $v->{_a}; delete $w->{_a};
  $x->badd($y)->bsub($z)->badd($u)->bsub($v)->bsub($w);

  $x->bround($n-4);
  delete $x->{_a} if $fallback == 1;
  $x;
  }

sub bcos
  {
  # Calculate a cosinus of x.
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # Taylor:      x^2   x^4   x^6   x^8
  #    cos = 1 - --- + --- - --- + --- ...
  #               2!    4!    6!    8!

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  #         constant object       or error in _find_round_parameters?
  return $x if $x->modify('bcos') || $x->is_nan();

  return $x->bone(@r) if $x->is_zero();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my $last = 0;
  my $over = $x * $x;                   # X ^ 2
  my $x2 = $over->copy();               # X ^ 2; difference between terms
  my $sign = 1;                         # start with -=
  my $below = $self->new(2); my $factorial = $self->new(3);
  $x->bone(); delete $x->{_a}; delete $x->{_p};

  my $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    my $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;

    if ($sign == 0)
      {
      $x->badd($next);
      }
    else
      {
      $x->bsub($next);
      }
    $sign = 1-$sign;					# alternate
    # calculate things for the next term
    $over->bmul($x2);					# $x*$x
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    }

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub bsin
  {
  # Calculate a sinus of x.
  my ($self,$x,@r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  # taylor:      x^3   x^5   x^7   x^9
  #    sin = x - --- + --- - --- + --- ...
  #               3!    5!    7!    9!

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  #         constant object       or error in _find_round_parameters?
  return $x if $x->modify('bsin') || $x->is_nan();

  return $x->bzero(@r) if $x->is_zero();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my $last = 0;
  my $over = $x * $x;			# X ^ 2
  my $x2 = $over->copy();		# X ^ 2; difference between terms
  $over->bmul($x);			# X ^ 3 as starting value
  my $sign = 1;				# start with -=
  my $below = $self->new(6); my $factorial = $self->new(4);
  delete $x->{_a}; delete $x->{_p};

  my $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    my $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;

    if ($sign == 0)
      {
      $x->badd($next);
      }
    else
      {
      $x->bsub($next);
      }
    $sign = 1-$sign;					# alternate
    # calculate things for the next term
    $over->bmul($x2);					# $x*$x
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    $below->bmul($factorial); $factorial->binc();	# n*(n+1)
    }

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

sub batan2
  { 
  # calculate arcus tangens of ($y/$x)
  
  # set up parameters
  my ($self,$y,$x,@r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$y,$x,@r) = objectify(2,@_);
    }

  return $y if $y->modify('batan2');

  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);

  # Y X
  # 0 0 result is 0
  # 0 +x result is 0
  # ? inf result is 0
  return $y->bzero(@r) if ($x->is_inf('+') && !$y->is_inf()) || ($y->is_zero() && $x->{sign} eq '+');

  # Y    X
  # != 0 -inf result is +- pi
  if ($x->is_inf() || $y->is_inf())
    {
    # calculate PI
    my $pi = $self->bpi(@r);
    if ($y->is_inf())
      {
      # upgrade to BigRat etc. 
      return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;
      if ($x->{sign} eq '-inf')
        {
        # calculate 3 pi/4
        $MBI->_mul($pi->{_m}, $MBI->_new(3));
        $MBI->_div($pi->{_m}, $MBI->_new(4));
        }
      elsif ($x->{sign} eq '+inf')
	{
        # calculate pi/4
        $MBI->_div($pi->{_m}, $MBI->_new(4));
	}
      else
        {
        # calculate pi/2
        $MBI->_div($pi->{_m}, $MBI->_new(2));
        }
      $y->{sign} = substr($y->{sign},0,1); # keep +/-
      }
    # modify $y in place
    $y->{_m} = $pi->{_m};
    $y->{_e} = $pi->{_e};
    $y->{_es} = $pi->{_es};
    # keep the sign of $y
    return $y;
    }

  return $upgrade->new($y)->batan2($upgrade->new($x),@r) if defined $upgrade;

  # Y X
  # 0 -x result is PI
  if ($y->is_zero())
    {
    # calculate PI
    my $pi = $self->bpi(@r);
    # modify $y in place
    $y->{_m} = $pi->{_m};
    $y->{_e} = $pi->{_e};
    $y->{_es} = $pi->{_es};
    $y->{sign} = '+';
    return $y;
    }

  # Y X
  # +y 0 result is PI/2
  # -y 0 result is -PI/2
  if ($x->is_zero())
    {
    # calculate PI/2
    my $pi = $self->bpi(@r);
    # modify $y in place
    $y->{_m} = $pi->{_m};
    $y->{_e} = $pi->{_e};
    $y->{_es} = $pi->{_es};
    # -y => -PI/2, +y => PI/2
    $MBI->_div($y->{_m}, $MBI->_new(2));
    return $y;
    }

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($y,@params) = $y->_find_round_parameters(@r);
    
  # error in _find_round_parameters?
  return $y if $y->is_nan();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # inlined is_one() && is_one('-')
  if ($MBI->_is_one($y->{_m}) && $MBI->_is_zero($y->{_e}))
    {
    # shortcut: 1 1 result is PI/4
    # inlined is_one() && is_one('-')
    if ($MBI->_is_one($x->{_m}) && $MBI->_is_zero($x->{_e}))
      {
      # 1,1 => PI/4
      my $pi_4 = $self->bpi( $scale - 3);
      # modify $y in place
      $y->{_m} = $pi_4->{_m};
      $y->{_e} = $pi_4->{_e};
      $y->{_es} = $pi_4->{_es};
      # 1 1 => +
      # -1 1 => -
      # 1 -1 => -
      # -1 -1 => +
      $y->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';
      $MBI->_div($y->{_m}, $MBI->_new(4));
      return $y;
      }
    # shortcut: 1 int(X) result is _atan_inv(X)

    # is integer
    if ($x->{_es} eq '+')
      {
      my $x1 = $MBI->_copy($x->{_m});
      $MBI->_lsft($x1, $x->{_e},10) unless $MBI->_is_zero($x->{_e});

      my ($a,$b) = $self->_atan_inv($x1, $scale);
      my $y_sign = $y->{sign};
      # calculate A/B
      $y->bone(); $y->{_m} = $a; my $y_d = $self->bone(); $y_d->{_m} = $b;
      $y->bdiv($y_d, @r);
      $y->{sign} = $y_sign;
      return $y;
      }
    }

  # handle all other cases
  #  X  Y
  # +x +y 0 to PI/2
  # -x +y PI/2 to PI
  # +x -y 0 to -PI/2
  # -x -y -PI/2 to -PI 

  my $y_sign = $y->{sign};

  # divide $x by $y
  $y->bdiv($x, $scale) unless $x->is_one();
  $y->batan(@r);

  # restore sign
  $y->{sign} = $y_sign;

  $y;
  }

sub batan
  {
  # Calculate a arcus tangens of x.
  my ($x,@r) = @_;
  my $self = ref($x);

  # taylor:       x^3   x^5   x^7   x^9
  #    atan = x - --- + --- - --- + --- ...
  #                3     5     7     9 

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@params);
  ($x,@params) = $x->_find_round_parameters(@r);
    
  #         constant object       or error in _find_round_parameters?
  return $x if $x->modify('batan') || $x->is_nan();

  if ($x->{sign} =~ /^[+-]inf\z/)
    {
    # +inf result is PI/2
    # -inf result is -PI/2
    # calculate PI/2
    my $pi = $self->bpi(@r);
    # modify $x in place
    $x->{_m} = $pi->{_m};
    $x->{_e} = $pi->{_e};
    $x->{_es} = $pi->{_es};
    # -y => -PI/2, +y => PI/2
    $x->{sign} = substr($x->{sign},0,1);		# +inf => +
    $MBI->_div($x->{_m}, $MBI->_new(2));
    return $x;
    }

  return $x->bzero(@r) if $x->is_zero();

  # no rounding at all, so must use fallback
  if (scalar @params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# disable P
    $scale = $params[0]+4; 		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it is not
    # enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  # 1 or -1 => PI/4
  # inlined is_one() && is_one('-')
  if ($MBI->_is_one($x->{_m}) && $MBI->_is_zero($x->{_e}))
    {
    my $pi = $self->bpi($scale - 3);
    # modify $x in place
    $x->{_m} = $pi->{_m};
    $x->{_e} = $pi->{_e};
    $x->{_es} = $pi->{_es};
    # leave the sign of $x alone (+1 => +PI/4, -1 => -PI/4)
    $MBI->_div($x->{_m}, $MBI->_new(4));
    return $x;
    }
  
  # This series is only valid if -1 < x < 1, so for other x we need to
  # to calculate PI/2 - atan(1/x):
  my $one = $MBI->_new(1);
  my $pi = undef;
  if ($x->{_es} eq '+' && ($MBI->_acmp($x->{_m},$one) >= 0))
    {
    # calculate PI/2
    $pi = $self->bpi($scale - 3);
    $MBI->_div($pi->{_m}, $MBI->_new(2));
    # calculate 1/$x:
    my $x_copy = $x->copy();
    # modify $x in place
    $x->bone(); $x->bdiv($x_copy,$scale);
    }

  # when user set globals, they would interfere with our calculation, so
  # disable them and later re-enable them
  no strict 'refs';
  my $abr = "$self\::accuracy"; my $ab = $$abr; $$abr = undef;
  my $pbr = "$self\::precision"; my $pb = $$pbr; $$pbr = undef;
  # we also need to disable any set A or P on $x (_find_round_parameters took
  # them already into account), since these would interfere, too
  delete $x->{_a}; delete $x->{_p};
  # need to disable $upgrade in BigInt, to avoid deep recursion
  local $Math::BigInt::upgrade = undef;
 
  my $last = 0;
  my $over = $x * $x;			# X ^ 2
  my $x2 = $over->copy();		# X ^ 2; difference between terms
  $over->bmul($x);			# X ^ 3 as starting value
  my $sign = 1;				# start with -=
  my $below = $self->new(3);
  my $two = $self->new(2);
  delete $x->{_a}; delete $x->{_p};

  my $limit = $self->new("1E-". ($scale-1));
  #my $steps = 0;
  while (3 < 5)
    {
    # we calculate the next term, and add it to the last
    # when the next term is below our limit, it won't affect the outcome
    # anymore, so we stop:
    my $next = $over->copy()->bdiv($below,$scale);
    last if $next->bacmp($limit) <= 0;

    if ($sign == 0)
      {
      $x->badd($next);
      }
    else
      {
      $x->bsub($next);
      }
    $sign = 1-$sign;					# alternate
    # calculate things for the next term
    $over->bmul($x2);					# $x*$x
    $below->badd($two);					# n += 2
    }

  if (defined $pi)
    {
    my $x_copy = $x->copy();
    # modify $x in place
    $x->{_m} = $pi->{_m};
    $x->{_e} = $pi->{_e};
    $x->{_es} = $pi->{_es};
    # PI/2 - $x
    $x->bsub($x_copy);
    }

  # shortcut to not run through _find_round_parameters again
  if (defined $params[0])
    {
    $x->bround($params[0],$params[2]);		# then round accordingly
    }
  else
    {
    $x->bfround($params[1],$params[2]);		# then round accordingly
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }
  # restore globals
  $$abr = $ab; $$pbr = $pb;
  $x;
  }

###############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 means round to integer
  # expects and returns normalized numbers!
  my $x = shift; my $self = ref($x) || $x; $x = $self->new(shift) if !ref($x);

  my ($scale,$mode) = $x->_scale_p(@_);
  return $x if !defined $scale || $x->modify('bfround'); # no-op

  # never round a 0, +-inf, NaN
  if ($x->is_zero())
    {
    $x->{_p} = $scale if !defined $x->{_p} || $x->{_p} < $scale; # -3 < -2
    return $x; 
    }
  return $x if $x->{sign} !~ /^[+-]$/;

  # don't round if x already has lower precision
  return $x if (defined $x->{_p} && $x->{_p} < 0 && $scale < $x->{_p});

  $x->{_p} = $scale;			# remember round in any case
  delete $x->{_a};			# and clear A
  if ($scale < 0)
    {
    # round right from the '.'

    return $x if $x->{_es} eq '+';		# e >= 0 => nothing to round

    $scale = -$scale;				# positive for simplicity
    my $len = $MBI->_len($x->{_m});		# length of mantissa

    # the following poses a restriction on _e, but if _e is bigger than a
    # scalar, you got other problems (memory etc) anyway
    my $dad = -(0+ ($x->{_es}.$MBI->_num($x->{_e})));	# digits after dot
    my $zad = 0;				# zeros after dot
    $zad = $dad - $len if (-$dad < -$len);	# for 0.00..00xxx style
   
    # print "scale $scale dad $dad zad $zad len $len\n";
    # number  bsstr   len zad dad	
    # 0.123   123e-3	3   0 3
    # 0.0123  123e-4	3   1 4
    # 0.001   1e-3      1   2 3
    # 1.23    123e-2	3   0 2
    # 1.2345  12345e-4	5   0 4

    # do not round after/right of the $dad
    return $x if $scale > $dad;			# 0.123, scale >= 3 => exit

    # round to zero if rounding inside the $zad, but not for last zero like:
    # 0.0065, scale -2, round last '0' with following '65' (scale == zad case)
    return $x->bzero() if $scale < $zad;
    if ($scale == $zad)			# for 0.006, scale -3 and trunc
      {
      $scale = -$len;
      }
    else
      {
      # adjust round-point to be inside mantissa
      if ($zad != 0)
        {
	$scale = $scale-$zad;
        }
      else
        {
        my $dbd = $len - $dad; $dbd = 0 if $dbd < 0;	# digits before dot
	$scale = $dbd+$scale;
        }
      }
    }
  else
    {
    # round left from the '.'

    # 123 => 100 means length(123) = 3 - $scale (2) => 1

    my $dbt = $MBI->_len($x->{_m}); 
    # digits before dot 
    my $dbd = $dbt + ($x->{_es} . $MBI->_num($x->{_e}));
    # should be the same, so treat it as this 
    $scale = 1 if $scale == 0; 
    # shortcut if already integer 
    return $x if $scale == 1 && $dbt <= $dbd; 
    # maximum digits before dot 
    ++$dbd;

    if ($scale > $dbd) 
       { 
       # not enough digits before dot, so round to zero 
       return $x->bzero; 
       }
    elsif ( $scale == $dbd )
       { 
       # maximum 
       $scale = -$dbt; 
       } 
    else
       { 
       $scale = $dbd - $scale; 
       }
    }
  # pass sign to bround for rounding modes '+inf' and '-inf'
  my $m = bless { sign => $x->{sign}, value => $x->{_m} }, 'Math::BigInt';
  $m->bround($scale,$mode);
  $x->{_m} = $m->{value};			# get our mantissa back
  $x->bnorm();
  }

sub bround
  {
  # accuracy: preserve $N digits, and overwrite the rest with 0's
  my $x = shift; my $self = ref($x) || $x; $x = $self->new(shift) if !ref($x);

  if (($_[0] || 0) < 0)
    {
    require Carp; Carp::croak ('bround() needs positive accuracy');
    }

  my ($scale,$mode) = $x->_scale_a(@_);
  return $x if !defined $scale || $x->modify('bround');	# no-op

  # scale is now either $x->{_a}, $accuracy, or the user parameter
  # test whether $x already has lower accuracy, do nothing in this case 
  # but do round if the accuracy is the same, since a math operation might
  # want to round a number with A=5 to 5 digits afterwards again
  return $x if defined $x->{_a} && $x->{_a} < $scale;

  # scale < 0 makes no sense
  # scale == 0 => keep all digits
  # never round a +-inf, NaN
  return $x if ($scale <= 0) || $x->{sign} !~ /^[+-]$/;

  # 1: never round a 0
  # 2: if we should keep more digits than the mantissa has, do nothing
  if ($x->is_zero() || $MBI->_len($x->{_m}) <= $scale)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale;
    return $x; 
    }

  # pass sign to bround for '+inf' and '-inf' rounding modes
  my $m = bless { sign => $x->{sign}, value => $x->{_m} }, 'Math::BigInt';

  $m->bround($scale,$mode);		# round mantissa
  $x->{_m} = $m->{value};		# get our mantissa back
  $x->{_a} = $scale;			# remember rounding
  delete $x->{_p};			# and clear P
  $x->bnorm();				# del trailing zeros gen. by bround()
  }

sub bfloor
  {
  # round towards minus infinity
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bfloor');
   
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  # if $x has digits after dot
  if ($x->{_es} eq '-')
    {
    $x->{_m} = $MBI->_rsft($x->{_m},$x->{_e},10); # cut off digits after dot
    $x->{_e} = $MBI->_zero();			# trunc/norm	
    $x->{_es} = '+';				# abs e
    $MBI->_inc($x->{_m}) if $x->{sign} eq '-';	# increment if negative
    }
  $x->round($a,$p,$r);
  }

sub bceil
  {
  # round towards plus infinity
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bceil');
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  # if $x has digits after dot
  if ($x->{_es} eq '-')
    {
    $x->{_m} = $MBI->_rsft($x->{_m},$x->{_e},10); # cut off digits after dot
    $x->{_e} = $MBI->_zero();			# trunc/norm	
    $x->{_es} = '+';				# abs e
    $MBI->_inc($x->{_m}) if $x->{sign} eq '+';	# increment if positive
    }
  $x->round($a,$p,$r);
  }

sub bint
  {
  # round towards zero
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@_) : objectify(1,@_);

  return $x if $x->modify('bint');
  return $x if $x->{sign} !~ /^[+-]$/;  # nan, +inf, -inf

  # if $x has digits after the decimal point
  if ($x->{_es} eq '-')
    {
    $x->{_m} = $MBI->_rsft($x->{_m},$x->{_e},10); # cut off digits after dot
    $x->{_e} = $MBI->_zero();                     # truncate/normalize
    $x->{_es} = '+';                              # abs e
    }
  $x->round($a,$p,$r);
  }

sub brsft
  {
  # shift right by $y (divide by power of $n)
  
  # set up parameters
  my ($self,$x,$y,$n,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('brsft');
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  $n = 2 if !defined $n; $n = $self->new($n);

  # negative amount?
  return $x->blsft($y->copy()->babs(),$n) if $y->{sign} =~ /^-/;

  # the following call to bdiv() will return either quo or (quo,remainder):
  $x->bdiv($n->bpow($y),$a,$p,$r,$y);
  }

sub blsft
  {
  # shift left by $y (multiply by power of $n)
  
  # set up parameters
  my ($self,$x,$y,$n,$a,$p,$r) = (ref($_[0]),@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,$a,$p,$r) = objectify(2,@_);
    }

  return $x if $x->modify('blsft');
  return $x if $x->{sign} !~ /^[+-]$/;	# nan, +inf, -inf

  $n = 2 if !defined $n; $n = $self->new($n);

  # negative amount?
  return $x->brsft($y->copy()->babs(),$n) if $y->{sign} =~ /^-/;

  $x->bmul($n->bpow($y),$a,$p,$r,$y);
  }

###############################################################################

sub DESTROY
  {
  # going through AUTOLOAD for every DESTROY is costly, avoid it by empty sub
  }

sub AUTOLOAD
  {
  # make fxxx and bxxx both work by selectively mapping fxxx() to MBF::bxxx()
  # or falling back to MBI::bxxx()
  my $name = $AUTOLOAD;

  $name =~ s/(.*):://;	# split package
  my $c = $1 || $class;
  no strict 'refs';
  $c->import() if $IMPORT == 0;
  if (!_method_alias($name))
    {
    if (!defined $name)
      {
      # delayed load of Carp and avoid recursion	
      require Carp;
      Carp::croak ("$c: Can't call a method without name");
      }
    if (!_method_hand_up($name))
      {
      # delayed load of Carp and avoid recursion	
      require Carp;
      Carp::croak ("Can't call $c\-\>$name, not a valid method");
      }
    # try one level up, but subst. bxxx() for fxxx() since MBI only got bxxx()
    $name =~ s/^f/b/;
    return &{"Math::BigInt"."::$name"}(@_);
    }
  my $bname = $name; $bname =~ s/^f/b/;
  $c .= "::$name";
  *{$c} = \&{$bname};
  &{$c};	# uses @_
  }

sub exponent
  {
  # return a copy of the exponent
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;
    return Math::BigInt->new($s); 		# -inf, +inf => +inf
    }
  Math::BigInt->new( $x->{_es} . $MBI->_str($x->{_e}));
  }

sub mantissa
  {
  # return a copy of the mantissa
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);
 
  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+]//;
    return Math::BigInt->new($s);		# -inf, +inf => +inf
    }
  my $m = Math::BigInt->new( $MBI->_str($x->{_m}));
  $m->bneg() if $x->{sign} eq '-';

  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+]//; my $se = $s; $se =~ s/^[-]//;
    return ($self->new($s),$self->new($se)); # +inf => inf and -inf,+inf => inf
    }
  my $m = Math::BigInt->bzero();
  $m->{value} = $MBI->_copy($x->{_m});
  $m->bneg() if $x->{sign} eq '-';
  ($m, Math::BigInt->new( $x->{_es} . $MBI->_num($x->{_e}) ));
  }

##############################################################################
# private stuff (internal use only)

sub import
  {
  my $self = shift;
  my $l = scalar @_;
  my $lib = ''; my @a;
  my $lib_kind = 'try';
  $IMPORT=1;
  for ( my $i = 0; $i < $l ; $i++)
    {
    if ( $_[$i] eq ':constant' )
      {
      # This causes overlord er load to step in. 'binary' and 'integer'
      # are handled by BigInt.
      overload::constant float => sub { $self->new(shift); }; 
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] eq 'downgrade')
      {
      # this causes downgrading
      $downgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      # alternative library
      $lib = $_[$i+1] || '';		# default Calc
      $lib_kind = $1;			# lib, try or only
      $i++;
      }
    elsif ($_[$i] eq 'with')
      {
      # alternative class for our private parts()
      # XXX: no longer supported
      # $MBI = $_[$i+1] || 'Math::BigInt';
      $i++;
      }
    else
      {
      push @a, $_[$i];
      }
    }

  $lib =~ tr/a-zA-Z0-9,://cd;		# restrict to sane characters
  # let use Math::BigInt lib => 'GMP'; use Math::BigFloat; still work
  my $mbilib = eval { Math::BigInt->config()->{lib} };
  if ((defined $mbilib) && ($MBI eq 'Math::BigInt::Calc'))
    {
    # MBI already loaded
    Math::BigInt->import( $lib_kind, "$lib,$mbilib", 'objectify');
    }
  else
    {
    # MBI not loaded, or with ne "Math::BigInt::Calc"
    $lib .= ",$mbilib" if defined $mbilib;
    $lib =~ s/^,//;				# don't leave empty 
    
    # replacement library can handle lib statement, but also could ignore it
    
    # Perl < 5.6.0 dies with "out of memory!" when eval() and ':constant' is
    # used in the same script, or eval inside import(). So we require MBI:
    require Math::BigInt;
    Math::BigInt->import( $lib_kind => $lib, 'objectify' );
    }
  if ($@)
    {
    require Carp; Carp::croak ("Couldn't load $lib: $! $@");
    }
  # find out which one was actually loaded
  $MBI = Math::BigInt->config()->{lib};

  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback( $self, sub { $MBI = $_[0]; } );

  $self->export_to_level(1,$self,@a);		# export wanted functions
  }

sub bnorm
  {
  # adjust m and e so that m is smallest possible
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@_);

  return $x if $x->{sign} !~ /^[+-]$/;		# inf, nan etc

  my $zeros = $MBI->_zeros($x->{_m});		# correct for trailing zeros
  if ($zeros != 0)
    {
    my $z = $MBI->_new($zeros);
    $x->{_m} = $MBI->_rsft ($x->{_m}, $z, 10);
    if ($x->{_es} eq '-')
      {
      if ($MBI->_acmp($x->{_e},$z) >= 0)
        {
        $x->{_e} = $MBI->_sub ($x->{_e}, $z);
        $x->{_es} = '+' if $MBI->_is_zero($x->{_e});
        }
      else
        {
        $x->{_e} = $MBI->_sub ( $MBI->_copy($z), $x->{_e});
        $x->{_es} = '+';
        }
      }
    else
      {
      $x->{_e} = $MBI->_add ($x->{_e}, $z);
      }
    }
  else
    {
    # $x can only be 0Ey if there are no trailing zeros ('0' has 0 trailing
    # zeros). So, for something like 0Ey, set y to 1, and -0 => +0
    $x->{sign} = '+', $x->{_es} = '+', $x->{_e} = $MBI->_one()
     if $MBI->_is_zero($x->{_m});
    }

  $x;					# MBI bnorm is no-op, so do not call it
  } 
 
##############################################################################

sub as_hex
  {
  # return number as hexadecimal string (only for integers defined)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
  return '0x0' if $x->is_zero();

  return $nan if $x->{_es} ne '+';		# how to do 1e-1 in hex!?

  my $z = $MBI->_copy($x->{_m});
  if (! $MBI->_is_zero($x->{_e}))		# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_num($z));
  $z->as_hex();
  }

sub as_bin
  {
  # return number as binary digit string (only for integers defined)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
  return '0b0' if $x->is_zero();

  return $nan if $x->{_es} ne '+';		# how to do 1e-1 in hex!?

  my $z = $MBI->_copy($x->{_m});
  if (! $MBI->_is_zero($x->{_e}))		# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_num($z));
  $z->as_bin();
  }

sub as_oct
  {
  # return number as octal digit string (only for integers defined)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;  # inf, nan etc
  return '0' if $x->is_zero();

  return $nan if $x->{_es} ne '+';		# how to do 1e-1 in hex!?

  my $z = $MBI->_copy($x->{_m});
  if (! $MBI->_is_zero($x->{_e}))		# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_num($z));
  $z->as_oct();
  }

sub as_number
  {
  # return copy as a bigint representation of this BigFloat number
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@_);

  return $x if $x->modify('as_number');

  if (!$x->isa('Math::BigFloat'))
    {
    # if the object can as_number(), use it
    return $x->as_number() if $x->can('as_number');
    # otherwise, get us a float and then a number
    $x = $x->can('as_float') ? $x->as_float() : $self->new(0+"$x");
    }

  return Math::BigInt->binf($x->sign()) if $x->is_inf();
  return Math::BigInt->bnan()           if $x->is_nan();

  my $z = $MBI->_copy($x->{_m});
  if ($x->{_es} eq '-')			# < 0
    {
    $MBI->_rsft( $z, $x->{_e},10);
    } 
  elsif (! $MBI->_is_zero($x->{_e}))	# > 0 
    {
    $MBI->_lsft( $z, $x->{_e},10);
    }
  $z = Math::BigInt->new( $x->{sign} . $MBI->_str($z));
  $z;
  }

sub length
  {
  my $x = shift;
  my $class = ref($x) || $x;
  $x = $class->new(shift) unless ref($x);

  return 1 if $MBI->_is_zero($x->{_m});

  my $len = $MBI->_len($x->{_m});
  $len += $MBI->_num($x->{_e}) if $x->{_es} eq '+';
  if (wantarray())
    {
    my $t = 0;
    $t = $MBI->_num($x->{_e}) if $x->{_es} eq '-';
    return ($len, $t);
    }
  $len;
  }

1;

__END__

=head1 NAME

Math::BigFloat - Arbitrary size floating point math package

=head1 SYNOPSIS

 use Math::BigFloat;

 # Number creation
 my $x = Math::BigFloat->new($str);	# defaults to 0
 my $y = $x->copy();			# make a true copy
 my $nan  = Math::BigFloat->bnan();	# create a NotANumber
 my $zero = Math::BigFloat->bzero();	# create a +0
 my $inf = Math::BigFloat->binf();	# create a +inf
 my $inf = Math::BigFloat->binf('-');	# create a -inf
 my $one = Math::BigFloat->bone();	# create a +1
 my $mone = Math::BigFloat->bone('-');	# create a -1

 my $pi = Math::BigFloat->bpi(100);	# PI to 100 digits

 # the following examples compute their result to 100 digits accuracy:
 my $cos  = Math::BigFloat->new(1)->bcos(100);	      # cosinus(1)
 my $sin  = Math::BigFloat->new(1)->bsin(100);	      # sinus(1)
 my $atan = Math::BigFloat->new(1)->batan(100);	      # arcus tangens(1)

 my $atan2 = Math::BigFloat->new(  1 )->batan2( 1 ,100); # batan(1)
 my $atan2 = Math::BigFloat->new(  1 )->batan2( 8 ,100); # batan(1/8)
 my $atan2 = Math::BigFloat->new( -2 )->batan2( 1 ,100); # batan(-2)

 # Testing
 $x->is_zero();		 # true if arg is +0
 $x->is_nan();		 # true if arg is NaN
 $x->is_one();		 # true if arg is +1
 $x->is_one('-');	 # true if arg is -1
 $x->is_odd();		 # true if odd, false for even
 $x->is_even();		 # true if even, false for odd
 $x->is_pos();		 # true if >= 0
 $x->is_neg();		 # true if <  0
 $x->is_inf(sign);	 # true if +inf, or -inf (default is '+')

 $x->bcmp($y);		 # compare numbers (undef,<0,=0,>0)
 $x->bacmp($y);		 # compare absolutely (undef,<0,=0,>0)
 $x->sign();		 # return the sign, either +,- or NaN
 $x->digit($n);		 # return the nth digit, counting from right
 $x->digit(-$n);	 # return the nth digit, counting from left 

 # The following all modify their first argument. If you want to pre-
 # serve $x, use $z = $x->copy()->bXXX($y); See under L</CAVEATS> for
 # necessary when mixing $a = $b assignments with non-overloaded math.

 # set 
 $x->bzero();		 # set $i to 0
 $x->bnan();		 # set $i to NaN
 $x->bone();		 # set $x to +1
 $x->bone('-');		 # set $x to -1
 $x->binf();		 # set $x to inf
 $x->binf('-');		 # set $x to -inf

 $x->bneg();		 # negation
 $x->babs();		 # absolute value
 $x->bnorm();		 # normalize (no-op)
 $x->bnot();		 # two's complement (bit wise not)
 $x->binc();		 # increment x by 1
 $x->bdec();		 # decrement x by 1

 $x->badd($y);		 # addition (add $y to $x)
 $x->bsub($y);		 # subtraction (subtract $y from $x)
 $x->bmul($y);		 # multiplication (multiply $x by $y)
 $x->bdiv($y);		 # divide, set $x to quotient
			 # return (quo,rem) or quo if scalar

 $x->bmod($y);		 # modulus ($x % $y)
 $x->bpow($y);		 # power of arguments ($x ** $y)
 $x->bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
 $x->blsft($y, $n);	 # left shift by $y places in base $n
 $x->brsft($y, $n);	 # right shift by $y places in base $n
			 # returns (quo,rem) or quo if in scalar context

 $x->blog();		 # logarithm of $x to base e (Euler's number)
 $x->blog($base);	 # logarithm of $x to base $base (f.i. 2)
 $x->bexp();		 # calculate e ** $x where e is Euler's number

 $x->band($y);		 # bit-wise and
 $x->bior($y);		 # bit-wise inclusive or
 $x->bxor($y);		 # bit-wise exclusive or
 $x->bnot();		 # bit-wise not (two's complement)

 $x->bsqrt();		 # calculate square-root
 $x->broot($y);		 # $y'th root of $x (e.g. $y == 3 => cubic root)
 $x->bfac();		 # factorial of $x (1*2*3*4*..$x)

 $x->bround($N); 	 # accuracy: preserve $N digits
 $x->bfround($N);	 # precision: round to the $Nth digit

 $x->bfloor();		 # return integer less or equal than $x
 $x->bceil();		 # return integer greater or equal than $x
 $x->bint();             # round towards zero

  # The following do not modify their arguments:

 bgcd(@values);		 # greatest common divisor
 blcm(@values);		 # lowest common multiplicator

 $x->bstr();		 # return string
 $x->bsstr();		 # return string in scientific notation

 $x->as_int();		 # return $x as BigInt 
 $x->exponent();	 # return exponent as BigInt
 $x->mantissa();	 # return mantissa as BigInt
 $x->parts();		 # return (mantissa,exponent) as BigInt

 $x->length();		 # number of digits (w/o sign and '.')
 ($l,$f) = $x->length(); # number of digits, and length of fraction

 $x->precision();	 # return P of $x (or global, if P of $x undef)
 $x->precision($n);	 # set P of $x to $n
 $x->accuracy();	 # return A of $x (or global, if A of $x undef)
 $x->accuracy($n);	 # set A $x to $n

 # these get/set the appropriate global value for all BigFloat objects
 Math::BigFloat->precision();	# Precision
 Math::BigFloat->accuracy();	# Accuracy
 Math::BigFloat->round_mode();	# rounding mode

=head1 DESCRIPTION

All operators (including basic math operations) are overloaded if you
declare your big floating point numbers as

  $i = new Math::BigFloat '12_3.456_789_123_456_789E-2';

Operations with overloaded operators preserve the arguments, which is
exactly what you expect.

=head2 Input

Input to these routines are either BigFloat objects, or strings of the
following four forms:

=over

=item *

C</^[+-]\d+$/>

=item *

C</^[+-]\d+\.\d*$/>

=item *

C</^[+-]\d+E[+-]?\d+$/>

=item *

C</^[+-]\d*\.\d+E[+-]?\d+$/>

=back

all with optional leading and trailing zeros and/or spaces. Additionally,
numbers are allowed to have an underscore between any two digits.

Empty strings as well as other illegal numbers results in 'NaN'.

bnorm() on a BigFloat object is now effectively a no-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigFloat 
object.

=head2 Output

Output values are BigFloat objects (normalized), except for bstr() and bsstr().

The string output will always have leading and trailing zeros stripped and drop
a plus sign. C<bstr()> will give you always the form with a decimal point,
while C<bsstr()> (s for scientific) gives you the scientific notation.

	Input			bstr()		bsstr()
	'-0'			'0'		'0E1'
   	'  -123 123 123'	'-123123123'	'-123123123E0'
	'00.0123'		'0.0123'	'123E-4'
	'123.45E-2'		'1.2345'	'12345E-4'
	'10E+3'			'10000'		'1E4'

Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef, <0, 0 or >0 and are suited for sort.

Actual math is done by using the class defined with C<< with => Class; >>
(which defaults to BigInts) to represent the mantissa and exponent.

The sign C</^[+-]$/> is stored separately. The string 'NaN' is used to 
represent the result when input arguments are not numbers, as well as 
the result of dividing by zero.

=head2 mantissa(), exponent() and parts()

mantissa() and exponent() return the said parts of the BigFloat
as BigInts such that:

	$m = $x->mantissa();
	$e = $x->exponent();
	$y = $m * ( 10 ** $e );
	print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts(); >> is just a shortcut giving you both of them.

A zero is represented and returned as C<0E1>, B<not> C<0E0> (after Knuth).

Currently the mantissa is reduced as much as possible, favouring higher
exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0).
This might change in the future, so do not depend on it.

=head2 Accuracy vs. Precision

See also: L<Rounding|/Rounding>.

Math::BigFloat supports both precision (rounding to a certain place before or
after the dot) and accuracy (rounding to a certain number of digits). For a
full documentation, examples and tips on these topics please see the large
section about rounding in L<Math::BigInt>.

Since things like C<sqrt(2)> or C<1 / 3> must presented with a limited
accuracy lest a operation consumes all resources, each operation produces
no more than the requested number of digits.

If there is no global precision or accuracy set, B<and> the operation in
question was not called with a requested precision or accuracy, B<and> the
input $x has no accuracy or precision set, then a fallback parameter will
be used. For historical reasons, it is called C<div_scale> and can be accessed
via:

	$d = Math::BigFloat->div_scale();	# query
	Math::BigFloat->div_scale($n);		# set to $n digits

The default value for C<div_scale> is 40.

In case the result of one operation has more digits than specified,
it is rounded. The rounding mode taken is either the default mode, or the one
supplied to the operation after the I<scale>:

    $x = Math::BigFloat->new(2);
    Math::BigFloat->accuracy(5);	      # 5 digits max
    $y = $x->copy()->bdiv(3);		      # will give 0.66667
    $y = $x->copy()->bdiv(3,6);		      # will give 0.666667
    $y = $x->copy()->bdiv(3,6,undef,'odd');   # will give 0.666667
    Math::BigFloat->round_mode('zero');
    $y = $x->copy()->bdiv(3,6);		      # will also give 0.666667

Note that C<< Math::BigFloat->accuracy() >> and C<< Math::BigFloat->precision() >>
set the global variables, and thus B<any> newly created number will be subject
to the global rounding B<immediately>. This means that in the examples above, the
C<3> as argument to C<bdiv()> will also get an accuracy of B<5>.

It is less confusing to either calculate the result fully, and afterwards
round it explicitly, or use the additional parameters to the math
functions like so:

	use Math::BigFloat;
	$x = Math::BigFloat->new(2);
	$y = $x->copy()->bdiv(3);
	print $y->bround(5),"\n";		# will give 0.66667

	or

	use Math::BigFloat;
	$x = Math::BigFloat->new(2);
	$y = $x->copy()->bdiv(3,5);		# will give 0.66667
	print "$y\n";

=head2 Rounding

=over

=item ffround ( +$scale )

Rounds to the $scale'th place left from the '.', counting from the dot.
The first digit is numbered 1. 

=item ffround ( -$scale )

Rounds to the $scale'th place right from the '.', counting from the dot.

=item ffround ( 0 )

Rounds to an integer.

=item fround  ( +$scale )

Preserves accuracy to $scale digits from the left (aka significant digits)
and pads the rest with zeros. If the number is between 1 and -1, the
significant digits count from the first non-zero after the '.'

=item fround  ( -$scale ) and fround ( 0 )

These are effectively no-ops.

=back

All rounding functions take as a second parameter a rounding mode from one of
the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.

The default rounding mode is 'even'. By using
C<< Math::BigFloat->round_mode($round_mode); >> you can get and set the default
mode for subsequent rounding. The usage of C<$Math::BigFloat::$round_mode> is
no longer supported.
The second parameter to the round functions then overrides the default
temporarily. 

The C<as_number()> function returns a BigInt from a Math::BigFloat. It uses
'trunc' as rounding mode to make it equivalent to:

	$x = 2.5;
	$y = int($x) + 2;

You can override this by passing the desired rounding mode as parameter to
C<as_number()>:

	$x = Math::BigFloat->new(2.5);
	$y = $x->as_number('odd');	# $y = 3

=head1 METHODS

Math::BigFloat supports all methods that Math::BigInt supports, except it
calculates non-integer results when possible. Please see L<Math::BigInt>
for a full description of each method. Below are just the most important
differences:

=over

=item accuracy()

      $x->accuracy(5);           # local for $x
      CLASS->accuracy(5);        # global for all members of CLASS
                                 # Note: This also applies to new()!

      $A = $x->accuracy();       # read out accuracy that affects $x
      $A = CLASS->accuracy();    # read out global accuracy

Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded.

In most cases, you should probably round the results explicitly using one of
L<Math::BigInt/round()>, L<Math::BigInt/bround()> or L<Math::BigInt/bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

        my $x = Math::BigInt->new(30000);
        my $y = Math::BigInt->new(7);
        print scalar $x->copy()->bdiv($y, 2);           # print 4300
        print scalar $x->copy()->bdiv($y)->bround(2);   # print 4300

=item precision()

      $x->precision(-2);      # local for $x, round at the second
                              # digit right of the dot
      $x->precision(2);       # ditto, round at the second digit
                              # left of the dot

      CLASS->precision(5);    # Global for all members of CLASS
                              # This also applies to new()!
      CLASS->precision(-5);   # ditto

      $P = CLASS->precision();  # read out global precision
      $P = $x->precision();     # read out precision that affects $x

Note: You probably want to use L</accuracy()> instead. With L</accuracy()> you
set the number of digits each result should have, with L</precision()> you
set the place where to round!

=item bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

=item bnok()

	$x->bnok($y);	# x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=item bpi()

	print Math::BigFloat->bpi(100), "\n";

Calculate PI to N digits (including the 3 before the dot). The result is
rounded according to the current rounding mode, which defaults to "even".

This method was added in v1.87 of Math::BigInt (June 2007).

=item bcos()

	my $x = Math::BigFloat->new(1);
	print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bsin()

	my $x = Math::BigFloat->new(1);
	print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan2()

	my $y = Math::BigFloat->new(2);
	my $x = Math::BigFloat->new(3);
	print $y->batan2($x), "\n";

Calculate the arcus tanges of C<$y> divided by C<$x>, modifying $y in place.
See also L</batan()>.

This method was added in v1.87 of Math::BigInt (June 2007).

=item batan()

	my $x = Math::BigFloat->new(1);
	print $x->batan(100), "\n";

Calculate the arcus tanges of $x, modifying $x in place. See also L</batan2()>.

This method was added in v1.87 of Math::BigInt (June 2007).

=item bmuladd()

	$x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result.

This method was added in v1.87 of Math::BigInt (June 2007).

=back

=head1 Autocreating constants

After C<use Math::BigFloat ':constant'> all the floating point constants
in the given scope are converted to C<Math::BigFloat>. This conversion
happens at compile time.

In particular

  perl -MMath::BigFloat=:constant -e 'print 2E-100,"\n"'

prints the value of C<2E-100>. Note that without conversion of 
constants the expression 2E-100 will be calculated as normal floating point 
number.

Please note that ':constant' does not affect integer constants, nor binary 
nor hexadecimal constants. Use L<bignum> or L<Math::BigInt> to get this to
work.

=head2 Math library

Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:

	use Math::BigFloat lib => 'Calc';

You can change this by using:

	use Math::BigFloat lib => 'GMP';

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

Note: The keyword 'lib' will warn when the requested library could not be
loaded. To suppress the warning use 'try' instead:

	use Math::BigFloat try => 'GMP';

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

        use Math::BigFloat only => 'GMP,Pari';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigFloat lib => 'Foo,Math::BigInt::Bar';

See the respective low-level library documentation for further details.

Please note that Math::BigFloat does B<not> use the denoted library itself,
but it merely passes the lib argument to Math::BigInt. So, instead of the need
to do:

	use Math::BigInt lib => 'GMP';
	use Math::BigFloat;

you can roll it all into one line:

	use Math::BigFloat lib => 'GMP';

It is also possible to just require Math::BigFloat:

	require Math::BigFloat;

This will load the necessary things (like BigInt) when they are needed, and
automatically.

See L<Math::BigInt> for more details than you ever wanted to know about using
a different low-level library.

=head2 Using Math::BigInt::Lite

For backwards compatibility reasons it is still possible to
request a different storage class for use with Math::BigFloat:

        use Math::BigFloat with => 'Math::BigInt::Lite';

However, this request is ignored, as the current code now uses the low-level
math library for directly storing the number parts.

=head1 EXPORTS

C<Math::BigFloat> exports nothing by default, but can export the C<bpi()> method:

	use Math::BigFloat qw/bpi/;

	print bpi(10), "\n";

=head1 BUGS

Please see the file BUGS in the CPAN distribution Math::BigInt for known bugs.

=head1 CAVEATS

Do not try to be clever to insert some operations in between switching
libraries:

    require Math::BigFloat;
    my $matter = Math::BigFloat->bone() + 4;	# load BigInt and Calc
    Math::BigFloat->import( lib => 'Pari' );	# load Pari, too
    my $anti_matter = Math::BigFloat->bone()+4;	# now use Pari

This will create objects with numbers stored in two different backend libraries,
and B<VERY BAD THINGS> will happen when you use these together:

	my $flash_and_bang = $matter + $anti_matter;	# Don't do this!

=over

=item stringify, bstr()

Both stringify and bstr() now drop the leading '+'. The old code would return
'+1.23', the new returns '1.23'. See the documentation in L<Math::BigInt> for
reasoning and details.

=item bdiv()

The following will probably not print what you expect:

	print $c->bdiv(123.456),"\n";

It prints both quotient and remainder since print works in list context. Also,
bdiv() will modify $c, so be careful. You probably want to use

    print $c / 123.456,"\n";
    # or if you want to modify $c:
    print scalar $c->bdiv(123.456),"\n";

instead.

=item brsft()

The following will probably not print what you expect:

	my $c = Math::BigFloat->new('3.14159');
        print $c->brsft(3,10),"\n";	# prints 0.00314153.1415

It prints both quotient and remainder, since print calls C<brsft()> in list
context. Also, C<< $c->brsft() >> will modify $c, so be careful.
You probably want to use

	print scalar $c->copy()->brsft(3,10),"\n";
	# or if you really want to modify $c
        print scalar $c->brsft(3,10),"\n";

instead.

=item Modifying and =

Beware of:

	$x = Math::BigFloat->new(5);
	$y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x will modify $y (except overloaded math operators), and vice
versa. See L<Math::BigInt> for details and how to avoid that.

=item bpow()

C<bpow()> now modifies the first argument, unlike the old code which left
it alone and only returned the result. This is to be consistent with
C<badd()> etc. The first will modify $x, the second one won't:

	print bpow($x,$i),"\n"; 	# modify $x
	print $x->bpow($i),"\n"; 	# ditto
	print $x ** $i,"\n";		# leave $x alone 

=item precision() vs. accuracy()

A common pitfall is to use L</precision()> when you want to round a result to
a certain number of digits:

    use Math::BigFloat;

    Math::BigFloat->precision(4);	    # does not do what you
					    # think it does
    my $x = Math::BigFloat->new(12345);	    # rounds $x to "12000"!
    print "$x\n";			    # print "12000"
    my $y = Math::BigFloat->new(3);	    # rounds $y to "0"!
    print "$y\n";			    # print "0"
    $z = $x / $y;			    # 12000 / 0 => NaN!
    print "$z\n";
    print $z->precision(),"\n";		    # 4

Replacing L</precision()> with L</accuracy()> is probably not what you want, either:

    use Math::BigFloat;

    Math::BigFloat->accuracy(4);	  # enables global rounding:
    my $x = Math::BigFloat->new(123456);  # rounded immediately
                                          #   to "12350"
    print "$x\n";			  # print "123500"
    my $y = Math::BigFloat->new(3);	  # rounded to "3
    print "$y\n";			  # print "3"
    print $z = $x->copy()->bdiv($y),"\n"; # 41170
    print $z->accuracy(),"\n";		  # 4

What you want to use instead is:

    use Math::BigFloat;

    my $x = Math::BigFloat->new(123456);    # no rounding
    print "$x\n";			    # print "123456"
    my $y = Math::BigFloat->new(3);	    # no rounding
    print "$y\n";			    # print "3"
    print $z = $x->copy()->bdiv($y,4),"\n"; # 41150
    print $z->accuracy(),"\n";		    # undef

In addition to computing what you expected, the last example also does B<not>
"taint" the result with an accuracy or precision setting, which would
influence any further operation.

=back

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigRat> and L<Math::Big> as well as
L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.

The pragmas L<bignum>, L<bigint> and L<bigrat> might also be of interest
because they solve the autoupgrading/downgrading issue, at least partly.

The package at L<http://search.cpan.org/~tels/Math-BigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 AUTHORS

Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels L<http://bloodgate.com> in 2001 - 2006, and still
at it in 2007.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/Math/BigInt/                                                                  0040755 0000000 0000000 00000000000 13077704254 014727  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Math/BigInt/Calc.pm                                                           0100644 0000000 0000000 00000233421 12744441327 016130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Math::BigInt::Calc;

use 5.006002;
use strict;
# use warnings;	# do not use warnings for older Perls

our $VERSION = '1.998';

# Package to store unsigned big integers in decimal and do math with them

# Internally the numbers are stored in an array with at least 1 element, no
# leading zero parts (except the first) and in base 1eX where X is determined
# automatically at loading time to be the maximum possible value

# todo:
# - fully remove funky $# stuff in div() (maybe - that code scares me...)

# USE_MUL: due to problems on certain os (os390, posix-bc) "* 1e-5" is used
# instead of "/ 1e5" at some places, (marked with USE_MUL). Other platforms
# BS2000, some Crays need USE_DIV instead.
# The BEGIN block is used to determine which of the two variants gives the
# correct result.

# Beware of things like:
# $i = $i * $y + $car; $car = int($i / $BASE); $i = $i % $BASE;
# This works on x86, but fails on ARM (SA1100, iPAQ) due to who knows what
# reasons. So, use this instead (slower, but correct):
# $i = $i * $y + $car; $car = int($i / $BASE); $i -= $BASE * $car;

##############################################################################
# global constants, flags and accessory

# announce that we are compatible with MBI v1.83 and up
sub api_version () { 2; }
 
# constants for easier life
my ($BASE,$BASE_LEN,$RBASE,$MAX_VAL);
my ($AND_BITS,$XOR_BITS,$OR_BITS);
my ($AND_MASK,$XOR_MASK,$OR_MASK);

sub _base_len 
  {
  # Set/get the BASE_LEN and assorted other, connected values.
  # Used only by the testsuite, the set variant is used only by the BEGIN
  # block below:
  shift;

  my ($b, $int) = @_;
  if (defined $b)
    {
    # avoid redefinitions
    undef &_mul;
    undef &_div;

    if ($] >= 5.008 && $int && $b > 7)
      {
      $BASE_LEN = $b;
      *_mul = \&_mul_use_div_64;
      *_div = \&_div_use_div_64;
      $BASE = int("1e".$BASE_LEN);
      $MAX_VAL = $BASE-1;
      return $BASE_LEN unless wantarray;
      return ($BASE_LEN, $BASE, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL,);
      }

    # find whether we can use mul or div in mul()/div()
    $BASE_LEN = $b+1;
    my $caught = 0;
    while (--$BASE_LEN > 5)
      {
      $BASE = int("1e".$BASE_LEN);
      $RBASE = abs('1e-'.$BASE_LEN);			# see USE_MUL
      $caught = 0;
      $caught += 1 if (int($BASE * $RBASE) != 1);	# should be 1
      $caught += 2 if (int($BASE / $BASE) != 1);	# should be 1
      last if $caught != 3;
      }
    $BASE = int("1e".$BASE_LEN);
    $RBASE = abs('1e-'.$BASE_LEN);			# see USE_MUL
    $MAX_VAL = $BASE-1;
   
    # ($caught & 1) != 0 => cannot use MUL
    # ($caught & 2) != 0 => cannot use DIV
    if ($caught == 2)				# 2
      {
      # must USE_MUL since we cannot use DIV
      *_mul = \&_mul_use_mul;
      *_div = \&_div_use_mul;
      }
    else					# 0 or 1
      {
      # can USE_DIV instead
      *_mul = \&_mul_use_div;
      *_div = \&_div_use_div;
      }
    }
  return $BASE_LEN unless wantarray;
  return ($BASE_LEN, $BASE, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL);
  }

sub _new
  {
  # (ref to string) return ref to num_array
  # Convert a number from string format (without sign) to internal base
  # 1ex format. Assumes normalized value as input.
  my $il = length($_[1])-1;

  # < BASE_LEN due len-1 above
  return [ int($_[1]) ] if $il < $BASE_LEN;	# shortcut for short numbers

  # this leaves '00000' instead of int 0 and will be corrected after any op
  [ reverse(unpack("a" . ($il % $BASE_LEN+1) 
    . ("a$BASE_LEN" x ($il / $BASE_LEN)), $_[1])) ];
  }                                                                             

BEGIN
  {
  # from Daniel Pfeiffer: determine largest group of digits that is precisely
  # multipliable with itself plus carry
  # Test now changed to expect the proper pattern, not a result off by 1 or 2
  my ($e, $num) = 3;	# lowest value we will use is 3+1-1 = 3
  do 
    {
    $num = ('9' x ++$e) + 0;
    $num *= $num + 1.0;
    } while ("$num" =~ /9{$e}0{$e}/);	# must be a certain pattern
  $e--; 				# last test failed, so retract one step
  # the limits below brush the problems with the test above under the rug:
  # the test should be able to find the proper $e automatically
  $e = 5 if $^O =~ /^uts/;	# UTS get's some special treatment
  $e = 5 if $^O =~ /^unicos/;	# unicos is also problematic (6 seems to work
				# there, but we play safe)

  my $int = 0;
  if ($e > 7)
    {
    use integer;
    my $e1 = 7;
    $num = 7;
    do 
      {
      $num = ('9' x ++$e1) + 0;
      $num *= $num + 1;
      } while ("$num" =~ /9{$e1}0{$e1}/);	# must be a certain pattern
    $e1--; 					# last test failed, so retract one step
    if ($e1 > 7)
      { 
      $int = 1; $e = $e1; 
      }
    }
 
  __PACKAGE__->_base_len($e,$int);	# set and store

  use integer;
  # find out how many bits _and, _or and _xor can take (old default = 16)
  # I don't think anybody has yet 128 bit scalars, so let's play safe.
  local $^W = 0;	# don't warn about 'nonportable number'
  $AND_BITS = 15; $XOR_BITS = 15; $OR_BITS = 15;

  # find max bits, we will not go higher than numberofbits that fit into $BASE
  # to make _and etc simpler (and faster for smaller, slower for large numbers)
  my $max = 16;
  while (2 ** $max < $BASE) { $max++; }
  {
    no integer;
    $max = 16 if $] < 5.006;	# older Perls might not take >16 too well
  }
  my ($x,$y,$z);
  do {
    $AND_BITS++;
    $x = CORE::oct('0b' . '1' x $AND_BITS); $y = $x & $x;
    $z = (2 ** $AND_BITS) - 1;
    } while ($AND_BITS < $max && $x == $z && $y == $x);
  $AND_BITS --;						# retreat one step
  do {
    $XOR_BITS++;
    $x = CORE::oct('0b' . '1' x $XOR_BITS); $y = $x ^ 0;
    $z = (2 ** $XOR_BITS) - 1;
    } while ($XOR_BITS < $max && $x == $z && $y == $x);
  $XOR_BITS --;						# retreat one step
  do {
    $OR_BITS++;
    $x = CORE::oct('0b' . '1' x $OR_BITS); $y = $x | $x;
    $z = (2 ** $OR_BITS) - 1;
    } while ($OR_BITS < $max && $x == $z && $y == $x);
  $OR_BITS --;						# retreat one step
  
  $AND_MASK = __PACKAGE__->_new( ( 2 ** $AND_BITS ));
  $XOR_MASK = __PACKAGE__->_new( ( 2 ** $XOR_BITS ));
  $OR_MASK = __PACKAGE__->_new( ( 2 ** $OR_BITS ));

  # We can compute the approximate length no faster than the real length:
  *_alen = \&_len;
  }

###############################################################################

sub _zero
  {
  # create a zero
  [ 0 ];
  }

sub _one
  {
  # create a one
  [ 1 ];
  }

sub _two
  {
  # create a two (used internally for shifting)
  [ 2 ];
  }

sub _ten
  {
  # create a 10 (used internally for shifting)
  [ 10 ];
  }

sub _1ex
  {
  # create a 1Ex
  my $rem = $_[1] % $BASE_LEN;		# remainder
  my $parts = $_[1] / $BASE_LEN;	# parts

  # 000000, 000000, 100 
  [ (0) x $parts, '1' . ('0' x $rem) ];
  }

sub _copy
  {
  # make a true copy
  [ @{$_[1]} ];
  }

# catch and throw away
sub import { }

##############################################################################
# convert back to string and number

sub _str
  {
  # (ref to BINT) return num_str
  # Convert number from internal base 100000 format to string format.
  # internal format is always normalized (no leading zeros, "-0" => "+0")
  my $ar = $_[1];

  my $l = scalar @$ar;				# number of parts
  if ($l < 1)					# should not happen
    {
    require Carp;
    Carp::croak("$_[1] has no elements");
    }

  my $ret = "";
  # handle first one different to strip leading zeros from it (there are no
  # leading zero parts in internal representation)
  $l --; $ret .= int($ar->[$l]); $l--;
  # Interestingly, the pre-padd method uses more time
  # the old grep variant takes longer (14 vs. 10 sec)
  my $z = '0' x ($BASE_LEN-1);                            
  while ($l >= 0)
    {
    $ret .= substr($z.$ar->[$l],-$BASE_LEN); # fastest way I could think of
    $l--;
    }
  $ret;
  }                                                                             

sub _num
  {
    # Make a Perl scalar number (int/float) from a BigInt object.
    my $x = $_[1];

    return 0 + $x->[0] if scalar @$x == 1;      # below $BASE

    # Start with the most significant element and work towards the least
    # significant element. Avoid multiplying "inf" (which happens if the number
    # overflows) with "0" (if there are zero elements in $x) since this gives
    # "nan" which propagates to the output.

    my $num = 0;
    for (my $i = $#$x ; $i >= 0 ; --$i) {
        $num *= $BASE;
        $num += $x -> [$i];
    }
    return $num;
  }

##############################################################################
# actual math code

sub _add
  {
  # (ref to int_num_array, ref to int_num_array)
  # routine to add two base 1eX numbers
  # stolen from Knuth Vol 2 Algorithm A pg 231
  # there are separate routines to add and sub as per Knuth pg 233
  # This routine modifies array x, but not y.
 
  my ($c,$x,$y) = @_;

  return $x if (@$y == 1) && $y->[0] == 0;		# $x + 0 => $x
  if ((@$x == 1) && $x->[0] == 0)			# 0 + $y => $y->copy
    {
    # twice as slow as $x = [ @$y ], but nec. to retain $x as ref :(
    @$x = @$y; return $x;		
    }
 
  # for each in Y, add Y to X and carry. If after that, something is left in
  # X, foreach in X add carry to X and then return X, carry
  # Trades one "$j++" for having to shift arrays
  my $i; my $car = 0; my $j = 0;
  for $i (@$y)
    {
    $x->[$j] -= $BASE if $car = (($x->[$j] += $i + $car) >= $BASE) ? 1 : 0;
    $j++;
    }
  while ($car != 0)
    {
    $x->[$j] -= $BASE if $car = (($x->[$j] += $car) >= $BASE) ? 1 : 0; $j++;
    }
  $x;
  }                                                                             

sub _inc
  {
  # (ref to int_num_array, ref to int_num_array)
  # Add 1 to $x, modify $x in place
  my ($c,$x) = @_;

  for my $i (@$x)
    {
    return $x if (($i += 1) < $BASE);		# early out
    $i = 0;					# overflow, next
    }
  push @$x,1 if (($x->[-1] || 0) == 0);		# last overflowed, so extend
  $x;
  }                                                                             

sub _dec
  {
  # (ref to int_num_array, ref to int_num_array)
  # Sub 1 from $x, modify $x in place
  my ($c,$x) = @_;

  my $MAX = $BASE-1;				# since MAX_VAL based on BASE
  for my $i (@$x)
    {
    last if (($i -= 1) >= 0);			# early out
    $i = $MAX;					# underflow, next
    }
  pop @$x if $x->[-1] == 0 && @$x > 1;		# last underflowed (but leave 0)
  $x;
  }                                                                             

sub _sub
  {
  # (ref to int_num_array, ref to int_num_array, swap)
  # subtract base 1eX numbers -- stolen from Knuth Vol 2 pg 232, $x > $y
  # subtract Y from X by modifying x in place
  my ($c,$sx,$sy,$s) = @_;
 
  my $car = 0; my $i; my $j = 0;
  if (!$s)
    {
    for $i (@$sx)
      {
      last unless defined $sy->[$j] || $car;
      $i += $BASE if $car = (($i -= ($sy->[$j] || 0) + $car) < 0); $j++;
      }
    # might leave leading zeros, so fix that
    return __strip_zeros($sx);
    }
  for $i (@$sx)
    {
    # we can't do an early out if $x is < than $y, since we
    # need to copy the high chunks from $y. Found by Bob Mathews.
    #last unless defined $sy->[$j] || $car;
    $sy->[$j] += $BASE
     if $car = (($sy->[$j] = $i-($sy->[$j]||0) - $car) < 0);
    $j++;
    }
  # might leave leading zeros, so fix that
  __strip_zeros($sy);
  }                                                                             

sub _mul_use_mul
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  my ($c,$xv,$yv) = @_;

  if (@$yv == 1)
    {
    # shortcut for two very short numbers (improved by Nathan Zook)
    # works also if xv and yv are the same reference, and handles also $x == 0
    if (@$xv == 1)
      {
      if (($xv->[0] *= $yv->[0]) >= $BASE)
         {
         $xv->[0] = $xv->[0] - ($xv->[1] = int($xv->[0] * $RBASE)) * $BASE;
         };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@$xv)
      {
      $i = $i * $y + $car; $car = int($i * $RBASE); $i -= $car * $BASE;
      }
    push @$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@$xv] if $xv == $yv;	# same references?

  my @prod = (); my ($prod,$car,$cty,$xi,$yi);

  for $xi (@$xv)
    {
    $car = 0; $cty = 0;

    # slow variant
#    for $yi (@$yv)
#      {
#      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
#      $prod[$cty++] =
#       $prod - ($car = int($prod * RBASE)) * $BASE;  # see USE_MUL
#      }
#    $prod[$cty] += $car if $car; # need really to check for 0?
#    $xi = shift @prod;

    # faster variant
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @prod || 0), next if $xi == 0;
    for $yi (@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
##     this is actually a tad slower
##        $prod = $prod[$cty]; $prod += ($car + $xi * $yi);	# no ||0 here
      $prod[$cty++] =
       $prod - ($car = int($prod * $RBASE)) * $BASE;  # see USE_MUL
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @$xv, @prod;
  # can't have leading zeros
#  __strip_zeros($xv);
  $xv;
  }                                                                             

sub _mul_use_div_64
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  # works for 64 bit integer with "use integer"
  my ($c,$xv,$yv) = @_;

  use integer;
  if (@$yv == 1)
    {
    # shortcut for two small numbers, also handles $x == 0
    if (@$xv == 1)
      {
      # shortcut for two very short numbers (improved by Nathan Zook)
      # works also if xv and yv are the same reference, and handles also $x == 0
      if (($xv->[0] *= $yv->[0]) >= $BASE)
          {
          $xv->[0] =
              $xv->[0] - ($xv->[1] = $xv->[0] / $BASE) * $BASE;
          };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@$xv)
      {
      #$i = $i * $y + $car; $car = $i / $BASE; $i -= $car * $BASE;
      $i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;
      }
    push @$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@$xv] if $xv == $yv;	# same references?

  my @prod = (); my ($prod,$car,$cty,$xi,$yi);
  for $xi (@$xv)
    {
    $car = 0; $cty = 0;
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @prod || 0), next if $xi == 0;
    for $yi (@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
      $prod[$cty++] = $prod - ($car = $prod / $BASE) * $BASE;
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @$xv, @prod;
  $xv;
  }                                                                             

sub _mul_use_div
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  my ($c,$xv,$yv) = @_;

  if (@$yv == 1)
    {
    # shortcut for two small numbers, also handles $x == 0
    if (@$xv == 1)
      {
      # shortcut for two very short numbers (improved by Nathan Zook)
      # works also if xv and yv are the same reference, and handles also $x == 0
      if (($xv->[0] *= $yv->[0]) >= $BASE)
          {
          $xv->[0] =
              $xv->[0] - ($xv->[1] = int($xv->[0] / $BASE)) * $BASE;
          };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@$xv)
      {
      $i = $i * $y + $car; $car = int($i / $BASE); $i -= $car * $BASE;
      # This (together with use integer;) does not work on 32-bit Perls
      #$i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;
      }
    push @$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@$xv] if $xv == $yv;	# same references?

  my @prod = (); my ($prod,$car,$cty,$xi,$yi);
  for $xi (@$xv)
    {
    $car = 0; $cty = 0;
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @prod || 0), next if $xi == 0;
    for $yi (@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
      $prod[$cty++] = $prod - ($car = int($prod / $BASE)) * $BASE;
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @$xv, @prod;
  # can't have leading zeros
#  __strip_zeros($xv);
  $xv;
  }                                                                             

sub _div_use_mul
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context

  # see comments in _div_use_div() for more explanations

  my ($c,$x,$yorg) = @_;
  
  # the general div algorithm here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@$x == 1 && @$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }

  # if x has more than one, but y has only one element:
  if (@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @$x if @$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }

  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@$yorg > @$x)
    {
    my $rem;
    $rem = [@$x] if wantarray;                  # make copy
    splice (@$x,1);                             # keep ref to original array
    $x->[0] = 0;                                # set to 0
    return ($x,$rem) if wantarray;              # including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@$yorg == @$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@$x] if wantarray;		# make copy
      splice (@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg
    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];                   # a = 0 => x == y => rem 0
        $rem = [@$x] if $a != 0;        # a < 0 => x < y => rem = x
        splice(@$x,1);                  # keep single element
        $x->[0] = 0;                    # if $a < 0
        $x->[0] = 1 if $a == 0;         # $x == $y
        return ($x,$rem) if wantarray;
        return $x;
        }
      # $x >= $y, so proceed normally
      }
    }

  # all other cases:

  my $y = [ @$yorg ];				# always make copy to preserve

  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi * $RBASE)) * $BASE;	# see USE_MUL
      }
    push(@$x, $car); $car = 0;
    for $yi (@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi * $RBASE)) * $BASE;	# see USE_MUL
      }
    }
  else 
    {
    push(@$x, 0);
    }
  @q = (); ($v2,$v1) = @$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd * $RBASE)) * $BASE;	# see USE_MUL
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@$x);
    unshift(@q, $q);
    }
  if (wantarray) 
    {
    @d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd; # see USE_MUL
        unshift(@d, $tmp);
        }
      }
    else 
      {
      @d = @$x;
      }
    @$x = @q;
    my $d = \@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @$x = @q;
  __strip_zeros($x);
  $x;
  }

sub _div_use_div_64
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  # This version works on 64 bit integers
  my ($c,$x,$yorg) = @_;

  use integer;
  # the general div algorithm here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@$x == 1 && @$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  # if x has more than one, but y has only one element:
  if (@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @$x if @$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }
  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@$yorg > @$x)
    {
    my $rem;
    $rem = [@$x] if wantarray;			# make copy
    splice (@$x,1);				# keep ref to original array
    $x->[0] = 0;				# set to 0
    return ($x,$rem) if wantarray;		# including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@$yorg == @$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@$x] if wantarray;		# make copy
      splice (@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg

    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];			# a = 0 => x == y => rem 0
        $rem = [@$x] if $a != 0;	# a < 0 => x < y => rem = x
        splice(@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        $x->[0] = 1 if $a == 0; 	# $x == $y
        return ($x,$rem) if wantarray;	# including remainder?
        return $x;
        }
      # $x >= $y, so proceed normally

      }
    }

  # all other cases:

  my $y = [ @$yorg ];				# always make copy to preserve
 
  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi / $BASE)) * $BASE;
      }
    push(@$x, $car); $car = 0;
    for $yi (@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi / $BASE)) * $BASE;
      }
    }
  else 
    {
    push(@$x, 0);
    }

  # @q will accumulate the final result, $q contains the current computed
  # part of the final result

  @q = (); ($v2,$v1) = @$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd / $BASE)) * $BASE;
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@$x); unshift(@q, $q);
    }
  if (wantarray) 
    {
    @d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd;
        unshift(@d, $tmp);
        }
      }
    else 
      {
      @d = @$x;
      }
    @$x = @q;
    my $d = \@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @$x = @q;
  __strip_zeros($x);
  $x;
  }

sub _div_use_div
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  my ($c,$x,$yorg) = @_;

  # the general div algorithm here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@$x == 1 && @$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  # if x has more than one, but y has only one element:
  if (@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @$x if @$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }
  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@$yorg > @$x)
    {
    my $rem;
    $rem = [@$x] if wantarray;			# make copy
    splice (@$x,1);				# keep ref to original array
    $x->[0] = 0;				# set to 0
    return ($x,$rem) if wantarray;		# including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@$yorg == @$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@$x] if wantarray;		# make copy
      splice (@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg

    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];			# a = 0 => x == y => rem 0
        $rem = [@$x] if $a != 0;	# a < 0 => x < y => rem = x
        splice(@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        $x->[0] = 1 if $a == 0; 	# $x == $y
        return ($x,$rem) if wantarray;	# including remainder?
        return $x;
        }
      # $x >= $y, so proceed normally

      }
    }

  # all other cases:

  my $y = [ @$yorg ];				# always make copy to preserve
 
  my ($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi / $BASE)) * $BASE;
      }
    push(@$x, $car); $car = 0;
    for $yi (@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi / $BASE)) * $BASE;
      }
    }
  else 
    {
    push(@$x, 0);
    }

  # @q will accumulate the final result, $q contains the current computed
  # part of the final result

  @q = (); ($v2,$v1) = @$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd / $BASE)) * $BASE;
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@$x); unshift(@q, $q);
    }
  if (wantarray) 
    {
    @d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd;
        unshift(@d, $tmp);
        }
      }
    else 
      {
      @d = @$x;
      }
    @$x = @q;
    my $d = \@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @$x = @q;
  __strip_zeros($x);
  $x;
  }

##############################################################################
# testing

sub _acmp
  {
  # internal absolute post-normalized compare (ignore signs)
  # ref to array, ref to array, return <0, 0, >0
  # arrays must have at least one entry; this is not checked for
  my ($c,$cx,$cy) = @_;
 
  # shortcut for short numbers 
  return (($cx->[0] <=> $cy->[0]) <=> 0) 
   if scalar @$cx == scalar @$cy && scalar @$cx == 1;

  # fast comp based on number of array elements (aka pseudo-length)
  my $lxy = (scalar @$cx - scalar @$cy)
  # or length of first element if same number of elements (aka difference 0)
    ||
  # need int() here because sometimes the last element is '00018' vs '18'
   (length(int($cx->[-1])) - length(int($cy->[-1])));
  return -1 if $lxy < 0;				# already differs, ret
  return 1 if $lxy > 0;					# ditto

  # manual way (abort if unequal, good for early ne)
  my $a; my $j = scalar @$cx;
  while (--$j >= 0)
    {
    last if ($a = $cx->[$j] - $cy->[$j]);
    }
  $a <=> 0;
  }

sub _len
  {
  # compute number of digits in base 10

  # int() because add/sub sometimes leaves strings (like '00005') instead of
  # '5' in this place, thus causing length() to report wrong length
  my $cx = $_[1];

  (@$cx-1)*$BASE_LEN+length(int($cx->[-1]));
  }

sub _digit
  {
  # Return the nth digit. Zero is rightmost, so _digit(123,0) gives 3.
  # Negative values count from the left, so _digit(123, -1) gives 1.
  my ($c,$x,$n) = @_;

  my $len = _len('',$x);

  $n += $len if $n < 0;                 # -1 last, -2 second-to-last
  return "0" if $n < 0 || $n >= $len;   # return 0 for digits out of range

  my $elem = int($n / $BASE_LEN);       # which array element
  my $digit = $n % $BASE_LEN;           # which digit in this element
  substr("$x->[$elem]", -$digit-1, 1);
  }

sub _zeros
  {
  # return amount of trailing zeros in decimal
  # check each array elem in _m for having 0 at end as long as elem == 0
  # Upon finding a elem != 0, stop
  my $x = $_[1];

  return 0 if scalar @$x == 1 && $x->[0] == 0;

  my $zeros = 0; my $elem;
  foreach my $e (@$x)
    {
    if ($e != 0)
      {
      $elem = "$e";				# preserve x
      $elem =~ s/.*?(0*$)/$1/;			# strip anything not zero
      $zeros *= $BASE_LEN;			# elems * 5
      $zeros += length($elem);			# count trailing zeros
      last;					# early out
      }
    $zeros ++;					# real else branch: 50% slower!
    }
  $zeros;
  }

##############################################################################
# _is_* routines

sub _is_zero
  {
  # return true if arg is zero 
  (((scalar @{$_[1]} == 1) && ($_[1]->[0] == 0))) <=> 0;
  }

sub _is_even
  {
  # return true if arg is even
  (!($_[1]->[0] & 1)) <=> 0; 
  }

sub _is_odd
  {
  # return true if arg is odd
  (($_[1]->[0] & 1)) <=> 0;
  }

sub _is_one
  {
  # return true if arg is one
  (scalar @{$_[1]} == 1) && ($_[1]->[0] == 1) <=> 0; 
  }

sub _is_two
  {
  # return true if arg is two 
  (scalar @{$_[1]} == 1) && ($_[1]->[0] == 2) <=> 0; 
  }

sub _is_ten
  {
  # return true if arg is ten 
  (scalar @{$_[1]} == 1) && ($_[1]->[0] == 10) <=> 0; 
  }

sub __strip_zeros
  {
  # internal normalization function that strips leading zeros from the array
  # args: ref to array
  my $s = shift;
 
  my $cnt = scalar @$s; # get count of parts
  my $i = $cnt-1;
  push @$s,0 if $i < 0;		# div might return empty results, so fix it

  return $s if @$s == 1;		# early out

  #print "strip: cnt $cnt i $i\n";
  # '0', '3', '4', '0', '0',
  #  0    1    2    3    4
  # cnt = 5, i = 4
  # i = 4
  # i = 3
  # => fcnt = cnt - i (5-2 => 3, cnt => 5-1 = 4, throw away from 4th pos)
  # >= 1: skip first part (this can be zero)
  while ($i > 0) { last if $s->[$i] != 0; $i--; }
  $i++; splice @$s,$i if ($i < $cnt); # $i cant be 0
  $s;                                                                    
  }                                                                             

###############################################################################
# check routine to test internal state for corruptions

sub _check
  {
  # used by the test suite
  my $x = $_[1];

  return "$x is not a reference" if !ref($x);

  # are all parts are valid?
  my $i = 0; my $j = scalar @$x; my ($e,$try);
  while ($i < $j)
    {
    $e = $x->[$i]; $e = 'undef' unless defined $e;
    $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e)";
    last if $e !~ /^[+]?[0-9]+$/;
    $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e) (stringify)";
    last if "$e" !~ /^[+]?[0-9]+$/;
    $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e) (cat-stringify)";
    last if '' . "$e" !~ /^[+]?[0-9]+$/;
    $try = ' < 0 || >= $BASE; '."($x, $e)";
    last if $e <0 || $e >= $BASE;
    # this test is disabled, since new/bnorm and certain ops (like early out
    # in add/sub) are allowed/expected to leave '00000' in some elements
    #$try = '=~ /^00+/; '."($x, $e)";
    #last if $e =~ /^00+/;
    $i++;
    }
  return "Illegal part '$e' at pos $i (tested: $try)" if $i < $j;
  0;
  }


###############################################################################

sub _mod
  {
  # if possible, use mod shortcut
  my ($c,$x,$yo) = @_;

  # slow way since $y too big
  if (scalar @$yo > 1)
    {
    my ($xo,$rem) = _div($c,$x,$yo);
    @$x = @$rem;
    return $x;
    }

  my $y = $yo->[0];

  # if both are single element arrays
  if (scalar @$x == 1)
    {
    $x->[0] %= $y;
    return $x;
    }

  # if @$x has more than one element, but @$y is a single element
  my $b = $BASE % $y;
  if ($b == 0)
    {
    # when BASE % Y == 0 then (B * BASE) % Y == 0
    # (B * BASE) % $y + A % Y => A % Y
    # so need to consider only last element: O(1)
    $x->[0] %= $y;
    }
  elsif ($b == 1)
    {
    # else need to go through all elements in @$x: O(N), but loop is a bit
    # simplified
    my $r = 0;
    foreach (@$x)
      {
      $r = ($r + $_) % $y;		# not much faster, but heh...
      #$r += $_ % $y; $r %= $y;
      }
    $r = 0 if $r == $y;
    $x->[0] = $r;
    }
  else
    {
    # else need to go through all elements in @$x: O(N)
    my $r = 0;
    my $bm = 1;
    foreach (@$x)
      {
      $r = ($_ * $bm + $r) % $y;
      $bm = ($bm * $b) % $y;

      #$r += ($_ % $y) * $bm;
      #$bm *= $b;
      #$bm %= $y;
      #$r %= $y;
      }
    $r = 0 if $r == $y;
    $x->[0] = $r;
    }
  @$x = $x->[0];		# keep one element of @$x
  return $x;
  }

##############################################################################
# shifts

sub _rsft
  {
  my ($c,$x,$y,$n) = @_;

  if ($n != 10)
    {
    $n = _new($c,$n); return _div($c,$x, _pow($c,$n,$y));
    }

  # shortcut (faster) for shifting by 10)
  # multiples of $BASE_LEN
  my $dst = 0;				# destination
  my $src = _num($c,$y);		# as normal int
  my $xlen = (@$x-1)*$BASE_LEN+length(int($x->[-1]));  # len of x in digits
  if ($src >= $xlen or ($src == $xlen and ! defined $x->[1]))
    {
    # 12345 67890 shifted right by more than 10 digits => 0
    splice (@$x,1);                    # leave only one element
    $x->[0] = 0;                       # set to zero
    return $x;
    }
  my $rem = $src % $BASE_LEN;		# remainder to shift
  $src = int($src / $BASE_LEN);		# source
  if ($rem == 0)
    {
    splice (@$x,0,$src);		# even faster, 38.4 => 39.3
    }
  else
    {
    my $len = scalar @$x - $src;	# elems to go
    my $vd; my $z = '0'x $BASE_LEN;
    $x->[scalar @$x] = 0;		# avoid || 0 test inside loop
    while ($dst < $len)
      {
      $vd = $z.$x->[$src];
      $vd = substr($vd,-$BASE_LEN,$BASE_LEN-$rem);
      $src++;
      $vd = substr($z.$x->[$src],-$rem,$rem) . $vd;
      $vd = substr($vd,-$BASE_LEN,$BASE_LEN) if length($vd) > $BASE_LEN;
      $x->[$dst] = int($vd);
      $dst++;
      }
    splice (@$x,$dst) if $dst > 0;		# kill left-over array elems
    pop @$x if $x->[-1] == 0 && @$x > 1;	# kill last element if 0
    } # else rem == 0
  $x;
  }

sub _lsft
  {
  my ($c,$x,$y,$n) = @_;

  if ($n != 10)
    {
    $n = _new($c,$n); return _mul($c,$x, _pow($c,$n,$y));
    }

  # shortcut (faster) for shifting by 10) since we are in base 10eX
  # multiples of $BASE_LEN:
  my $src = scalar @$x;			# source
  my $len = _num($c,$y);		# shift-len as normal int
  my $rem = $len % $BASE_LEN;		# remainder to shift
  my $dst = $src + int($len/$BASE_LEN);	# destination
  my $vd;				# further speedup
  $x->[$src] = 0;			# avoid first ||0 for speed
  my $z = '0' x $BASE_LEN;
  while ($src >= 0)
    {
    $vd = $x->[$src]; $vd = $z.$vd;
    $vd = substr($vd,-$BASE_LEN+$rem,$BASE_LEN-$rem);
    $vd .= $src > 0 ? substr($z.$x->[$src-1],-$BASE_LEN,$rem) : '0' x $rem;
    $vd = substr($vd,-$BASE_LEN,$BASE_LEN) if length($vd) > $BASE_LEN;
    $x->[$dst] = int($vd);
    $dst--; $src--;
    }
  # set lowest parts to 0
  while ($dst >= 0) { $x->[$dst--] = 0; }
  # fix spurious last zero element
  splice @$x,-1 if $x->[-1] == 0;
  $x;
  }

sub _pow
  {
  # power of $x to $y
  # ref to array, ref to array, return ref to array
  my ($c,$cx,$cy) = @_;

  if (scalar @$cy == 1 && $cy->[0] == 0)
    {
    splice (@$cx,1); $cx->[0] = 1;		# y == 0 => x => 1
    return $cx;
    }
  if ((scalar @$cx == 1 && $cx->[0] == 1) ||	#    x == 1
      (scalar @$cy == 1 && $cy->[0] == 1))	# or y == 1
    {
    return $cx;
    }
  if (scalar @$cx == 1 && $cx->[0] == 0)
    {
    splice (@$cx,1); $cx->[0] = 0;		# 0 ** y => 0 (if not y <= 0)
    return $cx;
    }

  my $pow2 = _one();

  my $y_bin = _as_bin($c,$cy); $y_bin =~ s/^0b//;
  my $len = length($y_bin);
  while (--$len > 0)
    {
    _mul($c,$pow2,$cx) if substr($y_bin,$len,1) eq '1';		# is odd?
    _mul($c,$cx,$cx);
    }

  _mul($c,$cx,$pow2);
  $cx;
  }

sub _nok {
    # Return binomial coefficient (n over k).
    # Given refs to arrays, return ref to array.
    # First input argument is modified.

    my ($c, $n, $k) = @_;

    # If k > n/2, or, equivalently, 2*k > n, compute nok(n, k) as
    # nok(n, n-k), to minimize the number if iterations in the loop.

    {
        my $twok = _mul($c, _two($c), _copy($c, $k));   # 2 * k
        if (_acmp($c, $twok, $n) > 0) {                 # if 2*k > n
            $k = _sub($c, _copy($c, $n), $k);           # k = n - k
        }
    }

    # Example:
    #
    # / 7 \       7!       1*2*3*4 * 5*6*7   5 * 6 * 7       6   7
    # |   | = --------- =  --------------- = --------- = 5 * - * -
    # \ 3 /   (7-3)! 3!    1*2*3*4 * 1*2*3   1 * 2 * 3       2   3

    if (_is_zero($c, $k)) {
        @$n = 1;
    }

    else {

        # Make a copy of the original n, since we'll be modifying n in-place.

        my $n_orig = _copy($c, $n);

        # n = 5, f = 6, d = 2 (cf. example above)

        _sub($c, $n, $k);
        _inc($c, $n);

        my $f = _copy($c, $n);
        _inc($c, $f);

        my $d = _two($c);

        # while f <= n (the original n, that is) ...

        while (_acmp($c, $f, $n_orig) <= 0) {

            # n = (n * f / d) == 5 * 6 / 2 (cf. example above)

            _mul($c, $n, $f);
            _div($c, $n, $d);

            # f = 7, d = 3 (cf. example above)

            _inc($c, $f);
            _inc($c, $d);
        }

    }

    return $n;
}

my @factorials = (
  1,
  1,
  2,
  2*3,
  2*3*4,
  2*3*4*5,
  2*3*4*5*6,
  2*3*4*5*6*7,
);

sub _fac
  {
  # factorial of $x
  # ref to array, return ref to array
  my ($c,$cx) = @_;

  if ((@$cx == 1) && ($cx->[0] <= 7))
    {
    $cx->[0] = $factorials[$cx->[0]];		# 0 => 1, 1 => 1, 2 => 2 etc.
    return $cx;
    }

  if ((@$cx == 1) && 		# we do this only if $x >= 12 and $x <= 7000
      ($cx->[0] >= 12 && $cx->[0] < 7000))
    {

  # Calculate (k-j) * (k-j+1) ... k .. (k+j-1) * (k + j)
  # See http://blogten.blogspot.com/2007/01/calculating-n.html
  # The above series can be expressed as factors:
  #   k * k - (j - i) * 2
  # We cache k*k, and calculate (j * j) as the sum of the first j odd integers

  # This will not work when N exceeds the storage of a Perl scalar, however,
  # in this case the algorithm would be way to slow to terminate, anyway.

  # As soon as the last element of $cx is 0, we split it up and remember
  # how many zeors we got so far. The reason is that n! will accumulate
  # zeros at the end rather fast.
  my $zero_elements = 0;

  # If n is even, set n = n -1
  my $k = _num($c,$cx); my $even = 1;
  if (($k & 1) == 0)
    {
    $even = $k; $k --;
    }
  # set k to the center point
  $k = ($k + 1) / 2;
#  print "k $k even: $even\n";
  # now calculate k * k
  my $k2 = $k * $k;
  my $odd = 1; my $sum = 1;
  my $i = $k - 1;
  # keep reference to x
  my $new_x = _new($c, $k * $even);
  @$cx = @$new_x;
  if ($cx->[0] == 0)
    {
    $zero_elements ++; shift @$cx;
    }
#  print STDERR "x = ", _str($c,$cx),"\n";
  my $BASE2 = int(sqrt($BASE))-1;
  my $j = 1; 
  while ($j <= $i)
    {
    my $m = ($k2 - $sum); $odd += 2; $sum += $odd; $j++;
    while ($j <= $i && ($m < $BASE2) && (($k2 - $sum) < $BASE2))
      {
      $m *= ($k2 - $sum);
      $odd += 2; $sum += $odd; $j++;
#      print STDERR "\n k2 $k2 m $m sum $sum odd $odd\n"; sleep(1);
      }
    if ($m < $BASE)
      {
      _mul($c,$cx,[$m]);
      }
    else
      {
      _mul($c,$cx,$c->_new($m));
      }
    if ($cx->[0] == 0)
      {
      $zero_elements ++; shift @$cx;
      }
#    print STDERR "Calculate $k2 - $sum = $m (x = ", _str($c,$cx),")\n";
    }
  # multiply in the zeros again
  unshift @$cx, (0) x $zero_elements; 
  return $cx;
  }

  # go forward until $base is exceeded
  # limit is either $x steps (steps == 100 means a result always too high) or
  # $base.
  my $steps = 100; $steps = $cx->[0] if @$cx == 1;
  my $r = 2; my $cf = 3; my $step = 2; my $last = $r;
  while ($r*$cf < $BASE && $step < $steps)
    {
    $last = $r; $r *= $cf++; $step++;
    }
  if ((@$cx == 1) && $step == $cx->[0])
    {
    # completely done, so keep reference to $x and return
    $cx->[0] = $r;
    return $cx;
    }
  
  # now we must do the left over steps
  my $n;					# steps still to do
  if (scalar @$cx == 1)
    {
    $n = $cx->[0];
    }
  else
    {
    $n = _copy($c,$cx);
    }

  # Set $cx to the last result below $BASE (but keep ref to $x)
  $cx->[0] = $last; splice (@$cx,1);
  # As soon as the last element of $cx is 0, we split it up and remember
  # how many zeors we got so far. The reason is that n! will accumulate
  # zeros at the end rather fast.
  my $zero_elements = 0;

  # do left-over steps fit into a scalar?
  if (ref $n eq 'ARRAY')
    {
    # No, so use slower inc() & cmp()
    # ($n is at least $BASE here)
    my $base_2 = int(sqrt($BASE)) - 1;
    #print STDERR "base_2: $base_2\n"; 
    while ($step < $base_2)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      my $b = $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    $step = [$step];
    while (_acmp($c,$step,$n) <= 0)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      _mul($c,$cx,$step); _inc($c,$step);
      }
    }
  else
    {
    # Yes, so we can speed it up slightly
  
#    print "# left over steps $n\n";

    my $base_4 = int(sqrt(sqrt($BASE))) - 2;
    #print STDERR "base_4: $base_4\n";
    my $n4 = $n - 4; 
    while ($step < $n4 && $step < $base_4)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      my $b = $step * ($step + 1); $step += 2; $b *= $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    my $base_2 = int(sqrt($BASE)) - 1;
    my $n2 = $n - 2; 
    #print STDERR "base_2: $base_2\n"; 
    while ($step < $n2 && $step < $base_2)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      my $b = $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    # do what's left over
    while ($step <= $n)
      {
      _mul($c,$cx,[$step]); $step++;
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @$cx;
        }
      }
    }
  # multiply in the zeros again
  unshift @$cx, (0) x $zero_elements;
  $cx;			# return result
  }

#############################################################################

sub _log_int
  {
  # calculate integer log of $x to base $base
  # ref to array, ref to array - return ref to array
  my ($c,$x,$base) = @_;

  # X == 0 => NaN
  return if (scalar @$x == 1 && $x->[0] == 0);
  # BASE 0 or 1 => NaN
  return if (scalar @$base == 1 && $base->[0] < 2);
  my $cmp = _acmp($c,$x,$base); # X == BASE => 1
  if ($cmp == 0)
    {
    splice (@$x,1); $x->[0] = 1;
    return ($x,1)
    }
  # X < BASE
  if ($cmp < 0)
    {
    splice (@$x,1); $x->[0] = 0;
    return ($x,undef);
    }

  my $x_org = _copy($c,$x);		# preserve x
  splice(@$x,1); $x->[0] = 1;		# keep ref to $x

  # Compute a guess for the result based on:
  # $guess = int ( length_in_base_10(X) / ( log(base) / log(10) ) )
  my $len = _len($c,$x_org);
  my $log = log($base->[-1]) / log(10);

  # for each additional element in $base, we add $BASE_LEN to the result,
  # based on the observation that log($BASE,10) is BASE_LEN and
  # log(x*y) == log(x) + log(y):
  $log += ((scalar @$base)-1) * $BASE_LEN;

  # calculate now a guess based on the values obtained above:
  my $res = int($len / $log);

  $x->[0] = $res;
  my $trial = _pow ($c, _copy($c, $base), $x);
  my $a = _acmp($c,$trial,$x_org);

#  print STDERR "# trial ", _str($c,$x)," was: $a (0 = exact, -1 too small, +1 too big)\n";

  # found an exact result?
  return ($x,1) if $a == 0;

  if ($a > 0)
    {
    # or too big
    _div($c,$trial,$base); _dec($c, $x);
    while (($a = _acmp($c,$trial,$x_org)) > 0)
      {
#      print STDERR "# big _log_int at ", _str($c,$x), "\n"; 
      _div($c,$trial,$base); _dec($c, $x);
      }
    # result is now exact (a == 0), or too small (a < 0)
    return ($x, $a == 0 ? 1 : 0);
    }

  # else: result was to small
  _mul($c,$trial,$base);

  # did we now get the right result?
  $a = _acmp($c,$trial,$x_org);

  if ($a == 0)				# yes, exactly
    {
    _inc($c, $x);
    return ($x,1); 
    }
  return ($x,0) if $a > 0;  

  # Result still too small (we should come here only if the estimate above
  # was very off base):
 
  # Now let the normal trial run obtain the real result
  # Simple loop that increments $x by 2 in each step, possible overstepping
  # the real result

  my $base_mul = _mul($c, _copy($c,$base), $base);	# $base * $base

  while (($a = _acmp($c,$trial,$x_org)) < 0)
    {
#    print STDERR "# small _log_int at ", _str($c,$x), "\n"; 
    _mul($c,$trial,$base_mul); _add($c, $x, [2]);
    }

  my $exact = 1;
  if ($a > 0)
    {
    # overstepped the result
    _dec($c, $x);
    _div($c,$trial,$base);
    $a = _acmp($c,$trial,$x_org);
    if ($a > 0)
      {
      _dec($c, $x);
      }
    $exact = 0 if $a != 0;		# a = -1 => not exact result, a = 0 => exact
    }
  
  ($x,$exact);				# return result
  }

# for debugging:
  use constant DEBUG => 0;
  my $steps = 0;
  sub steps { $steps };

sub _sqrt
  {
  # square-root of $x in place
  # Compute a guess of the result (by rule of thumb), then improve it via
  # Newton's method.
  my ($c,$x) = @_;

  if (scalar @$x == 1)
    {
    # fits into one Perl scalar, so result can be computed directly
    $x->[0] = int(sqrt($x->[0]));
    return $x;
    } 
  my $y = _copy($c,$x);
  # hopefully _len/2 is < $BASE, the -1 is to always undershot the guess
  # since our guess will "grow"
  my $l = int((_len($c,$x)-1) / 2);	

  my $lastelem = $x->[-1];					# for guess
  my $elems = scalar @$x - 1;
  # not enough digits, but could have more?
  if ((length($lastelem) <= 3) && ($elems > 1))
    {
    # right-align with zero pad
    my $len = length($lastelem) & 1;
    print "$lastelem => " if DEBUG;
    $lastelem .= substr($x->[-2] . '0' x $BASE_LEN,0,$BASE_LEN);
    # former odd => make odd again, or former even to even again
    $lastelem = $lastelem / 10 if (length($lastelem) & 1) != $len;
    print "$lastelem\n" if DEBUG;
    }

  # construct $x (instead of _lsft($c,$x,$l,10)
  my $r = $l % $BASE_LEN;	# 10000 00000 00000 00000 ($BASE_LEN=5)
  $l = int($l / $BASE_LEN);
  print "l =  $l " if DEBUG;

  splice @$x,$l;		# keep ref($x), but modify it

  # we make the first part of the guess not '1000...0' but int(sqrt($lastelem))
  # that gives us:
  # 14400 00000 => sqrt(14400) => guess first digits to be 120
  # 144000 000000 => sqrt(144000) => guess 379

  print "$lastelem (elems $elems) => " if DEBUG;
  $lastelem = $lastelem / 10 if ($elems & 1 == 1);		# odd or even?
  my $g = sqrt($lastelem); $g =~ s/\.//;			# 2.345 => 2345
  $r -= 1 if $elems & 1 == 0;					# 70 => 7

  # padd with zeros if result is too short
  $x->[$l--] = int(substr($g . '0' x $r,0,$r+1));
  print "now ",$x->[-1] if DEBUG;
  print " would have been ", int('1' . '0' x $r),"\n" if DEBUG;

  # If @$x > 1, we could compute the second elem of the guess, too, to create
  # an even better guess. Not implemented yet. Does it improve performance?
  $x->[$l--] = 0 while ($l >= 0);	# all other digits of guess are zero

  print "start x= ",_str($c,$x),"\n" if DEBUG;
  my $two = _two();
  my $last = _zero();
  my $lastlast = _zero();
  $steps = 0 if DEBUG;
  while (_acmp($c,$last,$x) != 0 && _acmp($c,$lastlast,$x) != 0)
    {
    $steps++ if DEBUG;
    $lastlast = _copy($c,$last);
    $last = _copy($c,$x);
    _add($c,$x, _div($c,_copy($c,$y),$x));
    _div($c,$x, $two );
    print " x= ",_str($c,$x),"\n" if DEBUG;
    }
  print "\nsteps in sqrt: $steps, " if DEBUG;
  _dec($c,$x) if _acmp($c,$y,_mul($c,_copy($c,$x),$x)) < 0;	# overshot? 
  print " final ",$x->[-1],"\n" if DEBUG;
  $x;
  }

sub _root
  {
  # take n'th root of $x in place (n >= 3)
  my ($c,$x,$n) = @_;
 
  if (scalar @$x == 1)
    {
    if (scalar @$n > 1)
      {
      # result will always be smaller than 2 so trunc to 1 at once
      $x->[0] = 1;
      }
    else
      {
      # fits into one Perl scalar, so result can be computed directly
      # cannot use int() here, because it rounds wrongly (try 
      # (81 ** 3) ** (1/3) to see what I mean)
      #$x->[0] = int( $x->[0] ** (1 / $n->[0]) );
      # round to 8 digits, then truncate result to integer
      $x->[0] = int ( sprintf ("%.8f", $x->[0] ** (1 / $n->[0]) ) );
      }
    return $x;
    } 

  # we know now that X is more than one element long

  # if $n is a power of two, we can repeatedly take sqrt($X) and find the
  # proper result, because sqrt(sqrt($x)) == root($x,4)
  my $b = _as_bin($c,$n);
  if ($b =~ /0b1(0+)$/)
    {
    my $count = CORE::length($1);	# 0b100 => len('00') => 2
    my $cnt = $count;			# counter for loop
    unshift (@$x, 0);			# add one element, together with one
					# more below in the loop this makes 2
    while ($cnt-- > 0)
      {
      # 'inflate' $X by adding one element, basically computing
      # $x * $BASE * $BASE. This gives us more $BASE_LEN digits for result
      # since len(sqrt($X)) approx == len($x) / 2.
      unshift (@$x, 0);
      # calculate sqrt($x), $x is now one element to big, again. In the next
      # round we make that two, again.
      _sqrt($c,$x);
      }
    # $x is now one element to big, so truncate result by removing it
    splice (@$x,0,1);
    } 
  else
    {
    # trial computation by starting with 2,4,8,16 etc until we overstep
    my $step;
    my $trial = _two();

    # while still to do more than X steps
    do
      {
      $step = _two();
      while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)
        {
        _mul ($c, $step, [2]);
        _add ($c, $trial, $step);
        }

      # hit exactly?
      if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) == 0)
        {
        @$x = @$trial;			# make copy while preserving ref to $x
        return $x;
        }
      # overstepped, so go back on step
      _sub($c, $trial, $step);
      } while (scalar @$step > 1 || $step->[0] > 128);

    # reset step to 2
    $step = _two();
    # add two, because $trial cannot be exactly the result (otherwise we would
    # already have found it)
    _add($c, $trial, $step);
 
    # and now add more and more (2,4,6,8,10 etc)
    while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)
      {
      _add ($c, $trial, $step);
      }

    # hit not exactly? (overstepped)
    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)
      {
      _dec($c,$trial);
      }

    # hit not exactly? (overstepped)
    # 80 too small, 81 slightly too big, 82 too big
    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)
      {
      _dec ($c, $trial); 
      }

    @$x = @$trial;			# make copy while preserving ref to $x
    return $x;
    }
  $x; 
  }

##############################################################################
# binary stuff

sub _and
  {
  my ($c,$x,$y) = @_;

  # the shortcut makes equal, large numbers _really_ fast, and makes only a
  # very small performance drop for small numbers (e.g. something with less
  # than 32 bit) Since we optimize for large numbers, this is enabled.
  return $x if _acmp($c,$x,$y) == 0;		# shortcut
  
  my $m = _one(); my ($xr,$yr);
  my $mask = $AND_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);

    # make ints() from $xr, $yr
    # this is when the AND_BITS are greater than $BASE and is slower for
    # small (<256 bits) numbers, but faster for large numbers. Disabled
    # due to KISS principle

#    $b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }
#    $b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }
#    _add($c,$x, _mul($c, _new( $c, ($xrr & $yrr) ), $m) );
    
    # 0+ due to '&' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] & 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  $x;
  }

sub _xor
  {
  my ($c,$x,$y) = @_;

  return _zero() if _acmp($c,$x,$y) == 0;	# shortcut (see -and)

  my $m = _one(); my ($xr,$yr);
  my $mask = $XOR_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);
    # make ints() from $xr, $yr (see _and())
    #$b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }
    #$b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }
    #_add($c,$x, _mul($c, _new( $c, ($xrr ^ $yrr) ), $m) );

    # 0+ due to '^' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] ^ 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  # the loop stops when the shorter of the two numbers is exhausted
  # the remainder of the longer one will survive bit-by-bit, so we simple
  # multiply-add it in
  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);
  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);
  
  $x;
  }

sub _or
  {
  my ($c,$x,$y) = @_;

  return $x if _acmp($c,$x,$y) == 0;		# shortcut (see _and)

  my $m = _one(); my ($xr,$yr);
  my $mask = $OR_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);
    # make ints() from $xr, $yr (see _and())
#    $b = 1; $xrr = 0; foreach (@$xr) { $xrr += $_ * $b; $b *= $BASE; }
#    $b = 1; $yrr = 0; foreach (@$yr) { $yrr += $_ * $b; $b *= $BASE; }
#    _add($c,$x, _mul($c, _new( $c, ($xrr | $yrr) ), $m) );
    
    # 0+ due to '|' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] | 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  # the loop stops when the shorter of the two numbers is exhausted
  # the remainder of the longer one will survive bit-by-bit, so we simple
  # multiply-add it in
  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);
  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);
  
  $x;
  }

sub _as_hex
  {
  # convert a decimal number to hex (ref to array, return ref to string)
  my ($c,$x) = @_;

  # fits into one element (handle also 0x0 case)
  return sprintf("0x%x",$x->[0]) if @$x == 1;

  my $x1 = _copy($c,$x);

  my $es = '';
  my ($xr, $h, $x10000);
  if ($] >= 5.006)
    {
    $x10000 = [ 0x10000 ]; $h = 'h4';
    }
  else
    {
    $x10000 = [ 0x1000 ]; $h = 'h3';
    }
  while (@$x1 != 1 || $x1->[0] != 0)		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x10000);
    $es .= unpack($h,pack('V',$xr->[0]));
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  '0x' . $es;					# return result prepended with 0x
  }

sub _as_bin
  {
  # convert a decimal number to bin (ref to array, return ref to string)
  my ($c,$x) = @_;

  # fits into one element (and Perl recent enough), handle also 0b0 case
  # handle zero case for older Perls
  if ($] <= 5.005 && @$x == 1 && $x->[0] == 0)
    {
    my $t = '0b0'; return $t;
    }
  if (@$x == 1 && $] >= 5.006)
    {
    my $t = sprintf("0b%b",$x->[0]);
    return $t;
    }
  my $x1 = _copy($c,$x);

  my $es = '';
  my ($xr, $b, $x10000);
  if ($] >= 5.006)
    {
    $x10000 = [ 0x10000 ]; $b = 'b16';
    }
  else
    {
    $x10000 = [ 0x1000 ]; $b = 'b12';
    }
  while (!(@$x1 == 1 && $x1->[0] == 0))		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x10000);
    $es .= unpack($b,pack('v',$xr->[0]));
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  '0b' . $es;					# return result prepended with 0b
  }

sub _as_oct
  {
  # convert a decimal number to octal (ref to array, return ref to string)
  my ($c,$x) = @_;

  # fits into one element (handle also 0 case)
  return sprintf("0%o",$x->[0]) if @$x == 1;

  my $x1 = _copy($c,$x);

  my $es = '';
  my $xr;
  my $x1000 = [ 0100000 ];
  while (@$x1 != 1 || $x1->[0] != 0)		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x1000);
    $es .= reverse sprintf("%05o", $xr->[0]);
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  '0' . $es;					# return result prepended with 0
  }

sub _from_oct
  {
  # convert a octal number to decimal (string, return ref to array)
  my ($c,$os) = @_;

  # for older Perls, play safe
  my $m = [ 0100000 ];
  my $d = 5;					# 5 digits at a time

  my $mul = _one();
  my $x = _zero();

  my $len = int( (length($os)-1)/$d );		# $d digit parts, w/o the '0'
  my $val; my $i = -$d;
  while ($len >= 0)
    {
    $val = substr($os,$i,$d);			# get oct digits
    $val = CORE::oct($val);
    $i -= $d; $len --;
    my $adder = [ $val ];
    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

sub _from_hex
  {
  # convert a hex number to decimal (string, return ref to array)
  my ($c,$hs) = @_;

  my $m = _new($c, 0x10000000);			# 28 bit at a time (<32 bit!)
  my $d = 7;					# 7 digits at a time
  if ($] <= 5.006)
    {
    # for older Perls, play safe
    $m = [ 0x10000 ];				# 16 bit at a time (<32 bit!)
    $d = 4;					# 4 digits at a time
    }

  my $mul = _one();
  my $x = _zero();

  my $len = int( (length($hs)-2)/$d );		# $d digit parts, w/o the '0x'
  my $val; my $i = -$d;
  while ($len >= 0)
    {
    $val = substr($hs,$i,$d);			# get hex digits
    $val =~ s/^0x// if $len == 0;		# for last part only because
    $val = CORE::hex($val);			# hex does not like wrong chars
    $i -= $d; $len --;
    my $adder = [ $val ];
    # if the resulting number was to big to fit into one element, create a
    # two-element version (bug found by Mark Lakata - Thanx!)
    if (CORE::length($val) > $BASE_LEN)
      {
      $adder = _new($c,$val);
      }
    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

sub _from_bin
  {
  # convert a hex number to decimal (string, return ref to array)
  my ($c,$bs) = @_;

  # instead of converting X (8) bit at a time, it is faster to "convert" the
  # number to hex, and then call _from_hex.

  my $hs = $bs;
  $hs =~ s/^[+-]?0b//;					# remove sign and 0b
  my $l = length($hs);					# bits
  $hs = '0' x (8-($l % 8)) . $hs if ($l % 8) != 0;	# padd left side w/ 0
  my $h = '0x' . unpack('H*', pack ('B*', $hs));	# repack as hex
  
  $c->_from_hex($h);
  }

##############################################################################
# special modulus functions

sub _modinv
  {
  # modular multiplicative inverse
  my ($c,$x,$y) = @_;

  # modulo zero
  if (_is_zero($c, $y)) {
      return (undef, undef);
  }

  # modulo one
  if (_is_one($c, $y)) {
      return (_zero($c), '+');
  }

  my $u = _zero($c);
  my $v = _one($c);
  my $a = _copy($c,$y);
  my $b = _copy($c,$x);

  # Euclid's Algorithm for bgcd(), only that we calc bgcd() ($a) and the result
  # ($u) at the same time. See comments in BigInt for why this works.
  my $q;
  my $sign = 1;
  {
      ($a, $q, $b) = ($b, _div($c, $a, $b));        # step 1
      last if _is_zero($c, $b);

      my $t = _add($c,                              # step 2:
                   _mul($c, _copy($c, $v), $q) ,    #  t =   v * q
                   $u );                            #      + u
      $u = $v;                                      #  u = v
      $v = $t;                                      #  v = t
      $sign = -$sign;
      redo;
  }

  # if the gcd is not 1, then return NaN
  return (undef, undef) unless _is_one($c, $a);

  ($v, $sign == 1 ? '+' : '-');
  }

sub _modpow
  {
  # modulus of power ($x ** $y) % $z
  my ($c,$num,$exp,$mod) = @_;

  # a^b (mod 1) = 0 for all a and b
  if (_is_one($c,$mod))
    {
        @$num = 0;
        return $num;
    }

  # 0^a (mod m) = 0 if m != 0, a != 0
  # 0^0 (mod m) = 1 if m != 0
  if (_is_zero($c, $num)) {
      if (_is_zero($c, $exp)) {
          @$num = 1;
      } else {
          @$num = 0;
      }
      return $num;
  }

#  $num = _mod($c,$num,$mod);	# this does not make it faster

  my $acc = _copy($c,$num); my $t = _one();

  my $expbin = _as_bin($c,$exp); $expbin =~ s/^0b//;
  my $len = length($expbin);
  while (--$len >= 0)
    {
    if ( substr($expbin,$len,1) eq '1')			# is_odd
      {
      _mul($c,$t,$acc);
      $t = _mod($c,$t,$mod);
      }
    _mul($c,$acc,$acc);
    $acc = _mod($c,$acc,$mod);
    }
  @$num = @$t;
  $num;
  }

sub _gcd {
    # Greatest common divisor.

    my ($c, $x, $y) = @_;

    # gcd(0,0) = 0
    # gcd(0,a) = a, if a != 0

    if (@$x == 1 && $x->[0] == 0) {
        if (@$y == 1 && $y->[0] == 0) {
            @$x = 0;
        } else {
            @$x = @$y;
        }
        return $x;
    }

    # Until $y is zero ...

    until (@$y == 1 && $y->[0] == 0) {

        # Compute remainder.

        _mod($c, $x, $y);

        # Swap $x and $y.

        my $tmp = [ @$x ];
        @$x = @$y;
        $y = $tmp;      # no deref here; that would modify input $y
    }

    return $x;
}

##############################################################################
##############################################################################

1;
__END__

=pod

=head1 NAME

Math::BigInt::Calc - Pure Perl module to support Math::BigInt

=head1 SYNOPSIS

This library provides support for big integer calculations. It is not
intended to be used by other modules. Other modules which support the same
API (see below) can also be used to support Math::BigInt, like
Math::BigInt::GMP and Math::BigInt::Pari.

=head1 DESCRIPTION

In this library, the numbers are represented in base B = 10**N, where N is
the largest possible value that does not cause overflow in the intermediate
computations. The base B elements are stored in an array, with the least
significant element stored in array element zero. There are no leading zero
elements, except a single zero element when the number is zero.

For instance, if B = 10000, the number 1234567890 is represented internally
as [3456, 7890, 12].

=head1 THE Math::BigInt API

In order to allow for multiple big integer libraries, Math::BigInt was
rewritten to use a plug-in library for core math routines. Any module which
conforms to the API can be used by Math::BigInt by using this in your program:

	use Math::BigInt lib => 'libname';

'libname' is either the long name, like 'Math::BigInt::Pari', or only the short
version, like 'Pari'.

=head2 General Notes

A library only needs to deal with unsigned big integers. Testing of input
parameter validity is done by the caller, so there is no need to worry about
underflow (e.g., in C<_sub()> and C<_dec()>) nor about division by zero (e.g.,
in C<_div()>) or similar cases.

For some methods, the first parameter can be modified. That includes the
possibility that you return a reference to a completely different object
instead. Although keeping the reference and just changing its contents is
preferred over creating and returning a different reference.

Return values are always objects, strings, Perl scalars, or true/false for
comparison routines.

=head2 API version 1

The following methods must be defined in order to support the use by
Math::BigInt v1.70 or later.

=head3 API version

=over 4

=item I<api_version()>

Return API version as a Perl scalar, 1 for Math::BigInt v1.70, 2 for
Math::BigInt v1.83.

=back

=head3 Constructors

=over 4

=item I<_new(STR)>

Convert a string representing an unsigned decimal number to an object
representing the same number. The input is normalize, i.e., it matches
C<^(0|[1-9]\d*)$>.

=item I<_zero()>

Return an object representing the number zero.

=item I<_one()>

Return an object representing the number one.

=item I<_two()>

Return an object representing the number two.

=item I<_ten()>

Return an object representing the number ten.

=item I<_from_bin(STR)>

Return an object given a string representing a binary number. The input has a
'0b' prefix and matches the regular expression C<^0[bB](0|1[01]*)$>.

=item I<_from_oct(STR)>

Return an object given a string representing an octal number. The input has a
'0' prefix and matches the regular expression C<^0[1-7]*$>.

=item I<_from_hex(STR)>

Return an object given a string representing a hexadecimal number. The input
has a '0x' prefix and matches the regular expression
C<^0x(0|[1-9a-fA-F][\da-fA-F]*)$>.

=back

=head3 Mathematical functions

Each of these methods may modify the first input argument, except I<_bgcd()>,
which shall not modify any input argument, and I<_sub()> which may modify the
second input argument.

=over 4

=item I<_add(OBJ1, OBJ2)>

Returns the result of adding OBJ2 to OBJ1.

=item I<_mul(OBJ1, OBJ2)>

Returns the result of multiplying OBJ2 and OBJ1.

=item I<_div(OBJ1, OBJ2)>

Returns the result of dividing OBJ1 by OBJ2 and truncating the result to an
integer.

=item I<_sub(OBJ1, OBJ2, FLAG)>

=item I<_sub(OBJ1, OBJ2)>

Returns the result of subtracting OBJ2 by OBJ1. If C<flag> is false or omitted,
OBJ1 might be modified. If C<flag> is true, OBJ2 might be modified.

=item I<_dec(OBJ)>

Decrement OBJ by one.

=item I<_inc(OBJ)>

Increment OBJ by one.

=item I<_mod(OBJ1, OBJ2)>

Return OBJ1 modulo OBJ2, i.e., the remainder after dividing OBJ1 by OBJ2.

=item I<_sqrt(OBJ)>

Return the square root of the object, truncated to integer.

=item I<_root(OBJ, N)>

Return Nth root of the object, truncated to int. N is E<gt>= 3.

=item I<_fac(OBJ)>

Return factorial of object (1*2*3*4*...).

=item I<_pow(OBJ1, OBJ2)>

Return OBJ1 to the power of OBJ2. By convention, 0**0 = 1.

=item I<_modinv(OBJ1, OBJ2)>

Return modular multiplicative inverse, i.e., return OBJ3 so that

    (OBJ3 * OBJ1) % OBJ2 = 1 % OBJ2

The result is returned as two arguments. If the modular multiplicative
inverse does not exist, both arguments are undefined. Otherwise, the
arguments are a number (object) and its sign ("+" or "-").

The output value, with its sign, must either be a positive value in the
range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the
input arguments are objects representing the numbers 7 and 5, the method
must either return an object representing the number 3 and a "+" sign, since
(3*7) % 5 = 1 % 5, or an object representing the number 2 and "-" sign,
since (-2*7) % 5 = 1 % 5.

=item I<_modpow(OBJ1, OBJ2, OBJ3)>

Return modular exponentiation, (OBJ1 ** OBJ2) % OBJ3.

=item I<_rsft(OBJ, N, B)>

Shift object N digits right in base B and return the resulting object. This is
equivalent to performing integer division by B**N and discarding the remainder,
except that it might be much faster, depending on how the number is represented
internally.

For instance, if the object $obj represents the hexadecimal number 0xabcde,
then C<_rsft($obj, 2, 16)> returns an object representing the number 0xabc. The
"remainer", 0xde, is discarded and not returned.

=item I<_lsft(OBJ, N, B)>

Shift the object N digits left in base B. This is equivalent to multiplying by
B**N, except that it might be much faster, depending on how the number is
represented internally.

=item I<_log_int(OBJ, B)>

Return integer log of OBJ to base BASE. This method has two output arguments,
the OBJECT and a STATUS. The STATUS is Perl scalar; it is 1 if OBJ is the exact
result, 0 if the result was truncted to give OBJ, and undef if it is unknown
whether OBJ is the exact result.

=item I<_gcd(OBJ1, OBJ2)>

Return the greatest common divisor of OBJ1 and OBJ2.

=back

=head3 Bitwise operators

Each of these methods may modify the first input argument.

=over 4

=item I<_and(OBJ1, OBJ2)>

Return bitwise and. If necessary, the smallest number is padded with leading
zeros.

=item I<_or(OBJ1, OBJ2)>

Return bitwise or. If necessary, the smallest number is padded with leading
zeros.

=item I<_xor(OBJ1, OBJ2)>

Return bitwise exclusive or. If necessary, the smallest number is padded
with leading zeros.

=back

=head3 Boolean operators

=over 4

=item I<_is_zero(OBJ)>

Returns a true value if OBJ is zero, and false value otherwise.

=item I<_is_one(OBJ)>

Returns a true value if OBJ is one, and false value otherwise.

=item I<_is_two(OBJ)>

Returns a true value if OBJ is two, and false value otherwise.

=item I<_is_ten(OBJ)>

Returns a true value if OBJ is ten, and false value otherwise.

=item I<_is_even(OBJ)>

Return a true value if OBJ is an even integer, and a false value otherwise.

=item I<_is_odd(OBJ)>

Return a true value if OBJ is an even integer, and a false value otherwise.

=item I<_acmp(OBJ1, OBJ2)>

Compare OBJ1 and OBJ2 and return -1, 0, or 1, if OBJ1 is less than, equal
to, or larger than OBJ2, respectively.

=back

=head3 String conversion

=over 4

=item I<_str(OBJ)>

Return a string representing the object. The returned string should have no
leading zeros, i.e., it should match C<^(0|[1-9]\d*)$>.

=item I<_as_bin(OBJ)>

Return the binary string representation of the number. The string must have a
'0b' prefix.

=item I<_as_oct(OBJ)>

Return the octal string representation of the number. The string must have
a '0x' prefix.

Note: This method was required from Math::BigInt version 1.78, but the required
API version number was not incremented, so there are older libraries that
support API version 1, but do not support C<_as_oct()>.

=item I<_as_hex(OBJ)>

Return the hexadecimal string representation of the number. The string must
have a '0x' prefix.

=back

=head3 Numeric conversion

=over 4

=item I<_num(OBJ)>

Given an object, return a Perl scalar number (int/float) representing this
number.

=back

=head3 Miscellaneous

=over 4

=item I<_copy(OBJ)>

Return a true copy of the object.

=item I<_len(OBJ)>

Returns the number of the decimal digits in the number. The output is a
Perl scalar.

=item I<_zeros(OBJ)>

Return the number of trailing decimal zeros. The output is a Perl scalar.

=item I<_digit(OBJ, N)>

Return the Nth digit as a Perl scalar. N is a Perl scalar, where zero refers to
the rightmost (least significant) digit, and negative values count from the
left (most significant digit). If $obj represents the number 123, then
I<_digit($obj, 0)> is 3 and I<_digit(123, -1)> is 1.

=item I<_check(OBJ)>

Return a true value if the object is OK, and a false value otherwise. This is a
check routine to test the internal state of the object for corruption.

=back

=head2 API version 2

The following methods are required for an API version of 2 or greater.

=head3 Constructors

=over 4

=item I<_1ex(N)>

Return an object representing the number 10**N where N E<gt>= 0 is a Perl
scalar.

=back

=head3 Mathematical functions

=over 4

=item I<_nok(OBJ1, OBJ2)>

Return the binomial coefficient OBJ1 over OBJ1.

=back

=head3 Miscellaneous

=over 4

=item I<_alen(OBJ)>

Return the approximate number of decimal digits of the object. The
output is one Perl scalar. This estimate must be greater than or equal
to what C<_len()> returns.

=back

=head2 API optional methods

The following methods are optional, and can be defined if the underlying lib
has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence
slow) fallback routines to emulate these:

=head3 Signed bitwise operators.

Each of these methods may modify the first input argument.

=over 4

=item I<_signed_or(OBJ1, OBJ2, SIGN1, SIGN2)>

Return the signed bitwise or.

=item I<_signed_and(OBJ1, OBJ2, SIGN1, SIGN2)>

Return the signed bitwise and.

=item I<_signed_xor(OBJ1, OBJ2, SIGN1, SIGN2)>

Return the signed bitwise exclusive or.

=back

=head1 WRAP YOUR OWN

If you want to port your own favourite c-lib for big numbers to the
Math::BigInt interface, you can take any of the already existing modules as
a rough guideline. You should really wrap up the latest BigInt and BigFloat
testsuites with your module, and replace in them any of the following:

	use Math::BigInt;

by this:

	use Math::BigInt lib => 'yourlib';

This way you ensure that your library really works 100% within Math::BigInt.

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself. 

=head1 AUTHORS

=over 4

=item *

Original math code by Mark Biggar, rewritten by Tels L<http://bloodgate.com/>
in late 2000.

=item *

Separated from BigInt and shaped API with the help of John Peacock.

=item *

Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.

=item *

API documentation corrected and extended by Peter John Acklam,
E<lt>pjacklam@online.noE<gt>

=back

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>,
L<Math::BigInt::GMP>, L<Math::BigInt::FastCalc> and L<Math::BigInt::Pari>.

=cut
                                                                                                                                                                                                                                               usr/share/perl/5.20.2/Math/BigInt/CalcEmu.pm                                                        0100644 0000000 0000000 00000021235 12744441327 016575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Math::BigInt::CalcEmu;

use 5.006002;
use strict;
# use warnings;	# do not use warnings for older Perls
use vars qw/$VERSION/;

$VERSION = '1.9991';

package Math::BigInt;

# See SYNOPSIS below.

my $CALC_EMU;

BEGIN
  {
  $CALC_EMU = Math::BigInt->config()->{'lib'};
  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback( __PACKAGE__, sub { $CALC_EMU = $_[0]; } );
  }

sub __emu_band
  {
  my ($self,$x,$y,$sx,$sy,@r) = @_;

  return $x->bzero(@r) if $y->is_zero() || $x->is_zero();
  
  my $sign = 0;					# sign of result
  $sign = 1 if $sx == -1 && $sy == -1;

  my ($bx,$by);

  if ($sx == -1)				# if x is negative
    {
    # two's complement: inc and flip all "bits" in $bx
    $bx = $x->binc()->as_hex();			# -1 => 0, -2 => 1, -3 => 2 etc
    $bx =~ s/-?0x//;
    $bx =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $bx = $x->as_hex();				# get binary representation
    $bx =~ s/-?0x//;
    $bx =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  if ($sy == -1)				# if y is negative
    {
    # two's complement: inc and flip all "bits" in $by
    $by = $y->copy()->binc()->as_hex();		# -1 => 0, -2 => 1, -3 => 2 etc
    $by =~ s/-?0x//;
    $by =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $by = $y->as_hex();				# get binary representation
    $by =~ s/-?0x//;
    $by =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  # now we have bit-strings from X and Y, reverse them for padding
  $bx = reverse $bx;
  $by = reverse $by;

  # padd the shorter string
  my $xx = "\x00"; $xx = "\x0f" if $sx == -1;
  my $yy = "\x00"; $yy = "\x0f" if $sy == -1;
  my $diff = CORE::length($bx) - CORE::length($by);
  if ($diff > 0)
    {
    # if $yy eq "\x00", we can cut $bx, otherwise we need to padd $by
    $by .= $yy x $diff;
    }
  elsif ($diff < 0)
    {
    # if $xx eq "\x00", we can cut $by, otherwise we need to padd $bx
    $bx .= $xx x abs($diff);
    }
  
  # and the strings together
  my $r = $bx & $by;

  # and reverse the result again
  $bx = reverse $r;

  # One of $x or $y was negative, so need to flip bits in the result.
  # In both cases (one or two of them negative, or both positive) we need
  # to get the characters back.
  if ($sign == 1)
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/0123456789abcdef/;
    }
  else
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/fedcba9876543210/;
    }

  # leading zeros will be stripped by _from_hex()
  $bx = '0x' . $bx;
  $x->{value} = $CALC_EMU->_from_hex( $bx );

  # calculate sign of result
  $x->{sign} = '+';
  $x->{sign} = '-' if $sign == 1 && !$x->is_zero();

  $x->bdec() if $sign == 1;

  $x->round(@r);
  }

sub __emu_bior
  {
  my ($self,$x,$y,$sx,$sy,@r) = @_;

  return $x->round(@r) if $y->is_zero();

  my $sign = 0;					# sign of result
  $sign = 1 if ($sx == -1) || ($sy == -1);

  my ($bx,$by);

  if ($sx == -1)				# if x is negative
    {
    # two's complement: inc and flip all "bits" in $bx
    $bx = $x->binc()->as_hex();			# -1 => 0, -2 => 1, -3 => 2 etc
    $bx =~ s/-?0x//;
    $bx =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $bx = $x->as_hex();				# get binary representation
    $bx =~ s/-?0x//;
    $bx =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  if ($sy == -1)				# if y is negative
    {
    # two's complement: inc and flip all "bits" in $by
    $by = $y->copy()->binc()->as_hex();		# -1 => 0, -2 => 1, -3 => 2 etc
    $by =~ s/-?0x//;
    $by =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $by = $y->as_hex();				# get binary representation
    $by =~ s/-?0x//;
    $by =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  # now we have bit-strings from X and Y, reverse them for padding
  $bx = reverse $bx;
  $by = reverse $by;

  # padd the shorter string
  my $xx = "\x00"; $xx = "\x0f" if $sx == -1;
  my $yy = "\x00"; $yy = "\x0f" if $sy == -1;
  my $diff = CORE::length($bx) - CORE::length($by);
  if ($diff > 0)
    {
    $by .= $yy x $diff;
    }
  elsif ($diff < 0)
    {
    $bx .= $xx x abs($diff);
    }

  # or the strings together
  my $r = $bx | $by;

  # and reverse the result again
  $bx = reverse $r;

  # one of $x or $y was negative, so need to flip bits in the result
  # in both cases (one or two of them negative, or both positive) we need
  # to get the characters back.
  if ($sign == 1)
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/0123456789abcdef/;
    }
  else
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/fedcba9876543210/;
    }

  # leading zeros will be stripped by _from_hex()
  $bx = '0x' . $bx;
  $x->{value} = $CALC_EMU->_from_hex( $bx );

  # calculate sign of result
  $x->{sign} = '+';
  $x->{sign} = '-' if $sign == 1 && !$x->is_zero();

  # if one of X or Y was negative, we need to decrement result
  $x->bdec() if $sign == 1;

  $x->round(@r);
  }

sub __emu_bxor
  {
  my ($self,$x,$y,$sx,$sy,@r) = @_;

  return $x->round(@r) if $y->is_zero();

  my $sign = 0;					# sign of result
  $sign = 1 if $x->{sign} ne $y->{sign};

  my ($bx,$by);

  if ($sx == -1)				# if x is negative
    {
    # two's complement: inc and flip all "bits" in $bx
    $bx = $x->binc()->as_hex();			# -1 => 0, -2 => 1, -3 => 2 etc
    $bx =~ s/-?0x//;
    $bx =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $bx = $x->as_hex();				# get binary representation
    $bx =~ s/-?0x//;
    $bx =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  if ($sy == -1)				# if y is negative
    {
    # two's complement: inc and flip all "bits" in $by
    $by = $y->copy()->binc()->as_hex();		# -1 => 0, -2 => 1, -3 => 2 etc
    $by =~ s/-?0x//;
    $by =~ tr/0123456789abcdef/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  else
    {
    $by = $y->as_hex();				# get binary representation
    $by =~ s/-?0x//;
    $by =~ tr/fedcba9876543210/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/;
    }
  # now we have bit-strings from X and Y, reverse them for padding
  $bx = reverse $bx;
  $by = reverse $by;

  # padd the shorter string
  my $xx = "\x00"; $xx = "\x0f" if $sx == -1;
  my $yy = "\x00"; $yy = "\x0f" if $sy == -1;
  my $diff = CORE::length($bx) - CORE::length($by);
  if ($diff > 0)
    {
    $by .= $yy x $diff;
    }
  elsif ($diff < 0)
    {
    $bx .= $xx x abs($diff);
    }

  # xor the strings together
  my $r = $bx ^ $by;

  # and reverse the result again
  $bx = reverse $r;

  # one of $x or $y was negative, so need to flip bits in the result
  # in both cases (one or two of them negative, or both positive) we need
  # to get the characters back.
  if ($sign == 1)
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/0123456789abcdef/;
    }
  else
    {
    $bx =~ tr/\x0f\x0e\x0d\x0c\x0b\x0a\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00/fedcba9876543210/;
    }

  # leading zeros will be stripped by _from_hex()
  $bx = '0x' . $bx;
  $x->{value} = $CALC_EMU->_from_hex( $bx );

  # calculate sign of result
  $x->{sign} = '+';
  $x->{sign} = '-' if $sx != $sy && !$x->is_zero();

  $x->bdec() if $sign == 1;

  $x->round(@r);
  }

##############################################################################
##############################################################################

1;
__END__

=head1 NAME

Math::BigInt::CalcEmu - Emulate low-level math with BigInt code

=head1 SYNOPSIS

	use Math::BigInt::CalcEmu;

=head1 DESCRIPTION

Contains routines that emulate low-level math functions in BigInt, e.g.
optional routines the low-level math package does not provide on its own.

Will be loaded on demand and called automatically by BigInt.

Stuff here is really low-priority to optimize, since it is far better to
implement the operation in the low-level math library directly, possible even
using a call to the native lib.

=head1 METHODS

=over

=item __emu_bxor

=item __emu_band

=item __emu_bior

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself. 

=head1 AUTHORS

(c) Tels http://bloodgate.com 2003, 2004 - based on BigInt code by
Tels from 2001-2003.

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>,
L<Math::BigInt::GMP> and L<Math::BigInt::Pari>.

=cut
                                                                                                                                                                                                                                                                                                                                                                   usr/share/perl/5.20.2/Math/BigInt/Trace.pm                                                          0100644 0000000 0000000 00000001731 12744441327 016321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl -w

package Math::BigInt::Trace;

require 5.005_02;
use strict;

use Exporter;
use Math::BigInt;
use vars qw($VERSION @ISA $PACKAGE @EXPORT_OK
            $accuracy $precision $round_mode $div_scale);

@ISA = qw(Exporter Math::BigInt);

$VERSION = '0.36';

use overload;	# inherit overload from BigInt

# Globals
$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;

sub new
{
        my $proto  = shift;
        my $class  = ref($proto) || $proto;

        my $value       = shift;
	my $a = $accuracy; $a = $_[0] if defined $_[0];
	my $p = $precision; $p = $_[1] if defined $_[1];
        my $self = Math::BigInt->new($value,$a,$p,$round_mode);
	bless $self,$class;
	print "MBI new '$value' => '$self' (",ref($self),")";
        return $self;
}

sub import
  {
  print "MBI import ",join(' ',@_);
  my $self = shift;
  Math::BigInt::import($self,@_);		# need it for subclasses
#  $self->export_to_level(1,$self,@_);		# need this ?
  @_ = ();
  }

1;
                                       usr/share/perl/5.20.2/Math/BigInt.pm                                                                0100644 0000000 0000000 00000467201 12744441327 015273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Math::BigInt;

#
# "Mike had an infinite amount to do and a negative amount of time in which
# to do it." - Before and After
#

# The following hash values are used:
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similar)
#   sign : +,-,NaN,+inf,-inf
#   _a   : accuracy
#   _p   : precision
#   _f   : flags, used by MBF to flag parts of a float as untouchable

# Remember not to take shortcuts ala $xs = $x->{value}; $CALC->foo($xs); since
# underlying lib might change the reference!

my $class = "Math::BigInt";
use 5.006002;

$VERSION = '1.9993';

@ISA = qw(Exporter);
@EXPORT_OK = qw(objectify bgcd blcm); 

# _trap_inf and _trap_nan are internal and should never be accessed from the
# outside
use vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode 
	    $upgrade $downgrade $_trap_nan $_trap_inf/;
use strict;

# Inside overload, the first arg is always an object. If the original code had
# it reversed (like $x = 2 * $y), then the third parameter is true.
# In some cases (like add, $x = $x + 2 is the same as $x = 2 + $x) this makes
# no difference, but in some cases it does.

# For overloaded ops with only one argument we simple use $_[0]->copy() to
# preserve the argument.

# Thus inheritance of overload operators becomes possible and transparent for
# our subclasses without the need to repeat the entire overload section there.

# We register ops that are not registerable yet, so suppress warnings
{ no warnings;
use overload
'='     =>      sub { $_[0]->copy(); },

# some shortcuts for speed (assumes that reversed order of arguments is routed
# to normal '+' and we thus can always modify first arg. If this is changed,
# this breaks and must be adjusted.)
'+='	=>	sub { $_[0]->badd($_[1]); },
'-='	=>	sub { $_[0]->bsub($_[1]); },
'*='	=>	sub { $_[0]->bmul($_[1]); },
'/='	=>	sub { scalar $_[0]->bdiv($_[1]); },
'%='	=>	sub { $_[0]->bmod($_[1]); },
'^='	=>	sub { $_[0]->bxor($_[1]); },
'&='	=>	sub { $_[0]->band($_[1]); },
'|='	=>	sub { $_[0]->bior($_[1]); },

'**='	=>	sub { $_[0]->bpow($_[1]); },
'<<='	=>	sub { $_[0]->blsft($_[1]); },
'>>='	=>	sub { $_[0]->brsft($_[1]); },

# not supported by Perl yet
'..'	=>	\&_pointpoint,

'<=>'	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1]); 
		      $rc = 1 unless defined $rc;
		      $rc <=> 0;
		},
# we need '>=' to get things like "1 >= NaN" right:
'>='	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1]);
		      # if there was a NaN involved, return false
		      return '' unless defined $rc;
		      $rc >= 0;
		},
'cmp'	=>	sub {
         $_[2] ? 
               "$_[1]" cmp $_[0]->bstr() :
               $_[0]->bstr() cmp "$_[1]" },

'cos'	=>	sub { $_[0]->copy->bcos(); }, 
'sin'	=>	sub { $_[0]->copy->bsin(); }, 
'atan2'	=>	sub { $_[2] ?
			ref($_[0])->new($_[1])->batan2($_[0]) :
			$_[0]->copy()->batan2($_[1]) },

# are not yet overloadable
#'hex'	=>	sub { print "hex"; $_[0]; }, 
#'oct'	=>	sub { print "oct"; $_[0]; }, 

# log(N) is log(N, e), where e is Euler's number
'log'	=>	sub { $_[0]->copy()->blog($_[1], undef); }, 
'exp'	=>	sub { $_[0]->copy()->bexp($_[1]); }, 
'int'	=>	sub { $_[0]->copy(); }, 
'neg'	=>	sub { $_[0]->copy()->bneg(); }, 
'abs'	=>	sub { $_[0]->copy()->babs(); },
'sqrt'  =>	sub { $_[0]->copy()->bsqrt(); },
'~'	=>	sub { $_[0]->copy()->bnot(); },

# for subtract it's a bit tricky to not modify b: b-a => -a+b
'-'	=>	sub { my $c = $_[0]->copy; $_[2] ?
			$c->bneg()->badd( $_[1]) :
			$c->bsub( $_[1]) },
'+'	=>	sub { $_[0]->copy()->badd($_[1]); },
'*'	=>	sub { $_[0]->copy()->bmul($_[1]); },

'/'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bdiv($_[0]) : $_[0]->copy->bdiv($_[1]);
  }, 
'%'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bmod($_[0]) : $_[0]->copy->bmod($_[1]);
  }, 
'**'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bpow($_[0]) : $_[0]->copy->bpow($_[1]);
  }, 
'<<'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->blsft($_[0]) : $_[0]->copy->blsft($_[1]);
  }, 
'>>'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->brsft($_[0]) : $_[0]->copy->brsft($_[1]);
  }, 
'&'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->band($_[0]) : $_[0]->copy->band($_[1]);
  }, 
'|'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bior($_[0]) : $_[0]->copy->bior($_[1]);
  }, 
'^'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bxor($_[0]) : $_[0]->copy->bxor($_[1]);
  }, 

# can modify arg of ++ and --, so avoid a copy() for speed, but don't
# use $_[0]->bone(), it would modify $_[0] to be 1!
'++'	=>	sub { $_[0]->binc() },
'--'	=>	sub { $_[0]->bdec() },

# if overloaded, O(1) instead of O(N) and twice as fast for small numbers
'bool'  =>	sub {
  # this kludge is needed for perl prior 5.6.0 since returning 0 here fails :-/
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;		    :-(
  my $t = undef;
  $t = 1 if !$_[0]->is_zero();
  $t;
  },

# the original qw() does not work with the TIESCALAR below, why?
# Order of arguments insignificant
'""' => sub { $_[0]->bstr(); },
'0+' => sub { $_[0]->numify(); }
;
} # no warnings scope

##############################################################################
# global constants, flags and accessory

# These vars are public, but their direct usage is not recommended, use the
# accessor methods instead

$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;			# default is no upgrade
$downgrade = undef;			# default is no downgrade

# These are internally, and not to be used from the outside at all

$_trap_nan = 0;				# are NaNs ok? set w/ config()
$_trap_inf = 0;				# are infs ok? set w/ config()
my $nan = 'NaN'; 			# constants for easier life

my $CALC = 'Math::BigInt::Calc';	# module to do the low level math
					# default is Calc.pm
my $IMPORT = 0;				# was import() called yet?
					# used to make require work
my %WARN;				# warn only once for low-level libs
my %CAN;				# cache for $CALC->can(...)
my %CALLBACKS;				# callbacks to notify on lib loads
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm';	# emulate low-level math

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

$rnd_mode   = 'even';
sub TIESCALAR  { my ($class) = @_; bless \$round_mode, $class; }
sub FETCH      { return $round_mode; }
sub STORE      { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN
  { 
  # tie to enable $rnd_mode to work transparently
  tie $rnd_mode, 'Math::BigInt'; 

  # set up some handy alias names
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
  }

############################################################################## 

sub round_mode
  {
  no strict 'refs';
  # make Class->round_mode() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    my $m = shift;
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
      {
      require Carp; Carp::croak ("Unknown round mode '$m'");
      }
    return ${"${class}::round_mode"} = $m;
    }
  ${"${class}::round_mode"};
  }

sub upgrade
  {
  no strict 'refs';
  # make Class->upgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@_ > 0)
    {
    return ${"${class}::upgrade"} = $_[0];
    }
  ${"${class}::upgrade"};
  }

sub downgrade
  {
  no strict 'refs';
  # make Class->downgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@_ > 0)
    {
    return ${"${class}::downgrade"} = $_[0];
    }
  ${"${class}::downgrade"};
  }

sub div_scale
  {
  no strict 'refs';
  # make Class->div_scale() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    if ($_[0] < 0)
      {
      require Carp; Carp::croak ('div_scale must be greater than zero');
      }
    ${"${class}::div_scale"} = $_[0];
    }
  ${"${class}::div_scale"};
  }

sub accuracy
  {
  # $x->accuracy($a);		ref($x)	$a
  # $x->accuracy();		ref($x)
  # Class->accuracy();		class
  # Class->accuracy($a);	class $a

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  # need to set new value?
  if (@_ > 0)
    {
    my $a = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $a = $a->numify() if ref($a) && $a->can('numify');

    if (defined $a)
      {
      # also croak on non-numerical
      if (!$a || $a <= 0)
        {
        require Carp;
	Carp::croak ('Argument to accuracy must be greater than zero');
        }
      if (int($a) != $a)
        {
        require Carp;
	Carp::croak ('Argument to accuracy must be an integer');
        }
      }
    if (ref($x))
      {
      # $object->accuracy() or fallback to global
      $x->bround($a) if $a;		# not for undef, 0
      $x->{_a} = $a;			# set/overwrite, even if not rounded
      delete $x->{_p};			# clear P
      $a = ${"${class}::accuracy"} unless defined $a;   # proper return value
      }
    else
      {
      ${"${class}::accuracy"} = $a;	# set global A
      ${"${class}::precision"} = undef;	# clear global P
      }
    return $a;				# shortcut
    }

  my $a;
  # $object->accuracy() or fallback to global
  $a = $x->{_a} if ref($x);
  # but don't return global undef, when $x's accuracy is 0!
  $a = ${"${class}::accuracy"} if !defined $a;
  $a;
  }

sub precision
  {
  # $x->precision($p);		ref($x)	$p
  # $x->precision();		ref($x)
  # Class->precision();		class
  # Class->precision($p);	class $p

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  if (@_ > 0)
    {
    my $p = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $p = $p->numify() if ref($p) && $p->can('numify');
    if ((defined $p) && (int($p) != $p))
      {
      require Carp; Carp::croak ('Argument to precision must be an integer');
      }
    if (ref($x))
      {
      # $object->precision() or fallback to global
      $x->bfround($p) if $p;		# not for undef, 0
      $x->{_p} = $p;			# set/overwrite, even if not rounded
      delete $x->{_a};			# clear A
      $p = ${"${class}::precision"} unless defined $p;  # proper return value
      }
    else
      {
      ${"${class}::precision"} = $p;	# set global P
      ${"${class}::accuracy"} = undef;	# clear global A
      }
    return $p;				# shortcut
    }

  my $p;
  # $object->precision() or fallback to global
  $p = $x->{_p} if ref($x);
  # but don't return global undef, when $x's precision is 0!
  $p = ${"${class}::precision"} if !defined $p;
  $p;
  }

sub config
  {
  # return (or set) configuration data as hash ref
  my $class = shift || 'Math::BigInt';

  no strict 'refs';
  if (@_ > 1 || (@_ == 1 && (ref($_[0]) eq 'HASH')))
    {
    # try to set given options as arguments from hash

    my $args = $_[0];
    if (ref($args) ne 'HASH')
      {
      $args = { @_ };
      }
    # these values can be "set"
    my $set_args = {};
    foreach my $key (
     qw/trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale/
     )
      {
      $set_args->{$key} = $args->{$key} if exists $args->{$key};
      delete $args->{$key};
      }
    if (keys %$args > 0)
      {
      require Carp;
      Carp::croak ("Illegal key(s) '",
       join("','",keys %$args),"' passed to $class\->config()");
      }
    foreach my $key (keys %$set_args)
      {
      if ($key =~ /^trap_(inf|nan)\z/)
        {
        ${"${class}::_trap_$1"} = ($set_args->{"trap_$1"} ? 1 : 0);
        next;
        }
      # use a call instead of just setting the $variable to check argument
      $class->$key($set_args->{$key});
      }
    }

  # now return actual configuration

  my $cfg = {
    lib => $CALC,
    lib_version => ${"${CALC}::VERSION"},
    class => $class,
    trap_nan => ${"${class}::_trap_nan"},
    trap_inf => ${"${class}::_trap_inf"},
    version => ${"${class}::VERSION"},
    };
  foreach my $key (qw/
     upgrade downgrade precision accuracy round_mode div_scale
     /)
    {
    $cfg->{$key} = ${"${class}::$key"};
    };
  if (@_ == 1 && (ref($_[0]) ne 'HASH'))
    {
    # calls of the style config('lib') return just this value
    return $cfg->{$_[0]};
    }
  $cfg;
  }

sub _scale_a
  { 
  # select accuracy parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @_;

  $scale = $x->{_a} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::accuracy' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

sub _scale_p
  { 
  # select precision parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @_;
  
  $scale = $x->{_p} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::precision' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

##############################################################################
# constructors

sub copy
  {
  # if two arguments, the first one is the class to "swallow" subclasses
  if (@_ > 1)
    {
    my  $self = bless {
	sign => $_[1]->{sign}, 
	value => $CALC->_copy($_[1]->{value}),
    }, $_[0] if @_ > 1;

    $self->{_a} = $_[1]->{_a} if defined $_[1]->{_a};
    $self->{_p} = $_[1]->{_p} if defined $_[1]->{_p};
    return $self;
    }

  my $self = bless {
	sign => $_[0]->{sign}, 
	value => $CALC->_copy($_[0]->{value}),
	}, ref($_[0]);

  $self->{_a} = $_[0]->{_a} if defined $_[0]->{_a};
  $self->{_p} = $_[0]->{_p} if defined $_[0]->{_p};
  $self;
  }

sub new 
  {
  # create a new BigInt object from a string or another BigInt object. 
  # see hash keys documented at top

  # the argument could be an object, so avoid ||, && etc on it, this would
  # cause costly overloaded code to be called. The only allowed ops are
  # ref() and defined.

  my ($class,$wanted,$a,$p,$r) = @_;
 
  # avoid numify-calls by not using || on $wanted!
  return $class->bzero($a,$p) if !defined $wanted;	# default to 0
  return $class->copy($wanted,$a,$p,$r)
   if ref($wanted) && $wanted->isa($class);		# MBI or subclass

  $class->import() if $IMPORT == 0;		# make require work
  
  my $self = bless {}, $class;

  # shortcut for "normal" numbers
  if ((!ref $wanted) && ($wanted =~ /^([+-]?)[1-9][0-9]*\z/))
    {
    $self->{sign} = $1 || '+';

    if ($wanted =~ /^[+-]/)
     {
      # remove sign without touching wanted to make it work with constants
      my $t = $wanted; $t =~ s/^[+-]//;
      $self->{value} = $CALC->_new($t);
      }
    else
      {
      $self->{value} = $CALC->_new($wanted);
      }
    no strict 'refs';
    if ( (defined $a) || (defined $p) 
        || (defined ${"${class}::precision"})
        || (defined ${"${class}::accuracy"}) 
       )
      {
      $self->round($a,$p,$r) unless (@_ == 4 && !defined $a && !defined $p);
      }
    return $self;
    }

  # handle '+inf', '-inf' first
  if ($wanted =~ /^[+-]?inf\z/)
    {
    $self->{sign} = $wanted;		# set a default sign for bstr()
    return $self->binf($wanted);
    }
  # split str in m mantissa, e exponent, i integer, f fraction, v value, s sign
  my ($mis,$miv,$mfv,$es,$ev) = _split($wanted);
  if (!ref $mis)
    {
    if ($_trap_nan)
      {
      require Carp; Carp::croak("$wanted is not a number in $class");
      }
    $self->{value} = $CALC->_zero();
    $self->{sign} = $nan;
    return $self;
    }
  if (!ref $miv)
    {
    # _from_hex or _from_bin
    $self->{value} = $mis->{value};
    $self->{sign} = $mis->{sign};
    return $self;	# throw away $mis
    }
  # make integer from mantissa by adjusting exp, then convert to bigint
  $self->{sign} = $$mis;			# store sign
  $self->{value} = $CALC->_zero();		# for all the NaN cases
  my $e = int("$$es$$ev");			# exponent (avoid recursion)
  if ($e > 0)
    {
    my $diff = $e - CORE::length($$mfv);
    if ($diff < 0)				# Not integer
      {
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
        }
      #print "NOI 1\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    else					# diff >= 0
      {
      # adjust fraction and add it to value
      #print "diff > 0 $$miv\n";
      $$miv = $$miv . ($$mfv . '0' x $diff);
      }
    }
  else
    {
    if ($$mfv ne '')				# e <= 0
      {
      # fraction and negative/zero E => NOI
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
        }
      #print "NOI 2 \$\$mfv '$$mfv'\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    elsif ($e < 0)
      {
      # xE-y, and empty mfv
      #print "xE-y\n";
      $e = abs($e);
      if ($$miv !~ s/0{$e}$//)		# can strip so many zero's?
        {
        if ($_trap_nan)
          {
          require Carp; Carp::croak("$wanted not an integer in $class");
          }
        #print "NOI 3\n";
        return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
        $self->{sign} = $nan;
        }
      }
    }
  $self->{sign} = '+' if $$miv eq '0';			# normalize -0 => +0
  $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
  # if any of the globals is set, use them to round and store them inside $self
  # do not round for new($x,undef,undef) since that is used by MBF to signal
  # no rounding
  $self->round($a,$p,$r) unless @_ == 4 && !defined $a && !defined $p;
  $self;
  }

sub bnan
  {
  # create a bigint 'NaN', if given a BigInt, set it to 'NaN'
  my $self = shift;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_nan"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to NaN in $class\::bnan()");
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bnan');
  if ($self->can('_bnan'))
    {
    # use subclass to initialize
    $self->_bnan();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = $nan;
  delete $self->{_a}; delete $self->{_p};	# rounding NaN is silly
  $self;
  }

sub binf
  {
  # create a bigint '+-inf', if given a BigInt, set it to '+-inf'
  # the sign is either '+', or if given, used from there
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign !~ /^-(inf)?$/;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_inf"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to +-inf in $class\::binf()");
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('binf');
  if ($self->can('_binf'))
    {
    # use subclass to initialize
    $self->_binf();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $sign = $sign . 'inf' if $sign !~ /inf$/;	# - => -inf
  