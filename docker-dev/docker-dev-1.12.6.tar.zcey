	    output_size, TRUE)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_allocate() memory for output of size "
		       "%lu", output_size);
#ifdef RLD_VM_ALLOC_DEBUG
	print("rld() vm_allocate: addr = 0x%0x size = 0x%x\n",
	      (unsigned int)output_addr, (unsigned int)output_size);
#endif /* RLD_VM_ALLOC_DEBUG */
}
#endif /* defined(RLD) && !defined(SA_RLD) &&
	  !(defined(KLD) && defined(__STATIC__)) */

/*
 * layout_segments() basicly lays out the addresses and file offsets of
 * everything in the ouput file (since everything can be in a segment).
 * It checks for the link editor reserved segment "__PAGEZERO" and "__LINKEDIT"
 * and prints an error message if they exist in the output.  It creates these
 * segments if this is the right file type and the right options are specified.
 * It processes all the segment specifications from the command line options.
 * Sets the addresses of all segments and sections in those segments and sets
 * the sizes of all segments.  Also sets the file offsets of all segments,
 * sections, relocation information and symbol table information.  It creates
 * the mach header that will go in the output file.  It numbers the merged
 * sections with their section number they will have in the output file.
 */
static
void
layout_segments(void)
{
    unsigned long i, ncmds, sizeofcmds, headers_size, offset;
    unsigned long addr, size, max_first_align, pad, max_align;
    struct merged_segment **p, *msg, *first_msg;
    struct merged_section **content, **zerofill, *ms;
#ifndef RLD
    struct merged_fvmlib **q, *mfl;
    unsigned long nfvmlibs;
    struct segment_spec *seg_spec;
    enum bool address_zero_specified;
    struct merged_dylib *mdl;
    struct dynamic_library *dp;
#endif /* !defined(RLD) */
#ifdef RLD
#ifndef SA_RLD
    kern_return_t r;
#endif /* !defined SA_RLD */
    unsigned long allocate_size;
#endif /* defined(RLD) */
    struct merged_symbol *merged_symbol;

    static struct merged_segment linkedit_segment = { {0} };
    static struct merged_segment pagezero_segment = { {0} };
    static struct merged_segment stack_segment = { {0} };
    static struct merged_segment object_segment = { {0} };

#ifdef RLD
	memset(&object_segment, '\0', sizeof(struct merged_segment));
	original_merged_segments = merged_segments;
#endif /* RLD */

	/*
	 * If the file type is MH_OBJECT then place all the sections in one
	 * unnamed segment.
	 */
	if(filetype == MH_OBJECT){
	    object_segment.filename = outputfile;
	    content = &(object_segment.content_sections);
	    zerofill = &(object_segment.zerofill_sections);
	    p = &merged_segments;
	    while(*p){
		msg = *p;
		object_segment.sg.nsects += msg->sg.nsects;
		*content = msg->content_sections;
		while(*content){
		    ms = *content;
		    content = &(ms->next);
		}
		*zerofill = msg->zerofill_sections;
		while(*zerofill){
		    ms = *zerofill;
		    zerofill = &(ms->next);
		}
		p = &(msg->next);
	    }
	    if(object_segment.sg.nsects != 0)
		merged_segments = &object_segment;
	}

#ifndef RLD
	/*
	 * Set thread_in_output in the output_thread_info if we are going to
	 * create a thread command.  It is created if this is filetype is not a
	 * shared library or bundle and we have seen an object file so we know
	 * what type of machine the thread is for.  Or if we haven't seen an
	 * object file but entry point symbol name was specified.
	 */
 	if(filetype != MH_FVMLIB &&
	   filetype != MH_DYLIB &&
	   filetype != MH_BUNDLE &&
	   arch_flag.cputype != 0 &&
 	   ((merged_segments != NULL &&
	     merged_segments->content_sections != NULL) ||
	     entry_point_name != NULL)){

	    output_thread_info.thread_in_output = TRUE;

	    if(filetype == MH_DYLINKER)
		output_thread_info.thread_command.cmd = LC_THREAD;
	    else
		output_thread_info.thread_command.cmd = LC_UNIXTHREAD;

	    /*
	     * If the stack address or size is set then create the stack segment
	     * for it.
	     */
	    if((stack_addr_specified == TRUE || stack_size_specified == TRUE) &&
	       output_thread_info.thread_command.cmd == LC_UNIXTHREAD){
		if(check_reserved_segment(SEG_UNIXSTACK, "segment "
			SEG_UNIXSTACK " reserved for the -stack_addr and "
			"-stack_size options")){
		    /*
		     * There shouldn't be any segment specifications for this
		     * segment except protection. Protection must be at least
		     * rw- and defaults to architecure's segment protection
		     * default for both initial and maximum protection.
		     */
		    seg_spec = lookup_segment_spec(SEG_UNIXSTACK);
		    if(seg_spec != NULL){
			if(seg_spec->addr_specified)
			    error("specified address for segment " SEG_UNIXSTACK
				  " not allowed (segment " SEG_UNIXSTACK
				  " reserved for unix stack, use -stack_addr)");
			if(seg_spec->prot_specified){
			    if((seg_spec->maxprot &
			        (VM_PROT_READ | VM_PROT_WRITE)) !=
				(VM_PROT_READ | VM_PROT_WRITE)){
				error("specified maximum protection for "
				  "segment " SEG_UNIXSTACK " must include read "
				  " and write");
				seg_spec->maxprot |= (VM_PROT_READ |
						      VM_PROT_WRITE);
			    }
			    if((seg_spec->initprot &
			        (VM_PROT_READ | VM_PROT_WRITE)) !=
				(VM_PROT_READ | VM_PROT_WRITE)){
				error("specified initial protection for "
				  "segment " SEG_UNIXSTACK " must include read "
				  " and write");
				seg_spec->initprot |= (VM_PROT_READ |
						       VM_PROT_WRITE);
			    }
			    stack_segment.sg.maxprot = seg_spec->maxprot;
			    stack_segment.sg.initprot = seg_spec->initprot;
			    /*
			     * Only if the protection of the static is specified
			     * to include execute permision do we also cause the
			     * MH_ALLOW_STACK_EXECUTION bit to get set.
			     */
			    if((stack_segment.sg.maxprot & VM_PROT_EXECUTE) ==
			       VM_PROT_EXECUTE)
				allow_stack_execute = TRUE;
			}
			seg_spec->processed = TRUE;
			stack_segment.prot_set = TRUE;
		    }
		    else{
			stack_segment.sg.maxprot =
			    get_segprot_from_flag(&arch_flag);
			stack_segment.sg.initprot = stack_segment.sg.maxprot;
			stack_segment.prot_set = TRUE;
		    }
		    if(stack_addr_specified == TRUE){
			if(stack_addr % segalign != 0)
			    fatal("-stack_addr: 0x%x not a multiple of the "
				  "segment alignment (0x%x)",
				  (unsigned int)stack_addr,
				  (unsigned int)segalign);
		    }
		    else{
			stack_addr = get_stack_addr_from_flag(&arch_flag);
			warning("no -stack_addr specified using the default "
				"addr: 0x%x", (unsigned int)stack_addr);
			stack_addr_specified = TRUE;
		    }
		    if(stack_size_specified == TRUE){
			if(stack_size % segalign != 0)
			    fatal("-stack_size: 0x%x not a multiple of the "
				  "segment alignment (0x%x)",
				  (unsigned int)stack_size,
				  (unsigned int)segalign);
		    }
		    else{
			stack_size = get_stack_size_from_flag(&arch_flag);
			warning("no -stack_size specified using the default "
				"size: 0x%x", (unsigned int)stack_size);
		    }
		    stack_segment.filename = outputfile;
		    strcpy(stack_segment.sg.segname, SEG_UNIXSTACK);
		    if(get_stack_direction_from_flag(&arch_flag) < 0)
			stack_segment.sg.vmaddr = stack_addr - stack_size;
		    else
			stack_segment.sg.vmaddr = stack_addr;
		    stack_segment.sg.vmsize = stack_size;
		    stack_segment.addr_set = TRUE;
		    /* place this last in the merged segment list */
		    p = &merged_segments;
		    while(*p){
			msg = *p;
			p = &(msg->next);
		    }
		    *p = &stack_segment;
		}
	    }
	}
	else{
	    output_thread_info.thread_in_output = FALSE;
	}

	/*
	 * Set routines_in_output in the output_routines_info if we are going to
	 * create a routines command.  It is created if this filetype is a
	 * shared library and an init name was specified.
	 */
 	if(filetype == MH_DYLIB && init_name != NULL){
	    output_routines_info.routines_in_output = TRUE;
	    output_routines_info.routines_command.cmd = LC_ROUTINES;
	    output_routines_info.routines_command.cmdsize =
		sizeof(struct routines_command);
	}
	else{
	    output_routines_info.routines_in_output = FALSE;
	}

	/*
	 * Create the link edit segment if specified and size it.
	 */
	if(filetype == MH_EXECUTE ||
	   filetype == MH_BUNDLE ||
	   filetype == MH_FVMLIB ||
	   filetype == MH_DYLIB ||
	   filetype == MH_DYLINKER){
	    if(check_reserved_segment(SEG_LINKEDIT, "segment " SEG_LINKEDIT
				   " reserved for the -seglinkedit option")){
		/*
		 * Now that the above check has been made and the segment is
		 * known not to exist create the link edit segment if specified.
		 */
		if(seglinkedit == TRUE){
		    /*
		     * Fill in the merged segment.  In this case only the
		     * segment name and filesize of the segment are not zero
		     * or NULL.  Note the link edit segment is unique in that
		     * it's filesize is not rounded to the segment alignment.
		     * This can only be done because this is the last segment
		     * in the file (right before end of file).
		     */
		    linkedit_segment.filename = outputfile;
		    strcpy(linkedit_segment.sg.segname, SEG_LINKEDIT);
		    if(save_reloc)
			linkedit_segment.sg.filesize += nreloc *
						sizeof(struct relocation_info);
		    if(output_for_dyld)
			linkedit_segment.sg.filesize +=
			    (output_dysymtab_info.dysymtab_command.nlocrel +
			     output_dysymtab_info.dysymtab_command.nextrel) *
			    sizeof(struct relocation_info);
		    if(filetype == MH_DYLIB)
			linkedit_segment.sg.filesize +=
			    output_dysymtab_info.dysymtab_command.ntoc *
				sizeof(struct dylib_table_of_contents) +
			    output_dysymtab_info.dysymtab_command.nmodtab *
				sizeof(struct dylib_module) +
			    output_dysymtab_info.dysymtab_command.nextrefsyms *
				sizeof(struct dylib_reference);
		    if(nindirectsyms != 0)
			linkedit_segment.sg.filesize +=
			    nindirectsyms * sizeof(unsigned long);
		    if(strip_level != STRIP_ALL)
			linkedit_segment.sg.filesize +=
			    (nmerged_symbols
			     - nstripped_merged_symbols
			     + nlocal_symbols
			     - nmerged_symbols_referenced_only_from_dylibs) *
			    sizeof(struct nlist) +
			    rnd(merged_string_size +
				  local_string_size +
				  STRING_SIZE_OFFSET,
				  sizeof(unsigned long));
		    else
			warning("segment created for -seglinkedit zero size "
			        "(output file stripped)");
		    if(output_for_dyld &&
		       twolevel_namespace == TRUE &&
		       twolevel_namespace_hints == TRUE)
			linkedit_segment.sg.filesize +=
			    output_hints_info.twolevel_hints_command.nhints *
			    sizeof(struct twolevel_hint);
		    linkedit_segment.sg.vmsize =
				rnd(linkedit_segment.sg.filesize, segalign);
		    /* place this last in the merged segment list */
		    p = &merged_segments;
		    while(*p){
			msg = *p;
			p = &(msg->next);
		    }
		    *p = &linkedit_segment;
		}
	    }
	}

	/*
	 * If the the file type is MH_EXECUTE and address zero has not been
	 * assigned to a segment create the "__PAGEZERO" segment.
	 */
	if(filetype == MH_EXECUTE){
	    if(check_reserved_segment(SEG_PAGEZERO, "segment " SEG_PAGEZERO
				      " reserved for address zero through "
				      "segment alignment")){
		/*
		 * There shouldn't be any segment specifications for this
		 * segment (address or protection).
		 */
		seg_spec = lookup_segment_spec(SEG_PAGEZERO);
		if(seg_spec != NULL){
		    if(seg_spec->addr_specified)
			error("specified address for segment " SEG_PAGEZERO
			      " not allowed (segment " SEG_PAGEZERO " reserved "
			      "for address zero through segment alignment)");
		    if(seg_spec->prot_specified)
			error("specified protection for segment " SEG_PAGEZERO
			      " not allowed (segment " SEG_PAGEZERO " reserved "
			      "for address zero through segment alignment and "
			      "has no assess protections)");
		    seg_spec->processed = TRUE;
		}
		address_zero_specified = FALSE;
		for(i = 0; i < nsegment_specs; i++){
		    if(segment_specs[i].addr_specified &&
		       segment_specs[i].addr == 0 &&
		       &(segment_specs[i]) != seg_spec){
			address_zero_specified = TRUE;
			break;
		    }
		}
		if(address_zero_specified == FALSE &&
		   (seg1addr_specified == FALSE || seg1addr != 0)){
		    pagezero_segment.filename = outputfile;
		    pagezero_segment.addr_set = TRUE;
		    pagezero_segment.prot_set = TRUE;
		    strcpy(pagezero_segment.sg.segname, SEG_PAGEZERO);
		    if(pagezero_size != 0)
			pagezero_segment.sg.vmsize = rnd(pagezero_size,
							   segalign);
		    else
			pagezero_segment.sg.vmsize = segalign;
		    /* place this first in the merged segment list */
		    pagezero_segment.next = merged_segments;
		    merged_segments = &pagezero_segment;
		}
	    }
	}

	/*
	 * Process the command line specifications for the segments setting the
	 * addresses and protections for the specified segments into the merged
	 * segments.
	 */
	process_segment_specs();
#endif /* !defined(RLD) */

#ifndef RLD
	/*
	 * If there is a "__TEXT" segment who's protection has not been set
	 * set it's inital protection to "r-x" and it's maximum protection
	 * to "rwx".
	 */
	msg = lookup_merged_segment(SEG_TEXT);
	if(msg != NULL && msg->prot_set == FALSE){
	    msg->sg.initprot = VM_PROT_READ | VM_PROT_EXECUTE;
	    msg->sg.maxprot = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
	    msg->prot_set = TRUE;
	}
	/*
	 * If there is a "__IMPORT" segment who's protection has not been set
	 * set it's inital protection to "rwx" and it's maximum protection
	 * to "rwx".
	 */
	msg = lookup_merged_segment(SEG_IMPORT);
	if(msg != NULL && msg->prot_set == FALSE){
	    msg->sg.initprot = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
	    msg->sg.maxprot = VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
	    msg->prot_set = TRUE;
	}
	/*
	 * If the "__LINKEDIT" segment is created sets its inital protection to
	 * "r--" and it's maximum protection to the architecture's default.
	 */
	if(seglinkedit){
	    msg = lookup_merged_segment(SEG_LINKEDIT);
	    if(msg != NULL && msg->prot_set == FALSE){
		msg->sg.initprot = VM_PROT_READ;
		msg->sg.maxprot = get_segprot_from_flag(&arch_flag);
		msg->prot_set = TRUE;
	    }
	}
#endif /* !defined(RLD) */

	/*
	 * Set the protections of segments that have not had their protection
	 * set to the architecture's default protection.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    if(msg->prot_set == FALSE){
		/*
		 * Only turn on execute protection if any of the sections in
		 * the segment contain some instructions.  For pre-4.0 objects
		 * this is always in the (__TEXT,__text) section and is handled
		 * above anyway.
		 */
		msg->sg.initprot = VM_PROT_READ | VM_PROT_WRITE;
		content = &(msg->content_sections);
		while(*content){
		    ms = *content;
		    if((ms->s.flags & S_ATTR_SOME_INSTRUCTIONS) ==
			S_ATTR_SOME_INSTRUCTIONS){
			msg->sg.initprot |= VM_PROT_EXECUTE;
			break;
		    }
		    content = &(ms->next);
		}
		msg->sg.maxprot = get_segprot_from_flag(&arch_flag);
		if((msg->sg.initprot & VM_PROT_EXECUTE) == VM_PROT_EXECUTE)
		    msg->sg.maxprot |= VM_PROT_EXECUTE;
		msg->prot_set = TRUE;
	    }
	    p = &(msg->next);
	}

	/*
	 * Set the address of the first segment via the -seg1addr option or the
	 * -segs_read_only_addr/-segs_read_write_addr options or the default
	 * first address of the output format.
	 */
	if(segs_read_only_addr_specified){
	    if(segs_read_only_addr % segalign != 0)
		fatal("-segs_read_only_addr: 0x%x not a multiple of the segment"
		      " alignment (0x%x)", (unsigned int)segs_read_only_addr,
		      (unsigned int)segalign);
	    if(segs_read_write_addr_specified){
		if(segs_read_write_addr % segalign != 0)
		    fatal("-segs_read_write_addr: 0x%x not a multiple of the "
		          "segment alignment (0x%x)",
			  (unsigned int)segs_read_write_addr,
			  (unsigned int)segalign);
	    }
	    else{
		segs_read_write_addr = segs_read_only_addr + 
				   get_shared_region_size_from_flag(&arch_flag);
	    }
	}
	first_msg = merged_segments;
	if(first_msg == &pagezero_segment)
	    first_msg = first_msg->next;
	if(first_msg != NULL){
	    if(seg1addr_specified == TRUE){
		if(seg1addr % segalign != 0)
		    fatal("-seg1addr: 0x%x not a multiple of the segment "
			  "alignment (0x%x)", (unsigned int)seg1addr,
			  (unsigned int)segalign);
		if(first_msg->addr_set == TRUE)
		    fatal("address of first segment: %.16s set both by name "
			  "and with the -seg1addr option",
			  first_msg->sg.segname);
		first_msg->sg.vmaddr = seg1addr;
		first_msg->addr_set = TRUE;
	    }
	    else{
		if(first_msg->addr_set == FALSE){
		    if(filetype == MH_EXECUTE &&
		       pagezero_segment.addr_set == TRUE)
			first_msg->sg.vmaddr = pagezero_segment.sg.vmsize;
		    else{
			if(segs_read_only_addr_specified){
			    if((first_msg->sg.initprot & VM_PROT_WRITE) == 0)
				first_msg->sg.vmaddr = segs_read_only_addr;
			    else
				first_msg->sg.vmaddr = segs_read_write_addr;
			}
			else{
			    first_msg->sg.vmaddr = 0;
			}
		    }
		    first_msg->addr_set = TRUE;
		}
	    }
	}

	/*
	 * Size and count the load commands in the output file which include:
	 *   The segment load commands
	 *   The load fvmlib commands
	 *   A symtab command
	 *   A dysymtab command
	 *   A thread command (if the file type is NOT MH_DYLIB or MH_FVMLIB)
	 */
	ncmds = 0;
	sizeofcmds = 0;
	/*
	 * Size the segment commands and accumulate the number of commands and
	 * size of them.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    msg->sg.cmd = LC_SEGMENT;
	    msg->sg.cmdsize = sizeof(struct segment_command) +
			      msg->sg.nsects * sizeof(struct section);
	    ncmds++;
	    sizeofcmds += msg->sg.cmdsize;
	    p = &(msg->next);
	}
#ifndef RLD
	/*
	 * Accumulate the number of commands for the fixed VM shared libraries
	 * and their size.  Since the commands themselves come from the input
	 * object files the 'cmd' and 'cmdsize' fields are already set.
	 */
	nfvmlibs = 0;
	q = &merged_fvmlibs;
	while(*q){
	    mfl = *q;
	    nfvmlibs++;
	    sizeofcmds += mfl->fl->cmdsize;
	    q = &(mfl->next);
	}
	if(filetype == MH_FVMLIB && nfvmlibs != 1){
	    if(nfvmlibs == 0)
		error("no LC_IDFVMLIB command in the linked object files");
	    else
		error("more than one LC_IDFVMLIB command in the linked object "
		      "files");
	}
	ncmds += nfvmlibs;

	/*
	 * If the output file is a dynamicly linked shared library (MH_DYLIB)
	 * then create the library identifing information load command.  And
	 * if -sub_framework was specified then create the sub_framework
	 * command.
	 */
	if(filetype == MH_DYLIB){
	    create_dylib_id_command();
	    if(sub_framework == TRUE){
		create_sub_framework_command();
		sizeofcmds += merged_sub_framework->sub->cmdsize;
		ncmds++;
	    }
	    if(nsub_umbrellas != 0){
		sizeofcmds += create_sub_umbrella_commands();
		ncmds += nsub_umbrellas;
	    }
	    if(nsub_librarys != 0){
		sizeofcmds += create_sub_library_commands();
		ncmds += nsub_librarys;
	    }
	    if(nallowable_clients != 0){
		sizeofcmds += create_sub_client_commands();
		ncmds += nallowable_clients;
	    }
	}
	/*
	 * If the output file is a dynamic linker (MH_DYLINKER) then create the
	 * the dynamic linker identifing information load command.
	 */
	if(filetype == MH_DYLINKER)
	    create_dylinker_id_command();

	/*
	 * If there is a dynamic linkers then account for the load commands and
	 * it's size.  The command already has the 'cmd' and 'cmdsize' fields
	 * set.
	 */
	if(merged_dylinker != NULL){
	    sizeofcmds += merged_dylinker->dyld->cmdsize;
	    ncmds++;
	}

	/*
	 * Accumulate the number of commands for the dynamicly linked shared
	 * libraries and their size.  The commands already have their 'cmd' and
	 * 'cmdsize' fields set.
	 */
	mdl = merged_dylibs;
	while(mdl != NULL){
	    sizeofcmds += mdl->dl->cmdsize;
	    ncmds++;
	    /*
	     * If -headerpad_max_install_names is specified make sure headerpad
	     * is big enough to change all the install name of the dylibs in
	     * the output to MAXPATHLEN.
	     */
	    if(headerpad_max_install_names == TRUE){
		if(mdl->dl->cmdsize - sizeof(struct dylib_command) < MAXPATHLEN)
		    headerpad += MAXPATHLEN -
				 (mdl->dl->cmdsize -
				  sizeof(struct dylib_command));
	    }
	    mdl = mdl->next;
	}

	/*
	 * Accumulate the number of commands for the prebound dynamic libraries
	 * and their size.
	 */
	if(filetype == MH_EXECUTE){
	    for(dp = dynamic_libs; dp != NULL; dp = dp->next){
		if(dp->type == DYLIB){
		    if(dp->pbdylib != NULL){
			sizeofcmds += dp->pbdylib->cmdsize;
			ncmds++;
			/*
			 * If -headerpad_max_install_names is specified make
			 * sure headerpad is big enough to change all the
			 * install name of the dylibs in the output to
			 * MAXPATHLEN.
			 */
			if(headerpad_max_install_names == TRUE){
			    if(dp->pbdylib->cmdsize -
			       sizeof(struct prebound_dylib_command) <
				MAXPATHLEN)
				headerpad += MAXPATHLEN -
				     (dp->pbdylib->cmdsize -
				      sizeof(struct prebound_dylib_command));
			}
			/*
			 * Since we are building this executable prebound we
			 * want to have some header padding in case their are
			 * more indirectly referenced dylibs that will need to
			 * be added when redoing the prebinding.  We have found
			 * that in the 10.2 release that 3 times the size of
			 * the initial LC_PREBOUND_DYLIB commands seems to work
			 * for most but not all things.
			 */
			headerpad += dp->pbdylib->cmdsize * 3 * indirect_library_ratio;
		    }
		}
	    }
	}

#endif /* !defined(RLD) */
	/*
	 * Create the symbol table load command.
	 */
	output_symtab_info.symtab_command.cmd = LC_SYMTAB;
	output_symtab_info.symtab_command.cmdsize =
						sizeof(struct symtab_command);
	if(strip_level != STRIP_ALL){
	    output_symtab_info.symtab_command.nsyms =
		nmerged_symbols
		- nstripped_merged_symbols
		+ nlocal_symbols
		- nmerged_symbols_referenced_only_from_dylibs;
	    output_symtab_info.symtab_command.strsize =
		rnd(merged_string_size +
		      local_string_size +
		      STRING_SIZE_OFFSET,
		      sizeof(unsigned long));
	    output_symtab_info.output_strpad =
		output_symtab_info.symtab_command.strsize -
		(merged_string_size + local_string_size + STRING_SIZE_OFFSET);
	    output_symtab_info.output_merged_strsize = STRING_SIZE_OFFSET;
	    output_symtab_info.output_local_strsize = STRING_SIZE_OFFSET +
						      merged_string_size;
	}
	ncmds++;
	sizeofcmds += output_symtab_info.symtab_command.cmdsize;
	/*
	 * Create the dynamic symbol table load command.
	 */
	if(nindirectsyms != 0 || output_for_dyld){
	    output_dysymtab_info.dysymtab_command.cmd = LC_DYSYMTAB;
	    output_dysymtab_info.dysymtab_command.cmdsize =
						sizeof(struct dysymtab_command);
	    output_dysymtab_info.dysymtab_command.nindirectsyms = nindirectsyms;
	    ncmds++;
	    sizeofcmds += output_dysymtab_info.dysymtab_command.cmdsize;
	}
	/*
	 * Create the two-level namespace hints load command.
	 */
	if(output_for_dyld && twolevel_namespace == TRUE &&
	   twolevel_namespace_hints == TRUE){
	    output_hints_info.twolevel_hints_command.cmd = LC_TWOLEVEL_HINTS;
	    output_hints_info.twolevel_hints_command.cmdsize =
					sizeof(struct twolevel_hints_command);
	    ncmds++;
	    sizeofcmds += output_hints_info.twolevel_hints_command.cmdsize;
	}
	/*
	 * Create the prebind cksum load command.
	 */
	if(prebinding == TRUE && macosx_deployment_target.major >= 2){
	    output_cksum_info.prebind_cksum_command.cmd = LC_PREBIND_CKSUM;
	    output_cksum_info.prebind_cksum_command.cmdsize =
					sizeof(struct prebind_cksum_command);
	    output_cksum_info.prebind_cksum_command.cksum = 0;
	    ncmds++;
	    sizeofcmds += output_cksum_info.prebind_cksum_command.cmdsize;
	}
	/*
	 * Create the uuid load command.
	 */
#ifndef KLD
	if(output_uuid_info.suppress != TRUE &&
	   (output_uuid_info.emit == TRUE ||
	    arch_flag.cputype == CPU_TYPE_ARM)){
	    output_uuid_info.uuid_command.cmd = LC_UUID;
	    output_uuid_info.uuid_command.cmdsize = sizeof(struct uuid_command);
	    uuid(&(output_uuid_info.uuid_command.uuid[0]));
	    ncmds++;
	    sizeofcmds += output_uuid_info.uuid_command.cmdsize;
	}
#else
	if(output_uuid_info.uuid_command.cmdsize != 0){
	    ncmds++;
	    sizeofcmds += output_uuid_info.uuid_command.cmdsize;
	}
#endif /* KLD */

	/*
	 * Create the thread command if this is filetype is to have one.
	 */
	if(output_thread_info.thread_in_output == TRUE){
	    output_thread_info.thread_command.cmdsize =
						sizeof(struct thread_command) +
						2 * sizeof(long);
	    if(arch_flag.cputype == CPU_TYPE_MC680x0){
		output_thread_info.flavor = M68K_THREAD_STATE_REGS;
		output_thread_info.count = M68K_THREAD_STATE_REGS_COUNT;
		output_thread_info.entry_point = &(mc680x0.pc);
		output_thread_info.stack_pointer = &(mc680x0.areg[7]);
		output_thread_info.state = &mc680x0;
		output_thread_info.thread_command.cmdsize += sizeof(long) *
					    M68K_THREAD_STATE_REGS_COUNT;
	    }
	    else if(arch_flag.cputype == CPU_TYPE_POWERPC ||
		    arch_flag.cputype == CPU_TYPE_VEO){
		output_thread_info.flavor = PPC_THREAD_STATE;
		output_thread_info.count = PPC_THREAD_STATE_COUNT;
		output_thread_info.entry_point = (int *)&(powerpc.srr0);
		output_thread_info.stack_pointer = (int *)&(powerpc.r1);
		output_thread_info.state = &powerpc;
		output_thread_info.thread_command.cmdsize += sizeof(long) *
					    PPC_THREAD_STATE_COUNT;
	    }
	    else if(arch_flag.cputype == CPU_TYPE_MC88000){
		output_thread_info.flavor = M88K_THREAD_STATE_GRF;
		output_thread_info.count = M88K_THREAD_STATE_GRF_COUNT;
		output_thread_info.entry_point = (int *)&(mc88000.xip);
		output_thread_info.stack_pointer = (int *)&(mc88000.r31);
		output_thread_info.state = &mc88000;
		output_thread_info.thread_command.cmdsize += sizeof(long) *
					    M88K_THREAD_STATE_GRF_COUNT;
	    }
	    else if(arch_flag.cputype == CPU_TYPE_I860){
		output_thread_info.flavor = I860_THREAD_STATE_REGS;
		output_thread_info.count = I860_THREAD_STATE_REGS_COUNT;
		output_thread_info.entry_point = &(i860.pc);
		output_thread_info.stack_pointer = &(i860.ireg[0]);
		output_thread_info.state = &i860;
		output_thread_info.thread_command.cmdsize += sizeof(long) *
					  I860_THREAD_STATE_REGS_COUNT;
	    }
	    else if(arch_flag.cputype == CPU_TYPE_I386){
		output_thread_info.flavor = i386_THREAD_STATE;
		output_thread_info.count = i386_THREAD_STATE_COUNT;
		output_thread_info.entry_point = (int *)&(intel386.eip);
		output_thread_info.stack_pointer = (int *)&(intel386.esp);
		intel386.es = USER_DATA_SELECTOR;
		intel386.ds = USER_DATA_SELECTOR;
		intel386.ss = USER_DATA_SELECTOR;
		intel386.cs = USER_CODE_SELECTOR;
		output_thread_info.state = &intel386;
		output_thread_info.thread_command.cmdsize += sizeof(long) *
					    i386_THREAD_STATE_COUNT;
	    }
	    else if(arch_flag.cputype == CPU_TYPE_HPPA){
		output_thread_info.flavor = HPPA_FRAME_THREAD_STATE;
		output_thread_info.count = HPPA_FRAME_THREAD_STATE_COUNT;
		output_thread_info.entry_point =
				(int *)&(hppa_frame_state.ts_pcoq_front);
		output_thread_info.state = &hppa_frame_state;
		output_thread_info.thread_command.cmdsize += sizeof(long) *
					    HPPA_FRAME_THREAD_STATE_COUNT;
		if(stack_addr_specified == TRUE){
		    output_thread_info.second_flavor =
						HPPA_INTEGER_THREAD_STATE;
		    output_thread_info.second_count =
						HPPA_INTEGER_THREAD_STATE_COUNT;
		    output_thread_info.stack_pointer =
					(int *)&(hppa_integer_state.ts_gr30);
		    output_thread_info.second_state = &hppa_integer_state;
		    output_thread_info.thread_command.cmdsize +=
				sizeof(long) * HPPA_INTEGER_THREAD_STATE_COUNT +
				2 * sizeof(long);
		}
	    }
	    else if (arch_flag.cputype == CPU_TYPE_SPARC) {
	      output_thread_info.flavor = SPARC_THREAD_STATE_REGS;
	      output_thread_info.count = SPARC_THREAD_STATE_REGS_COUNT;
	      output_thread_info.entry_point = &(sparc_state.regs.r_pc);
	      output_thread_info.stack_pointer = &(sparc_state.regs.r_sp);
	      output_thread_info.state = &sparc_state;
	      output_thread_info.thread_command.cmdsize += sizeof(long) *
		SPARC_THREAD_STATE_REGS_COUNT;
	    }
	    else if (arch_flag.cputype == CPU_TYPE_ARM) {
	      output_thread_info.flavor = ARM_THREAD_STATE;
	      output_thread_info.count = ARM_THREAD_STATE_COUNT;
	      output_thread_info.entry_point = (int *)&(arm_state.__pc);
	      output_thread_info.stack_pointer = (int *)&(arm_state.__sp);
	      output_thread_info.state = &arm_state;
	      output_thread_info.thread_command.cmdsize += sizeof(long) *
		ARM_THREAD_STATE_COUNT;
	    }
	    else{
		fatal("internal error: layout_segments() called with unknown "
		      "cputype (%d) set", arch_flag.cputype);
	    }
	    sizeofcmds += output_thread_info.thread_command.cmdsize;
	    ncmds++;
	}

	/*
	 * Create the routines command if this is filetype is to have one.
	 */
	if(output_routines_info.routines_in_output == TRUE){
	    sizeofcmds += output_routines_info.routines_command.cmdsize;
	    ncmds++;
	}

	/*
	 * Fill in the mach_header for the output file.
	 */
	output_mach_header.magic = MH_MAGIC;
	output_mach_header.cputype = arch_flag.cputype;
	output_mach_header.cpusubtype = arch_flag.cpusubtype;
	output_mach_header.filetype = filetype;
	output_mach_header.ncmds = ncmds;
	output_mach_header.sizeofcmds = sizeofcmds;
	output_mach_header.flags = 0;
	if(base_obj != NULL)
	    output_mach_header.flags |= MH_INCRLINK;
	if(output_for_dyld){
	    output_mach_header.flags |= MH_DYLDLINK;
	    if(bind_at_load)
		output_mach_header.flags |= MH_BINDATLOAD;
	    if(segs_read_only_addr_specified)
		output_mach_header.flags |= MH_SPLIT_SEGS;
	    if(twolevel_namespace)
		output_mach_header.flags |= MH_TWOLEVEL;
	    if(force_flat_namespace)
		output_mach_header.flags |= MH_FORCE_FLAT;
	    if(nomultidefs)
		output_mach_header.flags |= MH_NOMULTIDEFS;
	    if(no_fix_prebinding)
		output_mach_header.flags |= MH_NOFIXPREBINDING;
	}
	if(some_non_subsection_via_symbols_objects == FALSE)
	    output_mach_header.flags |= MH_SUBSECTIONS_VIA_SYMBOLS;
	if(allow_stack_execute == TRUE)
	    output_mach_header.flags |= MH_ALLOW_STACK_EXECUTION;

	/*
	 * The total headers size needs to be known in the case of MH_EXECUTE,
	 * MH_BUNDLE, MH_FVMLIB, MH_DYLIB and MH_DYLINKER format file types
	 * because their headers get loaded as part of of the first segment.
	 * For the MH_FVMLIB and MH_DYLINKER file types the headers are placed
	 * on their own page or pages (the size of the segment alignment).
	 */
	headers_size = sizeof(struct mach_header) + sizeofcmds;
	if(filetype == MH_FVMLIB){
	    if(headers_size > segalign)
		fatal("size of headers (0x%x) exceeds the segment alignment "
		      "(0x%x) (would cause the addresses not to be fixed)",
		      (unsigned int)headers_size, (unsigned int)segalign);
	    headers_size = segalign;
	}
	else if(filetype == MH_DYLINKER){
	    headers_size = rnd(headers_size, segalign);
	}

	/*
	 * For MH_EXECUTE, MH_BUNDLE, and MH_DYLIB formats the as much of the
	 * segment padding that can be is moved to the begining of the segment
	 * just after the headers.  This is done so that the headers could
	 * added to by a smart program like segedit(1) some day.
	 */
	if(filetype == MH_EXECUTE ||
	   filetype == MH_BUNDLE ||
	   filetype == MH_DYLIB){
	    if(first_msg != NULL){
		size = 0;
		content = &(first_msg->content_sections);
		if(*content){
		    max_first_align = 1 << (*content)->s.align;
		    while(*content){
			ms = *content;
			if((unsigned long)(1 << ms->s.align) > segalign)
			    error("alignment (0x%x) of section (%.16s,%.16s) "
				  "greater than the segment alignment (0x%x)",
				  (unsigned int)(1 << ms->s.align),
				  ms->s.segname, ms->s.sectname,
				  (unsigned int)segalign);
			size = rnd(size, 1 << ms->s.align);
			if((unsigned long)(1 << ms->s.align) > max_first_align)
			    max_first_align = 1 << ms->s.align;
			size += ms->s.size;
			content = &(ms->next);
		    }
		    if(errors == 0){
			pad = ((rnd(size + rnd(headers_size,
				      max_first_align), segalign) -
			       (size + rnd(headers_size, max_first_align))) /
				 max_first_align) * max_first_align;
			if(pad > headerpad)
			    headerpad = pad;
			headers_size += headerpad;
		    }
		}
	    }
	}

	/*
	 * Assign the section addresses relitive to the start of their segment
	 * to accumulate the file and vm sizes of the segments.
	 */
	max_align = 1;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    if(msg != &pagezero_segment &&
	       msg != &linkedit_segment &&
	       msg != &stack_segment){
		if(msg == first_msg &&
		   (filetype == MH_EXECUTE ||
		    filetype == MH_BUNDLE ||
		    filetype == MH_FVMLIB ||
		    filetype == MH_DYLIB ||
		    filetype == MH_DYLINKER))
		    addr = headers_size;
		else
		    addr = 0;
		content = &(msg->content_sections);
		while(*content){
		    ms = *content;
		    if((unsigned long)(1 << ms->s.align) > segalign)
			error("alignment (0x%x) of section (%.16s,%.16s) "
			      "greater than the segment alignment (0x%x)",
			      (unsigned int)(1 << ms->s.align), ms->s.segname,
			      ms->s.sectname, (unsigned int)segalign);
		    if((unsigned long)(1 << ms->s.align) > max_align)
			max_align = 1 << ms->s.align;
		    addr = rnd(addr, 1 << ms->s.align);
		    ms->s.addr = addr;
		    addr += ms->s.size;
		    content = &(ms->next);
		}
		if(msg == &object_segment)
		    msg->sg.filesize = addr;
		else
		    msg->sg.filesize = rnd(addr, segalign);
		zerofill = &(msg->zerofill_sections);
		while(*zerofill){
		    ms = *zerofill;
		    if((unsigned long)(1 << ms->s.align) > segalign)
			error("alignment (0x%x) of section (%.16s,%.16s) "
			      "greater than the segment alignment (0x%x)",
			      (unsigned int)(1 << ms->s.align), ms->s.segname,
			      ms->s.sectname, (unsigned int)segalign);
		    if((unsigned long)(1 << ms->s.align) > max_align)
			max_align = 1 << ms->s.align;
		    addr = rnd(addr, 1 << ms->s.align);
		    ms->s.addr = addr;
		    addr += ms->s.size;
		    zerofill = &(ms->next);
		}
		if(msg == &object_segment)
		    msg->sg.vmsize = addr;
		else
		    msg->sg.vmsize = rnd(addr, segalign);
	    }
	    p = &(msg->next);
	}

#ifdef RLD
	/*
	 * For rld() the output format is MH_OBJECT and the contents of the
	 * first segment (the entire vmsize not just the filesize), if it exists,
	 * plus headers are allocated and the address the segment is linked to
	 * is the address of this memory.
	 */
	output_size = 0;

	headers_size = rnd(headers_size, max_align);
	output_size = headers_size;
	if(first_msg != NULL)
	    output_size += first_msg->sg.vmsize;
	allocate_size = output_size;
	if(strip_level != STRIP_ALL)
	    allocate_size += output_symtab_info.symtab_command.nsyms *
				sizeof(struct nlist) +
				output_symtab_info.symtab_command.strsize;

#ifdef SA_RLD
	if(allocate_size > sa_rld_output_size)
	    fatal("not enough memory for output of size %lu (memory "
		    "available %lu)", allocate_size, sa_rld_output_size);
	output_addr = sa_rld_output_addr;
#else /* !defined(SA_RLD) */
	if((r = vm_allocate(mach_task_self(), (vm_address_t *)&output_addr,
			    allocate_size, TRUE)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_allocate() memory for output of size "
			"%lu", allocate_size);
	/*
	 * The default initial protection for vm_allocate()'ed memory
	 * may not include VM_PROT_EXECUTE so we need to raise the
	 * the protection to VM_PROT_ALL which include this.
	 */
	if((r = vm_protect(mach_task_self(), (vm_address_t)output_addr,
	    allocate_size, FALSE, VM_PROT_ALL)) != KERN_SUCCESS)
	    mach_fatal(r, "can't set vm_protection on memory for output");
#endif /* defined(SA_RLD) */
#ifdef RLD_VM_ALLOC_DEBUG
	print("rld() vm_allocate: addr = 0x%0x size = 0x%x\n",
		(unsigned int)output_addr, (unsigned int)allocate_size);
#endif /* RLD_VM_ALLOC_DEBUG */
	sets[cur_set].output_addr = output_addr;
	sets[cur_set].output_size = output_size;

	if(first_msg != NULL){
	    if(address_func != NULL){
	        if(RLD_DEBUG_OUTPUT_FILENAME_flag)
		    first_msg->sg.vmaddr =
		      (*address_func)(allocate_size, headers_size)+headers_size;
		else
		    first_msg->sg.vmaddr =
		      (*address_func)(output_size, headers_size) + headers_size;
	    }
	    else
		first_msg->sg.vmaddr = (long)output_addr + headers_size;
	}
#endif /* RLD */
	/*
	 * Set the addresses of segments that have not had their addresses set
	 * and set the addresses of all sections (previously set relitive to the
	 * start of their section and here just moved by the segment address).
	 * The addresses of segments that are not set are set to the next
	 * available address after the first segment that the vmsize will fit
	 * (note that the address of the first segment has been set above).
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    /*
	     * The first segment has had it's address set previouly above so
	     * this test will always fail for it and there is no problem of
	     * trying to use first_msg for the first segment.
	     */
	    if(msg->addr_set == FALSE){
		if(segs_read_only_addr_specified){
		    if((msg->sg.initprot & VM_PROT_WRITE) == 0)
			msg->sg.vmaddr = next_vmaddr(segs_read_only_addr,
						     msg->sg.vmsize);
		    else
			msg->sg.vmaddr = next_vmaddr(segs_read_write_addr,
						     msg->sg.vmsize);
		}
		else{
		    msg->sg.vmaddr = next_vmaddr(first_msg->sg.vmaddr,
						 msg->sg.vmsize);
		}
		msg->addr_set = TRUE;
	    }
	    if(msg != &pagezero_segment &&
	       msg != &linkedit_segment &&
	       msg != &stack_segment){
		content = &(msg->content_sections);
		while(*content){
		    ms = *content;
		    ms->s.addr += msg->sg.vmaddr;
		    content = &(ms->next);
		}
		zerofill = &(msg->zerofill_sections);
		while(*zerofill){
		    ms = *zerofill;
		    ms->s.addr += msg->sg.vmaddr;
		    zerofill = &(ms->next);
		}
	    }
	    p = &(msg->next);
	}

#ifndef RLD
	/*
	 * Check for overlapping segments (including fvmlib segments).
	 */
	check_for_overlapping_segments(&linkedit_segment);

	/*
	 * If prebinding check to see the that the lazy pointer relocation
	 * entries are not too far away to fit into the 24-bit r_adderess field
	 * of a scattered relocation entry.
	 */
	if(prebinding)
	    check_for_lazy_pointer_relocs_too_far();

	if(prebinding)
	    output_mach_header.flags |= MH_PREBOUND;
#endif /* RLD */

	/*
	 * Assign all file offsets.  Things with offsets appear in the following
	 * two possible orders in the file:
	 *
	 *   For relocatable objects (not output for dyld)
	 *	The segments (and their content sections)
	 *	The relocation entries for the content sections
	 *	The symbol table
	 *	The string table.
	 *
	 *   For objects output for dyld
	 *	The segments (and their content sections)
	 *	The local relocation entries
	 *	The symbol table
	 *		local symbols
	 *		external defined symbols
	 *		undefined symbols
	 *	The two-level namespace hints table
	 *	The external relocation entries
	 *	The indirect symbol table
	 *	The table of contents (MH_DYLIB only)
	 *	The module table (MH_DYLIB only)
	 *	The reference table (MH_DYLIB only)
	 *	The string table.
	 *		external strings
	 *		local strings
	 */
	offset = headers_size;
	/* set the offset to the segments and sections */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    if(msg != &pagezero_segment &&
	       msg != &linkedit_segment &&
	       msg != &stack_segment){
		if(msg == first_msg &&
		   (filetype == MH_EXECUTE ||
		    filetype == MH_BUNDLE ||
		    filetype == MH_FVMLIB ||
		    filetype == MH_DYLIB ||
		    filetype == MH_DYLINKER)){
		    msg->sg.fileoff = 0;
		    content = &(msg->content_sections);
		    if(*content){
			ms = *content;
			offset = ms->s.addr - msg->sg.vmaddr;
		    }
		}
		else
		    msg->sg.fileoff = offset;
		content = &(msg->content_sections);
		while(*content){
		    ms = *content;
		    ms->s.offset = offset;
		    if(ms->next != NULL)
			offset += (ms->next->s.addr - ms->s.addr);
		    content = &(ms->next);
		}
		if(msg->sg.filesize == 0)
		    msg->sg.fileoff = 0;
		if(msg == first_msg &&
		   (filetype == MH_EXECUTE ||
		    filetype == MH_BUNDLE ||
		    filetype == MH_FVMLIB ||
		    filetype == MH_DYLIB ||
		    filetype == MH_DYLINKER))
		    offset = msg->sg.filesize;
		else
		    if(msg->sg.filesize != 0)
			offset = msg->sg.fileoff + msg->sg.filesize;
	    }
	    p = &(msg->next);
	}

	/*
	 * The offsets to all the link edit structures in the file must be on
	 * boundaries that they can be mapped into memory and then used as is.
	 * The maximum alignment of all structures in a Mach-O file is
	 * sizeof(long) so the offset must be rounded to this as the sections
	 * and segments may not be rounded to this.
	 */
	offset = rnd(offset, sizeof(long));
#ifdef RLD
	/*
	 * For RLD if there is any symbol table it is written past the size
	 * of the output_size.  Room has been allocated for it above if the
	 * strip_level != STRIP_ALL.
	 */
	offset = output_size;
#endif /* RLD */

	/* the linkedit segment will start here */
	linkedit_segment.sg.fileoff = offset;

	/* set the offset to the relocation entries (if in the output file) */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(save_reloc && ms->s.nreloc != 0){
		    ms->s.reloff = offset;
		    offset += ms->s.nreloc * sizeof(struct relocation_info);
		}
		else{
		    ms->s.reloff = 0;
		    ms->s.nreloc = 0;
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
	if(output_for_dyld){
	    if(output_dysymtab_info.dysymtab_command.nlocrel != 0){
		output_dysymtab_info.dysymtab_command.locreloff = offset;
		offset += output_dysymtab_info.dysymtab_command.nlocrel *
			  sizeof(struct relocation_info);
	    }
	}
	/* set the offset to the symbol table (output for dyld case) */
	if(output_for_dyld){
	    if(strip_level != STRIP_ALL){
		output_symtab_info.symtab_command.symoff = offset;
		offset += output_symtab_info.symtab_command.nsyms *
			  sizeof(struct nlist);
	    }
	}
	/* set the offset to the two-level namespace hints */
	if(output_for_dyld && twolevel_namespace == TRUE &&
	   twolevel_namespace_hints == TRUE){
	    output_hints_info.twolevel_hints_command.offset = offset;
	    offset += output_hints_info.twolevel_hints_command.nhints *
		      sizeof(struct twolevel_hint);
	}
	if(output_for_dyld){
	    if(output_dysymtab_info.dysymtab_command.nextrel != 0){
		output_dysymtab_info.dysymtab_command.extreloff = offset;
		offset += output_dysymtab_info.dysymtab_command.nextrel *
			  sizeof(struct relocation_info);
	    }
	}
	/* set the offset to the indirect symbol table */
	if(nindirectsyms != 0){
	    output_dysymtab_info.dysymtab_command.indirectsymoff = offset;
	    offset += nindirectsyms * sizeof(unsigned long);
	}
#ifndef RLD
	/* set the offset to the dylib tables */
	if(filetype == MH_DYLIB){
	    output_dysymtab_info.dysymtab_command.tocoff = offset;
	    offset += output_dysymtab_info.dysymtab_command.ntoc *
		      sizeof(struct dylib_table_of_contents);
	    output_dysymtab_info.dysymtab_command.modtaboff = offset;
	    offset += output_dysymtab_info.dysymtab_command.nmodtab *
		      sizeof(struct dylib_module);
	    output_dysymtab_info.dysymtab_command.extrefsymoff = offset;
	    offset += output_dysymtab_info.dysymtab_command.nextrefsyms *
		      sizeof(struct dylib_reference);
	}
#endif /* !defined(RLD) */
	/* set the offset to the symbol table (output not for dyld case) */
	if(output_for_dyld == FALSE){
	    if(strip_level != STRIP_ALL){
		output_symtab_info.symtab_command.symoff = offset;
		offset += output_symtab_info.symtab_command.nsyms *
			  sizeof(struct nlist);
	    }
	}
	/* set the offset to the string table */
	if(strip_level != STRIP_ALL){
	    output_symtab_info.symtab_command.stroff = offset;
	    offset += output_symtab_info.symtab_command.strsize;
	}
#ifndef RLD
	/* set the size of the output file */
	output_size = offset;
#endif /* !defined(RLD) */

	/*
	 * Set the output section number in to each merged section to be used
	 * to set symbol's section numbers and local relocation section indexes.
	 */
	i = 1;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		ms->output_sectnum = i++;
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		ms->output_sectnum = i++;
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}
	if(i > MAX_SECT)
	    fatal("too many sections used, maximum is: %d", MAX_SECT);

#ifndef RLD
	/*
	 * Define the loader defined symbols.  This is done here because the
	 * address of the headers is needed to defined the symbol for
	 * MH_EXECUTE, MH_BUNDLE, MH_DYLIB and MH_DYLINKER filetypes.
	 */
	if(filetype == MH_EXECUTE &&
	   first_msg != NULL && first_msg != &linkedit_segment)
	    define_link_editor_execute_symbols(first_msg->sg.vmaddr);
	if((filetype == MH_BUNDLE ||
	    filetype == MH_DYLIB || filetype == MH_DYLINKER) &&
	   first_msg != NULL && first_msg != &linkedit_segment)
	    define_link_editor_dylib_symbols(first_msg->sg.vmaddr);
	if(filetype == MH_PRELOAD)
	    define_link_editor_preload_symbols(FALSE);
#endif /* !defined(RLD) */

	/*
	 * Now with the addresses of the segments and sections set and the
	 * sections numbered for the output file set the values and section
	 * numbers of the merged symbols.
	 */
	layout_merged_symbols();

	/*
	 * Set the entry point to either the specified symbol name's value or
	 * the address of the first section.
	 */
	if(output_thread_info.thread_in_output == TRUE){
	    if(entry_point_name != NULL){
		merged_symbol = lookup_symbol(entry_point_name);
		/*
		 * If the symbol is not found, undefined or common the
		 * entry point can't be set.
		 */
		if(merged_symbol->name_len == 0 ||
		   merged_symbol->nlist.n_type == (N_EXT | N_UNDF))
		    fatal("entry point symbol name: %s not defined",
			  entry_point_name);
		*output_thread_info.entry_point = merged_symbol->nlist.n_value;
	    }
	    else{
		*output_thread_info.entry_point =
					    first_msg->content_sections->s.addr;
	    }
	    /*
	     * Set up wierd hppa instruction address offset queue.
	     * iioq_head is the entry point.  iioq_tail is the next instruction.
	     */
	    if(arch_flag.cputype == CPU_TYPE_HPPA)
		hppa_frame_state.ts_pcoq_back =
			hppa_frame_state.ts_pcoq_front + 4;
	    /*
	     * If the stack address is specified set this in the stack pointer.
	     */
	    if(stack_addr_specified == TRUE &&
	       output_thread_info.thread_command.cmd == LC_UNIXTHREAD)
		*output_thread_info.stack_pointer = stack_addr;
	}
	else{
	    if(entry_point_name != NULL)
		warning("specified entry point symbol name ignored, output "
 			"file type has no entry point or no non-zerofill "
 			"sections");
	}

	/*
	 * Set the addresses and module indexes in the routine command if that
	 * is to appear in the output.
	 */
	if(output_routines_info.routines_in_output == TRUE){
	    if(init_name != NULL){
		merged_symbol = lookup_symbol(init_name);
		/*
		 * If the symbol is not found, undefined or common the
		 * initialization routine address can't be set.
		 */
		if(merged_symbol->name_len == 0 ||
		   merged_symbol->nlist.n_type == (N_EXT | N_UNDF))
		    fatal("initialization routine symbol name: %s not defined",
			  init_name);
		if(arch_flag.cputype == CPU_TYPE_ARM &&
		   (merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF))
		    /* Have to set the low-order bit if symbol is Thumb */
		    output_routines_info.routines_command.init_address =
			merged_symbol->nlist.n_value | 1;
		else
		    output_routines_info.routines_command.init_address =
			merged_symbol->nlist.n_value;
		output_routines_info.routines_command.init_module =
		    merged_symbol->definition_object->imodtab;
	    }
	}
	else{
	    if(init_name != NULL)
		warning("specified initialization routine symbol name ignored, "
			"output file type has no initialization routine");
	}
}

/*
 * next_vmaddr() is passed in a vmaddr and vmsize and returns then next highest
 * vmaddr that will fit the vmsize in the merged segments which have addresses
 * assigned.
 */
static
unsigned long
next_vmaddr(
unsigned long vmaddr,
unsigned long vmsize)
{
    unsigned long i, n;
    struct merged_segment *msg, **sorted_merged_segments;

	/*
	 * Count the of merged segments with addresses set of non-zero size.
	 */
	n = 0;
	for(msg = merged_segments; msg != NULL ; msg = msg->next){
	    if(msg->addr_set == TRUE && msg->sg.vmsize != 0)
		n++;
	}
	/*
	 * If no merged segment of non-zero size has an address set return the
	 * vmaddr passed in.
	 */
	if(n == 0)
	    return(vmaddr);

	/*
	 * Create a list of merged segments sorted by vmaddr for the merged
	 * segments with addresses set of non-zero size.
	 */
	sorted_merged_segments = (struct merged_segment **)
				 allocate(n * sizeof(struct merged_segment *));
	i = 0;
	for(msg = merged_segments; msg != NULL ; msg = msg->next){
	    if(msg->addr_set == TRUE && msg->sg.vmsize != 0){
		sorted_merged_segments[i] = msg;
		i++;
	    }
	}
	qsort(sorted_merged_segments, n, sizeof(struct merged_segment *),
	      (int (*)(const void *, const void *))qsort_vmaddr);

	/*
	 * Find the next highest address from the vmaddr passed in that will fit
	 * the vmsize passed in.  This may wrap around to lower addresses.  Also
	 * if all address space is taken this will return a address that
	 * overlaps.
	 */
	for(i = 0; i < n; i++){
	    if(vmaddr < sorted_merged_segments[i]->sg.vmaddr){
		if(vmaddr + vmsize <= sorted_merged_segments[i]->sg.vmaddr)
		    goto done;
		vmaddr = sorted_merged_segments[i]->sg.vmaddr +
			 sorted_merged_segments[i]->sg.vmsize;
	    }
	    if(vmaddr < sorted_merged_segments[i]->sg.vmaddr +
			sorted_merged_segments[i]->sg.vmsize){
		vmaddr = sorted_merged_segments[i]->sg.vmaddr +
			 sorted_merged_segments[i]->sg.vmsize;
	    }
	}
done:
	free(sorted_merged_segments);
	return(vmaddr);
}

/*
 * Function for qsort to sort merged_segments by their vmaddr.
 */
static
int
qsort_vmaddr(
const struct merged_segment **msg1,
const struct merged_segment **msg2)
{
	if((*msg1)->sg.vmaddr < (*msg2)->sg.vmaddr)
	    return(-1);
	if((*msg1)->sg.vmaddr == (*msg2)->sg.vmaddr)
	    return(0);
	/* (*msg1)->sg.vmaddr > (*msg2)->sg.vmaddr */
	    return(1);
}

#ifndef RLD
/*
 * check_reserved_segment() checks to that the reserved segment is NOT in the
 * merged segment list and returns TRUE if so.  If it the segment is found in
 * the merged segment list it prints an error message stating the segment exists
 * and prints the string passed to it as to why this segment is reserved.  Then
 * It prints all sections created from files in that segment and all object
 * files that contain that segment.  Finally it returns FALSE in this case.
 */
static
enum bool
check_reserved_segment(
char *segname,
char *reserved_error_string)
{
    struct merged_segment *msg;
    struct merged_section **content, *ms;

    unsigned long i, j;
    struct object_list *object_list, **q;
    struct object_file *object_file;
    struct section *s;

	msg = lookup_merged_segment(segname);
	if(msg != NULL){
	    error("segment %s exist in the output file (%s)", segname,
		  reserved_error_string);
	    /*
	     * Loop through the content sections and report any sections
	     * created from files.
	     */
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->contents_filename != NULL)
		    print("section (%.16s,%.16s) created from file "
			   "%s\n", ms->s.segname, ms->s.sectname,
			   ms->contents_filename);
		content = &(ms->next);
	    }
	    /*
	     * Loop through all the objects and report those that have
	     * this segment.
	     */
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    object_file = &(object_list->object_files[i]);
		    if(object_file == base_obj)
			continue;
		    if(object_file->dylib)
			continue;
		    if(object_file->bundle_loader)
			continue;
		    if(object_file->dylinker)
			continue;
		    for(j = 0; j < object_file->nsection_maps; j++){
			s = object_file->section_maps[j].s;
			if(strcmp(s->segname, segname) == 0){
			    print_obj_name(object_file);
			    print("contains section (%.16s,%.16s)\n",
				   s->segname, s->sectname);
			}
		    }
		}
	    }
	    return(FALSE);
	}
	return(TRUE);
}

/*
 * check_for_overlapping_segments() checks for overlapping segments in the
 * output file and in the segments from the fixed VM shared libraries it uses.
 */
static
void
check_for_overlapping_segments(
struct merged_segment *outputs_linkedit_segment)
{
    struct merged_segment **p1, **p2, **last_merged, **last_fvmseg, **last_base,
			  *msg1, *msg2;

	/*
	 * To make the checking loops below clean the fvmlib segment list is
	 * attached to the end of the merged segment list and then detached
	 * before we return.
	 */
	last_merged = &merged_segments;
	while(*last_merged){
	    msg1 = *last_merged;
	    last_merged = &(msg1->next);
	}
	if(fvmlib_segments != NULL){
	    *last_merged = fvmlib_segments;

	    last_fvmseg = &fvmlib_segments;
	    while(*last_fvmseg){
		msg1 = *last_fvmseg;
		last_fvmseg = &(msg1->next);
	    }
	}
	else
	    last_fvmseg = last_merged;
	*last_fvmseg = base_obj_segments;

	p1 = &merged_segments;
	while(*p1){
	    msg1 = *p1;
	    p2 = &(msg1->next);
	    while(*p2){
		msg2 = *p2;
		check_overlap(msg1, msg2, FALSE, outputs_linkedit_segment);
		p2 = &(msg2->next);
	    }
	    p1 = &(msg1->next);
	}

	/*
	 * If we are doing prebinding add the segments from the dylibs and
	 * then check for overlap with these segments.
	 */
	if(prebinding && dylib_segments != NULL){
	    /* first add on the dylib segments */
	    last_base = last_fvmseg;
	    while(*last_base){
		msg1 = *last_base;
		last_base = &(msg1->next);
	    }
	    *last_base = dylib_segments;
	    /* now check overlap for prebinding */
	    p1 = &merged_segments;
	    while(*p1){
		msg1 = *p1;
		p2 = &(msg1->next);
		while(*p2){
		    msg2 = *p2;
		    check_overlap(msg1, msg2, TRUE, outputs_linkedit_segment);
		    p2 = &(msg2->next);
		}
		p1 = &(msg1->next);
	    }
	    /* take off the dylib segments */
	    *last_base = NULL;
	}

	/* take off the fvmlib segments */
	*last_merged = NULL;

	/* take off the base_obj segments */
	*last_fvmseg = NULL;
}

/*
 * check_overlap() checks if the two segments passed to it overlap and if so
 * prints an error message if prebind_check is FALSE.  If prebind_check is
 * TRUE it prints a warning that prebind is will be disabled.  In either case
 * prebinding is disabled if there is an overlap.
 */
static
void
check_overlap(
struct merged_segment *msg1,
struct merged_segment *msg2,
enum bool prebind_check,
struct merged_segment *outputs_linkedit_segment)
{
    char *not;

	if(msg1->sg.vmsize == 0 || msg2->sg.vmsize == 0)
	    return;

	if(msg1->sg.vmaddr > msg2->sg.vmaddr){
	    if(msg2->sg.vmaddr + msg2->sg.vmsize <= msg1->sg.vmaddr)
		return;
	}
	else{
	    if(msg1->sg.vmaddr + msg1->sg.vmsize <= msg2->sg.vmaddr)
		return;
	}
	if(prebind_check == FALSE)
	    error("%.16s segment (address = 0x%x size = 0x%x) of %s overlaps "
		  "with %.16s segment (address = 0x%x size = 0x%x) of %s",
		  msg1->sg.segname, (unsigned int)(msg1->sg.vmaddr),
		  (unsigned int)(msg1->sg.vmsize), msg1->filename,
		  msg2->sg.segname, (unsigned int)(msg2->sg.vmaddr),
		  (unsigned int)(msg2->sg.vmsize), msg2->filename);
	else{
	    if((segs_read_only_addr_specified &&
		((msg1 == outputs_linkedit_segment &&
			msg2->split_dylib == TRUE)||
	         (msg2 == outputs_linkedit_segment &&
			msg1->split_dylib == TRUE))) ||
		 (msg1->split_dylib == TRUE &&
			strcmp(msg1->sg.segname, SEG_LINKEDIT) == 0) ||
		 (msg2->split_dylib == TRUE &&
			strcmp(msg2->sg.segname, SEG_LINKEDIT) == 0)){
		warning("prebinding not disabled even though (%.16s segment "
			"(address = 0x%x size = 0x%x) of %s overlaps with "
			"%.16s segment (address = 0x%x size = 0x%x) of %s on "
			"the assumption that the stripped output will not "
			"overlap",
			msg1->sg.segname, (unsigned int)(msg1->sg.vmaddr),
			(unsigned int)(msg1->sg.vmsize), msg1->filename,
			msg2->sg.segname, (unsigned int)(msg2->sg.vmaddr),
			(unsigned int)(msg2->sg.vmsize), msg2->filename);
		return;
	    }
	    if(prebind_allow_overlap == TRUE)
		not = " not";
	    else
		not = "";
	    warning("prebinding%s disabled because (%.16s segment (address = "
		    "0x%x size = 0x%x) of %s overlaps with %.16s segment "
		    "(address = 0x%x size = 0x%x) of %s", not,
		    msg1->sg.segname, (unsigned int)(msg1->sg.vmaddr),
		    (unsigned int)(msg1->sg.vmsize), msg1->filename,
		    msg2->sg.segname, (unsigned int)(msg2->sg.vmaddr),
		    (unsigned int)(msg2->sg.vmsize), msg2->filename);
	    if(prebind_allow_overlap == TRUE)
		return;
	    if(ld_trace_prebinding_disabled == TRUE)
	      ld_trace("[Logging for XBS] prebinding disabled "
		       "for %s because (%.16s segment (address = 0x%x size = "
		       "0x%x) of %s overlaps with %.16s segment (address = 0x%x "
		       "size = 0x%x) of %s\n", final_output != NULL ?
		       final_output : outputfile,
		       msg1->sg.segname, (unsigned int)(msg1->sg.vmaddr),
		       (unsigned int)(msg1->sg.vmsize), msg1->filename,
		       msg2->sg.segname, (unsigned int)(msg2->sg.vmaddr),
		       (unsigned int)(msg2->sg.vmsize), msg2->filename);
	}
	prebinding = FALSE;
}

/*
 * check_for_lazy_pointer_relocs_too_far() is call when prebinding is TRUE and
 * checks to see that the lazy pointer's will not be too far away to overflow
 * the the 24-bit r_address field of a scattered relocation entry.  If so
 * then prebinding will be disabled.
 */
static
void
check_for_lazy_pointer_relocs_too_far(
void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;
    unsigned long base_addr;

	if(segs_read_only_addr_specified == TRUE)
	    base_addr = segs_read_write_addr;
	else
	    base_addr = merged_segments->sg.vmaddr;

	p = &merged_segments;
	while(*p && prebinding){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content && prebinding){
		ms = *content;
		if((ms->s.flags & SECTION_TYPE) ==
		   S_LAZY_SYMBOL_POINTERS){
		    if(((ms->s.addr + ms->s.size) - base_addr) & 0xff000000){
			warning("prebinding disabled because output is too "
				"large (limitation of the 24-bit r_address "
				"field of scattered relocation entries)");
			prebinding = FALSE;
		    }
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

/*
 * print_load_map() is called from layout() if a load map is requested.
 */
static
void
print_load_map(void)
{
    unsigned long i;
    struct merged_segment *msg;
    struct merged_section *ms;
    struct common_symbol *common_symbol;

	print("Load map for: %s\n", outputfile);
	print("Segment name     Section name     Address    Size\n");
	for(msg = merged_segments; msg ; msg = msg->next){
	    print("%-16.16s %-16.16s 0x%08x 0x%08x\n",
		   msg->sg.segname, "", (unsigned int)(msg->sg.vmaddr),
		   (unsigned int)(msg->sg.vmsize));
	    for(ms = msg->content_sections; ms ; ms = ms->next){
		print("%-16.16s %-16.16s 0x%08x 0x%08x",
		       ms->s.segname, ms->s.sectname,
		       (unsigned int)(ms->s.addr), (unsigned int)(ms->s.size));
		if(ms->contents_filename)
		    print(" from the file: %s\n", ms->contents_filename);
		else{
		    if(ms->order_load_maps){
			print("\n");
			for(i = 0; i < ms->norder_load_maps; i++){
			    if(dead_strip == FALSE ||
			       ms->order_load_maps[i].load_order->
			       fine_reloc->live == TRUE){
				print("\t\t\t\t  0x%08x 0x%08x ",
				  (unsigned int)(fine_reloc_output_offset(
				    ms->order_load_maps[i].section_map,
				    ms->order_load_maps[i].value -
				    ms->order_load_maps[i].section_map->
					s->addr) +
				    ms->order_load_maps[i].section_map->
					output_section->s.addr),
				    (unsigned int)
					(ms->order_load_maps[i].size));
			    }
			    else{
				print("\t\t\t\t  (dead stripped)       ");
			    }
			    if(ms->order_load_maps[i].archive_name != NULL)
				print("%s:",
					   ms->order_load_maps[i].archive_name);
			    if(ms->order_load_maps[i].symbol_name != NULL)
				print("%s:%s\n",
				      ms->order_load_maps[i].object_name,
				      ms->order_load_maps[i].symbol_name);
			    else
				print("%s\n",
				      ms->order_load_maps[i].object_name);
			}
		    }
		    else{
			print("\n");
			print_load_map_for_objects(ms);
		    }
		}
	    }
	    for(ms = msg->zerofill_sections; ms ; ms = ms->next){
		print("%-16.16s %-16.16s 0x%08x 0x%08x\n",
		       ms->s.segname, ms->s.sectname,
		       (unsigned int)(ms->s.addr), (unsigned int)(ms->s.size));
		if(ms->order_load_maps){
		    for(i = 0; i < ms->norder_load_maps; i++){
			if(dead_strip == FALSE ||
			   ms->order_load_maps[i].load_order->
			   fine_reloc->live == TRUE){
			    print("\t\t\t\t  0x%08x 0x%08x ",
				(unsigned int)(fine_reloc_output_offset(
				    ms->order_load_maps[i].section_map,
				    ms->order_load_maps[i].value -
				    ms->order_load_maps[i].section_map->
					s->addr) +
				    ms->order_load_maps[i].section_map->
					output_section->s.addr),
				    (unsigned int)
					(ms->order_load_maps[i].size));
			}
			else{
			    print("\t\t\t\t  (dead stripped)       ");
			}

/* old
			print("\t\t\t\t  0x%08x 0x%08x ",
			    (unsigned int)(fine_reloc_output_offset(
				ms->order_load_maps[i].section_map,
				ms->order_load_maps[i].value -
				ms->order_load_maps[i].section_map->s->addr) +
				ms->order_load_maps[i].section_map->
							output_section->s.addr),
				(unsigned int)(ms->order_load_maps[i].size));
*/
			if(ms->order_load_maps[i].archive_name != NULL)
			    print("%s:", ms->order_load_maps[i].archive_name);
			print("%s:%s\n",
			      ms->order_load_maps[i].object_name,
			      ms->order_load_maps[i].symbol_name);
		    }
		}
		else{
		    print_load_map_for_objects(ms);
		    if(common_load_map.common_ms == ms){
			common_symbol = common_load_map.common_symbols;
			for(i = 0; i < common_load_map.ncommon_symbols; i++){
			    print("\t\t\t\t  0x%08x 0x%08x symbol: %s\n",
			       (unsigned int)
				(common_symbol->merged_symbol->nlist.n_value),
			       (unsigned int)(common_symbol->common_size),
			       common_symbol->merged_symbol->nlist.n_un.n_name);
			    common_symbol++;
			}
			common_load_map.common_ms = NULL;
			common_load_map.ncommon_symbols = 0;
			free(common_load_map.common_symbols);
		    }
		}
	    }
	    if(msg->next != NULL)
		print("\n");
	}

	if(base_obj){
	    print("\nLoad map for base file: %s\n", base_obj->file_name);
	    print("Segment name     Section name     Address    Size\n");
	    for(msg = base_obj_segments; msg ; msg = msg->next){
		print("%-16.16s %-16.16s 0x%08x 0x%08x\n",
		      msg->sg.segname, "", (unsigned int)(msg->sg.vmaddr),
		      (unsigned int)(msg->sg.vmsize));
	    }
	}

	if(fvmlib_segments != NULL){
	    print("\nLoad map for fixed VM shared libraries\n");
	    print("Segment name     Section name     Address    Size\n");
	    for(msg = fvmlib_segments; msg ; msg = msg->next){
		print("%-16.16s %-16.16s 0x%08x 0x%08x %s\n",
		      msg->sg.segname, "", (unsigned int)(msg->sg.vmaddr),
		      (unsigned int)(msg->sg.vmsize), msg->filename);
	    }
	}
}

/*
 * print_load_map_for_objects() prints the load map for each object that has
 * a non-zero size in the specified merge section.
 */
static
void
print_load_map_for_objects(
struct merged_section *ms)
{
    unsigned long i, j, k;
    struct object_list *object_list, **p;
    struct object_file *object_file;
    struct fine_reloc *fine_relocs;

	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		object_file = &(object_list->object_files[i]);
		if(object_file == base_obj)
		    continue;
		if(object_file->dylib)
		    continue;
		if(object_file->bundle_loader)
		    continue;
		if(object_file->dylinker)
		    continue;
		for(j = 0; j < object_file->nsection_maps; j++){
		    if(object_file->section_maps[j].output_section == ms &&
		       object_file->section_maps[j].s->size != 0){

		        if(object_file->section_maps[j].nfine_relocs != 0){
			    fine_relocs =
				object_file->section_maps[j].fine_relocs;
			    for(k = 0;
				k < object_file->section_maps[j].nfine_relocs;
				k++){
				print("  (input address 0x%08x) ",
				      (unsigned int)
				      (object_file->section_maps[j].s->addr +
					fine_relocs[k].input_offset));
				if((object_file->section_maps[j].s->flags &
				    SECTION_TYPE) == S_SYMBOL_STUBS ||
				   (object_file->section_maps[j].s->flags &
				    SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
				   (object_file->section_maps[j].s->flags &
				    SECTION_TYPE) ==
				    S_NON_LAZY_SYMBOL_POINTERS ||
				   (object_file->section_maps[j].s->flags &
				    SECTION_TYPE) == S_COALESCED){
				    if(fine_relocs[k].use_contents == FALSE)
					print("(eliminated)    ");
				    else if(dead_strip == TRUE &&
				       fine_relocs[k].live == FALSE)
					print("(dead stripped) ");
				    else
					print("     0x%08x ",
					      (unsigned int)(ms->s.addr +
						fine_relocs[k].output_offset));

				}
				else if(dead_strip == TRUE &&
				   fine_relocs[k].live == FALSE)
				    print("(dead stripped) ");
				else
				    print("     0x%08x ",
					  (unsigned int)(ms->s.addr +
					    fine_relocs[k].output_offset));
				print("0x%08x ",
				      (unsigned int)
				      (k == (unsigned int)
					((object_file->section_maps[j].
							    nfine_relocs) -
					(unsigned int)1) ?
				      (unsigned int)
				      (object_file->section_maps[j].s->size) -
					(unsigned int)(fine_relocs[k].
						input_offset) :
				      (unsigned int)(fine_relocs[k + 1].
					input_offset) -
					(unsigned int)(fine_relocs[k].
					input_offset)));
				print_obj_name(object_file);
				print("\n");
			    }
			}
			else{
			    print("\t\t\t\t  0x%08x 0x%08x ",
				   (unsigned int)(ms->s.addr +
				   object_file->section_maps[j].offset),
				   (unsigned int)
					(object_file->section_maps[j].s->size));
			    print_obj_name(object_file);
			    print("\n");
			}
		    }
		}
	    }
	}
}
#endif /* !defined(RLD) */

#ifdef DEBUG
/*
 * print_mach_header() prints the output file's mach header.  For debugging.
 */
__private_extern__
void
print_mach_header(void)
{
	print("Mach header for output file\n");
	print("    magic = 0x%x\n", (unsigned int)(output_mach_header.magic));
	print("    cputype = %d\n", output_mach_header.cputype);
	print("    cpusubtype = %d\n", output_mach_header.cpusubtype);
	print("    filetype = %u\n", output_mach_header.filetype);
	print("    ncmds = %u\n", output_mach_header.ncmds);
	print("    sizeofcmds = %u\n", output_mach_header.sizeofcmds);
	print("    flags = %u\n", output_mach_header.flags);
}

/*
 * print_symtab_info() prints the output file's symtab command.  For
 * debugging.
 */
__private_extern__
void
print_symtab_info(void)
{
	print("Symtab info for output file\n");
	print("    cmd = %u\n", output_symtab_info.symtab_command.cmd);
	print("    cmdsize = %u\n", output_symtab_info.symtab_command.cmdsize);
	print("    nsyms = %u\n", output_symtab_info.symtab_command.nsyms);
	print("    symoff = %u\n", output_symtab_info.symtab_command.symoff);
	print("    strsize = %u\n", output_symtab_info.symtab_command.strsize);
	print("    stroff = %u\n", output_symtab_info.symtab_command.stroff);
}

/*
 * print_thread_info() prints the output file's thread information.  For
 * debugging.
 */
__private_extern__
void
print_thread_info(void)
{
	print("Thread info for output file\n");
	print("    flavor = %lu\n", output_thread_info.flavor);
	print("    count = %lu\n", output_thread_info.count);
	print("    entry_point = 0x%x",
	      (unsigned int)(output_thread_info.entry_point));
	if(output_thread_info.entry_point != NULL)
	    print(" (0x%x)\n", (unsigned int)(*output_thread_info.entry_point));
	else
	    print("\n");
}
#endif /* DEBUG */
                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/layout.h                                 0100644 0001750 0001750 00000011034 12612724205 022523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file layout.c.
 * (and the global varaiable declared in rld.c).
 *
 * The following include file need to be included before this file:
 * #include <sys/loader.h>
 */

/* The output file's mach header */
__private_extern__ struct mach_header output_mach_header;

/*
 * The output file's symbol table load command and the offsets used in the
 * second pass to output the symbol table and string table.
 */
struct symtab_info {
    struct symtab_command symtab_command;
    unsigned long
      output_strpad,	     /* the number of padded bytes at the end */
      output_merged_strsize, /* the current merged string table size in pass2 */
      output_local_strsize;  /* the current local string table size in pass2 */
};
__private_extern__ struct symtab_info output_symtab_info;

/*
 * The output file's dynamic symbol table load command.
 */
struct dysymtab_info {
    struct dysymtab_command dysymtab_command;
};
__private_extern__ struct dysymtab_info output_dysymtab_info;

/*
 * The output file's two level hints load command.
 */
struct hints_info {
    struct twolevel_hints_command twolevel_hints_command;
};
__private_extern__ struct hints_info output_hints_info;

/*
 * The output file's prebind_cksum load command.
 */
struct cksum_info {
    struct prebind_cksum_command prebind_cksum_command;
};
__private_extern__ struct cksum_info output_cksum_info;

/*
 * The output file's uuid load command.
 */
struct uuid_info {
    enum bool suppress;	/* suppress when -no_uuid is specified */
    enum bool emit;	/* TRUE if any input file has a debug section or
			   an LC_UUID load command */
    struct uuid_command uuid_command;
};
__private_extern__ struct uuid_info output_uuid_info;

/*
 * The output file's thread load command and the machine specific information
 * for it.
 */
struct thread_info {
    struct thread_command thread_command;
    enum bool thread_in_output;	/* TRUE if the output file has a thread cmd */
    unsigned long flavor;	/* the flavor for the registers with the pc */
    unsigned long count;	/* the count (sizeof(long)) of the state */
    int *entry_point;		/* pointer to the entry point in the state */
    int *stack_pointer;		/* pointer to the stack pointer in the state */
    void *state;		/* a pointer to a thread state */
    unsigned long second_flavor;/* the flavor for the registers with the sp */
    unsigned long second_count;	/* the count (sizeof(long)) of second_state */
    void *second_state;		/* a pointer to the second thread state */
};
__private_extern__ struct thread_info output_thread_info;

/*
 * The output file's routines load command and the information for it.
 */
struct routines_info {
    struct routines_command routines_command;
    enum bool routines_in_output;/* TRUE if the output file has a routines cmd*/
};
__private_extern__ struct routines_info output_routines_info;

__private_extern__ void layout(
    void);
#if defined(RLD) && !defined(SA_RLD)
__private_extern__ void layout_rld_symfile(
    void);
#endif /* defined(RLD) && !defined(SA_RLD) */

#ifdef RLD
/*
 * The user's address function to be called in layout to get the address of
 * where to link edit the result.
 */
__private_extern__ unsigned long (
    *address_func)(
	unsigned long size,
	unsigned long header_address);
#endif /* RLD */

#ifdef DEBUG
__private_extern__ void print_mach_header(
    void);
__private_extern__ void print_symtab_info(
    void);
__private_extern__ void print_thread_info(
    void);
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/ld.c                                     0100644 0001750 0001750 00000342521 12612724205 021610  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * The Apple, Inc. Mach-O (Mach object file format) link-editor.  This file
 * contains the main() routine and the global error handling routines and other
 * miscellaneous small global routines.  It also defines the global varaibles
 * that are set or changed by command line arguments.
 */
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include "stuff/arch.h"
#include "stuff/version_number.h"
#include "stuff/guess_short_name.h"
#include "stuff/macosx_deployment_target.h"
#include "stuff/execute.h"
#if !(defined(KLD))
#include <stdio.h>
#endif
#if !(defined(KLD) && defined(__STATIC__))
#include <signal.h>
#include <errno.h>
#include <libc.h>
#include <ar.h>
#include <mach/mach.h>
#include <mach/mach_error.h>
#include "stuff/seg_addr_table.h"
#ifndef RLD
#include "stuff/symbol_list.h"
#endif
#include <mach/mach_init.h>
#if defined(__OPENSTEP__) || defined(__GONZO_BUNSEN_BEAKER__)
#include <servers/netname.h>
#else
#include <servers/bootstrap.h>
#endif
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/mach.h>
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */

#include "ld.h"
#ifndef RLD
static char *mkstr(
	const char *args,
	...);
#endif /* !defined(RLD) */
#include "specs.h"
#include "pass1.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "fvmlibs.h"
#include "symbols.h"
#include "layout.h"
#include "pass2.h"

/* name of this program as executed (argv[0]) */
__private_extern__ char *progname = NULL;
/* indication of an error set in error(), for processing a number of errors
   and then exiting */
__private_extern__ unsigned long errors = 0;
/* the pagesize of the machine this program is running on, getpagesize() value*/
__private_extern__ unsigned long host_pagesize = 0;
/* the byte sex of the machine this program is running on */
__private_extern__ enum byte_sex host_byte_sex = UNKNOWN_BYTE_SEX;

/* name of output file */
__private_extern__ char *outputfile = NULL;
/* type of output file */
__private_extern__ unsigned long filetype = MH_EXECUTE;
/* multi or single module dylib output */
__private_extern__ enum bool multi_module_dylib = TRUE;
#ifndef RLD
static enum bool filetype_specified = FALSE;
static enum bool moduletype_specified = FALSE;
/* if the -A flag is specified use to set the object file type */
static enum bool Aflag_specified = FALSE;
#endif /* !defined(RLD) */
/*
 * The architecture of the output file as specified by -arch and the cputype
 * and cpusubtype of the object files being loaded which will be the output
 * cputype and cpusubtype.  specific_arch_flag is true if an -arch flag is
 * specified and the flag for a specific implementation of an architecture.
 */
__private_extern__ struct arch_flag arch_flag =
#if defined(KLD) && defined(__STATIC__)

#ifdef __ppc__
    { "ppc",    CPU_TYPE_POWERPC, CPU_SUBTYPE_POWERPC_ALL };
#elif __i386__
    { "i386",   CPU_TYPE_I386,    CPU_SUBTYPE_I386_ALL };
#elif __arm__
    { "arm",	CPU_TYPE_ARM,     CPU_SUBTYPE_ARM_ALL };
#else
#error "unsupported architecture for static KLD"
#endif

#else /* !(defined(KLD) && defined(__STATIC__)) */
    { 0 };
#endif /* defined(KLD) && defined(__STATIC__) */
__private_extern__ enum bool specific_arch_flag = FALSE;

/*
 * The -force_cpusubtype_ALL flag.
 */
__private_extern__ enum bool force_cpusubtype_ALL = FALSE;

/* the byte sex of the output file */
__private_extern__ enum byte_sex target_byte_sex = UNKNOWN_BYTE_SEX;
static enum bool arch_multiple = FALSE;	/* print one arch message before error*/

__private_extern__
enum bool trace = FALSE;		/* print stages of link-editing */
__private_extern__
enum bool save_reloc = FALSE;		/* save relocation information */
__private_extern__
enum bool output_for_dyld = FALSE;	/* produce output for use with dyld */
__private_extern__
enum bool bind_at_load = FALSE;		/* mark the output for dyld to be bound
					   when loaded */
__private_extern__
enum bool no_fix_prebinding = FALSE;	/* mark the output for dyld to never
					   run fix_prebinding */
__private_extern__
enum bool load_map = FALSE;		/* print a load map */
__private_extern__
enum bool define_comldsyms = TRUE;	/* define common and link-editor defined
					   symbol reguardless of file type */
#ifndef RLD
static enum bool
    dflag_specified = FALSE;		/* the -d flag has been specified */
#endif /* !defined(RLD) */
__private_extern__
enum bool seglinkedit = FALSE;		/* create the link edit segment */
#ifndef RLD
static enum bool
    seglinkedit_specified = FALSE;	/* if either -seglinkedit or */
					/*  -noseglinkedit was specified */
#endif /* !defined(RLD) */
__private_extern__
enum bool whyload = FALSE;		/* print why archive members are
					   loaded */
#ifndef RLD
static enum bool whatsloaded = FALSE;	/* print which object files are loaded*/
#endif /* !defined(RLD) */
__private_extern__
enum bool flush = TRUE;			/* Use the output_flush routine to flush
					   output file by pages */
__private_extern__
enum bool sectorder_detail = FALSE;	/* print sectorder warnings in detail */
__private_extern__
enum bool nowarnings = FALSE;		/* suppress warnings */
__private_extern__
enum bool no_arch_warnings = FALSE;	/* suppress wrong arch warnings */
__private_extern__
enum bool arch_errors_fatal = FALSE;	/* cause wrong arch errors to be fatal*/
__private_extern__
enum bool archive_ObjC = FALSE;		/* objective-C archive semantics */
__private_extern__
enum bool archive_all = FALSE;		/* always load everything in archives */
__private_extern__
enum bool keep_private_externs = FALSE;	/* don't turn private externs into
					   non-external symbols */
/* TRUE if -dynamic is specified, FALSE if -static is specified */
__private_extern__
enum bool dynamic = TRUE;
#ifndef RLD
static enum bool dynamic_specified = FALSE;
static enum bool static_specified = FALSE;
#endif

/* The level of symbol table stripping */
__private_extern__ enum strip_levels strip_level = STRIP_DUP_INCLS;
/* Strip the base file symbols (the -A argument's symbols) */
__private_extern__ enum bool strip_base_symbols = FALSE;

/* strip dead blocks */
__private_extern__ enum bool dead_strip = FALSE;
/* don't strip module init and term sections */
__private_extern__ enum bool no_dead_strip_inits_and_terms = FALSE;
/* print timings for dead striping code */
__private_extern__ enum bool dead_strip_times = FALSE;

#ifndef RLD
/*
 * Data structures to perform selective exporting of global symbols.
 * save_symbols is the names of the symbols from -exported_symbols_list
 * remove_symbols is the names of the symbols from -unexported_symbols_list
 */
__private_extern__ struct symbol_list *save_symbols = NULL;
__private_extern__ uint32_t nsave_symbols = 0;
__private_extern__ struct symbol_list *remove_symbols = NULL;
__private_extern__ uint32_t nremove_symbols = 0;

/*
 * -executable_path option's argument, executable_path is used to replace
 * @executable_path for dependent libraries.
 */
__private_extern__ char *executable_path = NULL;
#endif /* RLD */


/* The list of symbols to be traced */
__private_extern__ char **trace_syms = NULL;
__private_extern__ unsigned long ntrace_syms = 0;

/* The number of references of undefined symbols to print */
__private_extern__ unsigned long Yflag = 0;

/* The list of allowed undefined symbols */
__private_extern__ char **undef_syms = NULL;
__private_extern__ unsigned long nundef_syms = 0;

/* The list of -dylib_file arguments */
__private_extern__ char **dylib_files = NULL;
__private_extern__ unsigned long ndylib_files = 0;

/* The checking for undefined symbols */
__private_extern__ enum undefined_check_level undefined_flag = UNDEFINED_ERROR;
#ifndef RLD
static enum bool undefined_flag_specified = FALSE;
#endif

/* The checking for (twolevel namespace) multiply defined symbols */
__private_extern__ enum multiply_defined_check_level
    multiply_defined_flag = MULTIPLY_DEFINED_WARNING;
__private_extern__ enum multiply_defined_check_level
    multiply_defined_unused_flag = MULTIPLY_DEFINED_SUPPRESS;
/* the -nomultidefs option */
__private_extern__ enum bool nomultidefs = FALSE;
#ifndef RLD
static enum bool multiply_defined_flag_specified = FALSE;
static enum bool multiply_defined_unused_flag_specified = FALSE;
#endif

/* The checking for read only relocs */
__private_extern__ enum read_only_reloc_check_level
    read_only_reloc_flag = READ_ONLY_RELOC_ERROR;

/* The checking for section difference relocs */
__private_extern__ enum sect_diff_reloc_check_level
    sect_diff_reloc_flag = SECT_DIFF_RELOC_SUPPRESS;

/* The handling for weak reference mismatches */
__private_extern__ enum weak_reference_mismatches_handling
    weak_reference_mismatches = WEAK_REFS_MISMATCH_ERROR;

/* The Mac OS X deployment target */
__private_extern__ struct macosx_deployment_target
	macosx_deployment_target = { 0 };

/* The prebinding optimization */
#ifndef RLD
static enum bool prebinding_flag_specified = FALSE;
#endif
__private_extern__ enum bool prebinding = FALSE;
__private_extern__ enum bool prebind_allow_overlap = FALSE;
__private_extern__ enum bool prebind_all_twolevel_modules = FALSE;
#ifndef RLD
static enum bool read_only_reloc_flag_specified = FALSE;
static enum bool sect_diff_reloc_flag_specified = FALSE;
static enum bool weak_reference_mismatches_specified = FALSE;
static enum bool prebind_all_twolevel_modules_specified = FALSE;
static enum bool unprebound_library(
    char *dylib_install_name,
    char *seg_addr_table_filename);
#endif

/* True if -m is specified to allow multiply symbols, as a warning */
__private_extern__ enum bool allow_multiply_defined_symbols = FALSE;

/* The segment alignment and pagezero_size, note the segalign is reset in
 * layout() by get_segalign_from_flag() based on the target architecture.
 */
__private_extern__ unsigned long segalign = 0x2000;
#ifndef RLD
__private_extern__ enum bool segalign_specified = FALSE;
#endif /* !defined(RLD) */
__private_extern__ unsigned long pagezero_size = 0;

/* The default section alignment */
__private_extern__ unsigned long defaultsectalign = DEFAULTSECTALIGN;

/* The first segment address */
__private_extern__ unsigned long seg1addr = 0;
__private_extern__ enum bool seg1addr_specified = FALSE;

/* read-only and read-write segment addresses */
__private_extern__ unsigned long segs_read_only_addr = 0;
__private_extern__ enum bool segs_read_only_addr_specified = FALSE;
__private_extern__ unsigned long segs_read_write_addr = 0;
__private_extern__ enum bool segs_read_write_addr_specified = FALSE;

#ifndef RLD
/* file name of the segment address table */
static char *seg_addr_table_name = NULL;
/* the file system path name to use instead of the install name */
static char *seg_addr_table_filename = NULL;
#endif /* !defined(RLD) */

/* The stack address and size */
__private_extern__ unsigned long stack_addr = 0;
__private_extern__ enum bool stack_addr_specified = FALSE;
__private_extern__ unsigned long stack_size = 0;
__private_extern__ enum bool stack_size_specified = FALSE;

/* TRUE if -allow_stack_execute is specified */
__private_extern__ enum bool allow_stack_execute = FALSE;

#ifndef RLD
/* A -segaddr option was specified */
static enum bool segaddr_specified = FALSE;
#endif /* !defined(RLD) */

/*
 * The header pad, the default is set to the size of a section strcuture so
 * that if /bin/objcunique is run on the result and up to two sections can be
 * added.
 */
__private_extern__ unsigned long headerpad = sizeof(struct section) * 2;
#ifndef RLD
static enum bool headerpad_specified = FALSE;
#endif /* !defined(RLD) */
/*
 * If specified makes sure the header pad is big enough to change all the
 * install name of the dylibs in the output to MAXPATHLEN.
 */
__private_extern__ enum bool headerpad_max_install_names = FALSE;

/* The name of the specified entry point */
__private_extern__ char *entry_point_name = NULL;

/* The name of the specified library initialization routine */
__private_extern__ char *init_name = NULL;

/* The dylib information */
__private_extern__ char *dylib_install_name = NULL;
__private_extern__ uint32_t dylib_current_version = 0;
__private_extern__ uint32_t dylib_compatibility_version = 0;

/* the umbrella/sub/client framework information */
__private_extern__ enum bool sub_framework = FALSE;
__private_extern__ enum bool umbrella_framework = FALSE;
__private_extern__ char *sub_framework_name = NULL;
__private_extern__ char *umbrella_framework_name = NULL;
__private_extern__ char *client_name = NULL;
__private_extern__ char **allowable_clients = NULL;
__private_extern__ unsigned long nallowable_clients = 0;

/* The list of sub_umbrella frameworks */
__private_extern__ char **sub_umbrellas = NULL;
__private_extern__ unsigned long nsub_umbrellas = 0;

/* The list of sub_library dynamic libraries */
__private_extern__ char **sub_librarys = NULL;
__private_extern__ unsigned long nsub_librarys = 0;

/* The dylinker information */
__private_extern__ char *dylinker_install_name = NULL;

#ifndef RLD
/* set to the -bundle_loader argument if specified */
static char *bundle_loader = NULL;
#endif

/* set to TRUE if -private_bundle is specified */
__private_extern__ enum bool private_bundle = FALSE;

/* The value of the environment variable NEXT_ROOT or the -syslibroot argument*/
__private_extern__ char *next_root = NULL;
#ifndef RLD
static enum bool syslibroot_specified = FALSE;
#endif

/* TRUE if the environment variable LD_TRACE_ARCHIVES
   (or temporarily RC_TRACE_ARCHIVES) is set */
__private_extern__ enum bool ld_trace_archives = FALSE;

/* TRUE if the environment variable LD_TRACE_DYLIBS
   (or temporarily RC_TRACE_DYLIBS) is set */
__private_extern__ enum bool ld_trace_dylibs = FALSE;

/* TRUE if the environment variable LD_TRACE_PREBINDING_DISABLED
   (or temporarily LD_TRACE_PREBINDING_DISABLED) is set */
__private_extern__ enum bool ld_trace_prebinding_disabled = FALSE;

#ifndef KLD
/* The file LD_TRACE_FILE references, or NULL if none is set */
static const char *trace_file_path = NULL;
#endif

/* the argument to -final_output if any */
__private_extern__ char *final_output = NULL;

/* The variables to support namespace options */
__private_extern__ enum bool namespace_specified = FALSE;
__private_extern__ enum bool twolevel_namespace = TRUE;
__private_extern__ enum bool force_flat_namespace = FALSE;

#ifndef RLD
/* Variable to support options logging.  */
static enum bool ld_print_options = FALSE;
#endif

/*
 * Because the MacOS X 10.0 code in libSystem for the NSObjectFileImage*() APIs
 * does not ignore unknown load commands if MH_BUNDLE files are built with
 * two-level namespace hints the LC_TWOLEVEL_HINTS load command will produce a
 * "malformed object" errors.  So to make the MacOS X 10.1 ld(1) produce
 * MH_BUNDLE files that will work on MacOS X 10.0 the hints table is not
 * produced by default for MH_BUNDLE files.
 */
#ifndef RLD
static enum bool twolevel_namespace_hints_specified = FALSE;
#endif
__private_extern__ enum bool twolevel_namespace_hints = TRUE;

#ifdef DEBUG
__private_extern__ unsigned long debug = 0;	/* link-editor debugging */
#endif /* DEBUG */

#ifdef RLD
/* the cleanup routine for fatal errors to remove the output file */
__private_extern__ void cleanup(void);
#else /* !defined(RLD) */
static void cleanup(void);
static void ld_exit(int exit_value);

/* The signal hander routine for SIGINT, SIGTERM, SIGBUS & SIGSEGV */
static void handler(int sig);

/* Static routines to help parse arguments */
static enum bool ispoweroftwo(unsigned long x);
static vm_prot_t getprot(char *prot, char **endp);
static enum bool check_max_init_prot(vm_prot_t maxprot, vm_prot_t initprot);

/* apple_version is created by the libstuff/Makefile */
extern char apple_version[];

/*
 * main() parses the command line arguments and drives the link-edit process.
 */
int
main(
int argc,
char *argv[],
char *envp[])
{
    int i;
    unsigned long j, symbols_created, objects_specified, sections_created;
    uint32_t table_size;
    int fd;
    char *p, *symbol_name, *indr_symbol_name, *endp, *file_name;
    char *filelist, *dirname, *addr, *env_seg_addr_table_name;
    struct seg_addr_table *seg_addr_table, *seg_addr_table_entry;
    struct segment_spec *seg_spec;
    struct section_spec *sect_spec;
    unsigned long align, tmp;
    struct stat stat_buf;
    kern_return_t r;
    const struct arch_flag *family_arch_flag;
    enum undefined_check_level new_undefined_flag;
    enum multiply_defined_check_level new_multiply_defined_flag,
	new_multiply_defined_unused_flag;
    enum read_only_reloc_check_level new_read_only_reloc_flag;
    enum sect_diff_reloc_check_level new_sect_diff_reloc_flag;
    enum weak_reference_mismatches_handling new_weak_reference_mismatches;
    enum bool is_framework;
    char *has_suffix;
    struct symbol_list *sp;
    char *exported_symbols_list, *unexported_symbols_list;
    enum bool missing_syms;
    enum bool vflag;
    enum bool prebinding_via_LD_PREBIND;
    enum bool hash_instrument_specified;
    char *ld_library_path;

#ifdef __MWERKS__
    char **dummy;
        dummy = envp;
#endif

	vflag = FALSE;
	exported_symbols_list = NULL;
	unexported_symbols_list = NULL;
	seg_addr_table_entry = NULL;
	hash_instrument_specified = FALSE;

	progname = argv[0];
#ifndef BINARY_COMPARE
	host_pagesize = 0x2000;
#else
	host_pagesize = getpagesize();
#endif
	host_byte_sex = get_host_byte_sex();

	if(argc == 1)
	    fatal("Usage: %s [options] file [...]", progname);

	/*
	 * If interrupt and termination signal are not being ignored catch
	 * them so things can be cleaned up.
	 */
	if(signal(SIGINT, SIG_IGN) != SIG_IGN)
	    signal(SIGINT, handler);
	if(signal(SIGTERM, SIG_IGN) != SIG_IGN)
	    signal(SIGTERM, handler);
	if(signal(SIGBUS, SIG_IGN) != SIG_IGN)
	    signal(SIGBUS, handler);
	if(signal(SIGSEGV, SIG_IGN) != SIG_IGN)
	    signal(SIGSEGV, handler);

	/* This needs to be here so that we test the environment variable before
	   the rest of options parsing.  */
	if (getenv("LD_PRINT_OPTIONS") != NULL)
	  ld_print_options = TRUE;

	/*
	 * Parse the command line options in this pass and skip the object files
	 * and symbol creation flags in this pass.  This will make sure optionsd
	 * like -Ldir are not position dependent relative to -lx options (the
	 * same for -ysymbol relative to object files, etc).
	 */
	for(i = 1 ; i < argc ; i++){
	    if(*argv[i] != '-'){
		/* object file argv[i] processed in the next pass of
		   parsing arguments */
		continue;
	    }
	    else{
	        if (ld_print_options == TRUE)
		  print("[Logging ld options]\t%s\n", argv[i]);

	        p = &(argv[i][1]);
		switch(*p){
		case 'l':
		    if(p[1] == '\0')
			fatal("-l: argument missing");
		    /* path searched abbrevated file name, processed in the
		       next pass of parsing arguments */
		    break;

		/* Flags effecting search path of -lx arguments */
		case 'L':
		    if(p[1] == '\0')
			fatal("-L: directory name missing");
		    /* add a pathname to the list of search paths */
		    search_dirs = reallocate(search_dirs,
					   (nsearch_dirs + 1) * sizeof(char *));
		    search_dirs[nsearch_dirs++] = &(p[1]);
		    if(stat(&(p[1]), &stat_buf) == -1)
			warning("-L: directory name (%s) does not exist",
				&(p[1]));
		    break;
		case 'Z':
		    if(p[1] != '\0')
			goto unknown_flag;
		    /* do not use the standard search path */
		    standard_dirs[0] = NULL;
		    standard_framework_dirs[0] = NULL;
		    break;

		/* File format flags */
		case 'M':
		    if(strcmp(p, "Mach") == 0){
			if(filetype_specified == TRUE && filetype != MH_EXECUTE)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_EXECUTE;
		    }
		    else if(strcmp(p, "M") == 0){
			/* produce load map */
			load_map = TRUE;
		    }
		    else
			goto unknown_flag;
		    break;
		case 'p':
		    if(strcmp(p, "preload") == 0 || p[1] == '\0'){
			if(filetype_specified == TRUE && filetype != MH_PRELOAD)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_PRELOAD;
		    }
		    else if(strcmp(p, "pagezero_size") == 0){
			if(i + 1 >= argc)
			    fatal("-pagezero_size: argument missing");
			if(pagezero_size != 0)
			    fatal("-pagezero_size: multiply specified");
			pagezero_size = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("size for -pagezero_size %s not a proper "
				  "hexadecimal number", argv[i+1]);
			if(pagezero_size == 0)
			    fatal("size for -pagezero_size %s must not be zero",
				  argv[i+1]);
			i += 1;
		    }
		    else if(strcmp(p, "prebind") == 0){
			if(prebinding_flag_specified == TRUE &&
			   prebinding == FALSE)
			    fatal("both -prebind and -noprebind can't "
				  "be specified");
			prebinding_flag_specified = TRUE;
			prebinding = TRUE;
		    }
		    else if(strcmp(p, "prebind_allow_overlap") == 0){
			prebind_allow_overlap = TRUE;
		    }
		    else if(strcmp(p, "prebind_all_twolevel_modules") == 0){
			if(prebind_all_twolevel_modules_specified == TRUE &&
			   prebind_all_twolevel_modules == FALSE)
			    fatal("both -prebind_all_twolevel_modules and "
				  "-noprebind_all_twolevel_modules can't be "
				  "specified");
			prebind_all_twolevel_modules = TRUE;
			prebind_all_twolevel_modules_specified = TRUE;
		    }
		    else if(strcmp(p, "private_bundle") == 0){
			private_bundle = TRUE;
		    }
		    else
			goto unknown_flag;
		    break;
		case 'f':
		    if(p[1] == '\0')
			fatal("use of old flag -f (old version of mkshlib(1) "
			      "will not work with this version of ld(1))");
		    else if(strcmp(p, "fvmlib") == 0){
			if(filetype_specified == TRUE && filetype != MH_FVMLIB)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_FVMLIB;
		    }
		    else if(strcmp(p, "force_cpusubtype_ALL") == 0){
			force_cpusubtype_ALL = TRUE;
		    }
		    else if(strcmp(p, "framework") == 0){
			if(i + 1 >= argc)
			    fatal("-framework: argument missing");
			/* path searched abbrevated framework name, processed
			   in the next pass of parsing arguments */
			i += 1;
		    }
		    else if(strcmp(p, "filelist") == 0){
			if(i + 1 >= argc)
			    fatal("-filelist: argument missing");
			/* filelist of object names, processed
			   in the next pass of parsing arguments */
			i += 1;
		    }
		    else if(strcmp(p, "flat_namespace") == 0){
			if(namespace_specified == TRUE &&
			   twolevel_namespace == TRUE)
			    fatal("can't specify both -flat_namespace and "
				  "-twolevel_namespace");
			namespace_specified = TRUE;
			twolevel_namespace = FALSE;
		    }
		    else if(strcmp(p, "force_flat_namespace") == 0){
			if(namespace_specified == TRUE &&
			   twolevel_namespace == TRUE)
			    fatal("can't specify both -force_flat_namespace "
				  "and -twolevel_namespace");
			force_flat_namespace = TRUE;
		        twolevel_namespace = FALSE;
		    }
		    else if(strcmp(p, "final_output") == 0){
			if(i + 1 >= argc)
			    fatal("-final_output: argument missing");
			if(final_output != NULL)
			    fatal("-final_output multiply specified");
			final_output = argv[i+1];
			i += 1;
		    }
		    else
			goto unknown_flag;
		    break;

		case 'F':
		    if(p[1] == '\0')
			fatal("-F: directory name missing");
		    /* add a pathname to the list of framework search paths */
		    framework_dirs = reallocate(framework_dirs,
				       (nframework_dirs + 1) * sizeof(char *));
		    framework_dirs[nframework_dirs++] = &(p[1]);
		    if(stat(&(p[1]), &stat_buf) == -1)
			warning("-F: directory name (%s) does not exist",
				&(p[1]));
		    break;

		case 'r':
		    if(strcmp(p, "read_only_relocs") == 0){
			if(++i >= argc)
			    fatal("-read_only_relocs: argument missing");
			if(strcmp(argv[i], "error") == 0)
			    new_read_only_reloc_flag = READ_ONLY_RELOC_ERROR;
			else if(strcmp(argv[i], "warning") == 0)
			    new_read_only_reloc_flag = READ_ONLY_RELOC_WARNING;
			else if(strcmp(argv[i], "suppress") == 0)
			    new_read_only_reloc_flag = READ_ONLY_RELOC_SUPPRESS;
			else{
			    fatal("-read_only_relocs: unknown argument: %s",
				  argv[i]);
			    new_read_only_reloc_flag = READ_ONLY_RELOC_ERROR;
			}
			if(read_only_reloc_flag_specified == TRUE &&
			   new_read_only_reloc_flag != read_only_reloc_flag)
			    fatal("more than one value specified for "
				  "-read_only_relocs");
			read_only_reloc_flag_specified = TRUE;
			read_only_reloc_flag = new_read_only_reloc_flag;
			break;
		    }
		    else if(strcmp(p, "run_init_lazily") == 0){
			warning("-run_init_lazily is obsolete");
			break;
		    }
		    if(p[1] != '\0')
			goto unknown_flag;
		    /* save relocation information, and produce a relocatable
		       object */
		    save_reloc = TRUE;
		    if(filetype_specified == FALSE)
			filetype = MH_OBJECT;
		    if(dflag_specified == FALSE)
			define_comldsyms = FALSE;
		    break;
		case 'A':
		    if(p[1] != '\0')
			goto unknown_flag;
		    if(++i >= argc)
			fatal("-A: argument missing");
		    /* object file argv[i] processed in the next pass of
		       parsing arguments */
		    Aflag_specified = TRUE;
		    break;
		case 'd':
		    if(strcmp(p, "d") == 0){
			/* define common symbols and loader defined symbols
			   reguardless of file format */
			dflag_specified = TRUE;
			define_comldsyms = TRUE;
		    }
		    else if(strcmp(p, "dynamic") == 0){
			if(static_specified)
			    fatal("only one of -dynamic or -static can be "
				  "specified");

			dynamic = TRUE;
			dynamic_specified = TRUE;
		    }
		    else if(strcmp(p, "dylib") == 0){
			if(filetype_specified == TRUE && filetype != MH_DYLIB)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_DYLIB;
			output_for_dyld = TRUE;
		    }
		    else if(strcmp(p, "dylib_install_name") == 0){
			if(i + 1 >= argc)
			    fatal("-dylib_install_name: argument missing");
			dylib_install_name = argv[i + 1];
			i += 1;
		    }
  		    else if(strcmp(p, "dylib_current_version") == 0){
			if(i + 1 >= argc)
			    fatal("-dylib_current_version: argument missing");
			if(get_version_number("-dylib_current_version",
			    argv[i+1], &dylib_current_version) == FALSE)
			    cleanup();
			if(dylib_current_version == 0)
			    fatal("-dylib_current_version must be greater than "
				  "zero");
			i += 1;
		    }
		    else if(strcmp(p, "dylib_compatibility_version") == 0){
			if(i + 1 >= argc)
			    fatal("-dylib_compatibility_version: argument "
				  "missing");
			if(get_version_number("-dylib_compatibility_version",
			    argv[i+1], &dylib_compatibility_version) == FALSE)
			    cleanup();
			if(dylib_compatibility_version == 0)
			    fatal("-dylib_compatibility_version must be "
				  "greater than zero");
			i += 1;
		    }
		    else if(strcmp(p, "dylib_file") == 0){
			if(++i >= argc)
			    fatal("-dylib_file: argument missing");
			file_name = strchr(argv[i], ':');
			if(file_name == NULL ||
			   file_name[1] == '\0' || argv[i][0] == ':')
			    fatal("-dylib_file argument: %s must have a ':' "
				  "between its file names", argv[i]);
			dylib_files = reallocate(dylib_files,
					(ndylib_files + 1) * sizeof(char *));
			dylib_files[ndylib_files++] = argv[i];
		    }
		    else if(strcmp(p, "dylinker") == 0){
			if(filetype_specified == TRUE &&
			   filetype != MH_DYLINKER)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_DYLINKER;
			output_for_dyld = TRUE;
		    }
		    else if(strcmp(p, "dylinker_install_name") == 0){
			if(i + 1 >= argc)
			    fatal("-dylinker_install_name: argument missing");
			if(dylinker_install_name != NULL)
			    fatal("-dylinker_install_name multiply specified");
			dylinker_install_name = argv[i + 1];
			i += 1;
		    }
		    else if(strcmp(p, "dead_strip") == 0){
			dead_strip = TRUE;
		    }
		    else if(strcmp(p, "dead_strip_times") == 0){
			dead_strip_times = TRUE;
		    }
#ifdef DEBUG
		    else if(strcmp(p, "debug") == 0){
			if(++i >= argc)
			    fatal("-debug: argument missing");
			debug |= 1 << strtoul(argv[i], &endp, 10);
			if(*endp != '\0' || strtoul(argv[i], &endp, 10) > 32)
			    fatal("argument for -debug %s not a proper "
				  "decimal number less than 32", argv[i]);
		    }
#endif /* DEBUG */
		    else
			goto unknown_flag;
		    break;

		case 'n':
		    if(strcmp(p, "noflush") == 0){
			flush = FALSE;
		    }
		    else if(strcmp(p, "nofixprebinding") == 0){
			no_fix_prebinding = TRUE;
		    }
		    else if(strcmp(p, "no_arch_warnings") == 0){
			no_arch_warnings = TRUE;
		    }
		    else if(strcmp(p, "noseglinkedit") == 0){
			if(seglinkedit_specified && seglinkedit == TRUE)
			    fatal("both -seglinkedit and -noseglinkedit can't "
				  "be specified");
			seglinkedit = FALSE;
			seglinkedit_specified = TRUE;
		    }
		    else if(strcmp(p, "noprebind") == 0){
			if(prebinding_flag_specified == TRUE &&
			   prebinding == TRUE)
			    fatal("both -prebind and -noprebind can't "
				  "be specified");
			prebinding_flag_specified = TRUE;
			prebinding = FALSE;
		    }
		    else if(strcmp(p, "nomultidefs") == 0){
			nomultidefs = TRUE;
		    }
		    else if(strcmp(p, "noprebind_all_twolevel_modules") == 0){
			if(prebind_all_twolevel_modules_specified == TRUE &&
			   prebind_all_twolevel_modules == TRUE)
			    fatal("both -prebind_all_twolevel_modules and "
				  "-noprebind_all_twolevel_modules can't be "
				  "specified");
			prebind_all_twolevel_modules = FALSE;
			prebind_all_twolevel_modules_specified = TRUE;
		    }
		    else if(strcmp(p, "no_dead_strip_inits_and_terms") == 0){
			no_dead_strip_inits_and_terms = TRUE;
		    }
		    else if(strcmp(p, "no_uuid") == 0){
			 output_uuid_info.suppress = TRUE;
		    }
		    else if(strcmp(p, "noall_load") == 0){
		      /* Ignore the flag.  */
		      ;
		    }
		    else
			goto unknown_flag;
		    break;

		case 'b':
		    if(strcmp(p, "bundle") == 0){
			if(filetype_specified == TRUE && filetype != MH_BUNDLE)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_BUNDLE;
			output_for_dyld = TRUE;
		    }
		    else if(strcmp(p, "bind_at_load") == 0){
			bind_at_load = TRUE;
		    }
		    else if(strcmp(p, "bundle_loader") == 0){
			if(i + 1 >= argc)
			    fatal("-bundle_loader: argument missing");
			if(bundle_loader != NULL)
			    fatal("-bundle_loader multiply specified");
			bundle_loader = argv[i + 1];
			i += 1;
		    }
		    /* Strip the base file symbols (the -A argument's symbols)*/
		    else if(p[1] == '\0')
			strip_base_symbols = TRUE;
		    else
			goto unknown_flag;
		    break;

		/*
		 * Stripping level flags, in increasing level of stripping.  The
		 * level of stripping is set to the maximum level specified.
		 */
		case 'X':
		    if(p[1] != '\0')
			goto unknown_flag;
		    if(strip_level < STRIP_L_SYMBOLS)
			strip_level = STRIP_L_SYMBOLS;
		    break;
		case 'S':
		    if(strcmp(p, "Sn") == 0){
			strip_level = STRIP_NONE;
		    }
		    else if(strcmp(p, "Si") == 0){
			if(strip_level < STRIP_DUP_INCLS)
			    strip_level = STRIP_DUP_INCLS;
		    }
		    else if(strcmp(p, "Sp") == 0){
			if(strip_level < STRIP_MIN_DEBUG)
			    strip_level = STRIP_MIN_DEBUG;
		    }
		    else if(p[1] == '\0'){
			if(strip_level < STRIP_DEBUG)
			    strip_level = STRIP_DEBUG;
		    }
		    else{
			goto unknown_flag;
		    }
		    break;
		case 'x':
		    if(p[1] != '\0')
			goto unknown_flag;
		    if(strip_level < STRIP_NONGLOBALS)
			strip_level = STRIP_NONGLOBALS;
		    break;
		case 's':
		    if(strcmp(p, "s") == 0){
			strip_level = STRIP_ALL;
		    }
		    else if(strcmp(p, "static") == 0){
			if(dynamic_specified)
			    fatal("only one of -static or -dynamic can be "
				  "specified");
			dynamic = FALSE;
			static_specified = TRUE;
		        twolevel_namespace = FALSE;
		    }
		    else if(strcmp(p, "search_paths_first") == 0){
			search_paths_first = TRUE;
		    }
		    /*
		     * Flags for specifing information about sections.
		     */
		    /* create a section from the contents of a file
		       -sectcreate <segname> <sectname> <filename> */
		    else if(strcmp(p, "sectcreate") == 0 ||
		    	    strcmp(p, "segcreate") == 0){ /* the old name */
			if(i + 3 >= argc)
			    fatal("%s: arguments missing", argv[i]);
			seg_spec = create_segment_spec(argv[i+1]);
			sect_spec = create_section_spec(seg_spec, argv[i+2]);
			if(sect_spec->contents_filename != NULL)
			     fatal("section (%s,%s) multiply specified with a "
				   "%s option", argv[i+1], argv[i+2], argv[i]);
			if((fd = open(argv[i+3], O_RDONLY, 0)) == -1)
			    system_fatal("Can't open: %s for %s %s %s",
				    argv[i+3], argv[i], argv[i+1], argv[i+2]);
			if(fstat(fd, &stat_buf) == -1)
			    system_fatal("Can't stat file: %s for %s %s %s",
				    argv[i+3], argv[i], argv[i+1], argv[i+2]);
			/*
			 * For some reason mapping files with zero size fails
			 * so it has to be handled specially.
			 */
			if(stat_buf.st_size != 0){
			    if((r = map_fd((int)fd, (vm_offset_t)0,
				(vm_offset_t *)&(sect_spec->file_addr),
				(boolean_t)TRUE, (vm_size_t)stat_buf.st_size)
				) != KERN_SUCCESS)
				mach_fatal(r, "can't map file: %s for %s %s %s",
				    argv[i+3], argv[i], argv[i+1], argv[i+2]);
			}
			else{
			    sect_spec->file_addr = NULL;
			}
			close(fd);
			sect_spec->file_size = stat_buf.st_size;
			sect_spec->contents_filename = argv[i+3];
			i += 3;
		    }
		    /* specify the alignment of a section as a hexadecimal
		       power of 2
		       -sectalign <segname> <sectname> <number> */
		    else if(strcmp(p, "sectalign") == 0){
			if(i + 3 >= argc)
			    fatal("-sectalign arguments missing");
			seg_spec = create_segment_spec(argv[i+1]);
			sect_spec = create_section_spec(seg_spec, argv[i+2]);
			if(sect_spec->align_specified)
			     fatal("alignment for section (%s,%s) multiply "
				   "specified", argv[i+1], argv[i+2]);
			sect_spec->align_specified = TRUE;
			align = strtoul(argv[i+3], &endp, 16);
			if(*endp != '\0')
			    fatal("argument for -sectalign %s %s: %s not a "
				  "proper hexadecimal number", argv[i+1],
				  argv[i+2], argv[i+3]);
			if(!ispoweroftwo(align))
			    fatal("argument to -sectalign %s %s: %lx (hex) must"
				  " be a power of two", argv[i+1], argv[i+2],
				  align);
			if(align != 0)
			    for(tmp = align; (tmp & 1) == 0; tmp >>= 1)
				sect_spec->align++;
			if(sect_spec->align > MAXSECTALIGN)
			    fatal("argument to -sectalign %s %s: %lx (hex) must"
				  " equal to or less than %x (hex)", argv[i+1],
				  argv[i+2], align,
				  (unsigned int)(1 << MAXSECTALIGN));
			i += 3;
		    }
		    /* specify that section object symbols are to be created
		       for the specified section
		       -sectobjectsymbols <segname> <sectname> */
		    else if(strcmp(p, "sectobjectsymbols") == 0){
			if(i + 2 >= argc)
			    fatal("-sectobjectsymbols arguments missing");
			if(sect_object_symbols.specified &&
			   (strcmp(sect_object_symbols.segname,
				   argv[i+1]) != 0 ||
			    strcmp(sect_object_symbols.sectname,
				   argv[i+2]) != 0) )
			     fatal("-sectobjectsymbols multiply specified (it "
				   "can only be specified for one section)");
			sect_object_symbols.specified = TRUE;
			sect_object_symbols.segname = argv[i+1];
			sect_object_symbols.sectname = argv[i+2];
			i += 2;
		    }
		    /* layout a section in the order the symbols appear in file
		       -sectorder <segname> <sectname> <filename> */
		    else if(strcmp(p, "sectorder") == 0){
			if(i + 3 >= argc)
			    fatal("%s: arguments missing", argv[i]);
			seg_spec = create_segment_spec(argv[i+1]);
			sect_spec = create_section_spec(seg_spec, argv[i+2]);
			if(sect_spec->order_filename != NULL)
			     fatal("section (%s,%s) multiply specified with a "
				   "%s option", argv[i+1], argv[i+2], argv[i]);
			if((fd = open(argv[i+3], O_RDONLY, 0)) == -1)
			    system_fatal("Can't open: %s for %s %s %s",
				    argv[i+3], argv[i], argv[i+1], argv[i+2]);
			if(fstat(fd, &stat_buf) == -1)
			    system_fatal("Can't stat file: %s for %s %s %s",
				    argv[i+3], argv[i], argv[i+1], argv[i+2]);
			/*
			 * For some reason mapping files with zero size fails
			 * so it has to be handled specially.
			 */
			if(stat_buf.st_size != 0){
			    if((r = map_fd((int)fd, (vm_offset_t)0,
				(vm_offset_t *)&(sect_spec->order_addr),
				(boolean_t)TRUE, (vm_size_t)stat_buf.st_size)
				) != KERN_SUCCESS)
				mach_fatal(r, "can't map file: %s for %s %s %s",
				    argv[i+3], argv[i], argv[i+1], argv[i+2]);
			}
			else{
			    sect_spec->order_addr = NULL;
			}
			close(fd);
			sect_spec->order_size = stat_buf.st_size;
			sect_spec->order_filename = argv[i+3];
			i += 3;
		    }
		    else if(strcmp(p, "sectorder_detail") == 0){
			sectorder_detail = TRUE;
		    }
		    else if(strcmp(p, "sect_diff_relocs") == 0){
			if(++i >= argc)
			    fatal("-sect_diff_relocs: argument missing");
			if(strcmp(argv[i], "error") == 0)
			    new_sect_diff_reloc_flag = SECT_DIFF_RELOC_ERROR;
			else if(strcmp(argv[i], "warning") == 0)
			    new_sect_diff_reloc_flag = SECT_DIFF_RELOC_WARNING;
			else if(strcmp(argv[i], "suppress") == 0)
			    new_sect_diff_reloc_flag = SECT_DIFF_RELOC_SUPPRESS;
			else{
			    fatal("-sect_diff_relocs: unknown argument: %s",
				  argv[i]);
			    new_sect_diff_reloc_flag = SECT_DIFF_RELOC_SUPPRESS;
			}
			if(sect_diff_reloc_flag_specified == TRUE &&
			   new_sect_diff_reloc_flag != sect_diff_reloc_flag)
			    fatal("more than one value specified for "
				  "-sect_diff_relocs");
			sect_diff_reloc_flag_specified = TRUE;
			sect_diff_reloc_flag = new_sect_diff_reloc_flag;
			break;
		    }
		    /*
		     * Flags for specifing information about segments.
		     */
		    /* specify the address (in hex) of a segment
		       -segaddr <segname> <address> */
		    else if(strcmp(p, "segaddr") == 0){
			if(i + 2 >= argc)
			    fatal("-segaddr: arguments missing");
			seg_spec = create_segment_spec(argv[i+1]);
			if(seg_spec->addr_specified == TRUE)
			    fatal("address of segment %s multiply specified",
				  argv[i+1]);
			segaddr_specified = TRUE;
			seg_spec->addr_specified = TRUE;
			seg_spec->addr = strtoul(argv[i+2], &endp, 16);
			if(*endp != '\0')
			    fatal("address for -segaddr %s %s not a proper "
				  "hexadecimal number", argv[i+1], argv[i+2]);
			i += 2;
		    }
		    /* specify the protection for a segment
		       -segprot <segname> <maxprot> <initprot>
		       where the protections are specified with "rwx" with a
		       "-" for no protection. */
		    else if(strcmp(p, "segprot") == 0){
			if(i + 3 >= argc)
			    fatal("-segprot: arguments missing");
			seg_spec = create_segment_spec(argv[i+1]);
			if(seg_spec->prot_specified == TRUE)
			    fatal("protection of segment %s multiply "
				  "specified", argv[i]);
			seg_spec->maxprot = getprot(argv[i+2], &endp);
			if(*endp != '\0')
			    fatal("bad character: '%c' in maximum protection: "
				  "%s for segment %s", *endp, argv[i+2],
				  argv[i+1]);
			seg_spec->initprot = getprot(argv[i+3], &endp);
			if(*endp != '\0')
			    fatal("bad character: '%c' in initial protection: "
				  "%s for segment %s", *endp, argv[i+3],
				  argv[i+1]);
			if(check_max_init_prot(seg_spec->maxprot,
					       seg_spec->initprot) == FALSE)
			    fatal("maximum protection: %s for segment: %s "
				  "doesn't include all initial protections: %s",
				  argv[i+2], argv[i+1], argv[i+3]);
			seg_spec->prot_specified = TRUE;
			i += 3;
		    }
		    /* specify the address (in hex) of the first segment
		       -seg1addr <address> */
		    else if(strcmp(p, "seg1addr") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(seg1addr_specified == TRUE)
			    fatal("%s: multiply specified", argv[i]);
			seg1addr = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for %s %s not a proper "
				  "hexadecimal number", argv[i], argv[i+1]);
			seg1addr_specified = TRUE;
			i += 1;
		    }
		    /* specify the address (in hex) of the read-only segments
		       -segs_read_only_addr <address> */
		    else if(strcmp(p, "segs_read_only_addr") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(segs_read_only_addr_specified == TRUE)
			    fatal("%s: multiply specified", argv[i]);
			segs_read_only_addr = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for %s %s not a proper "
				  "hexadecimal number", argv[i], argv[i+1]);
			segs_read_only_addr_specified = TRUE;
			i += 1;
		    }
		    /* specify the address (in hex) of the read-write segments
		       -segs_read_write_addr <address> */
		    else if(strcmp(p, "segs_read_write_addr") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(segs_read_write_addr_specified == TRUE)
			    fatal("%s: multiply specified", argv[i]);
			segs_read_write_addr = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for %s %s not a proper "
				  "hexadecimal number", argv[i], argv[i+1]);
			segs_read_write_addr_specified = TRUE;
			i += 1;
		    }
		    /* specify the name of the segment address table */
		    else if(strcmp(p, "seg_addr_table") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(seg_addr_table_name != NULL)
			    fatal("%s: multiply specified", argv[i]);
			seg_addr_table_name = argv[i+1];
			i += 1;
		    }
		    /* specify the file system path name to be used instead of
		       the install name in the segment address table */
		    else if(strcmp(p, "seg_addr_table_filename") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(seg_addr_table_filename != NULL)
			    fatal("%s: multiply specified", argv[i]);
			seg_addr_table_filename = argv[i+1];
			i += 1;
		    }
		    /* specify the segment alignment as a hexadecimal power of 2
		       -segalign <number> */
		    else if(strcmp(p, "segalign") == 0){
			if(segalign_specified)
			    fatal("-segalign: multiply specified");
			if(++i >= argc)
			    fatal("-segalign: argument missing");
			segalign = strtoul(argv[i], &endp, 16);
			if(*endp != '\0')
			    fatal("argument for -segalign %s not a proper "
				  "hexadecimal number", argv[i]);
			if(!ispoweroftwo(segalign) || segalign == 0)
			    fatal("argument to -segalign: %lx (hex) must be a "
				  "non-zero power of two", segalign);
			if(segalign > MAXSEGALIGN)
			    fatal("argument to -segalign: %lx (hex) must equal "
				  "to or less than %x (hex)", segalign,
				  (unsigned int)MAXSEGALIGN);
			segalign_specified = TRUE;
			if(segalign < (1 << DEFAULTSECTALIGN)){
			    defaultsectalign = 0;
			    align = segalign;
			    while((align & 0x1) != 1){
				defaultsectalign++;
				align >>= 1;
			    }
			}
		    }
		    else if(strcmp(p, "seglinkedit") == 0){
			if(seglinkedit_specified && seglinkedit == FALSE)
			    fatal("both -seglinkedit and -noseglinkedit can't "
				  "be specified");
			seglinkedit = TRUE;
			seglinkedit_specified = TRUE;
		    }
		    /* specify the stack address as a hexadecimal number
		       -stack_addr <address> */
		    else if(strcmp(p, "stack_addr") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(stack_addr_specified == TRUE)
			    fatal("%s: multiply specified", argv[i]);
			stack_addr = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for %s %s not a proper "
				  "hexadecimal number", argv[i], argv[i+1]);
			stack_addr_specified = TRUE;
			i += 1;
		    }
		    /* specify the stack size as a hexadecimal number
		       -stack_size <address> */
		    else if(strcmp(p, "stack_size") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(stack_size_specified == TRUE)
			    fatal("%s: multiply specified", argv[i]);
			stack_size = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for %s %s not a proper "
				  "hexadecimal number", argv[i], argv[i+1]);
			stack_size_specified = TRUE;
			i += 1;
		    }
		    /* specify a sub_umbrella
		       -sub_umbrella <name> */
		    else if(strcmp(p, "sub_umbrella") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			sub_umbrellas = reallocate(sub_umbrellas,
					(nsub_umbrellas + 1) * sizeof(char *));
			sub_umbrellas[nsub_umbrellas++] = argv[i+1];
			i += 1;
		    }
		    /* specify a sub_library
		       -sub_library <name> */
		    else if(strcmp(p, "sub_library") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			sub_librarys = reallocate(sub_librarys,
					(nsub_librarys + 1) * sizeof(char *));
			sub_librarys[nsub_librarys++] = argv[i+1];
			i += 1;
		    }
		    /* -single_module for MH_DYLIB output */
		    else if(strcmp(p, "single_module") == 0){
			if(moduletype_specified == TRUE &&
			   multi_module_dylib == TRUE)
			    fatal("can't specify both -single_module and "
				  "-multi_module");
			moduletype_specified = TRUE;
			multi_module_dylib = FALSE;
		    }
		    else if(strcmp(p, "syslibroot") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(syslibroot_specified == TRUE && strcmp(next_root, argv[i+1]) != 0)
			    fatal("%s: multiply specified", argv[i]);
			next_root = argv[i+1];
			syslibroot_specified = TRUE;
			i += 1;
		    }
		    else
			goto unknown_flag;
		    break;

		case 't':
		    /* trace flag */
		    if(strcmp(p, "twolevel_namespace") == 0){
			if(namespace_specified == TRUE &&
			   twolevel_namespace == FALSE)
			    fatal("can't specify both -twolevel_namespace and "
				  "-flat_namespace");
			namespace_specified = TRUE;
			twolevel_namespace = TRUE;
		    }
		    else if(strcmp(p, "twolevel_namespace_hints") == 0){
			if(namespace_specified == TRUE &&
			   twolevel_namespace == FALSE)
			    fatal("can't specify both -twolevel_namespace_hints"
				  " and -flat_namespace");
			twolevel_namespace_hints_specified = TRUE;
		    }
		    else if(p[1] == '\0')
			trace = TRUE;
		    else
			goto unknown_flag;
		    break;

		case 'o':
		    if(strcmp(p, "object") == 0){
			if(filetype_specified == TRUE && filetype != MH_OBJECT)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_OBJECT;
			break;
		    }
		    /* specify the output file name */
		    if(p[1] != '\0')
			goto unknown_flag;
		    if(outputfile != NULL)
			fatal("-o: multiply specified");
		    if(++i >= argc)
			fatal("-o: argument missing");
		    outputfile = argv[i];
		    break;

		case 'a':
		    if(strcmp(p, "all_load") == 0)
			archive_all = TRUE;
		    else if(strcmp(p, "arch_multiple") == 0)
			arch_multiple = TRUE;
		    else if(strcmp(p, "arch_errors_fatal") == 0)
			arch_errors_fatal = TRUE;
		    else if(strcmp(p, "allow_stack_execute") == 0)
			allow_stack_execute = TRUE;
		    else if(strcmp(p, "arch") == 0){
			if(++i >= argc)
			    fatal("-arch: argument missing");
			if(arch_flag.name != NULL &&
			   strcmp(arch_flag.name, argv[i]) != 0)
			    fatal("-arch: multiply specified");
			if(get_arch_from_flag(argv[i], &arch_flag) == 0){
			    error("unknown architecture specification flag: "
				  "-arch %s", argv[i]);
			    fatal("Usage: %s [options] file [...]", progname);
			}
			/* Default to -single_module on ARM. */
			if(arch_flag.cputype == CPU_TYPE_ARM){
			    multi_module_dylib = FALSE;
			}
			target_byte_sex = get_byte_sex_from_flag(&arch_flag);
		    }
		    /* specify an allowable client of this subframework
		       -allowable_client client_name */
		    else if(strcmp(p, "allowable_client") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			allowable_clients = reallocate(allowable_clients,
				    (nallowable_clients + 1) * sizeof(char *));
			allowable_clients[nallowable_clients++] = argv[i+1];
			i += 1;
			break;
		    }
		    else
			goto unknown_flag;
		    break;

		case 'c':
		    /* specify this client's name which is using a subframework
		       -client_name client_name */
		    if(strcmp(p, "client_name") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(client_name != NULL)
			    fatal("%s: multiply specified", argv[i]);
			client_name = argv[i+1];
			i += 1;
			break;
		    }
		    else if(strcmp(p, "compatibility_version") == 0){
		        if(i + 1 >= argc)
			    fatal("-compatibility_version: argument "
				  "missing");
			if(get_version_number("-compatibility_version",
			    argv[i+1], &dylib_compatibility_version) == FALSE)
			    cleanup();
			if(dylib_compatibility_version == 0)
			    fatal("-compatibility_version must be "
				  "greater than zero");
			i += 1;
			break;
		    }
		    else if(strcmp(p, "current_version") == 0){
		        if(i + 1 >= argc)
			    fatal("-current_version: argument missing");
			if(get_version_number("-current_version",
			    argv[i+1], &dylib_current_version) == FALSE)
			    cleanup();
			if(dylib_current_version == 0)
			    fatal("-current_version must be greater than "
				  "zero");
			i += 1;
			break;
		    }
		    if(p[1] != '\0')
			goto unknown_flag;
		    break;


		/* Flags dealing with symbols */
		case 'i':
		    if(strcmp(p, "image_base") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(seg1addr_specified == TRUE)
			    fatal("%s: argument missing", argv[i]);
			seg1addr = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for %s %s not a proper "
				  "hexadecimal number", argv[i], argv[i+1]);
			seg1addr_specified = TRUE;
			i += 1;
		    }
		    else if(strcmp(p, "init") == 0){
			/* check to see if the pointer is not already set */
			if(init_name != NULL)
			    fatal("-init: multiply specified");
			if(++i >= argc)
			    fatal("-init: argument missing");
			init_name = argv[i];
		    }
		    else if(strcmp(p, "install_name") == 0){
		        if(i + 1 >= argc)
			    fatal("-install_name: argument missing");
			dylib_install_name = argv[i + 1];
			i += 1;
		    }
		    else{
			/* create an indirect symbol, symbol_name, to be an
			   indirect symbol for indr_symbol_name */
			symbol_name = p + 1;
			indr_symbol_name = strchr(p + 1, ':');
			if(indr_symbol_name == NULL ||
			   indr_symbol_name[1] == '\0' || *symbol_name == ':')
			    fatal("-i argument: %s must have a ':' between "
				  "its symbol names", p + 1);
			/* the creating of the symbol is done in the next pass
			   of parsing arguments */
		    }
		    break;

		case 'm':
		    if(strcmp(p, "multiply_defined") == 0){
			if(++i >= argc)
			    fatal("-multiply_defined: argument missing");
			if(strcmp(argv[i], "error") == 0)
			    new_multiply_defined_flag = MULTIPLY_DEFINED_ERROR;
			else if(strcmp(argv[i], "warning") == 0)
			    new_multiply_defined_flag =MULTIPLY_DEFINED_WARNING;
			else if(strcmp(argv[i], "suppress") == 0)
			    new_multiply_defined_flag=MULTIPLY_DEFINED_SUPPRESS;
			else{
			    fatal("-multiply_defined: unknown argument: %s",
				  argv[i]);
			    new_multiply_defined_flag =MULTIPLY_DEFINED_WARNING;
			}
			if(multiply_defined_flag_specified == TRUE &&
			   new_multiply_defined_flag != multiply_defined_flag)
			    fatal("more than one value specified for "
				  "-multiply_defined");
			multiply_defined_flag_specified = TRUE;
			multiply_defined_flag = new_multiply_defined_flag;
			break;
		    }
		    else if(strcmp(p, "multiply_defined_unused") == 0){
			if(++i >= argc)
			    fatal("-multiply_defined_unused: argument missing");
			if(strcmp(argv[i], "error") == 0)
			    new_multiply_defined_unused_flag =
				MULTIPLY_DEFINED_ERROR;
			else if(strcmp(argv[i], "warning") == 0)
			    new_multiply_defined_unused_flag =
				MULTIPLY_DEFINED_WARNING;
			else if(strcmp(argv[i], "suppress") == 0)
			    new_multiply_defined_unused_flag =
				MULTIPLY_DEFINED_SUPPRESS;
			else{
			    fatal("-multiply_defined_unused: unknown argument: "
				  "%s", argv[i]);
			    new_multiply_defined_unused_flag =
				MULTIPLY_DEFINED_SUPPRESS;
			}
			if(multiply_defined_unused_flag_specified == TRUE &&
			   new_multiply_defined_unused_flag !=
				multiply_defined_unused_flag)
			    fatal("more than one value specified for "
				  "-multiply_defined_unused");
			multiply_defined_unused_flag_specified = TRUE;
			multiply_defined_unused_flag =
			    new_multiply_defined_unused_flag;
			break;
		    }
		    /* -multi_module for MH_DYLIB output */
		    else if(strcmp(p, "multi_module") == 0){
			if(moduletype_specified == TRUE &&
			   multi_module_dylib == FALSE)
			    fatal("can't specify both -single_module and "
				  "-multi_module");
			moduletype_specified = TRUE;
			multi_module_dylib = TRUE;
			break;
		    }
		    /* -macosx_version_min for overriding
		       MACOSX_DEPLOYMENT_TARGET on command line */
		    else if(strcmp (p, "macosx_version_min") == 0){
			if(++i >= argc)
			    fatal("-macosx_version_min: argument missing");
			put_macosx_deployment_target (argv[i]);
			break;
		    }
		    /* treat multiply defined symbols as a warning not a
		       hard error */
		    if(p[1] != '\0')
			goto unknown_flag;
		    allow_multiply_defined_symbols = TRUE;
		    break;

		case 'u':
		    if(strcmp(p, "undefined") == 0){
			if(++i >= argc)
			    fatal("-undefined: argument missing");
			if(strcmp(argv[i], "error") == 0)
			    new_undefined_flag = UNDEFINED_ERROR;
			else if(strcmp(argv[i], "warning") == 0)
			    new_undefined_flag = UNDEFINED_WARNING;
			else if(strcmp(argv[i], "suppress") == 0)
			    new_undefined_flag = UNDEFINED_SUPPRESS;
			else if(strcmp(argv[i], "dynamic_lookup") == 0)
			    new_undefined_flag = UNDEFINED_DYNAMIC_LOOKUP;
			else if(strcmp(argv[i], "define_a_way") == 0){
			    new_undefined_flag = UNDEFINED_DEFINE_A_WAY;
			    warning("suggest the use of -dead_strip instead of "
				    "-undefined define_a_way");
			}
			else{
			    fatal("-undefined: unknown argument: %s", argv[i]);
			    new_undefined_flag = UNDEFINED_ERROR;
			}
			if(undefined_flag_specified == TRUE &&
			   new_undefined_flag != undefined_flag)
			    fatal("more than one value specified for "
				  "-undefined");
			undefined_flag_specified = TRUE;
			undefined_flag = new_undefined_flag;
			break;
		    }
		    /* specify this dynamic library as a subframework
		       -umbrella umbrella_framework_name */
		    else if(strcmp(p, "umbrella") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(sub_framework == TRUE)
			    fatal("%s: multiply specified", argv[i]);
			umbrella_framework_name = argv[i+1];
		        sub_framework = TRUE;
			i += 1;
			break;
		    }
		    else if(strcmp(p, "unexported_symbols_list") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(remove_symbols != NULL)
			    fatal("%s: multiply specified", argv[i]);
			setup_symbol_list(argv[i+1], &remove_symbols,
					  &nremove_symbols);
			unexported_symbols_list = argv[i+1];
			i += 1;
			break;
		    }
		    if(p[1] != '\0')
			goto unknown_flag;
		    /* cause the specified symbol name to be undefined */
		    if(++i >= argc)
			fatal("-u: argument missing");
		    /* the creating of the symbol is done in the next pass of
		       parsing arguments */
		    break;

		case 'e':
		    if(strcmp(p, "execute") == 0){
			if(filetype_specified == TRUE && filetype != MH_EXECUTE)
			    fatal("more than one output filetype specified");
			filetype_specified = TRUE;
			filetype = MH_EXECUTE;
			break;
		    }
		    else if(strcmp(p, "exported_symbols_list") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(save_symbols != NULL)
			    fatal("%s: multiply specified", argv[i]);
			setup_symbol_list(argv[i+1], &save_symbols,
					  &nsave_symbols);
			exported_symbols_list = argv[i+1];
			i += 1;
			break;
		    }
		    else if(strcmp(p, "executable_path") == 0){
			if(i + 1 >= argc)
			    fatal("%s: argument missing", argv[i]);
			if(executable_path != NULL)
			    fatal("%s: multiply specified", argv[i]);
			executable_path = argv[i+1];
			i += 1;
			break;
		    }
		    /* specify the entry point, the symbol who's value to be
		       used as the program counter in the unix thread */
		    if(p[1] != '\0')
			goto unknown_flag;
		    /* check to see if the pointer is not already set */
		    if(entry_point_name != NULL)
			fatal("-e: multiply specified");
		    if(++i >= argc)
			fatal("-e: argument missing");
		    entry_point_name = argv[i];
		    break;

		case 'U':
		    if(p[1] != '\0')
			goto unknown_flag;
		    /* allow the specified symbol name to be undefined */
		    if(++i >= argc)
			fatal("-U: argument missing");
		    undef_syms = reallocate(undef_syms,
					    (nundef_syms + 1) * sizeof(char *));
		    undef_syms[nundef_syms++] = argv[i];
		    break;

		case 'w':
		    if(strcmp(p, "w") == 0)
			nowarnings = TRUE;
		    else if(strcmp(p, "whyload") == 0)
			whyload = TRUE;
		    else if(strcmp(p, "whatsloaded") == 0)
			whatsloaded = TRUE;
		    else if(strcmp(p, "weak_reference_mismatches") == 0){
			if(++i >= argc)
			    fatal("-weak_reference_mismatches: "
				  "argument missing");
			if(strcmp(argv[i], "error") == 0)
			    new_weak_reference_mismatches =
				WEAK_REFS_MISMATCH_ERROR;
			else if(strcmp(argv[i], "weak") == 0)
			    new_weak_reference_mismatches =
				WEAK_REFS_MISMATCH_WEAK;
			else if(strcmp(argv[i], "non-weak") == 0)
			    new_weak_reference_mismatches =
				WEAK_REFS_MISMATCH_NON_WEAK;
			else{
			    fatal("-weak_reference_mismatches: unknown "
				  "argument: %s", argv[i]);
			    new_weak_reference_mismatches =
				WEAK_REFS_MISMATCH_ERROR;
			}
			if(weak_reference_mismatches_specified == TRUE &&
			   new_weak_reference_mismatches !=
				weak_reference_mismatches)
			    fatal("more than one value specified for "
				  "-weak_reference_mismatches");
			weak_reference_mismatches_specified = TRUE;
			weak_reference_mismatches =
			    new_weak_reference_mismatches;
			break;
		    }
		    else if(strcmp(p, "weak_library") == 0){
			if(i + 1 >= argc)
			    fatal("-weak_library: argument missing");
			/* object file argv[i] processed in the next pass of
			   parsing arguments */
			i += 1;
		    }
		    else if(strncmp(p, "weak-l", sizeof("weak-l") - 1) == 0){
			if(p[sizeof("weak-l") - 1] == '\0')
			    fatal("-weak-l: argument missing");
			/* path searched abbrevated file name, processed in the
			   next pass of parsing arguments */
		    }
		    else if(strcmp(p, "weak_framework") == 0){
			if(i + 1 >= argc)
			    fatal("-weak_framework: argument missing");
			/* path searched abbrevated framework name, processed
			   in the next pass of parsing arguments */
			i += 1;
		    }
		    else
			goto unknown_flag;
		    break;

		case 'O':
		    if(strcmp(p, "ObjC") == 0)
			archive_ObjC = TRUE;
		    else
			goto unknown_flag;
		    break;

		case 'y':
		    /* symbol tracing */
		    if(p[1] == '\0')
			fatal("-y: symbol name missing");
		    trace_syms = reallocate(trace_syms,
					    (ntrace_syms + 1) * sizeof(char *));
		    trace_syms[ntrace_syms++] = &(p[1]);
		    break;

		case 'Y':
		    /* undefined reference symbol tracing */
		    if(strcmp(p, "Y") == 0){
			if(i + 1 >= argc)
			    fatal("-Y: argument missing");
			Yflag = strtoul(argv[i+1], &endp, 10);
			if(*endp != '\0')
			    fatal("reference count for -Y %s not a proper "
				  "decimal number", argv[i+1]);
		    }
		    else
			goto unknown_flag;
		    break;

		case 'h':
		    /* specify the header pad (in hex)
		       -headerpad <value> */
		    if(strcmp(p, "headerpad") == 0){
			if(i + 1 >= argc)
			    fatal("-headerpad: argument missing");
			if(headerpad_specified == TRUE)
			    fatal("-headerpad: multiply specified");
			headerpad = strtoul(argv[i+1], &endp, 16);
			if(*endp != '\0')
			    fatal("address for -headerpad %s not a proper "
				  "hexadecimal number", argv[i+1]);
			headerpad_specified = TRUE;
			i += 1;
		    }
		    else if(strcmp(p, "headerpad_max_install_names") == 0){
			headerpad_max_install_names = TRUE;
		    }
		    else if(strcmp(p, "hash_instrument") == 0){
			hash_instrument_specified = TRUE;
		    }
		    else
			goto unknown_flag;
		    break;

		case 'k':
		    if(strcmp(p, "keep_private_externs") == 0)
			keep_private_externs = TRUE;
		    else if(strcmp(p, "k") == 0)
			dynamic = TRUE;
		    else
			goto unknown_flag;
		    break;

		case 'N':
		    if(strcmp(p, "NEXTSTEP-deployment-target") == 0){
			if(i + 1 >= argc)
			    fatal("-NEXTSTEP-deployment-target: argument "
				  "missing");
			if(dynamic_specified == TRUE ||
			   static_specified == TRUE)
			    fatal("-NEXTSTEP-deployment-target, -dynamic or "
				  "-static : multiply specified");
			if(strcmp(argv[i+1], "3.3") == 0){
			    if(static_specified)
				fatal("only one of -NEXTSTEP-deployment-target "
				      "3.3 or -static can be specified");
			    dynamic = TRUE;
			    dynamic_specified = TRUE;
			}
			else if(strcmp(argv[i+1], "3.2") == 0){
			    if(dynamic_specified)
				fatal("only one of -NEXTSTEP-deployment-target "
				      "3.2 or -dynamic can be specified");
			    dynamic = FALSE;
			    static_specified = TRUE;
			}
			else
			    fatal("unknown deployment release flag: "
				"-NEXTSTEP-deployment-target %s", argv[i+1]);
			i += 1;
		    }
		    else
			goto unknown_flag;
		    break;

		case 'v':
		    if(strcmp(p, "v") == 0){
			vflag = TRUE;
			printf("Apple Inc. version %s\n", apple_version);
		    }
		    else
			goto unknown_flag;
		    break;

		default:
unknown_flag:
		    fatal("unknown flag: %s", argv[i]);
		}
	    }
	}

	/*
	 * -sub_umbrella and -sub_library are not supported on ARM.
	 * See <rdar://problem/4771657>.
	 */
	if(arch_flag.cputype == CPU_TYPE_ARM){
	    if(sub_umbrellas != NULL){
	        fatal("-sub_umbrella is not supported on ARM");
	    }
	    if(sub_librarys != NULL){
	        fatal("-sub_library is not supported on ARM");
	    }
	}

	/*
	 * If either -syslibroot or the environment variable NEXT_ROOT is set
	 * prepend it to the standard paths for library searches.  This was
	 * added to ease cross build environments.
	 */
	p = getenv("NEXT_ROOT");
	if(syslibroot_specified == TRUE){
	    if(p != NULL && strcmp(p, next_root) != 0)
		warning("NEXT_ROOT environment variable ignored because "
			"-syslibroot specified");
	}
	else{
	    next_root = p;
	}
	if(next_root != NULL){
	    for(i = 0; standard_dirs[i] != NULL; i++){
		p = allocate(strlen(next_root) +
			     strlen(standard_dirs[i]) + 1);
		strcpy(p, next_root);
		strcat(p, standard_dirs[i]);
		standard_dirs[i] = p;
	    }
	    for(i = 0; standard_framework_dirs[i] != NULL; i++){
		p = allocate(strlen(next_root) +
			     strlen(standard_framework_dirs[i]) + 1);
		strcpy(p, next_root);
		strcat(p, standard_framework_dirs[i]);
		standard_framework_dirs[i] = p;
	    }
	}
 	/*
	 * If -syslibroot is specified, prepend it to the user-specified
	 * paths *if* the prepended version exists.
	 */
	if(syslibroot_specified == TRUE){
	    for(i = 0; i < nsearch_dirs; i++){
		if(search_dirs[i][0] == '/'){
		    p = mkstr(next_root, search_dirs[i], NULL);
		    if(stat(p, &stat_buf) == 0)
			search_dirs[i] = p;
		    else
			free(p);
		}
	    }
	    for(i = 0; i < nframework_dirs; i++){
		if(framework_dirs[i][0] == '/'){
		    p = mkstr(next_root, framework_dirs[i], NULL);
		    if(stat(p, &stat_buf) == 0)
			framework_dirs[i] = p;
		    else
			free(p);
		}
	    }
	}

	/*
         * Test to see if the various RC_* or XBS_* environment variables
	 * are set.
         */
        if((getenv("LD_TRACE_ARCHIVES") != NULL) ||
	   getenv("RC_TRACE_ARCHIVES") != NULL)
	  ld_trace_archives = TRUE;
        if((getenv("LD_TRACE_DYLIBS") != NULL) ||
	   (getenv("RC_TRACE_DYLIBS") != NULL))
	  ld_trace_dylibs = TRUE;
        if((getenv("LD_TRACE_PREBINDING_DISABLED") != NULL) ||
	   getenv("RC_TRACE_PREBINDING_DISABLED") != NULL)
	  ld_trace_prebinding_disabled = TRUE;
	if(ld_trace_archives || ld_trace_dylibs)
	  trace_file_path = getenv("LD_TRACE_FILE");
        if(getenv("LD_TRACE_BUNDLE_LOADER") != NULL &&
	   bundle_loader != NULL)
	    print("[Logging for XBS] Referenced bundle loader: %s\n",
		  bundle_loader);

	if(save_reloc == FALSE){
	    if(getenv("LD_DEAD_STRIP") != NULL)
		dead_strip = TRUE;
	    if(getenv("LD_NO_DEAD_STRIP_INITS_AND_TERMS") != NULL)
		no_dead_strip_inits_and_terms = TRUE;
	}
	if(getenv("LD_DEAD_STRIP_DYLIB") != NULL && filetype == MH_DYLIB)
	    dead_strip = TRUE;

	prebinding_via_LD_PREBIND = FALSE;
	/*
	 * The LD_FORCE_NO_PREBIND environment variable overrides the command
	 * line and the LD_PREBIND environment variable.
	 */
	if(getenv("LD_FORCE_NO_PREBIND") != NULL){
	    if(prebinding_flag_specified == TRUE &&
	       prebinding == TRUE){
		warning("-prebind ignored because LD_FORCE_NO_PREBIND "
			"environment variable specified");
		prebinding_flag_specified = TRUE;
		prebinding = FALSE;
	    }
	}
	/*
	 * The -prebind flag can also be specified with the LD_PREBIND
	 * environment variable.  We quitely ignore this when -r is on or
	 * if this is a fixed shared library output.
	 */
	else if(getenv("LD_PREBIND") != NULL &&
	   save_reloc == FALSE &&
	   filetype != MH_FVMLIB){
	    if(prebinding_flag_specified == TRUE &&
	       prebinding == FALSE){
		warning("LD_PREBIND environment variable ignored because "
			"-noprebind specified");
	    }
	    else{
		if(prebinding_flag_specified == FALSE)
		    prebinding_via_LD_PREBIND = TRUE;
		prebinding_flag_specified = TRUE;
		prebinding = TRUE;
	    }
	}
	if(getenv("LD_PREBIND_ALLOW_OVERLAP") != NULL)
	    prebind_allow_overlap = TRUE;
	if(prebind_all_twolevel_modules_specified == FALSE &&
	   getenv("LD_PREBIND_ALL_TWOLEVEL_MODULES") != NULL)
	    prebind_all_twolevel_modules = TRUE;

	/*
	 * The -twolevel_namespace flag can also be specified with the
	 * LD_TWOLEVEL_NAMESPACE environment variable.  We quitely ignore this
	 * when -flat_namespace or -static is specified.
	 */
	if(getenv("LD_TWOLEVEL_NAMESPACE") != NULL &&
	   namespace_specified == FALSE &&
	   static_specified == FALSE){
		namespace_specified = TRUE;
		twolevel_namespace = TRUE;
	}

	/*
	 * See if LD_LIBRARY_PATH is set.  And if so parse out the colon
	 * separated set of paths.
	 */
	ld_library_path = getenv("LD_LIBRARY_PATH");
	if(ld_library_path != NULL){
	    nld_library_paths = 1;
	    for(i = 0; ld_library_path[i] != '\0'; i++){
		if(ld_library_path[i] == ':')
		     nld_library_paths++;
	    }
	    ld_library_paths = allocate(sizeof(char *) * nld_library_paths);
	    j = 0;
	    ld_library_paths[j] = ld_library_path;
	    j++;
	    for(i = 0; ld_library_path[i] != '\0'; i++){
		if(ld_library_path[i] == ':'){
		    ld_library_path[i] = '\0';
		    ld_library_paths[j] = ld_library_path + i + 1;
		    j++;
		}
	    }
	}

	/*
	 * If there was a -arch flag two things needed to be done in reguard to
	 * the handling of the cpusubtypes.
	 */
	if(arch_flag.name != NULL){

	    /*
	     * 64-bit architectures are an error.
	     */
	    if(arch_flag.cputype & CPU_ARCH_ABI64)
		fatal("does not support 64-bit architectures");

	    family_arch_flag = get_arch_family_from_cputype(arch_flag.cputype);
	    if(family_arch_flag == NULL)
		fatal("internal error: unknown cputype (%d) for -arch %s (this "
		      "program out of sync with get_arch_family_from_cputype())"
		      ,arch_flag.cputype, arch_flag.name);
	    /*
	     * Pick up the Mac OS X deployment target.
	     */
	    get_macosx_deployment_target(&macosx_deployment_target);
	    /*
	     * If for this cputype we are to always output the ALL cpusubtype
	     * then set force_cpusubtype_ALL.
	     */
	    if(force_cpusubtype_ALL_for_cputype(arch_flag.cputype) == TRUE)
		force_cpusubtype_ALL = TRUE;
	    /*
	     * First, if -force_cpusubtype_ALL is set and an -arch flag was
	     * specified set the cpusubtype to the _ALL type for that cputype
	     * since the specified flag may not have the _ALL type and the
	     * -force_cpusubtype_ALL has precedence over an -arch flags for a
	     * specific implementation of an architecture.
	     */
	    if(force_cpusubtype_ALL == TRUE){
		arch_flag.cpusubtype = family_arch_flag->cpusubtype;
	    }
	    else{
		/*
		 * Second, if no -force_cpusubtype_ALL is specified and an -arch
		 * flag for a specific implementation of an architecture was
		 * specified then the resulting cpusubtype will be for that
		 * specific implementation of that architecture and all
		 * cpusubtypes must combine with the cpusubtype for the -arch
		 * flag to the cpusubtype for the -arch flag else an error must
		 * be flaged.  This is done check_cur_obj() where cpusubtypes
		 * are combined.  What needs to be done here is to determine if
		 * the -arch flag is for a specific implementation of an
		 * architecture.
		 */
		if(arch_flag.cpusubtype != family_arch_flag->cpusubtype)
		    specific_arch_flag = TRUE;
	    }
	}
	else{
	    /*
	     * We need to pick up the Mac OS X deployment target even if the
	     * target architecture is not yet known so we can check to see if
	     * the flags specified are valid.
	     */
	    if(macosx_deployment_target.major == 0)
		get_macosx_deployment_target(&macosx_deployment_target);
	}

	/*
	 * If the -sect_diff_relocs is specified check to see it can be used
	 * else pick up the LD_SECT_DIFF_RELOC if that can be used.
	 */
	if(sect_diff_reloc_flag_specified == TRUE){
	    if(filetype != MH_EXECUTE || dynamic == FALSE)
		fatal("can't use -sect_diff_relocs unless both -execute and "
		      "-dynamic are in effect");
	}
	else{
	    /*
	     * The -sect_diff_relocs flag was not specified on the command
	     * line, so if both -execute and -dynamic are in effect see if
	     * LD_SECT_DIFF_RELOCS is specified as an environment variable and
	     * use that value.
	     */
	    if(filetype == MH_EXECUTE && dynamic == TRUE){
		p = getenv("LD_SECT_DIFF_RELOCS");
		if(p != NULL){
		    if(strcmp(p, "error") == 0)
			sect_diff_reloc_flag = SECT_DIFF_RELOC_ERROR;
		    else if(strcmp(p, "warning") == 0)
			sect_diff_reloc_flag = SECT_DIFF_RELOC_WARNING;
		    else if(strcmp(p, "suppress") == 0)
			sect_diff_reloc_flag = SECT_DIFF_RELOC_SUPPRESS;
		    else{
			fatal("Unknown LD_SECT_DIFF_RELOCS environment variable"
			      " %s value", p);
		    }
		}
	    }
	}

	/*
	 * Check for flag combinations that would result in a bad output file.
	 */
	if(save_reloc && strip_level == STRIP_ALL)
	    fatal("can't use -s with -r (resulting file would not be "
		  "relocatable)");
	if(save_reloc && strip_level == STRIP_MIN_DEBUG)
	    fatal("can't use -Sp with -r (only allowed for fully linked "
		  "images)");
	if(save_reloc && strip_base_symbols == TRUE)
	    fatal("can't use -b with -r (resulting file would not be "
		  "relocatable)");
	if(save_reloc && dead_strip == TRUE)
	    fatal("can't use -dead_strip with -r (only allowed for fully "
		  "linked images)");
	if(keep_private_externs == TRUE){
	    if(save_symbols != NULL)
		fatal("can't use both -keep_private_externs and "
		      "-exported_symbols_list");
	    if(remove_symbols != NULL)
		fatal("can't use both -keep_private_externs and "
		      "-unexported_symbols_list");
	}
	if(save_symbols != NULL && remove_symbols != NULL){
	    for(j = 0; j < nremove_symbols ; j++){
		sp = bsearch(remove_symbols[j].name,
			     save_symbols, nsave_symbols,
			     sizeof(struct symbol_list),
			     (int (*)(const void *, const void *))
				symbol_list_bsearch);
		if(sp != NULL){
		    error("symbol name: %s is listed in both "
			  "-exported_symbols_list and -unexported_symbols_list "
			  "(can't be both exported and unexported)",
			  remove_symbols[j].name);
		}
	    }
	    if(errors != 0)
		ld_exit(1);
	}
	if(filetype_specified == TRUE && filetype == MH_OBJECT){
	    if(dynamic == TRUE)
		fatal("incompatible to specifiy -object when -dynamic is used "
		      "(use -execute (the default) with -dynamic or -static "
		      "with -object)");
	}
	if(filetype == MH_DYLINKER){
	    if(dynamic == FALSE)
		fatal("incompatible flag -dylinker used (must specify "
		      "\"-dynamic\" to be used)");
	}
	if(filetype == MH_DYLIB){
	    if(dynamic == FALSE)
		fatal("incompatible flag -dylib used (must specify "
		      "\"-dynamic\" to be used)");
	    if(save_reloc)
		fatal("can't use -r and -dylib (file format produced with "
		      "-dylib is not a relocatable format)");
	    if(strip_level == STRIP_ALL)
		fatal("can't use -s with -dylib (file must contain at least "
		      "global symbols, for maximum stripping use -x)");
	    if(Aflag_specified)
		fatal("can't use -A and -dylib");
	    if(keep_private_externs == TRUE)
		fatal("can't use -keep_private_externs and -dylib");
	    if(segaddr_specified)
		fatal("can't use -segaddr options with -dylib (use seg1addr to "
		      "specify the starting address)");
	    if(seg1addr_specified && segs_read_only_addr_specified)
		fatal("can't use both the -seg1addr option and "
		      "-segs_read_only_addr option");
	    if(seg1addr_specified && segs_read_write_addr_specified)
		fatal("can't use both the -seg1addr option and "
		      "-segs_read_write_addr option");
	    if(seg1addr_specified && seg_addr_table_name != NULL)
		fatal("can't use both the -seg1addr option and "
		      "-seg_addr_table option");
	    if(seg_addr_table_name != NULL && segs_read_only_addr_specified)
		fatal("can't use both the -seg_addr_table option and "
		      "-segs_read_only_addr option");
	    if(seg_addr_table_name != NULL && segs_read_write_addr_specified)
		fatal("can't use both the -seg_addr_table option and "
		      "-segs_read_only_addr option");
	    if(seg_addr_table_name != NULL && dylib_install_name == NULL)
		fatal("must also specify -dylib_install_name when using "
		      "-seg_addr_table");
	    if(segs_read_only_addr_specified &&
	       read_only_reloc_flag != READ_ONLY_RELOC_ERROR)
		fatal("can't used -read_only_relocs %s with format produced "
		      "with the -segs_read_only_addr option\n",
		      read_only_reloc_flag == READ_ONLY_RELOC_WARNING ?
		      "warning" : "suppress");
	    if(segs_read_write_addr_specified &&
	       !segs_read_only_addr_specified)
		fatal("must also specify -segs_read_only_addr when using "
		      "-segs_read_write_addr");
	    if(seglinkedit_specified && seglinkedit == FALSE)
		fatal("can't use -noseglinkedit with -dylib (resulting file "
		      "must have a link edit segment to access symbols)");
	    if(bind_at_load == TRUE){
		warning("-bind_at_load is meaningless with -dylib");
		bind_at_load = FALSE;
	    }
	    /* use a segment address table if specified */
	    env_seg_addr_table_name = getenv("LD_SEG_ADDR_TABLE");
	    if(seg_addr_table_name != NULL ||
	       (env_seg_addr_table_name != NULL && dylib_install_name != NULL)){
		if(seg_addr_table_name != NULL &&
		   env_seg_addr_table_name != NULL &&
		   strcmp(seg_addr_table_name, env_seg_addr_table_name) != 0){
		    warning("-seg_addr_table %s ignored, LD_SEG_ADDR_TABLE "
			    "environment variable: %s used instead",
			    seg_addr_table_name, env_seg_addr_table_name);
		}
		if(env_seg_addr_table_name != NULL){
		    seg_addr_table_name = env_seg_addr_table_name;
		    seg_addr_table = parse_seg_addr_table(seg_addr_table_name,
			"LD_SEG_ADDR_TABLE", "environment variable",
			&table_size);
		}
		else
		    seg_addr_table = parse_seg_addr_table(seg_addr_table_name,
			"-seg_addr_table", seg_addr_table_name, &table_size);
		if(seg_addr_table_filename != NULL)
		    seg_addr_table_entry = search_seg_addr_table(seg_addr_table,
						     seg_addr_table_filename);
		else
		    seg_addr_table_entry = search_seg_addr_table(seg_addr_table,
						     dylib_install_name);
		if(seg_addr_table_entry != NULL){
		    if(seg_addr_table_entry->split == TRUE){
	       		if(read_only_reloc_flag != READ_ONLY_RELOC_ERROR){
			    warning("-read_only_relocs %s ignored, when using "
				    "with format produced with the "
				    "-segs_read_only_addr option (via the "
				    "segment address table: %s %s line %u)",
		      		    read_only_reloc_flag ==
					READ_ONLY_RELOC_WARNING ?
				    "warning" : "suppress",
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			    read_only_reloc_flag = READ_ONLY_RELOC_ERROR;
			}
			if(seg1addr_specified){
			    warning("-seg1addr 0x%x ignored, using "
				    "-segs_read_only_addr 0x%x and "
				    "-segs_read_write_addr 0x%x from segment "
				    "address table: %s %s line %u",
				    (unsigned int)seg1addr,
				    (unsigned int)seg_addr_table_entry->
					    segs_read_only_addr,
				    (unsigned int)seg_addr_table_entry->
					    segs_read_write_addr,
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			}
			if(segs_read_only_addr_specified &&
			   segs_read_only_addr !=
				    seg_addr_table_entry->segs_read_only_addr){
			    warning("-segs_read_only_addr 0x%x ignored, using "
				    "-segs_read_only_addr 0x%x from segment "
				    "address table: %s %s line %u",
				    (unsigned int)segs_read_only_addr,
				    (unsigned int)seg_addr_table_entry->
					    segs_read_only_addr,
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			}
			if(segs_read_write_addr_specified &&
			   segs_read_write_addr !=
				    seg_addr_table_entry->segs_read_write_addr){
			    warning("-segs_read_write_addr 0x%x ignored, using "
				    "-segs_read_write_addr 0x%x from segment "
				    "address table: %s %s line %u",
				    (unsigned int)segs_read_write_addr,
				    (unsigned int)seg_addr_table_entry->
					    segs_read_write_addr,
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			}
			seg1addr_specified = FALSE;
			seg1addr = 0;
			segs_read_only_addr_specified = TRUE;
			segs_read_only_addr =
				seg_addr_table_entry->segs_read_only_addr;
			segs_read_write_addr_specified = TRUE;
			segs_read_write_addr =
				seg_addr_table_entry->segs_read_write_addr;
			if(segs_read_only_addr == 0 &&
			   segs_read_write_addr == 0){
			    segs_read_write_addr = get_shared_region_size_from_flag(&arch_flag);
			    warning("-segs_read_write_addr 0x0 ignored from "
				    "segment address table: %s %s line %u "
				    "using -segs_read_write_addr 0x%x",
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line,
				    (unsigned int)segs_read_write_addr);
			}
		    }
		    else{
			if(seg1addr_specified &&
			   seg1addr != seg_addr_table_entry->seg1addr){
			    warning("-seg1addr 0x%x ignored, using "
				    "-seg1addr 0x%x from segment address "
				    "table: %s %s line %u",
				    (unsigned int)seg1addr,
				    (unsigned int)seg_addr_table_entry->
					    seg1addr,
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			}
			if(segs_read_only_addr_specified){
			    warning("-segs_read_only_addr 0x%x ignored, using "
				    "-seg1addr 0x%x from segment address "
				    "table: %s %s line %u",
				    (unsigned int)segs_read_only_addr,
				    (unsigned int)seg_addr_table_entry->
					    seg1addr,
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			}
			if(segs_read_write_addr_specified){
			    warning("-segs_read_write_addr 0x%x ignored, using "
				    "-seg1addr 0x%x from segment address "
				    "table: %s %s line %u",
				    (unsigned int)segs_read_write_addr,
				    (unsigned int)seg_addr_table_entry->
					    seg1addr,
				    env_seg_addr_table_name != NULL ?
				    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
				    seg_addr_table_name,
				    seg_addr_table_entry->line);
			}
			seg1addr_specified = TRUE;
			seg1addr = seg_addr_table_entry->seg1addr;
			segs_read_only_addr_specified = FALSE;
			segs_read_only_addr = 0;
			segs_read_write_addr_specified = FALSE;
			segs_read_write_addr = 0;
		    }
		}
		else{
		    warning("%s %s not found in segment address table %s %s",
			    seg_addr_table_filename != NULL ?
			    "-seg_addr_table_filename" : "-dylib_install_name",
			    seg_addr_table_filename != NULL ?
			    seg_addr_table_filename : dylib_install_name,
			    env_seg_addr_table_name != NULL ?
			    "LD_SEG_ADDR_TABLE" : "-seg_addr_table",
			    seg_addr_table_name);
		}
	    }
	    /*
	     * If this is not a subframework then if it has an install name
	     * then guess its implied umbrella framework name from the
	     * install name.  Then if its install name is a framework name use
	     * that as the umbrella framework name.  Otherwise it is not
	     * considered an umbrella framework.
	     */
	    if(sub_framework == FALSE && dylib_install_name != NULL){
		umbrella_framework_name = guess_short_name(dylib_install_name,
			&is_framework, &has_suffix);
		if(umbrella_framework_name != NULL && is_framework == TRUE)
		    umbrella_framework = TRUE;
		else
		    umbrella_framework_name = NULL;
	    }
	    if(nallowable_clients != 0 && sub_framework == FALSE)
		fatal("-allowable_client flags can only be used when -umbrella "
		      "is also specified");
	}
	else{
	    if(segs_read_only_addr_specified)
		fatal("-segs_read_only_addr can only be used when -dylib "
		      "is also specified");
	    if(segs_read_write_addr_specified)
		fatal("-segs_read_write_addr can only be used when -dylib "
		      "is also specified");
	    if(seg_addr_table_name != NULL)
		fatal("-seg_addr_table can only be used when -dylib "
		      "is also specified");
	    if(sub_framework == TRUE)
		fatal("-umbrella %s can only be used when -dylib "
		      "is also specified", umbrella_framework_name);
	    if(nsub_umbrellas != 0)
		fatal("-sub_umbrella flags can only be used when -dylib "
		      "is also specified");
	    if(nsub_librarys != 0)
		fatal("-sub_library flags can only be used when -dylib "
		      "is also specified");
	    if(nallowable_clients != 0)
		fatal("-allowable_client flags can only be used when -dylib "
		      "is also specified");
	    if(moduletype_specified == TRUE)
		fatal("-single_module or -multi_module flags can only be used "
		      "when -dylib is also specified");
	}

	/*
	 * For Mac OS X 10.4 and later, prebinding will be limited to split
	 * shared libraries. So if this is not a split library then turn off
	 * prebinding.
	 */
	if(macosx_deployment_target.major >= 4){
	    if(filetype != MH_DYLIB){
		/* 
		 * If this is arm* or xscale, we want to prebind executables
		 * too, not just dylibs and frameworks. 
		 */
		if (!((arch_flag.name != NULL) && 
		      ((strncmp(arch_flag.name, "arm", 3) == 0) ||
		       (strcmp(arch_flag.name, "xscale") == 0))))
		{
		    if(prebinding_via_LD_PREBIND == FALSE &&
		       prebinding_flag_specified == TRUE &&
		       prebinding == TRUE){
			warning("-prebind ignored because MACOSX_DEPLOYMENT_TARGET "
				"environment variable greater or equal to 10.4");
		    }
		    prebinding = FALSE;
		}
	    }
	    /*
	     * This is an MH_DYLIB.  First see if it is on the list of libraries
	     * not to be prebound.  Then see if was specified to be built as a
	     * split, if not check LD_SPLITSEGS_NEW_LIBRARIES to see if we are
	     * forcing it to be a split library.
	     */
	    else{
		/*
		 * If this library was not in the seg_addr_table see if it is
		 * on the list of libraries not to be prebound. And if so turn
		 * off prebinding.  Note this list is only ever used when
		 * macosx_deployment_target.major >= 4 .
		 */
		if(seg_addr_table_entry == NULL &&
		   unprebound_library(dylib_install_name,
				      seg_addr_table_filename) == TRUE){
		    if(prebinding_flag_specified == TRUE &&
		       prebinding == TRUE){
			warning("-prebind ignored because -install_name %s "
				"listed in LD_UNPREBOUND_LIBRARIES environment "
				"variable file: %s", dylib_install_name,
				getenv("LD_UNPREBOUND_LIBRARIES"));
		    }
		    prebinding = FALSE;
		}
		else{
		    /*
		     * This is not on the list of libraries not to be prebound,
		     * and if there was no seg_addr_table entry for this then
		     * force this to be a split library.  Note even if
		     * prebinding was not specified we will still force this to
		     * be a split library.
		     */
		    if(seg_addr_table_entry == NULL &&
		       getenv("LD_SPLITSEGS_NEW_LIBRARIES") != NULL){
		    unsigned long arch_rw_addr =
			get_shared_region_size_from_flag(&arch_flag);

			if(seg1addr_specified){
			    warning("-seg1addr 0x%x ignored, using "
				    "-segs_read_only_addr 0x%x and "
				    "-segs_read_write_addr 0x%x because "
				    "LD_SPLITSEGS_NEW_LIBRARIES environment is "
				    "set",(unsigned int)seg1addr, 0,
				    (unsigned int)arch_rw_addr);
			}
			seg1addr_specified = FALSE;
			seg1addr = 0;
			segs_read_only_addr_specified = TRUE;
			segs_read_only_addr = 0;
			segs_read_write_addr = arch_rw_addr;
		    }
		    /*
		     * Finally if this is not a split library then turn off
		     * prebinding.
		     */
		    if(segs_read_only_addr_specified == FALSE){
			if(prebinding_via_LD_PREBIND == FALSE &&
			   prebinding_flag_specified == TRUE &&
			   prebinding == TRUE){
			    warning("-prebind ignored because "
				    "MACOSX_DEPLOYMENT_TARGET environment "
				    "variable greater or equal to 10.4");
			}
			prebinding = FALSE;
		    }
		}
	    }
	}

	if(filetype == MH_BUNDLE){
	    if(dynamic == FALSE)
		fatal("incompatible flag -bundle used (must specify "
		      "\"-dynamic\" to be used)");
	    if(save_reloc)
		fatal("can't use -r and -bundle (flags are mutually "
		      "exclusive, only one or the other can be used)");
	    if(strip_level == STRIP_ALL)
		fatal("can't use -s with -bundle (file must contain "
		      "at least global symbols, for maximum stripping use -x)");
	    if(Aflag_specified)
		fatal("can't use -A and -bundle");
	    if(keep_private_externs == TRUE)
		fatal("can't use -keep_private_externs and -bundle");
	    if(segaddr_specified)
		fatal("can't use -segaddr options with -bundle (use "
		      "seg1addr to specify the starting address)");
	    if(seglinkedit_specified && seglinkedit == FALSE)
		fatal("can't use -noseglinkedit with -bundle "
		      "(resulting file must have a link edit segment to access "
		      "symbols)");
	    if(prebinding == TRUE){
		if(prebinding_flag_specified == TRUE)
		    warning("-prebind has no effect with -bundle");
		prebinding = FALSE;
	    }
	    if(private_bundle == TRUE && twolevel_namespace == TRUE)
		warning("-private_bundle has no effect when "
			"-twolevel_namespace is in effect");
	    if(twolevel_namespace_hints_specified != TRUE)
		twolevel_namespace_hints = FALSE;
	}
	else{
	    if(client_name != NULL)
		fatal("-client_name %s flag can only be used with -bundle",
		      client_name);
	    if(bundle_loader != NULL)
		fatal("-bundle_loader %s flag can only be used with -bundle",
		      bundle_loader);
	    if(private_bundle == TRUE)
		fatal("-private_bundle flag can only be used with -bundle");
	}
	if(filetype != MH_DYLINKER){
	    if(dylinker_install_name != NULL)
		warning("flag: -dylinker_install_name %s ignored (-dylinker "
			"was not specified", dylinker_install_name);
	}
	if(filetype != MH_DYLIB){
	    if(dylib_install_name != NULL)
		warning("flag: -dylib_install_name %s ignored (-dylib "
			"was not specified", dylib_install_name);
	    if(dylib_current_version != 0)
		warning("flag: -dylib_current_version %u ignored (-dylib "
			"was not specified", dylib_current_version);
	    if(dylib_compatibility_version != 0)
		warning("flag: -dylib_compatibility_version %u ignored (-dylib"
			" was not specified", dylib_compatibility_version);
	    if(init_name != NULL)
		warning("flag: -init %s ignored (-dylib was not specified",
			init_name);
	}
	if(twolevel_namespace == TRUE &&
	   undefined_flag != UNDEFINED_ERROR &&
	   undefined_flag != UNDEFINED_DYNAMIC_LOOKUP &&
	   undefined_flag != UNDEFINED_DEFINE_A_WAY){
	    if(macosx_deployment_target.major >= 3)
		fatal("-undefined error, -undefined dynamic_lookup or "
		      "-undefined define_a_way must be used when "
		      "-twolevel_namespace is in effect");
	    else
		fatal("-undefined error or -undefined define_a_way must be "
		      "used when -twolevel_namespace is in effect");
	}
	if(undefined_flag == UNDEFINED_DYNAMIC_LOOKUP){
	    if(dynamic == FALSE)
		fatal("incompatible flag -undefined dynamic_lookup used (must "
		      "specify \"-dynamic\" to be used)");
	    if(macosx_deployment_target.major < 3)
		fatal("flag: -undefined dynamic_lookup can't be used with "
		      "MACOSX_DEPLOYMENT_TARGET environment variable set to: "
		      "%s", macosx_deployment_target.name);
	}
	if(twolevel_namespace == TRUE && nundef_syms != 0){
	    fatal("can't use -U flags when -twolevel_namespace is in effect");
	}
	if(nomultidefs == TRUE){
	    if(multiply_defined_flag_specified == TRUE &&
	       multiply_defined_flag != MULTIPLY_DEFINED_ERROR)
		fatal("-multiply_defined error must be used when -nomultidefs "
		      "is specified");
	   multiply_defined_flag = MULTIPLY_DEFINED_ERROR;
	}
	if(prebinding == TRUE && undefined_flag == UNDEFINED_SUPPRESS){
	    if(prebinding_flag_specified == TRUE)
		warning("-undefined suppress disables -prebind");
	    prebinding = FALSE;
	}
	if(prebinding == TRUE && save_reloc){
	    if(prebinding_flag_specified == TRUE)
		warning("-r disables -prebind");
	    prebinding = FALSE;
	}
	if(prebinding == TRUE && dynamic == FALSE){
	    prebinding = FALSE;
	}

	/*
	 * If the output file name as not specified set it to the default name
	 * "a.out".  This needs to be done before any segments are merged
	 * because this is used when merging them (the 'filename' field in a
	 * merged_segment is set to it).
	 */
	if(outputfile == NULL)
	    outputfile = "a.out";
	/*
	 * If the -A flag is specified and the file type has not been specified
	 * then make the output file type MH_OBJECT.
	 */
	if(Aflag_specified == TRUE && filetype_specified == FALSE)
	    filetype = MH_OBJECT;

	/*
	 * If neither the -seglinkedit or -noseglinkedit has been specified then
	 * set creation of this segment if the output file type can have one.
	 * If -seglinkedit has been specified make sure the output file type
	 * can have one.
	 */
	if(seglinkedit_specified == FALSE){
	    if(filetype == MH_EXECUTE || filetype == MH_BUNDLE ||
	       filetype == MH_FVMLIB ||
	       filetype == MH_DYLIB || filetype == MH_DYLINKER)
		seglinkedit = TRUE;
	    else
		seglinkedit = FALSE;
	}
	else{
	    if(seglinkedit &&
	       (filetype != MH_EXECUTE && filetype != MH_BUNDLE &&
		filetype != MH_FVMLIB &&
		filetype != MH_DYLIB && filetype != MH_DYLINKER))
		fatal("link edit segment can't be created (wrong output file "
		      "type, file type must be MH_EXECUTE, MH_BUNDLE, "
		      "MH_DYLIB, MH_DYLINKER or MH_FVMLIB)");
	}
	if(allow_stack_execute == TRUE && filetype != MH_EXECUTE)
	    fatal("-allow_stack_execute can only be used when output file type "
		  "is MH_EXECUTE");

	if(trace)
	    print("%s: Pass 1\n", progname);
	/*
	 * This pass of parsing arguments only processes object files
	 * and creation of symbols now that all the options are set.
	 * This are order dependent and must be processed as they appear
	 * on the command line.
	 */
	symbols_created = 0;
	objects_specified = 0;
	sections_created = 0;
	/*
	 * If a -bundle_loader is specified and this is a flat_namespace
	 * output force the bundle_loader to be loaded first.
	 */
	if(bundle_loader != NULL && twolevel_namespace == FALSE){
	    pass1(bundle_loader, FALSE, FALSE, FALSE, TRUE, FALSE);
	}
	for(i = 1 ; i < argc ; i++){
	    if(*argv[i] != '-'){
		/* just a normal object file name */
		pass1(argv[i], FALSE, FALSE, FALSE, FALSE, FALSE);
		objects_specified++;
	    }
	    else{
		p = &(argv[i][1]);
		switch(*p){
		case 'b':
		    if(strcmp(p, "bundle_loader") == 0){
			/*
			 * If a -bundle_loader was specified and this is a
			 * flat_namespace output force the bundle_loader was
			 * loaded first above.
			 */
			if(twolevel_namespace == TRUE)
			    pass1(argv[i+1], FALSE, FALSE, FALSE, TRUE, FALSE);
			i++;
			break;
		    }
		    break;
		case 'l':
		    /* path searched abbrevated file name */
		    pass1(argv[i], TRUE, FALSE, FALSE, FALSE, FALSE);
		    objects_specified++;
		    break;
		case 'A':
		    if(base_obj != NULL)
			fatal("only one -A argument can be specified");
		    pass1(argv[++i], FALSE, TRUE, FALSE, FALSE, FALSE);
		    objects_specified++;
		    break;
		case 'f':
		    if(strcmp(p, "framework") == 0){
			if(dynamic == FALSE)
			    fatal("incompatible flag -framework used (must "
				  "specify \"-dynamic\" to be used)");
			pass1(argv[++i], FALSE, FALSE, TRUE, FALSE, FALSE);
			objects_specified++;
		    }
		    if(strcmp(p, "filelist") == 0){
			filelist = argv[++i];
			dirname = strrchr(filelist, ',');
			if(dirname != NULL){
			    *dirname = '\0';
			    dirname++;
			}
			else
			    dirname = "";
			if((fd = open(filelist, O_RDONLY, 0)) == -1)
			    system_fatal("can't open file list file: %s",
				         filelist);
			if(fstat(fd, &stat_buf) == -1)
			    system_fatal("can't stat file list file: %s",
					 filelist);
			/*
			 * For some reason mapping files with zero size fails
			 * so it has to be handled specially.
			 */
			if(stat_buf.st_size != 0){
			    if((r = map_fd((int)fd, (vm_offset_t)0,
				(vm_offset_t *)&(addr), (boolean_t)TRUE,
				(vm_size_t)stat_buf.st_size)) != KERN_SUCCESS)
				mach_fatal(r, "can't map file list file: %s",
				    filelist);
			}
			else{
			    fatal("file list file: %s is empty", filelist);
			}
			close(fd);
			file_name = addr;
			for(j = 0; j < stat_buf.st_size; j++){
			    if(addr[j] == '\n'){
				addr[j] = '\0';
				if(*dirname != '\0'){
				    file_name = mkstr(dirname, "/",
						      file_name, NULL);
				}
				pass1(file_name, FALSE, FALSE, FALSE, FALSE,
				      FALSE);
				objects_specified++;
				file_name = addr + j + 1;
			    }
			}
		    }
		    if(strcmp(p, "final_output") == 0)
			i++;
		    break;
		case 'm':
		    if(strcmp(p, "multiply_defined") == 0 ||
		       strcmp(p, "multiply_defined_unused") == 0 ||
		       strcmp(p, "macosx_version_min") == 0){
			i++;
			break;
		    }
		    break;
		case 'u':
		    if(strcmp(p, "undefined") == 0 ||
		       strcmp(p, "umbrella") == 0 ||
		       strcmp(p, "unexported_symbols_list") == 0){
			i++;
			break;
		    }
		    /* cause the specified symbol name to be undefined */
		    (void)command_line_symbol(argv[++i]);
		    symbols_created++;
		    break;
		case 'i':
		    if(strcmp(p, "image_base") == 0){
			i++;
			break;
		    }
		    else if(strcmp(p, "init") == 0){
			i++;
			break;
		    }
		    else if(strcmp(p, "install_name") == 0){
		        i++;
			break;
		    }
		    /* create an indirect symbol, symbol_name, to be an indirect
		       symbol for indr_symbol_name */
		    symbol_name = p + 1;
	  	    indr_symbol_name = strchr(p + 1, ':');
		    *indr_symbol_name = '\0';
		    indr_symbol_name++;
		    command_line_indr_symbol(symbol_name, indr_symbol_name);
		    symbols_created++;
		    break;

		/* multi argument flags */
		case 'a':
		    if(strcmp(p, "all_load") == 0 ||
		       strcmp(p, "arch_multiple") == 0 ||
		       strcmp(p, "arch_errors_fatal") == 0 ||
		       strcmp(p, "allow_stack_execute") == 0)
			break;
		    i++;
		    break;
		case 'c':
		    i++;
		    break;
		case 'p':
		    if(strcmp(p, "pagezero_size") == 0){
			i++;
			break;
		    }
		    break;
		case 's':
		    if(strcmp(p, "sectcreate") == 0 ||
		       strcmp(p, "segcreate") == 0){
			sections_created++;
			i += 3;
		    }
		    else if(strcmp(p, "sectalign") == 0 ||
		            strcmp(p, "segprot") == 0 ||
		            strcmp(p, "sectorder") == 0)
			i += 3;
		    else if(strcmp(p, "segaddr") == 0 ||
			    strcmp(p, "sect_diff_relocs") == 0 ||
		            strcmp(p, "sectobjectsymbols") == 0)
			i += 2;
		    else if(strcmp(p, "seg1addr") == 0 ||
		            strcmp(p, "stack_addr") == 0 ||
		            strcmp(p, "stack_size") == 0 ||
		            strcmp(p, "segalign") == 0 ||
			    strcmp(p, "segs_read_only_addr") == 0 ||
			    strcmp(p, "segs_read_write_addr") == 0 ||
			    strcmp(p, "seg_addr_table") == 0 ||
			    strcmp(p, "seg_addr_table_filename") == 0 ||
			    strcmp(p, "sub_umbrella") == 0 ||
			    strcmp(p, "sub_library") == 0 ||
			    strcmp(p, "syslibroot") == 0)
			i++;
		    break;
		case 'r':
		    if(strcmp(p, "r") == 0 ||
		       strcmp(p, "run_init_lazily") == 0)
			break;
		    i++;
		    break;
		case 'o':
		    if(strcmp(p, "object") == 0)
			break;
		    i++;
		    break;
		case 'e':
		    if(strcmp(p, "execute") == 0)
			break;
		    i++;
		    break;
		case 'd':
		    if(strcmp(p, "d") == 0 ||
		       strcmp(p, "dylib") == 0 ||
		       strcmp(p, "dylinker") == 0 ||
		       strcmp(p, "dynamic") == 0 ||
		       strcmp(p, "dead_strip") == 0)
			break;
		    i++;
		    break;
		case 'h':
		    if(strcmp(p, "headerpad_max_install_names") == 0)
			break;
		    i++;
		    break;
		case 'U':
		case 'N':
		case 'Y':
		    i++;
		    break;
		case 'w':
		    if(strcmp(p, "weak_reference_mismatches") == 0)
			i++;
		    else if(strcmp(p, "weak_library") == 0){
			pass1(argv[++i], FALSE, FALSE, FALSE, FALSE, TRUE);
			objects_specified++;
		    }
		    else if(strncmp(p, "weak-l", sizeof("weak-l") - 1) == 0){
			/* path searched abbrevated file name */
			pass1(argv[i] + sizeof("weak"), TRUE, FALSE, FALSE,
			      FALSE, TRUE);
			objects_specified++;
		    }
		    else if(strcmp(p, "weak_framework") == 0){
			if(dynamic == FALSE)
			    fatal("incompatible flag -weak_framework used (must"
				  " specify \"-dynamic\" to be used)");
			pass1(argv[++i], FALSE, FALSE, TRUE, FALSE, TRUE);
			objects_specified++;
		    }
		    break;
		}
	    }
	}

 	/*
	 * If the architecture was not specified, and was inferred
	 * from the object files, if it is a 64-bit architecture it is an error.
	 */
	if(arch_flag.cputype != 0 &&
	    arch_flag.cputype & CPU_ARCH_ABI64){
	    fatal("does not support 64-bit architectures");
	}

	/*
	 * Now search the libraries on the dynamic shared libraries search list
	 */
	search_dynamic_libs();

	/*
	 * Check to see that the output file will have something in it.
	 */
	if(objects_specified == 0){
	    if(symbols_created != 0 || sections_created != 0){
		warning("no object files specified, only command line created "
			"symbols and/or sections created from files will "
			"appear in the output file");
		if(arch_flag.name == NULL)
		    target_byte_sex = host_byte_sex;
		segalign = host_pagesize;
	    }
	    else{
		if(vflag == TRUE)
		    ld_exit(0);
		fatal("no object files specified");
	    }
	}
	else if(base_obj != NULL && nobjects == 1){
	    if(symbols_created != 0 || sections_created != 0)
		warning("no object files loaded other than base file, only "
			"additional command line created symbols and/or "
			"sections created from files will appear in the output "
			"file");
	    else{
		if(vflag == TRUE)
		    ld_exit(0);
		fatal("no object files loaded other than base file");
	    }
	}
	else if(nobjects == 0){
	    if(symbols_created != 0 || sections_created != 0)
		warning("no object files loaded, only command line created "
			"symbols and/or sections created from files will "
			"appear in the output file");
	    else{
		if(vflag == TRUE)
		    ld_exit(0);
		fatal("no object files loaded");
	    }
	}

#ifdef DEBUG
	if(debug & (1 < 0))
	    print_object_list();
	if(debug & (1 << 1))
	    print_merged_sections("after pass1");
	if(debug & (1 << 2))
	    print_symbol_list("after pass1", TRUE);
	if(debug & (1 << 3))
	    print_undefined_list();
	if(debug & (1 << 4))
	    print_segment_specs();
	if(debug & (1 << 5))
	    print_load_fvmlibs_list();
	if(debug & (1 << 6))
	    print_fvmlib_segments();
	if(debug & (1 << 9)){
	    print("Number of objects loaded = %lu\n", nobjects);
	    print("Number of merged symbols = %lu\n", nmerged_symbols);
	}
#endif /* DEBUG */

	/*
	 * If there were any errors from pass1() then don't continue.
	 */
	if(errors != 0)
	    ld_exit(1);

	/*
	 * Print which files are loaded if requested.
	 */
	if(whatsloaded == TRUE)
	    print_whatsloaded();

	/*
	 * Clean up any data structures not need for layout() or pass2().
	 */
	if(nsearch_dirs != 0){
	    free(search_dirs);
	    nsearch_dirs = 0;
	}

	/*
	 * Layout the output object file.
	 */
	layout();

	/*
	 * Check to that the exported or unexported symbols listed were seen.
	 */
	if(save_symbols != NULL){
	    missing_syms = FALSE;
	    for(j = 0; j < nsave_symbols ; j++){
		if(save_symbols[j].seen == FALSE){
		    if(missing_syms == FALSE){
			error("symbols names listed in "
			      "-exported_symbols_list: %s not in linked "
			      "objects", exported_symbols_list);
			missing_syms = TRUE;
		    }
		    printf("%s\n", save_symbols[j].name);
		}
	    }
	}

	/*
	 * If there were any errors from layout() then don't continue.
	 */
	if(errors != 0)
	    ld_exit(1);

	/*
	 * Clean up any data structures not need for pass2().
	 */
	free_pass1_symbol_data();
	if(ntrace_syms != 0){
	    free(trace_syms);
	    ntrace_syms = 0;
	}
	if(nundef_syms != 0){
	    free(undef_syms);
	    nundef_syms = 0;
	}

	/*
	 * Write the output object file doing relocation on the sections.
	 */
	if(trace)
	    print("%s: Pass 2\n", progname);
	pass2();
	/*
	 * If there were any errors from pass2() make sure the output file is
	 * removed and exit non-zero.
	 */
	if(errors != 0)
	    cleanup();

	if(hash_instrument_specified == TRUE)
	    hash_instrument();

	ld_exit(0);

	/* this is to remove the compiler warning, it never gets here */
	return(0);
}

/*
 * unprebound_library() checks the file for the environment variable
 * LD_UNPREBOUND_LIBRARIES to see if the dynamic library is one listed as to
 * not be prebound.  The dynamic library is specified with the
 * dylib_install_name unless seg_addr_table_filename is not NULL then
 * seg_addr_table_filename is used.  If it is found on the list then TRUE is
 * returned.  If not FALSE is returned.
 */
static
enum bool
unprebound_library(
char *dylib_install_name,
char *seg_addr_table_filename)
{
    int fd;
    kern_return_t r;
    struct stat stat_buf;
    unsigned long j, file_size, line;
    char *file_name, *library_name, *file_addr, *name, *end;

	/*
	 * If there is no file name then it is not on the list and return FALSE.
	 */
	file_name = getenv("LD_UNPREBOUND_LIBRARIES");
	if(file_name == NULL)
	    return(FALSE);

	/*
	 * If there is no library name then it is not on the list and return
	 * FALSE.
	 */
	if(seg_addr_table_filename != NULL)
	    library_name = dylib_install_name;
	else if(dylib_install_name != NULL)
	    library_name = dylib_install_name;
	else
	    return(FALSE);


	if((fd = open(file_name, O_RDONLY, 0)) == -1)
	    system_fatal("Can't open: %s for LD_UNPREBOUND_LIBRARIES "
			 "environment variable", file_name);
	if(fstat(fd, &stat_buf) == -1)
	    system_fatal("Can't stat file: %s for LD_UNPREBOUND_LIBRARIES "
		    	 "environment variable", file_name);
	/*
	 * For some reason mapping files with zero size fails
	 * so it has to be handled specially.
	 */
	if(stat_buf.st_size != 0){
	    if((r = map_fd((int)fd, (vm_offset_t)0,
		(vm_offset_t *)&file_addr, (boolean_t)TRUE,
		(vm_size_t)stat_buf.st_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't map file: %s for LD_UNPREBOUND_LIBRARIES "
			   "environment variable", file_name);
	}
	else
	    fatal("Empty file: %s for LD_UNPREBOUND_LIBRARIES environment "
		  "variable", file_name);
	close(fd);
	file_size = stat_buf.st_size;

	/*
	 * Got the file mapped now parse it.
	 */
	if(file_addr[file_size - 1] != '\n')
	    fatal("file: %s for LD_UNPREBOUND_LIBRARIES environment variable "
		  "does not end in new line", file_name);

	line = 1;
	for(j = 0; j < file_size; /* no increment expression */ ){
	    /* Skip lines that start with '#' */
	    if(file_addr[j] == '#'){
		j++;
		while(file_addr[j] != '\n')
		    j++;
		continue;
	    }
	    /* Skip blank lines and leading white space */
	    while(file_addr[j] == ' ' || file_addr[j] == '\t')
		j++;
	    if(file_addr[j] == '\n'){
		j++;
		line++;
		continue;
	    }
	    if(j == file_size)
		fatal("missing library install name on line %lu in file: "
		      "%s for LD_UNPREBOUND_LIBRARIES environment variable",
		      line, file_name);

	    name = file_addr + j;
	    while(file_addr[j] != '\n')
		j++;
	    file_addr[j] = '\0';
	    end = file_addr + j;
	    line++;
	    j++;

	    /* Trim trailing spaces */
	    end--;
	    while(end > name && (*end == ' ' || *end == '\t')){
		*end = '\0';
		end--;
	    }

	    /* finally compare the name on this line with the library name */
	    if(strcmp(library_name, name) == 0)
		return(TRUE);
	}

	return(FALSE);
}

/*
 * ispoweroftwo() returns TRUE or FALSE depending if x is a power of two.
 */
static
enum
bool
ispoweroftwo(
unsigned long x)
{
	if(x == 0)
	    return(TRUE);
	while((x & 0x1) != 0x1){
	    x >>= 1;
	}
	if((x & ~0x1) != 0)
	    return(FALSE);
	else
	    return(TRUE);
}

/*
 * getprot() returns the vm_prot for the specified string passed to it.  The
 * string may contain any of the following characters: 'r', 'w', 'x' and '-'
 * representing read, write, execute and no protections.  The pointer pointed
 * to by endp is set to the first character that is not one of the above
 * characters.
 */
static
vm_prot_t
getprot(
char *prot,
char **endp)
{
    vm_prot_t vm_prot;

	vm_prot = VM_PROT_NONE;
	while(*prot){
	    switch(*prot){
	    case 'r':
	    case 'R':
		vm_prot |= VM_PROT_READ;
		break;
	    case 'w':
	    case 'W':
		vm_prot |= VM_PROT_WRITE;
		break;
	    case 'x':
	    case 'X':
		vm_prot |= VM_PROT_EXECUTE;
		break;
	    case '-':
		break;
	    default:
		*endp = prot;
		return(vm_prot);
	    }
	    prot++;
	}
	*endp = prot;
	return(vm_prot);
}

/*
 * check_max_init_prot() checks to make sure that all protections in the initial
 * protection are also in the maximum protection.
 */
static
enum bool
check_max_init_prot(
vm_prot_t maxprot,
vm_prot_t initprot)
{
	if(((initprot & VM_PROT_READ)    && !(maxprot & VM_PROT_READ)) ||
	   ((initprot & VM_PROT_WRITE)   && !(maxprot & VM_PROT_WRITE)) ||
	   ((initprot & VM_PROT_EXECUTE) && !(maxprot & VM_PROT_EXECUTE)) )
	return(FALSE);
	return(TRUE);
}

/*
 * ld_exit() is use for all exit()s from the link editor.
 */
static
void
ld_exit(
int exit_value)
{
	exit(exit_value);
}

/*
 * cleanup() is called by all routines handling fatal errors to remove the
 * output file if it had been created by the link editor and exit non-zero.
 */
static
void
cleanup(void)
{
	if(output_addr != NULL)
	    unlink(outputfile);
	ld_exit(1);
}

/*
 * handler() is the routine for catching SIGINT, SIGTERM, SIGBUG & SIGSEGV
 *  signals. It cleans up and exit()'s non-zero.
 */
static
void
handler(
int sig)
{
#ifdef __MWERKS__
    int dummy;
        dummy = sig;
#endif
	if(output_addr != NULL)
	    unlink(outputfile);
	_exit(1);
}

/*
 * allocate() is just a wrapper around malloc that prints and error message and
 * exits if the malloc fails.
 */
__private_extern__
void *
allocate(
unsigned long size)
{
    void *p;

	if(size == 0)
	    return(NULL);
	if((p = malloc(size)) == NULL)
	    system_fatal("virtual memory exhausted (malloc failed)");
	return(p);
}

/*
 * reallocate() is just a wrapper around realloc that prints and error message
 * and exits if the realloc fails.
 */
__private_extern__
void *
reallocate(
void *p,
unsigned long size)
{
	if(p == NULL)
	    return(allocate(size));
	if((p = realloc(p, size)) == NULL)
	    system_fatal("virtual memory exhausted (realloc failed)");
	return(p);
}

/*
 * savestr() malloc's space for the string passed to it, copys the string into
 * the space and returns a pointer to that space.
 */
__private_extern__
char *
savestr(
const char *s)
{
    long len;
    char *r;

	len = strlen(s) + 1;
	r = (char *)allocate(len);
	strcpy(r, s);
	return(r);
}

/*
 * Mkstr() creates a string that is the concatenation of a variable number of
 * strings.  It is pass a variable number of pointers to strings and the last
 * pointer is NULL.  It returns the pointer to the string it created.  The
 * storage for the string is malloc()'ed can be free()'ed when nolonger needed.
 */
static
char *
mkstr(
const char *args,
...)
{
    va_list ap;
    char *s, *p;
    unsigned long size;

	size = 0;
	if(args != NULL){
	    size += strlen(args);
	    va_start(ap, args);
	    p = (char *)va_arg(ap, char *);
	    while(p != NULL){
		size += strlen(p);
		p = (char *)va_arg(ap, char *);
	    }
	}
	s = allocate(size + 1);
	*s = '\0';

	if(args != NULL){
	    (void)strcat(s, args);
	    va_start(ap, args);
	    p = (char *)va_arg(ap, char *);
	    while(p != NULL){
		(void)strcat(s, p);
		p = (char *)va_arg(ap, char *);
	    }
	    va_end(ap);
	}
	return(s);
}
#endif /* !defined(RLD) */

/*
 * rnd() rounds v to a multiple of r.
 */
__private_extern__
unsigned long
rnd(
unsigned long v,
unsigned long r)
{
	r--;
	v += r;
	v &= ~(long)r;
	return(v);
}

#ifndef RLD
#include "stuff/unix_standard_mode.h"
/*
 * All printing of all messages goes through this function.
 */
__private_extern__
void
vprint(
const char *format,
va_list ap)
{
	if(get_unix_standard_mode() == TRUE)
	    vfprintf(stderr, format, ap);
	else
	    vprintf(format, ap);
}
#endif /* !defined(RLD) */

/*
 * The print function that just calls the above vprint() function.
 */
__private_extern__
void
print(
const char *format,
...)
{
    va_list ap;

	va_start(ap, format);
	vprint(format, ap);
	va_end(ap);
}

/*
 * The ld_trace function that logs things for B&I.
 */
__private_extern__
void
ld_trace(
const char *format,
...)
{
#ifdef KLD
    va_list ap;

	va_start(ap, format);
	vprint(format, ap);
	va_end(ap);
#else
	static int trace_file = -1;
	char trace_buffer[MAXPATHLEN * 2];
	char *buffer_ptr;
	int length;
	ssize_t amount_written;

	if(trace_file == -1){
		if(trace_file_path != NULL){
			trace_file = open(trace_file_path, O_WRONLY | O_APPEND | O_CREAT, 0666);
			if(trace_file == -1)
				fatal("Could not open or create trace file: %s\n", trace_file_path);
		}
		else{
			trace_file = fileno(stderr);
		}
	}
    va_list ap;

	va_start(ap, format);
	length = vsnprintf(trace_buffer, sizeof(trace_buffer), format, ap);
	va_end(ap);
	buffer_ptr = trace_buffer;
	while(length > 0){
		amount_written = write(trace_file, buffer_ptr, length);
		if(amount_written == -1)
			/* Failure to write shouldn't fail the build. */
			return;
		buffer_ptr += amount_written;
		length -= amount_written;
	}
#endif
}

static
void
print_architecture_banner(void)
{
    static enum bool printed = FALSE;

	if(arch_multiple == TRUE && printed == FALSE && arch_flag.name != NULL){
	    print("%s: for architecture %s\n", progname, arch_flag.name);
	    printed = TRUE;
	}
}

/*
 * Print the warning message.  This is non-fatal and does not set 'errors'.
 */
__private_extern__
void
warning(
const char *format,
...)
{
    va_list ap;

	if(nowarnings == TRUE)
	    return;
	if(arch_multiple)
	    print_architecture_banner();
	va_start(ap, format);
        print("%s: warning ", progname);
	vprint(format, ap);
        print("\n");
	va_end(ap);
}

/*
 * Print the error message and set the 'error' indication.
 */
__private_extern__
void
error(
const char *format,
...)
{
    va_list ap;

	if(arch_multiple)
	    print_architecture_banner();
	va_start(ap, format);
        print("%s: ", progname);
	vprint(format, ap);
        print("\n");
	va_end(ap);
	errors = 1;
}

/*
 * Print the fatal error message, and exit non-zero.
 */
__private_extern__
void
fatal(
const char *format,
...)
{
    va_list ap;

	if(arch_multiple)
	    print_architecture_banner();
	va_start(ap, format);
        print("%s: ", progname);
	vprint(format, ap);
        print("\n");
	va_end(ap);
	cleanup();
}

/*
 * Print the current object file name and warning message.
 */
__private_extern__
void
warning_with_cur_obj(
const char *format,
...)
{
    va_list ap;

	if(nowarnings == TRUE)
	    return;
	if(arch_multiple)
	    print_architecture_banner();
	va_start(ap, format);
        print("%s: warning ", progname);
	print_obj_name(cur_obj);
	vprint(format, ap);
        print("\n");
	va_end(ap);
}

/*
 * Print the current object file name and error message, set the non-fatal
 * error indication.
 */
__private_extern__
void
error_with_cur_obj(
const char *format,
...)
{
    va_list ap;

	if(arch_multiple)
	    print_architecture_banner();
	va_start(ap, format);
        print("%s: ", progname);
	print_obj_name(cur_obj);
	vprint(format, ap);
        print("\n");
	va_end(ap);
	errors = 1;
}

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
/*
 * Print the warning message along with the system error message.
 */
__private_extern__
void
system_warning(
const char *format,
...)
{
    va_list ap;
    int errnum;

	if(arch_multiple)
	    print_architecture_banner();
	errnum = errno;
	va_start(ap, format);
        print("%s: warning ", progname);
	vprint(format, ap);
	print(" (%s, errno = %d)\n", strerror(errnum), errnum);
	va_end(ap);
}

/*
 * Print the error message along with the system error message, set the
 * non-fatal error indication.
 */
__private_extern__
void
system_error(
const char *format,
...)
{
    va_list ap;
    int errnum;

	if(arch_multiple)
	    print_architecture_banner();
	errnum = errno;
	va_start(ap, format);
        print("%s: ", progname);
	vprint(format, ap);
	print(" (%s, errno = %d)\n", strerror(errnum), errnum);
	va_end(ap);
	errors = 1;
}

/*
 * Print the fatal message along with the system error message, and exit
 * non-zero.
 */
__private_extern__
void
system_fatal(
const char *format,
...)
{
    va_list ap;
    int errnum;

	if(arch_multiple)
	    print_architecture_banner();
	errnum = errno;
	va_start(ap, format);
        print("%s: ", progname);
	vprint(format, ap);
	print(" (%s, errno = %d)\n", strerror(errnum), errnum);
	va_end(ap);
	cleanup();
}
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

/*
 * Print the fatal error message along with the mach error string, and exit
 * non-zero.
 */
__private_extern__
void
mach_fatal(
kern_return_t r,
char *format,
...)
{
    va_list ap;

	if(arch_multiple)
	    print_architecture_banner();
	va_start(ap, format);
        print("%s: ", progname);
	vprint(format, ap);
	print(" (%s)\n", mach_error_string(r));
	va_end(ap);
	cleanup();
}
                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/ld.h                                     0100644 0001750 0001750 00000032504 12612724205 021612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file ld.c.
 *
 * The following include file need to be included before this file:
 * #include <sys/loader.h>
 * #include <mach.h>
 * #include <stdarg.h>  (included in <stdio.h>)
 */

/* Type for the possible levels of stripping, in increasing order */
enum strip_levels {
    STRIP_NONE,
    STRIP_DUP_INCLS,
    STRIP_L_SYMBOLS,
    STRIP_MIN_DEBUG,
    STRIP_DEBUG,
    STRIP_NONGLOBALS,
    STRIP_DYNAMIC_EXECUTABLE,
    STRIP_ALL
};

/* The error level check for undefined symbols */
enum undefined_check_level {
    UNDEFINED_ERROR,
    UNDEFINED_WARNING,
    UNDEFINED_SUPPRESS,
    UNDEFINED_DYNAMIC_LOOKUP,
    UNDEFINED_DEFINE_A_WAY
};

/* The error level check for (twolevel namespace) multiply defined symbols */
enum multiply_defined_check_level {
    MULTIPLY_DEFINED_ERROR,
    MULTIPLY_DEFINED_WARNING,
    MULTIPLY_DEFINED_SUPPRESS
};

/* The error level check for read only relocs */
enum read_only_reloc_check_level {
    READ_ONLY_RELOC_ERROR,
    READ_ONLY_RELOC_WARNING,
    READ_ONLY_RELOC_SUPPRESS
};

/* The error level check for section difference relocs */
enum sect_diff_reloc_check_level {
    SECT_DIFF_RELOC_ERROR,
    SECT_DIFF_RELOC_WARNING,
    SECT_DIFF_RELOC_SUPPRESS
};

/* The error handling for weak reference mismatches */
enum weak_reference_mismatches_handling {
    WEAK_REFS_MISMATCH_ERROR,
    WEAK_REFS_MISMATCH_WEAK,
    WEAK_REFS_MISMATCH_NON_WEAK
};

__private_extern__ struct macosx_deployment_target macosx_deployment_target;

/* name of this program as executed (argv[0]) */
__private_extern__ char *progname;
/* indication of an error set in error(), for processing a number of errors
   and then exiting */
__private_extern__ unsigned long errors;
/* the pagesize of the machine this program is running on, getpagesize() value*/
__private_extern__ unsigned long host_pagesize;
/* the byte sex of the machine this program is running on */
__private_extern__ enum byte_sex host_byte_sex;

/* name of output file */
__private_extern__ char *outputfile;
/* type of output file */
__private_extern__ unsigned long filetype;
/* multi or single module dylib output */
__private_extern__ enum bool multi_module_dylib;

/*
 * The architecture of the output file as specified by -arch and the cputype
 * and cpusubtype of the object files being loaded which will be the output
 * cputype and cpusubtype.  specific_arch_flag is true if an -arch flag is
 * specified and the flag for a specific implementation of an architecture.
 */
__private_extern__ struct arch_flag arch_flag;
__private_extern__ enum bool specific_arch_flag;

/*
 * The -force_cpusubtype_ALL flag.
 */
__private_extern__ enum bool force_cpusubtype_ALL;

/* the byte sex of the output file */
__private_extern__ enum byte_sex target_byte_sex;

__private_extern__
enum bool trace;		/* print stages of link-editing */
__private_extern__
enum bool save_reloc;		/* save relocation information */
__private_extern__
enum bool output_for_dyld;	/* produce output for use with dyld */
__private_extern__
enum bool bind_at_load;		/* mark the output for dyld to be bound
				   when loaded */
__private_extern__
enum bool no_fix_prebinding;	/* mark the output for dyld to never
				   run fix_prebinding */
__private_extern__
enum bool load_map;		/* print a load map */
__private_extern__
enum bool define_comldsyms;	/* define common and link-editor defined
					   symbol reguardless of file type */
__private_extern__
enum bool seglinkedit;		/* create the link edit segment */
__private_extern__
enum bool whyload;		/* print why archive members are
					   loaded */
__private_extern__
enum bool flush;		/* Use the output_flush routine to flush
				   output file by pages */
__private_extern__
enum bool sectorder_detail;	/* print sectorder warnings in detail */
__private_extern__
enum bool nowarnings;		/* suppress warnings */
__private_extern__
enum bool no_arch_warnings;	/* suppress wrong arch warnings */
__private_extern__
enum bool arch_errors_fatal;	/* cause wrong arch errors to be fatal */
__private_extern__
enum bool archive_ObjC;		/* objective-C archive semantics */
__private_extern__
enum bool archive_all;		/* always load everything in archives */
__private_extern__
enum bool keep_private_externs;	/* don't turn private externs into
					   non-external symbols */
/* TRUE if -dynamic is specified, FALSE if -static is specified */
__private_extern__ enum bool dynamic;

/* The level of symbol table stripping */
__private_extern__ enum strip_levels strip_level;
/* Strip the base file symbols (the -A argument's symbols) */
__private_extern__ enum bool strip_base_symbols;

/* strip dead blocks */
__private_extern__ enum bool dead_strip;
/* don't strip module init and term sections */
__private_extern__ enum bool no_dead_strip_inits_and_terms;
/* print timings for dead striping code */
__private_extern__ enum bool dead_strip_times;

#ifndef RLD
/*
 * Data structures to perform selective exporting of global symbols.
 * save_symbols is the names of the symbols from -exported_symbols_list
 * remove_symbols is the names of the symbols from -unexported_symbols_list
 */
__private_extern__ struct symbol_list *save_symbols;
__private_extern__ uint32_t nsave_symbols;
__private_extern__ struct symbol_list *remove_symbols;
__private_extern__ uint32_t nremove_symbols;

/*
 * -executable_path option's argument, executable_path is used to replace
 * "@executable_path for dependent libraries.
 */
__private_extern__ char *executable_path;
#endif /* RLD */

/* The list of symbols to be traced */
__private_extern__ char **trace_syms;
__private_extern__ unsigned long ntrace_syms;

/* The number of references of undefined symbols to print */
__private_extern__ unsigned long Yflag;

/* The list of allowed undefined symbols */
__private_extern__ char **undef_syms;
__private_extern__ unsigned long nundef_syms;

/* The list of -dylib_file arguments */
__private_extern__ char **dylib_files;
__private_extern__ unsigned long ndylib_files;

/* The checking for undefined symbols */
__private_extern__ enum undefined_check_level undefined_flag;

/* The checking for (twolevel namespace) multiply defined symbols */
__private_extern__ enum multiply_defined_check_level
    multiply_defined_flag;
__private_extern__ enum multiply_defined_check_level
    multiply_defined_unused_flag;
/* the -nomultidefs option */
__private_extern__ enum bool nomultidefs;

/* The checking for read only relocs */
__private_extern__ enum read_only_reloc_check_level read_only_reloc_flag;

/* The checking for pic relocs */
__private_extern__ enum sect_diff_reloc_check_level sect_diff_reloc_flag;

/* The handling for weak reference mismatches */
__private_extern__ enum weak_reference_mismatches_handling
    weak_reference_mismatches;

/* The prebinding optimization */
__private_extern__ enum bool prebinding;
__private_extern__ enum bool prebind_allow_overlap;
__private_extern__ enum bool prebind_all_twolevel_modules;

/* True if -m is specified to allow multiply symbols, as a warning */
__private_extern__ enum bool allow_multiply_defined_symbols;

/* The segment alignment */
__private_extern__ unsigned long segalign;
#ifndef RLD
__private_extern__ enum bool segalign_specified;
#endif /* !defined(RLD) */
/* The size of pagezero from the -pagezero_size flag */
__private_extern__ unsigned long pagezero_size;
/* The maximum segment alignment allowed to be specified, in hex */
#define MAXSEGALIGN		0x8000
/* The default section alignment */
__private_extern__ unsigned long defaultsectalign;
/* The maximum section alignment allowed to be specified, as a power of two */
#define MAXSECTALIGN		15 /* 2**15 or 0x8000 */
/* The default section alignment if not specified, as a power of two */
#define DEFAULTSECTALIGN	4  /* 2**4 or 16 */

/* The first segment address */
__private_extern__ unsigned long seg1addr;
__private_extern__ enum bool seg1addr_specified;

/* read-only and read-write segment addresses */
__private_extern__ unsigned long segs_read_only_addr;
__private_extern__ enum bool segs_read_only_addr_specified;
__private_extern__ unsigned long segs_read_write_addr;
__private_extern__ enum bool segs_read_write_addr_specified;

/* The stack address and size */
__private_extern__ unsigned long stack_addr;
__private_extern__ enum bool stack_addr_specified;
__private_extern__ unsigned long stack_size;
__private_extern__ enum bool stack_size_specified;

/* TRUE if -allow_stack_execute is specified */
__private_extern__ enum bool allow_stack_execute;

/* The header pad */
__private_extern__ unsigned long headerpad;
/*
 * If specified makes sure the header pad is big enough to change all the
 * install name of the dylibs in the output to MAXPATHLEN.
 */
__private_extern__ enum bool headerpad_max_install_names;

/* The name of the specified entry point */
__private_extern__ char *entry_point_name;

/* The name of the specified library initialization routine */
__private_extern__ char *init_name;

/* The dylib information */
__private_extern__ char *dylib_install_name;
__private_extern__ uint32_t dylib_current_version;
__private_extern__ uint32_t dylib_compatibility_version;

/* the umbrella/sub framework information */
__private_extern__ enum bool sub_framework;
__private_extern__ enum bool umbrella_framework;
__private_extern__ char *sub_framework_name;
__private_extern__ char *umbrella_framework_name;
__private_extern__ char *client_name;
__private_extern__ char **allowable_clients;
__private_extern__ unsigned long nallowable_clients;

/* The list of sub_umbrella frameworks */
__private_extern__ char **sub_umbrellas;
__private_extern__ unsigned long nsub_umbrellas;

/* The list of sub_library dynamic libraries */
__private_extern__ char **sub_librarys;
__private_extern__ unsigned long nsub_librarys;

/* The dylinker information */
__private_extern__ char *dylinker_install_name;

/* set to TRUE if -private_bundle is specified */
__private_extern__ enum bool private_bundle;

/* The value of the environment variable NEXT_ROOT */
__private_extern__ char *next_root;

/* TRUE if the environment variable LD_TRACE_ARCHIVES
   (or temporarily RC_TRACE_ARCHIVES) is set */
__private_extern__ enum bool ld_trace_archives;

/* TRUE if the environment variable LD_TRACE_DYLIBS
   (or temporarily RC_TRACE_DYLIBS) is set */
__private_extern__ enum bool ld_trace_dylibs;

/* TRUE if the environment variable LD_TRACE_PREBINDING_DISABLED
   (or temporarily RC_TRACE_PREBINDING_DISABLED) is set */
__private_extern__ enum bool ld_trace_prebinding_disabled;

/* the argument to -final_output if any */
__private_extern__ char *final_output;

/* The variables to support namespace options */
__private_extern__ enum bool namespace_specified;
__private_extern__ enum bool twolevel_namespace;
__private_extern__ enum bool force_flat_namespace;

__private_extern__ enum bool twolevel_namespace_hints;

__private_extern__ void *allocate(
    unsigned long size);
__private_extern__ void *reallocate(
    void *,
    unsigned long size);
__private_extern__ unsigned long rnd(
    unsigned long v,
    unsigned long r);
__private_extern__ void tell_ProjectBuilder(
    char *message);
__private_extern__ void print(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void ld_trace(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void vprint(
    const char *format, va_list ap);
__private_extern__ void warning(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void error(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void fatal(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void warning_with_cur_obj(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void error_with_cur_obj(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void system_warning(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void system_error(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void system_fatal(
    const char *format, ...) __attribute__ ((format (printf, 1, 2)));
__private_extern__ void mach_fatal(
    kern_return_t r,
    char *format, ...) __attribute__ ((format (printf, 2, 3)));

#ifdef DEBUG
__private_extern__ unsigned long debug;		/* link-editor debugging */
#endif /* DEBUG */
                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/librld.ofileList                         0100644 0001750 0001750 00000000011 12612724205 024152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        librld.o
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/literal_pointers.c                       0100644 0001750 0001750 00000144652 12612724205 024575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with literal pointers sections.
 * A literal pointer must point to something in another literal section.  And
 * since it is a pointer and is being relocated it must have exactly one
 * relocation entry for each pointer.  Also that relocation entry must have an
 * r_length of 2 (long, since each pointer is the size of a long) and must have
 * r_pcrel set to 0 (FALSE, since the pointer is not going to have the pc added
 * to it).  As with all literals, literals in this section must beable to me
 * moved freely with respect to other literals.  This means relocation to this
 * literal must not reach outside the size of the literal.  The size of this
 * this type of section must be a multiple of 4 bytes (size of a pointer) in
 * all input files.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/mach.h>
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "pass1.h"
#include "symbols.h"
#include "layout.h"
#include "literal_pointers.h"
#include "cstring_literals.h"
#include "4byte_literals.h"
#include "8byte_literals.h"
#include "dylibs.h"

static unsigned long lookup_literal_pointer(
    struct merged_symbol *merged_symbol,
    struct merged_section *literal_ms,
    unsigned long merged_section_offset,
    unsigned long offset,
    struct literal_pointer_data *data, 
    struct merged_section *ms,
    enum bool *new);

#ifndef RLD
static unsigned long literal_pointer_order_line(
    unsigned long *line_start,
    unsigned long line_number,
    struct literal_pointer_data *data, 
    struct merged_section *ms,
    char *buffer);
#endif /* !defined(RLD) */

static void count_reloc(
    struct merged_section *ms,
    enum bool new,
    unsigned long r_extern,
    enum bool defined);

/*
 * literal_pointer_merge() merges literal pointers from the specified section
 * current object file (cur_obj). When redo_live is FALSE it allocates a fine
 * relocation map and sets the fine_relocs field in the section_map to it (as
 * well as the count).  When redo_live is TRUE it re-merges only the live
 * literal pointers based on the live bit in the previouly allocated
 * fine_relocs.
 */
__private_extern__
void
literal_pointer_merge(
struct literal_pointer_data *data, 
struct merged_section *ms,
struct section *s, 
struct section_map *section_map,
enum bool redo_live)
{
    long i;
    unsigned long nliterals, j;
    char *literals;
    struct fine_reloc *fine_relocs;
    struct relocation_info *relocs;
    struct relocation_info *reloc;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value;
    struct undefined_map *undefined_map;
    struct nlist *nlists;
    char *strings;
    enum bool defined, new;

    struct merged_symbol *merged_symbol;
    struct section_map *literal_map;
    struct merged_section *literal_ms;
    struct section *literal_s;
    unsigned long section_value, input_section_offset, merged_section_offset,
		  offset;

    if(s->size == 0){
	if(redo_live == FALSE){
	    section_map->fine_relocs = NULL;
	    section_map->nfine_relocs = 0;
	}
	return;
    }
    if(s->size % 4 != 0){
	error_with_cur_obj("literal pointer section (%.16s,%.16s) size is "
			   "not a multiple of 4 bytes",s->segname, s->sectname);
	return;
    }
    nliterals = s->size / 4;
    if(s->nreloc != nliterals){
	error_with_cur_obj("literal pointer section (%.16s,%.16s) does not "
			   "have is exactly one relocation entry for each "
			   "pointer\n", s->segname, s->sectname);
	return;
    }
#ifdef DEBUG
    if(redo_live == FALSE){
	data->nfiles++;
	data->nliterals += nliterals;
    }
#endif /* DEBUG */
    /*
     * The size is not zero an it has as many relocation entries as literals so
     * this section is being relocated (as long as -dead_strip is not
     * specified).
     */
    if(dead_strip == FALSE)
	ms->relocated = TRUE;

    /*
     * If redo_live == FALSE this is the first time we are called so set the
     * output_offset to -1 here so that when going through the relocation
     * entries to merge the literals the error of having more than one
     * relocation entry for each literal can be caught.
     */
    if(redo_live == FALSE){
	fine_relocs = allocate(nliterals * sizeof(struct fine_reloc));
	memset(fine_relocs, '\0', nliterals * sizeof(struct fine_reloc));
	for(j = 0; j < nliterals; j++){
	    fine_relocs[j].output_offset = -1;
	}
	section_map->fine_relocs = fine_relocs;
	section_map->nfine_relocs = nliterals;
    }
    else{
	/*
	 * redo_live is TRUE so this is the second time we are called to
	 * re-merge just the live fine_relocs.
	 */
	fine_relocs = section_map->fine_relocs;
	nliterals = section_map->nfine_relocs;
    }

    /*
     * Because at this point it is known that their are exactly as many literals
     * in the section as relocation entries either could be used to merge the
     * the literals themselves.  The loop is driven off the relocation entries
     * for two reasons: first if it looped throught the literals themselfs a
     * costly search would result in trying to find the relocation entry for it
     * and by doing it the way it is done here the r_address (really an offset)
     * can be used directly to get the literal, secondly by looping through the
     * relocation entries checking for the error case of more than one
     * relocation entry refering to the same literal can be caught easily.  So
     * if everything goes without error then their must have been exactly one
     * relocation entry for each literal pointer in this section.  The reason
     * that this loop runs backwards through the relocation entries is to get
     * this implementation of merging literal pointers to match the previous
     * one so a binary compare can be done (the previous implemention went
     * through the literals and the current assembler puts out the relocation
     * entries in reverse order so these two implementions just happen to get
     * the exact same result).
     */
    relocs = (struct relocation_info *)(cur_obj->obj_addr + s->reloff);
    literals = (char *)(cur_obj->obj_addr + s->offset);
    if(cur_obj->swapped && section_map->input_relocs_already_swapped == FALSE){
	swap_relocation_info(relocs, s->nreloc, host_byte_sex);
	section_map->input_relocs_already_swapped = TRUE;
    }
    merged_symbol = NULL;
    for(i = s->nreloc - 1; i >= 0 ; i--){
	/*
	 * Break out the fields of the relocation entry.
	 */
	if((relocs[i].r_address & R_SCATTERED) != 0){
	    sreloc = (struct scattered_relocation_info *)(relocs + i);
	    reloc = NULL;
	    r_scattered = 1;
	    r_address = sreloc->r_address;
	    r_pcrel = sreloc->r_pcrel;
	    r_length = sreloc->r_length;
	    r_value = sreloc->r_value;
	    r_extern = 0;
	    /* calculate the r_symbolnum (n_sect) from the r_value */
	    r_symbolnum = 0;
	    for(j = 0; j < cur_obj->nsection_maps; j++){
		if(r_value >= cur_obj->section_maps[j].s->addr &&
		   r_value < cur_obj->section_maps[j].s->addr +
			     cur_obj->section_maps[j].s->size){
		    r_symbolnum = j + 1;
		    break;
		}
	    }
	    if(r_symbolnum == 0){
		/*
		 * The edge case where the last address past then end of
		 * of the last section is referenced.
		 */
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value == cur_obj->section_maps[j].s->addr +
				  cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i, s->segname, s->sectname);
		    continue;
		}
	    }
	}
	else{
	    reloc = relocs + i;
	    sreloc = NULL;
	    r_scattered = 0;
	    r_address = reloc->r_address;
	    r_pcrel = reloc->r_pcrel;
	    r_length = reloc->r_length;
	    r_extern = reloc->r_extern;
	    r_symbolnum = reloc->r_symbolnum;
	    r_value = 0;
	}
	/*
	 * The r_address field is really an offset into the contents of the
	 * section and must reference something inside the section.
	 */
	if(r_address >= s->size){
	    error_with_cur_obj("r_address (0x%x) field of relocation entry "
		"%ld in section (%.16s,%.16s) out of range",
		(unsigned int)r_address, i, s->segname, s->sectname);
	    continue;
	}
	/*
	 * For a literal pointer section all relocation entries must be for one
	 * of the pointers and therefore the offset must be a multiple of 4,
	 * have an r_length field of 2 (long) and a r_pcrel field of 0 (FALSE).
	 */
	if(r_address % 4 != 0){
	    error_with_cur_obj("r_address (0x%x) field of relocation entry "
		"%ld in literal pointer section (%.16s,%.16s) is not a "
		"multiple of 4", (unsigned int)r_address, i, s->segname,
		s->sectname);
	    continue;
	}
	if(r_length != 2){
	    error_with_cur_obj("r_length (0x%x) field of relocation entry "
		"%ld in literal pointer section (%.16s,%.16s) is not 2 (long)",
		(unsigned int)r_length, i, s->segname, s->sectname);
	    continue;
	}
	if(r_pcrel != 0){
	    error_with_cur_obj("r_pcrel (0x%x) field of relocation entry "
		"%ld in literal pointer section (%.16s,%.16s) is not 0 "
		"(FALSE)", (unsigned int)r_pcrel, i, s->segname, s->sectname);
	    continue;
	}
	defined = TRUE;
	/*
	 * If r_extern is set this relocation entry is an external entry
	 * else it is a local entry (or scattered entry).
	 */
	if(r_extern){
	    /*
	     * This is an external relocation entry.  So the value to be
	     * added to the item to be relocated is the value of the symbol.
	     * r_symbolnum is an index into the input file's symbol table
	     * of the symbol being refered to.  The symbol must be an
	     * undefined symbol to be used in an external relocation entry.
	     */
	    if(r_symbolnum >= cur_obj->symtab->nsyms){
		error_with_cur_obj("r_symbolnum (%lu) field of external "
		    "relocation entry %ld in section (%.16s,%.16s) out of "
		    "range", r_symbolnum, i, s->segname, s->sectname);
		continue;
	    }
	    undefined_map = bsearch(&r_symbolnum, cur_obj->undefined_maps,
		cur_obj->nundefineds, sizeof(struct undefined_map),
		(int (*)(const void *, const void *))undef_bsearch);
	    if(undefined_map != NULL){
		merged_symbol = undefined_map->merged_symbol;
	    }
	    else{
		nlists = (struct nlist *)(cur_obj->obj_addr +
					  cur_obj->symtab->symoff);
		strings = cur_obj->obj_addr + cur_obj->symtab->stroff;
		if((nlists[r_symbolnum].n_type & N_EXT) != N_EXT){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) refers "
			"to a non-external symbol", r_symbolnum, i, s->segname,
			s->sectname);
		    continue;
		}
		/*
		 * We must correctly catch the errors of a literal pointer
		 * refering defined global coalesced symbols with external
		 * relocation entries.
		 */
		if((nlists[r_symbolnum].n_type & N_TYPE) == N_SECT &&
		   (cur_obj->section_maps[nlists[r_symbolnum].
		    n_sect-1].s->flags & SECTION_TYPE) == S_COALESCED){
		    merged_symbol = lookup_symbol(strings +
				       nlists[r_symbolnum].n_un.n_strx);
		    if(merged_symbol->name_len == 0){
			fatal("internal error, in literal_pointer_merge() "
			      "failed to lookup coalesced symbol %s",
			      strings + nlists[r_symbolnum].n_un.n_strx);
		    }
		    error_with_cur_obj("exteral symbol (%s) for external "
			"relocation entry %ld in section (%.16s,%.16s) refers "
			"a symbol not defined in a literal section",
			merged_symbol->nlist.n_un.n_name, i, s->segname,
			s->sectname);
		    continue;
		}
		else{
		    if(nlists[r_symbolnum].n_type != (N_EXT | N_UNDF)){
			error_with_cur_obj("r_symbolnum (%lu) field of "
			    "external relocation entry %lu in section "
			    "(%.16s,%.16s) refers to a non-undefined symbol",
			    r_symbolnum, i, s->segname, s->sectname);
			continue;
		    }
		    print_obj_name(cur_obj);
		    fatal("internal error, in literal_pointer_merge() symbol "
			  "index %lu in above file not in undefined map",
			  r_symbolnum);
		}
	    }
	    /*
	     * If this is an indirect symbol resolve indirection (all chains
	     * of indirect symbols have been resolved so that they point at
	     * a symbol that is not an indirect symbol).
	     */
	    if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		merged_symbol = (struct merged_symbol *)
				merged_symbol->nlist.n_value;
	    /*
	     * If the symbol is a common symbol it is an error
	     * because it not a pointer to a literal.
	     */
	    if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
	       merged_symbol->nlist.n_value != 0){
		error_with_cur_obj("r_symbolnum (%lu) field of external "
		    "relocation entry %ld in section (%.16s,%.16s) refers to "
		    "a common symbol (%s) and is not in a literal section",
		    r_symbolnum, i, s->segname, s->sectname,
		    merged_symbol->nlist.n_un.n_name);
		continue;
	    }
	    /*
	     * If the symbol is an absolute symbol it is treated as an error
	     * because it is not known to be a pointer to a literal.
	     */
	    if((merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
		error_with_cur_obj("r_symbolnum (%lu) field of external "
		    "relocation entry %ld in section (%.16s,%.16s) refers to "
		    "an absolue symbol (%s) and is not known to be in a "
		    "literal section", r_symbolnum, i, s->segname, s->sectname,
		    merged_symbol->nlist.n_un.n_name);
		continue;
	    }
	    /*
	     * For multi module dynamic shared library format files the
	     * merged sections that could have had external relocation
	     * entries must be resolved to private extern symbols.  This is
	     * because for multi module MH_DYLIB files all modules share the
	     * merged sections and the entire section gets relocated when
	     * the library is mapped in. So the above restriction assures
	     * the merged section will get relocated properly and can be
	     * shared amoung library modules.
	     */
	    if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		/*
		 * If the symbol is undefined or not a private extern it is an
		 * error for in this section for a MH_DYLIB file.
		 */
		if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF)){
		    if(merged_symbol->error_flagged_for_dylib == 0){
			error_with_cur_obj("illegal undefined reference for "
			    "multi module MH_DYLIB output file to symbol: %s "
			    "from a literal pointer section (section (%.16s,"
			    "%.16s) relocation entry: %lu)",
			    merged_symbol->nlist.n_un.n_name, s->segname,
			    s->sectname, i);
			merged_symbol->error_flagged_for_dylib = 1;
		    }
		}
		else if((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT){
		    if(merged_symbol->error_flagged_for_dylib == 0){
			error_with_cur_obj("illegal external reference for "
			    "multi module MH_DYLIB output file to symbol: %s "
			    "(not a private extern symbol) from a literal "
			    "pointer section (section (%.16s,%.16s) relocation "
			    "entry: %lu)", merged_symbol->nlist.n_un.n_name,
			    s->segname, s->sectname, i);
			merged_symbol->error_flagged_for_dylib = 1;
		    }
		}
	    }
	    /*
	     * If the symbol is an undefined symbol then the literal is an
	     * offset to be added to the value of the symbol.
	     */
	    if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF)){
		literal_ms = NULL;
		merged_section_offset = 0;
		offset = get_long((long *)(literals + r_address));
		defined = FALSE;
	    }
	    else {
		/*
		 * All other types of symbol of symbol have been handled so this
		 * symbol must be defined in a section.  The section that the
		 * symbol is defined in must be a literal section or else it
		 * is an error.  Since this is an external relocation entry and
		 * the symbol is defined this means it is defined in some other
		 * object than this one.
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) != N_SECT ||
		   (merged_symbol->nlist.n_type & N_EXT)  != N_EXT){
		    fatal("internal error, in merge_literal_pointers() merged "
			  "symbol %s does not have a type of N_EXT|N_SECT",
			  merged_symbol->nlist.n_un.n_name);
		}
		literal_map = &(merged_symbol->definition_object->
				section_maps[merged_symbol->nlist.n_sect - 1]);
		literal_ms = literal_map->output_section;
		if((literal_ms->s.flags & SECTION_TYPE) != S_CSTRING_LITERALS &&
		   (literal_ms->s.flags & SECTION_TYPE) != S_4BYTE_LITERALS &&
		   (literal_ms->s.flags & SECTION_TYPE) != S_8BYTE_LITERALS){
		    error_with_cur_obj("exteral symbol (%s) for external "
			"relocation entry %ld in section (%.16s,%.16s) refers "
			"a symbol not defined in a literal section",
			merged_symbol->nlist.n_un.n_name, i, s->segname,
			s->sectname);
		    continue;
		}
		section_value = merged_symbol->nlist.n_value;
		literal_s = literal_map->s;
		if(section_value < literal_s->addr ||
		   section_value > literal_s->addr + literal_s->size){
		    error_with_cur_obj("exteral symbol's (%s) address not in "
			"the section (%.16s,%.16s) it is defined in", 
			merged_symbol->nlist.n_un.n_name, literal_s->segname,
			literal_s->sectname);
		    continue;
		}
		input_section_offset = section_value - literal_s->addr;
		/*
		 * At this point it is known that the merged section the
		 * literal is defined in is a literal section.  The checking
		 * for an internal error if the section does not have fine_reloc
		 * entry is left to fine_reloc_output_offset();
		 */
		merged_section_offset = fine_reloc_output_offset(literal_map,
							 input_section_offset);
		/*
		 * since this was an external relocation entry the value of the
		 * literal pointer is symbol+offset and the relocation is done
		 * based on only the symbol's value without the offset added.
		 * That's why offset is NOT added to input_section_offset above.
		 * Also if the offset is not zero that is need to be known so
		 * that a scattered relocation entry can be created on output.
		 */
		offset = get_long((long *)(literals + r_address));
		/*
		 * merged_symbol is set to NULL for the call to
		 * lookup_literal_pointer because this symbol is not undefined.
		 */
		merged_symbol = NULL;

		/* mark the section this symbol is in as referenced */
		literal_map->output_section->referenced = TRUE;
	    }
	}
	else{
	    /*
	     * This is a local relocation entry (the value to which the item
	     * to be relocated is refering to is defined in section number
	     * r_symbolnum in this object file).  Check that r_symbolnum is not
	     * R_ABS so it can be used to directly index the section map.
	     * For scattered relocation entries r_value was previously checked
	     * to be in the section refered to by r_symbolnum.
	     */
	    if(r_symbolnum == R_ABS){
		error_with_cur_obj("r_symbolnum (0x%x) field of relocation "
		    "entry %ld in literal pointer section (%.16s,%.16s) is "
		    "R_ABS (not correct for a literal pointer section)",
		    (unsigned int)r_symbolnum, i, s->segname, s->sectname);
		continue;
	    }
	    merged_symbol = NULL;
	    literal_map = &(cur_obj->section_maps[r_symbolnum - 1]);
	    literal_s = literal_map->s;
	    literal_ms  = literal_map->output_section;
	    if(r_scattered == 0){
		offset = 0;
		section_value = get_long((long *)(literals + r_address));
		if(section_value < literal_s->addr ||
		   section_value > literal_s->addr + literal_s->size){
		    error_with_cur_obj("literal pointer (0x%x) in section "
			"(%.16s,%.16s) at address 0x%x does not point into "
			"its (%.16s,%.16s) section as refered to by its "
			"r_symbolnum (0x%x) field in relocation entry %ld as "
			"it should", (unsigned int)section_value, s->segname,
			s->sectname, (unsigned int)(s->addr + r_address),
			literal_s->segname, literal_s->sectname,
			(unsigned int)r_symbolnum, i);
		    continue;
		}
		if((literal_ms->s.flags & SECTION_TYPE) != S_CSTRING_LITERALS &&
		   (literal_ms->s.flags & SECTION_TYPE) != S_4BYTE_LITERALS &&
		   (literal_ms->s.flags & SECTION_TYPE) != S_8BYTE_LITERALS){
		    error_with_cur_obj("r_symbolnum field (0x%x) in relocation "
			"entry %ld in literal pointer section (%.16s,%.16s) "
			"refers to section (%.16s,%.16s) which is not a "
			"literal section", (unsigned int)r_symbolnum, i,
			s->segname, s->sectname, literal_ms->s.segname,
			literal_ms->s.sectname);
		    continue;
		}
	    }
	    else{
		offset = get_long((long *)(literals + r_address)) - r_value;
		section_value = r_value;
		if((literal_ms->s.flags & SECTION_TYPE) != S_CSTRING_LITERALS &&
		   (literal_ms->s.flags & SECTION_TYPE) != S_4BYTE_LITERALS &&
		   (literal_ms->s.flags & SECTION_TYPE) != S_8BYTE_LITERALS){
		    error_with_cur_obj("r_value field (0x%x) in relocation "
			"entry %ld in literal pointer section (%.16s,%.16s) "
			"refers to section (%.16s,%.16s) which is not a "
			"literal section", (unsigned int)r_value, i, s->segname,
			s->sectname, literal_ms->s.segname,
			literal_ms->s.sectname);
		    continue;
		}
	    }
	    input_section_offset = section_value - literal_s->addr;
	    /*
	     * At this point it is known that the merged section the
	     * literal is defined in is a literal section.  The checking
	     * for an internal error if the section does not have fine_reloc
	     * entry is left to fine_reloc_output_offset();
	     */
	    merged_section_offset = fine_reloc_output_offset(literal_map,
						     input_section_offset);
	    /* mark the section this literal is in as referenced */
	    literal_map->output_section->referenced = TRUE;
	}

	/* 
	 * Since all the output_offset field of all the fine reloc entries were
	 * set to -1 before merging the literals and there must be only one
	 * relocation entry for each literal pointer if the relocation entry
	 * for this literal does not have an output_offset of -1 it is an error
	 * because we have seen it before.
	 */ 
	if(redo_live == FALSE &&
	   (int)(fine_relocs[r_address/4].output_offset) != -1){
	    error_with_cur_obj("more than one relocation entry for literal "
		"pointer at address 0x%x (r_address 0x%x) in section "
		"(%.16s,%.16s)", (unsigned int)(s->addr + r_address),
		(unsigned int)r_address, s->segname, s->sectname);
	    continue;
	}

	/*
	 * If redo_live == FALSE this is the first time we are called and now
	 * at long last the literal pointer can be merged and the fine 
	 * relocation entry for it can be built.
	 */
	if(redo_live == FALSE){
	    fine_relocs[r_address/4].input_offset = r_address;
	    fine_relocs[r_address/4].output_offset =
		    lookup_literal_pointer(merged_symbol, literal_ms,
				   merged_section_offset, offset, data,
				   ms, &new);
	    count_reloc(ms, new, r_extern, defined);
	}
	else{
	    /*
	     * redo_live == TRUE so if this fine_reloc is live re-merge it.
	     */
	    if(fine_relocs[r_address/4].live == TRUE){
		/*
     		 * Since we now know that there will be a live pointer in this
		 * section and since it has a relocation entry mark the merged
		 * section as relocated.
		 */
		ms->relocated = TRUE;
		fine_relocs[r_address/4].output_offset =
			lookup_literal_pointer(merged_symbol, literal_ms,
				       merged_section_offset, offset, data,
				       ms, &new);
		count_reloc(ms, new, r_extern, defined);
	    }
	    else{
		fine_relocs[r_address/4].output_offset = 0;
	    }
	}
    }
}

/*
 * count reloc is used after a call to lookup_literal_pointer() to count the
 * relocation entry for the literal if it will be in the output file.
 */
static void
count_reloc(
struct merged_section *ms,
enum bool new,
unsigned long r_extern,
enum bool defined)
{
	/*
	 * If saving relocation entries count it as one of the output
	 * relocation entries.
	 */
	if(output_for_dyld && new == TRUE){
	    /*
	     * The number of relocation entries in the output file is based
	     * on one of three different cases:
	     *  The output file is a multi module dynamic shared library
	     *  The output file has a dynamic linker load command
	     *  The output does not have a dynamic linker load command
	     */
	    if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		/*
		 * For a multi module dynamic shared library there are no
		 * external relocation entries that will be left as external as
		 * checked above.  Only non-sectdiff local relocation entries
		 * are kept.  Modules of multi module dylibs are not linked
		 * together and can only be slid keeping all sections
		 * relative to each other the same.
		 */
		ms->nlocrel++;
	    }
	    else if(has_dynamic_linker_command){
		/*
		 * For an file with a dynamic linker load command only
		 * external relocation entries for undefined symbols are
		 * kept.  This output file is a fixed address and can't be
		 * moved.
		 */
		if(r_extern)
		    if(defined == FALSE)
			ms->nextrel++;
	    }
	    else{
		/*
		 * For an file without a dynamic linker load command
		 * external relocation entries for undefined symbols are
		 * kept and locals that are non-sectdiff are kept.  This
		 * file can only be slid keeping all sections relative to
		 * each other the same.
		 */
		if(r_extern){
		    if(defined == FALSE)
			ms->nextrel++;
		    else
			ms->nlocrel++;
		}
		else
		    ms->nlocrel++;
	    }
	}
	else if(save_reloc && new == TRUE){
	    ms->s.nreloc++;
	    nreloc++;
	}
}

/*
 * literal_pointer_order() enters literal pointers from the order_file from the
 * merged section structure.  Since this is called before any call to
 * literal_pointer_merge and it enters the literals in the order of the file it
 * causes the section to be ordered.
 */
__private_extern__
void
literal_pointer_order(
struct literal_pointer_data *data, 
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, line_number, line_length, max_line_length, output_offset;
    char *buffer;
    kern_return_t r;
    struct literal_pointer_order_line *order_lines;

	/*
	 * Parse the load order file by changing '\n' to '\0'.  Also check for
	 * '\0 in the file and flag them as errors.  Also determine the maximum
	 * line length of the file for the needed buffer to allocate for
	 * character translation.
	 */
	line_number = 1;
	line_length = 1;
	max_line_length = 1;
	for(i = 0; i < ms->order_size; i++){
	    if(ms->order_addr[i] == '\0'){
		fatal("format error in -sectorder file: %s line %lu character "
		      "possition %lu for section (%.16s,%.16s) (illegal null "
		      "character \'\\0\' found)", ms->order_filename,
		      line_number, line_length, ms->s.segname, ms->s.sectname);
	    }
	    if(ms->order_addr[i] == '\n'){
		ms->order_addr[i] = '\0';
		if(line_length > max_line_length)
		    max_line_length = line_length;
		line_length = 1;
		line_number++;
	    }
	    else
		line_length++;
	}

	/*
	 * Allocate the buffer to translate the order file lines' escape
	 * characters into real characters.
	 */
	buffer = allocate(max_line_length + 1);

	/*
	 * If -dead_strip is specified allocate the needed structures so that
	 * the order of the live literal pointers can be recreated later by
	 * literal_pointer_reset_live().
	 */
	order_lines = NULL;
	if(dead_strip == TRUE){
	    data->literal_pointer_load_order_data =
		allocate(sizeof(struct literal_pointer_load_order_data));
	    order_lines = allocate(sizeof(struct literal_pointer_order_line) *
					   (line_number - 1));
	    data->literal_pointer_load_order_data->order_line_buffer =
		buffer;
	    data->literal_pointer_load_order_data->literal_pointer_order_lines =
		order_lines;
	    data->literal_pointer_load_order_data->nliteral_pointer_order_lines
		= (line_number - 1);
	}

	/*
	 * Process each line in the order file.
	 */
	line_number = 1;
	for(i = 0; i < ms->order_size; i++){

	    if(dead_strip == TRUE){
		order_lines[line_number - 1].character_index = i;
		order_lines[line_number - 1].line_number = line_number;
	    }

	    output_offset = literal_pointer_order_line(&i, line_number, data,
						       ms, buffer);
	    if(dead_strip == TRUE)
		order_lines[line_number - 1].output_offset = output_offset;

	    /* skip any trailing characters on the line */
	    while(i < ms->order_size && ms->order_addr[i] != '\0')
		i++;

	    line_number++;
	}

	/*
	 * If -dead_strip is not specified free up the memory for the line
	 * buffer and the load order file.  If -dead_strip is specified these
	 * will be free'ed up in literal_pointer_reset_live().
	 */
	if(dead_strip == FALSE){
	    /* deallocate the buffer */
	    free(buffer);

	    /*
	     * Deallocate the memory for the load order file now that it is
	     * nolonger needed (since the memory has been written on it is
	     * allways deallocated so it won't get written to the swap file
	     * unnecessarily).
	     */
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)
		ms->order_addr, ms->order_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
			   "file: %s for section (%.16s,%.16s)",
			   ms->order_filename, ms->s.segname,
			   ms->s.sectname);
	    ms->order_addr = NULL;
	}
#endif /* !defined(RLD) */
}

#ifndef RLD
/*
 * literal_pointer_order_line() parses out and enters the literal pointer and
 * literal from the order line specified by the parameters.  The parameter
 * buffer is a buffer used to parse any C string on the line and must be as
 * large as the longest line in the order file.  It returns the output_offset
 * in the merged section for the literal pointer and indirectly returns the
 * resulting line_start after the characters for this line.
 */
static
unsigned long
literal_pointer_order_line(
unsigned long *line_start,
unsigned long line_number,
struct literal_pointer_data *data, 
struct merged_section *ms,
char *buffer)
{
    unsigned long i, j, char_pos, output_offset, merged_section_offset;
    char segname[17], sectname[17];
    struct merged_section *literal_ms;
    struct literal8 literal8;
    struct literal4 literal4;
    enum bool new;

	/*
	 * An order line for a literal pointer is three parts:
	 * 	segment_name:section_name:literal
	 * The segment_name and section_name are strings separated by a colon
	 * character ':' which also separates the literal.  The literal is just
	 * as it would be for a cstring, 4-byte or 8-byte literal.  The literals
	 * are looked up using the function for each literal then the literal
	 * pointer is looked up.
	 */
	output_offset = 0;
	i = *line_start;
	char_pos = 1;
	/* copy segment name into segname */
	j = 0;
	while(i < ms->order_size &&
	      ms->order_addr[i] != ':' &&
	      ms->order_addr[i] != '\0'){
	    if(j <= 16)
		segname[j++] = ms->order_addr[i++];
	    else
		i++;
	    char_pos++;
	}
	if(i >= ms->order_size || ms->order_addr[i] == '\0'){
	    error("format error in -sectorder file: %s line %lu for section"
		  " (%.16s,%.16s) (missing ':' after segment name)",
		  ms->order_filename, line_number, ms->s.segname,
		  ms->s.sectname);
	    *line_start = i;
	    return(output_offset);
	}
	segname[j] = '\0';
	i++;
	char_pos++;

	/* copy section name into sectname */
	j = 0;
	while(i < ms->order_size &&
	      ms->order_addr[i] != ':' &&
	      ms->order_addr[i] != '\0'){
	    if(j <= 16)
		sectname[j++] = ms->order_addr[i++];
	    else
		i++;
	    char_pos++;
	}
	if(i >= ms->order_size || ms->order_addr[i] == '\0'){
	    error("format error in -sectorder file: %s line %lu for section"
		  " (%.16s,%.16s) (missing ':' after section name)",
		  ms->order_filename, line_number, ms->s.segname,
		  ms->s.sectname);
	    *line_start = i;
	    return(output_offset);
	}
	sectname[j] = '\0';
	i++;
	char_pos++;
    
	literal_ms = lookup_merged_section(segname, sectname);
	if(literal_ms == NULL){
	    error("error in -sectorder file: %s line %lu for section "
		  "(%.16s,%.16s) (specified section (%s,%s) is not "
		  "loaded objects)", ms->order_filename, line_number,
		  ms->s.segname, ms->s.sectname, segname, sectname);
	}
	else{
	    switch(literal_ms->s.flags & SECTION_TYPE){
	    case S_CSTRING_LITERALS:
		get_cstring_from_sectorder(ms, &i, buffer, line_number,
					   char_pos);
		merged_section_offset = lookup_cstring(buffer,
				      literal_ms->literal_data, literal_ms);
		output_offset = lookup_literal_pointer(NULL, literal_ms,
				merged_section_offset, 0, data, ms, &new);
		count_reloc(ms, new, 0, FALSE);
		break;
	    case S_4BYTE_LITERALS:
		if(get_hex_from_sectorder(ms, &i, &(literal4.long0),
					  line_number) == TRUE){
		    merged_section_offset = lookup_literal4(literal4,
				      literal_ms->literal_data, literal_ms);
		    output_offset = lookup_literal_pointer(NULL, literal_ms,
				merged_section_offset, 0, data, ms, &new);
		    count_reloc(ms, new, 0, FALSE);
		}
		else{
		    error("error in -sectorder file: %s line %lu for "
			  "section (%.16s,%.16s) (missing hex number for "
			  "specified 4 byte literal section (%s,%s))",
			  ms->order_filename, line_number,
			  ms->s.segname, ms->s.sectname, segname, sectname);
		}
		break;
	    case S_8BYTE_LITERALS:
		if(get_hex_from_sectorder(ms, &i, &(literal8.long0),
					  line_number) == TRUE){
		    if(get_hex_from_sectorder(ms, &i, &(literal8.long1),
					      line_number) == TRUE){
			merged_section_offset = lookup_literal8(literal8,
					      literal_ms->literal_data,
					      literal_ms);
			output_offset = lookup_literal_pointer(NULL, literal_ms,
				merged_section_offset, 0, data, ms, &new);
			count_reloc(ms, new, 0, FALSE);
		    }
		    else{
			error("error in -sectorder file: %s line %lu for "
			      "section (%.16s,%.16s) (missing second hex "
			      "number for specified 8 byte literal section "
			      "(%s,%s))", ms->order_filename, line_number,
			      ms->s.segname, ms->s.sectname, segname,
			      sectname);
		    }
		}
		else{
		    error("error in -sectorder file: %s line %lu for "
			  "section (%.16s,%.16s) (missing first hex number "
			  "for specified 8 byte literal section (%s,%s))",
			  ms->order_filename, line_number,
			  ms->s.segname, ms->s.sectname, segname, sectname);
		}
		break;
	    default:
		error("error in -sectorder file: %s line %lu for section "
		      "(%.16s,%.16s) (specified section (%s,%s) is not a "
		      "literal section)", ms->order_filename, line_number,
		      ms->s.segname, ms->s.sectname, segname, sectname);
		break;
	    }
	}
	*line_start = i;
	return(output_offset);
}
#endif /* !defined(RLD) */

/*
 * literal_pointer_reset_live() is called when -dead_strip is specified after
 * all the literal pointers from the input objects are merged.  It clears out
 * the literal_pointer_data so the live literal pointers can be re-merged (by
 * later calling literal_pointer_merge() with redo_live == TRUE.  In here we
 * first merge in the live literal pointers from the order file if any. 
 */
__private_extern__
void
literal_pointer_reset_live(
struct literal_pointer_data *data, 
struct merged_section *ms)
{
#ifndef RLD
    unsigned long i, norder_lines, line_number, character_index, output_offset;
    char *buffer;
    struct literal_pointer_order_line *order_lines;
    enum bool live;
    kern_return_t r;

	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* reset the count of relocation entries for this merged section */
	if(output_for_dyld){
	    ms->nlocrel = 0;
	    ms->nextrel = 0;
	}
	else if(save_reloc){
	    nreloc -= ms->s.nreloc;
	    ms->s.nreloc = 0;
	}

	/* clear out the previously merged data */
	literal_pointer_free(data);

	/*
	 * If this merged section has an order file we need to re-merged only
	 * the live literals from that order file.
	 */
	if(ms->order_filename != NULL){
	    buffer = data->literal_pointer_load_order_data->order_line_buffer;
	    order_lines = data->literal_pointer_load_order_data->
		literal_pointer_order_lines;
	    norder_lines = data->literal_pointer_load_order_data->
		nliteral_pointer_order_lines;
	    for(i = 0; i < norder_lines; i++){
		/*
		 * Figure out if this literal pointer order line's output_index
		 * is live and if so re-merge the literal pointer.
		 */
		live = is_literal_output_offset_live(
			ms, order_lines[i].output_offset);
		line_number = order_lines[i].line_number;
		if(live){
		    character_index = order_lines[i].character_index;
		    output_offset = literal_pointer_order_line(
			&character_index, line_number, data, ms, buffer);
		}
		else{
		    if(sectorder_detail == TRUE)
			warning("specification of literal pointer in "
				"-sectorder file: %s on line %lu for section "
				"(%.16s,%.16s) not used (dead stripped)",
				ms->order_filename, line_number, ms->s.segname,
				ms->s.sectname);
		}
	    }

	    /* deallocate the various data structures no longer needed */
	    free(data->literal_pointer_load_order_data->order_line_buffer);
	    free(data->literal_pointer_load_order_data->
		 literal_pointer_order_lines);
	    free(data->literal_pointer_load_order_data);
	    data->literal_pointer_load_order_data = NULL;

	    /*
	     * Deallocate the memory for the load order file now that it is
	     * nolonger needed (since the memory has been written on it is
	     * allways deallocated so it won't get written to the swap file
	     * unnecessarily).
	     */
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)
		ms->order_addr, ms->order_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
			   "file: %s for section (%.16s,%.16s)",
			   ms->order_filename, ms->s.segname,
			   ms->s.sectname);
	    ms->order_addr = NULL;
	}
#endif /* !defined(RLD) */
}

/*
 * lookup_literal_pointer() is passed a quad that defined a literal pointer
 * (merged_symbol, literal_ms, merged_section_offset, offset).  If merged_symbol
 * is not NULL then this pointer is the undefined merged_symbol plus the offset
 * else the pointer is into the merged literal section litersal_ms with an
 * offset into that section of merged_section_offset plus offset.  In either
 * case the literal pointer must match exactly (that means merged_section_offset
 * can't be added to offset and the sum be used to determine a match).
 */
static
unsigned long
lookup_literal_pointer(
struct merged_symbol *merged_symbol,
struct merged_section *literal_ms,
unsigned long merged_section_offset,
unsigned long offset,
struct literal_pointer_data *data, 
struct merged_section *ms,
enum bool *new)
{
    unsigned long hashval, output_offset;
    struct literal_pointer_block **p, *literal_pointer_block;
    struct literal_pointer *literal_pointer;
    struct literal_pointer_bucket *bp;

	*new = FALSE;
	if(data->hashtable == NULL){
	    data->hashtable = allocate(sizeof(struct literal_pointer_bucket *) *
						      LITERAL_POINTER_HASHSIZE);
	    memset(data->hashtable, '\0',
		   sizeof(struct literal_pointer_bucket *) *
						      LITERAL_POINTER_HASHSIZE);
	}
#if defined(DEBUG) && defined(PROBE_COUNT)
	    data->nprobes++;
#endif
	hashval = ((long)merged_symbol + (long)literal_ms +
		   merged_section_offset + offset) % LITERAL_POINTER_HASHSIZE;
	for(bp = data->hashtable[hashval]; bp; bp = bp->next){
#if defined(DEBUG) && defined(PROBE_COUNT)
	    data->nprobes++;
#endif
	    if(bp->literal_pointer->merged_symbol == merged_symbol &&
	       bp->literal_pointer->literal_ms == literal_ms &&
	       bp->literal_pointer->merged_section_offset ==
						        merged_section_offset &&
	       bp->literal_pointer->offset == offset)
		return(bp->output_offset);
	}

	bp = allocate(sizeof(struct literal_pointer_bucket));
	output_offset = 0;
	for(p = &(data->literal_pointer_blocks);
	    *p ;
	    p = &(literal_pointer_block->next)){

	    literal_pointer_block = *p;
	    if(literal_pointer_block->used != LITERAL_POINTER_BLOCK_SIZE){
		literal_pointer = literal_pointer_block->literal_pointers +
				  literal_pointer_block->used;
		literal_pointer->merged_symbol = merged_symbol;
		literal_pointer->literal_ms = literal_ms;
	        literal_pointer->merged_section_offset = merged_section_offset;
	        literal_pointer->offset = offset;

		bp->literal_pointer = literal_pointer;
		bp->output_offset = output_offset +
				    literal_pointer_block->used * 4;
		bp->next = data->hashtable[hashval];
		data->hashtable[hashval] = bp;

		literal_pointer_block->used++;
		ms->s.size += 4;
		*new = TRUE;
		return(bp->output_offset);
	    }
	    output_offset += literal_pointer_block->used * 4;
	}
	*p = allocate(sizeof(struct literal_pointer_block));
	literal_pointer_block = *p;
	literal_pointer = literal_pointer_block->literal_pointers;
	literal_pointer->merged_symbol = merged_symbol;
	literal_pointer->literal_ms = literal_ms;
	literal_pointer->merged_section_offset = merged_section_offset;
	literal_pointer->offset = offset;
	literal_pointer_block->used = 1;
	literal_pointer_block->next = NULL;

	bp->literal_pointer = literal_pointer;
	bp->output_offset = output_offset;
	bp->next = data->hashtable[hashval];
	data->hashtable[hashval] = bp;

	ms->s.size += 4;
	*new = TRUE;
	return(bp->output_offset);
}

/*
 * literal_pointer_output puts the literal pointers into the output file.
 * It also puts the relocation entries for the literal pointers in the output
 * file if relocation entries are being saved.
 */
__private_extern__
void
literal_pointer_output(
struct literal_pointer_data *data, 
struct merged_section *ms)
{
    unsigned long i;
    long *output_pointer;
    struct literal_pointer_block **p, *literal_pointer_block;
    struct literal_pointer *literal_pointers;

#ifndef RLD
    struct relocation_info *reloc, *extreloc, *r;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address;
#endif /* !defined(RLD) */

	/*
	 * Put the literal pointers into the output file.
	 */
	output_pointer = (long *)(output_addr + ms->s.offset);
	for(p = &(data->literal_pointer_blocks);
	    *p ;
	    p = &(literal_pointer_block->next)){

	    literal_pointer_block = *p;
	    literal_pointers = literal_pointer_block->literal_pointers;
	    for(i = 0; i < literal_pointer_block->used; i++){
		if(literal_pointers[i].merged_symbol != NULL){
		    *output_pointer = literal_pointers[i].offset;
		}
		else{
		    *output_pointer = 
			     literal_pointers[i].literal_ms->s.addr +
			     literal_pointers[i].merged_section_offset +
			     literal_pointers[i].offset;
		}
		if(host_byte_sex != target_byte_sex)
		    *output_pointer = SWAP_LONG(*output_pointer);
		output_pointer++;
	    }
	}
#ifndef RLD
	output_flush(ms->s.offset,
		(char *)output_pointer - (char *)(output_addr + ms->s.offset));

	/*
	 * If saving relocation entries the create the proper relocation entry
	 * for the literal pointer and put it in the file.
	 */
	if(save_reloc || output_for_dyld){
	    if(output_for_dyld){
		extreloc = (struct relocation_info *)(output_addr +
                            output_dysymtab_info.dysymtab_command.extreloff +
                            ms->iextrel * sizeof(struct relocation_info));
		reloc = (struct relocation_info *)(output_addr +
                            output_dysymtab_info.dysymtab_command.locreloff +
                            ms->ilocrel * sizeof(struct relocation_info));
		sreloc = (struct scattered_relocation_info *)reloc;

		/*
		 * For MH_SPLIT_SEGS images the r_address is relative to the
		 * first read-write segment and there are no relocation entries
		 * allowed in the read-only segments.  This is needed because
		 * the r_address field in a scattered relocation entry is 24
		 * bits which means that the normal split of 265meg wouldn't
		 * allow the use of 24 bits from the address of the first
		 * segment which is what is normally used for outputs for dyld.
		 */
		if(segs_read_only_addr_specified == TRUE)
		    r_address = ms->s.addr - segs_read_write_addr;
		else
		    r_address = ms->s.addr - merged_segments->sg.vmaddr;
	    }
	    else{
		extreloc = NULL;
		reloc = (struct relocation_info *)(output_addr + ms->s.reloff);
		sreloc = (struct scattered_relocation_info *)reloc;
		r_address = 0;
	    }

	    for(p = &(data->literal_pointer_blocks);
		*p ;
		p = &(literal_pointer_block->next)){

		literal_pointer_block = *p;
		literal_pointers = literal_pointer_block->literal_pointers;
		for(i = 0; i < literal_pointer_block->used; i++){
		    /*
		     * If the pointer is made up from an undefined merged 
		     * symbol and external relocation entry is created.
		     */
		    if(literal_pointers[i].merged_symbol != NULL){
			if(output_for_dyld)
			    r = extreloc;
			else
			    r = reloc;
			r->r_address = r_address;
			r->r_symbolnum =
				merged_symbol_output_index(
					literal_pointers[i].merged_symbol);
			r->r_pcrel = 0;
			r->r_length = 2;
			r->r_extern = 1;
			r->r_type = 0;
			if(output_for_dyld)
			    extreloc++;
			else
			    reloc++;
		    }
		    /*
		     * For an file with a dynamic linker load command only
		     * external relocation entries for undefined symbols are
		     * kept.  Which are handled above. So if this file has
		     * a dynamic linker load command the remaining relocation
		     * entries are local and not kept in the output.
		     */
		    else if(has_dynamic_linker_command){
			continue;
		    }
		    /*
		     * If the offset added to the item to be relocated is
		     * zero then local relocation entry is created.
		     */
		    else if(literal_pointers[i].offset == 0){
			reloc->r_address = r_address;
			reloc->r_symbolnum =
				 literal_pointers[i].literal_ms->output_sectnum;
			reloc->r_pcrel = 0;
			reloc->r_length = 2;
			reloc->r_extern = 0;
			reloc->r_type = 0;
			reloc++;
			sreloc++;
		    }
		    /*
		     * The offset added to the item to be relocated is NOT
		     * zero so a scattered relocation entry is created.
		     */
		    else{
			sreloc->r_scattered = 1;
			sreloc->r_pcrel = 0;
			sreloc->r_length = 2;
			sreloc->r_type = 0;
			sreloc->r_address = r_address;
			sreloc->r_value =
				      literal_pointers[i].literal_ms->s.addr +
				      literal_pointers[i].merged_section_offset;
			reloc++;
			sreloc++;
		    }
		    r_address += 4;
		}
	    }
	    if(output_for_dyld){
		if(host_byte_sex != target_byte_sex){
		    swap_relocation_info((struct relocation_info *)
			    (output_addr +
                            output_dysymtab_info.dysymtab_command.extreloff +
                            ms->iextrel * sizeof(struct relocation_info)),
			    ms->nextrel, target_byte_sex);
		    swap_relocation_info((struct relocation_info *)
			    (output_addr +
                            output_dysymtab_info.dysymtab_command.locreloff +
                            ms->ilocrel * sizeof(struct relocation_info)),
			    ms->nlocrel, target_byte_sex);
		}
		output_flush(output_dysymtab_info.dysymtab_command.extreloff +
                             ms->iextrel * sizeof(struct relocation_info),
			     ms->nextrel * sizeof(struct relocation_info));
		output_flush(output_dysymtab_info.dysymtab_command.locreloff +
                             ms->ilocrel * sizeof(struct relocation_info),
			     ms->nlocrel * sizeof(struct relocation_info));
	    }
	    else{
		if(host_byte_sex != target_byte_sex)
		    swap_relocation_info((struct relocation_info *)
			    (output_addr + ms->s.reloff), ms->s.nreloc,
			    target_byte_sex);
		output_flush(ms->s.reloff,
			     ms->s.nreloc * sizeof(struct relocation_info));
	    }
	}
#endif /* !defined(RLD) */

	literal_pointer_free(data);
}

/*
 * literal_pointer_free() free()'s up all space used by the data block except 
 * the data block itself.
 */
__private_extern__
void
literal_pointer_free(
struct literal_pointer_data *data)
{
    unsigned long i;
    struct literal_pointer_bucket *bp, *next_bp;
    struct literal_pointer_block *literal_pointer_block,
				 *next_literal_pointer_block;

	/*
	 * Free all data for this block.
	 */
	if(data->hashtable != NULL){
	    for(i = 0; i < LITERAL_POINTER_HASHSIZE; i++){
		for(bp = data->hashtable[i]; bp; ){
		    next_bp = bp->next;
		    free(bp);
		    bp = next_bp;
		}
	    }
	    free(data->hashtable);
	    data->hashtable = NULL;
	}
	for(literal_pointer_block = data->literal_pointer_blocks;
	    literal_pointer_block;
	    literal_pointer_block = next_literal_pointer_block){

	    next_literal_pointer_block = literal_pointer_block->next;
	    free(literal_pointer_block);
	}
	data->literal_pointer_blocks = NULL;
}

#ifdef DEBUG
/*
 * print_literal_pointer_data() prints a literal_pointer_data.  Used for
 * debugging.
 */
__private_extern__
void
print_literal_pointer_data(
struct literal_pointer_data *data, 
char *indent)
{
    unsigned long i;
    struct literal_pointer_block **p, *literal_pointer_block;
    struct literal_pointer *literal_pointers;

	print("%sliteral pointer data at 0x%x\n", indent, (unsigned int)data);
	if(data == NULL)
	    return;
	for(p = &(data->literal_pointer_blocks);
	    *p ;
	    p = &(literal_pointer_block->next)){

	    literal_pointer_block = *p;
	    literal_pointers = literal_pointer_block->literal_pointers;
	    print("%sused %lu\n", indent, literal_pointer_block->used);
	    for(i = 0; i < literal_pointer_block->used; i++){
		if(literal_pointers[i].merged_symbol != NULL){
		    print("%s    symbol %s offset %lu\n", indent,
			  literal_pointers[i].merged_symbol->nlist.n_un.n_name,
			  literal_pointers[i].offset);
		}
		else{
		    print("%s    section (%.16s,%.16s) section_offset %lu "
			  "offset %lu\n", indent,
			  literal_pointers[i].literal_ms->s.segname,
			  literal_pointers[i].literal_ms->s.sectname,
			  literal_pointers[i].merged_section_offset,
			  literal_pointers[i].offset);
		}
	    }
	}
}

/*
 * literal_pointer_data_stats() prints the literal_pointer_data stats.  Used for
 * tuning.
 */
__private_extern__
void
literal_pointer_data_stats(
struct literal_pointer_data *data,
struct merged_section *ms)
{
	if(data == NULL)
	    return;
	print("literal pointer section (%.16s,%.16s) contains:\n",
	      ms->s.segname, ms->s.sectname);
	print("    %u merged literal pointers\n", ms->s.size / 4);
	print("    from %lu files and %lu total literal pointers from those "
	      "files\n", data->nfiles, data->nliterals);
	print("    average number of literals per file %g\n",
	      (double)((double)data->nliterals / (double)(data->nfiles)));
	if(data->nprobes != 0){
	    print("    average number of hash probes %g\n",
	      (double)((double)data->nprobes / (double)(data->nliterals)));
	}
}
#endif /* DEBUG */
                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/literal_pointers.h                       0100644 0001750 0001750 00000011340 12612724205 024565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * The literal_data which is set into a merged_section's literal_data field for
 * S_LITERAL_POINTERS sections.  The external functions declared at the end of
 * this file operate on this data and are used for the other fields of a
 * merged_section for literals (literal_merge, literal_write, and literal_free).
 */
struct literal_pointer_data {
    struct literal_pointer_bucket **hashtable;	/* the hash table */
    struct literal_pointer_block		/* the literal pointers */
	*literal_pointer_blocks;
    struct literal_pointer_load_order_data/* the load order info needed to */
	*literal_pointer_load_order_data; /*  re-merge when using -dead_strip */
#ifdef DEBUG
    unsigned long nfiles;	/* number of files with this section */
    unsigned long nliterals;	/* total number of literal pointers in the */
				/*  input files merged into this section  */
    unsigned long nprobes;	/* number of hash probes */
#endif /* DEBUG */
};

/* the number of entries in the hash table */
#define LITERAL_POINTER_HASHSIZE 1000

/* the hash bucket entries in the hash table points to; allocated as needed */
struct literal_pointer_bucket {
    struct literal_pointer
	*literal_pointer;	/* pointer to the literal pointer */
    unsigned long output_offset;/* offset to this pointer in the output file */
    struct literal_pointer_bucket
	*next;			/* next in the hash chain */
};

/* The structure to hold a literal pointer.   This can be one of two things,
 * if the symbol is undefined then merged_symbol is not NULL and points to
 * a merged symbol and with offset defines the merged literal, second the
 * literal being pointed to is in the merged section literal_ms and is at
 * merged_section_offset in that section and offset is added.
 */
struct literal_pointer {
    struct merged_section *literal_ms;	
    unsigned long merged_section_offset;
    unsigned long offset;
    struct merged_symbol *merged_symbol;
};

/* the number of entries each literal pointer block*/
#define LITERAL_POINTER_BLOCK_SIZE 1000
/* the blocks that store the literals; allocated as needed */
struct literal_pointer_block {
    unsigned long used;			/* the number of literals used in */
    struct literal_pointer		/*  this block */
	literal_pointers
	[LITERAL_POINTER_BLOCK_SIZE];	/* the literal pointers */
    struct literal_pointer_block *next;	/* the next block */
};

/* the load order info needed to re-merge when using -dead_strip */
struct literal_pointer_load_order_data {
    char *order_line_buffer;
    unsigned long nliteral_pointer_order_lines;
    struct literal_pointer_order_line *literal_pointer_order_lines;
};
/* the load order info for a single literal pointer order line */
struct literal_pointer_order_line {
    unsigned character_index;
    unsigned long line_number;
    unsigned long output_offset;
};

__private_extern__ void literal_pointer_merge(
    struct literal_pointer_data *data, 
    struct merged_section *ms,
    struct section *s, 
    struct section_map *section_map,
    enum bool redo_live);

__private_extern__ void literal_pointer_order(
    struct literal_pointer_data *data, 
    struct merged_section *ms);

__private_extern__ void literal_pointer_reset_live(
    struct literal_pointer_data *data, 
    struct merged_section *ms);

__private_extern__ void literal_pointer_output(
    struct literal_pointer_data *data, 
    struct merged_section *ms);

__private_extern__ void literal_pointer_free(
    struct literal_pointer_data *data);

#ifdef DEBUG
__private_extern__ void print_literal_pointer_data(
    struct literal_pointer_data *data, 
    char *ident);
__private_extern__ void literal_pointer_data_stats(
    struct literal_pointer_data *data,
    struct merged_section *ms);
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/live_refs.h                              0100644 0001750 0001750 00000003326 12612724205 023171  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * For dead stipping the routine mark_fine_relocs_references_live() calls a
 * machine dependent *_get_reloc_refs() routine that fills in the live_refs
 * structure for a relocation entry in a section.
 */
enum live_ref_type {
    LIVE_REF_NONE,	/* there is no reference */
    LIVE_REF_VALUE,	/* the reference is in value, an address in on one
			   of the object's sections */
    LIVE_REF_SYMBOL	/* the reference is in the merged_symbol */
};
    
struct live_ref {
    enum live_ref_type ref_type;
    unsigned long value;
    struct merged_symbol *merged_symbol;
};

struct live_refs {
   struct live_ref ref1;
   struct live_ref ref2;
};
                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/m88k_reloc.c                             0100644 0001750 0001750 00000112305 12612724205 023157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to do relocation for the m88k.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/m88k/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "m88k_reloc.h"
#include "indirect_sections.h"
#include "dylibs.h"

/*
 * m88k_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 */
__private_extern__
void
m88k_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map)
{
    unsigned long i, j, symbolnum, value, input_pc, output_pc;
    unsigned long instruction, immediate;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_m88k r_type, pair_r_type;
    unsigned short other_half;
    unsigned long offset;

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler "warnings: ... may be used uninitialized in this
	 * function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	instruction = 0;
	other_half = 0;
	immediate = 0;
	offset = 0;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	pair_local_map = NULL;
#endif /* defined(DEBUG) || defined(RLD) */

	for(i = 0; i < section_map->s->nreloc; i++){
	    force_extern_reloc = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_m88k)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a M88K_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * M88K_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A M88K_RELOC_PAIR
		 * only follows M88K_RELOC_HI16, M88K_RELOC_LO16 and
		 * M88K_RELOC_SECTDIFF relocation types and it is an error
		 * to see one otherwise.
		 */
		if(r_type == M88K_RELOC_PAIR){
		    error_with_cur_obj("stray relocation M88K_RELOC_PAIR entry "
			"(%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_m88k)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * M88K_RELOC_PAIR relocation types only follow M88K_RELOC_HI16,
	     * M88K_RELOC_LO16 and M88K_RELOC_SECTDIFF relocation types and it 
	     * is an error to see one otherwise.
	     */
	    if(r_type == M88K_RELOC_PAIR){
		error_with_cur_obj("stray relocation M88K_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section (Note
	     * that this is not the case for M88K_RELOC_PAIR entries but this
	     * can't be one with the above checks).
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.
	     */
	    pair_r_type = (enum reloc_type_m88k)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == M88K_RELOC_HI16 || r_type == M88K_RELOC_LO16){
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc  = NULL;
			pair_r_type = (enum reloc_type_m88k)spair_reloc->r_type;
			other_half  = spair_reloc->r_address & 0xffff;
		    }
		    else{
			pair_r_type = (enum reloc_type_m88k)pair_reloc->r_type;
			other_half  = pair_reloc->r_address & 0xffff;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != M88K_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"M88K_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
	    }
	    else if(r_type == M88K_RELOC_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is M88K_RELOC_SECTDIFF but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_m88k)spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != M88K_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"M88K_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry (or scattered entry).
	     */
	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in m88k_reloc() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in m88k_reloc() symbol index %lu"
			    " in above file not in undefined map", symbolnum);
		    }
		}
		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		   (get_output_section(merged_symbol->nlist.n_sect)->
		    flags & SECTION_TYPE) == S_COALESCED){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    input_pc = section_map->s->addr + r_address;
		    if(r_type == M88K_RELOC_VANILLA){
			switch(r_length){
			case 0: /* byte */
			    offset = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    offset = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    offset = get_long((long *)(contents + r_address));
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
			if(r_pcrel)
			    offset += input_pc;
		    }
		    else{
			instruction = get_long((long *)(contents + r_address));
			switch(r_type){
			case M88K_RELOC_HI16:
			    offset = ((instruction & 0xffff) << 16) |
				     other_half;
			    break;
			case M88K_RELOC_LO16:
			    offset = (other_half << 16) |
				     (instruction & 0xffff);
			    break;
			case M88K_RELOC_PC16:
			    offset = instruction & 0xffff;
			    /* sign extend if needed */
			    if((offset & 0x8000) != 0)
				    offset |= 0xffff0000;
			    /*
			     * The offset is always a 32 bit word displacement.
			     */
			    offset <<= 2;
			    offset += input_pc;
			    break;
			case M88K_RELOC_PC26:
			    offset = instruction & 0x03ffffff;
			    /* sign extend if needed */
			    if((offset & 0x02000000) != 0)
				offset |= 0xfc000000;
			    /*
			     * The offset is always a 32 bit word displacement.
			     */
			    offset <<= 2;
			    offset += input_pc;
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
		    }
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT)
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum != R_ABS){
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    if(local_map->s->flags & S_ATTR_DEBUG){
			error_with_cur_obj("illegal reference to debug section,"
			    " from non-debug section (%.16s,%.16s) via "
			    "relocation entry (%lu) to section (%.16s,%.16s)",
			    section_map->s->segname, section_map->s->sectname,
			    i, local_map->s->segname, local_map->s->sectname);
			return;
		    }
		    pair_local_map = NULL;
		    if(r_type == M88K_RELOC_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
			if(pair_local_map->s->flags & S_ATTR_DEBUG){
			    error_with_cur_obj("illegal reference to debug "
				"section, from non-debug section (%.16s,%.16s) "
				"via relocation entry (%lu) to section (%.16s,"
				"%.16s)", section_map->s->segname,
				section_map->s->sectname, i,
				pair_local_map->s->segname,
				pair_local_map->s->sectname);
			    return;
			}
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == M88K_RELOC_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation the value is set (not adjusted
			 * with addition).  So the new value is directly
			 * calculated from the old value.
			 */
			if(r_pcrel){
			    input_pc = section_map->s->addr +
				       r_address;
			    if(section_map->nfine_relocs == 0)
				output_pc = section_map->output_section->s.addr
					    + section_map->offset +
					    r_address;
			    else
				output_pc = section_map->output_section->s.addr
					    + 
					fine_reloc_output_offset(section_map,
								 r_address);
			}
			else{
			    input_pc = 0;
			    output_pc = 0;
			}
			/*
			 * Get the value of the expresion of the item to be
			 * relocated.
			 */
			if(r_type == M88K_RELOC_VANILLA ||
			   r_type == M88K_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				value = get_byte((char *)(contents +
							  r_address));
				break;
			    case 1: /* word (2 byte) */
				value = get_short((short *)(contents +
							    r_address));
				break;
			    case 2: /* long (4 byte) */
				value = get_long((long *)(contents +
							  r_address));
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			else{
			    instruction = get_long((long *)(contents +
							    r_address));
			    switch(r_type){
			    case M88K_RELOC_HI16:
				value = ((instruction & 0xffff) << 16) |
					other_half;
				break;
			    case M88K_RELOC_LO16:
				value = (other_half << 16) |
					(instruction & 0xffff);
				break;
			    case M88K_RELOC_PC16:
				value = instruction & 0xffff;
				if((value & 0x8000) != 0)
				    value |= 0xffff0000;
				value <<= 2;
				break;
			    case M88K_RELOC_PC26:
				value = instruction & 0x03ffffff;
				if((value & 0x02000000) != 0)
				    value |= 0xfc000000;
				value <<= 2;
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			if(r_type == M88K_RELOC_SECTDIFF){
			    /*
			     * For M88K_RELOC_SECTDIFF's the item to be
			     * relocated, in value, is the value of the
			     * expression:
			     *     r_value - pair_r_value + offset
			     * To set the value of the relocated expression,
			     * it is set from relocating the two r_value's and
			     * adding back in the offset.  So here get the
			     * offset from the value of the expression.
			     */
			    value += input_pc; /* adjust for pcrel */
			    offset = value - r_value + pair_r_value;

			    /*
			     * Now build up the value of the relocated
			     * expression one part at a time.  First set the
			     * new value to the relocated r_value.
			     */
		    	    if(local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    local_map, r_value - local_map->s->addr +
				    offset, i, TRUE);
				value = fine_reloc_output_address(local_map,
					    r_value - local_map->s->addr,
					    local_map->output_section->s.addr);
			    }
			    else{
				value = local_map->output_section->s.addr +
					local_map->offset +
					r_value - local_map->s->addr;
			    }
			    /* Second subtract the relocated pair_r_value. */
			    if(pair_local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    pair_local_map, pair_r_value -
				    pair_local_map->s->addr, i, TRUE);
				value -=
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
				        pair_local_map->output_section->s.addr);
			    }
			    else{
				value -=
				    pair_local_map->output_section->s.addr +
				    pair_local_map->offset +
				    pair_r_value - pair_local_map->s->addr;
			    }
			    /* Third add in the offset. */
			    value += offset;
			    value -= output_pc; /* adjust for pcrel */
			}
			else{
			    /*
			     * If the relocation entry is not a scattered
			     * relocation entry then the relocation is based on
			     * the value of value of the expresion of the item
			     * to be relocated.  If it is a scattered relocation
			     * entry then the relocation is based on the r_value
			     * in the relocation entry and the offset part of
			     * the expression at the item to be relocated is
			     * extracted so it can be added after the relocation
			     * is done.
			     */
			    value += input_pc;
			    if(r_scattered == 0){
				r_value = value;
				offset = 0;
			    }
			    else{
				offset = value - r_value;
			    }
			    /*
			     * Check to see if this reference is legal with
			     * respect to indirect sections.
			     */
			    legal_reference(section_map, r_address, local_map,
				    r_value - local_map->s->addr + offset, i,
				    FALSE);
			    value = fine_reloc_output_address(local_map,
					r_value - local_map->s->addr,
					local_map->output_section->s.addr);
			    value -= output_pc;
			    value += offset;
			}
			if(r_type == M88K_RELOC_VANILLA ||
			   r_type == M88K_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				if( (value & 0xffffff00) &&
				   ((value & 0xffffff80) != 0xffffff80))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 1 byte", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_byte((char *)(contents + r_address), value);
				break;
			    case 1: /* word (2 byte) */
				if( (value & 0xffff0000) &&
				   ((value & 0xffff8000) != 0xffff8000))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 2 bytes", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_short((short *)(contents + r_address),
					  value);
				break;
			    case 2: /* long (4 byte) */
				set_long((long *)(contents + r_address), value);
				break;
			    default:
				error_with_cur_obj("r_length field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			}
			else{
			    switch(r_type){
			    case M88K_RELOC_HI16:
				other_half = value & 0xffff;
				instruction = (instruction & 0xffff0000) |
					      ((value >> 16) & 0xffff);
				break;
			    case M88K_RELOC_LO16:
				other_half = (value >> 16) & 0xffff;
				instruction = (instruction & 0xffff0000) |
					      (value & 0xffff);
				break;
			    case M88K_RELOC_PC16:
				if((value & 0xfffe0000) != 0xfffe0000 &&
				   (value & 0xfffe0000) != 0x00000000)
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
				value >>= 2;
				instruction = (instruction & 0xffff0000) |
					      (value & 0xffff);
				break;
			    case M88K_RELOC_PC26:
				if((value & 0xf8000000) != 0xf8000000 &&
				   (value & 0xf8000000) != 0x00000000)
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
				value >>= 2;
				instruction = (instruction & 0xfc000000) |
					      (value & 0x03ffffff);
				break;
			    default:
				error_with_cur_obj("r_type field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			    set_long((long *)(contents + r_address),
				     instruction);
			}

			goto update_reloc;
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr /* + r_address */
			     - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else
		    value += + section_map->s->addr + r_address
			     - (section_map->output_section->s.addr +
			        fine_reloc_output_offset(section_map,
							 r_address));
	    }
	    if(r_type == M88K_RELOC_VANILLA ||
	       r_type == M88K_RELOC_SECTDIFF){
		switch(r_length){
		case 0: /* byte */
		    value += get_byte((char *)(contents + r_address));
		    if( (value & 0xffffff00) &&
		       ((value & 0xffffff80) != 0xffffff80))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 1 byte", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_byte((char *)(contents + r_address), value);
		    break;
		case 1: /* word (2 byte) */
		    value += get_short((short *)(contents + r_address));
		    if( (value & 0xffff0000) &&
		       ((value & 0xffff8000) != 0xffff8000))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 2 bytes", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_short((short *)(contents + r_address), value);
		    break;
		case 2: /* long (4 byte) */
		    value += get_long((long *)(contents + r_address));
		    set_long((long *)(contents + r_address), value);
		    break;
		default:
		    error_with_cur_obj("r_length field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * Do m88k specific relocation based on the r_type.
	     */
	    else{
		instruction = get_long((long *)(contents + r_address));
		switch(r_type){
		case M88K_RELOC_HI16:
		    immediate = ((instruction & 0xffff) << 16) |
				other_half;
		    immediate += value;
		    instruction = (instruction & 0xffff0000) |
				  ((immediate >> 16) & 0xffff);
		    other_half = immediate & 0xffff;
		    break;
		case M88K_RELOC_LO16:
		    immediate = (other_half << 16) |
				(instruction & 0xffff);
		    immediate += value;
		    instruction = (instruction & 0xffff0000) |
				  (immediate & 0xffff);
		    other_half = (immediate >> 16) & 0xffff;
		    break;
		case M88K_RELOC_PC16:
		    immediate = instruction & 0xffff;
		    if((immediate & 0x8000) != 0)
			    immediate |= 0xffff0000;
		    immediate <<= 2;
		    immediate += value;
		    if((immediate & 0xfffe0000) != 0xfffe0000 &&
		       (immediate & 0xfffe0000) != 0x00000000)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    immediate >>= 2;
		    instruction = (instruction & 0xffff0000) |
				  (immediate & 0xffff);
		    break;
		case M88K_RELOC_PC26:
		    immediate = instruction & 0x03ffffff;
		    if((immediate & 0x02000000) != 0)
			immediate |= 0xfc000000;
		    immediate <<= 2;
		    immediate += value;
		    if((immediate & 0xf8000000) != 0xf8000000 &&
		       (immediate & 0xf8000000) != 0x00000000)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    immediate >>= 2;
		    instruction = (instruction & 0xfc000000) |
		    		  (immediate & 0x03ffffff);
		    break;
		default:
		    error_with_cur_obj("r_type field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		set_long((long *)(contents + r_address), instruction);
	    }

	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
update_reloc:
	    ;
#ifndef RLD
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a M88K_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = M88K_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		            (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		            force_extern_reloc == FALSE &&
		            ((filetype != MH_DYLIB ||
			      multi_module_dylib == FALSE) ||
			     (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value and the output is not for
			     * dyld make it a scattered relocation entry else
			     * make it a local relocation entry.
			     */
			    if(offset == 0 || output_for_dyld){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = r_type;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a M88K_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = M88K_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    else if(reloc->r_symbolnum != R_ABS){
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		}
		else{
		    /*
		     * This is a scattered relocation entry.  If the output is
		     * for dyld convert it to a local relocation entry so as
		     * to not overflow the 24-bit r_address field in a scattered
		     * relocation entry.  The overflow would happen in
		     * reloc_output_for_dyld() in sections.c when it adjusts
		     * the r_address fields of the relocation entries.
		     */
		    if(output_for_dyld){
			reloc = (struct relocation_info *)sreloc;
			r_scattered = 0;
			reloc->r_address = r_address;
			reloc->r_pcrel = r_pcrel;
			reloc->r_extern = 0;
			reloc->r_length = r_length;
			reloc->r_type = r_type;
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		    else{
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(local_map->nfine_relocs == 0)
			    sreloc->r_value +=
					   - local_map->s->addr
					   + local_map->output_section->s.addr +
					   local_map->offset;
			else
			    sreloc->r_value =
					fine_reloc_output_address(local_map,
						r_value - local_map->s->addr,
					   local_map->output_section->s.addr);
		    }
		}
		/*
		 * If this section that the reloation is being done for has fine
		 * relocation then the offset in the r_address field has to be
		 * set to where it will end up in the output file.  Otherwise
		 * it simply has to have the offset to where this contents
		 * appears in the output file. 
		 */
		if(r_scattered == 0){
		    if(section_map->nfine_relocs == 0){
			reloc->r_address += section_map->offset;
		    }
		    else{
			reloc->r_address = fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		else{
		    if(section_map->nfine_relocs == 0){
			sreloc->r_address += section_map->offset;
		    }
		    else{
			sreloc->r_address =fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == M88K_RELOC_PAIR){
		    if(pair_reloc != NULL)
			pair_reloc->r_address = other_half;
		    else if(spair_reloc != NULL){
			if(r_type == M88K_RELOC_SECTDIFF){
			    /*
			     * For M88K_RELOC_SECTDIFF relocation entries (which
			     * are always scattered types) the r_value field is
			     * relocated.
			     */
			    if(pair_local_map->nfine_relocs == 0)
				spair_reloc->r_value +=
				    - pair_local_map->s->addr
				    + (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			    else
				spair_reloc->r_value =
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
					pair_local_map->output_section->s.addr);
			}
			else{
			    spair_reloc->r_address = other_half;
			}
		    }
		    else{
			fatal("internal error, in m88k_reloc() pair_r_type "
			    "is M88K_RELOC_PAIR but pair_reloc and spair_reloc "
			    "are NULL");
		    }
		}
	    }
#endif /* !defined(RLD) */
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == M88K_RELOC_PAIR)
		i++;
	}
}
                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/m88k_reloc.h                             0100644 0001750 0001750 00000002612 12612724205 023163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file m88k_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void m88k_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *map);
                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/mod_sections.c                           0100644 0001750 0001750 00000030561 12612724205 023675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that deal with module initialization and
 * termination function pointer sections. 
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "mod_sections.h"

#ifndef RLD
/*
 * For MH_DYLIB formats only one module initialization and one module
 * termination function pointer section is allowed.  The module table has
 * indexes and counts of the number of entries in this section for each module
 * in a MH_DYLIB format file.  These variables are used for this.
 */
static struct merged_section *dylib_ms_init = NULL;
static struct merged_section *dylib_ms_term = NULL;
__private_extern__ unsigned long ninit = 0;
__private_extern__ unsigned long nterm = 0;
#endif /* !defined(RLD) */

/*
 * mod_section_merge() is used to check the section looks ok for a module
 * initialization or termination function pointer section.  After this the rest
 * of the link editor treats it like a regular section in how it's relocated and
 * output.  When redo_live is TRUE it re-merges only the live pointers based on
 * the live bit in the previouly allocated fine_relocs.
 */
__private_extern__
void
mod_section_merge(
struct mod_term_data *data,
struct merged_section *ms,
struct section *s, 
struct section_map *section_map,
enum bool redo_live)
{
    unsigned long i, npointers, nlive_pointers;
    struct relocation_info *relocs, reloc;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address, r_pcrel, r_length, r_type;
    char *type_name;
    struct fine_reloc *fine_relocs;
#ifdef __MWERKS__
    void *dummy;
        dummy = data;
#endif
	if((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS)
	    type_name = "initialization";
	else
	    type_name = "termination";

	/*
	 * Module initialization and termination function pointer sections must
	 * contain only pointers to functions.  Each of these pointers should be
	 * 4 bytes and have a relocation entry.  A good number of checks are
	 * done here to make sure that things are ok but it is not exaustive.
	 * There could be multiple relocation entries for the same address and
	 * there is no check for what the relocation entry points at (a check
	 * could be done to see that it points to a section with the attribute
	 * S_ATTR_PURE_INSTRUCTIONS).
	 */
	if(s->size % 4 != 0){
	    error_with_cur_obj("module %s function pointer section (%.16s,"
		"%.16s) size is not a multiple of 4 bytes", type_name,
		s->segname, s->sectname);
	    return;
	}
	if(s->nreloc != s->size / 4){
	    error_with_cur_obj("module %s function pointer section (%.16s,"
		"%.16s) does not have is exactly one relocation entry for each "
		"pointer\n", type_name, s->segname, s->sectname);
	    return;
	}
	relocs = (struct relocation_info *)(cur_obj->obj_addr + s->reloff);
	for(i = 0; i < s->nreloc; i++){
	    reloc = relocs[i];
	    if(cur_obj->swapped &&
	       section_map->input_relocs_already_swapped == FALSE)
		swap_relocation_info(&reloc, 1, host_byte_sex);
	    /*
	     * Break out the fields of the relocation entry we need here.
	     */
	    if((reloc.r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(&reloc);
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_type = sreloc->r_type;
	    }
	    else{
		r_address = reloc.r_address;
		r_pcrel = reloc.r_pcrel;
		r_length = reloc.r_length;
		r_type = reloc.r_type;
	    }
	    /*
	     * For a module initialization and termination function pointer
	     * sections all relocation entries must be for one of the pointers
	     * and therefore the offset must be a multiple of 4, have an
	     * r_length field of 2 (long), a r_pcrel field of 0 (FALSE) and a
	     * r_type of 0 (VANILLA).
	     */
	    if(r_address % 4 != 0){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%ld in module %s function pointer section (%.16s,%.16s) "
		    "is not a multiple of 4", (unsigned int)r_address, i,
		    type_name, s->segname, s->sectname);
		continue;
	    }
	    if(r_length != 2){
		error_with_cur_obj("r_length (0x%x) field of relocation entry "
		    "%ld in module %s function pointer section (%.16s,%.16s) "
		    "is not 2 (long)", (unsigned int)r_length, i, type_name,
		    s->segname, s->sectname);
		continue;
	    }
	    if(r_pcrel != 0){
		error_with_cur_obj("r_pcrel (0x%x) field of relocation entry "
		    "%ld in module %s function pointer section (%.16s,%.16s) "
		    "is not 0 (FALSE)", (unsigned int)r_pcrel, i, type_name,
		    s->segname, s->sectname);
		continue;
	    }
	    if(r_type != 0){
		error_with_cur_obj("r_type (0x%x) field of relocation entry "
		    "%ld in module %s function pointer section (%.16s,%.16s) "
		    "is not 0 (VANILLA)", (unsigned int)r_type, i, type_name,
		    s->segname, s->sectname);
		continue;
	    }
	}

#ifndef RLD
	/*
	 * For MH_DYLIB formats make sure there is only one module
	 * initialization and termination function pointer section and record
	 * the index into the output section and the number of enties for this
	 * object.
	 */
	if(filetype == MH_DYLIB){
	    if((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS){
		if(dylib_ms_init != NULL && dylib_ms_init != ms)
		    error("multiple module initialization function pointer "
			  "sections (%.16s,%.16s) and (%.16s,%.16s) only one "
			  "allowed in MH_DYLIB output", s->segname, s->sectname,
			  dylib_ms_init->s.segname, dylib_ms_init->s.sectname);
		dylib_ms_init = ms;
		cur_obj->ninit = s->size / 4;
		cur_obj->iinit = ninit;
		ninit += cur_obj->ninit;
		if(ninit > 0xffff)
		    error("too many module initialization function pointer in "
			  "section (%.16s,%.16s) in MH_DYLIB output (maximum "
			  "is %d)", s->segname, s->sectname, 0xffff);
	    }
	    else{
		if(dylib_ms_term != NULL && dylib_ms_term != ms)
		    error("multiple module termination function pointer "
			  "sections (%.16s,%.16s) and (%.16s,%.16s) only one "
			  "allowed in MH_DYLIB output", s->segname, s->sectname,
			  dylib_ms_term->s.segname, dylib_ms_term->s.sectname);
		dylib_ms_term = ms;
		cur_obj->nterm = s->size / 4;
		cur_obj->iterm = nterm;
		nterm += cur_obj->nterm;
		if(nterm > 0xffff)
		    error("too many module termination function pointer in "
			  "section (%.16s,%.16s) in MH_DYLIB output (maximum "
			  "is %d)", s->segname, s->sectname, 0xffff);
	    }
	}
#endif /* !defined(RLD) */

	/*
	 * Check to see if the alignment will not leave zero pointers.
	 */
	if(s->align > 2)
	    warning_with_cur_obj("aligment greater than 2 (2^2, 4 bytes) for "
		"module %s function pointer section (%.16s,%.16s) (will leave "
		"holes with zeroes for pointers)", type_name, s->segname,
		s->sectname);

	/*
	 * Now that every thing looks ok do what would have been done in
	 * merge_sections() for regular sections.
	 */
	section_map->flush_offset = ms->s.size;
	if(redo_live == FALSE){
	    ms->s.size = rnd(ms->s.size, 1 << s->align);
	    section_map->offset = ms->s.size;
	    ms->s.size   += s->size;
	    ms->s.nreloc += s->nreloc;
	    nreloc += s->nreloc;
	}

	/*
	 * If we are doing dead stripping create a fine relocation structure
	 * for each pointer.
	 */
	if(dead_strip == TRUE){
	    if(redo_live == FALSE){
		npointers = s->size / 4;
		fine_relocs = allocate(npointers * sizeof(struct fine_reloc));
		memset(fine_relocs, '\0',npointers * sizeof(struct fine_reloc));

		/*
		 * Create a fine relocation structure for each pointer in the 
		 * section and record the offsets in the input file and map it
		 * to the next offset in the output file.  The fine reloc will
		 * later be marked live if needed.
		 */
		for(i = 0; i < npointers; i++){
		    fine_relocs[i].input_offset = i * 4;
		    fine_relocs[i].output_offset = data->output_offset;
		    data->output_offset += 4;
		}
		section_map->fine_relocs = fine_relocs;
		section_map->nfine_relocs = npointers;
	    }
	    else{
		/*
		 * Walk through the relocation structures and reset the
		 * output_offset for each of the live pointers.  Then increment
		 * the size of the section based on the number of live pointers.
		 */
		fine_relocs = section_map->fine_relocs;
		npointers = section_map->nfine_relocs;
		nlive_pointers = 0;
		for(i = 0; i < npointers; i++){
		    if(fine_relocs[i].live == TRUE){
/*
printf("mod init pointer live in %s (%.16s,%.16s) at offset 0x%x\n",
cur_obj->file_name, ms->s.segname, ms->s.sectname, (unsigned int)r_address);
*/
			fine_relocs[i].output_offset = data->output_offset;
			data->output_offset += 4;
			nlive_pointers++;
		    }
		    else{
/*
printf("mod init pointer dead in %s (%.16s,%.16s) at offset 0x%x\n",
cur_obj->file_name, ms->s.segname, ms->s.sectname, (unsigned int)r_address);
*/
			fine_relocs[i].output_offset = 0;
		    }
		}
		if(nlive_pointers != 0){
		    ms->s.size = rnd(ms->s.size, 1 << s->align);
		    section_map->offset = ms->s.size;
		    ms->s.size   += nlive_pointers * 4;
		    ms->s.nreloc += s->nreloc;
		    nreloc += s->nreloc;
		}
	    }
	}
}

/*
 * mod_section_order() is here to generate an error if a module initialization
 * or termination function pointer has a sectorder file.  Since the functions
 * are called in the order they appear the pointers appear in the section and
 * that order is guaranteed the section can't be order differently.
 */
__private_extern__
void
mod_section_order(
struct mod_term_data *data, 
struct merged_section *ms)
{
#ifndef RLD
    kern_return_t r;
    char *type_name;

	if((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS)
	    type_name = "initialization";
	else
	    type_name = "termination";

	error("section ordering for module %s function pointer sections not "
	      "allowed (-sectorder %s %s %s ignored)", type_name, ms->s.segname,
	      ms->s.sectname, ms->order_filename);
	/*
	 * Deallocate the memory for the load order file now that it is
	 * nolonger needed.
	 */
	if((r = vm_deallocate(mach_task_self(), (vm_address_t)
	    ms->order_addr, ms->order_size)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_deallocate() memory for -sectorder file: "
		       "%s for section (%.16s,%.16s)", ms->order_filename,
		       ms->s.segname, ms->s.sectname);
	ms->order_addr = NULL;
#endif /* !defined(RLD) */
}

/*
 * mod_section_reset_live() is called when -dead_strip is specified after
 * the initialization or termination function pointer sections the input
 * objects are merged.  It clears out the output_offset so the live pointers
 * can be re-merged (by later calling mod_section_merge() with redo_live ==
 * TRUE.
 */
__private_extern__
void
mod_section_reset_live(
struct mod_term_data *data, 
struct merged_section *ms)
{
#ifndef RLD
	/* reset the merge section size back to zero */
	ms->s.size = 0;

	/* reset the counts of the number of inits and terms back to zero */
	ninit = 0;
	nterm = 0;

	/* reset the count of relocation entries for this merged section */
	nreloc -= ms->s.nreloc;
	ms->s.nreloc = 0;

	/* clear the current value of output_offset */
	data->output_offset = 0;
#endif /* !defined(RLD) */
}

/*
 * mod_section_free() resets the output_offset in the data block.
 */
__private_extern__
void
mod_section_free(
struct mod_term_data *data)
{
	data->output_offset = 0;
}
                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/mod_sections.h                           0100644 0001750 0001750 00000003655 12612724205 023706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * The mod_term_data is only used when -dead_strip is specified to break up
 * the section so each pointer has a fine relocation entry.
 */
struct mod_term_data {
    unsigned long output_offset;
};

/*
 * Global types, variables and routines declared in the file modinit_sections.c.
 */
__private_extern__ unsigned long ninit;
__private_extern__ unsigned long nterm;

__private_extern__ void mod_section_merge(
    struct mod_term_data *data, 
    struct merged_section *ms,
    struct section *s, 
    struct section_map *section_map,
    enum bool redo_live);
__private_extern__ void mod_section_order(
    struct mod_term_data *data, 
    struct merged_section *ms);
__private_extern__ void mod_section_reset_live(
    struct mod_term_data *data, 
    struct merged_section *ms);
__private_extern__ void mod_section_free(
    struct mod_term_data *data);
                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/objects.c                                0100644 0001750 0001750 00000103120 12612724205 022630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to manage the table of object files to be
 * loaded.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <limits.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/mach.h>
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <ar.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "sets.h"

/*
 * The head of the object file list and the total count of all object files
 * in the list.  The number objects is only used in main() to tell if there
 * had been any objects loaded into the output file.
 */
__private_extern__ struct object_list *objects = NULL;
__private_extern__ unsigned long nobjects = 0;

/*
 * A pointer to the current object being processed in pass1 or pass2.
 */
__private_extern__ struct object_file *cur_obj = NULL;

/*
 * A pointer to the base object for an incremental link if not NULL.
 */
__private_extern__ struct object_file *base_obj = NULL;

/*
 * new_object_file() returns a pointer to the next available object_file
 * structrure.  The object_file structure is allways zeroed.
 */
__private_extern__
struct object_file *
new_object_file(void)
{
    struct object_list *object_list, **p;
    struct object_file *object_file;

	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    if(object_list->used == NOBJECTS)
		continue;
	    object_file = &(object_list->object_files[object_list->used]);
	    object_list->used++;
	    nobjects++;
#ifdef RLD
	    object_file->set_num = cur_set;
#endif /* RLD */
	    return(object_file);
	}
	*p = allocate(sizeof(struct object_list));
	object_list = *p;
	memset(object_list, '\0', sizeof(struct object_list));
	object_file = &(object_list->object_files[object_list->used]);
	object_list->used++;
	nobjects++;
#ifdef RLD
	object_file->set_num = cur_set;
#endif /* RLD */
	return(object_file);
}

#ifndef RLD
/*
 * object_index() returns the index into the module table for a object file
 * structure.  It is only used in the creation of the table of contents entries
 * in a multi module MH_DYLIB file.
 */
__private_extern__
unsigned long
object_index(
struct object_file *obj)
{
    unsigned long index, i;
    struct object_list *object_list, **p;
    struct object_file *cmp_obj;

	if(multi_module_dylib == FALSE)
	    return(0);
	index = 0;
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cmp_obj = &(object_list->object_files[i]);
		if(cmp_obj->dylib == TRUE)
		    continue;
		if(cmp_obj->bundle_loader == TRUE)
		    continue;
		if(cmp_obj == obj)
		    return(index);
		index++;
	    }
	}
	fatal("internal error: object_index() called with bad object file "
	      "pointer");
	return(0); /* to prevent warning from compiler */
}
#endif /* !defined(RLD) */

/*
 * add_last_object_file() adds the specified object file to the end of the
 * object file list.
 */
__private_extern__
struct object_file *
add_last_object_file(
struct object_file *new_object)
{
    struct object_file *last_object;

	last_object = new_object_file();
	*last_object = *new_object;
	return(last_object);
}

/*
 * remove_last_object_file() removes the specified object file from the end of
 * the object file list.
 */
__private_extern__
void
remove_last_object_file(
struct object_file *last_object)
{
    struct object_list *object_list, **p;
    struct object_file *object_file;

	object_file = NULL;
	object_list = NULL;
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    object_file = &(object_list->object_files[object_list->used - 1]);
	    if(object_list->used == NOBJECTS)
		continue;
	}
	if(object_file == NULL || object_file != last_object)
	    fatal("internal error: remove_last_object_file() called with "
		  "object file that was not the last object file");
	memset(object_file, '\0', sizeof(struct object_file));
	object_list->used--;
}

/*
 * Print the name of the specified object structure in the form: "filename ",
 * "archive(member) " or "dylib(member).
 */
__private_extern__
void
print_obj_name(
struct object_file *obj)
{
    char *strings;

	if(obj->ar_hdr != NULL){
	    print("%s(%.*s) ", obj->file_name, (int)obj->ar_name_size,
		  obj->ar_name);
	}
	else if(obj->dylib_module != NULL){
	    strings = obj->obj_addr + obj->symtab->stroff;
	    print("%s(%s) ", obj->file_name,
		  strings + obj->dylib_module->module_name);
	}
	else
	    print("%s ", obj->file_name);
}

__private_extern__
unsigned long
size_ar_name(
struct ar_hdr *ar_hdr)
{
    long i;

	i = sizeof(ar_hdr->ar_name) - 1;
	if(ar_hdr->ar_name[i] == ' '){
	    do{
		if(ar_hdr->ar_name[i] != ' ')
		    break;
		i--;
	    }while(i > 0);
	}
	return(i + 1);
}

/*
 * set_obj_resolved_path() sets the resolved_path field of the specified
 * object file structure to be used for N_OSO names.
 */
__private_extern__
void
set_obj_resolved_path(
struct object_file *obj)
{
#if !defined (SA_RLD) && !(defined(KLD) && defined(__STATIC__))
    char resolved_path[PATH_MAX];

	if(obj->resolved_path == NULL){
	    if(realpath(obj->file_name, resolved_path) == NULL)
		system_error("can't get resolved path to: %s", obj->file_name);
	    if(obj->ar_hdr != NULL){
		obj->resolved_path_len = strlen(resolved_path) +
					 obj->ar_name_size + 2;
		obj->resolved_path = allocate(obj->resolved_path_len + 1);
		strcpy(obj->resolved_path, resolved_path);
		strcat(obj->resolved_path, "(");
		strncat(obj->resolved_path, obj->ar_name, obj->ar_name_size);
		strcat(obj->resolved_path, ")");
	    }
	    else{
		obj->resolved_path_len = strlen(resolved_path);
		obj->resolved_path = allocate(obj->resolved_path_len + 1);
		strcpy(obj->resolved_path, resolved_path);
	    }
	}
#else /* defined(SA_RLD) || defined(KLD) && defined(__STATIC__) */
	obj->resolved_path_len = strlen(obj->file_name + 1);
	obj->resolved_path = obj->file_name;
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */
}

/*
 * print_whatsloaded() prints which object files are loaded.  This has to be
 * called after pass1 to get the correct result.
 */
__private_extern__
void
print_whatsloaded(void)
{
    unsigned long i;
    struct object_list *object_list, **p;
    struct object_file *obj;
    char *strings;

	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		obj = &(object_list->object_files[i]);
		if(obj->dylib && obj->dylib_module == NULL)
		    continue;
		if(obj->bundle_loader)
		    continue;
		if(obj->dylinker)
		    continue;
		if(obj->ar_hdr){
		    print("%s(%.*s)\n",obj->file_name,
			  (int)obj->ar_name_size, obj->ar_name);
		}
		else if(obj->dylib_module != NULL){
		    strings = obj->obj_addr + obj->symtab->stroff;
		    print("%s(%s)\n", obj->file_name,
			  strings + obj->dylib_module->module_name);
		}
		else
		    print("%s\n", obj->file_name);
	    }
	}
}

/*
 * is_dylib_module_loaded() returns TRUE is the specified dynamic library module
 * is already loaded and FALSE otherwise.  It is used by search_dynamic_libs()
 * to make sure the module that defines the library initialization routine is
 * loaded.
 */
__private_extern__
enum bool
is_dylib_module_loaded(
struct dylib_module *dylib_module)
{
    unsigned long i;
    struct object_list *object_list, **p;
    struct object_file *obj;

	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		obj = &(object_list->object_files[i]);
		if(obj->dylib && obj->dylib_module != NULL){
		    if(obj->dylib_module == dylib_module)
			return(TRUE);
		}
	    }
	}
	return(FALSE);
}

/*
 * fine_reloc_output_offset() returns the output offset for the specified 
 * input offset and the section map using the fine relocation entries.
 */
__private_extern__
unsigned long
fine_reloc_output_offset(
struct section_map *map,
unsigned long input_offset)
{
    struct fine_reloc *fine_reloc;
    unsigned long section_type;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);

	/*
	 * This routine is used to set the r_address field of relocation
	 * entries.  For entries that are part of a item who's contents is
	 * not used in the output file the return value here for r_address is
	 * to set it past the end of the section in the output file.  This is
	 * then checked for in fine_reloc_offset_in_output_for_output_offset()
	 * to know if the r_address (output_offet) is not in the output.
	 */
	section_type = map->s->flags & SECTION_TYPE;

	if(((section_type == S_LAZY_SYMBOL_POINTERS ||
	     section_type == S_NON_LAZY_SYMBOL_POINTERS ||
	     section_type == S_SYMBOL_STUBS ||
	     section_type == S_COALESCED) &&
	    fine_reloc->use_contents == FALSE) ||
	   (dead_strip == TRUE && fine_reloc->live == FALSE))
	    return(map->output_section->s.size +
	       input_offset - fine_reloc->input_offset);

	return(fine_reloc->output_offset +
	       input_offset - fine_reloc->input_offset);
}

/*
 * fine_reloc_output_address() returns the output_address for the input_offset
 * in the section with the specified section map.  This can return one of two
 * things depending on the fine relocation entry for the input_offset.  If the
 * section is a symbol stub section and the fine_relocation entry's indirect
 * symbol is defined then the value of the symbol is used.  Otherwise the output
 * offset for the fine relocation entry is added to the specified
 * output_base_address.
 */
__private_extern__
unsigned long
fine_reloc_output_address(
struct section_map *map,
unsigned long input_offset,
unsigned long output_base_address)
{
    struct fine_reloc *fine_reloc;
    struct merged_symbol *merged_symbol;
    unsigned long index;
    struct nlist *nlists;
    struct section_map *section_map;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if(fine_reloc->local_symbol == TRUE){
	    if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS){
		index = fine_reloc->output_offset;
		nlists = (struct nlist *)(cur_obj->obj_addr +
					  cur_obj->symtab->symoff);
		if(nlists[index].n_sect == NO_SECT)
		    return(nlists[index].n_value);
		section_map = &(cur_obj->section_maps[nlists[index].n_sect -1]);
		if(section_map->nfine_relocs == 0)
		    return(nlists[index].n_value - section_map->s->addr +
			   section_map->output_section->s.addr +
			   section_map->offset);
		else
		    return(section_map->output_section->s.addr +
			   fine_reloc_output_offset(section_map,
						    nlists[index].n_value -
						    section_map->s->addr));
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		    (map->s->flags & SECTION_TYPE) ==
						  S_NON_LAZY_SYMBOL_POINTERS){
		return(output_base_address +
		       fine_reloc->output_offset +
		       input_offset - fine_reloc->input_offset);
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_COALESCED){
		if(fine_reloc->use_contents == TRUE){
		    return(output_base_address +
			   fine_reloc->output_offset +
			   input_offset - fine_reloc->input_offset);
		}
		else{
		    merged_symbol = fine_reloc->merged_symbol;
		    if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
			merged_symbol = (struct merged_symbol *)
					merged_symbol->nlist.n_value;
		    return(merged_symbol->nlist.n_value);
		}
	    }
	    else{
		fatal("internal error, fine_reloc_output_address() called with "
		      "an input_offset which maps to a fine_reloc where "
		      "local_symbol is TRUE but it's not in a S_SYMBOL_STUBS, "
		      "S_LAZY_SYMBOL_POINTERS or S_COALESCED section");
		return(0);
	    }
	}
	else if((map->s->flags & SECTION_TYPE) == S_COALESCED){
	    if(fine_reloc->use_contents == TRUE){
		return(output_base_address +
		       fine_reloc->output_offset +
		       input_offset - fine_reloc->input_offset);
	    }
	    else{
		merged_symbol = fine_reloc->merged_symbol;
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		return(merged_symbol->nlist.n_value);
	    }
	}
	else if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
	        fine_reloc->indirect_defined == TRUE){
	    if(filetype != MH_DYLIB ||
	       (filetype == MH_DYLIB && multi_module_dylib == FALSE) ||
	       (cur_obj == fine_reloc->merged_symbol->definition_object &&
		input_offset - fine_reloc->input_offset == 0)){
		if(cur_obj == fine_reloc->merged_symbol->definition_object)
		    merged_symbol = fine_reloc->merged_symbol;
		else
		    merged_symbol = fine_reloc->merged_symbol;
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		return(merged_symbol->nlist.n_value);
	    }
	    else{
		return(output_base_address +
		       fine_reloc->output_offset +
		       input_offset - fine_reloc->input_offset);
	    }
	}
	else{
	    return(output_base_address +
		   fine_reloc->output_offset +
		   input_offset - fine_reloc->input_offset);
	}
}

/*
 * fine_reloc_output_ref() sets the live_ref for the input_offset in the section
 * with the specified section map as to what is being referenced in the linked
 * output.  This is used when -dead_strip is specified to drive the live marking
 * pass.  The value field of the live_ref for LIVE_REF_VALUE is an address in
 * the input object file (not it's address in the linked output).  This routine
 * can set the live_ref to one of two things depending on the fine relocation
 * entry for the input_offset.  If the section is a symbol stub section and the
 * fine_relocation entry's indirect symbol is defined then the symbol is used 
 * with a LIVE_REF_SYMBOL.  Otherwise the input_offset is added back to the
 * map->s->addr for a LIVE_REF_VALUE.
 */
__private_extern__
void
fine_reloc_output_ref(
struct section_map *map,
unsigned long input_offset,
struct live_ref *ref)
{
    struct fine_reloc *fine_reloc;
    struct merged_symbol *merged_symbol;
    unsigned long index;
    struct nlist *nlists;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if(fine_reloc->local_symbol == TRUE){
	    if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS){
		index = fine_reloc->output_offset;
		nlists = (struct nlist *)(cur_obj->obj_addr +
					  cur_obj->symtab->symoff);
		ref->ref_type = LIVE_REF_VALUE;
		ref->value = nlists[index].n_value;
		return;
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		    (map->s->flags & SECTION_TYPE) ==
						  S_NON_LAZY_SYMBOL_POINTERS){
		ref->ref_type = LIVE_REF_VALUE;
		ref->value = map->s->addr + input_offset;
		return;
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_COALESCED){
		if(fine_reloc->use_contents == TRUE){
		    ref->ref_type = LIVE_REF_VALUE;
		    ref->value = map->s->addr + input_offset;
		    return;
		}
		else{
		    merged_symbol = fine_reloc->merged_symbol;
		    if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
			merged_symbol = (struct merged_symbol *)
					merged_symbol->nlist.n_value;
		    ref->ref_type = LIVE_REF_SYMBOL;
		    ref->merged_symbol = merged_symbol;
		    return;
		}
	    }
	    else{
		fatal("internal error, fine_reloc_output_ref() called with "
		      "an input_offset which maps to a fine_reloc where "
		      "local_symbol is TRUE but it's not in a S_SYMBOL_STUBS, "
		      "S_LAZY_SYMBOL_POINTERS or S_COALESCED section");
		return;
	    }
	}
	else if((map->s->flags & SECTION_TYPE) == S_COALESCED){
	    if(fine_reloc->use_contents == TRUE){
		ref->ref_type = LIVE_REF_VALUE;
		ref->value = map->s->addr + input_offset;
		return;
	    }
	    else{
		merged_symbol = fine_reloc->merged_symbol;
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		ref->ref_type = LIVE_REF_SYMBOL;
		ref->merged_symbol = merged_symbol;
		return;
	    }
	}
	else if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
	        fine_reloc->indirect_defined == TRUE){
	    if(filetype != MH_DYLIB ||
	       (filetype == MH_DYLIB && multi_module_dylib == FALSE) ||
	       (cur_obj == fine_reloc->merged_symbol->definition_object &&
		input_offset - fine_reloc->input_offset == 0)){
		if(cur_obj == fine_reloc->merged_symbol->definition_object)
		    merged_symbol = fine_reloc->merged_symbol;
		else
		    merged_symbol = fine_reloc->merged_symbol;
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		ref->ref_type = LIVE_REF_SYMBOL;
		ref->merged_symbol = merged_symbol;
		return;
	    }
	    else{
		ref->ref_type = LIVE_REF_VALUE;
		ref->value = map->s->addr + input_offset;
		return;
	    }
	}
	else{
	    ref->ref_type = LIVE_REF_VALUE;
	    ref->value = map->s->addr + input_offset;
	    return;
	}
}

/*
 * fine_reloc_offset_in_output() returns TRUE if the input offset is part of a
 * range that will be in the output file.  This is used in processing the parts
 * of sections (contents, relocation entries, symbols) that get removed when
 * a section is a symbol stub section, lazy pointer section or coalesced
 * section or -dead_strip is specified.
 */
__private_extern__
enum bool
fine_reloc_offset_in_output(
struct section_map *map,
unsigned long input_offset)
{
    struct fine_reloc *fine_reloc;
    unsigned long section_type;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if(dead_strip == TRUE){
	    section_type = map->s->flags & SECTION_TYPE;
	    if(section_type == S_LAZY_SYMBOL_POINTERS ||
	       section_type == S_NON_LAZY_SYMBOL_POINTERS ||
	       section_type == S_SYMBOL_STUBS ||
	       section_type == S_COALESCED){
		if(fine_reloc->use_contents == FALSE)
		    return(FALSE);
	    }
	    return((enum bool)(fine_reloc->live));
	}
	return((enum bool)(fine_reloc->use_contents));
}

/*
 * fine_reloc_offset_in_output_for_output_offset() does the same as
 * fine_reloc_offset_in_output() but using the output_offset instead of the
 * input offset and returns TRUE if the output offset is part of a range that
 * will be in the output file.  This is used in reloc_output_for_dyld() in
 * determing if a relocation entry will be in the output file and is needed
 * because the r_address of a relocation entry was modified by the reloc
 * routine.
 */
__private_extern__
enum bool
fine_reloc_offset_in_output_for_output_offset(
struct section_map *map,
unsigned long output_offset)
{
	if(map->nfine_relocs == 0)
	    fatal("internal error, fine_reloc_offset_in_output_for_output_"
		  "offset() called with a map->nfine_relocs == 0");
	/*
	 * For relocation entries that were part of a item who's contents is
	 * not used in the output file fine_reloc_output_offset() was used to
	 * set it's r_address to past the end of the section in the output file.
	 * So in here we check for that and if that is the case we say the
	 * output_offset is not in the output otherwise it is in the output.
	 */
	if(output_offset >= map->output_section->s.size)
	    return(FALSE);
	else
	    return(TRUE);
}

/*
 * fine_reloc_output_sectnum() returns the section number in the output file
 * being referenced for the input_offset in the section with the specified
 * section map.  This can return one of two things depending on the fine
 * relocation entry for the input_offset.  If the section being referenced is
 * a symbol stub section and the fine_relocation entry's indirect symbol is
 * define then the section number of the merged symbol is used.  Otherwise the
 * section number of the referenced section has in the output is returned.
 */
__private_extern__
unsigned long
fine_reloc_output_sectnum(
struct section_map *map,
unsigned long input_offset)
{
    struct fine_reloc *fine_reloc;
    struct merged_symbol *merged_symbol;
    unsigned long index;
    unsigned long *indirect_symtab;
    struct nlist *nlists;
    struct section_map *section_map;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if(fine_reloc->local_symbol == TRUE){
	    if((map->s->flags & SECTION_TYPE) == S_COALESCED){
		return(map->output_section->output_sectnum);
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS){
		index = fine_reloc->output_offset;
	    }
	    else if((map->s->flags & SECTION_TYPE) ==
		     S_NON_LAZY_SYMBOL_POINTERS ||
	    	    (map->s->flags & SECTION_TYPE) ==
		     S_LAZY_SYMBOL_POINTERS){
		indirect_symtab = (unsigned long *)(cur_obj->obj_addr +
					    cur_obj->dysymtab->indirectsymoff);
		index = indirect_symtab[map->s->reserved1 + 
			(fine_reloc->input_offset / 4)];
	    }
	    else{
		fatal("internal error, fine_reloc_output_sectnum() called with "
		      "an input_offset which maps to a fine_reloc where "
		      "local_symbol is TRUE but it's not in a S_SYMBOL_STUBS, "
		      "S_NON_LAZY_SYMBOL_POINTERS, S_LAZY_SYMBOL_POINTERS or "
		      "S_COALESCED section");
		index = 0;
	    }
	    nlists = (struct nlist *)(cur_obj->obj_addr +
				      cur_obj->symtab->symoff);
	    if(nlists[index].n_sect == NO_SECT)
		return(NO_SECT);
	    section_map = &(cur_obj->section_maps[nlists[index].n_sect - 1]);
	    return(section_map->output_section->output_sectnum);
	}
	else if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
	        fine_reloc->indirect_defined == TRUE &&
	        (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
	    merged_symbol = fine_reloc->merged_symbol;
	    if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		merged_symbol = (struct merged_symbol *)
				merged_symbol->nlist.n_value;
	    return(merged_symbol->nlist.n_sect);
	}
	else{
	    return(map->output_section->output_sectnum);
	}
}

/*
 * fine_reloc_arm() returns TRUE if fine relocation entry for the input_offset
 * in the section specified is for a symbol stub for a defined external symbol 
 * that is an arm symbol and stub will not be used.  This information is needed
 * when relocating an arm branch instruction that is targetted to a symbol stub
 * that ends up going to target the address of an arm symbol. Then in this case
 * the branch instruction needs to be changed from a blx to a bl instruction.
 */
__private_extern__
enum bool
fine_reloc_arm(
struct section_map *map,
unsigned long input_offset)
{
    struct fine_reloc *fine_reloc;
    struct merged_symbol *merged_symbol;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
	    fine_reloc->indirect_defined == TRUE &&
	    (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
	    merged_symbol = fine_reloc->merged_symbol;
	    if(merged_symbol != NULL)
		return((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF)
			!= N_ARM_THUMB_DEF);
	}
	return(FALSE);
}

/*
 * fine_reloc_thumb() returns TRUE if fine relocation entry for the input_offset
 * in the section specified is for a symbol stub for a defined external symbol 
 * that a thumb symbol and stub will not be used.  This information is needed
 * when relocating an arm branch instruction that is targetted to a symbol stub
 * that ends up going to target the address of a thumb symbol. Then in this case
 * the branch instruction needs to be changed to a branch and exchange
 * instuction.
 */
__private_extern__
enum bool
fine_reloc_thumb(
struct section_map *map,
unsigned long input_offset)
{
    struct fine_reloc *fine_reloc;
    struct merged_symbol *merged_symbol;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
	    fine_reloc->indirect_defined == TRUE &&
	    (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
	    merged_symbol = fine_reloc->merged_symbol;
	    if(merged_symbol != NULL)
		return((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF)
			== N_ARM_THUMB_DEF);
	}
	return(FALSE);
}

/*
 * fine_reloc_local() returns TRUE if fine relocation entry for the input_offset
 * in the section specified is for a symbol stub for a defined local symbol.
 */
__private_extern__
enum bool
fine_reloc_local(
struct section_map *map,
unsigned long input_offset)
{
    struct fine_reloc *fine_reloc;
    struct merged_symbol *merged_symbol;

	fine_reloc = fine_reloc_for_input_offset(map, input_offset);
	if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
	    fine_reloc->indirect_defined == TRUE &&
	    (filetype != MH_DYLIB || multi_module_dylib == FALSE)){
	    merged_symbol = fine_reloc->merged_symbol;
	    if(merged_symbol == NULL)
		return(TRUE);
	}
	return(FALSE);
}

/*
 * fine_reloc_for_input_offset() returns the fine relocation entry for the
 * specified input offset and the section map.
 */
__private_extern__
struct fine_reloc *
fine_reloc_for_input_offset(
struct section_map *map,
unsigned long input_offset)
{
    int l = 0;
    int u = map->nfine_relocs - 1;
    int m;
    int r;

	if(map->nfine_relocs == 0)
	    fatal("internal error, fine_reloc_for_input_offset() called with a "
		  "section_map->nfine_relocs == 0");
	l = 0;
	m = 0;
	u = map->nfine_relocs - 1;
	while(l <= u){
	    m = (l + u) / 2;
	    if((r = (input_offset - map->fine_relocs[m].input_offset)) == 0)
		return(map->fine_relocs + m);
	    else if (r < 0)
		u = m - 1;
	    else
		l = m + 1;
	}
	if(m == 0 || input_offset > map->fine_relocs[m].input_offset)
	    return(map->fine_relocs + m);
	else
	    return(map->fine_relocs + (m - 1));
}

#ifdef RLD
/*
 * clean_objects() does two things.  For each object file in the current set
 * it first it deallocates the memory used for the object file.  Then it sets
 * the pointer to the section in each section map to point at the merged section
 * so it still can be used by trace_symbol() on future rld_load()'s (again only
 * for object files in the current set).
 */
__private_extern__
void
clean_objects(void)
{
    unsigned long i, j;
    struct object_list *object_list, **p;
    struct object_file *object_file;
#ifndef SA_RLD
    kern_return_t r;
#endif /* !defined(SA_RLD) */

	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		object_file = &(object_list->object_files[i]);
		if(object_file->set_num != cur_set)
		    continue;
		if(object_file->ar_hdr == NULL &&
		   object_file->from_fat_file == FALSE &&
		   object_file->obj_size != 0 &&
		   object_file->user_obj_addr == FALSE){
#ifndef SA_RLD
		    if((r = vm_deallocate(mach_task_self(),
				  (vm_address_t)object_file->obj_addr,
				  object_file->obj_size)) != KERN_SUCCESS)
			mach_fatal(r, "can't vm_deallocate() memory for "
				   "mapped file %s",object_file->file_name);
#ifdef RLD_VM_ALLOC_DEBUG
		    print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
			  (unsigned int)object_file->obj_addr,
			  (unsigned int)object_file->obj_size);
#endif /* RLD_VM_ALLOC_DEBUG */
#endif /* !defined(SA_RLD) */
		}
		object_file->obj_addr = NULL;
		object_file->obj_size = 0;
	        object_file->user_obj_addr = FALSE;

		/*
		 * Since the tracing of symbols and the creation of the common
		 * section both use the section's segname and sectname feilds
		 * these need to still be valid after the memory for the file
		 * has been deallocated.  So just set the pointer to point at
		 * the merged section.
		 */
		if(object_file->section_maps != NULL){
		    for(j = 0; j < object_file->nsection_maps; j++){
			object_file->section_maps[j].s = 
			    &(object_file->section_maps[j].output_section->s);
		    }
		}
	    }
	}
}

/*
 * remove_objects() removes the object structures that are from the
 * current object file set.  This takes advantage of the fact
 * that objects from the current set come after the previous set.
 */
__private_extern__
void
remove_objects(void)
{
    unsigned long i, removed;
    /* The compiler "warning: `prev_object_list' may be used uninitialized in */
    /* this function" can safely be ignored */
    struct object_list *object_list, *prev_object_list, *next_object_list;
    struct object_file *object_file;

	/* The compiler "warning: `prev_object_list' may be used */
	/* uninitialized in this function" can safely be ignored */
	prev_object_list = NULL;

	for(object_list = objects;
	    object_list != NULL;
	    object_list = object_list->next){
	    removed = 0;
	    for(i = 0; i < object_list->used; i++){
		object_file = &(object_list->object_files[i]);
		if(object_file->set_num == cur_set){
		    if(cur_set != -1)
			free(object_file->file_name);
		    if(object_file->section_maps != NULL)
			free(object_file->section_maps);
		    if(object_file->undefined_maps != NULL)
			free(object_file->undefined_maps);
		    memset(object_file, '\0', sizeof(struct object_file));
		    removed++;
		}
	    }
	    object_list->used -= removed;
	    nobjects -= removed;
	}
	/*
	 * Find the first object list that now has 0 entries used.
	 */
	for(object_list = objects;
	    object_list != NULL;
	    object_list = object_list->next){
	    if(object_list->used == 0)
		break;
	    prev_object_list = object_list;
	}
	/*
	 * If there are any object lists with 0 entries used free them.
	 */
	if(object_list != NULL && object_list->used == 0){
	    /*
	     * First set the pointer to this list in the previous list to
	     * NULL.
	     */
	    if(object_list == objects)
		objects = NULL;
	    else
		prev_object_list->next = NULL;
	    /*
	     * Now free this list and do the same for all remaining lists.
	     */
	    do {
		next_object_list = object_list->next;
		free(object_list);
		object_list = next_object_list;
	    }while(object_list != NULL);
	}
}
#endif /* RLD */

#ifdef DEBUG
/*
 * print_object_list() prints the object table.  Used for debugging.
 */
__private_extern__
void
print_object_list(void)
{
    unsigned long i, j, k;
    struct object_list *object_list, **p;
    struct object_file *object_file;
    struct fine_reloc *fine_relocs;

	print("Object file list\n");
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    print("    object_list 0x%x\n", (unsigned int)object_list);
	    print("    used %lu\n", object_list->used);
	    print("    next 0x%x\n", (unsigned int)object_list->next);
	    for(i = 0; i < object_list->used; i++){
		object_file = &(object_list->object_files[i]);
		print("\tfile_name %s\n", object_file->file_name);
		print("\tobj_addr 0x%x\n", (unsigned int)object_file->obj_addr);
		print("\tobj_size %lu\n", object_file->obj_size);
    		print("\tar_hdr 0x%x", (unsigned int)object_file->ar_hdr);
    		if(object_file->ar_hdr != NULL)
		    print(" (%.12s)\n", (char *)object_file->ar_hdr);
		else
		    print("\n");
    		print("\tnsection_maps %lu\n", object_file->nsection_maps);
		for(j = 0; j < object_file->nsection_maps; j++){
		    print("\t    (%s,%s)\n",
			   object_file->section_maps[j].s->segname,
			   object_file->section_maps[j].s->sectname);
		    print("\t    offset 0x%x\n",
			   (unsigned int)object_file->section_maps[j].offset);
		    print("\t    fine_relocs 0x%x\n",
		       (unsigned int)object_file->section_maps[j].fine_relocs);
		    print("\t    nfine_relocs %lu\n",
			   object_file->section_maps[j].nfine_relocs);
		    fine_relocs = object_file->section_maps[j].fine_relocs;
		    for(k = 0;
			k < object_file->section_maps[j].nfine_relocs;
			k++){
			print("\t\t%-6lu %-6lu\n",
			       fine_relocs[k].input_offset,
			       fine_relocs[k].output_offset);
		    }
		}
    		print("\tnundefineds %lu\n", object_file->nundefineds);
		for(j = 0; j < object_file->nundefineds; j++){
		    print("\t    (%lu,%s)\n",
			   object_file->undefined_maps[j].index,
			   object_file->undefined_maps[j].merged_symbol->nlist.
								n_un.n_name);
		}
#ifdef RLD
		print("\tset_num = %d\n", object_file->set_num);
#endif /* RLD */
	    }
	}
}

/*
 * print_fine_relocs() prints fine_relocs.  Used for debugging.
 */
__private_extern__
void
print_fine_relocs(
struct fine_reloc *fine_relocs,
unsigned long nfine_relocs,
char *string)
{
    unsigned long i;

	print("%s\n", string);
	for(i = 0; i < nfine_relocs; i++){
	    print("fine_reloc[%lu]\n", i);
	    print("\t         input_offset  0x%x\n",
		  (unsigned int)(fine_relocs[i].input_offset));
	    print("\t         output_offset 0x%x\n",
		  (unsigned int)(fine_relocs[i].output_offset));
	    print("\t      indirect_defined %s\n",
		  fine_relocs[i].indirect_defined == 1 ? "TRUE" : "FALSE");
	    print("\t          use_contents %s\n",
		  fine_relocs[i].use_contents == 1 ? "TRUE" : "FALSE");
	    print("\t          local_symbol %s\n",
		  fine_relocs[i].local_symbol == 1 ? "TRUE" : "FALSE");
	    print("\t                  live %s\n",
		  fine_relocs[i].live == 1 ? "TRUE" : "FALSE");
	    print("\t      refs_marked_live %s\n",
		  fine_relocs[i].refs_marked_live == 1 ? "TRUE" : "FALSE");
	    print("\tsearched_for_live_refs %s\n",
		  fine_relocs[i].searched_for_live_refs == 1 ? "TRUE" :"FALSE");
	    print("\t         merged_symbol 0x08%x %s\n",
		  (unsigned int)(fine_relocs[i].merged_symbol),
		  fine_relocs[i].merged_symbol == NULL ? "" :
		      fine_relocs[i].merged_symbol->nlist.n_un.n_name);
	}
}
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/objects.h                                0100644 0001750 0001750 00000040004 12612724205 022636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file objects.c.
 *
 * The following include file need to be included before this file:
 * #include "ld.h"
 * #include "sections.h"
 */

/*
 * The structure to hold the information for the object files actually loaded.
 */
struct object_file {
    char *file_name;		/* Name of the file the object is in. */
    char *obj_addr;		/* Address of the object file in memory. */
    unsigned long obj_size;	/* Size of the object file. */
    enum bool swapped;		/* TRUE if the bytesex of the object does not */
				/*  match the host bytesex. */
    enum bool fvmlib_stuff;	/* TRUE if any SG_FVMLIB segments or any */
				/*  LC_LOADFVMLIB or LC_IDFVMLIB load */
				/*  commands in the file. */
    enum bool dylib;		/* TRUE if mh->filetype == MH_DYLIB */
    enum bool dylib_stuff;	/* TRUE if any LC_LOAD_DYLIB or LC_ID_DYLIB */
				/*  load commands in the file. */
    enum bool bundle_loader;	/* TRUE this the -bundle_loader object */
    unsigned long		/* when -twolevel_name space is in effect */
	library_ordinal;	/*  this the library_ordinal for recording */
    unsigned long isub_image;   /* when -twolevel_name space is in effect */
				/*  this the sub_image index for recording */
    unsigned long nload_dylibs; /* Number of LC_LOAD_DYLIB commands */
    enum bool dylinker;		/* TRUE if mh->filetype == MH_DYLINKER */
    enum bool command_line;	/* TRUE if object is created for a symbol */
				/*  created on the command line. */
    struct ar_hdr *ar_hdr;	/* Archive header (NULL in not in archive). */
    char *ar_name;		/* Archive member name */
    unsigned long ar_name_size; /* Size of archive member name */
    struct dylib_module		/* Dynamic shared library module this object */
		*dylib_module;	/*  file struct refers to or NULL. */
    unsigned long nsection_maps;/* Total number of sections in this object. */
    struct section_map		/* A section map for each section in this. */
	*section_maps;		/*  object file. */
    struct symtab_command	/* The LC_SYMTAB load command which has */
	*symtab;		/*  offsets to the symbol and string tables. */
    struct dysymtab_command	/* The LC_DYSYMTAB load command which has */
	*dysymtab;		/*  offsets to the tables for dynamic linking.*/
    struct routines_command *rc;/* The LC_ROUTINES load command */
    unsigned long nundefineds;	/* Number of undefined symbols in the object */
    struct undefined_map	/* Map of undefined symbol indexes and */
	*undefined_maps;	/*  pointers to merged symbols (for external */
				/*  relocation) */
    unsigned long nextdefsym;	/* number of externally defined symbols */
    unsigned long iextdefsym;	/* output index to above symbols for MH_DYLIB */
    unsigned long nprivatesym;	/* number of private external symbols */
    unsigned long iprivatesym;	/* output index to above symbols */
    unsigned long cprivatesym;	/* current output index being assigned to */
				/*  private external symbols */
    unsigned long nlocalsym;	/* number of local symbols in output */
    unsigned long ilocalsym;	/* output index to above symbols */
    struct localsym_block	/* the list of blocks of local symbols that */
	*localsym_blocks;	/*  that are to be excluded from the output */
    struct section_map		/* Current map of symbols used for -sectorder */
	*cur_section_map;	/*  that is being processed from this object */
    char *resolved_path;	/* The full path name and length of the name */
    unsigned long		/*  for N_OSO stabs added with the -Sp option */
	resolved_path_len;
    const char * dwarf_name;	/* The name of the main source file, */
    const char * dwarf_comp_dir; /* and the current directory, */
				/*  from the DWARF information; NULL if none */
    size_t * dwarf_source_data; /* See read_dwarf_info in pass1.c for */
				/*  an explanation.  */
    const char * * dwarf_paths; /* Array of DWARF source file pathnames.  */
    size_t dwarf_num_paths;	/* Length of dwarf_paths.  */
  
#ifdef RLD
    long set_num;		/* The set number this object belongs to. */
    enum bool user_obj_addr;	/* TRUE if the user allocated the object */
				/*  file's memory (then rld doesn't */
				/*  deallocate it) */
    enum bool from_fat_file;	/* TRUE if the object is in a fat file (then */
				/*  the file's memory is deallocate by */
				/*  clean_archives_and_fats(). */
#endif
#ifndef RLD
    /* These are for MH_DYLIB files only */
    char *module_name;		/* module name */
    unsigned long nrefsym;	/* number of reference symbol table entries */
    unsigned long irefsym;	/* output index to reference symbol table */
    struct reference_map	/* Map of external symbols (pointers to merged*/
	*reference_maps;	/*  merged symbols and flag for reference type*/
    unsigned long iinit;	/* index into mod init section */
    unsigned long ninit;	/* number of mod init entries */
    unsigned long iterm;	/* index into mod term section */
    unsigned long nterm;	/* number of mod term entries */
    struct section_map		/* the section map for the (__OBJC, */
	*objc_module_info;	/*  __module_info) section if any. */
    enum bool init_module_loaded; /* has the module with the library */
				  /*  initialization routine been loaded */
#endif
    unsigned long imodtab;	/* output index to the module table */
    unsigned long iextrel;	/* index into output external reloc entries */
    unsigned long nextrel;	/* number of output external reloc entries */
    unsigned long ilocrel;	/* index into output local reloc entries */
    unsigned long nlocrel;	/* number of output local reloc entries */
};

/* The number of object_file structrures in object_list */
#ifndef RLD
#define NOBJECTS 120
#else
#define NOBJECTS 10
#endif

/*
 * The structure to hold a chunk the list of object files actually loaded.
 */
struct object_list {
    struct object_file
	object_files[NOBJECTS]; /* the object_file structures in this chunk */
    unsigned long used;		/* the number used in this chunk */
    struct object_list *next;	/* the next chunk (NULL in no more chunks) */
};

/*
 * The structure for information about each section of an object module.  This
 * gets allocated as an array and the sections in it are in the order that
 * they appear in the header so that section numbers (minus one) can be used as
 * indexes into this array.
 */
struct section_map {
    struct section *s;		/* Pointer to the section structure in the    */
				/*  object file. */
    struct merged_section	/* Pointer the output section to get the      */
	*output_section;	/*  section number this will be in the output */
				/*  file used in pass2 to rewrite relocation  */
				/*  entries. */
    unsigned long offset;	/* The offset from the start of the section   */
			        /* that this object file's section will start */
				/* at in the output file. */
				/*  the address the section will be at and is */
				/*  used in pass2 to do the relocation.	      */
    unsigned long flush_offset;	/* The offset from the start of the section   */
				/*  that is to be used by output_flush() that */
				/*  includes the area before the above offset */
				/*  for alignment. */
    struct fine_reloc		/* Map for relocation of literals or other    */
	*fine_relocs;		/*  items which are smaller than the section. */
    unsigned long nfine_relocs;	/* Number of structures in the map */
    enum bool no_load_order;	/* Not to be scattered, loaded normalily */
    unsigned long order;	/* order when no_load_order == TRUE */
    struct load_order		/* Map of symbols used for -sectorder */
	*load_orders;
    unsigned long nload_orders;	/* Number of structures in the map */
    enum bool start_section;	/* There is a symbol at the start of the */
				/*  section. */
    enum bool			/* For symbol stub sections if any indirect */
	absolute_indirect_defineds; /* symbol is defined as an absolute */
    enum bool			/* TRUE when the input relocation entries */
	input_relocs_already_swapped; /* have been already swapped */
    /*
     * These are set in count_reloc() and tested in output_section() for
     * internal error checking.
     */
    unsigned long nlocrel;	/* number of local reloc entries */
    unsigned long nextrel;	/* number of external reloc entries */
    /*
     * These next two fields along with the above two fields are used for
     * output_for_dyld only if this is a non-regular section that will have
     * external relocation entries (currently only coaleseced sections)
     */
    unsigned long iextrel;	/* index into output external reloc entries */
    unsigned long ilocrel;	/* index into output local reloc entries */
};

/*
 * This structure is used for relocating items in a section from an input file
 * when they are scatered in the output file (normally the section is copied 
 * as a whole).  The address in the input file and the resulting address of
 * the section in the output file are also needed to do the relocation.
 * The two fields indirect_defined and use_contents are used for indirect
 * sections to indicate if the indirect symbol for the item is defined and if
 * the item from the object file will be used in the output file.
 */
struct fine_reloc {
    unsigned long
	indirect_defined:1,	     /* TRUE if the indirect sym is defined */
	use_contents:1,		     /* TRUE if this item is used */
	local_symbol:1,		     /* TRUE if the indirect sym is local */
	live:1,			     /* TRUE if referenced (for -dead_strip) */
	refs_marked_live:1,	     /* TRUE when references marked live */
	searched_for_live_refs:1,    /* TRUE if searched for live refs */
	indirect_symbol_local:1,     /* TRUE if this is for an indirect */
				     /*  section with INDIRECT_SYMBOL_LOCAL */
	unused_bits:25;
    unsigned long input_offset;      /* offset in the input file for the item */
    unsigned long output_offset;     /* offset in the output file for the item*/
    struct merged_symbol	     /* the global merged_symbol for the item */
		  *merged_symbol;    /*  if any (else NULL) */
    struct ref *refs;		     /* if dead code stripping list of refs */
};

/*
 * When dead code stripping a linked list of these ref structures are created
 * from the relocation entries for each fine_reloc.  There are fields if this
 * is for an external reference and fields for a local references.  One set of
 * fields are set and the other are set to NULL.
 */
struct ref {
    /* if this reference came from an external symbol this is set */
    struct merged_symbol *merged_symbol;

    /* if this reference is to a local block these are set */
    struct fine_reloc *fine_reloc;
    struct section_map *map;
    struct object_file *obj;

    /* next reference in the list if any, else NULL */
    struct ref *next;
};

/*
 * This structure is used when a section has a -sectorder order file and is used
 * to set the orders and then build fine_reloc structures for it so it can be
 * scatter loaded.
 */
struct load_order {
    char *name;			/* symbol's name */
    unsigned long value;	/* symbol's value */
    unsigned long index;	/* symbol's index in symbol table */
    unsigned long order;	/* order in output, 0 if not assigned yet */
    unsigned long line_number;  /* line number if specified or zero */
    unsigned long input_offset;	/* offset in the input file for the item */
    unsigned long input_size;	/* size of symbol in the input file */
    unsigned long output_offset;/* offset in the output file for the item */
    struct fine_reloc *fine_reloc; /* the fine_reloc for this load_order */
    /* the following is only used in coalesced_section_merge() to know if this
       load_order struct is for global coalesced symbol */
    enum bool global_coalesced_symbol;
};

/*
 * This structure holds pairs of indexes into an object files symbol table and
 * pointers to merged symbol table structures for each symbol that is an
 * undefined symbol in an object file.
 */
struct undefined_map {
    unsigned long index; /* index of symbol in the object file's symbol table */
    struct merged_symbol /* pointer to the merged symbol */
	*merged_symbol;
};

/*
 * This structure holds reference type flags and pointers to merged symbol table
 * structures for each exteranl symbol that is referenced in an object file that
 * will be part of a MH_DYLIB file.  These structures are used to create the
 * reference table for a MH_DYLIB file.
 */
struct reference_map {
    unsigned long flags; /* type of reference made to this symbol */
    struct merged_symbol /* pointer to the merged symbol being referenced */
	*merged_symbol;
};

/*
 * The head of the object file list and the total count of all object files
 * in the list.
 */
__private_extern__ struct object_list *objects;
__private_extern__ unsigned long nobjects;

/*
 * A pointer to the current object being processed in pass1 or pass2.
 */
__private_extern__ struct object_file *cur_obj;

/*
 * A pointer to the base object for an incremental link if not NULL.
 */
__private_extern__ struct object_file *base_obj;

__private_extern__ struct object_file *new_object_file(
    void);
#ifndef RLD
__private_extern__ unsigned long object_index(
    struct object_file *obj);
#endif
__private_extern__ struct object_file *add_last_object_file(
    struct object_file *new_object);
__private_extern__ void remove_last_object_file(
    struct object_file *last_object);
__private_extern__ void print_obj_name(
    struct object_file *obj);
__private_extern__ unsigned long size_ar_name(
    struct ar_hdr *ar_hdr);
__private_extern__ void set_obj_resolved_path(
    struct object_file *obj);
__private_extern__ void print_whatsloaded(
    void);
__private_extern__ enum bool is_dylib_module_loaded(
    struct dylib_module *dylib_module);
__private_extern__ unsigned long fine_reloc_output_offset(
    struct section_map *map,
    unsigned long input_offset);
__private_extern__ unsigned long fine_reloc_output_address(
    struct section_map *map,
    unsigned long input_offset,
    unsigned long output_base_address);
__private_extern__ void fine_reloc_output_ref(
    struct section_map *map,
    unsigned long input_offset,
    struct live_ref *ref);
__private_extern__ enum bool fine_reloc_offset_in_output(
    struct section_map *map,
    unsigned long input_offset);
__private_extern__ enum bool fine_reloc_offset_in_output_for_output_offset(
    struct section_map *map,
    unsigned long output_offset);
__private_extern__ unsigned long fine_reloc_output_sectnum(
    struct section_map *map,
    unsigned long input_offset);
__private_extern__ enum bool fine_reloc_arm(
    struct section_map *map,
    unsigned long input_offset);
__private_extern__ enum bool fine_reloc_thumb(
    struct section_map *map,
    unsigned long input_offset);
__private_extern__ enum bool fine_reloc_local(
    struct section_map *map,
    unsigned long input_offset);
__private_extern__ struct fine_reloc *fine_reloc_for_input_offset(
    struct section_map *map,
    unsigned long input_offset);
#ifdef RLD
__private_extern__ void clean_objects(
    void);
__private_extern__ void remove_objects(
    void);
#endif /* RLD */

#ifdef DEBUG
__private_extern__ void print_object_list(
    void);
__private_extern__ void print_fine_relocs(
    struct fine_reloc *fine_relocs,
    unsigned long nfine_relocs,
    char *string);
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/pass1.c                                  0100644 0001750 0001750 00000622044 12612724205 022241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that drives pass1 of the link-editor.  In
 * pass1 the objects needed from archives are selected for loading and all of
 * the things that need to be merged from the input objects are merged into
 * tables (for output and relocation on the second pass).
 */
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "stuff/openstep_mach.h"
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/ldsyms.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <libc.h>
#include <stdio.h>
#include <mach/mach.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <ar.h>
#ifndef AR_EFMT1
#define	AR_EFMT1	"#1/"		/* extended format #1 */
#endif
#include <mach-o/ranlib.h>
#include "stuff/arch.h"
#include "stuff/best_arch.h"
#include "stuff/guess_short_name.h"
#include "stuff/macosx_deployment_target.h"

#include "ld.h"
#include "pass1.h"
#include "live_refs.h"
#include "objects.h"
#include "fvmlibs.h"
#include "dylibs.h"
#include "sections.h"
#include "symbols.h"
#include "sets.h"
#include "layout.h"
#ifndef KLD
#include "debugcompunit.h"
#include "debugline.h"
#endif /* ! KLD */

#ifndef RLD
/* TRUE if -search_paths_first was specified */
__private_extern__ enum bool search_paths_first = FALSE;

/* the user specified directories to search for -lx names, and the number
   of them */
__private_extern__ char **search_dirs = NULL;
__private_extern__ unsigned long nsearch_dirs = 0;

/*
 * The user specified directories to search via the environment variable
 * LD_LIBRARY_PATH.
 */
__private_extern__ char **ld_library_paths = NULL;
__private_extern__ unsigned long nld_library_paths = 0;

/* the standard directories to search for -lx names */
__private_extern__ char *standard_dirs[] = {
    "/lib/",
    "/usr/lib/",
    "/usr/local/lib/",
    NULL
};

/*
 * The user specified directories to search for "-framework Foo" names, and the
 * number of them.  These are specified with -F options.
 */
__private_extern__ char **framework_dirs = NULL;
__private_extern__ unsigned long nframework_dirs = 0;

/* the standard framework directories to search for "-framework Foo" names */
__private_extern__ char *standard_framework_dirs[] = {
#ifdef __OPENSTEP__
    "/LocalLibrary/Frameworks/",
    "/NextLibrary/Frameworks/",
#else /* !defined(__OPENSTEP__) */

#ifdef __GONZO_BUNSEN_BEAKER__
    "/Local/Library/Frameworks/",
#else /* !defined(__BUNSEN_BEAKER__) */
    "/Library/Frameworks/",
#endif /* __BUNSEN_BEAKER__ */

    "/Network/Library/Frameworks/",
    "/System/Library/Frameworks/",
#endif /* __OPENSTEP__ */
    NULL
};

/* The pointer to the head of the base object file's segments */
__private_extern__ struct merged_segment *base_obj_segments = NULL;
#endif /* !defined(RLD) */

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
/*
 * The stat buffer for input files.  This is needed both by pass1() and
 * pass1_archive() to check the times.
 */
static struct stat stat_buf = { 0 };

/*
 * These are pointers to strings and symbols used to search of the table of
 * contents of a library.  These have to be can not be local so that
 * pass1_archive() and search_dylibs() can set them and that ranlib_bsearch()
 * and dylib_bsearch() can use them.  This is done instead of assigning to
 * ran_name so that the library can be mapped read only and thus not get dirty
 * and maybe written to the swap area by the kernel.
 */
__private_extern__ char *bsearch_strings = NULL;
#ifndef RLD
__private_extern__ struct nlist *bsearch_symbols = NULL;

/*
 * The list of dynamic libraries to search.  The list of specified libraries
 * can contain archive libraries when archive libraries appear after dynamic
 * libraries on the link line.
 */
__private_extern__ struct dynamic_library *dynamic_libs = NULL;

/*
 * When building two-level-namespace, indirect libraries are not kept
 * in the dynamic_libs list.  The pre-10.4 prebinding may need to grow
 * the load commands in an executable proportional to the number of
 * direct and indirect libraries.  The variable indirect_library_ratio
 * gives us a scaling factor to multiple by the number of libraries
 * in dynamic_libs as an estimate of the total number of libraries.
 */
__private_extern__ unsigned int indirect_library_ratio = 1;

/*
 * The variable indirect_dylib is used for search_dynamic_libs() to communicate
 * with check_cur_obj() to prevent the error message that is generated when
 * a subframework is directly linked against.  When an umbrella framework is
 * linked against it subframeworks are indirectly used which are not an error.
 */
static enum bool indirect_dylib = FALSE;

static void search_for_file(
    char *base_name,
    char **file_name,
    int *fd);
static void search_for_framework(
    char *name,
    char **file_name,
    int *fd);
static void search_paths_for_lname(
    const char *lname_argument,
    char **file_name,
    int *fd);
static void search_path_for_lname(
    const char *dir,
    const char *lname_argument,
    char **file_name,
    int *fd);
#endif /* !defined(RLD) */

static void pass1_fat(
    char *file_name,
    char *file_addr,
    unsigned long file_size,
    enum bool base_name,
    enum bool dylib_only,
    enum bool bundle_loader,
    enum bool force_weak);

static void pass1_archive(
    char *file_name,
    char *file_addr,
    unsigned long file_size,
    enum bool base_name,
    enum bool from_fat_file,
    enum bool bundle_loader,
    enum bool force_weak);

static enum bool check_archive_arch(
    char *file_name,
    char *file_addr,
    unsigned long file_size);

static enum bool check_extend_format_1(
    char *name,
    struct ar_hdr *ar_hdr,
    unsigned long size_left,
    unsigned long *member_name_size);

static void pass1_object(
    char *file_name,
    char *file_addr,
    unsigned long file_size,
    enum bool base_name,
    enum bool from_fat_file,
    enum bool dylib_only,
    enum bool bundle_loader,
    enum bool force_weak);

#ifndef RLD
static void load_init_dylib_module(
    struct dynamic_library *q);
static enum bool setup_sub_images(
    struct dynamic_library *p);
static void check_dylibs_for_definition(
    struct merged_symbol *merged_symbol,
    enum bool prebind_check,
    enum bool twolevel_namespace_check);
static enum bool check_dylibs_for_reference(
    struct merged_symbol *merged_symbol);

static enum bool open_dylib(
    struct dynamic_library *p);

static enum bool set_sub_frameworks_ordinals(
    struct dynamic_library *umbrella);

static enum bool set_sub_umbrella_sub_library_ordinal(
    struct dynamic_library *sub);

static void set_isub_image(
    struct dynamic_library *p,
    struct dynamic_library *sub);

static int nlist_bsearch(
    const char *symbol_name,
    const struct nlist *symbol);
#endif /* !defined(RLD) */

static int ranlib_bsearch(
    const char *symbol_name,
    const struct ranlib *ran);

#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

static void check_cur_obj(
    enum bool dylib_only,
    enum bool bundle_loader);

#ifndef KLD
static void read_dwarf_info(void);
#endif

static void check_size_offset(
    unsigned long size,
    unsigned long offset,
    unsigned long align,
    char *size_str,
    char *offset_str,
    unsigned long cmd);

static void check_size_offset_sect(
    unsigned long size,
    unsigned long offset,
    unsigned long align,
    char *size_str,
    char *offset_str,
    unsigned long cmd,
    unsigned long sect,
    char *segname,
    char *sectname);

#ifndef RLD
static void collect_base_obj_segments(
	void);

static void add_base_obj_segment(
	struct segment_command *sg,
	char *filename);

static char *mkstr(
	const char *args,
	...);
#endif /* !defined(RLD) */

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
/*
 * pass1() is called from main() and is passed the name of a file and a flag
 * indicating if it is a path searched abbrevated file name (a -lx argument).
 *
 * If the name is a path searched abbrevated file name (of the form "-lx")
 * then it is searched for in the search_dirs list (created from the -Ldir
 * arguments) and then in the list of standard_dirs.  The string "x" of the
 * "-lx" argument will be converted to "libx.a" if the string does not end in
 * ".o", in which case it is left alone.
 *
 * If the file is the object file for a the base of an incremental load then
 * base_name is TRUE and the pointer to the object_file structure for it,
 * base_obj, is set when it is allocated.
 *
 * If the file turns out to be just a plain object then merge() is called to
 * merge its symbolic information and it will be unconditionally loaded.
 *
 * Object files in archives are loaded only if they resolve currently undefined
 * references or the -ObjC flag is set and their are symbols with the ".objc"
 * prefix defined.
 */
__private_extern__
void
pass1(
char *name,
enum bool lname,
enum bool base_name,
enum bool framework_name,
enum bool bundle_loader,
enum bool force_weak)
{
    int fd;
    char *file_name;
#ifndef RLD
    char *p, *type;
#endif /* !defined(RLD) */
    kern_return_t r;
    unsigned long file_size;
    char *file_addr;
    struct fat_header *fat_header;
#ifdef __MWERKS__
    enum bool dummy;
        dummy = lname;
        dummy = base_name;
        dummy = framework_name;
#endif

#ifdef DEBUG
	/* The compiler "warning: `file_name' may be used uninitialized in */
	/* this function" can safely be ignored */
	file_name = NULL;
#endif /* DEBUG */

	fd = -1;
#ifndef RLD
	if(lname){
	    if(name[0] != '-' || name[1] != 'l')
		fatal("Internal error: pass1() called with name of: %s and "
		      "lname == TRUE", name);
	    p = &name[2];
	    p = strrchr(p, '.');
	    if(p != NULL && strcmp(p, ".o") == 0){
		p = &name[2];
		search_for_file(p, &file_name, &fd);
		if(fd == -1)
		    fatal("can't locate file for: %s", name);
	    }
	    else{
		p = NULL;
		if(dynamic == TRUE){
		    if(search_paths_first == TRUE){
			search_paths_for_lname(&name[2], &file_name, &fd);
		    }
		    else{
			p = mkstr("lib", &name[2], ".dylib", NULL);
			search_for_file(p, &file_name, &fd);
			if(fd == -1){
			    p = mkstr("lib", &name[2], ".a", NULL);
			    search_for_file(p, &file_name, &fd);
			}
		    }
		}
		else{
		    p = mkstr("lib", &name[2], ".a", NULL);
		    search_for_file(p, &file_name, &fd);
		}
		if(fd == -1)
		    fatal("can't locate file for: %s", name);
		if(p != NULL)
		    free(p);
	    }
	}
	else if(framework_name){
	    type = strrchr(name, ',');
	    if(type != NULL && type[1] != '\0'){
		*type = '\0';
		type++;
		p = mkstr(name, ".framework/", name, type, NULL);
		search_for_framework(p, &file_name, &fd);
		if(fd == -1)
		    warning("can't locate framework for: -framework %s,%s "
			    "using suffix %s", name, type, type);
	    }
	    else
		type = NULL;
	    if(fd == -1){
		p = mkstr(name, ".framework/", name, NULL);
		search_for_framework(p, &file_name, &fd);
	    }
	    if(fd == -1){
		if(type != NULL)
		    fatal("can't locate framework for: -framework %s,%s",
			  name, type);
		else
		    fatal("can't locate framework for: -framework %s", name);
	    }
	}
	else
#endif /* !defined(RLD) */
	{
	    if((fd = open(name, O_RDONLY, 0)) == -1){
		system_error("can't open: %s", name);
		return;
	    }
	    file_name = name;
	}

	/*
	 * Now that the file_name has been determined and opened get it into
	 * memory by mapping it.
	 */
	if(fstat(fd, &stat_buf) == -1){
	    system_fatal("can't stat file: %s", file_name);
	    close(fd);
	    return;
	}
	file_size = stat_buf.st_size;
	/*
	 * For some reason mapping files with zero size fails so it has to
	 * be handled specially.
	 */
	if(file_size == 0){
	    error("file: %s is empty (not an object or archive)", file_name);
	    close(fd);
	    return;
	}
	if((r = map_fd((int)fd, (vm_offset_t)0, (vm_offset_t *)&file_addr,
	    (boolean_t)TRUE, (vm_size_t)file_size)) != KERN_SUCCESS){
	    close(fd);
	    mach_fatal(r, "can't map file: %s", file_name);
	}
#ifdef RLD_VM_ALLOC_DEBUG
	print("rld() map_fd: addr = 0x%0x size = 0x%x\n",
	      (unsigned int)file_addr, (unsigned int)file_size);
#endif /* RLD_VM_ALLOC_DEBUG */
	/*
	 * The mapped file can't be made read-only because even in the case of
	 * errors where a wrong bytesex file is attempted to be loaded it must
	 * be writeable to detect the error.
	 *
	 *  if((r = vm_protect(mach_task_self(), (vm_address_t)file_addr,
	 * 		file_size, FALSE, VM_PROT_READ)) != KERN_SUCCESS){
	 *      close(fd);
	 *      mach_fatal(r, "can't make memory for mapped file: %s read-only",
	 *      	   file_name);
	 *  }
	 */
	close(fd);

	/*
	 * Determine what type of file it is (fat, archive or thin object file).
	 */
	if(sizeof(struct fat_header) > file_size){
	    error("truncated or malformed file: %s (file size too small to be "
		  "any kind of object or library)", file_name);
	    return;
	}
	fat_header = (struct fat_header *)file_addr;
#ifdef __BIG_ENDIAN__
	if(fat_header->magic == FAT_MAGIC)
#endif /* __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
	if(fat_header->magic == SWAP_LONG(FAT_MAGIC))
#endif /* __LITTLE_ENDIAN__ */
	{
#ifdef RLD
	    new_archive_or_fat(file_name, file_addr, file_size);
#endif /* RLD */
	    pass1_fat(file_name, file_addr, file_size, base_name, FALSE,
		      bundle_loader, force_weak);
	}
	else if(file_size >= SARMAG && strncmp(file_addr, ARMAG, SARMAG) == 0){
	    pass1_archive(file_name, file_addr, file_size, base_name, FALSE,
			  bundle_loader, force_weak);
	}
	else{
	    pass1_object(file_name, file_addr, file_size, base_name, FALSE,
			 FALSE, bundle_loader, force_weak);
	}
#ifdef VM_SYNC_DEACTIVATE
	vm_msync(mach_task_self(), (vm_address_t)file_addr,
		 (vm_size_t)file_size, VM_SYNC_DEACTIVATE);
#endif /* VM_SYNC_DEACTIVATE */
}

#ifndef RLD
/*
 * search_for_file() takes base_name and trys to open a file with that base name
 * in the -L search directories and in the standard directories.  If it is
 * sucessful it returns a pointer to the file name indirectly through file_name
 * and the open file descriptor indirectly through fd.
 */
static
void
search_for_file(
char *base_name,
char **file_name,
int *fd)
{
    unsigned long i;

	*fd = -1;
	for(i = 0; i < nsearch_dirs ; i++){
	    *file_name = mkstr(search_dirs[i], "/", base_name, NULL);
	    if((*fd = open(*file_name, O_RDONLY, 0)) != -1)
		break;
	    free(*file_name);
	}
	if(*fd == -1){
	    for(i = 0; i < nld_library_paths ; i++){
		*file_name = mkstr(ld_library_paths[i], "/", base_name, NULL);
		if((*fd = open(*file_name, O_RDONLY, 0)) != -1)
		    break;
		free(*file_name);
	    }
	}
	if(*fd == -1){
	    for(i = 0; standard_dirs[i] != NULL ; i++){
		*file_name = mkstr(standard_dirs[i], base_name, NULL);
		if((*fd = open(*file_name, O_RDONLY, 0)) != -1)
		    break;
		free(*file_name);
	    }
	}
}

/*
 * search_for_framework() takes name and trys to open a file with that name
 * in the -F search directories and in the standard framework directories.  If
 * it is sucessful it returns a pointer to the file name indirectly through
 * file_name and the open file descriptor indirectly through fd.
 */
static
void
search_for_framework(
char *name,
char **file_name,
int *fd)
{
    unsigned long i;

	*fd = -1;
	for(i = 0; i < nframework_dirs ; i++){
	    *file_name = mkstr(framework_dirs[i], "/", name, NULL);
	    if((*fd = open(*file_name, O_RDONLY, 0)) != -1)
		break;
	    free(*file_name);
	}
	if(*fd == -1){
	    for(i = 0; standard_framework_dirs[i] != NULL ; i++){
		*file_name = mkstr(standard_framework_dirs[i], name, NULL);
		if((*fd = open(*file_name, O_RDONLY, 0)) != -1)
		    break;
		free(*file_name);
	    }
	}
}

/*
 * search_paths_for_lname() takes the argument to a -lx option and and trys to
 * open a file with the name libx.dylib or libx.a.  This routine is only used
 * when the -search_paths_first option is specified and -dynamic is in effect.
 * And looks for a file name ending in .dylib then .a in each directory before
 * looking in the next directory.  The list of the -L search directories and in
 * the standard directories are searched in that order.  If this is sucessful
 * it returns a pointer to the file name indirectly through file_name and the
 * open file descriptor indirectly through fd.
 */
static
void
search_paths_for_lname(
const char *lname_argument,
char **file_name,
int *fd)
{
    unsigned long i;

	*fd = -1;
	for(i = 0; i < nsearch_dirs ; i++){
	    search_path_for_lname(search_dirs[i], lname_argument, file_name,fd);
	    if(*fd != -1)
		return;
	}
	for(i = 0; i < nld_library_paths ; i++){
	    search_path_for_lname(ld_library_paths[i], lname_argument,
				  file_name, fd);
	    if(*fd != -1)
		return;
	}
	for(i = 0; standard_dirs[i] != NULL ; i++){
	    search_path_for_lname(standard_dirs[i],lname_argument,file_name,fd);
	    if(*fd != -1)
		return;
	}
}

/*
 * search_path_for_lname() takes the argument to a -lx option and and trys to
 * open a file with the name libx.dylib then libx.a in the specified directory
 * name.  This routine is only used when the -search_paths_first option is
 * specified and -dynamic is in effect.  If this is sucessful it returns a
 * pointer to the file name indirectly through file_name and the open file
 * descriptor indirectly through fd.
 */
static
void
search_path_for_lname(
const char *dir,
const char *lname_argument,
char **file_name,
int *fd)
{
	*file_name = mkstr(dir, "/", "lib", lname_argument, ".dylib", NULL);
	if((*fd = open(*file_name, O_RDONLY)) != -1)
	    return;
	free(*file_name);

	*file_name = mkstr(dir, "/", "lib", lname_argument, ".a", NULL);
	if((*fd = open(*file_name, O_RDONLY)) != -1)
	    return;
	free(*file_name);
}
#endif /* !defined(RLD) */

/*
 * pass1_fat() is passed a fat file to process.  The reason the swapping of
 * the fat headers is not done in place is so that when running native on a
 * little endian machine and the output is also little endian we don't want
 * cause the memory for the input files to be written just because of the
 * fat headers.
 */
static
void
pass1_fat(
char *file_name,
char *file_addr,
unsigned long file_size,
enum bool base_name,
enum bool dylib_only,
enum bool bundle_loader,
enum bool force_weak)
{
    struct fat_header *fat_header;
#ifdef __LITTLE_ENDIAN__
    struct fat_header struct_fat_header;
#endif /* __LITTLE_ENDIAN__ */
    struct fat_arch *fat_archs, *best_fat_arch;
    unsigned long previous_errors;
    char *arch_addr;
    unsigned long arch_size;
#if !(defined(KLD) && defined(__STATIC__))
    struct arch_flag host_arch_flag;
#endif /* !(defined(KLD) && defined(__STATIC__)) */
    const char *prev_arch;

	fat_header = (struct fat_header *)file_addr;
#ifdef __LITTLE_ENDIAN__
	struct_fat_header = *fat_header;
	swap_fat_header(&struct_fat_header, host_byte_sex);
	fat_header = &struct_fat_header;
#endif /* __LITTLE_ENDIAN__ */

	if(sizeof(struct fat_header) + fat_header->nfat_arch *
	   sizeof(struct fat_arch) > file_size){
	    error("fat file: %s truncated or malformed (fat_arch structs "
		  "would extend past the end of the file)", file_name);
	    return;
	}

#ifdef __BIG_ENDIAN__
	fat_archs = (struct fat_arch *)(file_addr + sizeof(struct fat_header));
#endif /* __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
	fat_archs = allocate(fat_header->nfat_arch * sizeof(struct fat_arch));
	memcpy(fat_archs, file_addr + sizeof(struct fat_header),
	       fat_header->nfat_arch * sizeof(struct fat_arch));
	swap_fat_arch(fat_archs, fat_header->nfat_arch, host_byte_sex);
#endif /* __LITTLE_ENDIAN__ */

	/*
	 * save the previous errors and only return out of here if something
	 * we do in here gets an error.
	 */
	previous_errors = errors;
	errors = 0;

	/* check the fat file */
	check_fat(file_name, file_size, fat_header, fat_archs, NULL, 0);
	if(errors)
	    goto pass1_fat_return;

	/* Now select an architecture out of the fat file to use if any */

	/*
	 * If the output file's cputype has been set then load the best fat_arch
	 * from it else it's an error.
	 */
	if(arch_flag.cputype != 0){
	    best_fat_arch = cpusubtype_findbestarch(
					arch_flag.cputype, arch_flag.cpusubtype,
					fat_archs, fat_header->nfat_arch);
	    if(best_fat_arch == NULL){
		if(no_arch_warnings == TRUE)
		    goto pass1_fat_return;
		if(arch_flag.name != NULL){
		    if(arch_errors_fatal == TRUE){
			error("fat file: %s does not contain an architecture "
			      "that matches the specified -arch flag: %s ",
			      file_name, arch_flag.name);
		    }
		    else
			warning("fat file: %s does not contain an architecture "
				"that matches the specified -arch flag: %s "
				"(file ignored)", file_name, arch_flag.name);
		}
		else{
		    prev_arch = get_arch_name_from_types(arch_flag.cputype,
						         arch_flag.cpusubtype);
		    if(arch_errors_fatal == TRUE){
			error("fat file: %s does not contain an architecture "
			    "that matches the objects files (architecture %s) "
			    "previously loaded", file_name, prev_arch);
		    }
		    else
			warning("fat file: %s does not contain an architecture "
			    "that matches the objects files (architecture %s) "
			    "previously loaded (file ignored)", file_name,
			    prev_arch);
		}
		goto pass1_fat_return;
	    }
	    arch_addr = file_addr + best_fat_arch->offset;
	    arch_size = best_fat_arch->size;
	    if(arch_size >= SARMAG &&
	       strncmp(arch_addr, ARMAG, SARMAG) == 0){
		if(dylib_only == TRUE){
		    if(arch_flag.name != NULL){
			error("fat file: %s (for architecture %s) is not a "
			      "dynamic shared library", file_name,
			      arch_flag.name);
		    }
		    else{
			prev_arch = get_arch_name_from_types(arch_flag.cputype,
							 arch_flag.cpusubtype);
			error("fat file: %s (for architecture %s) is not a "
			      "dynamic shared library", file_name, prev_arch);
		    }
		    goto pass1_fat_return;
		}
		pass1_archive(file_name, arch_addr, arch_size,
			      base_name, TRUE, bundle_loader, force_weak);
	    }
	    else{
		pass1_object(file_name, arch_addr, arch_size, base_name, TRUE,
			     dylib_only, bundle_loader, force_weak);
	    }
	    goto pass1_fat_return;
	}

#if !(defined(KLD) && defined(__STATIC__))
	/*
	 * If the output file's cputype has not been set so if this fat file
	 * has exactly one type in it then load that type.
	 */
	if(fat_header->nfat_arch == 1){
	    arch_addr = file_addr + fat_archs[0].offset;
	    arch_size = fat_archs[0].size;
	    if(arch_size >= SARMAG &&
	       strncmp(arch_addr, ARMAG, SARMAG) == 0){
		if(dylib_only == TRUE){
		    error("fat file: %s (for architecture %s) is not a dynamic "
			  "shared library", file_name, get_arch_name_from_types(
			   fat_archs[0].cputype, fat_archs[0].cpusubtype));
		    goto pass1_fat_return;
		}
		pass1_archive(file_name, arch_addr, arch_size, base_name, TRUE,
			      bundle_loader, force_weak);
	    }
	    else{
		pass1_object(file_name, arch_addr, arch_size, base_name, TRUE,
			     dylib_only, bundle_loader, force_weak);
	    }
	    goto pass1_fat_return;
	}

	/*
	 * The output file's cputype has not been set and if this fat file has
	 * a best arch for the host's specific architecture type then load that
	 * type and set the output file's cputype to that.
	 */
	if(get_arch_from_host(NULL, &host_arch_flag) == 0)
	    fatal("can't determine the host architecture (specify an "
		  "-arch flag or fix get_arch_from_host() )");
	best_fat_arch = cpusubtype_findbestarch(
			    host_arch_flag.cputype, host_arch_flag.cpusubtype,
			    fat_archs, fat_header->nfat_arch);
	if(best_fat_arch != NULL){
	    arch_addr = file_addr + best_fat_arch->offset;
	    arch_size = best_fat_arch->size;
	    if(arch_size >= SARMAG &&
	       strncmp(arch_addr, ARMAG, SARMAG) == 0){
		if(dylib_only == TRUE){
		    error("fat file: %s (for architecture %s) is not a dynamic "
			  "shared library", file_name, get_arch_name_from_types(
			   best_fat_arch->cputype, best_fat_arch->cpusubtype));
		    goto pass1_fat_return;
		}
		pass1_archive(file_name, arch_addr, arch_size,
			      base_name, TRUE, bundle_loader, force_weak);
	    }
	    else{
		pass1_object(file_name, arch_addr, arch_size, base_name, TRUE,
			     dylib_only, bundle_loader, force_weak);
	    }
	    goto pass1_fat_return;
	}

	/*
	 * The output file's cputype has not been set and this fat file does not
	 * have only one architecture or has the host's family architecture so
	 * we are stuck not knowing what to load if anything from it.
	 */
	fatal("-arch flag must be specified (fat file: %s does not contain the "
	      "host architecture or just one architecture)", file_name);
#endif /* !(defined(KLD) && defined(__STATIC__)) */

pass1_fat_return:
	errors += previous_errors;
#ifdef __LITTLE_ENDIAN__
	free(fat_archs);
#endif /* __LITTLE_ENDIAN__ */
	return;
}

__private_extern__
void
check_fat(
char *file_name,
unsigned long file_size,
struct fat_header *fat_header,
struct fat_arch *fat_archs,
char *ar_name,
unsigned long ar_name_size)
{
    unsigned long i, j;

	if(fat_header->nfat_arch == 0){
	    if(ar_name != NULL)
		error("fat file: %s(%.*s) malformed (contains zero "
		      "architecture types)", file_name, (int)ar_name_size,
		      ar_name);
	    else
		error("fat file: %s malformed (contains zero architecture "
		      "types)", file_name);
	    return;
	}
	for(i = 0; i < fat_header->nfat_arch; i++){
	    if(fat_archs[i].offset + fat_archs[i].size > file_size){
		if(ar_name != NULL)
		    error("fat file: %s(%.*s) truncated or malformed (offset "
			  "plus size of cputype (%d) cpusubtype (%d) extends "
			  "past the end of the file)", file_name,
			  (int)ar_name_size, ar_name, fat_archs[i].cputype,
			  fat_archs[i].cpusubtype);
		else
		    error("fat file: %s truncated or malformed (offset plus "
			  "size of cputype (%d) cpusubtype (%d) extends past "
			  "the end of the file)", file_name,
			  fat_archs[i].cputype, fat_archs[i].cpusubtype);
		return;
	    }
	    if(fat_archs[i].cputype == 0){
		if(ar_name != NULL)
		    error("fat file: %s(%.*s) fat_archs %lu cputype is zero (a "
			  "reserved value)", file_name, (int)ar_name_size,
			  ar_name, i);
		else
		    error("fat file: %s fat_archs %lu cputype is zero (a "
			  "reserved value)", file_name, i);
		return;
	    }
	    if(fat_archs[i].align > MAXSECTALIGN){
		if(ar_name != NULL)
		    error("fat file: %s(%.*s) align (2^%u) too large for "
			  "cputype (%d) cpusubtype (%d) (maximum 2^%d)",
			  file_name, (int)ar_name_size, ar_name,
			  fat_archs[i].align, fat_archs[i].cputype,
			  fat_archs[i].cpusubtype, MAXSECTALIGN);
		else
		    error("fat file: %s align (2^%u) too large for cputype "
			  "(%d) cpusubtype (%d) (maximum 2^%d)", file_name,
			  fat_archs[i].align, fat_archs[i].cputype,
			  fat_archs[i].cpusubtype, MAXSECTALIGN);
		return;
	    }
	    if(fat_archs[i].offset %
	       (1 << fat_archs[i].align) != 0){
		if(ar_name != NULL)
		    error("fat file: %s(%.*s) offset: %u for cputype (%d) "
			  "cpusubtype (%d)) not aligned on it's alignment "
			  "(2^%u)", file_name, (int)ar_name_size, ar_name,
			  fat_archs[i].offset, fat_archs[i].cputype,
			  fat_archs[i].cpusubtype, fat_archs[i].align);
		else
		    error("fat file: %s offset: %u for cputype (%d) "
			  "cpusubtype (%d)) not aligned on it's alignment "
			  "(2^%u)", file_name, fat_archs[i].offset,
			  fat_archs[i].cputype, fat_archs[i].cpusubtype,
			  fat_archs[i].align);
		return;
	    }
	}
	for(i = 0; i < fat_header->nfat_arch; i++){
	    for(j = i + 1; j < fat_header->nfat_arch; j++){
		if(fat_archs[i].cputype == fat_archs[j].cputype &&
		   fat_archs[i].cpusubtype == fat_archs[j].cpusubtype){
		    if(ar_name != NULL)
			error("fat file: %s(%.*s) contains two of the same "
			      "architecture (cputype (%d) cpusubtype (%d))",
			      file_name, (int)ar_name_size, ar_name,
			      fat_archs[i].cputype, fat_archs[i].cpusubtype);
		    else
			error("fat file: %s contains two of the same "
			      "architecture (cputype (%d) cpusubtype (%d))",
			      file_name, fat_archs[i].cputype,
			      fat_archs[i].cpusubtype);
		    return;
		}
	    }
	}
	return;
}

/*
 * This is an archive so conditionally load those objects that defined
 * currently undefined symbols and process archives with respect to the
 * -ObjC and -load_all flags if set.
 */
static
void
pass1_archive(
char *file_name,
char *file_addr,
unsigned long file_size,
enum bool base_name,
enum bool from_fat_file,
enum bool bundle_loader,
enum bool force_weak)
{
    unsigned long i, j, offset;
#ifndef RLD
    unsigned long *loaded_offsets, nloaded_offsets;
    enum bool loaded_offset;
    struct ar_hdr *ar_hdr;
    unsigned long length;
    struct dynamic_library *p;
#endif /* !defined(RLD) */
    struct ar_hdr *symdef_ar_hdr;
    char *symdef_ar_name, *ar_name;
    unsigned long symdef_length, nranlibs, string_size, ar_name_size;
    struct ranlib *ranlibs, *ranlib;
    struct undefined_list *undefined;
    struct merged_symbol *merged_symbol;
    enum bool member_loaded;
    enum byte_sex toc_byte_sex;
    enum bool ld_trace_archive_printed;

#ifndef RLD
    unsigned long ar_size;
    struct fat_header *fat_header;
#ifdef __LITTLE_ENDIAN__
    struct fat_header struct_fat_header;
#endif /* __LITTLE_ENDIAN__ */
    struct fat_arch *fat_archs, *best_fat_arch;
    char *arch_addr;
    unsigned long arch_size;
    struct arch_flag host_arch_flag;
    const char *prev_arch;

	arch_addr = NULL;
	arch_size = 0;
#endif /* !defined(RLD) */
#ifdef __MWERKS__
	{
	    enum bool dummy;
		dummy = base_name;
		dummy = from_fat_file;
	}
#endif

	ld_trace_archive_printed = FALSE;
	if(check_archive_arch(file_name, file_addr, file_size) == FALSE)
	    return;

	offset = SARMAG;
#ifndef RLD
	if(base_name)
	    fatal("base file of incremental link (argument of -A): %s should't "
		  "be an archive", file_name);
	if(bundle_loader)
	    fatal("-bundle_loader argument: %s should't be an archive",
		  file_name);

	/*
	 * If the flag to specifiy that all the archive members are to be
	 * loaded then load them all.
	 */
	if(archive_all == TRUE){
	    if(offset + sizeof(struct ar_hdr) > file_size){
		error("truncated or malformed archive: %s (archive header of "
		      "first member extends past the end of the file, can't "
		      "load from it)", file_name);
		return;
	    }
	    symdef_ar_hdr = (struct ar_hdr *)(file_addr + offset);
	    if(strncmp(symdef_ar_hdr->ar_name, AR_EFMT1,
		       sizeof(AR_EFMT1)-1) == 0)
		ar_name = file_addr + offset + sizeof(struct ar_hdr);
	    else
		ar_name = symdef_ar_hdr->ar_name;
	    if(strncmp(ar_name, SYMDEF, sizeof(SYMDEF)-1) == 0){
		offset += sizeof(struct ar_hdr);
		symdef_length = strtol(symdef_ar_hdr->ar_size, NULL, 10);
		if(offset + symdef_length > file_size){
		    error("truncated or malformed archive: %s (table of "
			  "contents extends past the end of the file, can't "
			  "load from it)", file_name);
		    return;
		}
		offset += rnd(symdef_length, sizeof(short));
	    }
	    if(ld_trace_archives == TRUE && ld_trace_archive_printed == FALSE){
		char resolvedname[MAXPATHLEN];
		if(realpath(file_name, resolvedname) !=
		   NULL)
		    ld_trace("[Logging for XBS] Used static "
			     "archive: %s\n", resolvedname);
		else
		    ld_trace("[Logging for XBS] Used static "
			     "archive: %s\n", file_name);
		ld_trace_archive_printed = TRUE;
	    }
	    while(offset < file_size){
		if(offset + sizeof(struct ar_hdr) > file_size){
		    error("truncated or malformed archive: %s at offset %lu "
			  "(archive header of next member extends past the end "
			  "of the file, can't load from it)", file_name,offset);
		    return;
		}
		ar_hdr = (struct ar_hdr *)(file_addr + offset);
		if(strncmp(ar_hdr->ar_name, AR_EFMT1, sizeof(AR_EFMT1)-1) == 0){
		    ar_name = file_addr + offset + sizeof(struct ar_hdr);
		    ar_name_size = strtoul(ar_hdr->ar_name +
					   sizeof(AR_EFMT1) - 1, NULL, 10);
		    i = ar_name_size;
		}
		else{
		    ar_name = ar_hdr->ar_name;
		    ar_name_size = 0;
		    i = size_ar_name(ar_hdr);
		}
		offset += sizeof(struct ar_hdr) + ar_name_size;
		ar_size = strtol(ar_hdr->ar_size, NULL, 10) - ar_name_size;
		if(offset + ar_size > file_size){
		    error("truncated or malformed archive: %s (member %.*s "
			  "extends past the end of the file, can't load from "
			  "it)", file_name, (int)i, ar_name);
		    return;
		}
		/*
		 * For -all_load we allow fat files as archive members, so if
		 * this is a fat file load the right architecture.
		 */
		fat_header = (struct fat_header *)(file_addr + offset);
		if(ar_size >= sizeof(struct fat_header) &&
#ifdef __BIG_ENDIAN__
		   fat_header->magic == FAT_MAGIC)
#endif
#ifdef __LITTLE_ENDIAN__
		   fat_header->magic == SWAP_LONG(FAT_MAGIC))
#endif
		{
#ifdef __LITTLE_ENDIAN__
		    struct_fat_header = *fat_header;
		    swap_fat_header(&struct_fat_header, host_byte_sex);
		    fat_header = &struct_fat_header;
#endif
		    if(sizeof(struct fat_header) + fat_header->nfat_arch *
		       sizeof(struct fat_arch) > ar_size){
			error("fat file: %s(%.*s) truncated or malformed "
			    "(fat_arch structs would extend past the end of "
			    "the file)", file_name, (int)i, ar_name);
			return;
		    }
#ifdef __BIG_ENDIAN__
		    fat_archs = (struct fat_arch *)(file_addr + offset +
				sizeof(struct fat_header));
#endif
#ifdef __LITTLE_ENDIAN__
		    fat_archs = allocate(fat_header->nfat_arch *
					 sizeof(struct fat_arch));
		    memcpy(fat_archs, file_addr + offset +
				      sizeof(struct fat_header),
			   fat_header->nfat_arch * sizeof(struct fat_arch));
		    swap_fat_arch(fat_archs, fat_header->nfat_arch,
				  host_byte_sex);
#endif
		    /* check the fat file */
		    check_fat(file_name, ar_size, fat_header, fat_archs,
			      ar_name, i);
		    if(errors)
			return;

		    /* Now select an architecture out of the fat file to use */

		    /*
		     * If the output file's cputype has been set then load the
		     * best fat_arch from it else it's an error.
		     */
		    if(arch_flag.cputype != 0){
			best_fat_arch = cpusubtype_findbestarch(
					arch_flag.cputype, arch_flag.cpusubtype,
					fat_archs, fat_header->nfat_arch);
			if(best_fat_arch == NULL){
			    if(no_arch_warnings == TRUE)
				return;
			    if(arch_flag.name != NULL){
				if(arch_errors_fatal == TRUE){
				    error("fat file: %s(%.*s) does not contain "
					"an architecture that matches the "
					"specified -arch flag: %s", file_name,
					(int)i, ar_name, arch_flag.name);
				}
				else
				    warning("fat file: %s(%.*s) does not "
					"contain an architecture that matches "
					"the specified -arch flag: %s (file "
					"ignored)", file_name, (int)i,
					ar_name, arch_flag.name);
			    }
			    else{
				prev_arch = get_arch_name_from_types(
				    arch_flag.cputype, arch_flag.cpusubtype);
				if(arch_errors_fatal == TRUE){
				    error("fat file: %s(%.*s) does not contain "
					"an architecture that matches the "
					"objects files (architecture %s) "
					"previously loaded", file_name,
					(int)i, ar_name, prev_arch);
				}
				else
				    warning("fat file: %s(%.*s) does not "
					"contain an architecture that matches "
					"the objects files (architecture %s) "
					"previously loaded (file ignored)",
					file_name, (int)i, ar_name, prev_arch);
			    }
			    return;
			}
			arch_addr = file_addr + offset + best_fat_arch->offset;
			arch_size = best_fat_arch->size;
		    }
		    /*
		     * The output file's cputype has not been set so if this
		     * fat file has exactly one type in it then load that type.
		     */
		    else if(fat_header->nfat_arch == 1){
			arch_addr = file_addr + offset + fat_archs[0].offset;
			arch_size = fat_archs[0].size;
		    }
		    /*
		     * The output file's cputype has not been set and if this
		     * fat file has a best arch for the host's specific
		     * architecture type then load that type and set the output
		     * file's cputype to that.
		     */
		    else{
			if(get_arch_from_host(NULL, &host_arch_flag) == 0)
			    fatal("can't determine the host architecture "
				"(specify an -arch flag or fix "
				"get_arch_from_host() )");
			best_fat_arch = cpusubtype_findbestarch(
			    host_arch_flag.cputype, host_arch_flag.cpusubtype,
			    fat_archs, fat_header->nfat_arch);
			if(best_fat_arch != NULL){
			    arch_addr = file_addr + offset +
					best_fat_arch->offset;
			    arch_size = best_fat_arch->size;
			}
			/*
			 * The output file's cputype has not been set and this
			 * fat file does not have only one architecture or has
			 * the host's family architecture so we are stuck not
			 * knowing what to load if anything from it.
			 */
			else
			    fatal("-arch flag must be specified (fat file: "
				"%s(%.*s) does not contain the host "
				"architecture or just one architecture)",
				file_name, (int)i, ar_name);
		    }
		    cur_obj = new_object_file();
		    cur_obj->file_name = file_name;
		    cur_obj->obj_addr = arch_addr;
		    cur_obj->obj_size = arch_size;
		    cur_obj->ar_hdr = ar_hdr;
		    cur_obj->ar_name = ar_name;
		    cur_obj->ar_name_size = i;
#ifdef __LITTLE_ENDIAN__
		    free(fat_archs);
#endif
		    goto down;
		}
		cur_obj = new_object_file();
		cur_obj->file_name = file_name;
		cur_obj->obj_addr = file_addr + offset;
		cur_obj->ar_hdr = ar_hdr;
		cur_obj->ar_name = ar_name;
		cur_obj->ar_name_size = i;
		cur_obj->obj_size = ar_size;
down:
		if(whyload){
		    print_obj_name(cur_obj);
		    print("loaded because of -all_load flag\n");
		}
		merge(FALSE, FALSE, force_weak);
		length = rnd(ar_size + ar_name_size, sizeof(short));
		offset = (offset - ar_name_size) + length;
	    }
	    return;
	}
#endif /* !defined(RLD) */

	/*
	 * If there are no undefined symbols then the archive doesn't have
	 * to be searched because archive members are only loaded to resolve
	 * undefined references unless the -ObjC flag is set.
	 */
	if(undefined_list.next == &undefined_list && archive_ObjC == FALSE)
	    return;

#ifdef RLD
	if(from_fat_file == FALSE)
	    new_archive_or_fat(file_name, file_addr, file_size);
#endif /* RLD */
	/*
	 * The file is an archive so get the symdef file
	 */
	if(offset == file_size){
	    warning("empty archive: %s (can't load from it)", file_name);
	    return;
	}
	if(offset + sizeof(struct ar_hdr) > file_size){
	    error("truncated or malformed archive: %s (archive header of first "
		  "member extends past the end of the file, can't load from "
		  " it)", file_name);
	    return;
	}
	symdef_ar_hdr = (struct ar_hdr *)(file_addr + offset);
	if(strncmp(symdef_ar_hdr->ar_name, AR_EFMT1, sizeof(AR_EFMT1)-1) == 0){
	    symdef_ar_name = file_addr + offset + sizeof(struct ar_hdr);
	    ar_name_size = strtoul(symdef_ar_hdr->ar_name +
				   sizeof(AR_EFMT1) - 1, NULL, 10);
	}
	else{
	    symdef_ar_name = symdef_ar_hdr->ar_name;
	    ar_name_size = 0;
	}
	offset += sizeof(struct ar_hdr) + ar_name_size;
	if(strncmp(symdef_ar_name, SYMDEF, sizeof(SYMDEF) - 1) != 0){
	    error("archive: %s has no table of contents, add one with "
		  "ranlib(1) (can't load from it)", file_name);
	    return;
	}
	symdef_length = strtol(symdef_ar_hdr->ar_size, NULL, 10) - ar_name_size;
	/*
	 * The contents of a __.SYMDEF file is begins with a word giving the
	 * size in bytes of ranlib structures which immediately follow, and
	 * then continues with a string table consisting of a word giving the
	 * number of bytes of strings which follow and then the strings
	 * themselves.  So the smallest valid size is two words long.
	 */
	if(symdef_length < 2 * sizeof(long)){
	    error("size of table of contents for archive: %s too small to be "
		  "a valid table of contents (can't load from it)", file_name);
	    return;
	}
	if(offset + symdef_length > file_size){
	    error("truncated or malformed archive: %s (table of contents "
		  "extends past the end of the file, can't load from it)",
		  file_name);
	    return;
	}
	toc_byte_sex = get_toc_byte_sex(file_addr, file_size);
	nranlibs = *((long *)(file_addr + offset));
	if(toc_byte_sex != host_byte_sex)
	    nranlibs = SWAP_LONG(nranlibs);
	nranlibs = nranlibs / sizeof(struct ranlib);
	offset += sizeof(long);
	ranlibs = (struct ranlib *)(file_addr + offset);
	offset += sizeof(struct ranlib) * nranlibs;
	if(nranlibs == 0){
	    warning("empty table of contents: %s (can't load from it)",
		    file_name);
	    return;
	}
	if(offset - (2 * sizeof(long) + ar_name_size + sizeof(struct ar_hdr) +
		     SARMAG) > symdef_length){
	    error("truncated or malformed archive: %s (ranlib structures in "
		  "table of contents extends past the end of the table of "
		  "contents, can't load from it)", file_name);
	    return;
	}
	string_size = *((long *)(file_addr + offset));
	if(toc_byte_sex != host_byte_sex)
	    string_size = SWAP_LONG(string_size);
	offset += sizeof(long);
	bsearch_strings = file_addr + offset;
	offset += string_size;
	if(offset - (2 * sizeof(long) + ar_name_size + sizeof(struct ar_hdr) +
		     SARMAG) > symdef_length){
	    error("truncated or malformed archive: %s (ranlib strings in "
		  "table of contents extends past the end of the table of "
		  "contents, can't load from it)", file_name);
	    return;
	}
	if(symdef_length == 2 * sizeof(long)){
	    warning("empty table of contents for archive: %s (can't load from "
		    "it)", file_name);
	    return;
	}

	/*
	 * Check the string offset and the member offsets of the ranlib structs.
	 */
	if(toc_byte_sex != host_byte_sex)
	    swap_ranlib(ranlibs, nranlibs, host_byte_sex);
	for(i = 0; i < nranlibs; i++){
	    if(ranlibs[i].ran_un.ran_strx >= string_size){
		error("malformed table of contents in: %s (ranlib struct %lu "
		      "has bad string index, can't load from it)", file_name,i);
		return;
	    }
	    if(ranlibs[i].ran_off + sizeof(struct ar_hdr) >= file_size){
		error("malformed table of contents in: %s (ranlib struct %lu "
		      "has bad library member offset, can't load from it)",
		      file_name, i);
		return;
	    }
	    /*
	     * These should be on 4 byte boundaries because the maximum
	     * alignment of the header structures and relocation are 4 bytes.
	     * But this is has to be 2 bytes because that's the way ar(1) has
	     * worked historicly in the past.  Fortunately this works on the
	     * 68k machines but will have to change when this is on a real
	     * machine.
	     */
#if defined(mc68000) || defined(__i386__)
	    if(ranlibs[i].ran_off % sizeof(short) != 0){
		error("malformed table of contents in: %s (ranlib struct %lu "
		      "library member offset not a multiple of %lu bytes, can't"
		      " load from it)", file_name, i, sizeof(short));
		return;
	    }
#else
	    if(ranlibs[i].ran_off % sizeof(long) != 0){
		error("malformed table of contents in: %s (ranlib struct %lu "
		      "library member offset not a multiple of %lu bytes, can't"
		      " load from it)", file_name, i, sizeof(long));
		return;
	    }
#endif
	}

#ifndef RLD
	/*
	 * If the objective-C flag is set then load every thing in this archive
	 * that defines a symbol that starts with ".objc_class_name" or
	 * ".objc_category_name".
 	 */
	if(archive_ObjC == TRUE){
	    loaded_offsets = allocate(nranlibs * sizeof(unsigned long));
	    nloaded_offsets = 0;
	    for(i = 0; i < nranlibs; i++){
		/* See if this symbol is an objective-C symbol */
		if(strncmp(bsearch_strings + ranlibs[i].ran_un.ran_strx,
		           ".objc_class_name",
			   sizeof(".objc_class_name") - 1) != 0 &&
		   strncmp(bsearch_strings + ranlibs[i].ran_un.ran_strx,
		           ".objc_category_name",
			   sizeof(".objc_category_name") - 1) != 0)
		    continue;

		/* See if the object at this offset has already been loaded */
		loaded_offset = FALSE;
		for(j = 0; j < nloaded_offsets; j++){
		    if(loaded_offsets[j] == ranlibs[i].ran_off){
			loaded_offset = TRUE;
			break;
		    }
		}
		if(loaded_offset == TRUE)
		    continue;
		loaded_offsets[nloaded_offsets++] = ranlibs[i].ran_off;

		if(ld_trace_archives == TRUE &&
		   ld_trace_archive_printed == FALSE){
		    char resolvedname[MAXPATHLEN];
		    if(realpath(file_name, resolvedname) !=
		       NULL)
			ld_trace("[Logging for XBS] Used static "
				 "archive: %s\n", resolvedname);
		    else
			ld_trace("[Logging for XBS] Used static "
				 "archive: %s\n", file_name);
		    ld_trace_archive_printed = TRUE;
		}
		/*
		 * This is an objective-C symbol and the object file at this
		 * offset has not been loaded so load it.
		 */
		cur_obj = new_object_file();
		cur_obj->file_name = file_name;
		cur_obj->ar_hdr = (struct ar_hdr *)(file_addr +
					    ranlibs[i].ran_off);
		if(strncmp(cur_obj->ar_hdr->ar_name, AR_EFMT1,
			   sizeof(AR_EFMT1) - 1) == 0){
		    ar_name = file_addr + ranlibs[i].ran_off +
			      sizeof(struct ar_hdr);
		    ar_name_size = strtoul(cur_obj->ar_hdr->ar_name +
					   sizeof(AR_EFMT1) - 1, NULL, 10);
		    j = ar_name_size;
		}
		else{
		    ar_name = cur_obj->ar_hdr->ar_name;
		    ar_name_size = 0;
		    j = size_ar_name(cur_obj->ar_hdr);
		}
		cur_obj->ar_name = ar_name;
		cur_obj->ar_name_size = j;
		cur_obj->obj_addr = file_addr + ranlibs[i].ran_off +
				    sizeof(struct ar_hdr) + ar_name_size;
		cur_obj->obj_size = strtol(cur_obj->ar_hdr->ar_size,
					   NULL, 10) - ar_name_size;
		if(ranlibs[i].ran_off + sizeof(struct ar_hdr) + ar_name_size +
				    cur_obj->obj_size > file_size){
		    error("malformed library: %s (member %.*s "
			  "extends past the end of the file, can't "
			  "load from it)", file_name, (int)j, ar_name);
		    return;
		}
		if(whyload){
		    print_obj_name(cur_obj);
		    print("loaded because of -ObjC flag to get symbol: %s\n",
			  bsearch_strings + ranlibs[i].ran_un.ran_strx);
		}
		merge(FALSE, FALSE, force_weak);
	    }
	    free(loaded_offsets);
	}

	/*
	 * If a dynamic library has been referenced then this archive library
	 * is put on the dynamic library search list and it will be loaded
	 * from with dynamic library search semantics.
	 */
	if(dynamic_libs != NULL){
	    p = add_dynamic_lib(SORTED_ARCHIVE, NULL, NULL);
	    if(strncmp(symdef_ar_name, SYMDEF_SORTED,
		       sizeof(SYMDEF_SORTED) - 1) == 0){
		p->type = SORTED_ARCHIVE;
/*
 * With the 4.1mach patch and 4.2mach release, we are putting the libgcc
 * functions into a static archive (libcc_dynamic.a) which we will link into
 * every image.  So this obscure warning message would then be seen on nearly
 * every link.  So the decision is to just remove the warning message.
 */
#ifdef notdef
		warning("archive library: %s appears after reference to "
			"dynamic shared library and will be searched as a "
			"dynamic shared library which only the first member "
			"that defines a symbol will ever be loaded", file_name);
#endif /* notdef */
	    }
	    else{
		p->type = UNSORTED_ARCHIVE;
#ifdef notdef
		warning("table of contents of library: %s not sorted slower "
			"link editing will result (use the ranlib(1) -s "
			"option), also library appears after reference to "
			"dynamic shared library and will be searched as a "
			"dynamic shared library which only the first member "
			"that defines a symbol will ever be loaded", file_name);
#endif /* notdef */
	    }
	    p->file_name = file_name;
	    p->file_addr = file_addr;
	    p->file_size = file_size;
	    p->nranlibs = nranlibs;
	    p->ranlibs = ranlibs;
	    p->ranlib_strings = bsearch_strings;
	    return;
	}
#endif /* !defined(RLD) */

	/*
	 * Two possible algorithms are used to determine which members from the
	 * archive are to be loaded.  The first is faster and requires the
	 * ranlib structures to be in sorted order (as produced by the ranlib(1)
	 * -s option).  The only case this can't be done is when more than one
	 * library member in the same archive defines the same symbol.  In this
	 * case ranlib(1) will never sort the ranlib structures but will leave
	 * them in the order of the archive so that the proper member that
	 * defines a symbol that is defined in more that one object is loaded.
	 */
	if(strncmp(symdef_ar_name, SYMDEF_SORTED,
		   sizeof(SYMDEF_SORTED) - 1) == 0){
	    /*
	     * Now go through the undefined symbol list and look up each symbol
	     * in the sorted ranlib structures looking to see it their is a
	     * library member that satisfies this undefined symbol.  If so that
	     * member is loaded and merge() is called.
	     */
	    for(undefined = undefined_list.next;
		undefined != &undefined_list;
		/* no increment expression */){
		/* If this symbol is no longer undefined delete it and move on*/
		if(undefined->merged_symbol->nlist.n_type != (N_UNDF | N_EXT) ||
		   undefined->merged_symbol->nlist.n_value != 0){
		    undefined = undefined->next;
		    delete_from_undefined_list(undefined->prev);
		    continue;
		}
		ranlib = bsearch(undefined->merged_symbol->nlist.n_un.n_name,
			   ranlibs, nranlibs, sizeof(struct ranlib),
			   (int (*)(const void *, const void *))ranlib_bsearch);
		if(ranlib != NULL){

		    if(ld_trace_archives == TRUE &&
		       ld_trace_archive_printed == FALSE){
			char resolvedname[MAXPATHLEN];
			if(realpath(file_name, resolvedname) != NULL)
			    ld_trace("[Logging for XBS] Used "
				     "static archive: %s\n", resolvedname);
			else
			    ld_trace("[Logging for XBS] Used "
				     "static archive: %s\n", file_name);
			ld_trace_archive_printed = TRUE;
		    }

		    /* there is a member that defineds this symbol so load it */
		    cur_obj = new_object_file();
#ifdef RLD
		    cur_obj->file_name = allocate(strlen(file_name) + 1);
		    strcpy(cur_obj->file_name, file_name);
		    cur_obj->from_fat_file = from_fat_file;
#else
		    cur_obj->file_name = file_name;
#endif /* RLD */
		    cur_obj->ar_hdr = (struct ar_hdr *)(file_addr +
							ranlib->ran_off);
		    if(strncmp(cur_obj->ar_hdr->ar_name, AR_EFMT1,
			       sizeof(AR_EFMT1)-1) == 0){
			ar_name = file_addr + ranlib->ran_off +
				  sizeof(struct ar_hdr);
			ar_name_size = strtoul(cur_obj->ar_hdr->ar_name +
					       sizeof(AR_EFMT1) - 1, NULL, 10);
			j = ar_name_size;
		    }
		    else{
			ar_name = cur_obj->ar_hdr->ar_name;
			ar_name_size = 0;
			j = size_ar_name(cur_obj->ar_hdr);
		    }
		    cur_obj->ar_name = ar_name;
		    cur_obj->ar_name_size = j;
		    cur_obj->obj_addr = file_addr + ranlib->ran_off +
					sizeof(struct ar_hdr) + ar_name_size;
		    cur_obj->obj_size = strtol(cur_obj->ar_hdr->ar_size, NULL,
					       10) - ar_name_size;
		    if(ranlib->ran_off + sizeof(struct ar_hdr) + ar_name_size +
						cur_obj->obj_size > file_size){
			error("malformed library: %s (member %.*s extends past "
			      "the end of the file, can't load from it)",
			      file_name, (int)j, ar_name);
			return;
		    }
		    if(whyload){
			print_obj_name(cur_obj);
			print("loaded to resolve symbol: %s\n",
			       undefined->merged_symbol->nlist.n_un.n_name);
		    }

		    merge(FALSE, FALSE, force_weak);

		    /* make sure this symbol got defined */
		    if(errors == 0 &&
		       undefined->merged_symbol->nlist.n_type == (N_UNDF|N_EXT)
		       && undefined->merged_symbol->nlist.n_value == 0){
			error("malformed table of contents in library: %s "
			      "(member %.*s did not define symbol %s)",
			      file_name, (int)j, ar_name,
			      undefined->merged_symbol->nlist.n_un.n_name);
		    }
		    undefined = undefined->next;
		    delete_from_undefined_list(undefined->prev);
		    continue;
		}
		undefined = undefined->next;
	    }
	}
	else{
	    /*
	     * The slower algorithm.  Lookup each symbol in the table of
	     * contents to see if is undefined.  If so that member is loaded
	     * and merge() is called.  A complete pass over the table of
	     * contents without loading a member terminates searching
	     * the library.  This could be made faster if this wrote on the
	     * ran_off to indicate the member at that offset was loaded and
	     * then it's symbol would be not be looked up on later passes.
	     * But this is not done because it would dirty the table of contents
	     * and cause the possibility of more swapping and if fast linking is
	     * wanted then the table of contents can be sorted.
	     */
	    member_loaded = TRUE;
	    while(member_loaded == TRUE && errors == 0){
		member_loaded = FALSE;
		for(i = 0; i < nranlibs; i++){
		    merged_symbol = lookup_symbol(bsearch_strings +
						   ranlibs[i].ran_un.ran_strx);
		    if(merged_symbol->name_len != 0){
			if(merged_symbol->nlist.n_type == (N_UNDF | N_EXT) &&
			   merged_symbol->nlist.n_value == 0){

			    if(ld_trace_archives == TRUE &&
			       ld_trace_archive_printed == FALSE){
				char resolvedname[MAXPATHLEN];
				if(realpath(file_name, resolvedname) != NULL)
				    ld_trace("[Logging for XBS] "
					     "Used static archive: %s\n",
					     resolvedname);
				else
				    ld_trace("[Logging for XBS] "
					     "Used static archive: %s\n",
					     file_name);
				ld_trace_archive_printed = TRUE;
			    }

			    /*
			     * This symbol is defined in this member so load it.
			     */
			    cur_obj = new_object_file();
#ifdef RLD
			    cur_obj->file_name = allocate(strlen(file_name) +1);
			    strcpy(cur_obj->file_name, file_name);
			    cur_obj->from_fat_file = from_fat_file;
#else
			    cur_obj->file_name = file_name;
#endif /* RLD */
			    cur_obj->ar_hdr = (struct ar_hdr *)(file_addr +
							ranlibs[i].ran_off);
			    if(strncmp(cur_obj->ar_hdr->ar_name, AR_EFMT1,
				       sizeof(AR_EFMT1)-1) == 0){
				ar_name = file_addr + ranlibs[i].ran_off +
					  sizeof(struct ar_hdr);
				ar_name_size =
					strtoul(cur_obj->ar_hdr->ar_name +
					        sizeof(AR_EFMT1) - 1, NULL, 10);
				j = ar_name_size;
			    }
			    else{
				ar_name = cur_obj->ar_hdr->ar_name;
				ar_name_size = 0;
				j = size_ar_name(cur_obj->ar_hdr);
			    }
			    cur_obj->ar_name = ar_name;
			    cur_obj->ar_name_size = j;
			    cur_obj->obj_addr = file_addr + ranlibs[i].ran_off +
					sizeof(struct ar_hdr) + ar_name_size;
			    cur_obj->obj_size = strtol(cur_obj->ar_hdr->ar_size,
						       NULL, 10) - ar_name_size;
			    if(ranlibs[i].ran_off + sizeof(struct ar_hdr) +
			       ar_name_size + cur_obj->obj_size > file_size){
				error("malformed library: %s (member %.*s "
				      "extends past the end of the file, can't "
				      "load from it)", file_name, (int)j,
				      ar_name);
				return;
			    }
			    if(whyload){
				print_obj_name(cur_obj);
				print("loaded to resolve symbol: %s\n",
				       merged_symbol->nlist.n_un.n_name);
			    }

			    merge(FALSE, FALSE, force_weak);

			    /* make sure this symbol got defined */
			    if(errors == 0 &&
			       merged_symbol->nlist.n_type == (N_UNDF | N_EXT)
			       && merged_symbol->nlist.n_value == 0){
				error("malformed table of contents in library: "
				      "%s (member %.*s did not defined "
				      "symbol %s)", file_name, (int)j, ar_name,
				      merged_symbol->nlist.n_un.n_name);
			    }
			    /*
			     * Skip any other symbols that are defined in this
			     * member since it has just been loaded.
			     */
			    for(j = i; j + 1 < nranlibs; j++){
				if(ranlibs[i].ran_off != ranlibs[j + 1].ran_off)
				    break;
			    }
			    i = j;
			    member_loaded = TRUE;
			}
		    }
		}
	    }
	}
}

/*
 * get_toc_byte_sex() guesses the byte sex of the table of contents of the
 * library mapped in at the address, addr, of size, size based on the first
 * object file's bytesex.  If it can't figure it out, because the library has
 * no object file members or is malformed it will return UNKNOWN_BYTE_SEX.
 */
__private_extern__
enum byte_sex
get_toc_byte_sex(
char *addr,
uint32_t size)
{
     uint32_t magic;
     uint32_t ar_name_size;
     struct ar_hdr *ar_hdr;
     char *p;

	ar_hdr = (struct ar_hdr *)(addr + SARMAG);

	p = addr + SARMAG + sizeof(struct ar_hdr) +
	    rnd(strtoul(ar_hdr->ar_size, NULL, 10), sizeof(short));
	while(p + sizeof(struct ar_hdr) + sizeof(uint32_t) < addr + size){
	    ar_hdr = (struct ar_hdr *)p;
	    if(strncmp(ar_hdr->ar_name, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0)
		ar_name_size = strtoul(ar_hdr->ar_name + sizeof(AR_EFMT1) - 1,
				       NULL, 10);
	    else
		ar_name_size = 0;
	    p += sizeof(struct ar_hdr);
	    memcpy(&magic, p + ar_name_size, sizeof(uint32_t));
	    if(magic == MH_MAGIC || magic == MH_MAGIC_64)
		return(get_host_byte_sex());
	    else if(magic == SWAP_INT(MH_MAGIC) ||
		    magic == SWAP_INT(MH_MAGIC_64))
		return(get_host_byte_sex() == BIG_ENDIAN_BYTE_SEX ?
		       LITTLE_ENDIAN_BYTE_SEX : BIG_ENDIAN_BYTE_SEX);
	    p += rnd(strtoul(ar_hdr->ar_size, NULL, 10), sizeof(short));
	}
	return(UNKNOWN_BYTE_SEX);
}

/*
 * check_archive_arch() check the archive specified to see if it's architecture
 * does not match that of whats being loaded and if so returns FALSE.  Else it
 * returns TRUE and the archive should be attemped to be loaded from.  This is
 * done so that the obvious case of an archive that is the wrong architecture
 * is not reported an object file at a time but rather one error message is
 * printed.
 */
static
enum bool
check_archive_arch(
char *file_name,
char *file_addr,
unsigned long file_size)
{
    unsigned long offset, obj_size, length;
    struct ar_hdr *symdef_ar_hdr, *ar_hdr;
    unsigned long symdef_length, ar_name_size;
    char *obj_addr, *ar_name;
    struct mach_header mh;
    cpu_type_t cputype;
    cpu_subtype_t cpusubtype;
    enum bool mixed_types;
    const char *new_arch, *prev_arch;

	cputype = 0;
	cpusubtype = 0;
	mixed_types = FALSE;

	offset = SARMAG;
	if(offset == file_size){
	    warning("empty archive: %s (can't load from it)", file_name);
	    return(FALSE);
	}
	if(offset + sizeof(struct ar_hdr) > file_size){
	    error("truncated or malformed archive: %s (archive header of "
		  "first member extends past the end of the file, can't "
		  "load from it)", file_name);
	    return(FALSE);
	}
	symdef_ar_hdr = (struct ar_hdr *)(file_addr + offset);
	if(strncmp(symdef_ar_hdr->ar_name, AR_EFMT1, sizeof(AR_EFMT1)-1) == 0){
	    if(check_extend_format_1(file_name, symdef_ar_hdr,
				    file_size - (offset +sizeof(struct ar_hdr)),
				    &ar_name_size) == FALSE)
		return(FALSE);
	    ar_name = file_addr + offset + sizeof(struct ar_hdr);
	}
	else{
	    ar_name = symdef_ar_hdr->ar_name;
	    ar_name_size = 0;
	}
	if(strncmp(ar_name, SYMDEF, sizeof(SYMDEF) - 1) == 0){
	    offset += sizeof(struct ar_hdr);
	    symdef_length = strtol(symdef_ar_hdr->ar_size, NULL, 10);
	    if(offset + symdef_length > file_size){
		error("truncated or malformed archive: %s (table of "
		      "contents extends past the end of the file, can't "
		      "load from it)", file_name);
		return(FALSE);
	    }
	    offset += rnd(symdef_length, sizeof(short));
	}
	while(offset < file_size){
	    if(offset + sizeof(struct ar_hdr) > file_size){
		error("truncated or malformed archive: %s at offset %lu "
		      "(archive header of next member extends past the end "
		      "of the file, can't load from it)", file_name, offset);
		return(FALSE);
	    }
	    ar_hdr = (struct ar_hdr *)(file_addr + offset);
	    offset += sizeof(struct ar_hdr);
	    if(strncmp(ar_hdr->ar_name, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0){
		if(check_extend_format_1(file_name, ar_hdr, file_size - offset,
					&ar_name_size) == FALSE)
		    return(FALSE);
		ar_name = file_addr + offset;
	    }
	    else{
		ar_name = ar_hdr->ar_name;
		ar_name_size = 0;
	    }
	    offset += ar_name_size;
	    obj_addr = file_addr + offset;
	    obj_size = strtol(ar_hdr->ar_size, NULL, 10);
	    obj_size -= ar_name_size;
	    if(offset + obj_size > file_size){
		error("truncated or malformed archive: %s at offset %lu "
		      "(member extends past the end of the file, can't load "
		      "from it)", file_name, offset);
		return(FALSE);
	    }
	    if(obj_size >= sizeof(struct mach_header)){
		memcpy(&mh, obj_addr, sizeof(struct mach_header));
		if(mh.magic == SWAP_LONG(MH_MAGIC))
		    swap_mach_header(&mh, host_byte_sex);
		if(mh.magic == MH_MAGIC){
		    if(cputype == 0){
			cputype = mh.cputype;
			cpusubtype = mh.cpusubtype;
		    }
		    else if(cputype != mh.cputype){
			mixed_types = TRUE;
		    }
		}
	    }
	    length = rnd(obj_size, sizeof(short));
	    offset += length;
	}
	if(arch_flag.cputype != 0 && mixed_types == FALSE &&
	   arch_flag.cputype != cputype && cputype != 0){
	    if(no_arch_warnings == TRUE)
		return(FALSE);
	    new_arch = get_arch_name_from_types(cputype, cpusubtype);
	    prev_arch = get_arch_name_from_types(arch_flag.cputype,
						 arch_flag.cpusubtype);
	    if(arch_flag.name != NULL)
		warning("%s archive's cputype (%d, architecture %s) does "
		    "not match cputype (%d) for specified -arch flag: "
		    "%s (can't load from it)", file_name, cputype, new_arch,
		    arch_flag.cputype, arch_flag.name);
	    else
		warning("%s archive's cputype (%d, architecture %s) does "
		    "not match cputype (%d architecture %s) of objects "
		    "files previously loaded (can't load from it)", file_name,
		    cputype, new_arch, arch_flag.cputype, prev_arch);
	    return(FALSE);
	}
	return(TRUE);
}

/*
 * check_extend_format_1() checks the archive header for extended format #1.
 */
static
enum bool
check_extend_format_1(
char *name,
struct ar_hdr *ar_hdr,
unsigned long size_left,
unsigned long *member_name_size)
{
    char *p, *endp, buf[sizeof(ar_hdr->ar_name)+1];
    unsigned long ar_name_size;

	*member_name_size = 0;

	buf[sizeof(ar_hdr->ar_name)] = '\0';
	memcpy(buf, ar_hdr->ar_name, sizeof(ar_hdr->ar_name));
	p = buf + sizeof(AR_EFMT1) - 1;
	if(isdigit(*p) == 0){
	    error("truncated or malformed archive: %s (ar_name: %.*s for "
		  "archive extend format #1 starts with non-digit)", name,
		  (int)sizeof(ar_hdr->ar_name), ar_hdr->ar_name);
	    return(FALSE);
	}
	ar_name_size = strtoul(p, &endp, 10);
	if(ar_name_size == ULONG_MAX && errno == ERANGE){
	    error("truncated or malformed archive: %s (size in ar_name: %.*s "
		  "for archive extend format #1 overflows unsigned long)",
		  name, (int)sizeof(ar_hdr->ar_name), ar_hdr->ar_name);
	    return(FALSE);
	}
	while(*endp == ' ' && *endp != '\0')
	    endp++;
	if(*endp != '\0'){
	    error("truncated or malformed archive: %s (size in ar_name: %.*s "
		  "for archive extend format #1 contains non-digit and "
		  "non-space characters)", name, (int)sizeof(ar_hdr->ar_name),
		  ar_hdr->ar_name);
	    return(FALSE);
	}
	if(ar_name_size > size_left){
	    error("truncated or malformed archive: %s (archive name of member "
		  "extends past the end of the file)", name);
	    return(FALSE);
	}
	*member_name_size = ar_name_size;
	return(TRUE);
}


/* This is an object file so it is unconditionally loaded */
static
void
pass1_object(
char *file_name,
char *file_addr,
unsigned long file_size,
enum bool base_name,
enum bool from_fat_file,
enum bool dylib_only,
enum bool bundle_loader,
enum bool force_weak)
{
#ifdef __MWERKS__
    enum bool dummy;
        dummy = base_name;
        dummy = from_fat_file;
#endif
	cur_obj = new_object_file();
#ifdef RLD
	cur_obj->file_name = allocate(strlen(file_name) + 1);
	strcpy(cur_obj->file_name, file_name);
	cur_obj->from_fat_file = from_fat_file;
#else
	cur_obj->file_name = file_name;
#endif /* RLD */
	cur_obj->obj_addr = file_addr;
	cur_obj->obj_size = file_size;
#ifndef RLD
	/*
	 * If this is the base file of an incremental link then set the
	 * pointer to the object file.
	 */
	if(base_name == TRUE)
	    base_obj = cur_obj;
#endif /* !defined(RLD) */

	merge(dylib_only, bundle_loader, force_weak);

#ifndef RLD
	/*
	 * If this is the base file of an incremental link then collect it's
	 * segments for overlap checking.
	 */
	if(base_name == TRUE)
	    collect_base_obj_segments();
#endif /* !defined(RLD) */
	return;
}

#ifndef RLD
/*
 * search_dynamic_libs() searches the libraries on the list of dynamic libraries
 * to resolve undefined symbols.  This is mostly done for static checking of
 * undefined symbols.  If an archive library appears after a dynamic library
 * on the static link line then it will be on the list of dynamic libraries
 * to search and be searched with dynamic library search semantics.  Dynamic
 * library search semantics here mimic what happens in the dynamic link editor.
 * For each undefined symbol a module that defines this symbol is searched for
 * throught the list of libraries to be searched.  That is for each symbol the
 * search starts at the begining of the list of libraries to be searched.  This
 * is unlike archive library search semantic when each library is search once
 * when encountered.
 */
__private_extern__
void
search_dynamic_libs(
void)
{
    struct dynamic_library *p, *q, *dep, *prev;
    unsigned long i, j, nmodules, size, ar_name_size;
    enum bool removed, some_images_setup;
    char *ar_name;

    struct mach_header *mh;
    struct load_command *lc;
    struct dylib_command *dl;
    struct segment_command *sg;

    struct undefined_list *undefined;
    enum bool found;
    struct dylib_table_of_contents *toc;
    struct ranlib *ranlib;

    enum bool bind_at_load_warning;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

    unsigned long library_ordinal;
    char *umbrella_install_name, *short_name, *has_suffix;
    enum bool is_framework, set_some_ordinals, non_set_ordinals;

    struct nlist *extdef_symbols, *extdef;

	/*
	 * If -twolevel_namespace is in effect assign the library ordinals to
	 * all of the dynamic libraries specified on the command line and
	 * already entered on the dynamic_libs list.  These are the primary
	 * libraries and only these ordinals will be recoded in the symbols.
	 * any dependent library added will use the library ordinal from the
	 * primary library that depended on it.  Then when an undefined symbol
	 * is referenced from a dynamic library then its library_ordinal is
	 * recorded in the symbol table nlist struct in the n_desc field with
	 * the macro SET_LIBRARY_ORDINAL(nlist.n_desc, library_ordinal).
	 */
	library_ordinal = 1;
	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type == DYLIB && p->dl->cmd == LC_ID_DYLIB){
		if(twolevel_namespace == TRUE){
		    if(library_ordinal > MAX_LIBRARY_ORDINAL)
			fatal("too many dynamic libraries used, maximum is: %d "
			      "when -twolevel_namespace is in effect",
			      MAX_LIBRARY_ORDINAL);
		}
		p->definition_obj->library_ordinal = library_ordinal;
		library_ordinal++;
		p->dependent_images =
		    allocate(p->definition_obj->nload_dylibs *
			     sizeof(struct dynamic_library *));
	    }
	    else if(p->type == BUNDLE_LOADER){
		p->definition_obj->library_ordinal = EXECUTABLE_ORDINAL;
	    }
	}

	/*
	 * The code in the following loop adds dynamic libraries to the search
	 * list and this ordering matches the library search order dyld uses
	 * for flat-level namespace images and lookups.
	 *
	 * But for two-level namespace lookups ld(1) and dyld lookup symbols in
	 * all the sub_images of a dynamic library when it is encountered in the
	 * search list.  So this can get different symbols in the flat and
	 * two-level namespace cases if there are multiple definitions of the
	 * same symbol in a framework's sub-images.  Or if there are multiple
	 * umbrella frameworks where their sub-frameworks have multiple
	 * definitions of the same symbol.
	 *
	 * Also to record two-level namespace hints ld(1) must exactly match the
	 * list of sub-images created for each library so it can assign the
	 * sub-image indexes and then record them.
	 */

	/*
	 * For dynamic libraries on the dynamic library search list that are
	 * from LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB or LC_REEXPORT_DYLIB
	 * references convert them into using a dylib file so it can be
	 * searched.  Or remove them from the search list if it can't be
	 * converted.  Then add all the dependent libraries for that library to 
	 * the search list.
	 */
	indirect_dylib = TRUE;
	prev = NULL;
	for(p = dynamic_libs; p != NULL; p = p->next){
	    removed = FALSE;
	    /*
	     * If this element on the dynamic library list comes from a
	     * LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB or LC_REEXPORT_DYLIB reference
	     * try to convert them into using a dylib file so it can be
	     * searched.  If not take it off the list.
	     */
	    if(p->type == DYLIB &&
	       (p->dl->cmd == LC_LOAD_DYLIB ||
		p->dl->cmd == LC_LOAD_WEAK_DYLIB ||
		p->dl->cmd == LC_REEXPORT_DYLIB)){
		if(open_dylib(p) == FALSE){
		    if(prebinding == TRUE){
			warning("prebinding disabled because dependent "
			    "library: %s can't be searched", p->dylib_file !=
			    NULL ? p->file_name : p->dylib_name);
			if(ld_trace_prebinding_disabled == TRUE)
			    ld_trace("[Logging for XBS] prebinding"
				     " disabled for %s because dependent library: "
				     "%s can't be searched\n", final_output !=
				     NULL ? final_output : outputfile,
				     p->dylib_file != NULL ? p->file_name :
				     p->dylib_name);
			prebinding = FALSE;
		    }
		    /* remove this dynamic library from the search list */
		    if(prev == NULL)
			dynamic_libs = p->next;
		    else
			prev->next = p->next;
		    removed = TRUE;
		}
		else{
		    p->dependent_images =
			allocate(p->definition_obj->nload_dylibs *
			         sizeof(struct dynamic_library *));
		}
	    }
	    /*
	     * If this element on the dynamic library list is a dylib file
	     * add all of it's dependent libraries to the list.
	     */
	    if(removed == FALSE &&
	       p->type == DYLIB && p->dl->cmd == LC_ID_DYLIB){
		mh = (struct mach_header *)p->definition_obj->obj_addr;
		if(prebinding == TRUE &&
		   (mh->flags & MH_PREBOUND) != MH_PREBOUND){
		    warning("prebinding disabled because dependent library: %s "
			"is not prebound", p->dylib_file != NULL ?
			p->file_name : p->dylib_name);
		    if(ld_trace_prebinding_disabled == TRUE)
			ld_trace("[Logging for XBS] prebinding "
				 "disabled for %s because dependent library: %s "
				 "is not prebound\n", final_output != NULL ?
				 final_output : outputfile, p->dylib_file !=
				 NULL ? p->file_name : p->dylib_name);
		    prebinding = FALSE;
		}
		lc = (struct load_command *)
			((char *)p->definition_obj->obj_addr +
			 sizeof(struct mach_header));
		for(i = 0; i < mh->ncmds; i++){
		    if(lc->cmd == LC_LOAD_DYLIB ||
		       lc->cmd == LC_LOAD_WEAK_DYLIB ||
		       lc->cmd == LC_REEXPORT_DYLIB){
			dl = (struct dylib_command *)lc;
			dep = add_dynamic_lib(DYLIB, dl, p->definition_obj);
			p->dependent_images[p->ndependent_images++] = dep;
		    }
		    lc = (struct load_command *)((char *)lc + lc->cmdsize);
		}
	    }
	    if(removed == FALSE)
		prev = p;
	}
	indirect_dylib = FALSE;

#ifdef DEBUG
	if(debug & (1 << 22)){
	    print("dynamic library search list and ordinals before sub "
		  "assignments:\n");
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB){
		    if(p->dylib_file != NULL)
			printf("  %s ordinal %lu (using file %s)\n",
			   p->dylib_name, p->definition_obj->library_ordinal,
			   p->file_name);
		    else{
			short_name = guess_short_name(p->dylib_name,
						&is_framework, &has_suffix);
			printf("  %s oridinal %lu\n", short_name != NULL ?
			       short_name : p->dylib_name,
			       p->definition_obj->library_ordinal);
		    }
		}
		else
		    printf("  %s (archive)\n", p->file_name);
	    }
	}
#endif /* DEBUG */

	/*
	 * If we are creating or using two-level namespace images now that all
	 * the indirect libraries have been found and opened go through and set
	 * the library_ordinal for those that are used indirectly via a
	 * sub-umbrella, sub-library or sub-framework.
	 */

	/*
	 * Set up the umbrella and library names (if any) for all dynamic
	 * libraries.
	 */
	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type != DYLIB)
		continue;
	    if(p->umbrella_name == NULL){
		umbrella_install_name = (char *)p->dl +
					p->dl->dylib.name.offset;
		short_name = guess_short_name(umbrella_install_name,
					      &is_framework, &has_suffix);
		if(short_name != NULL && is_framework == TRUE)
		    p->umbrella_name = short_name;
		else if(short_name != NULL && is_framework == FALSE)
		    p->library_name = short_name;
	    }
	}
	/*
	 * Now with all the indirect libraries loaded and the
	 * dependent_images set up set up the sub_images for any dynamic
	 * library that does not have this set up yet.  Since sub_images
	 * include sub_umbrellas and sub_librarys any dynamic library that
	 * has sub_umbrellas or sub_librarys must have their sub_umbrella
	 * and sub_librarys images set up first. To do this
	 * setup_sub_images() will return FALSE for a dynamic library that
	 * needed one of its sub_umbrellas or sub_libraries set up and we
	 * will loop here until we get a clean pass with no more dynamic
	 * libraries needing setup.
	 */
	do{
	    some_images_setup = FALSE;
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type != DYLIB)
		    continue;
		if(p->sub_images_setup == FALSE)
		    some_images_setup |= setup_sub_images(p);
	    }
	}while(some_images_setup == TRUE);
	/*
	 * Set the library ordinals for libraries that are not set.
	 */
	do{
	    /*
	     * Set the library ordinals of sub-frameworks who's umbrella
	     * framework has its library ordinal set.
	     */
	    set_some_ordinals = FALSE;
	    non_set_ordinals = FALSE;
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type != DYLIB)
		    continue;
		if(p->definition_obj->library_ordinal != 0 &&
		   p->umbrella_name != NULL)
		    set_some_ordinals |= set_sub_frameworks_ordinals(p);
		else
		    non_set_ordinals = TRUE;
	    }
	    /*
	     * If there are still some not set ordinals then set the dylibs
	     * that are sub-umbrella's or sub-libraries that are not set.
	     */
	    if(non_set_ordinals == TRUE){
		for(p = dynamic_libs; p != NULL; p = p->next){
		    if(p->type != DYLIB)
			continue;
		    if(p->definition_obj->library_ordinal == 0 &&
		       (p->umbrella_name != NULL ||
			p->library_name != NULL)){
			set_some_ordinals |=
			    set_sub_umbrella_sub_library_ordinal(p);
		    }
		}
	    }
	}while(set_some_ordinals == TRUE);

#ifdef DEBUG
	if(debug & (1 << 22)){
	    print("dynamic library search list and ordinals after sub "
		  "assignments:\n");
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB){
		    if(p->dylib_file != NULL)
			printf("  %s ordinal %lu isub_image %lu "
			       "(using file %s)\n", p->dylib_name,
			       p->definition_obj->library_ordinal,
			       p->definition_obj->isub_image, p->file_name);
		    else{
			short_name = guess_short_name(p->dylib_name,
						&is_framework, &has_suffix);
			printf("  %s oridinal %lu isub_image %lu\n",
			       short_name != NULL ?  short_name : p->dylib_name,
			       p->definition_obj->library_ordinal,
			       p->definition_obj->isub_image);
		    }
		    print("    ndependent_images = %lu\n",p->ndependent_images);
		    for(i = 0; i < p->ndependent_images; i++){
			dep = p->dependent_images[i];
			short_name = guess_short_name(dep->dylib_name,
						&is_framework, &has_suffix);
			printf("      [%lu] %s\n", i, short_name != NULL ?
			       short_name : dep->dylib_name);

		    }
		    print("    nsub_images = %lu\n",p->nsub_images);
		    for(i = 0; i < p->nsub_images; i++){
			dep = p->sub_images[i];
			short_name = guess_short_name(dep->dylib_name,
						&is_framework, &has_suffix);
			printf("      [%lu] %s\n", i, short_name != NULL ?
			       short_name : dep->dylib_name);

		    }
		}
		else
		    printf("  %s (archive)\n", p->file_name);
	    }
	}
#endif /* DEBUG */

	/*
	 * When building for two-level-namespace, remove from the search path
	 * indirect libraries that cannot be encoded in a library ordinal.
	 *
	 * It is unclear what the reason for this part of the logic:
	 *  && (force_flat_namespace == FALSE) && (filetype != MH_OBJECT)
	 * is here for and is likely wrong.
	 */
	if((twolevel_namespace == TRUE) &&
	   (force_flat_namespace == FALSE) &&
	   (filetype != MH_OBJECT)){
	    struct dynamic_library* last_library;
	    unsigned int total_library_count;
	    unsigned int direct_library_count;

	    last_library = NULL;
	    total_library_count = 0;
	    direct_library_count = 0;
	    for(p = dynamic_libs; p != NULL; p = p->next){
		total_library_count += 1;
		if((p->type == DYLIB) &&
		   (p->definition_obj->library_ordinal == 0)){
		    if(last_library == NULL)
			dynamic_libs = p->next;
		    else
			last_library->next = p->next;
		}
		else{
		    last_library = p;
		    direct_library_count += 1;
		}
	    }
	    if(direct_library_count != 0)
		indirect_library_ratio =
		    total_library_count / direct_library_count;
	}

	/*
	 * Go through the specified dynamic libraries setting up their table of
	 * contents data.
	 */
	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type == DYLIB){
		if(p->dl->cmd == LC_ID_DYLIB){
		    p->tocs = (struct dylib_table_of_contents *)(
			       p->definition_obj->obj_addr +
			       p->definition_obj->dysymtab->tocoff);
		    p->strings = p->definition_obj->obj_addr +
				 p->definition_obj->symtab->stroff;
		    p->symbols = (struct nlist *)(
				  p->definition_obj->obj_addr +
				  p->definition_obj->symtab->symoff);
		    if(p->definition_obj->swapped)
	    		swap_nlist(p->symbols,
				   p->definition_obj->symtab->nsyms,
				   host_byte_sex);
		    p->mods = (struct dylib_module *)(
			       p->definition_obj->obj_addr +
			       p->definition_obj->dysymtab->modtaboff);
		    /*
		     * If prebinding an executable create a LC_PREBOUND_DYLIB
		     * load command for each dynamic library.  To allow the
		     * prebinding to be redone when the library has more
		     * modules the bit vector for the linked modules is padded
		     * to 125% of the number of modules with a minimum of 64
		     * modules.
		     */
		    if(prebinding == TRUE && filetype == MH_EXECUTE){
			nmodules = p->definition_obj->dysymtab->nmodtab +
				   (p->definition_obj->dysymtab->nmodtab >> 2);
			if(nmodules < 64)
			    nmodules = 64;
			size = sizeof(struct prebound_dylib_command) +
			       rnd(strlen(p->dylib_name) + 1, sizeof(long)) +
			       rnd(nmodules / 8, sizeof(long));
			p->pbdylib = allocate(size);
			memset(p->pbdylib, '\0', size);
			p->pbdylib->cmd = LC_PREBOUND_DYLIB;
			p->pbdylib->cmdsize = size;
			p->pbdylib->name.offset =
				sizeof(struct prebound_dylib_command);
			strcpy(((char *)p->pbdylib) +
				sizeof(struct prebound_dylib_command),
				p->dylib_name);
			p->pbdylib->nmodules =
				p->definition_obj->dysymtab->nmodtab;
			p->pbdylib->linked_modules.offset =
				sizeof(struct prebound_dylib_command) +
				rnd(strlen(p->dylib_name) + 1, sizeof(long));
			p->linked_modules = ((char *)p->pbdylib) +
				sizeof(struct prebound_dylib_command) +
				rnd(strlen(p->dylib_name) + 1, sizeof(long));
		    }
		}
	    }
	    if(p->type == BUNDLE_LOADER){
		p->strings = p->definition_obj->obj_addr +
			     p->definition_obj->symtab->stroff;
		p->symbols = (struct nlist *)(
			      p->definition_obj->obj_addr +
			      p->definition_obj->symtab->symoff);
		if(p->definition_obj->swapped)
		    swap_nlist(p->symbols,
			       p->definition_obj->symtab->nsyms,
			       host_byte_sex);
	    }
	}

	/*
	 * If we are going to attempt to prebind we save away the segments of
	 * the dylibs so they can be checked for overlap after layout.
	 */
	if(prebinding == TRUE){
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB && p->dl->cmd == LC_ID_DYLIB){
		    mh = (struct mach_header *)p->definition_obj->obj_addr;
		    lc = (struct load_command *)
			    ((char *)p->definition_obj->obj_addr +
			     sizeof(struct mach_header));
		    for(i = 0; i < mh->ncmds; i++){
			if(lc->cmd == LC_SEGMENT){
		    	    sg = (struct segment_command *)lc;
			    add_dylib_segment(sg, p->dylib_name,
				(mh->flags & MH_SPLIT_SEGS) == MH_SPLIT_SEGS);
			}
			lc = (struct load_command *)((char *)lc + lc->cmdsize);
		    }
		}
	    }
	}

#ifdef DEBUG
	if(debug & (1 << 22)){
	    print("dynamic library search list:\n");
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB){
		    if(p->dylib_file != NULL)
			printf("\t%s (using file %s)\n", p->dylib_name,
			       p->file_name);
		    else{
			short_name = guess_short_name(p->dylib_name,
						&is_framework, &has_suffix);
			printf("\t%s\n", short_name != NULL ?
			       short_name : p->dylib_name);
		    }
		}
		else
		    printf("\t%s (archive)\n", p->file_name);
	    }
	}
#endif
	if(ld_trace_dylibs == TRUE){
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB){
		    char resolvedname[MAXPATHLEN];
		    if(realpath(p->definition_obj->file_name, resolvedname) !=
		       NULL)
			ld_trace("[Logging for XBS] Used dynamic "
				 "library: %s\n", resolvedname);
		    else
		        ld_trace("[Logging for XBS] Used dynamic "
				 "library: %s\n", p->definition_obj->file_name);
		}
	    }
	}

	/*
	 * Now go through the undefined symbol list and look up each symbol
	 * in the table of contents of each library on the dynamic library
	 * search list.
	 */
	for(undefined = undefined_list.next;
	    undefined != &undefined_list;
	    /* no increment expression */){

	    /*
	     * If this symbol is a twolevel_reference placed on the undefined
	     * list by merge_dylib_module_symbols() in symbols.c then we
	     * determine which dylib module needs to be loaded and if it is not
	     * yet loaded we load it.  Note the merged symbol pointed to by
	     * this undefined entry is a fake and not entered into the symbol
	     * symbol table.  This merged symbol's nlist is a copy of the nlist
	     * from the referencing_library.
	     */
	    if(undefined->merged_symbol->twolevel_reference == TRUE){
		library_ordinal = GET_LIBRARY_ORDINAL(
				    undefined->merged_symbol->nlist.n_desc);
		if(library_ordinal == SELF_LIBRARY_ORDINAL)
		    p = undefined->merged_symbol->referencing_library;
		/*
		 * Note that if library_ordinal was DYNAMIC_LOOKUP_ORDINAL then
		 * merge_dylib_module_symbols() in symbols.c would not have
		 * set the twolevel_reference field to TRUE in the merged_symbol
		 * and if we get here it with this it is an internal error.
		 */
		else if(library_ordinal == DYNAMIC_LOOKUP_ORDINAL)
		    fatal("internal error: search_dynamic_libs() with a "
			  "merged_symbol (%s) on the undefined list with "
			  "twolevel_reference == TRUE and library_ordinal == "
			  "DYNAMIC_LOOKUP_ORDINAL", undefined->merged_symbol->
			  nlist.n_un.n_name);
		else
		    p = undefined->merged_symbol->referencing_library->
			    dependent_images[library_ordinal - 1];
		q = p;
		/*
		 * This could be a dylib that was missing so its dynamic_library
		 * struct will be just an LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB,
		 * LC_REEXPORT_DYLIB command and a name with no strings,
		 * symbols, sub_images, etc.
	 	 */
		if(p->dl->cmd == LC_LOAD_DYLIB ||
		   p->dl->cmd == LC_LOAD_WEAK_DYLIB ||
		   p->dl->cmd == LC_REEXPORT_DYLIB)
		    goto undefined_twolevel_reference;
		bsearch_strings = q->strings;
		bsearch_symbols = q->symbols;
		toc = bsearch(undefined->merged_symbol->nlist.n_un.n_name,
			      q->tocs, q->definition_obj->dysymtab->ntoc,
			      sizeof(struct dylib_table_of_contents),
			      (int (*)(const void *, const void *))
				dylib_bsearch);
		if(toc == NULL){
		    for(i = 0; toc == NULL && i < p->nsub_images; i++){
			q = p->sub_images[i];
			if(q->dl->cmd == LC_LOAD_DYLIB ||
			   q->dl->cmd == LC_LOAD_WEAK_DYLIB ||
			   q->dl->cmd == LC_REEXPORT_DYLIB)
			    break;
			bsearch_strings = q->strings;
			bsearch_symbols = q->symbols;
			toc = bsearch(undefined->merged_symbol->
				  nlist.n_un.n_name, q->tocs,
				  q->definition_obj->dysymtab->ntoc,
				  sizeof(struct dylib_table_of_contents),
				  (int (*)(const void *, const void *))
				    dylib_bsearch);
		    }
		}
		if(toc != NULL){
		    /*
		     * There is a module that defineds this symbol so see if it
		     * has been loaded and if not load it.
		     */
		    if(is_dylib_module_loaded(q->mods + toc->module_index) ==
		       FALSE){
			cur_obj = new_object_file();
			*cur_obj = *(q->definition_obj);
			cur_obj->dylib_module = q->mods + toc->module_index;
			if(q->linked_modules != NULL)
			    q->linked_modules[toc->module_index / 8] |=
				1 << toc->module_index % 8;
			if(whyload){
			    print_obj_name(cur_obj);
			    print("loaded to resolve symbol: %s ",
			       undefined->merged_symbol->nlist.n_un.n_name);
			    dep = undefined->merged_symbol->referencing_library;
			    if(dep->umbrella_name != NULL)
				short_name = dep->umbrella_name;
			    else if(dep->library_name != NULL)
				short_name = dep->library_name;
			    else
				short_name = dep->dylib_name;
			    print("referenced from %s\n", short_name);
			}
			merge_dylib_module_symbols(q);
			/*
			 * We would like to make sure this symbol got defined
			 * from this dylib module.  But since this is a
			 * two-level reference the symbol in this dylib module
			 * may or may not be used by the output file being
			 * created (the symbol entered in the merged symbol
			 * table not this fake one).
			 */

			/*
			 * Since something from this dynamic library is being
			 * used, if there is a library initialization routine
			 * make sure that the module that defines it is loaded.
			 */
			load_init_dylib_module(q);
		    }
		    /*
		     * If the -Y flag is not set free the memory for this fake
		     * merged_symbol which was for a two-level reference, move
		     * to the next undefined, and take this off the undefined
		     * list.
		     */
		    if(!Yflag)
			free(undefined->merged_symbol);
		    undefined = undefined->next;
		    delete_from_undefined_list(undefined->prev);
		}
		else{
		    /*
		     * The library expected to define this symbol did not define
		     * it so it must remain undefined and should result in an
		     * undefined symbol error.  In process_undefineds() in
		     * symbols.c it loops over the undefined list looking for
		     * these fake merged_symbols.
		     */
undefined_twolevel_reference:
		    undefined = undefined->next;
		}
		continue;
	    }

	    /* If this symbol is no longer undefined delete it and move on*/
	    if(undefined->merged_symbol->nlist.n_type != (N_UNDF | N_EXT) ||
	       undefined->merged_symbol->nlist.n_value != 0){
		undefined = undefined->next;
		delete_from_undefined_list(undefined->prev);
		continue;
	    }

	    /*
	     * If -twolevel_namespace is in effect then when each dynamic
	     * library is seen all of its sub-images are searched at that
	     * point.  So to avoid searching a dynamic library more than once
	     * per symbol the twolevel_searched field is set to TRUE when
	     * searched and the library is skipped if it is encountered again
	     * when looking for the same symbol.
	     */
	    if(twolevel_namespace == TRUE){
		for(p = dynamic_libs; p != NULL; p = p->next)
		    p->twolevel_searched = FALSE;
	    }
	    found = FALSE;
	    for(p = dynamic_libs; p != NULL && found == FALSE; p = p->next){
		switch(p->type){

		case DYLIB:
		    if(twolevel_namespace == TRUE &&
		       p->twolevel_searched == TRUE)
			break;
		    /*
		     * This could be a dylib that was missing so its
		     * dynamic_library struct will be just an LC_LOAD_DYLIB,
		     * LC_LOAD_WEAK_DYLIB or LC_REEXPORT_DYLIB command and a
		     * name with no strings, symbols, sub_images, etc.
		     */
		    if(p->dl->cmd == LC_LOAD_DYLIB ||
		       p->dl->cmd == LC_LOAD_WEAK_DYLIB ||
		       p->dl->cmd == LC_REEXPORT_DYLIB)
			break;
		    q = p;
		    bsearch_strings = q->strings;
		    bsearch_symbols = q->symbols;
		    toc = bsearch(undefined->merged_symbol->nlist.n_un.n_name,
				  q->tocs, q->definition_obj->dysymtab->ntoc,
				  sizeof(struct dylib_table_of_contents),
				  (int (*)(const void *, const void *))
				    dylib_bsearch);
		    if(toc == NULL && twolevel_namespace == TRUE){
			q->twolevel_searched = TRUE;
			for(i = 0; toc == NULL && i < p->nsub_images; i++){
			    q = p->sub_images[i];
			    q->twolevel_searched = TRUE;
			    if(q->dl->cmd == LC_LOAD_DYLIB ||
			       q->dl->cmd == LC_LOAD_WEAK_DYLIB ||
			       q->dl->cmd == LC_REEXPORT_DYLIB)
				break;
			    /*
			     * Don't search images that cannot be two level
			     * encoded.
			     *
			     * This logic seems questionable that this is not
			     * conditional on building a two-level namespace
			     * image.
			     */
			    if(q->definition_obj->library_ordinal == 0)
				continue;
			    bsearch_strings = q->strings;
			    bsearch_symbols = q->symbols;
			    toc = bsearch(undefined->merged_symbol->
				      nlist.n_un.n_name, q->tocs,
				      q->definition_obj->dysymtab->ntoc,
				      sizeof(struct dylib_table_of_contents),
				      (int (*)(const void *, const void *))
					dylib_bsearch);
			}
		    }
		    if(toc != NULL){
			/*
			 * There is a module that defineds this symbol so
			 * load it.
			 */
			cur_obj = new_object_file();
			*cur_obj = *(q->definition_obj);
			cur_obj->dylib_module = q->mods + toc->module_index;
			if(q->linked_modules != NULL)
			    q->linked_modules[toc->module_index / 8] |=
				1 << toc->module_index % 8;
			if(whyload){
			    print_obj_name(cur_obj);
			    print("loaded to resolve symbol: %s\n",
			       undefined->merged_symbol->nlist.n_un.n_name);
			}
			merge_dylib_module_symbols(q);
			/* make sure this symbol got defined */
			if(errors == 0 &&
			   undefined->merged_symbol->nlist.n_type ==
			    (N_UNDF|N_EXT)
			   && undefined->merged_symbol->nlist.n_value == 0){
			    error("malformed table of contents in library: "
			       "%s (module %s did not define symbol %s)",
			       cur_obj->file_name, bsearch_strings +
			       cur_obj->dylib_module->module_name,
			       undefined->merged_symbol->nlist.n_un.n_name);
			}
			if(twolevel_namespace == TRUE)
			    undefined->merged_symbol->itoc = toc - q->tocs;
			undefined = undefined->next;
			delete_from_undefined_list(undefined->prev);
			found = TRUE;

			/*
			 * Since something from this dynamic library is being
			 * used, if there is a library initialization routine
			 * make sure that the module that defines it is loaded.
			 */
			load_init_dylib_module(q);
		    }
		    break;

		case SORTED_ARCHIVE:
		    bsearch_strings = p->ranlib_strings;
		    ranlib = bsearch(undefined->merged_symbol->
				     nlist.n_un.n_name, p->ranlibs, p->nranlibs,
				     sizeof(struct ranlib),
				     (int (*)(const void *, const void *))
					ranlib_bsearch);
		    if(ranlib != NULL){
			if(ld_trace_archives == TRUE &&
			   p->ld_trace_archive_printed == FALSE){
			    char resolvedname[MAXPATHLEN];
			    if(realpath(p->file_name, resolvedname) != NULL)
				ld_trace("[Logging for XBS] Used "
					 "static archive: %s\n", resolvedname);
			    else
				ld_trace("[Logging for XBS] Used "
					 "static archive: %s\n", p->file_name);
			    p->ld_trace_archive_printed = TRUE;
			}
			/*
			 * There is a member that defineds this symbol so
			 * load it.
			 */
			cur_obj = new_object_file();
			cur_obj->file_name = p->file_name;
			cur_obj->ar_hdr = (struct ar_hdr *)(p->file_addr +
							    ranlib->ran_off);
			if(strncmp(cur_obj->ar_hdr->ar_name, AR_EFMT1,
				   sizeof(AR_EFMT1)-1) == 0){
			    ar_name = p->file_addr + ranlib->ran_off +
				      sizeof(struct ar_hdr);
			    ar_name_size =
				    strtoul(cur_obj->ar_hdr->ar_name +
					    sizeof(AR_EFMT1) - 1, NULL, 10);
			    j = ar_name_size;
			}
			else{
			    ar_name = cur_obj->ar_hdr->ar_name;
			    ar_name_size = 0;
			    j = size_ar_name(cur_obj->ar_hdr);
			}
			cur_obj->ar_name = ar_name;
			cur_obj->ar_name_size = j;
			cur_obj->obj_addr = p->file_addr +
					    ranlib->ran_off +
					    sizeof(struct ar_hdr) +
					    ar_name_size;
			cur_obj->obj_size = strtol(cur_obj->ar_hdr->ar_size,
						   NULL, 10) - ar_name_size;
			if(ranlib->ran_off + sizeof(struct ar_hdr) +
			   ar_name_size + cur_obj->obj_size > p->file_size){
			    error("malformed library: %s (member %.*s extends "
				  "past the end of the file, can't load from "
				  "it)",p->file_name, (int)j, ar_name);
			    return;
			}
			if(whyload){
			    print_obj_name(cur_obj);
			    print("loaded to resolve symbol: %s\n",
				   undefined->merged_symbol->nlist.n_un.n_name);
			}

			merge(FALSE, FALSE, FALSE);

			/* make sure this symbol got defined */
			if(errors == 0 &&
			   undefined->merged_symbol->nlist.n_type ==
			   (N_UNDF|N_EXT)
			   && undefined->merged_symbol->nlist.n_value == 0){
			    error("malformed table of contents in library: %s "
				  "(member %.*s did not define symbol %s)",
				  p->file_name, (int)j, ar_name,
				  undefined->merged_symbol->nlist.n_un.n_name);
			}
			undefined = undefined->next;
			delete_from_undefined_list(undefined->prev);
			found = TRUE;
		    }
		    break;

		case UNSORTED_ARCHIVE:
		    for(i = 0; found == FALSE && i < p->nranlibs; i++){
			if(strcmp(undefined->merged_symbol->nlist.n_un.n_name,
				  p->ranlib_strings +
				  p->ranlibs[i].ran_un.ran_strx) == 0){
			    if(ld_trace_archives == TRUE &&
			       p->ld_trace_archive_printed == FALSE){
				char resolvedname[MAXPATHLEN];
				if(realpath(p->file_name, resolvedname) != NULL)
				    ld_trace("[Logging for XBS] "
					     "Used static archive: %s\n",
					     resolvedname);
				else
				    ld_trace("[Logging for XBS] "
					     "Used static archive: %s\n",
					     p->file_name);
				p->ld_trace_archive_printed = TRUE;
			    }
			    /*
			     * There is a member that defineds this symbol so
			     * load it.
			     */
			    cur_obj = new_object_file();
			    cur_obj->file_name = p->file_name;
			    cur_obj->ar_hdr = (struct ar_hdr *)(p->file_addr +
							p->ranlibs[i].ran_off);
			    if(strncmp(cur_obj->ar_hdr->ar_name, AR_EFMT1,
				       sizeof(AR_EFMT1)-1) == 0){
				ar_name = p->file_addr + p->ranlibs[i].ran_off +
					  sizeof(struct ar_hdr);
				ar_name_size =
					strtoul(cur_obj->ar_hdr->ar_name +
					        sizeof(AR_EFMT1) - 1, NULL, 10);
				j = ar_name_size;
			    }
			    else{
				ar_name = cur_obj->ar_hdr->ar_name;
				ar_name_size = 0;
				j = size_ar_name(cur_obj->ar_hdr);
			    }
			    cur_obj->ar_name = ar_name;
			    cur_obj->ar_name_size = j;
			    cur_obj->obj_addr = p->file_addr +
						p->ranlibs[i].ran_off +
						sizeof(struct ar_hdr) +
						ar_name_size;
			    cur_obj->obj_size = strtol(cur_obj->ar_hdr->ar_size,
						       NULL, 10) - ar_name_size;
			    if(p->ranlibs[i].ran_off + sizeof(struct ar_hdr) +
			       ar_name_size + cur_obj->obj_size > p->file_size){
				error("malformed library: %s (member %.*s "
				      "extends past the end of the file, can't "
				      "load from it)", p->file_name, (int)j,
				      ar_name);
				return;
			    }
			    if(whyload){
				print_obj_name(cur_obj);
				print("loaded to resolve symbol: %s\n",
				   undefined->merged_symbol->nlist.n_un.n_name);
			    }

			    merge(FALSE, FALSE, FALSE);

			    /* make sure this symbol got defined */
			    if(errors == 0 &&
			       undefined->merged_symbol->nlist.n_type ==
			       (N_UNDF|N_EXT)
			       && undefined->merged_symbol->nlist.n_value == 0){
				error("malformed table of contents in library: "
				   "%s (member %.*s did not define symbol %s)",
				   p->file_name, (int)j, ar_name,
				   undefined->merged_symbol->nlist.n_un.n_name);
			    }
			    undefined = undefined->next;
			    delete_from_undefined_list(undefined->prev);
			    found = TRUE;
			}
		    }
		    break;

		case BUNDLE_LOADER:
		    bsearch_strings = p->definition_obj->obj_addr +
			      p->definition_obj->symtab->stroff;
		    extdef_symbols = (struct nlist *)(
				  p->definition_obj->obj_addr +
				  p->definition_obj->symtab->symoff) +
				  p->definition_obj->dysymtab->iextdefsym;
		    extdef =bsearch(undefined->merged_symbol->nlist.n_un.n_name,
				  extdef_symbols,
				  p->definition_obj->dysymtab->nextdefsym,
				  sizeof(struct nlist),
				  (int (*)(const void *, const void *))
				    nlist_bsearch);
		    if(extdef != NULL){
			/*
			 * There is a external symbol in the bundle loader that
			 * defineds this symbol so load it.
			 */
			cur_obj = p->definition_obj;
			if(whyload){
			    print_obj_name(cur_obj);
			    print("loaded to resolve symbol: %s\n",
			       undefined->merged_symbol->nlist.n_un.n_name);
			}

			merge_bundle_loader_symbols(p);

			/* make sure this symbol got defined */
			if(errors == 0 &&
			   undefined->merged_symbol->nlist.n_type ==
			    (N_UNDF|N_EXT)
			   && undefined->merged_symbol->nlist.n_value == 0){
			    error("malformed external defined symbols of "
			       "-bundle_loader: %s (it did not define symbol "
			       "%s)", cur_obj->file_name,
			       undefined->merged_symbol->nlist.n_un.n_name);
			}
			undefined = undefined->next;
			delete_from_undefined_list(undefined->prev);
			found = TRUE;
		    }
		    break;
		}
	    }
	    if(found == FALSE)
		undefined = undefined->next;
	}

	/*
	 * Check to see all merged symbols coming from dynamic libraries
	 * came from the first one defining the symbol.  If not issue a warning
	 * suggesting -bind_at_launch be used.
	 */
	if(filetype == MH_EXECUTE && bind_at_load == FALSE){
	    bind_at_load_warning = FALSE;
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
		merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(merged_symbol->defined_in_dylib != TRUE)
			continue;
		    if(merged_symbol->coalesced_defined_in_dylib == TRUE)
			continue;
		    if(twolevel_namespace == TRUE){
			for(p = dynamic_libs; p != NULL; p = p->next)
			    p->twolevel_searched = FALSE;
		    }
		    for(p = dynamic_libs; p != NULL; p = p->next){
			if(p->type == DYLIB){
			    if(twolevel_namespace == TRUE &&
			       p->twolevel_searched == TRUE)
				break;
			    q = p;
			    if(q->dl->cmd == LC_LOAD_DYLIB ||
			       q->dl->cmd == LC_LOAD_WEAK_DYLIB ||
			       q->dl->cmd == LC_REEXPORT_DYLIB)
				break;
			    bsearch_strings = q->strings;
			    bsearch_symbols = q->symbols;
			    toc = bsearch(merged_symbol->nlist.n_un.n_name,
				      q->tocs,q->definition_obj->dysymtab->ntoc,
				      sizeof(struct dylib_table_of_contents),
				      (int (*)(const void *, const void *))
					dylib_bsearch);
			    if(toc == NULL && twolevel_namespace == TRUE){
				q->twolevel_searched = TRUE;
				for(j = 0;
				    toc == NULL && j < p->nsub_images;
				    j++){
				    q = p->sub_images[j];
				    q->twolevel_searched = TRUE;
				    if(q->dl->cmd == LC_LOAD_DYLIB ||
				       q->dl->cmd == LC_LOAD_WEAK_DYLIB ||
				       q->dl->cmd == LC_REEXPORT_DYLIB)
					break;
				    bsearch_strings = q->strings;
				    bsearch_symbols = q->symbols;
				    toc = bsearch(merged_symbol->
				      nlist.n_un.n_name, q->tocs,
				      q->definition_obj->dysymtab->ntoc,
				      sizeof(struct dylib_table_of_contents),
				      (int (*)(const void *, const void *))
					dylib_bsearch);
				}
			    }
			    if(toc != NULL){
				if(merged_symbol->definition_object->obj_addr
				   == q->definition_obj->obj_addr)
				    break;
				if(merged_symbol->definition_object->obj_addr
				   != q->definition_obj->obj_addr){
				    if(bind_at_load_warning == FALSE){
					warning("suggest use of -bind_at_load, "
						"as lazy binding may result in "
						"errors or different symbols "
						"being used");
					bind_at_load_warning = TRUE;
				    }
				    printf("symbol %s used from dynamic "
					"library %s(%s) not from earlier "
					"dynamic library %s(%s)\n",
					merged_symbol->nlist.n_un.n_name,
					merged_symbol->definition_object->
					    file_name,
					(merged_symbol->definition_object->
					    obj_addr + merged_symbol->
					    definition_object->symtab->stroff) +
					merged_symbol->definition_object->
					    dylib_module->module_name,
					q->dylib_name,
					bsearch_strings + (q->mods +
					    toc->module_index)->module_name);
				}
			    }
			}
		    }
		}
	    }
	}

	/*
	 * If the -prebind_all_twolevel_modules is specified and prebinding is
	 * is still enabled and the output is an executable and we are not
	 * building with -force_flat_namespace then change the bit vectors in
	 * the two-level dynamic libraries to mark all modules as used.
	 */
	if(prebind_all_twolevel_modules == TRUE && prebinding == TRUE &&
	   filetype == MH_EXECUTE && force_flat_namespace == FALSE){
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB &&
		   p->dl->cmd == LC_ID_DYLIB &&
		   p->linked_modules != NULL){
		    mh = (struct mach_header *)(p->definition_obj->obj_addr);
		    if((mh->flags & MH_TWOLEVEL) == MH_TWOLEVEL){
			nmodules = p->definition_obj->dysymtab->nmodtab;
			for(i = 0; i < nmodules; i++){
			    p->linked_modules[i / 8] |= 1 << i % 8;
			}
		    }
		}
	    }
	}
}

/*
 * load_init_dylib_module() is passed a pointer to a dynamic library that just
 * had a module loaded.  Since something from this dynamic library is being used
 * if there is a library initialization routine make sure that the module that
 * defines it is loaded.
 */
static
void
load_init_dylib_module(
struct dynamic_library *q)
{
	if(q->definition_obj->rc != NULL &&
	   q->definition_obj->init_module_loaded == FALSE){
	    if(is_dylib_module_loaded(q->mods +
		  q->definition_obj->rc->init_module) == FALSE){
		cur_obj = new_object_file();
		*cur_obj = *(q->definition_obj);
		cur_obj->dylib_module = q->mods +
		    q->definition_obj->rc->init_module;
		if(q->linked_modules != NULL)
		    q->linked_modules[q->definition_obj->rc->
				  init_module / 8] |= 1 <<
			q->definition_obj->rc->init_module % 8;
		if(whyload){
		    print_obj_name(cur_obj);
		    print("loaded for library initialization "
			  "routine\n");
		}
		merge_dylib_module_symbols(q);
	    }
	    q->definition_obj->init_module_loaded = TRUE;
	}
}

/*
 * setup_sub_images() is called to set up the sub images that make up the
 * specified "primary" dynamic library.  If not all of its sub_umbrella's and
 * sub_librarys are set up then it will return FALSE and not set up the sub
 * images.  The caller will loop through all the libraries until all libraries
 * are setup.  This routine will return TRUE when it sets up the sub_images and
 * will also set the sub_images_setup field to TRUE in the specified library.
 */
static
enum bool
setup_sub_images(
struct dynamic_library *p)
{
    unsigned long i, j, k, l, n, max_libraries;
    struct mach_header *mh;
    struct load_command *lc, *load_commands;
    struct sub_umbrella_command *usub;
    struct sub_library_command *lsub;
    struct sub_framework_command *sub;
    struct dynamic_library **deps;
    char *sub_umbrella_name, *sub_library_name, *sub_framework_name;
    enum bool found;

	max_libraries = 0;
	deps = p->dependent_images;

	/*
	 * First see if this library has any sub-umbrellas or sub-librarys and
	 * that they have had their sub-images set up.  If not return FALSE and
	 * wait for this to be set up.  If so add the count of sub-images to
	 * max_libraries value which will be used for allocating the array for
	 * the sub-images of this library.
	 */
	mh = (struct mach_header *)(p->definition_obj->obj_addr);
	load_commands = (struct load_command *)((char *)mh +
						sizeof(struct mach_header));
	lc = load_commands;
	for(i = 0; i < mh->ncmds; i++){
	    switch(lc->cmd){
	    case LC_SUB_UMBRELLA:
		usub = (struct sub_umbrella_command *)lc;
		sub_umbrella_name = (char *)usub + usub->sub_umbrella.offset;
		for(j = 0; j < p->ndependent_images; j++){
		    if(deps[j]->umbrella_name != NULL &&
		       strcmp(sub_umbrella_name, deps[j]->umbrella_name) == 0){
			/*
			 * TODO: can't this logic (here and in our caller) hang
		         * if there is a circular loop?  And is that even
			 * possible to create?  See comments in our caller.
			 */
			if(deps[j]->sub_images_setup == FALSE)
			    return(FALSE);
			max_libraries += 1 + deps[j]->nsub_images;
		    }
		}
		break;
	    case LC_SUB_LIBRARY:
		lsub = (struct sub_library_command *)lc;
		sub_library_name = (char *)lsub + lsub->sub_library.offset;
		for(j = 0; j < p->ndependent_images; j++){
		    if(deps[j]->library_name != NULL &&
		       strcmp(sub_library_name, deps[j]->library_name) == 0){
			/*
			 * TODO: can't this logic (here and in our caller) hang
		         * if there is a circular loop?  And is that even
			 * possible to create?  See comments in our caller.
			 */
			if(deps[j]->sub_images_setup == FALSE)
			    return(FALSE);
			max_libraries += 1 + deps[j]->nsub_images;
		    }
		}
		break;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}

	/*
	 * Allocate the sub-images array of pointers to dynamic libraries that
	 * make up this "primary" library.  Allocate enough to handle the max.
	 */
	max_libraries += p->ndependent_images;
	p->sub_images = allocate(max_libraries *
				 sizeof(struct dynamic_library *));
	n = 0;

	/*
	 * First add the dependent images which are sub-frameworks of this
	 * image to the sub images list.
	 */
	if(p->umbrella_name != NULL){
	    for(i = 0; i < p->ndependent_images; i++){
		mh = (struct mach_header *)(deps[i]->definition_obj->obj_addr);
		load_commands = (struct load_command *)((char *)mh +
						    sizeof(struct mach_header));
		lc = load_commands;
		for(j = 0; j < mh->ncmds; j++){
		    if(lc->cmd == LC_SUB_FRAMEWORK){
			sub = (struct sub_framework_command *)lc;
			sub_framework_name = (char *)sub + sub->umbrella.offset;
			if(p->umbrella_name != NULL &&
			   strcmp(sub_framework_name, p->umbrella_name) == 0){
			    p->sub_images[n++] = deps[i];
			    if(p->force_weak_dylib == TRUE)
				deps[i]->force_weak_dylib = TRUE;
			    goto next_dep;
			}
		    }
		    lc = (struct load_command *)((char *)lc + lc->cmdsize);
		}
next_dep:	;
	    }
	}

	/*
	 * Second add the sub-umbrella's and sub-library's sub-images to the
	 * sub images list.
	 */
	mh = (struct mach_header *)p->definition_obj->obj_addr;
	load_commands = (struct load_command *)((char *)mh +
						sizeof(struct mach_header));
	lc = load_commands;
	for(i = 0; i < mh->ncmds; i++){
	    switch(lc->cmd){
	    case LC_SUB_UMBRELLA:
		usub = (struct sub_umbrella_command *)lc;
		sub_umbrella_name = (char *)usub + usub->sub_umbrella.offset;
		for(j = 0; j < p->ndependent_images; j++){
		    if(deps[j]->umbrella_name != NULL &&
		       strcmp(sub_umbrella_name, deps[j]->umbrella_name) == 0){

			/* make sure this image is not already on the list */
			found = FALSE;
			for(l = 0; l < n; l++){
			    if(p->sub_images[l] == deps[j]){
				found = TRUE;
				break;
			    }
			}
			if(found == FALSE){
			    p->sub_images[n++] = deps[j];
			    if(p->force_weak_dylib == TRUE)
				deps[j]->force_weak_dylib = TRUE;
			}

			for(k = 0; k < deps[j]->nsub_images; k++){
			    /* make sure this image is not already on the list*/
			    found = FALSE;
			    for(l = 0; l < n; l++){
				if(p->sub_images[l] == deps[j]->sub_images[k]){
				    found = TRUE;
				    break;
				}
			    }
			    if(found == FALSE)
				p->sub_images[n++] = deps[j]->sub_images[k];
			}
		    }
		}
		break;
	    case LC_SUB_LIBRARY:
		lsub = (struct sub_library_command *)lc;
		sub_library_name = (char *)lsub + lsub->sub_library.offset;
		for(j = 0; j < p->ndependent_images; j++){
		    if(deps[j]->library_name != NULL &&
		       strcmp(sub_library_name, deps[j]->library_name) == 0){

			/* make sure this image is not already on the list */
			found = FALSE;
			for(l = 0; l < n; l++){
			    if(p->sub_images[l] == deps[j]){
				found = TRUE;
				break;
			    }
			}
			if(found == FALSE)
			    p->sub_images[n++] = deps[j];

			for(k = 0; k < deps[j]->nsub_images; k++){
			    /* make sure this image is not already on the list*/
			    found = FALSE;
			    for(l = 0; l < n; l++){
				if(p->sub_images[l] == deps[j]->sub_images[k]){
				    found = TRUE;
				    break;
				}
			    }
			    if(found == FALSE)
				p->sub_images[n++] = deps[j]->sub_images[k];
			}
		    }
		}
		break;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	p->nsub_images = n;
	p->sub_images_setup = TRUE;
	return(TRUE);
}

/*
 * prebinding_check_for_dylib_override_symbols() checks to make sure that no
 * symbols are being overridden in a dependent library if prebinding is to
 * be done.  If a symbol is overridden prebinding is disabled and a warning
 * is printed.
 */
__private_extern__
void
prebinding_check_for_dylib_override_symbols(
void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	if(prebinding == TRUE){
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
		merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)
			continue;
		    check_dylibs_for_definition(merged_symbol, TRUE, FALSE);
		}
	    }
	}
}

/*
 * twolevel_namespace_check_for_unused_dylib_symbols() checks dylibs to make
 * sure the user sees a warning about unused symbols defined in a dylib that
 * where another symbol of the same name is being used from some other object
 * or dynamic library.
 */
__private_extern__
void
twolevel_namespace_check_for_unused_dylib_symbols(
void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)
		    continue;
		check_dylibs_for_definition(merged_symbol, FALSE, TRUE);
	    }
	}
}

/*
 * check_dylibs_for_definition() checks to see if the merged symbol is defined
 * in any of the dependent dynamic shared libraries.
 *
 * If prebind_check is TRUE and the symbol is defined in a dylib and also
 * refernced a warning is printed, prebinding is disabled and the symbols are
 * traced.
 *
 * If twolevel_namespace_check is TRUE and the symbol is defined in a dylib the
 * a warning about an unused defintion is printed and the symbols are traced.
 */
static
void
check_dylibs_for_definition(
struct merged_symbol *merged_symbol,
enum bool prebind_check,
enum bool twolevel_namespace_check)
{
    struct dynamic_library *p;
    struct dylib_table_of_contents *toc;
    static enum bool printed_override, printed_unused, merged_symbol_printed;

    printed_override = FALSE;
    printed_unused = FALSE;
    merged_symbol_printed = FALSE;

	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type == DYLIB){
		/*
		 * If this symbol is defined in the this dylib it is not an
		 * overridden symbol.
		 */
		if(merged_symbol->defined_in_dylib == TRUE &&
		   p->definition_obj->file_name ==
		   merged_symbol->definition_object->file_name)
		    continue;

		bsearch_strings = p->strings;
		bsearch_symbols = p->symbols;

		toc = bsearch(merged_symbol->nlist.n_un.n_name,
			      p->tocs, p->definition_obj->dysymtab->ntoc,
			      sizeof(struct dylib_table_of_contents),
			      (int (*)(const void *, const void *))
				dylib_bsearch);
		if(toc != NULL){
		    if(prebind_check == TRUE){
			/*
			 * There is a module that defineds this symbol.  If this
			 * symbol is also referenced by the libraries then we
			 * can't prebind.
			 */
			if(check_dylibs_for_reference(merged_symbol) == TRUE){
			    if(printed_override == FALSE){
				if(ld_trace_prebinding_disabled == TRUE)
				    ld_trace("[Logging for XBS] "
					     "prebinding disabled for %s because "
					     "of symbols overridden in dependent "
					     "dynamic shared libraries\n",
					     final_output != NULL ? final_output :
					     outputfile);
				warning("prebinding disabled because of symbols"
				   " overridden in dependent dynamic shared "
				   "libraries:");
				printed_override = TRUE;
			    }
			    trace_merged_symbol(merged_symbol);
			    printf("%s(%s) definition of %s\n",
				   p->definition_obj->file_name,
				   p->strings +
					p->mods[toc->module_index].module_name,
				   merged_symbol->nlist.n_un.n_name);
			    prebinding = FALSE;
			}
		    }
		    if(twolevel_namespace_check == TRUE){
			/*
			 * If this module was loaded then warnings about
			 * multiply defined symbols in it have previously been
			 * flagged.
			 */
			if(is_dylib_module_loaded(p->mods + toc->module_index)
			   == TRUE)
			    continue;
			if(printed_unused == FALSE){
			    if(multiply_defined_unused_flag ==
			       MULTIPLY_DEFINED_ERROR)
				error("unused multiple definitions of symbol "
				      "%s", merged_symbol->nlist.n_un.n_name);
			    else
				warning("unused multiple definitions of symbol "
					"%s", merged_symbol->nlist.n_un.n_name);
			    printed_unused = TRUE;
			}
			/*
			 * First print the symbol that is being used if not
			 * already printed.
			 */
			if(merged_symbol_printed == FALSE){
			    trace_merged_symbol(merged_symbol);
			    merged_symbol_printed = TRUE;
			}
			printf("%s(%s) unused definition of %s\n",
			       p->definition_obj->file_name,
			       p->strings +
				    p->mods[toc->module_index].module_name,
			       merged_symbol->nlist.n_un.n_name);
		    }
		}
	    }
	}
}

/*
 * check_dylibs_for_reference() checks the dependent dynamic shared libraries
 * to see if the specified merged symbol is referenced in a flat namespace
 * library.  If it is TRUE is returned else FALSE is returned.
 */
static
enum bool
check_dylibs_for_reference(
struct merged_symbol *merged_symbol)
{
    struct dynamic_library *p;
    struct dylib_table_of_contents *toc;
    struct nlist *symbol;
    struct dylib_reference *dylib_references;
    unsigned long i, symbol_index;
    struct mach_header *mh;

	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type == DYLIB){
		/*
		 * If we are not building an output file that forces flat name
		 * space and this library is a two-level namespace library then
		 * all references to undefined symbols are to specific
		 * libraries and can't be overridden.
		 */
		mh = (struct mach_header *)(p->definition_obj->obj_addr);
		if(force_flat_namespace == FALSE &&
		   (mh->flags & MH_TWOLEVEL) == MH_TWOLEVEL)
		    continue;
		/*
		 * See if this symbol appears at all (defined or undefined)
		 * in this library.
		 */
		bsearch_strings = p->strings;
		bsearch_symbols = p->symbols;
		toc = bsearch(merged_symbol->nlist.n_un.n_name,
			      p->tocs, p->definition_obj->dysymtab->ntoc,
			      sizeof(struct dylib_table_of_contents),
			      (int (*)(const void *, const void *))
				dylib_bsearch);
		if(toc != NULL){
		    symbol_index = toc->symbol_index;
		}
		else{
		    symbol = bsearch(merged_symbol->nlist.n_un.n_name,
			     bsearch_symbols +
				p->definition_obj->dysymtab->iundefsym,
			     p->definition_obj->dysymtab->nundefsym,
			     sizeof(struct nlist),
			     (int (*)(const void *,const void *))nlist_bsearch);
		    if(symbol == NULL)
			continue;
		    symbol_index = symbol - bsearch_symbols;
		}
		/*
		 * The symbol appears in this library.  Now see if it is
		 * referenced by a module in the library.
		 */
		dylib_references = (struct dylib_reference *)
		    (p->definition_obj->obj_addr +
		     p->definition_obj->dysymtab->extrefsymoff);
		for(i = 0; i < p->definition_obj->dysymtab->nextrefsyms; i++){
		    if(dylib_references[i].isym == symbol_index &&
		       (dylib_references[i].flags ==
			    REFERENCE_FLAG_UNDEFINED_NON_LAZY ||
		        dylib_references[i].flags ==
			    REFERENCE_FLAG_UNDEFINED_LAZY))
		    return(TRUE);
		}
	    }
	}
	return(FALSE);
}

/*
 * open_dylib() attempts to open the dynamic library specified by the pointer
 * to the dynamic_library structure.  This is only called for dependent
 * libraries found in the object loaded or in other dynamic libraries.  Since
 * this is only used for undefined checking and prebinding it is not fatal if
 * the library can't be opened.  But if it can't be opened and undefined
 * checking or prebinding is to be done a warning is issued.
 */
static
enum bool
open_dylib(
struct dynamic_library *p)
{
    unsigned long i, file_size;
    char *colon, *file_name, *dylib_name, *file_addr;
    int fd;
    struct stat stat_buf;
    kern_return_t r;
    struct fat_header *fat_header;
    struct mach_header *mh;
    struct load_command *lc;
    struct dylib_command *dl;

	/*
	 * First see if there is a -dylib_file option for this dylib and if so
	 * use that as the file name to open for the dylib.
	 */
	for(i = 0; i < ndylib_files; i++){
	    colon = strchr(dylib_files[i], ':');
	    *colon = '\0';
	    if(strcmp(p->dylib_name, dylib_files[i]) == 0){
		p->dylib_file = dylib_files[i];
		p->file_name = colon + 1;
		*colon = ':';
		break;
	    }
	    *colon = ':';
	}
#if 0
	/*
	 * It has been determined that this warning is distracting.  Even though
	 * the user may want to be alerted that this library is being included
	 * indirectly.  It has been determined this rarely a problem.  So when
	 * it is a problem we will just hope the user is smart enought to figure
	 * it out without any clue.
	 */
	if(p->dylib_file == NULL &&
	   (undefined_flag != UNDEFINED_SUPPRESS ||
	    prebinding == TRUE)){
	    if(p->definition_obj->ar_hdr != NULL)
		warning("using file: %s for reference to dynamic shared library"
			" from: %s(%.*s) because no -dylib_file specified",
			p->dylib_name, p->definition_obj->file_name,
			(int)p->definition_obj->ar_name_size,
			p->definition_obj->ar_name);

	    else
		warning("using file: %s for reference to dynamic shared library"
			" from: %s because no -dylib_file specified",
			p->dylib_name, p->definition_obj->file_name);
	}
#endif

	/*
	 * Try to open the dynamic library.  If it can't be opened it is only
	 * a warning if undefined checking or prebinding is to be done.  Once
	 * the file is opened sucessfully then any futher problems are treated
	 * as errors.
	 */
	if(p->dylib_file != NULL)
	    file_name = p->file_name;
	else{
	    if(executable_path != NULL &&
	       strncmp(p->dylib_name, "@executable_path",
                       sizeof("@executable_path") - 1) == 0){
		file_name = mkstr(executable_path,
				  p->dylib_name + sizeof("@executable_path") -1,
				  NULL);
	    }
	    else{
		file_name = p->dylib_name;
	    }
	}
	if((fd = open(file_name, O_RDONLY, 0)) == -1){
	    if(undefined_flag != UNDEFINED_SUPPRESS){
		system_warning("can't open dynamic library: %s referenced "
		    "from: %s (checking for undefined symbols may be affected)",
		    file_name, p->definition_obj->file_name);
	    }
	    return(FALSE);
	}

	/*
	 * Now that the file_name has been determined and opened get it into
	 * memory by mapping it.
	 */
	if(fstat(fd, &stat_buf) == -1){
	    system_error("can't stat dynamic library file: %s", file_name);
	    close(fd);
	    return(FALSE);
	}
	file_size = stat_buf.st_size;
	/*
	 * For some reason mapping files with zero size fails so it has to
	 * be handled specially.
	 */
	if(file_size == 0){
	    error("file: %s is empty (not a dynamic library)", file_name);
	    close(fd);
	    return(FALSE);
	}
	if((r = map_fd((int)fd, (vm_offset_t)0, (vm_offset_t *)&file_addr,
	    (boolean_t)TRUE, (vm_size_t)file_size)) != KERN_SUCCESS){
	    close(fd);
	    mach_fatal(r, "can't map dynamic library file: %s", file_name);
	}
	close(fd);

	/*
	 * This file must be a dynamic library (it can be fat too).
	 */
	cur_obj = NULL;
	if(sizeof(struct fat_header) > file_size){
	    error("truncated or malformed dynamic library file: %s (file size "
		  "too small to be a dynamic library)", file_name);
	    return(FALSE);
	}
	fat_header = (struct fat_header *)file_addr;
#ifdef __BIG_ENDIAN__
	if(fat_header->magic == FAT_MAGIC)
#endif /* __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
	if(fat_header->magic == SWAP_LONG(FAT_MAGIC))
#endif /* __LITTLE_ENDIAN__ */
	{
	    pass1_fat(file_name, file_addr, file_size, FALSE, TRUE, FALSE,
		      FALSE);
	}
	else{
	    pass1_object(file_name, file_addr, file_size, FALSE, FALSE, TRUE,
			 FALSE, FALSE);
	}
	if(errors)
	    return(FALSE);
	if(cur_obj == NULL || cur_obj->dylib == FALSE)
	    return(FALSE);

	dylib_name = NULL;
	mh = (struct mach_header *)cur_obj->obj_addr;
	lc = (struct load_command *)((char *)cur_obj->obj_addr +
				     sizeof(struct mach_header));
	for(i = 0; i < mh->ncmds; i++){
	    if(lc->cmd == LC_ID_DYLIB){
		dl = (struct dylib_command *)lc;
		dylib_name = (char *)dl + dl->dylib.name.offset;
#ifdef notdef
		if(strcmp(p->dylib_name, dylib_name) != 0){
		    error("wrong dynamic library: %s (the name in the "
			  "LC_ID_DYLIB command (%s) is not %s)", file_name,
			  dylib_name, p->dylib_name);
		}
#endif
		p->dl = dl;
		p->definition_obj = cur_obj;
		break;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	return(TRUE);
}

/*
 * set_sub_frameworks_ordinals() sets the library ordinal for other libraries
 * that are sub-frameworks of the specified dynamic library.  If any ordinals
 * are set then TRUE is returned else FALSE is returned.
 */
static
enum bool
set_sub_frameworks_ordinals(
struct dynamic_library *umbrella)
{
    enum bool set_some_ordinals;
    struct dynamic_library *p;
    unsigned long i;
    struct mach_header *mh;
    struct load_command *lc;
    struct sub_framework_command *sub;

	set_some_ordinals = FALSE;
	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type != DYLIB)
		continue;
	    /*
	     * If this library's ordinal is not set the see if it has an
	     * LC_SUB_FRAMEWORK command with the same name as the umbrella
	     * library.
	     */
	    if(p->definition_obj->library_ordinal == 0){
		mh = (struct mach_header *)p->definition_obj->obj_addr;
		lc = (struct load_command *)
			((char *)p->definition_obj->obj_addr +
				sizeof(struct mach_header));
		for(i = 0; i < mh->ncmds; i++){
		    if(lc->cmd == LC_SUB_FRAMEWORK){
			sub = (struct sub_framework_command *)lc;
			if(strcmp((char *)sub + sub->umbrella.offset,
				  umbrella->umbrella_name) == 0){
			    p->definition_obj->library_ordinal =
				umbrella->definition_obj->library_ordinal;
			    set_isub_image(p, p);
			    set_some_ordinals = TRUE;
			    break;
			}
		    }
		    lc = (struct load_command *)((char *)lc + lc->cmdsize);
		}
	    }
	}
	return(set_some_ordinals);
}

/*
 * set_sub_umbrella_sub_library_ordinal() sets the library ordinal for the
 * specified dynamic library if it is a sub-umbrella or a sub-library of another
 * dynamic library who's library ordinal is set.  If the ordinal is set then
 * TRUE is returned else FALSE is returned.
 */
static
enum bool
set_sub_umbrella_sub_library_ordinal(
struct dynamic_library *sub)
{
    struct dynamic_library *p;
    unsigned long i;
    struct mach_header *mh;
    struct load_command *lc;
    struct sub_umbrella_command *usub;
    struct sub_library_command *lsub;

	for(p = dynamic_libs; p != NULL; p = p->next){
	    if(p->type != DYLIB)
		continue;
	    /*
	     * If this library's ordinal is set the see if it has an
	     * LC_SUB_UMBRELLA or LC_SUB_LIBRARY command with the same name as
	     * the sub library.
	     */
	    if(p->definition_obj->library_ordinal != 0){
		mh = (struct mach_header *)p->definition_obj->obj_addr;
		lc = (struct load_command *)
			((char *)p->definition_obj->obj_addr +
				sizeof(struct mach_header));
		for(i = 0; i < mh->ncmds; i++){
		    if(lc->cmd == LC_SUB_UMBRELLA){
			usub = (struct sub_umbrella_command *)lc;
			if(sub->umbrella_name != NULL &&
			   strcmp((char *)usub + usub->sub_umbrella.offset,
				  sub->umbrella_name) == 0){
			    sub->definition_obj->library_ordinal =
				p->definition_obj->library_ordinal;
			    set_isub_image(p, sub);
			    return(TRUE);
			}
		    }
		    else if(lc->cmd == LC_SUB_LIBRARY){
			lsub = (struct sub_library_command *)lc;
			if(sub->library_name != NULL &&
			   strcmp((char *)lsub + lsub->sub_library.offset,
				  sub->library_name) == 0){
			    sub->definition_obj->library_ordinal =
				p->definition_obj->library_ordinal;
			    set_isub_image(p, sub);
			    return(TRUE);
			}
		    }
		    lc = (struct load_command *)((char *)lc + lc->cmdsize);
		}
	    }
	}
	return(FALSE);
}

/*
 * set_isub_image() sets the isub_image of the specified sub dynamic library to
 * the index into the sub_images of the specified dynamic library p.
 */
static
void
set_isub_image(
struct dynamic_library *p,
struct dynamic_library *sub)
{
    struct dynamic_library *q;
    unsigned long j;

	/*
	 * Find the first library in the list with this
	 * ordinal which is the primary library.  Then walk
	 * the primary library's sub_images to figure out
	 * what the sub_image index is for this library.
	 */
	for(q = dynamic_libs; q != NULL; q = q->next){
	    if(q->type != DYLIB)
		continue;
	    if(q->definition_obj->library_ordinal ==
	       p->definition_obj->library_ordinal){
		for(j = 0; j < q->nsub_images; j++){
		    if(q->sub_images[j] == sub){
			sub->definition_obj->isub_image = j + 1;
			return;
		    }
		}
	    }
	}
}

/*
 * add_dynamic_lib() adds a library to the list of specified
 * libraries.  A specified library is a library that is referenced from the
 * object files loaded.  It does not include libraries referenced from dynamic
 * libraries.  This returns a pointer to the dynamic_library struct for the
 * dylib_name specified in the dylib_command (or a new dynamic_library struct
 * for archive types).
 */
__private_extern__
struct dynamic_library *
add_dynamic_lib(
enum library_type type,
struct dylib_command *dl,
struct object_file *definition_obj)
{
    struct dynamic_library *p, *q;
    char *dylib_name;

	dylib_name = NULL;
	/*
	 * If this is a dynamic shared library check to see if it is all ready
	 * on the list.
	 */
	if(type == DYLIB){
	    dylib_name = (char *)dl + dl->dylib.name.offset;
	    /*
	     * See if this library is already on the list of specified libraries
	     * and if so merge the two.  If only one is an LC_ID_DYLIB then use
	     * that one.
	     */
	    for(p = dynamic_libs; p != NULL; p = p->next){
		if(p->type == DYLIB &&
		   strcmp(p->dylib_name, dylib_name) == 0){
		    if(p->dl->cmd == LC_ID_DYLIB){
			/*
			 * If the new one is also a LC_ID_DYLIB use the one
			 * with the highest compatiblity number.  Else if the
			 * new one is just an LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB
			 * or LC_REEXPORT_DYLIB ignore it and use the one that
			 * is on the list which is a LC_ID_DYLIB.
			 */
			if(dl->cmd == LC_ID_DYLIB){
			   if(dl->dylib.compatibility_version >
			      p->dl->dylib.compatibility_version){
				p->dylib_name = dylib_name;
				p->dl = dl;
				p->definition_obj = definition_obj;
			    }
			}
		    }
		    else{
			if(dl->cmd == LC_ID_DYLIB){
			    p->dylib_name = dylib_name;
			    p->dl = dl;
			    p->definition_obj = definition_obj;
			}
		    }
		    return(p);
		}
	    }
	}
	/*
	 * If this library is not the lists of libraries or is an archive
	 * library.  Create a new dynamic_library struct for it.  Add it to the
	 * end of the list of specified libraries.  Then return a pointer new
	 * dynamic_library struct.
	 */
	p = allocate(sizeof(struct dynamic_library));
	memset(p, '\0', sizeof(struct dynamic_library));
	if(dynamic_libs == NULL)
	    dynamic_libs = p;
	else{
	    for(q = dynamic_libs; q->next != NULL; q = q->next)
		;
	    q->next = p;
	}

	if(type == DYLIB){
	    p->type = DYLIB;
	    p->dylib_name = dylib_name;
	    p->dl = dl;
	    p->definition_obj = definition_obj;
	    /*
	     * If the environment variable NEXT_ROOT is set then the file_name
	     * for this library prepended with NEXT_ROOT.  Basicly faking out
	     * as if a -dylib_file argument was seen.
	     */
	    if(next_root != NULL && *dylib_name == '/'){
		p->file_name = allocate(strlen(next_root) +
				      strlen(dylib_name) + 1);
		strcpy(p->file_name, next_root);
		strcat(p->file_name, dylib_name);
		p->dylib_file = p->dylib_name;
	    }
	}

	if(type == BUNDLE_LOADER){
	    p->type = BUNDLE_LOADER;
	    p->dylib_name = NULL;
	    p->dl = NULL;
	    p->definition_obj = definition_obj;
	}
	return(p);
}

/*
 * Function for bsearch() for finding a symbol name in a dylib table of
 * contents.
 */
__private_extern__
int
dylib_bsearch(
const char *symbol_name,
const struct dylib_table_of_contents *toc)
{
	return(strcmp(symbol_name,
		      bsearch_strings +
		      bsearch_symbols[toc->symbol_index].n_un.n_strx));
}

/*
 * Function for bsearch() for finding a symbol name in the sorted list of
 * undefined symbols.
 */
static
int
nlist_bsearch(
const char *symbol_name,
const struct nlist *symbol)
{
	return(strcmp(symbol_name, bsearch_strings + symbol->n_un.n_strx));
}
#endif /* !defined(RLD) */

/*
 * Function for bsearch() for finding a symbol name in a ranlib table of
 * contents.
 */
static
int
ranlib_bsearch(
const char *symbol_name,
const struct ranlib *ran)
{
	return(strcmp(symbol_name, bsearch_strings + ran->ran_un.ran_strx));
}
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

/*
 * merge() merges all the global information from the cur_obj into the merged
 * data structures for the output object file to be built from.
 */
__private_extern__
void
merge(
enum bool dylib_only,
enum bool bundle_loader,
enum bool force_weak)
{
    unsigned long previous_errors;

	/*
	 * save the previous errors and only return out of here if something
	 * we do in here gets an error.
	 */
	previous_errors = errors;
	errors = 0;

	/* print the object file name if tracing */
	if(trace){
	    print_obj_name(cur_obj);
	    print("\n");
	}

	/* check the header and load commands of the object file */
	check_cur_obj(dylib_only, bundle_loader);
	if(errors)
	    goto merge_return;

	/* if this was called to via an open_dylib() we are done */
	if(dylib_only == TRUE)
	    goto merge_return;

#ifndef RLD
	/*
	 * if this is the -bundle_loader argument then put it on the list
	 * of dynamic libraries where it will be searched.
	 */
	if(bundle_loader){
	    /* If this object file has no symbols then don't add it */
	    if(cur_obj->symtab != NULL)
		(void)add_dynamic_lib(BUNDLE_LOADER, NULL, cur_obj);
	    goto merge_return;
	}
#endif /* !defined(RLD) */

	/* if this object has any fixed VM shared library stuff merge it */
	if(cur_obj->fvmlib_stuff){
#ifndef RLD
	    merge_fvmlibs();
	    if(errors)
		goto merge_return;
#else /* defined(RLD) */
	    if(cur_obj != base_obj){
		error_with_cur_obj("can't dynamicly load fixed VM shared "
				   "library");
		goto merge_return;
	    }
#endif /* defined(RLD) */
	}

	/* if this object has any dynamic shared library stuff merge it */
	if(cur_obj->dylib_stuff){
#ifndef RLD
	    merge_dylibs(force_weak);
	    if(errors)
		goto merge_return;
	    if(cur_obj->dylib)
		goto merge_return;
	    if(cur_obj->dylinker)
		goto merge_return;
#else /* defined(RLD) */
	    if(cur_obj != base_obj){
		error_with_cur_obj("can't used dynamic libraries or dynamic "
		    "linker with rld based interfaces");
		goto merge_return;
	    }
#endif /* defined(RLD) */
	}

#ifndef KLD
	/* read the DWARF information if any */
	if(strip_level < STRIP_DEBUG)
	  read_dwarf_info();
#endif

	/* merged it's sections */
	merge_sections();
	if(errors)
	    goto merge_return;

	/* merged it's symbols */
	merge_symbols();
	if(errors)
	    goto merge_return;

merge_return:
	errors += previous_errors;
}

/*
 * check_cur_obj() checks to see if the cur_obj object file is really an object
 * file and that all the offset and sizes in the headers are within the memory
 * the object file is mapped in.  This allows the rest of the code in the link
 * editor to use the offsets and sizes in the headers without bounds checking.
 *
 * Since this is making a pass through the headers a number of things are filled
 * in in the object structrure for this object file including: the symtab field,
 * the dysymtab field, the section_maps and nsection_maps fields (this routine
 * allocates the section_map structures and fills them in too), the fvmlib_
 * stuff field is set if any SG_FVMLIB segments or LC_LOADFVMLIB commands are
 * seen and the dylib_stuff field is set if the file is a MH_DYLIB or
 * MH_DYLIB_STUB type and has a LC_ID_DYLIB command or a LC_LOAD_DYLIB,
 * LC_LOAD_WEAK_DLIB or LC_REEXPORT_DYLIB command is seen.
 */
static
void
check_cur_obj(
enum bool dylib_only,
enum bool bundle_loader)
{
    unsigned long i, j, section_type;
    uint32_t magic;
    struct mach_header *mh;
    struct mach_header_64 *mh64;
    struct load_command l, *lc, *load_commands;
    struct segment_command *sg;
    struct section *s;
    struct symtab_command *st;
    struct dysymtab_command *dyst;
    struct routines_command *rc;
    struct symseg_command *ss;
    struct fvmlib_command *fl;
    struct dylib_command *dl, *dlid;
    struct dylinker_command *dyld, *dyldid;
    struct sub_framework_command *sub;
    struct sub_umbrella_command *usub;
    struct sub_library_command *lsub;
    struct sub_client_command *csub;
    struct twolevel_hints_command *hints;
    struct prebind_cksum_command *cs;
    struct uuid_command *uuid;
    char *fvmlib_name, *dylib_name, *dylib_id_name, *dylinker_name,
	 *umbrella_name, *sub_umbrella_name, *sub_library_name,*sub_client_name;
    cpu_subtype_t new_cpusubtype;
    const char *new_arch, *prev_arch;
    const struct arch_flag *family_arch_flag;
    uint32_t *indirect_symtab;
    struct dylib_table_of_contents *tocs;
    struct dylib_module *mods;
    struct dylib_reference *refs;
#ifndef RLD
    enum bool is_framework, allowable_client;
    char *short_name, *has_suffix, *this_client_name;
#endif

    static const struct symtab_command empty_symtab = { 0 };
    static const struct dysymtab_command empty_dysymtab = { 0 };

#ifdef KLD
	memset(&output_uuid_info, '\0', sizeof(struct uuid_info));
#endif
	/* check to see the mach_header is valid */
	if(sizeof(struct mach_header) > cur_obj->obj_size){
	    error_with_cur_obj("truncated or malformed object (mach header "
			       "extends past the end of the file)");
	    return;
	}

	magic = *((uint32_t *)cur_obj->obj_addr);

	if(magic ==  MH_MAGIC ||
	   magic == SWAP_LONG(MH_MAGIC)){
	  mh = (struct mach_header *)cur_obj->obj_addr;
	  if(magic == MH_MAGIC){
	    cur_obj->swapped = FALSE;
	  }
	  else{
	    cur_obj->swapped = TRUE;
	    swap_mach_header(mh, host_byte_sex);
	  }
	}
	else if(cur_obj->obj_size >= sizeof(struct mach_header_64) &&
		(magic == MH_MAGIC_64 ||
		 magic == SWAP_LONG(MH_MAGIC_64))){

	  mh64 = (struct mach_header_64 *)cur_obj->obj_addr;
	  if(magic == MH_MAGIC_64){
	    cur_obj->swapped = FALSE;
	  }
	  else{
	    cur_obj->swapped = TRUE;
        swap_mach_header_64(mh64, host_byte_sex);
	  }

	  /* If no architecture has been explicitly given, and
	   *  this is the first object seen, set up arch_flag
	   *  without interrogating the object file further
	   */
	  if(!arch_flag.cputype) {
		family_arch_flag = get_arch_family_from_cputype(mh64->cputype);
		if(family_arch_flag == NULL){
		    error_with_cur_obj("cputype (%d) unknown (file not loaded)",
			 mh64->cputype);
		    return;
		}
		arch_flag.cputype = mh64->cputype;
		if(force_cpusubtype_ALL == TRUE)
		    arch_flag.cpusubtype = family_arch_flag->cpusubtype;
		else
		    arch_flag.cpusubtype = mh64->cpusubtype;
	  }

	  return;
	}
	else{
	  if(no_arch_warnings != TRUE)
	    error_with_cur_obj("bad magic number (not a Mach-O file)");
	  return;
	}
	if(mh->cputype != 0){
	    if(target_byte_sex == UNKNOWN_BYTE_SEX){
		if(cur_obj->swapped == TRUE)
		    target_byte_sex = host_byte_sex == BIG_ENDIAN_BYTE_SEX ?
    			LITTLE_ENDIAN_BYTE_SEX : BIG_ENDIAN_BYTE_SEX;
		else
		    target_byte_sex = host_byte_sex;
	    }
	    /*
	     * If for this cputype we are to always output the ALL cpusubtype
	     * then set force_cpusubtype_ALL.
	     */
	    if(force_cpusubtype_ALL_for_cputype(mh->cputype) == TRUE)
		force_cpusubtype_ALL = TRUE;
	    /*
	     * If we have previous loaded something or an -arch flag was
	     * specified something so make sure the cputype of this object
	     * matches (the case the architecture has been previous selected).
	     */
	    if(arch_flag.cputype){
		if(arch_flag.cputype != mh->cputype){
		    new_arch = get_arch_name_from_types(mh->cputype,
						        mh->cpusubtype);
		    prev_arch = get_arch_name_from_types(arch_flag.cputype,
						         arch_flag.cpusubtype);
		    if(no_arch_warnings == TRUE)
			return;
		    if(arch_flag.name != NULL){
			if(arch_errors_fatal == TRUE){
			    error_with_cur_obj("cputype (%d, architecture %s) "
				"does not match cputype (%d) for specified "
				"-arch flag: %s", mh->cputype, new_arch,
				arch_flag.cputype, arch_flag.name);
			}
			else
			    warning_with_cur_obj("cputype (%d, architecture %s)"
				" does not match cputype (%d) for specified "
				"-arch flag: %s (file not loaded)", mh->cputype,
				 new_arch, arch_flag.cputype, arch_flag.name);
		    }
		    else{
			if(arch_errors_fatal == TRUE){
			    error_with_cur_obj("cputype (%d, architecture %s) "
				"does not match cputype (%d architecture %s) "
				"of objects files previously loaded",
				mh->cputype, new_arch, arch_flag.cputype,
				prev_arch);
			}
			else
			    warning_with_cur_obj("cputype (%d, architecture %s)"
				" does not match cputype (%d architecture %s) "
				"of objects files previously loaded (file not "
				"loaded)", mh->cputype, new_arch,
				arch_flag.cputype,prev_arch);
		    }
		    return;
		}
		/* deal with combining this cpusubtype and what is current */
		if(force_cpusubtype_ALL == FALSE){
		    new_cpusubtype = cpusubtype_combine(arch_flag.cputype,
					  arch_flag.cpusubtype, mh->cpusubtype);
		    if(new_cpusubtype == -1){
			new_arch = get_arch_name_from_types(mh->cputype,
							    mh->cpusubtype);
			prev_arch = get_arch_name_from_types(arch_flag.cputype,
							 arch_flag.cpusubtype);
			if(no_arch_warnings == TRUE)
			    return;
			if(arch_flag.name != NULL){
			    if(arch_errors_fatal == TRUE){
				error_with_cur_obj("cpusubtype (%d, "
				    "architecture %s) does not combine with "
				    "cpusubtype (%d) for specified -arch flag: "
				    "%s and -force_cpusubtype_ALL not "
				    "specified", mh->cpusubtype, new_arch,
				    arch_flag.cpusubtype, arch_flag.name);
			    }
			    else
				warning_with_cur_obj("cpusubtype (%d, "
				    "architecture %s) does not combine with "
				    "cpusubtype (%d) for specified -arch flag: "
				    "%s and -force_cpusubtype_ALL not specified"
				    " (file not loaded)", mh->cpusubtype,
				    new_arch, arch_flag.cpusubtype,
				    arch_flag.name);
			}
			else{
			    if(arch_errors_fatal == TRUE){
				error_with_cur_obj("cpusubtype (%d, "
				    "architecture %s) does not combine with "
				    "cpusubtype (%d, architecture %s) of "
				    "objects files previously loaded and "
				    "-force_cpusubtype_ALL not specified",
				    mh->cpusubtype, new_arch,
				    arch_flag.cpusubtype, prev_arch);
			    }
			    else
				warning_with_cur_obj("cpusubtype (%d, "
				    "architecture %s) does not combine with "
				    "cpusubtype (%d, architecture %s) of "
				    "objects files previously loaded and "
				    "-force_cpusubtype_ALL not specified (file "
				    "not loaded)", mh->cpusubtype, new_arch,
				    arch_flag.cpusubtype, prev_arch);
			}
			return;
		    }
		    else{
			/*
			 * No -force_cpusubtype_ALL is specified if an -arch
			 * flag for a specific implementation of an architecture
			 * was specified then the resulting cpusubtype will be
			 * for that specific implementation of that architecture
			 * and all cpusubtypes must combine with the cpusubtype
			 * for the -arch flag to the cpusubtype for the -arch
			 * flag else an error must be flaged.
			 */
			if(specific_arch_flag == TRUE){
			    if(arch_flag.cpusubtype != new_cpusubtype){
			      new_arch = get_arch_name_from_types(mh->cputype,
								mh->cpusubtype);
			      warning_with_cur_obj("cpusubtype (%d, "
				"architecture %s) does not combine with "
				"cpusubtype (%d) for specified -arch flag: %s "
				"and -force_cpusubtype_ALL not specified (file "
				"not loaded)", mh->cpusubtype, new_arch,
				arch_flag.cpusubtype, arch_flag.name);
			    }
			}
			else if(mh->filetype != MH_DYLIB &&
				bundle_loader == FALSE)
			    arch_flag.cpusubtype = new_cpusubtype;
		    }
		}
		else{ /* force_cpusubtype_ALL == TRUE */
		    family_arch_flag =get_arch_family_from_cputype(mh->cputype);
		    if(family_arch_flag != NULL)
			arch_flag.cpusubtype = family_arch_flag->cpusubtype;
		    else{
			warning_with_cur_obj("cputype (%d) unknown (file not "
			    "loaded)", mh->cputype);
			return;
		    }
		}
	    }
	    /*
	     * Nothing has been loaded yet and no -arch flag has been specified
	     * so use this object to set what is to be loaded (the case the
	     * architecture has not been selected).
	     */
	    else{
		family_arch_flag = get_arch_family_from_cputype(mh->cputype);
		if(family_arch_flag == NULL){
		    error_with_cur_obj("cputype (%d) unknown (file not loaded)",
			 mh->cputype);
		    return;
		}
		arch_flag.cputype = mh->cputype;
		if(force_cpusubtype_ALL == TRUE)
		    arch_flag.cpusubtype = family_arch_flag->cpusubtype;
		else
		    arch_flag.cpusubtype = mh->cpusubtype;
		if(target_byte_sex != get_byte_sex_from_flag(family_arch_flag))
		    error_with_cur_obj("wrong bytesex for cputype (%d) for "
			"-arch %s (bad object or this program out of sync with "
			"get_arch_family_from_cputype() and get_byte_sex_"
			"from_flag())", arch_flag.cputype,
			family_arch_flag->name);
#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
		/*
		 * Pick up the Mac OS X deployment target if not done already.
		 */
		if(macosx_deployment_target.major == 0)
		    get_macosx_deployment_target(&macosx_deployment_target);
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */
	    }
	}
	if(mh->sizeofcmds + sizeof(struct mach_header) > cur_obj->obj_size){
	    error_with_cur_obj("truncated or malformed object (load commands "
			       "extend past the end of the file)");
	    return;
	}
	if((mh->flags & MH_INCRLINK) != 0){
	    error_with_cur_obj("was the output of an incremental link, can't "
			       "be link edited again");
	    return;
	}
	if((mh->flags & MH_DYLDLINK) != 0 &&
	   (mh->filetype != MH_DYLIB &&
	    mh->filetype != MH_DYLIB_STUB &&
	    mh->filetype != MH_DYLINKER) &&
	   bundle_loader == FALSE){
	    error_with_cur_obj("is input for the dynamic link editor, is not "
			       "relocatable by the static link editor again");
	    return;
	}
	/*
	 * If this is a MH_DYLIB or MH_DYLIB_STUB file then a single LC_ID_DYLIB
	 * command must be seen to identify the library.
	 */
	cur_obj->dylib = (enum bool)(mh->filetype == MH_DYLIB ||
				     mh->filetype == MH_DYLIB_STUB);
	dlid = NULL;
	dylib_id_name = NULL;
	if(cur_obj->dylib == TRUE && dynamic == FALSE){
	    error_with_cur_obj("incompatible, file is a dynamic shared library "
		  "(must specify \"-dynamic\" to be used)");
	    return;
	}
	if(dylib_only == TRUE && cur_obj->dylib == FALSE){
	    error_with_cur_obj("file is not a dynamic shared library");
	    return;
	}
	/*
	 * If this is a MH_DYLINKER file then a single LC_ID_DYLINKER command
	 * must be seen to identify the dynamic linker.
	 */
	cur_obj->dylinker = (enum bool)(mh->filetype == MH_DYLINKER);
	dyldid = NULL;
	if(cur_obj->dylinker == TRUE && dynamic == FALSE){
	    error_with_cur_obj("incompatible, file is a dynamic link editor "
		  "(must specify \"-dynamic\" to be used)");
	    return;
	}

	/* check to see that the load commands are valid */
	load_commands = (struct load_command *)((char *)cur_obj->obj_addr +
			    sizeof(struct mach_header));
	st = NULL;
	dyst = NULL;
	rc = NULL;
	sub = NULL;
	umbrella_name = NULL;
	lc = load_commands;
	for(i = 0; i < mh->ncmds; i++){
	    l = *lc;
	    if(cur_obj->swapped)
		swap_load_command(&l, host_byte_sex);
	    if(l.cmdsize % sizeof(long) != 0){
		error_with_cur_obj("load command %lu size not a multiple of "
				   "sizeof(long)", i);
		return;
	    }
	    if(l.cmdsize <= 0){
		error_with_cur_obj("load command %lu size is less than or equal"
				   " to zero", i);
		return;
	    }
	    if((char *)lc + l.cmdsize >
	       (char *)load_commands + mh->sizeofcmds){
		error_with_cur_obj("load command %lu extends past end of all "
				   "load commands", i);
		return;
	    }
	    switch(l.cmd){
	    case LC_SEGMENT:
		sg = (struct segment_command *)lc;
		if(cur_obj->swapped)
		    swap_segment_command(sg, host_byte_sex);
		if(sg->cmdsize != sizeof(struct segment_command) +
				     sg->nsects * sizeof(struct section)){
		    error_with_cur_obj("cmdsize field of load command %lu is "
				       "inconsistant for a segment command "
				       "with the number of sections it has", i);
		    return;
		}
		if(sg->flags == SG_FVMLIB){
		    if(sg->nsects != 0){
			error_with_cur_obj("SG_FVMLIB segment %.16s contains "
					   "sections and shouldn't",
					   sg->segname);
			return;
		    }
		    cur_obj->fvmlib_stuff = TRUE;
		    break;
		}
		check_size_offset(sg->filesize, sg->fileoff, sizeof(long),
				  "filesize", "fileoff", i);
		if(errors)
		    return;
		/*
		 * Segments without sections are an error to see on input except
		 * for the segments created by the link-editor (which are
		 * recreated).
		 */
		if(sg->nsects == 0){
		    if(strcmp(sg->segname, SEG_PAGEZERO) != 0 &&
		       strcmp(sg->segname, SEG_LINKEDIT) != 0 &&
		       strcmp(sg->segname, SEG_UNIXSTACK) != 0){
			error_with_cur_obj("segment %.16s contains no "
					   "sections and can't be link-edited",
					   sg->segname);
			return;
		    }
		}
		else{
		    /*
		     * Doing a reallocate here is not bad beacuse in the
		     * normal case this is an MH_OBJECT file type and has only
		     * one segment.  So this only gets done once per object.
		     */
		    cur_obj->section_maps = reallocate(cur_obj->section_maps,
					(cur_obj->nsection_maps + sg->nsects) *
					sizeof(struct section_map));
		    memset(cur_obj->section_maps + cur_obj->nsection_maps, '\0',
			   sg->nsects * sizeof(struct section_map));
		}
		s = (struct section *)
		    ((char *)sg + sizeof(struct segment_command));
		if(cur_obj->swapped)
		    swap_section(s, sg->nsects, host_byte_sex);
		for(j = 0 ; j < sg->nsects ; j++){
		    cur_obj->section_maps[cur_obj->nsection_maps++].s = s;
		    /* check to see that segment name in the section structure
		       matches the one in the segment command if this is not in
		       an MH_OBJECT filetype */
		    if(mh->filetype != MH_OBJECT &&
		       strcmp(sg->segname, s->segname) != 0){
			error_with_cur_obj("segment name %.16s of section %lu "
				"(%.16s,%.16s) in load command %lu does not "
				"match segment name %.16s", s->segname, j,
				s->segname, s->sectname, i, sg->segname);
			return;
		    }
		    /* check to see that flags (type) of this section is some
		       thing the link-editor understands */
		    section_type = s->flags & SECTION_TYPE;
		    if(section_type != S_REGULAR &&
		       section_type != S_ZEROFILL &&
		       section_type != S_CSTRING_LITERALS &&
		       section_type != S_4BYTE_LITERALS &&
		       section_type != S_8BYTE_LITERALS &&
		       section_type != S_LITERAL_POINTERS &&
		       section_type != S_NON_LAZY_SYMBOL_POINTERS &&
		       section_type != S_LAZY_SYMBOL_POINTERS &&
		       section_type != S_SYMBOL_STUBS &&
		       section_type != S_COALESCED &&
		       section_type != S_MOD_INIT_FUNC_POINTERS &&
		       section_type != S_MOD_TERM_FUNC_POINTERS &&
		       section_type != S_DTRACE_DOF){
			error_with_cur_obj("unknown flags (type) of section %lu"
					   " (%.16s,%.16s) in load command %lu",
					   j, s->segname, s->sectname, i);
			return;
		    }
		    if((s->flags & S_ATTR_DEBUG) == S_ATTR_DEBUG &&
		       section_type != S_REGULAR){
			error_with_cur_obj("malformed object, debug section %lu"
			    " (%.16s,%.16s) in load command %lu is not of type "
			    "S_REGULAR\n", j, s->segname, s->sectname, i);
			return;
		    }
		    if(dynamic == FALSE){
			if(section_type == S_NON_LAZY_SYMBOL_POINTERS ||
			   section_type == S_LAZY_SYMBOL_POINTERS ||
			   section_type == S_SYMBOL_STUBS ||
			   section_type == S_MOD_INIT_FUNC_POINTERS ||
			   section_type == S_MOD_TERM_FUNC_POINTERS){
			    error_with_cur_obj("incompatible, file contains "
				"unsupported type of section %lu (%.16s,%.16s) "
				"in load command %lu (must specify "
				"\"-dynamic\" to be used)", j, s->segname,
				s->sectname, i);
			    return;
			}
		    }
#if defined(SA_RLD) || (defined(KLD) && defined(__STATIC__))
		    if(section_type == S_NON_LAZY_SYMBOL_POINTERS ||
		       section_type == S_LAZY_SYMBOL_POINTERS ||
		       section_type == S_SYMBOL_STUBS ||
		       section_type == S_MOD_INIT_FUNC_POINTERS ||
		       section_type == S_MOD_TERM_FUNC_POINTERS){
			error_with_cur_obj("unsupported type of section %lu "
			   "(%.16s,%.16s) for %s in load command %lu", j,
			   s->segname, s->sectname, progname, i);
			return;
		    }
#endif /* defined(SA_RLD) || (defined(KLD) && defined(__STATIC__)) */
		    /* check to make sure the alignment is reasonable */
		    if(s->align > MAXSECTALIGN){
			error_with_cur_obj("align (%u) of section %lu "
			    "(%.16s,%.16s) in load command %lu greater "
			    "than maximum section alignment (%d)", s->align,
			     j, s->segname, s->sectname, i, MAXSECTALIGN);
			return;
		    }
		    /* check the size and offset of the contents if it has any*/
		    if(mh->filetype != MH_DYLIB_STUB &&
		       section_type != S_ZEROFILL){
			check_size_offset_sect(s->size, s->offset, sizeof(char),
			    "size", "offset", i, j, s->segname, s->sectname);
			if(errors)
			    return;
		    }
		    /* check the relocation entries if it can have them */
		    if(section_type == S_ZEROFILL ||
		       section_type == S_CSTRING_LITERALS ||
		       section_type == S_4BYTE_LITERALS ||
		       section_type == S_8BYTE_LITERALS ||
		       section_type == S_NON_LAZY_SYMBOL_POINTERS){
			if(s->nreloc != 0){
			    error_with_cur_obj("section %lu (%.16s,%.16s) in "
				"load command %lu has relocation entries which "
				"it shouldn't for its type (flags)", j,
				 s->segname, s->sectname, i);
			    return;
			}
		    }
		    else{
			if(s->nreloc != 0){
			    if(mh->cputype == 0 && mh->cpusubtype == 0){
				error_with_cur_obj("section %lu (%.16s,%.16s)"
				    "in load command %lu has relocation entries"
				    " but the cputype and cpusubtype for the "
				    "object are not set", j, s->segname,
				    s->sectname, i);
				return;
			    }
			}
			else{
			    check_size_offset_sect(s->nreloc * sizeof(struct
				 relocation_info), s->reloff, sizeof(long),
				 "nreloc * sizeof(struct relocation_info)",
				 "reloff", i, j, s->segname, s->sectname);
			    if(errors)
				return;
			}
		    }
		    if(section_type == S_SYMBOL_STUBS && s->reserved2 == 0){
			error_with_cur_obj("symbol stub section %lu "
			    "(%.16s,%.16s) in load command %lu, sizeof stub in "
			    "reserved2 field is zero", j, s->segname,
			    s->sectname, i);
			return;
		    }
		    s++;
		}
		break;

	    case LC_SYMTAB:
		if(st != NULL){
		    error_with_cur_obj("contains more than one LC_SYMTAB load "
				       "command");
		    return;
		}
		st = (struct symtab_command *)lc;
		if(cur_obj->swapped)
		    swap_symtab_command(st, host_byte_sex);
		if(st->cmdsize != sizeof(struct symtab_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_SYMTAB", i);
		    return;
		}
		check_size_offset(st->nsyms * sizeof(struct nlist), st->symoff,
				  sizeof(long), "nsyms * sizeof(struct nlist)",
				  "symoff", i);
		if(errors)
		    return;
		check_size_offset(st->strsize, st->stroff, sizeof(long),
				  "strsize", "stroff", i);
		if(errors)
		    return;
		cur_obj->symtab = st;
		break;

	    case LC_DYSYMTAB:
		if(dyst != NULL){
		    error_with_cur_obj("contains more than one LC_DYSYMTAB "
				       "load command");
		    return;
		}
		dyst = (struct dysymtab_command *)lc;
		if(cur_obj->swapped)
		    swap_dysymtab_command(dyst, host_byte_sex);
		if(dyst->cmdsize != sizeof(struct dysymtab_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_DYSYMTAB", i);
		    return;
		}
		check_size_offset(dyst->ntoc *
				  sizeof(struct dylib_table_of_contents),
				  dyst->tocoff, sizeof(long),
				"ntoc * sizeof(struct dylib_table_of_contents)",
				"tocoff", i);
		if(dyst->ntoc == 0 && cur_obj->dylib == TRUE &&
		   dyst->nextdefsym != 0)
		    warning_with_cur_obj("shared library has no table of "
					 "contents entries (can't resolve "
				         "symbols from it)");
		if(errors)
		    return;
		check_size_offset(dyst->nmodtab * sizeof(struct dylib_module),
				  dyst->modtaboff, sizeof(long),
				  "nmodtab * sizeof(struct dylib_module)",
				  "modtaboff", i);
		if(errors)
		    return;
		check_size_offset(dyst->nextrefsyms *
				  sizeof(struct dylib_reference),
				  dyst->extrefsymoff, sizeof(long),
				 "nextrefsyms * sizeof(struct dylib_reference)",
				 "extrefsymoff", i);
		if(errors)
		    return;
		check_size_offset(dyst->nindirectsyms * sizeof(long),
				  dyst->indirectsymoff, sizeof(long),
				  "nindirectsyms * sizeof(long)",
				  "indirectsymoff", i);
		if(errors)
		    return;
		check_size_offset(dyst->nextrel *sizeof(struct relocation_info),
				  dyst->extreloff, sizeof(long),
				  "nextrel * sizeof(struct relocation_info)",
				  "extreloff", i);
		if(errors)
		    return;
		check_size_offset(dyst->nlocrel *sizeof(struct relocation_info),
				  dyst->locreloff, sizeof(long),
				  "nlocrel * sizeof(struct relocation_info)",
				  "locreloff", i);
		if(errors)
		    return;
		cur_obj->dysymtab = dyst;
		break;

	    case LC_ROUTINES:
		if(rc != NULL){
		    error_with_cur_obj("contains more than one LC_ROUTINES "
				       "load command");
		    return;
		}
		rc = (struct routines_command *)lc;
		if(cur_obj->swapped)
		    swap_routines_command(rc, host_byte_sex);
		if(rc->cmdsize != sizeof(struct routines_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_ROUTINES", i);
		    return;
		}
		if(errors)
		    return;
		cur_obj->rc = rc;
		break;

	    case LC_SYMSEG:
		ss = (struct symseg_command *)lc;
		if(cur_obj->swapped)
		    swap_symseg_command(ss, host_byte_sex);
		if(ss->size != 0){
		    warning_with_cur_obj("contains obsolete LC_SYMSEG load "
			"command with non-zero size (produced with a pre-1.0 "
			"version of the compiler, please recompile)");
		}
		break;

	    case LC_IDFVMLIB:
		if(filetype != MH_FVMLIB){
		    error_with_cur_obj("LC_IDFVMLIB load command in object "
			"file (should not be in an input file to the link "
			"editor for output filetypes other than MH_FVMLIB)");
		    return;
		}
		cur_obj->fvmlib_stuff = TRUE;
		fl = (struct fvmlib_command *)lc;
		if(cur_obj->swapped)
		    swap_fvmlib_command(fl, host_byte_sex);
		break;

	    case LC_LOADFVMLIB:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_LOADFVMLIB load command in object "
			"file (should not be in an input file to the link "
			"editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" :
			(filetype == MH_DYLIB ? "MH_DYLIB" : "MH_DYLINKER"));
		    return;
		}
		fl = (struct fvmlib_command *)lc;
		if(cur_obj->swapped)
		    swap_fvmlib_command(fl, host_byte_sex);
		if(fl->cmdsize < sizeof(struct fvmlib_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_LOADFVMLIB", i);
		    return;
		}
		if(fl->fvmlib.name.offset >= fl->cmdsize){
		    error_with_cur_obj("name.offset of load command %lu extends"
				       " past the end of the load command", i);
		    return;
		}
		fvmlib_name = (char *)fl + fl->fvmlib.name.offset;
		for(j = 0 ; j < fl->cmdsize - fl->fvmlib.name.offset; j++){
		    if(fvmlib_name[j] == '\0')
			break;
		}
		if(j >= fl->cmdsize - fl->fvmlib.name.offset){
		    error_with_cur_obj("library name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		cur_obj->fvmlib_stuff = TRUE;
		break;

	    case LC_ID_DYLIB:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_ID_DYLIB load command in object "
			"file (should not be in an input file to the link "
			"editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" : "MH_DYLINKER");
		    return;
		}
		if(mh->filetype != MH_DYLIB && mh->filetype != MH_DYLIB_STUB){
		    error_with_cur_obj("LC_ID_DYLIB load command in non-"
			"%s filetype", mh->filetype == MH_DYLIB ? "MH_DYLIB" :
			"MH_DYLIB_STUB");
		    return;
		}
		if(dlid != NULL){
		    error_with_cur_obj("malformed object (more than one "
			"LC_ID_DYLIB load command in %s file)", mh->filetype ==
			MH_DYLIB ? "MH_DYLIB" : "MH_DYLIB_STUB");
		    return;
		}
		dl = (struct dylib_command *)lc;
		dlid = dl;
		if(cur_obj->swapped)
		    swap_dylib_command(dl, host_byte_sex);
		if(dl->cmdsize < sizeof(struct dylib_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_ID_DYLIB", i);
		    return;
		}
		if(dl->dylib.name.offset >= dl->cmdsize){
		    error_with_cur_obj("name.offset of load command %lu extends"
				       " past the end of the load command", i);
		    return;
		}
		dylib_id_name = (char *)dl + dl->dylib.name.offset;
		for(j = 0 ; j < dl->cmdsize - dl->dylib.name.offset; j++){
		    if(dylib_id_name[j] == '\0')
			break;
		}
		if(j >= dl->cmdsize - dl->dylib.name.offset){
		    error_with_cur_obj("library name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		cur_obj->dylib_stuff = TRUE;
		break;

	    case LC_LOAD_DYLIB:
	    case LC_LOAD_WEAK_DYLIB:
	    case LC_REEXPORT_DYLIB:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("%s load command in object "
			"file (should not be in an input file to the link "
			"editor for the output file type %s)",
			l.cmd == LC_LOAD_DYLIB ? "LC_LOAD_DYLIB" :
			"LC_LOAD_WEAK_DYLIB",
			filetype == MH_FVMLIB ? "MH_FVMLIB" : "MH_DYLINKER");
		    return;
		}
		dl = (struct dylib_command *)lc;
		if(cur_obj->swapped)
		    swap_dylib_command(dl, host_byte_sex);
		if(dl->cmdsize < sizeof(struct dylib_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
			"for %s", i, l.cmd == LC_LOAD_DYLIB ?  "LC_LOAD_DYLIB" :
			"LC_LOAD_WEAK_DYLIB");
		    return;
		}
		if(dl->dylib.name.offset >= dl->cmdsize){
		    error_with_cur_obj("name.offset of load command %lu extends"
				       " past the end of the load command", i);
		    return;
		}
		dylib_name = (char *)dl + dl->dylib.name.offset;
		for(j = 0 ; j < dl->cmdsize - dl->dylib.name.offset; j++){
		    if(dylib_name[j] == '\0')
			break;
		}
		if(j >= dl->cmdsize - dl->dylib.name.offset){
		    error_with_cur_obj("library name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		cur_obj->dylib_stuff = TRUE;
		cur_obj->nload_dylibs++;
		break;

	    case LC_SUB_FRAMEWORK:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_SUB_FRAMEWORK load command in "
			"object file (should not be in an input file to the "
			"link editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" : "MH_DYLINKER");
		    return;
		}
		if(mh->filetype != MH_DYLIB && mh->filetype != MH_DYLIB_STUB){
		    error_with_cur_obj("LC_SUB_FRAMEWORK load command in non-"
			"%s filetype", mh->filetype == MH_DYLIB ? "MH_DYLIB" :
			"MH_DYLIB_STUB");
		    return;
		}
		if(sub != NULL){
		    error_with_cur_obj("malformed object (more than one "
			"LC_SUB_FRAMEWORK load command in %s file)",
			mh->filetype == MH_DYLIB ? "MH_DYLIB" :
			"MH_DYLIB_STUB");
		    return;
		}
		sub = (struct sub_framework_command *)lc;
		if(cur_obj->swapped)
		    swap_sub_framework_command(sub, host_byte_sex);
		if(sub->cmdsize < sizeof(struct sub_framework_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_SUB_FRAMEWORK", i);
		    return;
		}
		if(sub->umbrella.offset >= sub->cmdsize){
		    error_with_cur_obj("umbrella.offset of load command %lu "
				"extends past the end of the load command", i);
		    return;
		}
		umbrella_name = (char *)sub + sub->umbrella.offset;
		for(j = 0 ; j < sub->cmdsize - sub->umbrella.offset; j++){
		    if(umbrella_name[j] == '\0')
			break;
		}
		if(j >= sub->cmdsize - sub->umbrella.offset){
		    error_with_cur_obj("umbrella name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		break;

	    case LC_SUB_UMBRELLA:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_SUB_UMBRELLA load command in "
			"object file (should not be in an input file to the "
			"link editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" : "MH_DYLINKER");
		    return;
		}
		if(mh->filetype != MH_DYLIB && mh->filetype != MH_DYLIB_STUB){
		    error_with_cur_obj("LC_SUB_UMBRELLA load command in non-"
			"%s filetype", mh->filetype == MH_DYLIB ? "MH_DYLIB" :
			"MH_DYLIB_STUB");
		    return;
		}
		usub = (struct sub_umbrella_command *)lc;
		if(cur_obj->swapped)
		    swap_sub_umbrella_command(usub, host_byte_sex);
		if(usub->cmdsize < sizeof(struct sub_umbrella_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_SUB_UMBRELLA", i);
		    return;
		}
		if(usub->sub_umbrella.offset >= usub->cmdsize){
		    error_with_cur_obj("sub_umbrella.offset of load command "
			"%lu extends past the end of the load command", i);
		    return;
		}
		sub_umbrella_name = (char *)usub + usub->sub_umbrella.offset;
		for(j = 0 ; j < usub->cmdsize - usub->sub_umbrella.offset; j++){
		    if(sub_umbrella_name[j] == '\0')
			break;
		}
		if(j >= usub->cmdsize - usub->sub_umbrella.offset){
		    error_with_cur_obj("sub_umbrella name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		break;

	    case LC_SUB_LIBRARY:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_SUB_LIBRARY load command in "
			"object file (should not be in an input file to the "
			"link editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" : "MH_DYLINKER");
		    return;
		}
		if(mh->filetype != MH_DYLIB && mh->filetype != MH_DYLIB_STUB){
		    error_with_cur_obj("LC_SUB_LIBRARY load command in non-"
			"%s filetype", mh->filetype == MH_DYLIB ? "MH_DYLIB" :
			"MH_DYLIB_STUB");
		    return;
		}
		lsub = (struct sub_library_command *)lc;
		if(cur_obj->swapped)
		    swap_sub_library_command(lsub, host_byte_sex);
		if(lsub->cmdsize < sizeof(struct sub_library_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_SUB_LIBRARY", i);
		    return;
		}
		if(lsub->sub_library.offset >= lsub->cmdsize){
		    error_with_cur_obj("sub_library.offset of load command "
			"%lu extends past the end of the load command", i);
		    return;
		}
		sub_library_name = (char *)lsub + lsub->sub_library.offset;
		for(j = 0 ; j < lsub->cmdsize - lsub->sub_library.offset; j++){
		    if(sub_library_name[j] == '\0')
			break;
		}
		if(j >= lsub->cmdsize - lsub->sub_library.offset){
		    error_with_cur_obj("sub_library name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		break;

	    case LC_SUB_CLIENT:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_SUB_CLIENT load command in "
			"object file (should not be in an input file to the "
			"link editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" : "MH_DYLINKER");
		    return;
		}
		if(mh->filetype != MH_DYLIB && mh->filetype != MH_DYLIB_STUB){
		    error_with_cur_obj("LC_SUB_CLIENT load command in non-"
			"%s filetype", mh->filetype == MH_DYLIB ? "MH_DYLIB" :
			"MH_DYLIB_STUB");
		    return;
		}
		csub = (struct sub_client_command *)lc;
		if(cur_obj->swapped)
		    swap_sub_client_command(csub, host_byte_sex);
		if(csub->cmdsize < sizeof(struct sub_client_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_SUB_CLIENT", i);
		    return;
		}
		if(csub->client.offset >= csub->cmdsize){
		    error_with_cur_obj("client.offset of load command %lu "
				"extends past the end of the load command", i);
		    return;
		}
		sub_client_name = (char *)csub + csub->client.offset;
		for(j = 0 ; j < csub->cmdsize - csub->client.offset; j++){
		    if(sub_client_name[j] == '\0')
			break;
		}
		if(j >= csub->cmdsize - csub->client.offset){
		    error_with_cur_obj("sub_client name of load command %lu "
				       "not null terminated", i);
		    return;
		}
		break;

	    case LC_ID_DYLINKER:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_ID_DYLINKER load command in object "
			"file (should not be in an input file to the link "
			"editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" :
			(filetype == MH_DYLIB ? "MH_DYLIB" : "MH_DYLINKER"));
		    return;
		}
		if(mh->filetype != MH_DYLINKER){
		    error_with_cur_obj("LC_ID_DYLINKER load command in non-"
			"MH_DYLINKER filetype");
		    return;
		}
		if(dyldid != NULL){
		    error_with_cur_obj("malformed object (more than one "
			"LC_ID_DYLINKER load command in MH_DYLINKER file)");
		    return;
		}
		dyld = (struct dylinker_command *)lc;
		dyldid = dyld;
		if(cur_obj->swapped)
		    swap_dylinker_command(dyld, host_byte_sex);
		if(dyld->cmdsize < sizeof(struct dylinker_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_ID_DYLINKER", i);
		    return;
		}
		if(dyld->name.offset >= dyld->cmdsize){
		    error_with_cur_obj("name.offset of load command %lu extends"
				       " past the end of the load command", i);
		    return;
		}
		dylinker_name = (char *)dyld + dyld->name.offset;
		for(j = 0 ; j < dyld->cmdsize - dyld->name.offset; j++){
		    if(dylinker_name[j] == '\0')
			break;
		}
		if(j >= dyld->cmdsize - dyld->name.offset){
		    error_with_cur_obj("dynamic linker name of load command "
			"%lu not null terminated", i);
		    return;
		}
		cur_obj->dylib_stuff = TRUE;
		break;

	    case LC_LOAD_DYLINKER:
		if(filetype == MH_FVMLIB ||
		   filetype == MH_DYLIB ||
		   filetype == MH_DYLINKER){
		    error_with_cur_obj("LC_LOAD_DYLINKER load command in object"
			" file (should not be in an input file to the link "
			"editor for the output file type %s)",
			filetype == MH_FVMLIB ? "MH_FVMLIB" :
			(filetype == MH_DYLIB ? "MH_DYLIB" : "MH_DYLINKER"));
		    return;
		}
		dyld = (struct dylinker_command *)lc;
		if(cur_obj->swapped)
		    swap_dylinker_command(dyld, host_byte_sex);
		if(dyld->cmdsize < sizeof(struct dylinker_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_LOAD_DYLINKER", i);
		    return;
		}
		if(dyld->name.offset >= dyld->cmdsize){
		    error_with_cur_obj("name.offset of load command %lu extends"
				       " past the end of the load command", i);
		    return;
		}
		dylinker_name = (char *)dyld + dyld->name.offset;
		for(j = 0 ; j < dyld->cmdsize - dyld->name.offset; j++){
		    if(dylinker_name[j] == '\0')
			break;
		}
		if(j >= dyld->cmdsize - dyld->name.offset){
		    error_with_cur_obj("dynamic linker name of load command "
			"%lu not null terminated", i);
		    return;
		}
		cur_obj->dylib_stuff = TRUE;
		break;

	    case LC_TWOLEVEL_HINTS:
		hints = (struct twolevel_hints_command *)lc;
		if(cur_obj->swapped)
		    swap_twolevel_hints_command(hints, host_byte_sex);
		if(hints->cmdsize != sizeof(struct twolevel_hints_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_TWOLEVEL_HINTS", i);
		    return;
		}
		check_size_offset(hints->nhints * sizeof(struct twolevel_hint),
				  hints->offset, sizeof(long),
				  "nhints * sizeof(struct twolevel_hint)",
				  "offset", i);
		if(errors)
		    return;
		break;

	    case LC_PREBIND_CKSUM:
		cs = (struct prebind_cksum_command *)lc;
		if(cur_obj->swapped)
		    swap_prebind_cksum_command(cs, host_byte_sex);
		if(cs->cmdsize != sizeof(struct prebind_cksum_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_PREBIND_CKSUM", i);
		    return;
		}
		if(errors)
		    return;
		break;

	    case LC_UUID:
		uuid = (struct uuid_command *)lc;
		if(cur_obj->swapped)
		    swap_uuid_command(uuid, host_byte_sex);
		if(uuid->cmdsize != sizeof(struct uuid_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_UUID", i);
		    return;
		}
		if(errors)
		    return;
#ifndef KLD
		/*
		 * If we see an input file with an LC_UUID load command then
		 * set up to emit one in the output.
		 */
		output_uuid_info.emit = TRUE;
#else
		/*
		 * For kernel extensions preserve the existing UUID in the
		 * output.
		 */
		output_uuid_info.uuid_command.cmd = LC_UUID;
		output_uuid_info.uuid_command.cmdsize =
						sizeof(struct uuid_command);
		memcpy(&(output_uuid_info.uuid_command.uuid[0]), uuid->uuid,
		       sizeof(uuid->uuid));
#endif

		break;

	    /*
	     * All of these are not looked at so the whole command is not
	     * swapped.  But we need to swap just the first part in memory in
	     * case they are in a dylib so other code can step over them.
	     */
	    case LC_UNIXTHREAD:
	    case LC_THREAD:
	    case LC_IDENT:
	    case LC_FVMFILE:
	    case LC_PREPAGE:
	    case LC_PREBOUND_DYLIB:
	    case LC_CODE_SIGNATURE:
	    case LC_SEGMENT_SPLIT_INFO:
		if(cur_obj->swapped)
		    swap_load_command(lc, host_byte_sex);
		break;

	    default:
		error_with_cur_obj("load command %lu unknown cmd field", i);
		return;
	    }
	    lc = (struct load_command *)((char *)lc + l.cmdsize);
	}
	/*
	 * The -bundle_loader argument must be an object file with a dynamic
	 * symbol table command.
	 */
	if(bundle_loader){
	    if(cur_obj->dysymtab == NULL){
		error_with_cur_obj("bundle loader does not have an LC_DYSYMTAB "
				   "command");
		return;
	    }
	    cur_obj->bundle_loader = TRUE;
	}
	/*
	 * If this object does not have a symbol table command then set it's
	 * symtab pointer to the empty symtab.  This makes symbol number range
	 * checks in relocation cleaner.
	 */
	if(cur_obj->symtab == NULL){
	    if(cur_obj->dysymtab != NULL)
		error_with_cur_obj("contains LC_DYSYMTAB load command without "
				   "a LC_SYMTAB load command");
	    cur_obj->symtab = (struct symtab_command *)&empty_symtab;
	    cur_obj->dysymtab = (struct dysymtab_command *)&empty_dysymtab;
	}
	else{
	    if(cur_obj->dysymtab == NULL){
		cur_obj->dysymtab = (struct dysymtab_command *)&empty_dysymtab;
		if(cur_obj->rc != NULL)
		    error_with_cur_obj("contains LC_ROUTINES load command "
				       "without a LC_DYSYMTAB load command");
	    }
	    else{
		if(dyst->nlocalsym != 0 &&
		   dyst->ilocalsym > st->nsyms)
		    error_with_cur_obj("ilocalsym in LC_DYSYMTAB load "
			"command extends past the end of the symbol table");
		if(dyst->nlocalsym != 0 &&
		   dyst->ilocalsym + dyst->nlocalsym > st->nsyms)
		    error_with_cur_obj("ilocalsym plus nlocalsym in "
			"LC_DYSYMTAB load command extends past the "
			"end of the symbol table");

		if(dyst->nextdefsym != 0 &&
		   dyst->iextdefsym > st->nsyms)
		    error_with_cur_obj("iextdefsym in LC_DYSYMTAB load "
			"command extends past the end of the symbol table");
		if(dyst->nextdefsym != 0 &&
		   dyst->iextdefsym + dyst->nextdefsym > st->nsyms)
		    error_with_cur_obj("iextdefsym plus nextdefsym in "
			"LC_DYSYMTAB load command extends past the "
			"end of the symbol table");

		if(dyst->nundefsym != 0 &&
		   dyst->iundefsym > st->nsyms)
		    error_with_cur_obj("iundefsym in LC_DYSYMTAB load "
			"command extends past the end of the symbol table");
		if(dyst->nundefsym != 0 &&
		   dyst->iundefsym + dyst->nundefsym > st->nsyms)
		    error_with_cur_obj("iundefsym plus nundefsym in "
			"LC_DYSYMTAB load command extends past the "
			"end of the symbol table");

		if(dyst->ntoc != 0){
		    tocs =(struct dylib_table_of_contents *)(cur_obj->obj_addr +
							     dyst->tocoff);
		    if(cur_obj->swapped)
			swap_dylib_table_of_contents(tocs, dyst->ntoc,
						     host_byte_sex);
		    for(i = 0; i < dyst->ntoc; i++){
			if(tocs[i].symbol_index > st->nsyms)
			    error_with_cur_obj("symbol_index field of table of "
				"contents entry %lu past the end of the symbol "
				"table", i);
			if(tocs[i].module_index > dyst->nmodtab)
			    error_with_cur_obj("module_index field of table of "
				"contents entry %lu past the end of the module "
				"table", i);
		    }
		}

		if(dyst->nmodtab != 0){
		    mods = (struct dylib_module *)(cur_obj->obj_addr +
						   dyst->modtaboff);
		    if(cur_obj->swapped)
			swap_dylib_module(mods, dyst->nmodtab, host_byte_sex);
		    for(i = 0; i < dyst->nmodtab; i++){
			if(mods[i].module_name > st->strsize)
			    error_with_cur_obj("module_name field of module "
				"table entry %lu past the end of the string "
				"table", i);
			if(mods[i].iextdefsym > st->nsyms)
			    error_with_cur_obj("iextdefsym field of module "
				"table entry %lu past the end of the symbol "
				"table", i);
			if(mods[i].iextdefsym +
			   mods[i].nextdefsym > st->nsyms)
			    error_with_cur_obj("iextdefsym field plus "
				"nextdefsym field of module table entry %lu "
				"past the end of the symbol table", i);
			if(mods[i].irefsym > dyst->nextrefsyms)
			    error_with_cur_obj("irefsym field of module table "
				"entry %lu past the end of the reference table",
				i);
			if(mods[i].irefsym +
			   mods[i].nrefsym > dyst->nextrefsyms)
			    error_with_cur_obj("irefsym field plus "
				"nrefsym field of module table entry %lu past "
				"the end of the reference table", i);
			if(mods[i].ilocalsym > st->nsyms)
			    error_with_cur_obj("ilocalsym field of module "
				"table entry %lu past the end of the symbol "
				"table", i);
			if(mods[i].ilocalsym +
			   mods[i].nlocalsym > st->nsyms)
			    error_with_cur_obj("ilocalsym field plus "
				"nlocalsym field of module table entry %lu "
				"past the end of the symbol table", i);
		    }
		}

		if(dyst->nextrefsyms != 0){
		    refs = (struct dylib_reference *)(cur_obj->obj_addr +
						      dyst->extrefsymoff);
		    if(cur_obj->swapped)
			swap_dylib_reference(refs, dyst->nextrefsyms,
					     host_byte_sex);
		    for(i = 0; i < dyst->nextrefsyms; i++){
			if(refs[i].isym > st->nsyms)
			    error_with_cur_obj("isym field of reference table "
				"entry %lu past the end of the symbol table",i);
		    }
		}

		if(dyst->nindirectsyms != 0){
		    indirect_symtab = (uint32_t *)(cur_obj->obj_addr +
					    dyst->indirectsymoff);
		    if(cur_obj->swapped)
			swap_indirect_symbols(indirect_symtab,
			    dyst->nindirectsyms, host_byte_sex);
		    for(i = 0; i < dyst->nindirectsyms; i++){
			if(indirect_symtab[i] != INDIRECT_SYMBOL_LOCAL &&
			   indirect_symtab[i] != INDIRECT_SYMBOL_ABS){
			    if(indirect_symtab[i] > st->nsyms)
				error_with_cur_obj("indirect symbol table entry"
				    " %lu past the end of the symbol table", i);
			}
		    }
		}

		if(rc != NULL && rc->init_module > dyst->nmodtab)
		    error_with_cur_obj("init_module field of LC_ROUTINES load "
			"command past the end of the module table");
	    }
	}
	/*
	 * If this is a MH_DYLIB or MH_DYLIB_STUB file then a single
	 * LC_ID_DYLIB command must be seen to identify the library.
	 */
	if((mh->filetype == MH_DYLIB || mh->filetype == MH_DYLIB_STUB) &&
	   dlid == NULL){
	    error_with_cur_obj("malformed object (no LC_ID_DYLIB load command "
			       "in %s file)", mh->filetype == MH_DYLIB ?
			       "MH_DYLIB" : "MH_DYLIB_STUB");
	    return;
	}
	/*
	 * If this is a MH_DYLINKER file then a single LC_ID_DYLINKER command
	 * must be seen to identify the library.
	 */
	if(mh->filetype == MH_DYLINKER && dyldid == NULL){
	    error_with_cur_obj("malformed object (no LC_ID_DYLINKER load "
		"command in MH_DYLINKER file)");
	    return;
	}
#ifndef RLD
	/*
	 * If we find a sub_framework_command for a dynamic library that was
	 * directly linked against then we must generate a link error
	 * if what we are building is not the umbrella framework for this
	 * subframework or it is not a another subframework of the same
	 * umbrella framework.
	 *
	 * The following error is a non-standard form but it is exactly what is
	 * specified when this feature was added.
	 */
	if(indirect_dylib == FALSE && sub != NULL &&
	   (umbrella_framework_name == NULL ||
	    strcmp(umbrella_name, umbrella_framework_name) != 0)){

	    short_name = guess_short_name(dylib_id_name, &is_framework,
					  &has_suffix);
	    /*
	     * This may still be an allowable of this sub framework.  Check the
	     * LC_SUB_CLIENT commands to see if this client name is listed.
	     */
	    if(umbrella_framework_name != NULL)
		this_client_name = umbrella_framework_name;
	    else
		this_client_name = client_name;
	    allowable_client = FALSE;
	    if(this_client_name != NULL){
		lc = load_commands;
		for(i = 0; i < mh->ncmds; i++){
		    if(lc->cmd == LC_SUB_CLIENT){
			csub = (struct sub_client_command *)lc;
			sub_client_name = (char *)csub + csub->client.offset;
			if(strcmp(sub_client_name, this_client_name) == 0){
			    allowable_client = TRUE;
			    break;
			}
		    }
		    lc = (struct load_command *)((char *)lc + lc->cmdsize);
		}
	    }
	    if(allowable_client == FALSE){
		if(short_name != NULL && is_framework == TRUE)
		    error_with_cur_obj("'%s.framework' is a subframework.  "
			"Link against the umbrella framework '%s.framework' "
			"instead.", short_name, umbrella_name);
		else
		    error_with_cur_obj("is a subframework.  Link against the "
			"umbrella framework '%s.framework' instead.",
			umbrella_name);
	    }
	}
#endif /* RLD */
}

#ifdef RLD
/*
 * merge_base_program() does the pass1 functions for the base program that
 * called rld_load() using it's SEG_LINKEDIT.  It does the same things as the
 * routines pass1(),check_obj() and merge() except that the offset are assumed
 * to be correct in most cases (if they weren't the program would not be
 * executing).  If seg_linkedit is NULL it then the symbol and string table
 * passed in is used instead of seg_linkedit.
 *
 * A hand crafted object structure is created so to work with the rest of the
 * code.  Like check_obj() a number of things are filled in in the object
 * structrure including: the symtab field, the section_maps and nsection_maps
 * fields (this routine allocates the section_map structures and fills them in
 * too), all fvmlib stuff is ignored since the output is loaded as well as
 * linked.  The file offsets in symtab are faked since this is not a file mapped
 * into memory but rather a running process.  This involves setting where the
 * object starts to the address of the _mh_execute_header and calcating the
 * file offset of the symbol and string table as the differences of the
 * addresses from the _mh_execute_header.  This makes using the rest of the
 * code easy.
 */
__private_extern__
void
merge_base_program(
char *basefile_name,
struct mach_header *basefile_addr,
struct segment_command *seg_linkedit,
struct nlist *symtab,
unsigned long nsyms,
char *strtab,
unsigned long strsize)
{
    unsigned long i, j, section_type;
    struct mach_header *mh;
    struct load_command *lc, *load_commands;
    struct segment_command *sg;
    struct section *s;
    struct symtab_command *st;
    struct dysymtab_command *dyst;

    static const struct symtab_command empty_symtab = { 0 };
    static struct symtab_command base_program_symtab = { 0 };

	/*
	 * Hand craft the object structure as in pass1().  Note the obj_size
	 * feild should never be tested against since this is not a file mapped
	 * into memory but rather a running program.
	 */
	cur_obj = new_object_file();
	cur_obj->file_name = basefile_name;
	cur_obj->obj_addr = (char *)basefile_addr;
	cur_obj->obj_size = 0;
	cur_obj->from_fat_file = FALSE;
	base_obj = cur_obj;
	/* Set the output cpu types from the base program's header */
	mh = basefile_addr;
	arch_flag.cputype = mh->cputype;
	arch_flag.cpusubtype = mh->cpusubtype;

	/*
	 * Go through the load commands and do what would be done in check_obj()
	 * but not checking for offsets.
	 */
	load_commands = (struct load_command *)((char *)cur_obj->obj_addr +
			    sizeof(struct mach_header));
	st = NULL;
	dyst = NULL;
	lc = load_commands;
	for(i = 0; i < mh->ncmds; i++){
	    if(lc->cmdsize % sizeof(long) != 0){
		error_with_cur_obj("load command %lu size not a multiple of "
				   "sizeof(long)", i);
		return;
	    }
	    if(lc->cmdsize <= 0){
		error_with_cur_obj("load command %lu size is less than or equal"
				   " to zero", i);
		return;
	    }
	    if((char *)lc + lc->cmdsize >
	       (char *)load_commands + mh->sizeofcmds){
		error_with_cur_obj("load command %lu extends past end of all "
				   "load commands", i);
		return;
	    }
	    switch(lc->cmd){
	    case LC_SEGMENT:
		sg = (struct segment_command *)lc;
		if(sg->cmdsize != sizeof(struct segment_command) +
				     sg->nsects * sizeof(struct section)){
		    error_with_cur_obj("cmdsize field of load command %lu is "
				       "inconsistant for a segment command "
				       "with the number of sections it has", i);
		    return;
		}
		if(sg->flags == SG_FVMLIB){
		    if(sg->nsects != 0){
			error_with_cur_obj("SG_FVMLIB segment %.16s contains "
					   "sections and shouldn't",
					   sg->segname);
			return;
		    }
		    break;
		}
		/*
		 * Segments without sections are an error to see on input except
		 * for the segments created by the link-editor (which are
		 * recreated).
		 */
		if(sg->nsects == 0){
		    if(strcmp(sg->segname, SEG_PAGEZERO) != 0 &&
		       strcmp(sg->segname, SEG_LINKEDIT) != 0){
			error_with_cur_obj("segment %.16s contains no "
					   "sections and can't be link-edited",
					   sg->segname);
			return;
		    }
		}
		else{
		    /*
		     * Doing a reallocate here is not bad beacuse in the
		     * normal case this is an MH_OBJECT file type and has only
		     * one section.  So this only gets done once per object.
		     */
		    cur_obj->section_maps = reallocate(cur_obj->section_maps,
					(cur_obj->nsection_maps + sg->nsects) *
					sizeof(struct section_map));
		    memset(cur_obj->section_maps + cur_obj->nsection_maps, '\0',
			   sg->nsects * sizeof(struct section_map));
		}
		s = (struct section *)
		    ((char *)sg + sizeof(struct segment_command));
		for(j = 0 ; j < sg->nsects ; j++){
		    cur_obj->section_maps[cur_obj->nsection_maps++].s = s;
		    /* check to see that segment name in the section structure
		       matches the one in the segment command if this is not in
		       an MH_OBJECT filetype */
		    if(mh->filetype != MH_OBJECT &&
		       strcmp(sg->segname, s->segname) != 0){
			error_with_cur_obj("segment name %.16s of section %lu "
				"(%.16s,%.16s) in load command %lu does not "
				"match segment name %.16s", s->segname, j,
				s->segname, s->sectname, i, sg->segname);
			return;
		    }
		    /* check to see that flags (type) of this section is some
		       thing the link-editor understands */
		    section_type = s->flags & SECTION_TYPE;
		    if(section_type != S_REGULAR &&
		       section_type != S_ZEROFILL &&
		       section_type != S_CSTRING_LITERALS &&
		       section_type != S_4BYTE_LITERALS &&
		       section_type != S_8BYTE_LITERALS &&
		       section_type != S_LITERAL_POINTERS &&
		       section_type != S_NON_LAZY_SYMBOL_POINTERS &&
		       section_type != S_LAZY_SYMBOL_POINTERS &&
		       section_type != S_SYMBOL_STUBS &&
		       section_type != S_COALESCED &&
		       section_type != S_MOD_INIT_FUNC_POINTERS &&
		       section_type != S_MOD_TERM_FUNC_POINTERS &&
		       section_type != S_DTRACE_DOF){
			error_with_cur_obj("unknown flags (type) of section %lu"
					   " (%.16s,%.16s) in load command %lu",
					   j, s->segname, s->sectname, i);
			return;
		    }
		    /* check to make sure the alignment is reasonable */
		    if(s->align > MAXSECTALIGN){
			error_with_cur_obj("align (%u) of section %lu "
			    "(%.16s,%.16s) in load command %lu greater "
			    "than maximum section alignment (%d)", s->align,
			     j, s->segname, s->sectname, i, MAXSECTALIGN);
			return;
		    }
		    s++;
		}
		break;

	    case LC_SYMTAB:
		if(st != NULL){
		    error_with_cur_obj("contains more than one LC_SYMTAB load "
				       "command");
		    return;
		}
		st = (struct symtab_command *)lc;
		if(st->cmdsize != sizeof(struct symtab_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_SYMTAB", i);
		    return;
		}
		break;

	    case LC_DYSYMTAB:
		if(dyst != NULL){
		    error_with_cur_obj("contains more than one LC_DYSYMTAB "
				       "load command");
		    return;
		}
		dyst = (struct dysymtab_command *)lc;
		if(dyst->cmdsize != sizeof(struct dysymtab_command)){
		    error_with_cur_obj("cmdsize of load command %lu incorrect "
				       "for LC_DYSYMTAB", i);
		    return;
		}
		break;

	    case LC_SYMSEG:
	    case LC_IDFVMLIB:
	    case LC_LOADFVMLIB:
	    case LC_ID_DYLIB:
	    case LC_LOAD_DYLIB:
	    case LC_LOAD_WEAK_DYLIB:
	    case LC_REEXPORT_DYLIB:
	    case LC_ID_DYLINKER:
	    case LC_LOAD_DYLINKER:
	    case LC_UNIXTHREAD:
	    case LC_THREAD:
	    case LC_IDENT:
	    case LC_FVMFILE:
	    case LC_PREPAGE:
		break;

	    default:
		error_with_cur_obj("load command %lu unknown cmd", i);
		return;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
	/*
	 * Now the slightly tricky part of faking up a symtab command that
	 * appears to have offsets to the symbol and string table when added
	 * to the cur_obj->obj_addr get the correct addresses.
	 */
	if(seg_linkedit == NULL){
	    base_program_symtab.cmd = LC_SYMTAB;
	    base_program_symtab.cmdsize = sizeof(struct symtab_command);
	    base_program_symtab.symoff = (long)symtab - (long)cur_obj->obj_addr;
	    base_program_symtab.nsyms = nsyms;
	    base_program_symtab.stroff = (long)strtab - (long)cur_obj->obj_addr;
	    base_program_symtab.strsize = strsize;
	    cur_obj->symtab = &base_program_symtab;
	}
	else if(st != NULL && st->nsyms != 0){
	    if(st->symoff < seg_linkedit->fileoff ||
	       st->symoff + st->nsyms * sizeof(struct nlist) >
				seg_linkedit->fileoff + seg_linkedit->filesize){
		error_with_cur_obj("symbol table is not contained in "
				   SEG_LINKEDIT " segment");
		return;
	    }
	    if(st->stroff < seg_linkedit->fileoff ||
	       st->stroff + st->strsize >
				seg_linkedit->fileoff + seg_linkedit->filesize){
		error_with_cur_obj("string table is not contained in "
				   SEG_LINKEDIT " segment");
		return;
	    }
	    base_program_symtab = *st;
	    base_program_symtab.symoff = (seg_linkedit->vmaddr + (st->symoff -
					  seg_linkedit->fileoff)) -
					  (long)cur_obj->obj_addr;
	    base_program_symtab.stroff = (seg_linkedit->vmaddr + (st->stroff -
					  seg_linkedit->fileoff)) -
					  (long)cur_obj->obj_addr;
	    cur_obj->symtab = &base_program_symtab;
	}
	/*
	 * If this object does not have a symbol table command then set it's
	 * symtab pointer to the empty symtab.  This makes symbol number range
	 * checks in relocation cleaner.
	 */
	else{
	    cur_obj->symtab = (struct symtab_command *)&empty_symtab;
	}

	/*
	 * Now finish with the base program by doing what would be done in
	 * merge() by merging the base program's sections and symbols.
	 */
	/* merged the base program's sections */
	merge_sections();

	/* merged the base program's symbols */
	merge_symbols();
}
#endif /* RLD */

/*
 * check_size_offset() is used by check_cur_obj() to check a pair of sizes,
 * and offsets from the object file to see it they are aligned correctly and
 * containded with in the file.
 */
static
void
check_size_offset(
unsigned long size,
unsigned long offset,
unsigned long align,
char *size_str,
char *offset_str,
unsigned long cmd)
{
	if(size != 0){
	    if(offset % align != 0){
#ifdef mc68000
		/*
		 * For the mc68000 the alignment is only a warning because it
		 * can deal with all accesses on bad alignment.
		 */
		warning_with_cur_obj("%s in load command %lu not aligned on %lu"
				     " byte boundary", offset_str, cmd, align);
#else /* !defined(mc68000) */
		error_with_cur_obj("%s in load command %lu not aligned on %lu "
				   "byte boundary", offset_str, cmd, align);
#endif /* mc68000 */
		return;
	    }
	    if(offset > cur_obj->obj_size){
		error_with_cur_obj("%s in load command %lu extends past the "
				   "end of the file", offset_str, cmd);
		return;
	    }
	    if(offset + size > cur_obj->obj_size){
		error_with_cur_obj("%s plus %s in load command %lu extends past"
				   " the end of the file", offset_str, size_str,
				   cmd);
		return;
	    }
	}
}

/*
 * check_size_offset_sect() is used by check_cur_obj() to check a pair of sizes,
 * and offsets from a section in the object file to see it they are aligned
 * correctly and containded with in the file.
 */
static
void
check_size_offset_sect(
unsigned long size,
unsigned long offset,
unsigned long align,
char *size_str,
char *offset_str,
unsigned long cmd,
unsigned long sect,
char *segname,
char *sectname)
{
	if(size != 0){
	    if(offset % align != 0){
#ifdef mc68000
		/*
		 * For the mc68000 the alignment is only a warning because it
		 * can deal with all accesses on bad alignment.
		 */
		warning_with_cur_obj("%s of section %lu (%.16s,%.16s) in load "
		    "command %lu not aligned on %lu byte boundary", offset_str,
		    sect, segname, sectname, cmd, align);
#else /* !defined(mc68000) */
		error_with_cur_obj("%s of section %lu (%.16s,%.16s) in load "
		    "command %lu not aligned on %lu byte boundary", offset_str,
		    sect, segname, sectname, cmd, align);
#endif /* mc68000 */
		return;
	    }
	    if(offset > cur_obj->obj_size){
		error_with_cur_obj("%s of section %lu (%.16s,%.16s) in load "
		    "command %lu extends past the end of the file", offset_str,
		    sect, segname, sectname, cmd);
		return;
	    }
	    if(offset + size > cur_obj->obj_size){
		error_with_cur_obj("%s plus %s of section %lu (%.16s,%.16s) "
		    "in load command %lu extends past the end of the file",
		    offset_str, size_str, sect, segname, sectname, cmd);
		return;
	    }
	}
}

#ifndef RLD
/*
 * collect_base_obj_segments() collects the segments from the base file on a
 * merged segment list used for overlap checking in
 * check_for_overlapping_segments().
 */
static
void
collect_base_obj_segments(void)
{
    unsigned long i;
    struct mach_header *mh;
    struct load_command *lc, *load_commands;
    struct segment_command *sg;

	mh = (struct mach_header *)base_obj->obj_addr;
	load_commands = (struct load_command *)((char *)base_obj->obj_addr +
			    sizeof(struct mach_header));
	lc = load_commands;
	for(i = 0; i < mh->ncmds; i++){
	    switch(lc->cmd){
	    case LC_SEGMENT:
		sg = (struct segment_command *)lc;
		add_base_obj_segment(sg, base_obj->file_name);
		break;

	    default:
		break;
	    }
	    lc = (struct load_command *)((char *)lc + lc->cmdsize);
	}
}

/*
 * add_base_obj_segment() adds the specified segment to the list of
 * base_obj_segments as comming from the specified base filename.
 */
static
void
add_base_obj_segment(
struct segment_command *sg,
char *filename)
{
    struct merged_segment **p, *msg;

	p = &base_obj_segments;
	while(*p){
	    msg = *p;
	    p = &(msg->next);
	}
	*p = allocate(sizeof(struct merged_segment));
	msg = *p;
	memset(msg, '\0', sizeof(struct merged_segment));
	msg->sg = *sg;
	msg->filename = filename;
}

#ifndef KLD
/*
 * symbol_address_compare takes two pointers to pointers to symbol entries,
 * and returns an ordering on them by address.  It also looks for STABS
 * symbols and if found sets *(int *)fail_p.
 */
static int
symbol_address_compare (void *fail_p, const void *a_p, const void *b_p)
{
  const struct nlist * const * aa = a_p;
  const struct nlist * a = *aa;
  const struct nlist * const * bb = b_p;
  const struct nlist * b = *bb;

  if (a->n_type & N_STAB)
    *(int *)fail_p = 1;
  if ((a->n_type & N_TYPE) != (b->n_type & N_TYPE))
    return (a->n_type & N_TYPE) < (b->n_type & N_TYPE) ? -1 : 1;
  if (a->n_value != b->n_value)
    {
      /* This is before the symbols are swapped, so this routine must
	 swap what it needs.  */
      if (cur_obj->swapped)
	return SWAP_LONG (a->n_value) < SWAP_LONG (b->n_value) ? -1 : 1;
      else
	return a->n_value < b->n_value ? -1 : 1;
    }

  else
    return 0;
}

/*
 * read_dwarf_info looks for DWARF sections in cur_obj and if found,
 * fills in the dwarf_name and dwarf_comp_dir fields in cur_obj.
 *
 * Once this routine has completed, no section marked with
 * S_ATTR_DEBUG will be needed in the link, and so if the object file
 * layout is appropriate those sections can be unmapped.
 */
static void
read_dwarf_info(void)
{
  enum { chunksize = 256 };

  struct ld_chunk {
    struct ld_chunk * next;
    size_t filedata[chunksize];
  };

  int little_endian;
  struct section * debug_info = NULL;
  struct section * debug_line = NULL;
  struct section * debug_abbrev = NULL;

  const char * name;
  const char * comp_dir;
  uint64_t stmt_list;
  int has_stabs = FALSE;

  struct line_reader_data * lrd;
  /* 'st' is the symbol table, 'sst' is pointers into that table
     sorted by the symbol's address.  */
  struct nlist *st;
  struct nlist **sst;

  struct ld_chunk * chunks;
  struct ld_chunk * lastchunk;
  size_t * symdata;
  size_t lastused;
  size_t num_line_syms = 0;
  size_t dwarf_source_i;
  size_t max_files = 0;

  struct line_info li_start, li_end;

  size_t i;

#if __LITTLE_ENDIAN__
  little_endian = !cur_obj->swapped;
#else
  little_endian = cur_obj->swapped;
#endif

  /* Find the sections containing the DWARF information we need.  */
  for (i = 0; i < cur_obj->nsection_maps; i++)
    {
      struct section * s = cur_obj->section_maps[i].s;

      if (strncmp (s->segname, "__DWARF", 16) != 0)
	continue;
      if (strncmp (s->sectname, "__debug_info", 16) == 0)
	debug_info = s;
      else if (strncmp (s->sectname, "__debug_line", 16) == 0)
	debug_line = s;
      else if (strncmp (s->sectname, "__debug_abbrev", 16) == 0)
	debug_abbrev = s;
    }

  /* No DWARF means nothing to do.
     However, no line table may just mean that there's no code in this
     file, in which case processing continues.  */
  if (! debug_info || ! debug_abbrev || ! cur_obj->symtab
      || debug_info->size == 0)
    return;

  /* Read the debug_info (and debug_abbrev) sections, and determine
     the name and working directory to put in the SO stabs, and also
     the offset into the line number section.  */
  if (read_comp_unit ((const uint8_t *) cur_obj->obj_addr + debug_info->offset,
		      debug_info->size,
		      ((const uint8_t *)cur_obj->obj_addr
		       + debug_abbrev->offset),
		      debug_abbrev->size, little_endian,
		      &name, &comp_dir, &stmt_list)
      && name) {
    cur_obj->dwarf_name = strdup (name);
    if (comp_dir)
      cur_obj->dwarf_comp_dir = strdup (comp_dir);
    else
      cur_obj->dwarf_comp_dir = NULL;
  } else {
    warning_with_cur_obj("could not understand DWARF debug information");
    return;
  }

  /* If there is no line table, don't do any more processing.  No N_FUN
     or N_SOL stabs will be output.  */
  if (! debug_line || stmt_list == (uint64_t) -1)
    return;

  /* At this point check_symbol has not been called, so all the code below
     that processes symbols must not assume that the symbol's contents
     make any sense.  */

  /* Generate the line number information into
     cur_obj->dwarf_source_data.  The format of dwarf_source_data is a
     sequence of size_t-sized words made up of subsequences.  Each
     subsequence describes the source files which the debug_line information
     says contributed to the code of the entity starting at a particular
     symbol.

     The subsequences are sorted by the index of the symbol to which they
     refer.  The format of a subsequence is a word containing the index
     of the symbol, a word giving the end of the entity starting with
     that symbol, and then one or more words which are file numbers
     with their high bit set.

     A file number is simply an index into cur_obj->dwarf_paths; each
     dwarf_paths entry is either NULL (if not used) or the path of the
     source file.  */

  st = (struct nlist *)(cur_obj->obj_addr + cur_obj->symtab->symoff);
  /* The processing is easier if we have a list of symbols sorted by
     address.  */
  sst = allocate (sizeof (struct nlist *) * cur_obj->symtab->nsyms);
  for (i = 0; i < cur_obj->symtab->nsyms; i++)
    sst[i] = st + i;
  qsort_r (sst, cur_obj->symtab->nsyms, sizeof (struct nlist *), &has_stabs,
	   symbol_address_compare);
  if (has_stabs) {
    error_with_cur_obj("has both STABS and DWARF debugging info");
    free (sst);
    return;
  }

  if (stmt_list >= debug_line->size){
    warning_with_cur_obj("offset in DWARF debug_info for line number data is too large");
    free (sst);
    return;
  }

  lrd = line_open ((const uint8_t *) cur_obj->obj_addr + debug_line->offset
		   + stmt_list,
		   debug_line->size - stmt_list, little_endian);
  if (! lrd) {
    warning_with_cur_obj("could not understand DWARF line number information");
    free (sst);
    return;
  }

  /* In this first pass, we process the symbols in address order and
     put them into a linked list of chunks to avoid having to call
     reallocate().  */
  chunks = allocate (sizeof (*chunks));
  chunks->next = NULL;
  lastchunk = chunks;
  lastused = 0;
  /* There's also an index by symbol number so we can easily sort them
     later.  */
  symdata = allocate (sizeof (size_t) * cur_obj->symtab->nsyms);
  memset (symdata, 0, sizeof (size_t) * cur_obj->symtab->nsyms);

  li_start.end_of_sequence = TRUE;
  for (i = 0; i < cur_obj->symtab->nsyms; i++){
    struct nlist * s = sst[i];
    size_t idx = s - st;
    struct ld_chunk * symchunk;
    size_t n_value = s->n_value;

    size_t limit, max_limit;

    if ((s->n_type & N_TYPE) != N_SECT
	|| s->n_sect == NO_SECT)
      continue;
    /* Looking for line number information that isn't there is
       expensive, so we only look for line numbers for symbols in
       sections that might contain instructions.  */
    if (! (cur_obj->section_maps[s->n_sect - 1].s->flags
	   & (S_ATTR_SOME_INSTRUCTIONS | S_ATTR_PURE_INSTRUCTIONS)))
      continue;

    if (i + 1 < cur_obj->symtab->nsyms
	&& (sst[i + 1]->n_type & N_TYPE) == N_SECT)
      limit = sst[i + 1]->n_value;
    else
      limit = (uint32_t) -1;

    if (cur_obj->swapped){
      n_value = SWAP_LONG (n_value);
      limit = SWAP_LONG (limit);
    }

    if (li_start.pc > n_value || li_end.pc <= n_value
	|| li_start.end_of_sequence)
      {
	if (! line_find_addr (lrd, &li_start, &li_end, n_value)) {
	  if (li_start.end_of_sequence)
	    continue;
	  else
	    goto line_err;
	}

	/* Make the start...end range as large as possible.  */
	if (li_start.file == li_end.file && ! li_end.end_of_sequence)
	  if (! line_next (lrd, &li_end, line_stop_file))
	    goto line_err;
      }

    symdata[idx] = lastused + 1;

    symchunk = lastchunk;
    num_line_syms++;

    max_limit = 0;
    for (;;)
      {
	size_t j;
	struct ld_chunk * curchunk = symchunk;

	/* File numbers this large are probably an error, and if not
	   they're certainly too large for this linker to handle.  */
	if (li_start.file >= 0x10000000)
	  goto line_err;

	if (li_end.pc > max_limit)
	  max_limit = li_end.pc;

	for (j = symdata[idx]; j < lastused; j++)
	  {
	    if (j % chunksize == 0)
	      curchunk = curchunk->next;
	    if (curchunk->filedata[j % chunksize] == li_start.file)
	      goto skipfile;
	  }
	lastchunk->filedata[lastused % chunksize] = li_start.file;
	lastused++;
	if (li_start.file >= max_files)
	  max_files = li_start.file + 1;
	if (lastused % chunksize == 0)
	  {
	    lastchunk->next = allocate (sizeof (*chunks));
	    lastchunk = lastchunk->next;
	    lastchunk->next = NULL;
	  }

      skipfile:
	if (li_end.pc >= limit || li_end.end_of_sequence)
	  break;
	li_start = li_end;
	if (! line_next (lrd, &li_end, line_stop_file))
	  goto line_err;
      }

    /* The function ends at either the next symbol, or after the last
       byte which has a line number.  */
    if (limit > max_limit)
      limit = max_limit;

    lastchunk->filedata[lastused % chunksize] = (size_t) -1;
    lastused++;
    if (lastused % chunksize == 0)
      {
	lastchunk->next = allocate (sizeof (*chunks));
	lastchunk = lastchunk->next;
	lastchunk->next = NULL;
      }
    lastchunk->filedata[lastused % chunksize] = limit - n_value;
    lastused++;
    if (lastused % chunksize == 0)
      {
	lastchunk->next = allocate (sizeof (*chunks));
	lastchunk = lastchunk->next;
	lastchunk->next = NULL;
      }
  }

  free (sst);

  /* Now take the data in the chunks out ordered by symbol index, so
     the final result can be iterated through easily.  */

  cur_obj->dwarf_paths = allocate (max_files * sizeof (const char *));
  memset (cur_obj->dwarf_paths, 0, max_files * sizeof (const char *));
  cur_obj->dwarf_num_paths = max_files;

  cur_obj->dwarf_source_data = allocate ((lastused + num_line_syms*2 + 1)
					 * sizeof (size_t));
  dwarf_source_i = 0;
  for (i = 0; i < cur_obj->symtab->nsyms; i++)
    if (symdata[i]) {
      struct ld_chunk * symchunk = chunks;
      size_t j;
      size_t * limit_space;

      cur_obj->dwarf_source_data[dwarf_source_i++] = i;
      limit_space = cur_obj->dwarf_source_data + dwarf_source_i++;
      for (j = 0; j < (symdata[i] - 1) / chunksize; j++)
	symchunk = symchunk->next;
      for (j = symdata[i] - 1;
	   symchunk->filedata[j % chunksize] != (size_t) -1;
	   j++) {
	size_t filenum = symchunk->filedata[j % chunksize];
	cur_obj->dwarf_source_data[dwarf_source_i++] = filenum | 0x80000000;
	if (! cur_obj->dwarf_paths[filenum])
	  cur_obj->dwarf_paths[filenum] = line_file (lrd, filenum);
	if (j % chunksize == chunksize - 1)
	  symchunk = symchunk->next;
      }
      j++;
      if (j % chunksize == 0)
	symchunk = symchunk->next;
      *limit_space = symchunk->filedata[j % chunksize];
    }
  /* Terminate with 0x7fffffff, which is larger than any valid symbol
     index.  */
  cur_obj->dwarf_source_data[dwarf_source_i++] = 0x7fffffff;

  /* Finish up by freeing everything.  */
  line_free (lrd);
  free (symdata);
  lastchunk = chunks;
  while (lastchunk) {
    struct ld_chunk * tmp = lastchunk->next;
    free (lastchunk);
    lastchunk = tmp;
  };

  return;

 line_err:
  line_free (lrd);
  free (sst);
  free (symdata);
  lastchunk = chunks;
  while (lastchunk) {
    struct ld_chunk * tmp = lastchunk->next;
    free (lastchunk);
    lastchunk = tmp;
  };

  warning_with_cur_obj("invalid DWARF line number information");
  return;
}
#endif

/*
 * Mkstr() creates a string that is the concatenation of a variable number of
 * strings.  It is pass a variable number of pointers to strings and the last
 * pointer is NULL.  It returns the pointer to the string it created.  The
 * storage for the string is malloc()'ed can be free()'ed when nolonger needed.
 */
static
char *
mkstr(
const char *args,
...)
{
    va_list ap;
    char *s, *p;
    unsigned long size;

	size = 0;
	if(args != NULL){
	    size += strlen(args);
	    va_start(ap, args);
	    p = (char *)va_arg(ap, char *);
	    while(p != NULL){
		size += strlen(p);
		p = (char *)va_arg(ap, char *);
	    }
	}
	s = allocate(size + 1);
	*s = '\0';

	if(args != NULL){
	    (void)strcat(s, args);
	    va_start(ap, args);
	    p = (char *)va_arg(ap, char *);
	    while(p != NULL){
		(void)strcat(s, p);
		p = (char *)va_arg(ap, char *);
	    }
	    va_end(ap);
	}
	return(s);
}
#endif /* !defined(RLD) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/pass1.h                                  0100644 0001750 0001750 00000013206 12612724205 022240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file pass1.c.
 *
 * The following include file need to be included before this file:
 * #include "ld.h"
 */

#ifndef RLD
/* TRUE if -search_paths_first was specified */
__private_extern__ enum bool search_paths_first;

/* the user specified directories to search for -lx filenames, and the number
   of them */
__private_extern__ char **search_dirs;
__private_extern__ unsigned long nsearch_dirs;

/*
 * The user specified directories to search via the environment variable
 * LD_LIBRARY_PATH.
 */
__private_extern__ char **ld_library_paths;
__private_extern__ unsigned long nld_library_paths;

/* the standard directories to search for -lx filenames */
__private_extern__ char *standard_dirs[];

/*
 * The user specified directories to search for "-framework Foo" names, and the
 * number of them.  These are specified with -F options.
 */
__private_extern__ char **framework_dirs;
__private_extern__ unsigned long nframework_dirs;

/* the standard framework directories to search for "-framework Foo" names */
__private_extern__ char *standard_framework_dirs[];

/* the pointer to the head of the base object file's segments */
__private_extern__ struct merged_segment *base_obj_segments;

/*
 * These are pointers to strings and symbols used to search of the table of
 * contents of a library.  These have to be can not be local so that routines
 * can set them and that ranlib_bsearch() and dylib_bsearch() can use them.
 */
__private_extern__ char *bsearch_strings;
#ifndef RLD
__private_extern__ struct nlist *bsearch_symbols;
#endif /* !defined(RLD) */

/*
 * The lists of libraries to be search with dynamic library search semantics.
 */
enum library_type {
    DYLIB,
    SORTED_ARCHIVE,
    UNSORTED_ARCHIVE,
    BUNDLE_LOADER
};
struct dynamic_library {
    enum library_type type;

    /* following used for dynamic libraries */
    char *dylib_name;
    struct dylib_command *dl;
    char *umbrella_name;
    char *library_name;
    enum bool indirect_twolevel_ref_flagged;
    enum bool some_non_weak_refs;
    enum bool some_symbols_referenced;
    enum bool force_weak_dylib;
    struct object_file *definition_obj;
    char *dylib_file; /* argument to -dylib_file "install_name:file_name" */
    struct dylib_table_of_contents *tocs;
    struct nlist *symbols;
    char *strings;
    struct dylib_module *mods;
    struct prebound_dylib_command *pbdylib;
    char *linked_modules;
    /* following are used when -twolevel_namespace is in effect */
    unsigned long ndependent_images;
    struct dynamic_library **dependent_images;
    enum bool sub_images_setup;
    unsigned long nsub_images;
    struct dynamic_library **sub_images;
    enum bool twolevel_searched;

    /* following used for archive libraries */
    char *file_name;
    char *file_addr;
    unsigned long file_size;
    unsigned long nranlibs;
    struct ranlib *ranlibs;
    char *ranlib_strings;
    enum bool ld_trace_archive_printed;

    struct dynamic_library *next;
};

/*
 * The list of dynamic libraries to search.  The list of specified libraries
 * can contain archive libraries when archive libraries appear after dynamic
 * libraries on the link line.
 */
__private_extern__ struct dynamic_library *dynamic_libs;

__private_extern__ unsigned int indirect_library_ratio;

#endif /* !defined(RLD) */

__private_extern__ void pass1(
    char *filename,
    enum bool lname,
    enum bool base_name,
    enum bool framework_name,
    enum bool bundle_loader,
    enum bool force_weak);
__private_extern__ void merge(
    enum bool dylib_only,
    enum bool bundle_loader,
    enum bool force_weak);
__private_extern__ void check_fat(
    char *file_name,
    unsigned long file_size,
    struct fat_header *fat_header,
    struct fat_arch *fat_archs,
    char *ar_name,
    unsigned long ar_name_size);

#ifndef RLD
__private_extern__ void search_dynamic_libs(
    void);
__private_extern__ void prebinding_check_for_dylib_override_symbols(
    void);
__private_extern__ void twolevel_namespace_check_for_unused_dylib_symbols(
    void);
__private_extern__ struct dynamic_library *add_dynamic_lib(
    enum library_type type,
    struct dylib_command *dl,
    struct object_file *definition_obj);
__private_extern__ int dylib_bsearch(
    const char *symbol_name,
    const struct dylib_table_of_contents *toc);
#endif /* !defined(RLD) */

#ifdef RLD
__private_extern__ void merge_base_program(
    char *basefile_name,
    struct mach_header *basefile_addr,
    struct segment_command *seg_linkedit,
    struct nlist *symtab,
    unsigned long nsyms,
    char *strtab,
    unsigned long strsize);
#endif /* RLD */
                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/pass2.c                                  0100644 0001750 0001750 00000117307 12612724205 022243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines that drives pass2 of the link-editor.  In
 * pass2 the output is created and written.  The sections from the input files
 * are copied into the output and relocated.  The headers, relocation entries,
 * symbol table and string table are all copied into the output file.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <libc.h>
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"
#include "stuff/macosx_deployment_target.h"
#include "stuff/unix_standard_mode.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "fvmlibs.h"
#include "dylibs.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "layout.h"
#include "pass2.h"
#include "sets.h"
#include "indirect_sections.h"

/*
 * The total size of the output file and the memory buffer for the output file.
 */
__private_extern__ unsigned long output_size = 0;
__private_extern__ char *output_addr = NULL;

/*
 * This is used to setting the SG_NORELOC flag in the segment flags correctly.
 * This is an array of pointers to the merged sections in the output file that
 * is used by the relocation routines to set the field 'referenced' in the
 * merged section structure by indexing this array (directly without subtracting
 * one from the section number) with the section number of a merged symbol that
 * is refered to in a relocation entry.  The array is created by the routine
 * create_output_sections_array() in here. Then after the 'referenced' field is
 * set by the relocation routines (like generic_reloc() in generic_reloc.c) and
 * the 'relocated' field is set by output_section() in sections.c then the
 * routine set_SG_NORELOC_flags() in here can use these two fields to set the
 * SG_NORELOC flag in the segments that have no relocation to or for them.
 */
__private_extern__ struct merged_section **output_sections = NULL;

#ifndef RLD
/* the file descriptor of the output file */
static int fd = 0;

/*
 * This structure is used to describe blocks of the output file that are flushed
 * to the disk file with output_flush.  It is kept in an ordered list starting
 * with output_blocks.
 */
static struct block {
    unsigned long offset;	/* starting offset of this block */
    unsigned long size;		/* size of this block */
    unsigned long written_offset;/* first page offset after starting offset */
    unsigned long written_size;	/* size of written area from written_offset */
    struct block *next; /* next block in the list */
} *output_blocks;

static void setup_output_flush(void);
static void final_output_flush(void);
#ifdef DEBUG
static void print_block_list(void);
#endif /* DEBUG */
static struct block *get_block(void);
static void remove_block(struct block *block);
static unsigned long trnc(unsigned long v, unsigned long r);
#endif /* !defined(RLD) */
static void create_output_sections_array(void);
static void set_SG_NORELOC_flags(void);
static void output_headers(void);

/*
 * pass2() creates the output file and the memory buffer to create the file
 * into.  It drives the process to get everything copied into the buffer for
 * the output file.  It then writes the output file and deallocates the buffer.
 */ 
__private_extern__
void
pass2(void)
{
    unsigned long i, j, section_type;
    struct object_list *object_list, **p;
#ifndef RLD
    int mode;
    struct stat stat_buf;
    kern_return_t r;

	/*
	 * In UNIX standard conformance mode we are not allowed to replace
	 * a file that is not writeable.
	 */
	if(get_unix_standard_mode() == TRUE && 
	   access(outputfile, F_OK) == 0 &&
	   access(outputfile, W_OK) == -1)
	    system_fatal("can't write output file: %s", outputfile);

	/*
	 * Create the output file.  The unlink() is done to handle the problem
	 * when the outputfile is not writable but the directory allows the
	 * file to be removed (since the file may not be there the return code
	 * of the unlink() is ignored).
	 */
	(void)unlink(outputfile);
	if((fd = open(outputfile, O_WRONLY | O_CREAT | O_TRUNC, 0777)) == -1)
	    system_fatal("can't create output file: %s", outputfile);
#ifdef F_NOCACHE
        /* tell filesystem to NOT cache the file when reading or writing */
	(void)fcntl(fd, F_NOCACHE, 1);
#endif
	if(fstat(fd, &stat_buf) == -1)
	    system_fatal("can't stat file: %s", outputfile);
	/*
	 * Turn the execute bits on or off depending if there are any undefined
	 * symbols in the output file.  If the file existed before the above
	 * open() call the creation mode in that call would have been ignored
	 * so it has to be set explicitly in any case.
	 */
	if(output_mach_header.flags & MH_NOUNDEFS ||
	   (has_dynamic_linker_command && output_for_dyld))
	    mode = (stat_buf.st_mode & 0777) | (0111 & ~umask(0));
	else
	    mode = (stat_buf.st_mode & 0777) & ~0111;
	if(fchmod(fd, mode) == -1)
	    system_fatal("can't set execution permissions output file: %s",
			 outputfile);

	/*
	 * Create the buffer to copy the parts of the output file into.
	 */
	if((r = vm_allocate(mach_task_self(), (vm_address_t *)&output_addr,
			    output_size, TRUE)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_allocate() buffer for output file of size "
		       "%lu", output_size);

	/*
	 * Set up for flushing pages to the output file as they fill up.
	 */
	if(flush)
	    setup_output_flush();

	/*
	 * Make sure pure_instruction sections are padded with nop's.
	 */
	nop_pure_instruction_scattered_sections();

#endif /* !defined(RLD) */

	/*
	 * The strings indexes for the merged string blocks need to be set
	 * before the dylib tables are output because the module names are in
	 * them as well as the merged symbol names.
	 */
	set_merged_string_block_indexes();

#ifndef RLD
	/*
	 * Copy the dylib tables into the output file.  This is done before the
	 * sections are outputted so that the indexes to the local and external
	 * relocation entries for each object can be used as running indexes as
	 * each section in the object is outputted.
	 */
	if(filetype == MH_DYLIB)
	    output_dylib_tables();
#endif /* !defined(RLD) */

	/*
	 * Create the array of pointers to merged sections in the output file
	 * so the relocation routines can use it to set the 'referenced' fields
	 * in the merged section structures.
	 */
	create_output_sections_array();

	/*
	 * Copy the merged literal sections and the sections created from files
	 * into the output object file.
	 */
	output_literal_sections();
#ifndef RLD
	output_sections_from_files();
#endif /* !defined(RLD) */

	/*
	 * For each non-literal content section in each object file loaded 
	 * relocate it into the output file (along with the relocation entries).
	 * Then relocate local symbols into the output file for the loaded
	 * objects.
	 */
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		/* print the object file name if tracing */
		if(trace){
		    print_obj_name(cur_obj);
		    print("\n");
		}
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		if(cur_obj != base_obj){
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(cur_obj->section_maps[j].s->flags & S_ATTR_DEBUG)
			    continue;
#ifdef RLD
			if(cur_obj->set_num == cur_set)
#endif /* RLD */
			{
			    section_type = (cur_obj->section_maps[j].s->flags &
                                                   SECTION_TYPE);
			    if(section_type == S_REGULAR ||
			       section_type == S_SYMBOL_STUBS ||
			       section_type == S_NON_LAZY_SYMBOL_POINTERS ||
			       section_type == S_LAZY_SYMBOL_POINTERS ||
			       section_type == S_COALESCED ||
			       section_type == S_MOD_INIT_FUNC_POINTERS ||
			       section_type == S_MOD_TERM_FUNC_POINTERS){
				output_section(&(cur_obj->section_maps[j]));
			    }
			}
		    }
		}
		output_local_symbols();
#ifdef VM_SYNC_DEACTIVATE
		vm_msync(mach_task_self(), (vm_address_t)cur_obj->obj_addr,
			 (vm_size_t)cur_obj->obj_size, VM_SYNC_DEACTIVATE);
#endif /* VM_SYNC_DEACTIVATE */
	    }
	}
	/*
	 * If there were errors in output_section() then return as so not
	 * to cause later internal errors.
	 */
	if(errors != 0)
	    return;

#ifdef RLD
	/*
	 * For each content section clean up the data structures not needed
	 * after rld is run.  This must be done after ALL the sections are
	 * output'ed because the fine relocation entries could be used by any
	 * of the sections.
	 */
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(cur_obj->section_maps[j].nfine_relocs != 0){
			free(cur_obj->section_maps[j].fine_relocs);
			cur_obj->section_maps[j].fine_relocs = NULL;
			cur_obj->section_maps[j].nfine_relocs = 0;
		    }
		}
		if(cur_obj->nundefineds != 0){
		    free(cur_obj->undefined_maps);
		    cur_obj->undefined_maps = NULL;
		    cur_obj->nundefineds = 0;
		}
	    }
	}
#endif /* RLD */

	/*
	 * Set the SG_NORELOC flag in the segments that had no relocation to
	 * or for them.
	 */
	set_SG_NORELOC_flags();

#ifndef SA_RLD
	/*
	 * Copy the indirect symbol table into the output file.
	 */
	output_indirect_symbols();
#endif /* SA_RLD */

	/*
	 * Copy the merged symbol table into the output file.
	 */
	output_merged_symbols();

	/*
	 * Copy the headers into the output file.
	 */
	output_headers();

#ifndef RLD
	if(flush){
	    /*
	     * Flush the sections that have been scatter loaded.
	     */
	    flush_scatter_copied_sections();
	    /*
	     * flush the remaining part of the object file that is not a full
	     * page.
	     */
	    final_output_flush();
	}
	else{
	    /*
	     * Write the entire object file.
	     */
	    if(write(fd, output_addr, output_size) != (int)output_size)
		system_fatal("can't write output file");

	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)output_addr,
				  output_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() buffer for output file");
	}
#ifdef F_NOCACHE
	/* re-enable caching of file reads/writes */
	(void)fcntl(fd, F_NOCACHE, 0);
#endif
	if(close(fd) == -1)
	    system_fatal("can't close output file");
#endif /* RLD */
}

#if defined(RLD) && !defined(SA_RLD)
/*
 * pass2_rld_symfile() drives the process to get everything copied into the
 * buffer for the output file.
 */ 
__private_extern__
void
pass2_rld_symfile(void)
{
	/*
	 * Copy the merged symbol table into the output file.
	 */
	output_rld_symfile_merged_symbols();

	/*
	 * Copy the headers into the output file.
	 */
	/* first the mach header */
	memcpy(output_addr, &output_mach_header, sizeof(struct mach_header));

	/* next the symbol table load command */
	memcpy(output_addr + sizeof(struct mach_header),
	       &(output_symtab_info.symtab_command),
	       output_symtab_info.symtab_command.cmdsize);
}
#endif /* defined(RLD) && !defined(SA_RLD) */

/*
 * create_output_sections_array() creates the output_sections array and fills
 * it in with the pointers to the merged sections in the output file.  This 
 * is used by the relocation routines to set the field 'referenced' in the
 * merged section structure by indexing this array (directly without subtracting
 * one from the section number) with the section number of a merged symbol that
 * is refered to in a relocation entry.
 */
__private_extern__
void
create_output_sections_array(void)
{
    unsigned long i, nsects;
    struct merged_segment **p, *msg;
    struct merged_section **content, **zerofill, *ms;

	nsects = 1;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    nsects += msg->sg.nsects;
	    p = &(msg->next);
	}

	output_sections = (struct merged_section **)
			  allocate(nsects * sizeof(struct merged_section *));

	i = 1;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		output_sections[i++] = ms;
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		output_sections[i++] = ms;
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

/*
 * set_SG_NORELOC_flags() sets the SG_NORELOC flag in the segment that have no
 * relocation to or from them.  This uses the fields 'referenced' and
 * 'relocated' in the merged section structures.  The array that was created
 * by the routine create_output_sections_array() to help set the above
 * 'referenced' field is deallocated in here.
 */
static
void
set_SG_NORELOC_flags(void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, **zerofill, *ms;
    enum bool relocated, referenced;

	free(output_sections);
	output_sections = NULL;

	p = &merged_segments;
	while(*p){
	    relocated = FALSE;
	    referenced = FALSE;
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->relocated == TRUE)
		    relocated = TRUE;
		if(ms->referenced == TRUE)
		    referenced = TRUE;
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		/* a zero fill section can't be relocated */
		if(ms->referenced == TRUE)
		    referenced = TRUE;
		zerofill = &(ms->next);
	    }
	    if(relocated == FALSE && referenced == FALSE)
		msg->sg.flags |= SG_NORELOC;
	    p = &(msg->next);
	}
}

#ifndef RLD
/*
 * setup_output_flush() flushes the gaps between things in the file that are
 * holes created by alignment.  This must stay in lock step with the layout
 * routine that lays out the file (layout_segments() in layout.c).
 */
static
void
setup_output_flush(void)
{
    unsigned long offset;
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;

	offset = sizeof(struct mach_header) + output_mach_header.sizeofcmds;

	/* the offsets to the contents of the sections */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->s.size != 0){
		    if(ms->s.offset != offset)
			output_flush(offset, ms->s.offset - offset);
		    offset = ms->s.offset + ms->s.size;
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}

	/* the offsets to the relocation entries */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->s.nreloc != 0){
		    if(ms->s.reloff != offset)
			output_flush(offset, ms->s.reloff - offset);
		    offset = ms->s.reloff +
			     ms->s.nreloc * sizeof(struct relocation_info);
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
	if(output_dysymtab_info.dysymtab_command.nlocrel != 0){
	    output_flush(offset,
			 output_dysymtab_info.dysymtab_command.locreloff -
			 offset);
	    offset = output_dysymtab_info.dysymtab_command.locreloff +
		     output_dysymtab_info.dysymtab_command.nlocrel * 
		     sizeof(struct relocation_info);
	}
	if(output_for_dyld){
	    if(strip_level != STRIP_ALL){
		/* the offset to the symbol table */
		if(output_symtab_info.symtab_command.symoff != offset)
		    output_flush(offset,
			output_symtab_info.symtab_command.symoff - offset);
		offset = output_symtab_info.symtab_command.symoff +
			 output_symtab_info.symtab_command.nsyms *
							sizeof(struct nlist);
	    }
	}
	if(output_for_dyld && twolevel_namespace == TRUE &&
	   twolevel_namespace_hints == TRUE){
	    output_flush(offset,
			 output_hints_info.twolevel_hints_command.offset -
			 offset);
	    offset = output_hints_info.twolevel_hints_command.offset +
		     output_hints_info.twolevel_hints_command.nhints *
		     sizeof(struct twolevel_hint);
	}
	if(output_dysymtab_info.dysymtab_command.nextrel != 0){
	    output_flush(offset,
			 output_dysymtab_info.dysymtab_command.extreloff -
			 offset);
	    offset = output_dysymtab_info.dysymtab_command.extreloff +
		     output_dysymtab_info.dysymtab_command.nextrel *
		     sizeof(struct relocation_info);
	}
	/* the offset to the indirect symbol table */
	if(output_dysymtab_info.dysymtab_command.nindirectsyms != 0){
	    if(output_dysymtab_info.dysymtab_command.indirectsymoff != offset)
		output_flush(offset, output_dysymtab_info.
			     dysymtab_command.indirectsymoff - offset);
	    offset = output_dysymtab_info.dysymtab_command.indirectsymoff +
		     output_dysymtab_info.dysymtab_command.nindirectsyms *
							sizeof(unsigned long);
	}
#ifndef RLD
	/* the offset to the dylib table of contents */
	if(output_dysymtab_info.dysymtab_command.ntoc != 0){
	    if(output_dysymtab_info.dysymtab_command.tocoff != offset)
		output_flush(offset, output_dysymtab_info.
			     dysymtab_command.tocoff - offset);
	    offset = output_dysymtab_info.dysymtab_command.tocoff +
		     output_dysymtab_info.dysymtab_command.ntoc *
					sizeof(struct dylib_table_of_contents);
	}

	/* the offset to the dylib module table */
	if(output_dysymtab_info.dysymtab_command.nmodtab != 0){
	    if(output_dysymtab_info.dysymtab_command.modtaboff != offset)
		output_flush(offset, output_dysymtab_info.
			     dysymtab_command.modtaboff - offset);
	    offset = output_dysymtab_info.dysymtab_command.modtaboff +
		     output_dysymtab_info.dysymtab_command.nmodtab *
					sizeof(struct dylib_module);
	}

	/* the offset to the dylib reference table */
	if(output_dysymtab_info.dysymtab_command.nextrefsyms != 0){
	    if(output_dysymtab_info.dysymtab_command.extrefsymoff != offset)
		output_flush(offset, output_dysymtab_info.
			     dysymtab_command.extrefsymoff - offset);
	    offset = output_dysymtab_info.dysymtab_command.extrefsymoff +
		     output_dysymtab_info.dysymtab_command.nextrefsyms *
					sizeof(struct dylib_reference);
	}
#endif /* !defined(RLD) */

	if(output_for_dyld == FALSE){
	    if(strip_level != STRIP_ALL){
		/* the offset to the symbol table */
		if(output_symtab_info.symtab_command.symoff != offset)
		    output_flush(offset,
			output_symtab_info.symtab_command.symoff - offset);
		offset = output_symtab_info.symtab_command.symoff +
			 output_symtab_info.symtab_command.nsyms *
							sizeof(struct nlist);
	    }
	}

	if(strip_level != STRIP_ALL){
	    /* the offset to the string table */
	    /*
	     * This is flushed to output_symtab_info.symtab_command.stroff plus
	     * output_symtab_info.output_merged_strsize and not just to
	     * output_symtab_info.symtab_command.stroff because the first byte
	     * can't be used to store a string because a symbol with a string
	     * offset of zero (nlist.n_un.n_strx == 0) is defined to be a symbol
	     * with a null name "".  So this byte(s) have to be flushed.
	     */
	    if(output_symtab_info.symtab_command.stroff +
	       output_symtab_info.output_merged_strsize != offset)
		output_flush(offset, output_symtab_info.symtab_command.stroff +
			     output_symtab_info.output_merged_strsize - offset);
	    /* flush the string table pad if any */
	    if(output_symtab_info.output_strpad != 0){
		output_flush(output_symtab_info.symtab_command.stroff +
			     output_symtab_info.symtab_command.strsize -
			     output_symtab_info.output_strpad,
			     output_symtab_info.output_strpad);
	    }
	    offset = output_symtab_info.symtab_command.stroff +
		     output_symtab_info.symtab_command.strsize;
	}

	/* the offset to the end of the file */
	if(offset != output_size)
	    output_flush(offset, output_size - offset);
}

/*
 * output_flush() takes an offset and a size of part of the output file, known
 * in the comments as the new area, and causes any fully flushed pages to be
 * written to the output file the new area in combination with previous areas
 * creates.  The data structure output_blocks has ordered blocks of areas that
 * have been flushed which are maintained by this routine.  Any area can only
 * be flushed once and an error will result is the new area overlaps with a
 * previously flushed area.
 *
 * The goal of this is to again minimize the number of dirty pages the link
 * editor has and hopfully improve performance in a memory starved system and
 * to prevent these pages to be written to the swap area when they could just be
 * written to the output file (if only external pagers worked well ...).
 */
__private_extern__
void
output_flush(
unsigned long offset,
unsigned long size)
{ 
    unsigned long write_offset, write_size;
    struct block **p, *block, *before, *after;
    kern_return_t r;

	if(flush == FALSE)
	    return;

/*
if(offset == 588824 && size != 0)
printf("in output_flush() offset = %lu size = %lu\n", offset, size);
*/

	if(offset + size > output_size)
	    fatal("internal error: output_flush(offset = %lu, size = %lu) out "
		  "of range for output_size = %lu", offset, size, output_size);

#ifdef DEBUG
	if(debug & (1 << 12))
	    print_block_list();
	if(debug & (1 << 11))
	    print("output_flush(offset = %lu, size %lu)", offset, size);
#endif /* DEBUG */

	if(size == 0){
#ifdef DEBUG
	if(debug & (1 << 11))
	    print("\n");
#endif /* DEBUG */
	    return;
	}

	/*
	 * Search through the ordered output blocks to find the block before the
	 * new area and after the new area if any exist.
	 */
	before = NULL;
	after = NULL;
	p = &(output_blocks);
	while(*p){
	    block = *p;
	    if(offset < block->offset){
		after = block;
		break;
	    }
	    else{
		before = block;
	    }
	    p = &(block->next);
	}

	/*
	 * Check for overlap of the new area with the block before and after the
	 * new area if there are such blocks.
	 */
	if(before != NULL){
	    if(before->offset + before->size > offset){
		warning("internal error: output_flush(offset = %lu, size = %lu) "
		      "overlaps with flushed block(offset = %lu, size = %lu)",
		      offset, size, before->offset, before->size);
		printf("calling abort()\n");	
		abort();
	    }
	}
	if(after != NULL){
	    if(offset + size > after->offset){
		warning("internal error: output_flush(offset = %lu, size = %lu) "
		      "overlaps with flushed block(offset = %lu, size = %lu)",
		      offset, size, after->offset, after->size);
		printf("calling abort()\n");	
		abort();
	    }
	}

	/*
	 * Now see how the new area fits in with the blocks before and after it
	 * (that is does it touch both, one or the other or neither blocks).
	 * For each case first the offset and size to write (write_offset and
	 * write_size) are set for the area of full pages that can now be
	 * written from the block.  Then the area written in the block
	 * (->written_offset and ->written_size) are set to reflect the total
	 * area in the block now written.  Then offset and size the block
	 * refers to (->offset and ->size) are set to total area of the block.
	 * Finally the links to others blocks in the list are adjusted if a
	 * block is added or removed.
	 *
	 * See if there is a block before the new area and the new area
	 * starts at the end of that block.
	 */
	if(before != NULL && before->offset + before->size == offset){
	    /*
	     * See if there is also a block after the new area and the new area
	     * ends at the start of that block.
	     */
	    if(after != NULL && offset + size == after->offset){
		/*
		 * This is the case where the new area exactly fill the area
		 * between two existing blocks.  The total area is folded into
		 * the block before the new area and the block after the new
		 * area is removed from the list.
		 */
		if(before->offset == 0 && before->written_size == 0){
		    write_offset = 0;
		    before->written_offset = 0;
		}
		else
		    write_offset =before->written_offset + before->written_size;
		if(after->written_size == 0)
		    write_size = trnc(after->offset + after->size -
				      write_offset, host_pagesize);
		else
		    write_size = trnc(after->written_offset - write_offset,
				      host_pagesize);
		if(write_size != 0){
		    before->written_size += write_size;
		}
		if(after->written_size != 0)
		    before->written_size += after->written_size;
		before->size += size + after->size;

		/* remove the block after the new area */
		before->next = after->next;
		remove_block(after);
	    }
	    else{
		/*
		 * This is the case where the new area starts at the end of the
		 * block just before it but does not end where the block after
		 * it (if any) starts.  The new area is folded into the block
		 * before the new area.
		 */
		write_offset = before->written_offset + before->written_size;
		write_size = trnc(offset + size - write_offset, host_pagesize);
		if(write_size != 0)
		    before->written_size += write_size;
		before->size += size;
	    }
	}
	/*
	 * See if the new area and the new area ends at the start of the block
	 * after it (if any).
	 */
	else if(after != NULL && offset + size == after->offset){
	    /*
	     * This is the case where the new area ends at the begining of the
	     * block just after it but does not start where the block before it.
	     * (if any) ends.  The new area is folded into this block after the
	     * new area.
	     */
	    write_offset = rnd(offset, host_pagesize);
	    if(after->written_size == 0)
		write_size = trnc(after->offset + after->size - write_offset,
				  host_pagesize);
	    else
		write_size = trnc(after->written_offset - write_offset,
				  host_pagesize);
	    if(write_size != 0){
		after->written_offset = write_offset;
		after->written_size += write_size;
	    }
	    else if(write_offset != after->written_offset){
		after->written_offset = write_offset;
	    }
	    after->offset = offset;
	    after->size += size;
	}
	else{
	    /*
	     * This is the case where the new area neither starts at the end of
	     * the block just before it (if any) or ends where the block after
	     * it (if any) starts.  A new block is created and the new area is
	     * is placed in it.
	     */
	    write_offset = rnd(offset, host_pagesize);
	    write_size = trnc(offset + size - write_offset, host_pagesize);
	    block = get_block();
	    block->offset = offset;
	    block->size = size;
	    block->written_offset = write_offset;
	    block->written_size = write_size;
	    /*
	     * Insert this block in the ordered list in the correct place.
	     */
	    if(before != NULL){
		block->next = before->next;
		before->next = block;
	    }
	    else{
		block->next = output_blocks;
		output_blocks = block;
	    }
	}

	/*
	 * Now if there are full pages to write write them to the output file.
	 */
	if(write_size != 0){
#ifdef DEBUG
	if((debug & (1 << 11)) || (debug & (1 << 10)))
	    print(" writing (write_offset = %lu write_size = %lu)\n",
		   write_offset, write_size);
#endif /* DEBUG */
	    lseek(fd, write_offset, L_SET);
	    if(write(fd, output_addr + write_offset, write_size) !=
	       (int)write_size)
		system_fatal("can't write to output file");
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)(output_addr +
				  write_offset), write_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() buffer for output file");
	}
#ifdef DEBUG
	else{
	    if(debug & (1 << 11))
		print(" no write\n");
	}
#endif /* DEBUG */
}

/*
 * final_output_flush() flushes the last part of the last page of the object
 * file if it does not round out to exactly a page.
 */
static
void
final_output_flush(void)
{ 
    struct block *block;
    unsigned long write_offset, write_size;
    kern_return_t r;

#ifdef DEBUG
	/* The compiler "warning: `write_offset' may be used uninitialized in */
	/* this function" can safely be ignored */
	write_offset = 0;
	if((debug & (1 << 11)) || (debug & (1 << 10))){
	    print("final_output_flush block_list:\n");
	    print_block_list();
	}
#endif /* DEBUG */

	write_size = 0;
	block = output_blocks;
	if(block != NULL){
	    if(block->offset != 0)
		fatal("internal error: first block not at offset 0");
	    if(block->written_size != 0){
		if(block->written_offset != 0)
		    fatal("internal error: first block written_offset not 0");
		write_offset = block->written_size;
		write_size = block->size - block->written_size;
	    }
	    else{
		write_offset = block->offset;
		write_size = block->size;
	    }
	    if(block->next != NULL)
		fatal("internal error: more than one block in final list");
	}
	if(write_size != 0){
#ifdef DEBUG
	    if((debug & (1 << 11)) || (debug & (1 << 10)))
		print(" writing (write_offset = %lu write_size = %lu)\n",
		       write_offset, write_size);
#endif /* DEBUG */
	    lseek(fd, write_offset, L_SET);
	    if(write(fd, output_addr + write_offset, write_size) !=
	       (int)write_size)
		system_fatal("can't write to output file");
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)(output_addr +
				  write_offset), write_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() buffer for output file");
	}
}

#ifdef DEBUG
/*
 * print_block_list() prints the list of blocks.  Used for debugging.
 */
static
void
print_block_list(void)
{
    struct block **p, *block;

	p = &(output_blocks);
	if(*p == NULL)
	    print("Empty block list\n");
	while(*p){
	    block = *p;
	    print("block 0x%x\n", (unsigned int)block);
	    print("    offset %lu\n", block->offset);
	    print("    size %lu\n", block->size);
	    print("    written_offset %lu\n", block->written_offset);
	    print("    written_size %lu\n", block->written_size);
	    print("    next 0x%x\n", (unsigned int)(block->next));
	    p = &(block->next);
	}
}
#endif /* DEBUG */

/*
 * get_block() returns a pointer to a new block.  This could be done by
 * allocating block of these placing them on a free list and and handing them
 * out.  The maximum number of blocks needed would be one for each content
 * section, one for each section that has relocation entries (if saving them)
 * and one for the symbol and string table.  For the initial release of this
 * code this number is typicly around 8 it is not a big win so each block is
 * just allocated and free'ed.
 */
static
struct block *
get_block(void)
{
    struct block *block;

	block = allocate(sizeof(struct block));
	return(block);
}

/*
 * remove_block() throws away the block specified.  See comments in get_block().
 */
static
void
remove_block(
struct block *block)
{
	free(block);
}

/*
 * trnc() truncates the value 'v' to the power of two value 'r'.  If v is
 * less than zero it returns zero.
 */
static
unsigned long
trnc(
unsigned long v,
unsigned long r)
{
	if(((long)v) < 0)
	    return(0);
	return(v & ~(r - 1));
}
#endif /* !defined(RLD) */

/*
 * output_headers() copys the headers of the object file into the buffer for
 * the output file.
 */
static
void
output_headers(void)
{
    unsigned long header_offset;
    struct merged_segment **p, *msg;
    struct merged_section **content, **zerofill, *ms;
#ifndef RLD
    unsigned long i;
    struct merged_fvmlib **q, *mfl;
    struct dylinker_command *dyld;
    struct merged_dylib *mdl;
    struct dylib_command *dl;
    struct dynamic_library *dp;
    enum bool some_symbols_referenced, some_non_weak_refs;
#endif /* !defined(RLD) */
    struct mach_header *mh;
    struct load_command *lc;

	header_offset = 0;

	/* first the mach header */
	mh = (struct mach_header *)output_addr;
	memcpy(mh, &output_mach_header, sizeof(struct mach_header));
	header_offset += sizeof(struct mach_header);
	lc = (struct load_command *)(output_addr + header_offset);

	/* next the segment load commands (and section structures) */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    memcpy(output_addr + header_offset, &(msg->sg),
		   sizeof(struct segment_command));
	    header_offset += sizeof(struct segment_command);
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		memcpy(output_addr + header_offset, &(ms->s),
		       sizeof(struct section));
		header_offset += sizeof(struct section);
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		memcpy(output_addr + header_offset, &(ms->s),
		       sizeof(struct section));
		header_offset += sizeof(struct section);
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}

#ifndef RLD
	/* next the fixed VM shared library load commands */
	q = &merged_fvmlibs;
	while(*q){
	    mfl = *q;
	    memcpy(output_addr + header_offset, mfl->fl, mfl->fl->cmdsize);
	    header_offset += mfl->fl->cmdsize;
	    q = &(mfl->next);
	}

	/* next the dynamic linker load command */
	if(merged_dylinker != NULL){
	    memcpy(output_addr + header_offset, merged_dylinker->dyld,
		   merged_dylinker->dyld->cmdsize);
	    if(filetype != MH_DYLINKER){
		dyld = (struct dylinker_command *)(output_addr + header_offset);
		dyld->cmd = LC_LOAD_DYLINKER;
	    }
	    header_offset += merged_dylinker->dyld->cmdsize;
	}

	/* next the dynamicly linked shared library load commands */
	mdl = merged_dylibs;
	while(mdl != NULL){
	    memcpy(output_addr + header_offset, mdl->dl, mdl->dl->cmdsize);
	    if(mdl->output_id == FALSE){
		dl = (struct dylib_command *)(output_addr + header_offset);
		/*
		 * Propagate the some_non_weak_refs and some_non_weak_refs 
		 * booleans up through the sub images for this dylib.
		 */
		some_symbols_referenced =
		    mdl->dynamic_library->some_symbols_referenced;
		some_non_weak_refs = 
		    mdl->dynamic_library->some_non_weak_refs;
		for(i = 0; i < mdl->dynamic_library->nsub_images; i++){
		    if(mdl->dynamic_library->sub_images[i]->
		       some_symbols_referenced == TRUE){
			some_symbols_referenced = TRUE;
			if(mdl->dynamic_library->sub_images[i]->
			   some_non_weak_refs == TRUE)
			    some_non_weak_refs = TRUE;
		    }
		}
		if((some_symbols_referenced == TRUE &&
		    some_non_weak_refs == FALSE) ||
		    mdl->dynamic_library->force_weak_dylib == TRUE){
		    if(macosx_deployment_target.major >= 2){
			dl->cmd = LC_LOAD_WEAK_DYLIB;
		    }
		    else{
			warning("dynamic shared library: %s not made a weak "
				"library in output with "
				"MACOSX_DEPLOYMENT_TARGET environment variable "
				"set to: %s", mdl->definition_object->file_name,
				macosx_deployment_target.name);
			dl->cmd = LC_LOAD_DYLIB;
		    }
		}
		else
		    dl->cmd = LC_LOAD_DYLIB;
	    }
	    header_offset += mdl->dl->cmdsize;
	    mdl = mdl->next;
	}

	/* next the sub framework load command */
	if(merged_sub_framework != NULL){
	    memcpy(output_addr + header_offset, merged_sub_framework->sub,
		   merged_sub_framework->sub->cmdsize);
	    header_offset += merged_sub_framework->sub->cmdsize;
	}

	/* next the sub umbrella load commands */
	for(i = 0; i < nsub_umbrellas ; i++){
	    memcpy(output_addr + header_offset, merged_sub_umbrellas[i].sub,
		   merged_sub_umbrellas[i].sub->cmdsize);
	    header_offset += merged_sub_umbrellas[i].sub->cmdsize;
	}

	/* next the sub library load commands */
	for(i = 0; i < nsub_librarys ; i++){
	    memcpy(output_addr + header_offset, merged_sub_librarys[i].sub,
		   merged_sub_librarys[i].sub->cmdsize);
	    header_offset += merged_sub_librarys[i].sub->cmdsize;
	}

	/* next the sub client load commands */
	for(i = 0; i < nallowable_clients ; i++){
	    memcpy(output_addr + header_offset, merged_sub_clients[i].sub,
		   merged_sub_clients[i].sub->cmdsize);
	    header_offset += merged_sub_clients[i].sub->cmdsize;
	}

	/* next the prebound dynamic libraries load commands */
	if(filetype == MH_EXECUTE){
	    for(dp = dynamic_libs; dp != NULL; dp = dp->next){
		if(dp->type == DYLIB){
		    if(dp->pbdylib != NULL){
			memcpy(output_addr + header_offset, dp->pbdylib,
			       dp->pbdylib->cmdsize);
			header_offset += dp->pbdylib->cmdsize;
		    }
		}
	    }
	}
#endif /* !defined(RLD) */

	/* next the symbol table load command */
	memcpy(output_addr + header_offset,
	       &(output_symtab_info.symtab_command),
	       output_symtab_info.symtab_command.cmdsize);
	header_offset += output_symtab_info.symtab_command.cmdsize;

	/* next the dysymbol table load command */
	if(nindirectsyms != 0 || output_for_dyld){
	    memcpy(output_addr + header_offset,
		   &(output_dysymtab_info.dysymtab_command),
		   output_dysymtab_info.dysymtab_command.cmdsize);
	    header_offset += output_dysymtab_info.dysymtab_command.cmdsize;
	}

	/* next the two-level namespace hints load command */
	if(output_for_dyld && twolevel_namespace == TRUE &&
	   twolevel_namespace_hints == TRUE){
	    memcpy(output_addr + header_offset,
	    	   &(output_hints_info.twolevel_hints_command),
		   output_hints_info.twolevel_hints_command.cmdsize);
	    header_offset += output_hints_info.twolevel_hints_command.cmdsize;
	}

	/* next the prebind cksum load command */
	if(output_cksum_info.prebind_cksum_command.cmdsize != 0){
	    memcpy(output_addr + header_offset,
	    	   &(output_cksum_info.prebind_cksum_command),
		   output_cksum_info.prebind_cksum_command.cmdsize);
	    header_offset += output_cksum_info.prebind_cksum_command.cmdsize;
	}

	/* next the uuid load command */
	if(output_uuid_info.uuid_command.cmdsize != 0){
	    memcpy(output_addr + header_offset,
	    	   &(output_uuid_info.uuid_command),
		   output_uuid_info.uuid_command.cmdsize);
	    header_offset += output_uuid_info.uuid_command.cmdsize;
	}

	/* next the thread command if the output file has one */
	if(output_thread_info.thread_in_output == TRUE){
	    /* the thread command itself */
	    memcpy(output_addr + header_offset,
		   &(output_thread_info.thread_command),
		   sizeof(struct thread_command));
	    header_offset += sizeof(struct thread_command);
	    /* the flavor of the thread state */
	    memcpy(output_addr + header_offset, &(output_thread_info.flavor),
		   sizeof(long));
	    header_offset += sizeof(long);
	    /* the count of longs of the thread state */
	    memcpy(output_addr + header_offset, &(output_thread_info.count),
		   sizeof(long));
	    header_offset += sizeof(long);
	    /* the thread state */
	    memcpy(output_addr + header_offset, output_thread_info.state,
		   output_thread_info.count * sizeof(long));
	    header_offset += output_thread_info.count * sizeof(long);
	    /* the second thread state if any */
	    if(output_thread_info.second_count != 0){
		/* the flavor of the second thread state */
		memcpy(output_addr + header_offset,
		       &(output_thread_info.second_flavor),
		       sizeof(long));
		header_offset += sizeof(long);
		/* the count of longs of the second thread state */
		memcpy(output_addr + header_offset,
		       &(output_thread_info.second_count),
		       sizeof(long));
		header_offset += sizeof(long);
		/* the second thread state */
		memcpy(output_addr + header_offset,
		       output_thread_info.second_state,
		       output_thread_info.second_count * sizeof(long));
		header_offset += output_thread_info.second_count * sizeof(long);
	    }
	}
	/* next the routines command if the output file has one */
	if(output_routines_info.routines_in_output == TRUE){
	    memcpy(output_addr + header_offset,
		   &(output_routines_info.routines_command),
		   sizeof(struct routines_command));
	    header_offset += sizeof(struct routines_command);
	}
	if(host_byte_sex != target_byte_sex)
	    if(swap_object_headers(mh, lc) == FALSE)
		fatal("internal error: swap_object_headers() failed in "
		      "output_headers()");
#ifndef RLD
	output_flush(0, sizeof(struct mach_header) +
			output_mach_header.sizeofcmds);
#endif /* !defined(RLD) */
}
                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/pass2.h                                  0100644 0001750 0001750 00000003323 12612724205 022240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * The total size of the output file and the memory buffer for the output file.
 */
__private_extern__ unsigned long output_size;
__private_extern__ char *output_addr;

/*
 * This is used to setting the SG_NORELOC flag in the segment flags correctly.
 * See the comments in the file pass2.c where this is defined.
 */
__private_extern__ struct merged_section **output_sections;

__private_extern__ void pass2(
    void);
#if defined(RLD) && !defined(SA_RLD)
__private_extern__ void pass2_rld_symfile(
    void);
#endif /* defined(RLD) && !defined(SA_RLD) */
__private_extern__ void output_flush(
    unsigned long offset,
    unsigned long size);
                                                                                                                                                                                                                                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/ppc_reloc.c                              0100644 0001750 0001750 00000137500 12612724205 023156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to do relocation for the ppc.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/ppc/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "ppc_reloc.h"
#include "indirect_sections.h"
#include "dylibs.h"

#define U_ABS(l) (((long)(l))<0 ? (unsigned long)(-(l)) : (l))

/*
 * ppc_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 *
 * Or if refs is not NULL it is being called by to get the addresses or
 * merged_symbols from the item being referenced by the relocation entry(s) at
 * reloc_index. This is used by mark_fine_relocs_references_live() when
 * -dead_strip is specified to determined what is being referenced and is only
 * called when all sections have fine_relocs (that is why refs is only filled
 * in when nfine_relocs != 0). When refs is not NULL, only refs is filled in
 * and returned and the contents are not relocated.
 */
__private_extern__
void
ppc_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map,
struct live_refs *refs,
unsigned long reloc_index)
{
    unsigned long i, j, symbolnum, value, input_pc, output_pc;
    unsigned long instruction, immediate;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_ppc r_type, pair_r_type;
    unsigned long other_half;
    unsigned long offset;
    unsigned long br14_disp_sign;

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler "warnings: ... may be used uninitialized in this
	 * function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	instruction = 0;
	other_half = 0;
	immediate = 0;
	offset = 0;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	pair_local_map = NULL;
#endif /* defined(DEBUG) || defined(RLD) */

	if(refs != NULL)
	    memset(refs, '\0', sizeof(struct live_refs));
	else
	    reloc_index = 0;
	for(i = reloc_index; i < section_map->s->nreloc; i++){
	    br14_disp_sign = 0;
	    force_extern_reloc = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_ppc)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a PPC_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * PPC_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A PPC_RELOC_PAIR
		 * only follows PPC_RELOC_{HI16,LO16,HA16,LO14,JBSR,SECTDIFF,
		 * HI16_SECTDIFF,LO16_SECTDIFF,HA16_SECTDIFF} relocation types
		 * and it is an error to see one otherwise.
		 */
		if(r_type == PPC_RELOC_PAIR){
		    error_with_cur_obj("stray relocation PPC_RELOC_PAIR entry "
			"(%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_ppc)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * PPC_RELOC_PAIR relocation types only follows PPC_RELOC_{HI16,
	     * LO16,HA16,LO14,JBSR,SECTDIFF,HI16_SECTDIFF,LO16_SECTDIFF,
	     * HA16_SECTDIFF} relocation types and it is an error to see one
	     * otherwise.
	     */
	    if(r_type == PPC_RELOC_PAIR){
		error_with_cur_obj("stray relocation PPC_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section (Note
	     * that this is not the case for PPC_RELOC_PAIR entries but this
	     * can't be one with the above checks).
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.
	     */
	    pair_r_type = (enum reloc_type_ppc)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == PPC_RELOC_HI16 || r_type == PPC_RELOC_LO16 ||
	       r_type == PPC_RELOC_HA16 || r_type == PPC_RELOC_LO14 ||
	       r_type == PPC_RELOC_JBSR){
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc  = NULL;
			pair_r_type = (enum reloc_type_ppc)spair_reloc->r_type;
			if(r_type == PPC_RELOC_JBSR)
			    other_half = spair_reloc->r_value;
			else
			    other_half = spair_reloc->r_address & 0xffff;
		    }
		    else{
			pair_r_type = (enum reloc_type_ppc)pair_reloc->r_type;
			if(r_type == PPC_RELOC_JBSR)
			    other_half = pair_reloc->r_address;
			else
			    other_half = pair_reloc->r_address & 0xffff;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != PPC_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"PPC_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
	    }
	    else if(r_type == PPC_RELOC_SECTDIFF ||
		    r_type == PPC_RELOC_LOCAL_SECTDIFF ||
		    r_type == PPC_RELOC_HI16_SECTDIFF ||
		    r_type == PPC_RELOC_LO16_SECTDIFF ||
		    r_type == PPC_RELOC_LO14_SECTDIFF ||
		    r_type == PPC_RELOC_HA16_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is PPC_RELOC_SECTDIFF but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_ppc)spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
			other_half = spair_reloc->r_address;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != PPC_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"PPC_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry (or scattered entry).
	     */
	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in ppc_reloc() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in ppc_reloc() symbol index %lu "
			    "in above file not in undefined map", symbolnum);
		    }
		}
		if(refs == NULL && 
		   ((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		    (get_output_section(merged_symbol->nlist.n_sect)->
		     flags & SECTION_TYPE) == S_COALESCED)){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;

		/*
		 * If we are being called only to get the references for this
		 * relocation entry fill it in and return.
		 */
		if(refs != NULL){
		    refs->ref1.ref_type = LIVE_REF_SYMBOL;
		    refs->ref1.merged_symbol = merged_symbol;
		    refs->ref2.ref_type = LIVE_REF_NONE;
		    return;
		}

		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    input_pc = section_map->s->addr + r_address;
		    if(r_type == PPC_RELOC_VANILLA){
			switch(r_length){
			case 0: /* byte */
			    offset = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    offset = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    offset = get_long((long *)(contents + r_address));
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
			if(r_pcrel)
			    offset += input_pc;
		    }
		    else{
			instruction = get_long((long *)(contents + r_address));
			switch(r_type){
			case PPC_RELOC_HI16:
			    offset = ((instruction & 0xffff) << 16) |
				     other_half;
			    break;
			case PPC_RELOC_LO16:
			    offset = (other_half << 16) |
				     (instruction & 0xffff);
			    break;
			case PPC_RELOC_HA16:
			    if((other_half & 0x00008000) != 0)
				offset = ((instruction & 0xffff) << 16) +
					 (0xffff0000 + other_half);
			    else
				offset = ((instruction & 0xffff) << 16) +
					 other_half;
			    break;
			case PPC_RELOC_LO14:
			    offset = (other_half << 16) |
				     (instruction & 0xfffc);
			    break;
			case PPC_RELOC_BR14:
			    offset = instruction & 0xfffc;
			    /* sign extend if needed */
			    br14_disp_sign = (offset & 0x8000);
			    if(br14_disp_sign != 0)
				    offset |= 0xffff0000;
			    if(r_pcrel)
				offset += input_pc;
			    break;
			case PPC_RELOC_BR24:
			    offset = instruction & 0x03fffffc;
			    /* sign extend if needed */
			    if((offset & 0x02000000) != 0)
				offset |= 0xfc000000;
			    if(r_pcrel)
				offset += input_pc;
			    break;
			case PPC_RELOC_JBSR:
			    offset = other_half;
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
		    }
		}

		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT)
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum == R_ABS){
		    /*
		     * If we are being called only to get the references for
		     * this relocation entry fill in it has none and return.
		     */
		    if(refs != NULL){
			refs->ref1.ref_type = LIVE_REF_NONE;
			refs->ref2.ref_type = LIVE_REF_NONE;
			return;
		    }
		}
		else{
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    if(local_map->s->flags & S_ATTR_DEBUG){
			error_with_cur_obj("illegal reference to debug section,"
			    " from non-debug section (%.16s,%.16s) via "
			    "relocation entry (%lu) to section (%.16s,%.16s)",
			    section_map->s->segname, section_map->s->sectname,
			    i, local_map->s->segname, local_map->s->sectname);
			return;
		    }
		    pair_local_map = NULL;
		    if(r_type == PPC_RELOC_SECTDIFF ||
		       r_type == PPC_RELOC_LOCAL_SECTDIFF ||
		       r_type == PPC_RELOC_HI16_SECTDIFF ||
		       r_type == PPC_RELOC_LO16_SECTDIFF ||
		       r_type == PPC_RELOC_LO14_SECTDIFF ||
		       r_type == PPC_RELOC_HA16_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
			if(pair_local_map->s->flags & S_ATTR_DEBUG){
			    error_with_cur_obj("illegal reference to debug "
				"section, from non-debug section (%.16s,%.16s) "
				"via relocation entry (%lu) to section (%.16s,"
				"%.16s)", section_map->s->segname,
				section_map->s->sectname, i,
				pair_local_map->s->segname,
				pair_local_map->s->sectname);
			    return;
			}
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == PPC_RELOC_SECTDIFF ||
			   r_type == PPC_RELOC_LOCAL_SECTDIFF ||
			   r_type == PPC_RELOC_HI16_SECTDIFF ||
			   r_type == PPC_RELOC_LO16_SECTDIFF ||
			   r_type == PPC_RELOC_LO14_SECTDIFF ||
			   r_type == PPC_RELOC_HA16_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation the value is set (not adjusted
			 * with addition).  So the new value is directly
			 * calculated from the old value.
			 */
			if(r_pcrel){
			    input_pc = section_map->s->addr +
				       r_address;
			    if(section_map->nfine_relocs == 0)
				output_pc = section_map->output_section->s.addr
					    + section_map->offset +
					    r_address;
			    else
				output_pc = section_map->output_section->s.addr
					    + 
					fine_reloc_output_offset(section_map,
								 r_address);
			}
			else{
			    input_pc = 0;
			    output_pc = 0;
			}
			/*
			 * Get the value of the expresion of the item to be
			 * relocated.
			 */
			if(r_type == PPC_RELOC_VANILLA ||
			   r_type == PPC_RELOC_SECTDIFF ||
			   r_type == PPC_RELOC_LOCAL_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				value = get_byte((char *)(contents +
							  r_address));
				break;
			    case 1: /* word (2 byte) */
				value = get_short((short *)(contents +
							    r_address));
				break;
			    case 2: /* long (4 byte) */
				value = get_long((long *)(contents +
							  r_address));
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			else{
			    instruction = get_long((long *)(contents +
							    r_address));
			    switch(r_type){
			    case PPC_RELOC_HI16:
			    case PPC_RELOC_HI16_SECTDIFF:
				value = ((instruction & 0xffff) << 16) |
					other_half;
				break;
			    case PPC_RELOC_LO16:
			    case PPC_RELOC_LO16_SECTDIFF:
				value = (other_half << 16) |
					(instruction & 0xffff);
				break;
			    case PPC_RELOC_HA16:
			    case PPC_RELOC_HA16_SECTDIFF:
				if((other_half & 0x00008000) != 0)
				    value = ((instruction & 0xffff) << 16) +
					    (0xffff0000 + other_half);
				else
				    value = ((instruction & 0xffff) << 16) +
					    other_half;
				break;
			    case PPC_RELOC_LO14:
			    case PPC_RELOC_LO14_SECTDIFF:
				value = (other_half << 16) |
					(instruction & 0xfffc);
				break;
			    case PPC_RELOC_BR14:
				value = instruction & 0xfffc;
				br14_disp_sign = (value & 0x8000);
				if(br14_disp_sign != 0)
				    value |= 0xffff0000;
				break;
			    case PPC_RELOC_BR24:
				value = instruction & 0x03fffffc;
				if((value & 0x02000000) != 0)
				    value |= 0xfc000000;
				break;
			    case PPC_RELOC_JBSR:
			        value = other_half;
			        break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			if(r_type == PPC_RELOC_SECTDIFF ||
			   r_type == PPC_RELOC_LOCAL_SECTDIFF ||
			   r_type == PPC_RELOC_HI16_SECTDIFF ||
			   r_type == PPC_RELOC_LO16_SECTDIFF ||
			   r_type == PPC_RELOC_LO14_SECTDIFF ||
			   r_type == PPC_RELOC_HA16_SECTDIFF){
			    /*
			     * For PPC_RELOC_SECTDIFF's the item to be
			     * relocated, in value, is the value of the
			     * expression:
			     *     r_value - pair_r_value + offset
			     * To set the value of the relocated expression,
			     * it is set from relocating the two r_value's and
			     * adding back in the offset.  So here get the
			     * offset from the value of the expression.
			     */
			    value += input_pc; /* adjust for pcrel */
			    offset = value - r_value + pair_r_value;

			    /*
			     * If we are being called only to get the references
			     * for this relocation entry fill it in and return.
			     */
			    if(refs != NULL){
				fine_reloc_output_ref(
				    local_map,
				    r_value - local_map->s->addr,
				    &(refs->ref1) );
				fine_reloc_output_ref(
				    local_map,
				    pair_r_value - local_map->s->addr,
				    &(refs->ref2) );
				return;
			    }

			    /*
			     * Now build up the value of the relocated
			     * expression one part at a time.  First set the
			     * new value to the relocated r_value.
			     */
		    	    if(local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    local_map, r_value - local_map->s->addr +
				    offset, i,
				    r_type != PPC_RELOC_LOCAL_SECTDIFF);
				value = fine_reloc_output_address(local_map,
					    r_value - local_map->s->addr,
					    local_map->output_section->s.addr);
			    }
			    else{
				value = local_map->output_section->s.addr +
					local_map->offset +
					r_value - local_map->s->addr;
			    }
			    /* Second subtract the relocated pair_r_value. */
			    if(pair_local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    pair_local_map, pair_r_value -
				    pair_local_map->s->addr, i, TRUE);
				value -=
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
				        pair_local_map->output_section->s.addr);
			    }
			    else{
				value -=
				    pair_local_map->output_section->s.addr +
				    pair_local_map->offset +
				    pair_r_value - pair_local_map->s->addr;
			    }
			    /* Third add in the offset. */
			    value += offset;
			    value -= output_pc; /* adjust for pcrel */
			}
			else{
			    /*
			     * If the relocation entry is not a scattered
			     * relocation entry then the relocation is based on
			     * the value of value of the expresion of the item
			     * to be relocated.  If it is a scattered relocation
			     * entry then the relocation is based on the r_value
			     * in the relocation entry and the offset part of
			     * the expression at the item to be relocated is
			     * extracted so it can be added after the relocation
			     * is done.
			     */
			    value += input_pc;
			    if(r_scattered == 0){
				r_value = value;
				offset = 0;
			    }
			    else{
				offset = value - r_value;
			    }
			    /*
			     * Check to see if this reference is legal with
			     * respect to indirect sections.
			     */
			    legal_reference(section_map, r_address, local_map,
				    r_value - local_map->s->addr + offset, i,
				    FALSE);

			    /*
			     * If we are being called only to get the references
			     * for this relocation entry fill it in and return.
			     */
			    if(refs != NULL){
				fine_reloc_output_ref(
				    local_map,
				    r_value - local_map->s->addr,
				    &(refs->ref1) );
				refs->ref2.ref_type = LIVE_REF_NONE;
				return;
			    }

			    value = fine_reloc_output_address(local_map,
					r_value - local_map->s->addr,
					local_map->output_section->s.addr);
			    value -= output_pc;
			    value += offset;
			}
			if(r_type == PPC_RELOC_VANILLA ||
			   r_type == PPC_RELOC_LOCAL_SECTDIFF ||
			   r_type == PPC_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				if( (value & 0xffffff00) &&
				   ((value & 0xffffff80) != 0xffffff80))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 1 byte", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_byte((char *)(contents + r_address), value);
				break;
			    case 1: /* word (2 byte) */
				if( (value & 0xffff0000) &&
				   ((value & 0xffff8000) != 0xffff8000))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 2 bytes", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_short((short *)(contents + r_address),
					  value);
				break;
			    case 2: /* long (4 byte) */
				set_long((long *)(contents + r_address), value);
				break;
			    default:
				error_with_cur_obj("r_length field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			}
			else{
			    switch(r_type){
			    case PPC_RELOC_HI16:
			    case PPC_RELOC_HI16_SECTDIFF:
				other_half = value & 0xffff;
				instruction = (instruction & 0xffff0000) |
					      ((value >> 16) & 0xffff);
				break;
			    case PPC_RELOC_LO16:
			    case PPC_RELOC_LO16_SECTDIFF:
				other_half = (value >> 16) & 0xffff;
				instruction = (instruction & 0xffff0000) |
					      (value & 0xffff);
				break;
			    case PPC_RELOC_HA16:
			    case PPC_RELOC_HA16_SECTDIFF:
				other_half = value & 0xffff;
				if((value & 0x00008000) != 0)
				    instruction = (instruction & 0xffff0000) |
				        (((value + 0x00008000) >> 16) & 0xffff);
				else
				    instruction = (instruction & 0xffff0000) |
						  ((value >> 16) & 0xffff);
				break;
			    case PPC_RELOC_LO14:
			    case PPC_RELOC_LO14_SECTDIFF:
				if((value & 0x3) != 0)
				    error_with_cur_obj("relocation error "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (relocated value not a "
					"multiple of 4 bytes)", i,
					section_map->s->segname,
					section_map->s->sectname);
				other_half = (value >> 16) & 0xffff;
				instruction = (instruction & 0xffff0003) |
					      (value & 0xfffc);
				break;
			    case PPC_RELOC_BR14:
				br14_disp_sign = (instruction & 0x8000);
				if((value & 0x3) != 0)
				    error_with_cur_obj("relocation error "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement not a "
					"multiple of 4 bytes)", i,
					section_map->s->segname,
					section_map->s->sectname);
				if((value & 0xffff8000) != 0xffff8000 &&
				   (value & 0xffff8000) != 0x00000000)
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
				instruction = (instruction & 0xffff0003) |
					      (value & 0xfffc);
				/*
				 * If this is a predicted branch conditional
				 * (r_length is 3) where the branch condition
				 * is not branch always and the sign of the
				 * displacement is different after relocation
				 * then flip the Y-bit to preserve the sense of
				 * the branch prediction. 
				 */
				if(r_length == 3 &&
				   (instruction & 0xfc000000) == 0x40000000 &&
				   (instruction & 0x03e00000) != 0x02800000 &&
				   (instruction & 0x00008000) != br14_disp_sign)
				    instruction ^= (1 << 21);
				break;
			    case PPC_RELOC_BR24:
				if((value & 0x3) != 0)
				    error_with_cur_obj("relocation error "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement not a "
					"multiple of 4 bytes)", i,
					section_map->s->segname,
					section_map->s->sectname);
				if((value & 0xfe000000) != 0xfe000000 &&
				   (value & 0xfe000000) != 0x00000000)
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
				instruction = (instruction & 0xfc000003) |
					      (value & 0x03fffffc);
				break;
			    case PPC_RELOC_JBSR:
				other_half = value;

				if(section_map->nfine_relocs == 0)
				    value -= section_map->output_section->s.addr
					     + section_map->offset + r_address;
				else
				    value -= section_map->output_section->s.addr
					     + fine_reloc_output_offset(
						    section_map, r_address);
				if(save_reloc == 0 &&
				   (output_for_dyld == FALSE || r_extern == 0 ||
				    (merged_symbol->nlist.n_type & N_TYPE) !=
								N_UNDF) &&
				   (U_ABS(value) <= 0x01ffffff)){
				    instruction = (instruction & 0xfc000003) |
						  (value & 0x03fffffc);
				}
				break;
			    default:
				error_with_cur_obj("r_type field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			    set_long((long *)(contents + r_address),
				     instruction);
			}

			goto update_reloc;
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr /* + r_address */
			     - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else
		    value += + section_map->s->addr + r_address
			     - (section_map->output_section->s.addr +
			        fine_reloc_output_offset(section_map,
							 r_address));
	    }
	    if(r_type == PPC_RELOC_VANILLA ||
	       r_type == PPC_RELOC_LOCAL_SECTDIFF ||
	       r_type == PPC_RELOC_SECTDIFF){
		switch(r_length){
		case 0: /* byte */
		    value += get_byte((char *)(contents + r_address));
		    if( (value & 0xffffff00) &&
		       ((value & 0xffffff80) != 0xffffff80))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 1 byte", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_byte((char *)(contents + r_address), value);
		    break;
		case 1: /* word (2 byte) */
		    value += get_short((short *)(contents + r_address));
		    if( (value & 0xffff0000) &&
		       ((value & 0xffff8000) != 0xffff8000))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 2 bytes", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_short((short *)(contents + r_address), value);
		    break;
		case 2: /* long (4 byte) */
		    value += get_long((long *)(contents + r_address));
		    set_long((long *)(contents + r_address), value);
		    break;
		default:
		    error_with_cur_obj("r_length field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * Do ppc specific relocation based on the r_type.
	     */
	    else{
		instruction = get_long((long *)(contents + r_address));
		switch(r_type){
		case PPC_RELOC_HI16:
		case PPC_RELOC_HI16_SECTDIFF:
		    immediate = ((instruction & 0xffff) << 16) |
				other_half;
		    immediate += value;
		    instruction = (instruction & 0xffff0000) |
				  ((immediate >> 16) & 0xffff);
		    other_half = immediate & 0xffff;
		    break;
		case PPC_RELOC_LO16:
		case PPC_RELOC_LO16_SECTDIFF:
		    immediate = (other_half << 16) |
				(instruction & 0xffff);
		    immediate += value;
		    instruction = (instruction & 0xffff0000) |
				  (immediate & 0xffff);
		    other_half = (immediate >> 16) & 0xffff;
		    break;
		case PPC_RELOC_HA16:
		case PPC_RELOC_HA16_SECTDIFF:
		    if((other_half & 0x00008000) != 0)
			immediate = ((instruction & 0xffff) << 16) +
				    (0xffff0000 + other_half);
		    else
			immediate = ((instruction & 0xffff) << 16) +
				    (other_half);
		    immediate += value;
		    if((immediate & 0x00008000) != 0)
			instruction = (instruction & 0xffff0000) |
				  (((immediate + 0x00008000) >> 16) & 0xffff);
		    else
			instruction = (instruction & 0xffff0000) |
				      ((immediate >> 16) & 0xffff);
		    other_half = immediate & 0xffff;
		    break;
		case PPC_RELOC_LO14:
		case PPC_RELOC_LO14_SECTDIFF:
		    immediate = (other_half << 16) |
				(instruction & 0xfffc);
		    immediate += value;
		    if((immediate & 0x3) != 0)
			error_with_cur_obj("relocation error for relocation "
			    "entry %lu in section (%.16s,%.16s) (relocated "
			    "value not a multiple of 4 bytes)", i,
			    section_map->s->segname, section_map->s->sectname);
		    instruction = (instruction & 0xffff0003) |
				  (immediate & 0xfffc);
		    other_half = (immediate >> 16) & 0xffff;
		    break;
		case PPC_RELOC_BR14:
		    br14_disp_sign = (instruction & 0x8000);
		    immediate = instruction & 0xfffc;
		    if((immediate & 0x8000) != 0)
			    immediate |= 0xffff0000;
		    immediate += value;
		    if((immediate & 0x3) != 0)
			error_with_cur_obj("relocation error for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "not a multiple of 4 bytes)", i,
			    section_map->s->segname, section_map->s->sectname);
		    if((immediate & 0xffff8000) != 0xffff8000 &&
		       (immediate & 0xffff8000) != 0x00000000)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    instruction = (instruction & 0xffff0003) |
				  (immediate & 0xfffc);
		    /*
		     * If this is a predicted branch conditional
		     * (r_length is 3) where the branch condition
		     * is not branch always and the sign of the
		     * displacement is different after relocation
		     * then flip the Y-bit to preserve the sense of
		     * the branch prediction. 
		     */
		    if(r_length == 3 &&
		       (instruction & 0xfc000000) == 0x40000000 &&
		       (instruction & 0x03e00000) != 0x02800000 &&
		       (instruction & 0x00008000) != br14_disp_sign)
			instruction ^= (1 << 21);
		    break;
		    break;
		case PPC_RELOC_BR24:
		    immediate = instruction & 0x03fffffc;
		    if((immediate & 0x02000000) != 0)
			immediate |= 0xfc000000;
		    immediate += value;
		    if((immediate & 0x3) != 0)
			error_with_cur_obj("relocation error for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "not a multiple of 4 bytes)", i,
			    section_map->s->segname, section_map->s->sectname);
		    if((immediate & 0xfe000000) != 0xfe000000 &&
		       (immediate & 0xfe000000) != 0x00000000)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    instruction = (instruction & 0xfc000003) |
		    		  (immediate & 0x03fffffc);
		    break;
		case PPC_RELOC_JBSR:
		    value += other_half;
		    other_half = value;
		    if(section_map->nfine_relocs == 0)
			value += - (section_map->output_section->s.addr +
				    section_map->offset + r_address);
		    else
			value += - (section_map->output_section->s.addr +
				    fine_reloc_output_offset(section_map,
							     r_address));
		    if(save_reloc == 0 &&
		       (output_for_dyld == FALSE || r_extern == 0 ||
			(merged_symbol->nlist.n_type & N_TYPE) != N_UNDF) &&
		       (U_ABS(value) <= 0x01ffffff)){
			instruction = (instruction & 0xfc000003) |
				      (value & 0x03fffffc);
		    }
		    break;
		default:
		    error_with_cur_obj("r_type field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		set_long((long *)(contents + r_address), instruction);
	    }

	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
update_reloc:
	    ;
#ifndef RLD
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a PPC_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = PPC_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		            (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		            force_extern_reloc == FALSE &&
		            ((filetype != MH_DYLIB ||
			      multi_module_dylib == FALSE) ||
			     (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value and the output is not for
			     * dyld make it a scattered relocation entry else
			     * make it a local relocation entry.
			     */
			    if(offset == 0 || output_for_dyld){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = r_type;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a PPC_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = PPC_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    else if(reloc->r_symbolnum != R_ABS){
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		}
		else{
		    /*
		     * This is a scattered relocation entry.  If the output is
		     * for dyld convert it to a local relocation entry so as
		     * to not overflow the 24-bit r_address field in a scattered
		     * relocation entry.  The overflow would happen in
		     * reloc_output_for_dyld() in sections.c when it adjusts
		     * the r_address fields of the relocation entries.
		     */
		    if(output_for_dyld){
			reloc = (struct relocation_info *)sreloc;
			r_scattered = 0;
			reloc->r_address = r_address;
			reloc->r_pcrel = r_pcrel;
			reloc->r_extern = 0;
			reloc->r_length = r_length;
			reloc->r_type = r_type;
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		    else{
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(local_map->nfine_relocs == 0)
			    sreloc->r_value +=
					   - local_map->s->addr
					   + local_map->output_section->s.addr +
					   local_map->offset;
			else
			    sreloc->r_value =
					fine_reloc_output_address(local_map,
						r_value - local_map->s->addr,
					   local_map->output_section->s.addr);
		    }
		}
		/*
		 * If this section that the reloation is being done for has fine
		 * relocation then the offset in the r_address field has to be
		 * set to where it will end up in the output file.  Otherwise
		 * it simply has to have the offset to where this contents
		 * appears in the output file. 
		 */
		if(r_scattered == 0){
		    if(section_map->nfine_relocs == 0){
			reloc->r_address += section_map->offset;
		    }
		    else{
			reloc->r_address = fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		else{
		    if(section_map->nfine_relocs == 0){
			/* this can overflow the 24-bit sreloc->r_address */
			sreloc->r_address += section_map->offset;
		    }
		    else{
			sreloc->r_address =fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == PPC_RELOC_PAIR){
		    if(pair_reloc != NULL){
			/*
			 * For a PPC_RELOC_JBSR if the high bit of the "true
			 * target" address is set we need to use scattered
			 * relocation entry.  Then place the "true target"
			 * address in the r_value field.
			 */
			if(r_type == PPC_RELOC_JBSR &&
			   (other_half & 0x80000000) == 0x80000000){
			    sreloc = (struct scattered_relocation_info *)
				pair_reloc;
			    r_scattered = 1;
			    sreloc->r_scattered = r_scattered;
			    sreloc->r_address = 0;
			    sreloc->r_pcrel = r_pcrel;
			    sreloc->r_length = r_length;
			    sreloc->r_type = PPC_RELOC_PAIR;
			    sreloc->r_value = other_half;
			}
			else{
			    pair_reloc->r_address = other_half;
			}
		    }
		    else if(spair_reloc != NULL){
			if(r_type == PPC_RELOC_SECTDIFF ||
			   r_type == PPC_RELOC_LOCAL_SECTDIFF ||
			   r_type == PPC_RELOC_HI16_SECTDIFF ||
			   r_type == PPC_RELOC_LO16_SECTDIFF ||
			   r_type == PPC_RELOC_LO14_SECTDIFF ||
			   r_type == PPC_RELOC_HA16_SECTDIFF){
			    /*
			     * For PPC_RELOC_SECTDIFF relocation entries (which
			     * are always scattered types) the r_value field is
			     * relocated.
			     */
			    if(pair_local_map->nfine_relocs == 0)
				spair_reloc->r_value +=
				    - pair_local_map->s->addr
				    + (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			    else
				spair_reloc->r_value =
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
					pair_local_map->output_section->s.addr);
			    if(r_type == PPC_RELOC_HI16_SECTDIFF ||
			       r_type == PPC_RELOC_LO16_SECTDIFF ||
			       r_type == PPC_RELOC_LO14_SECTDIFF ||
			       r_type == PPC_RELOC_HA16_SECTDIFF)
				spair_reloc->r_address = other_half;
			}
			else{
			    if(r_type == PPC_RELOC_JBSR)
				spair_reloc->r_value = other_half;
			    else
				spair_reloc->r_address = other_half;
			}
		    }
		    else{
			fatal("internal error, in ppc_reloc() pair_r_type "
			    "is PPC_RELOC_PAIR but pair_reloc and spair_reloc "
			    "are NULL");
		    }
		}
	    }
#endif /* !defined(RLD) */
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == PPC_RELOC_PAIR)
		i++;
	}
}
                                                                                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/ppc_reloc.h                              0100644 0001750 0001750 00000002721 12612724205 023157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file ppc_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void ppc_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *section_map,
    struct live_refs *refs,
    unsigned long reloc_index);
                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/rld.c                                    0100644 0001750 0001750 00000174110 12612724205 021767  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#undef moninitrld
#endif /* SHLIB */
#ifdef RLD
/*
 * This file contains the functions of the RLD package.
 */
#include <mach-o/loader.h>
#ifndef __OPENSTEP__
extern const struct segment_command *getsegbyname(const char *segname);
extern const struct section *getsectbynamefromheader(
	const struct mach_header *mhp,
	const char *segname,
	const char *sectname);
#endif
#if !(defined(KLD) && defined(__STATIC__))
#include <libc.h>
#include <stdio.h>
#include <mach/mach.h>
#include "stuff/vm_flush_cache.h"
#else /* defined(KLD) && defined(__STATIC__) */
#include <stdlib.h>
#include <unistd.h>
#include <mach/kern_return.h>
#include <mach/vm_map.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <setjmp.h>
#include <stdarg.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "stuff/openstep_mach.h"
#include <mach-o/fat.h>
#include <mach-o/nlist.h>
#ifdef KLD
#include <mach-o/kld.h>
#else /* !defined(KLD) */
#include <mach-o/rld.h>
#include <streams/streams.h>
#include <objc/zone.h>
#endif /* KLD */
#include <mach-o/rld_state.h>
#include <mach-o/ldsyms.h>
#define __darwin_i386_float_state i386_float_state
#include "stuff/arch.h"
#include "stuff/best_arch.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "symbols.h"
#include "pass1.h"
#include "layout.h"
#include "pass2.h"
#include "sets.h"
#ifdef SA_RLD
#include "mach-o/sarld.h"
#endif /* SA_RLD */
#ifdef KLD
#include "mach-o/kld.h"
#endif /* KLD */
#if defined(SA_RLD)
#include "standalone/libsa.h"
#endif

#ifndef __OPENSTEP__
#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
#include <crt_externs.h>
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */
#else /* defined(__OPENSTEP__) */
#ifdef __DYNAMIC__
#include "mach-o/dyld.h"
#endif /* __DYNAMIC__ */
#endif /* !defined(__OPENSTEP__) */

/*
 * The user's address function to be called in layout to get the address of
 * where to link edit the result.
 */
__private_extern__
unsigned long (*address_func)(unsigned long size, unsigned long headers_size) =
									   NULL;

static
enum strip_levels kld_requested_strip_level = STRIP_ALL;

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
/*
 * The function pointer passed to moninitrld() to do profiling of rld loaded
 * code.  If this function pointer is not NULL at the time of an rld_load()
 * called it is called indirectly to set up the profiling buffers.
 */
static void (*rld_monaddition)(char *lowpc, char *highpc) = NULL;
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

/*
 * This is a hack to let the code in layout_segments() in layout.c to know if
 * the special output_file flag RLD_DEBUG_OUTPUT_FILENAME is being used so it
 * can call the address_func (above) with the allocated_size of memory
 * (including the symbol table) so that it can deallocate it correctly.
 */
__private_extern__ long RLD_DEBUG_OUTPUT_FILENAME_flag = 0;

#ifndef KLD
/*
 * The stream passed in to the rld routines to print errors on.
 */
static NXStream *error_stream = NULL;
#endif /* !defined(KLD) */

#if !defined(SA_RLD) && !defined(KLD)
/*
 * The zone allocation is done from.
 */
static NXZone *zonep = NULL;
#endif /* !defined(SA_RLD) && !defined(KLD) */

/*
 * The jump buffer to get back to rld_load() or rld_unload() used by the error
 * routines.
 */
static jmp_buf rld_env;

/*
 * Indicator that a fatal error occured and that no more processing will be
 * done on all future calls to protect calls from causing a core dump.
 */
static volatile int fatals = 0;

/*
 * The base file name passed to rld_load_basefile() if it has been called.
 * This points at an allocated copy of the name.
 */
__private_extern__ char *base_name = NULL;

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
/* 
 * These are maintained for the debugger's use.  See <rld_state.h> for details.
 */
static enum bool rld_maintain_states = FALSE;
static unsigned long rld_nallocated_states = 0;

static unsigned long rld_nloaded_states = 0;
static struct rld_loaded_state *rld_loaded_state = NULL;
static void rld_loaded_state_changed(void);
#define NSTATES_INCREMENT 10
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

#ifdef KLD
/* hook for kext tools to set target byte order */
void
kld_set_byteorder(enum NXByteOrder order)
{
    switch (order) {
	case NX_BigEndian:
	target_byte_sex = BIG_ENDIAN_BYTE_SEX;
	break;
    case NX_LittleEndian:
	target_byte_sex = LITTLE_ENDIAN_BYTE_SEX;
	break;
    default:
	target_byte_sex = UNKNOWN_BYTE_SEX;
    }
}
#endif

/* The internal routine that implements rld_load_basefiles()'s */
#ifdef KLD
static long internal_kld_load(
#else /* !defined(KLD) */
static long internal_rld_load(
    NXStream *stream,
#endif /* KLD */
    struct mach_header **header_addr,
    const char * const *object_filenames,
    const char *output_filename,
    const char *file_name,
    const char *obj_addr,
    long obj_size);


/* The internal routine that implements rld_unload()'s */
#ifdef KLD
static long internal_kld_unload(
#else /* !defined(KLD) */
static long internal_rld_unload(
    NXStream *stream,
#endif /* KLD */
    enum bool internal_cleanup);

#if !defined(SA_RLD) && !defined(KLD)
static long internal_rld_load_basefile(
    NXStream *stream,
    const char *base_filename,
    char *base_addr,
    long base_size);
#endif /* !defined(SA_RLD) && !defined(KLD) */

#if defined(KLD)
static long internal_kld_load_basefile(
    const char *base_filename,
    char *base_addr,
    long base_size);
#endif /* defined(KLD) */

#if !defined(SA_RLD) && !defined(KLD)
/*
 * rld_load() link edits and loads the specified object filenames in the NULL
 * terminated array of object file names, object_files, into the program that
 * called it.  If the program wishes to allow the loaded object files to use
 * symbols from itself it must be built with the -seglinkedit link editor
 * option to have its symbol table mapped into memory.  The symbol table may
 * be trimed to exactly which symbol are allowed to be referenced by use of the
 * '-s list_filenam' option to strip(1).  For this routine only global symbols
 * are used so the -x option to the link editor or strip(1) can be used to save
 * space in the final program.  The set of object files being loaded will only
 * be successfull if there are no link edit errors (undefined symbols, etc.).
 * If an error ocurrs the set of object files is unloaded automaticly.  If
 * errors occur and the value specified for stream is not NULL error messages
 * are printed in that stream.  If the link editing and loading is successfull
 * the address of the header of what was loaded is returned through the pointer
 * header_addr it if is not NULL.  rld_load() returns 1 for success and 0 for
 * failure.  If a fatal system error (out of memory, etc.) occurs then all
 * future calls will fail.
 */
long
rld_load(
NXStream *stream,
struct mach_header **header_addr,
const char * const *object_filenames,
const char *output_filename)
{
	return(internal_rld_load(stream, header_addr, object_filenames,
				 output_filename, NULL, NULL, 0));
}
#endif /* !defined(SA_RLD) && !defined(KLD) */

#if defined(KLD) && defined(__DYNAMIC__)
/*
 * kld_load() is used by kextload(8) for loading kernel drivers running in
 * user space.  It is like rld_load() above but only takes one object_filename
 * argument.  Errors for the kld api's are done through kld_error_vprintf()
 * which kextload(8) provides.
 * 
 * Note thes symbols are really __private_extern__ and done by the "nmedit -p"
 * command in the Makefile so that the other __private_extern__ symbols can be
 * hidden by the "ld -r" first.
 */
long
kld_load(
struct mach_header **header_addr,
const char *object_filename,
const char *output_filename)
{
    const char *object_filenames[2];

	object_filenames[0] = object_filename;
	object_filenames[1] = NULL;

	return(internal_kld_load(header_addr, object_filenames,
				 output_filename, NULL, NULL, 0));
}

/*
 * kld_load_from_memory() is the same as kld_load() but loads one object file
 * that has been mapped into memory.  The object is described by its name,
 * object_name, at address object_addr and is of size object_size.
 */
long
kld_load_from_memory(
struct mach_header **header_addr,
const char *object_name,
char *object_addr,
long object_size,
const char *output_filename)
{
	return(internal_kld_load(header_addr, NULL, output_filename,
				 object_name, object_addr, object_size));
}
#endif /* defined(KLD) && defined(__DYNAMIC__) */

#if !defined(SA_RLD) && !defined(KLD)
/*
 * rld_load_from_memory() is the same as rld_load() but loads one object file
 * that has been mapped into memory.  The object is described by its name,
 * object_name, at address object_addr and is of size object_size.
 */
long
rld_load_from_memory(
NXStream *stream,
struct mach_header **header_addr,
const char *object_name,
char *object_addr,
long object_size,
const char *output_filename)
{
	return(internal_rld_load(stream, header_addr, NULL, output_filename,
				 object_name, object_addr, object_size));
}
#endif /* !defined(SA_RLD) && !defined(KLD) */

#if defined(KLD) && defined(__STATIC__)
/*
 * rld_load_from_memory() is used by /mach_kernel for loading boot drivers
 * running in the kernel.  It is like rld_load_from_memory() above but 
 * does not produce an output file. Errors for the kld api's are done through
 * kld_error_vprintf() which /mach_kernel provides.
 * 
 * Note this symbol is really __private_extern__ and done by the "nmedit -p"
 * command in the Makefile so that the other __private_extern__ symbols can be
 * hidden by the "ld -r" first.
 */
long
kld_load_from_memory(
struct mach_header **header_addr,
const char *object_name,
char *object_addr,
long object_size)
{
	return(internal_kld_load(header_addr, NULL, NULL,
				 object_name, object_addr, object_size));
}
#endif /* defined(KLD) && defined(__DYNAMIC__) */

/*
 * internal_rld_load() is the internal routine that implements rld_load()'s.
 */
static
long
#ifdef KLD
internal_kld_load(
#else /* !defined(KLD) */
internal_rld_load(
NXStream *stream,
#endif /* KLD */
struct mach_header **header_addr,
const char * const *object_filenames,
const char *output_filename,
const char *file_name,
const char *obj_addr,
long obj_size)
{
#if !(defined(KLD) && defined(__STATIC__))
    kern_return_t r;
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
    int i, n;
    int fd;
    long symbol_size, deallocate_size;
    char dir[MAXPATHLEN];
    long dir_len;
    const struct section *s;
    void (**routines)(void);

    	dir[0] = '\0';
	dir_len = 0;
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

#ifndef KLD
	error_stream = stream;
#endif /* !defined(KLD) */

	if(header_addr != NULL)
	    *header_addr = NULL;

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/*
	 * Set up and handle link edit errors and fatal errors
	 */
	if(setjmp(rld_env) != 0){
	    /*
	     * It takes a longjmp() to get to this point.  If it was not a fatal
	     * error unload the set of object files being loaded.  Otherwise
	     * just return failure.
	     */
	    if(fatals == 0)
#ifdef KLD
		internal_kld_unload(TRUE);
#else /* !defined(KLD) */
		internal_rld_unload(stream, TRUE);
#endif /* KLD */
	    return(0);
	}

	/* Set up the globals for rld */
#ifdef KLD
	progname = "kld()";
#else /* !defined(KLD) */
	progname = "rld()";
#endif /* KLD */
	host_pagesize = getpagesize();
	host_byte_sex = get_host_byte_sex();
	force_cpusubtype_ALL = TRUE;
	filetype = MH_OBJECT;
	flush = FALSE;
	nmerged_symbols = 0;
	merged_string_size = 0;
	nlocal_symbols = 0;
	local_string_size = 0;
	/*
	 * If there is to be an output file then save the symbols.  Only the
	 * symbols from the current set will be placed in the output file.  The
	 * symbols from the base file are never placed in any output file.
	 */
	strip_base_symbols = TRUE;
	if(output_filename != NULL)
	    strip_level = STRIP_NONE;
	else
	    strip_level = kld_requested_strip_level;

	/* This must be cleared for each call to rld() */
	errors = 0;

#if !defined(SA_RLD) && !(defined(KLD) && defined(__DYNAMIC__))
	/*
	 * If the symbols from base program has not been loaded load them.
	 * This will happen the first time rld() is called or will not happen.
	 */
	if(base_obj == NULL){
	    /*
	     * The NeXT global variable that gets set to argv in crt0.o.  Used
	     * here to set the name of the base program's object file
	     * (NXArgv[0]).
	     */
#if !defined(__OPENSTEP__) && !defined(KLD)
	    static char ***NXArgv_pointer = NULL;
	    static struct mach_header *_mh_execute_header_pointer = NULL;
	    struct segment_command *sg;

	    if(NXArgv_pointer == NULL)
		NXArgv_pointer = _NSGetArgv();
	    if(_mh_execute_header_pointer == NULL)
		_mh_execute_header_pointer = _NSGetMachExecuteHeader();

	    sg = (struct segment_command *)getsegbyname(SEG_LINKEDIT);
	    if(sg != NULL)
		merge_base_program((*NXArgv_pointer)[0],
				   _mh_execute_header_pointer, sg,
				   NULL, 0, NULL, 0);
#else /* !defined(__OPENSTEP__) && !defined(KLD) */
	    struct segment_command *sg;
#ifndef __DYNAMIC__
#ifdef KLD
#ifndef _LIBSA_STDLIB_H_
	    /*
	     * This needs to match what is in
	     * /System/Library/Frameworks/Kernel.framework/PrivateHeaders/
	     *     libsa/stdlib.h
	     * if it exists on the system.
	     */
	    __private_extern__ const char *kld_basefile_name;
#endif /* !defined(_LIBSA_STDLIB_H_) */
#else /* !defined(KLD) */
	    extern char **NXArgv;
#endif /* KLD */
#else /* defined(__DYNAMIC__) */
	    static char ***NXArgv_pointer = NULL;
	    static struct mach_header *_mh_execute_header_pointer = NULL;

	    if(NXArgv_pointer == NULL)
		_dyld_lookup_and_bind("_NXArgv",
		    (unsigned long *)&NXArgv_pointer, NULL);
	    if(_mh_execute_header_pointer == NULL)
		_dyld_lookup_and_bind("__mh_execute_header",
		    (unsigned long *)&_mh_execute_header_pointer, NULL);
#endif /* !defined(__DYNAMIC__) */

	    sg = (struct segment_command *)getsegbyname(SEG_LINKEDIT);
	    if(sg != NULL)
#ifndef __DYNAMIC__
#ifdef KLD
		merge_base_program(kld_basefile_name,
		    (struct mach_header *)&_mh_execute_header, sg,
		    NULL, 0, NULL, 0);
#else
		merge_base_program(
		    NXArgv[0], (struct mach_header *)&_mh_execute_header, sg,
		    NULL, 0, NULL, 0);
#endif /* KLD */
#else /* defined(__DYNAMIC__) */
		merge_base_program((*NXArgv_pointer)[0],
				   _mh_execute_header_pointer, sg,
				   NULL, 0, NULL, 0);
#endif /* !defined(__DYNAMIC__) */
#endif /* !defined(__OPENSTEP__) && !defined(KLD) */
	    if (target_byte_sex == UNKNOWN_BYTE_SEX)
		target_byte_sex = host_byte_sex;
	    /*
	     * If there were any errors in processing the base program it is
	     * treated as a fatal error and no futher processing is done.
	     */
	    if(errors){
		fatals = 1;
		return(0);
	    }
#ifndef KLD
	    /*
	     * Since we are loading into this program maintain state for the
	     * debugger.
	     */
	    rld_maintain_states = TRUE;
#endif /* KLD */
	}
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__DYNAMIC__)) */

	/*
	 * Create an entry in the sets array for this new set.  This has to be
	 * done after the above base program has been merged so it does not
	 * appear apart of any set.
	 */
	new_set();

	/*
	 * The merged section sizes need to be zeroed before we start loading.
	 * The only case they would not be zero would be if a previous rld_load
	 * failed with a pass1 error they would not get reset.
	 */
	zero_merged_sections_sizes();

	/*
	 * Do pass1() for each object file or merge() for the one object in
	 * memory.
	 */
#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
	if(file_name == NULL){
	    for(i = 0; object_filenames[i] != NULL; i++)
		pass1((char *)object_filenames[i], FALSE, FALSE, FALSE, FALSE,
		      FALSE);
	}
	else
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */
	{
	    cur_obj = new_object_file();
	    cur_obj->file_name = allocate(strlen(file_name) + 1);
	    strcpy(cur_obj->file_name, file_name);
	    cur_obj->user_obj_addr = TRUE;
	    cur_obj->obj_addr = (char *)obj_addr;
	    cur_obj->obj_size = obj_size;
	    merge(FALSE, FALSE, FALSE);
	}

	if(errors){
#ifdef KLD
	    internal_kld_unload(TRUE);
#else /* !defined(KLD) */
	    internal_rld_unload(stream, TRUE);
#endif /* KLD */
	    return(0);
	}

	if(output_filename == RLD_DEBUG_OUTPUT_FILENAME)
	    RLD_DEBUG_OUTPUT_FILENAME_flag = 1;
	else
	    RLD_DEBUG_OUTPUT_FILENAME_flag = 0;
	layout();
	if(errors){
#ifdef KLD
	    internal_kld_unload(TRUE);
#else /* !defined(KLD) */
	    internal_rld_unload(stream, TRUE);
#endif /* KLD */
	    return(0);
	}

	pass2();
	if(errors){
#ifdef KLD
	    internal_kld_unload(TRUE);
#else /* !defined(KLD) */
	    internal_rld_unload(stream, TRUE);
#endif /* KLD */
	    return(0);
	}

	/*
	 * Place the merged sections back on their list of their merged segment
	 * (since now the are all in one segment after layout() placed them
	 * there for the MH_OBJECT format) and also reset the sizes of the 
	 * sections to zero for any future loads.
	 */
	reset_merged_sections();

	/*
	 * Clean the object structures of things from this set that are not
	 * needed once the object has been successfully loaded.
	 */
	clean_objects();
	clean_archives_and_fats();

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
	if(output_filename != NULL &&
	   output_filename != RLD_DEBUG_OUTPUT_FILENAME){
	    /*
	     * Create the output file.  The unlink() is done to handle the
	     * problem when the outputfile is not writable but the directory
	     * allows the file to be removed (since the file may not be there
	     * the return code of the unlink() is ignored).
	     */
	    symbol_size = output_symtab_info.symtab_command.nsyms *
			  sizeof(struct nlist) +
			  output_symtab_info.symtab_command.strsize;
	    (void)unlink(output_filename);
	    if((fd = open(output_filename, O_WRONLY | O_CREAT | O_TRUNC,
			  0666)) == -1){
		system_error("can't create output file: %s", output_filename);
#ifdef KLD
		internal_kld_unload(TRUE);
#else /* !defined(KLD) */
		internal_rld_unload(stream, TRUE);
#endif /* KLD */
		return(0);
	    }
	    else {
		/*
		 * Write the entire output file.
		 */
		if(write(fd, output_addr, output_size + symbol_size) !=
		   (int)(output_size + symbol_size)){
		    system_error("can't write output file: %s",output_filename);
#ifdef KLD
		    internal_kld_unload(TRUE);
#else /* !defined(KLD) */
		    internal_rld_unload(stream, TRUE);
#endif /* KLD */
		    return(0);
		}
		if(close(fd) == -1){
		    system_error("can't close output file: %s",output_filename);
#ifdef KLD
		    internal_kld_unload(TRUE);
#else /* !defined(KLD) */
		    internal_rld_unload(stream, TRUE);
#endif /* KLD */
		    return(0);
		}
	    }
	    /*
	     * Deallocate the pages of memory for the symbol table if there are
	     * any whole pages.
	     */
	    if (strip_level == STRIP_ALL)
		deallocate_size = rnd(output_size + symbol_size, host_pagesize) -
				rnd(output_size, host_pagesize);
	    else {
		deallocate_size = 0;
		sets[cur_set].output_size += symbol_size;
	    }

	    if(deallocate_size > 0){
		if((r = vm_deallocate(mach_task_self(),
				      (vm_address_t)(output_addr +
				      rnd(output_size, host_pagesize)),
				      deallocate_size)) != KERN_SUCCESS)
		    mach_fatal(r, "can't vm_deallocate() buffer for output "
			       "file's symbol table");
#ifdef RLD_VM_ALLOC_DEBUG
		print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
		      (unsigned int)(output_addr +
				     rnd(output_size, host_pagesize)),
		      (unsigned int)deallocate_size);
#endif /* RLD_VM_ALLOC_DEBUG */
	    }
	}
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

	/*
	 * Now that this was successfull all that is left to do is return the
	 * address of the header if requested.
	 */
	if(header_addr != NULL)
	    *header_addr = (struct mach_header *)output_addr;

#if !(defined(KLD) && defined(__STATIC__))
	/*
	 * Flush the cache of the output buffer so the the caller can execute
	 * the instructions written on by the relocation.
	 */
	if((r = vm_flush_cache(mach_task_self(), (vm_address_t)output_addr,
			       output_size)) != KERN_SUCCESS)
#ifndef SA_RLD
	    mach_fatal(r, "can't vm_flush_cache() output buffer");
#else
	    fatal("can't vm_flush_cache() output buffer");
#endif
#endif /* !(defined(KLD) && defined(__STATIC__)) */


#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
	/*
	 * Now that this was successfull if the state for the debugger is to
	 * be maintained fill it in.
	 */
	if(rld_maintain_states == TRUE){
	    if(rld_nloaded_states + 1 >= rld_nallocated_states){
		rld_loaded_state = reallocate(rld_loaded_state,
					sizeof(struct rld_loaded_state) *
				(rld_nallocated_states + NSTATES_INCREMENT) );
		rld_nallocated_states += NSTATES_INCREMENT;
	    }

	    if(file_name == NULL){
		for(i = 0; object_filenames[i] != NULL; )
		    i++;
		rld_loaded_state[rld_nloaded_states].object_filenames =
						allocate(i * sizeof(char *));
		rld_loaded_state[rld_nloaded_states].nobject_filenames = i;

		for(i = 0; object_filenames[i] != NULL; i++){
		    if(object_filenames[i][0] != '/'){
			if(dir[0] == '\0'){
			    getwd(dir);
			    dir_len = strlen(dir);
			}
			rld_loaded_state[rld_nloaded_states].
			    object_filenames[i] =
				allocate(dir_len + 1 +
					 strlen(object_filenames[i]) + 1);
			strcpy(rld_loaded_state[rld_nloaded_states].
				object_filenames[i], dir);
			strcat(rld_loaded_state[rld_nloaded_states].
				object_filenames[i], "/");
			strcat(rld_loaded_state[rld_nloaded_states].
				object_filenames[i], object_filenames[i]);
		    }
		    else{
			rld_loaded_state[rld_nloaded_states].
			    object_filenames[i] =
				allocate(strlen(object_filenames[i]) + 1);
			strcpy(rld_loaded_state[rld_nloaded_states].
				object_filenames[i], object_filenames[i]);
		    }
		}
	    }
	    else{
		rld_loaded_state[rld_nloaded_states].object_filenames =
						allocate(sizeof(char *));
		rld_loaded_state[rld_nloaded_states].nobject_filenames = 1;
		rld_loaded_state[rld_nloaded_states].object_filenames[0] =
			allocate(strlen(file_name) + 1);
		strcpy(rld_loaded_state[rld_nloaded_states].
			object_filenames[0], file_name);
	    }
	    rld_loaded_state[rld_nloaded_states].header_addr =
					(struct mach_header *)output_addr;

	    rld_nloaded_states += 1;
	    rld_loaded_state_changed();
	}

	/*
	 * If the base file comes from the executable then the profiling and
	 * constructor calls should be made.  Else an rld_load_basefile() was
	 * done and these calls should not be made.
	 */
	if(base_name == NULL){
	    /*
	     * If moninitrld() was called and it save away a pointer to
	     * monaddition() then profiling for the rld_load'ed code is wanted
	     * and make the indirect call to monaddition().
	     */
	    if(rld_monaddition != NULL && rld_maintain_states == TRUE){
		(*rld_monaddition)(output_addr, output_addr + output_size);
	    }
	    /*
	     * Call the C++ constructors and register the C++ destructors.
	     */
	    s = getsectbynamefromheader((struct mach_header *)output_addr,
					"__TEXT", "__constructor");
	    if(s != NULL){
		routines = (void(**)(void))s->addr;
		n = s->size / sizeof(routines[0]);
		for(i = 0; i < n; i++)
		    (*routines[i])();
	    }
	    s = getsectbynamefromheader((struct mach_header *)output_addr,
					"__TEXT", "__destructor");
	    if(s != NULL){
		routines = (void(**)(void))s->addr;
		n = s->size / sizeof(routines[0]);
		for(i = 0; i < n; i++)
		    atexit(routines[i]);
	    }
	}
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

	return(1);
}

#if !defined(SA_RLD)
/*
 * rld_load_basefile() loads a base file from an object file rather than just
 * picking up the link edit segment from this program.
 */
#if defined(KLD)
#if !defined(__STATIC__)
long
kld_load_basefile(
const char *base_filename)
{
	return(internal_kld_load_basefile(base_filename, NULL, 0));
}
#endif /* !defined(__STATIC__) */

long
kld_load_basefile_from_memory(
const char *base_filename,
char *base_addr,
long base_size)
{
	return(internal_kld_load_basefile(base_filename, base_addr, base_size));
}

#else /* !defined(KLD) */
long
rld_load_basefile(
NXStream *stream,
const char *base_filename)
{
	return(internal_rld_load_basefile(stream, base_filename, NULL, 0));
}
#endif /* defined(KLD) */

/*
 * rld_load_basefile() loads a base file from an object file rather than just
 * picking up the link edit segment from this program.
 */
static long
#ifdef KLD
internal_kld_load_basefile(
#else /* !defined(KLD) */
internal_rld_load_basefile(
NXStream *stream,
#endif
const char *base_filename,
char *base_addr,
long base_size)
{
#if !(defined(KLD) && defined(__STATIC__))
    unsigned long size;
    char *addr;
    int fd;
    struct stat stat_buf;
    kern_return_t r;
    struct fat_header *fat_header;
#ifdef __LITTLE_ENDIAN__
    struct fat_header struct_fat_header;
#endif /* __LITTLE_ENDIAN__ */
    struct fat_arch *fat_archs, *best_fat_arch;
    struct arch_flag host_arch_flag;
    enum bool from_fat_file;

	size = 0;
	from_fat_file = FALSE;

#endif /* !(defined(KLD) && defined(__STATIC__)) */

#ifndef KLD
	error_stream = stream;
#endif /* !defined(KLD) */

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/*
	 * Set up and handle link edit errors and fatal errors
	 */
	if(setjmp(rld_env) != 0){
	    /*
	     * It takes a longjmp() to get to this point.  If it was not a fatal
	     * error unload the base file being loaded.  Otherwise just return
	     * failure.
	     */
	    if(fatals == 0)
#ifdef KLD
		kld_unload_all(1);
#else /* !defined(KLD) */
		rld_unload_all(stream, 1);
#endif /* KLD */
	    return(0);
	}

	/* This must be cleared for each call to rld() */
	errors = 0;

	/*
	 * If a base file has been loaded at this point return failure.
	 */
	if(base_obj != NULL){
	    error("a base program is currently loaded");
	    return(0);
	}
	if(cur_set != -1){
	    error("object sets are currently loaded (base file must be loaded"
		  "before object sets)");
	    return(0);
	}

	/* Set up the globals for rld */
#ifdef KLD
	progname = "kld()";
#else /* !defined(KLD) */
	progname = "rld()";
#endif /* KLD */
	host_pagesize = getpagesize();
	host_byte_sex = get_host_byte_sex();
	strip_base_symbols = TRUE;
	force_cpusubtype_ALL = TRUE;
	base_name = allocate(strlen(base_filename) + 1);
	strcpy(base_name, base_filename);

#if !(defined(KLD) && defined(__STATIC__))

	/*
	 * If there is to be an output file then save the symbols.  Only the
	 * symbols from the current set will be placed in the output file.  The
	 * symbols from the base file are never placed in any output file.
	 */

	if (base_addr == NULL) {
	    /*
	    * Open this file and map it in.
	    */
	    if((fd = open(base_name, O_RDONLY, 0)) == -1){
		system_error("Can't open: %s", base_name);
		free(base_name);
		base_name = NULL;
		return(0);
	    }
	    if(fstat(fd, &stat_buf) == -1)
		system_fatal("Can't stat file: %s", base_name);
	    /*
	    * For some reason mapping files with zero size fails so it has to
	    * be handled specially.
	    */
	    if(stat_buf.st_size == 0){
		error("file: %s is empty (not an object)", base_name);
		close(fd);
		free(base_name);
		base_name = NULL;
		return(0);
	    }
	    size = stat_buf.st_size;
	    if((r = map_fd((int)fd, (vm_offset_t)0, (vm_offset_t *)&addr,
		(boolean_t)TRUE, (vm_size_t)size)) != KERN_SUCCESS)
		mach_fatal(r, "can't map file: %s", base_name);
#ifdef RLD_VM_ALLOC_DEBUG
	    print("rld() map_fd: addr = 0x%0x size = 0x%x\n",
		(unsigned int)addr, (unsigned int)size);
#endif /* RLD_VM_ALLOC_DEBUG */
	    /*
	     * The mapped file can't be made read-only because even in the case
	     * of errors where a wrong bytesex file is attempted to be loaded
	     * it must be writeable to detect the error.
	     *  if((r = vm_protect(mach_task_self(), (vm_address_t)addr, size,
	     * 		       FALSE, VM_PROT_READ)) != KERN_SUCCESS)
	     *      mach_fatal(r, "can't make memory for mapped file: %s "
	     *      	   "read-only", base_name);
	     */
	    close(fd);
    
	    /*
	    * Determine what type of file it is (fat or thin object file).
	    */
	    if(sizeof(struct fat_header) > size){
		error("truncated or malformed file: %s (file size too small "
		    "to be any kind of object)", base_name);
		free(base_name);
		base_name = NULL;
		return(0);
	    }
	    from_fat_file = FALSE;
	    fat_header = (struct fat_header *)addr;
#ifdef __LITTLE_ENDIAN__
	    fat_archs = NULL;
#endif /* __LITTLE_ENDIAN__ */
#ifdef __BIG_ENDIAN__
	    if(fat_header->magic == FAT_MAGIC)
#endif /* __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
	    if(fat_header->magic == SWAP_LONG(FAT_MAGIC))
#endif /* __LITTLE_ENDIAN__ */
	    {
		from_fat_file = TRUE;
#ifdef __LITTLE_ENDIAN__
		struct_fat_header = *fat_header;
		swap_fat_header(&struct_fat_header, host_byte_sex);
		fat_header = &struct_fat_header;
#endif /* __LITTLE_ENDIAN__ */
    
		if(sizeof(struct fat_header) + fat_header->nfat_arch *
		   sizeof(struct fat_arch) > (unsigned long)size){
		    error("fat file: %s truncated or malformed (fat_arch "
			"structs would extend past the end of the file)",
			base_name);
		    goto rld_load_basefile_error_return;
		}
    
#ifdef __BIG_ENDIAN__
		fat_archs = (struct fat_arch *)
				    (addr + sizeof(struct fat_header));
#endif /* __BIG_ENDIAN__ */
#ifdef __LITTLE_ENDIAN__
		fat_archs = allocate(fat_header->nfat_arch *
				    sizeof(struct fat_arch));
		memcpy(fat_archs, addr + sizeof(struct fat_header),
		    fat_header->nfat_arch * sizeof(struct fat_arch));
		swap_fat_arch(fat_archs, fat_header->nfat_arch, host_byte_sex);
#endif /* __LITTLE_ENDIAN__ */
    
		/* check the fat file */
		check_fat(base_name, size, fat_header, fat_archs, NULL, 0);
		if(errors){
		    goto rld_load_basefile_error_return;
		    return(0);
		}
    
#if defined(KLD) && defined(__STATIC__)
		best_fat_arch = cpusubtype_findbestarch(
				arch_flag.cputype, arch_flag.cpusubtype,
				fat_archs, fat_header->nfat_arch);
#else /* !(defined(KLD) && defined(__STATIC__)) */
		if(get_arch_from_host(&host_arch_flag, NULL) == 0){
		    error("can't determine the host architecture (fix "
			"get_arch_from_host() )");
		    goto rld_load_basefile_error_return;
		}
		best_fat_arch = cpusubtype_findbestarch(
				host_arch_flag.cputype,
				host_arch_flag.cpusubtype,
				fat_archs, fat_header->nfat_arch);
#endif /* defined(KLD) && defined(__STATIC__) */
		if(best_fat_arch != NULL){
		    cur_obj = new_object_file();
		    cur_obj->file_name = base_name;
		    cur_obj->obj_addr = addr + best_fat_arch->offset;
		    cur_obj->obj_size = best_fat_arch->size;
		    cur_obj->from_fat_file = TRUE;
		    base_obj = cur_obj;
		}
		if(base_obj == NULL){
		    error("fat file: %s does not contain the host architecture "
			"(can't be used as a base file)", base_name);
		    goto rld_load_basefile_error_return;
		}
#ifdef __LITTLE_ENDIAN__
		free(fat_archs);
#endif /* __LITTLE_ENDIAN__ */
	    }
	    else{
		cur_obj = new_object_file();
		cur_obj->file_name = base_name;
		cur_obj->obj_addr = addr;
		cur_obj->obj_size = size;
		base_obj = cur_obj;
	    }
	}
	else
#endif /* !(defined(KLD) && defined(__STATIC__)) */
	{
	    cur_obj = new_object_file();
	    cur_obj->file_name = base_name;
	    cur_obj->obj_addr = base_addr;
	    cur_obj->obj_size = base_size;
	    cur_obj->user_obj_addr = TRUE;
	    base_obj = cur_obj;
	}

	/*
	 * Now that the file is mapped in merge it as the base file.
	 */
	merge(FALSE, FALSE, FALSE);

	if(errors){
#ifdef KLD
	    kld_unload_all(1);
#else /* !defined(KLD) */
	    rld_unload_all(stream, 1);
#endif /* KLD */
	    return(0);
	}

	/*
	 * This is called to deallocate the memory for the base file and to
	 * clean up it's section map.
	 */
	clean_objects();
	clean_archives_and_fats();
#if !(defined(KLD) && defined(__STATIC__))
	if(from_fat_file == TRUE){
	    if((r = vm_deallocate(mach_task_self(), (vm_address_t)addr,
				  (vm_size_t)size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() memory for mapped file %s",
			   base_name);
#ifdef RLD_VM_ALLOC_DEBUG
	    print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
		  (unsigned int)addr, (unsigned int)size);
#endif /* RLD_VM_ALLOC_DEBUG */
	}

	/*
	 * Since we are NOT loading into this program don't maintain state for
	 * the debugger.
	 */
	rld_maintain_states = FALSE;

#endif /* !(defined(KLD) && defined(__STATIC__)) */

	return(1);

#if !(defined(KLD) && defined(__STATIC__))
rld_load_basefile_error_return:
	if((r = vm_deallocate(mach_task_self(), (vm_address_t)addr,
			      (vm_size_t)size)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_deallocate() memory for mapped file %s",
		       base_name);
#ifdef RLD_VM_ALLOC_DEBUG
	print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
	      (unsigned int)addr, (unsigned int)size);
#endif /* RLD_VM_ALLOC_DEBUG */
	free(base_name);
	base_name = NULL;
#ifdef __LITTLE_ENDIAN__
	if(fat_archs != NULL)
	    free(fat_archs);
#endif /* __LITTLE_ENDIAN__ */
	return(0);
#endif /* !(defined(KLD) && defined(__STATIC__)) */
}

#ifndef KLD
/*
 * rld_unload() unlinks and unloads that last object set that was loaded.
 * It returns 1 if it is successfull and 0 otherwize.  If any errors ocurr
 * and the specified stream, stream, is not zero the error messages are printed
 * on that stream.
 */
long
rld_unload(
NXStream *stream)
{
    return(internal_rld_unload(stream, FALSE));
}
#endif /* KLD */
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

/*
 * internal_rld_unload() does the work for rld_unload() and takes one extra
 * parameter which is used to know if to remove the state maintained by the
 * debugger.
 */
static
long
#ifdef KLD
internal_kld_unload(
#else /* !defined(KLD) */
internal_rld_unload(
NXStream *stream,
#endif /* KLD */
enum bool internal_cleanup)
{
#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
    kern_return_t r;
    unsigned long i;
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

#ifndef KLD
	error_stream = stream;
#endif /* !defined(KLD) */

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/*
	 * Set up and handle link edit errors and fatal errors
	 */
	if(setjmp(rld_env) != 0){
	    /*
	     * It takes a longjmp() to get to this point.  If it was a fatal
	     * error or not just return failure.
	     */
	    return(0);
	}

	/* Set up the globals for rld */
#ifdef KLD
	progname = "kld()";
#else /* !defined(KLD) */
	progname = "rld()";
#endif /* KLD */
	host_byte_sex = get_host_byte_sex();
	force_cpusubtype_ALL = TRUE;

	/* This must be cleared for each call to rld() */
	errors = 0;

	free_multiple_defs();
	free_undefined_list();

	/*
	 * If no set has been loaded at this point return failure.
	 */
	if(cur_set == -1){
	    error("no object sets currently loaded");
	    return(0);
	}

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
	/*
	 * First adjust the state maintained for the debugger.  This is done
	 * first before the unload happens so if the debugger attaches while
	 * in this unload it does not use the state that is being unloaded.
	 */
	if(internal_cleanup == FALSE && rld_maintain_states == TRUE){
	    rld_nloaded_states -= 1;
	    for(i = 0;
		i < rld_loaded_state[rld_nloaded_states].nobject_filenames;
		i++){
		    free(rld_loaded_state[rld_nloaded_states].
			 object_filenames[i]);
	    }
	    free(rld_loaded_state[rld_nloaded_states].object_filenames);

	    rld_loaded_state[rld_nloaded_states].object_filenames = NULL;
	    rld_loaded_state[rld_nloaded_states].nobject_filenames = 0;
	    rld_loaded_state[rld_nloaded_states].header_addr = NULL;
	}
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

	/*
	 * Remove the merged symbols for the current set of objects.
	 */
	remove_merged_symbols();

	/*
	 * Remove the merged sections for the current set of objects.
	 */
	remove_merged_sections();

	/*
	 * Clean and remove the object strcutures for the current set of
	 * objects.
	 */
	clean_objects();
	clean_archives_and_fats();
	remove_objects();

	/*
	 * deallocate the output memory for the current set if it had been
	 * allocated.
	 */
	if(sets[cur_set].output_addr != NULL){
#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
	    if((r = vm_deallocate(mach_task_self(),
				  (vm_address_t)sets[cur_set].output_addr,
				  sets[cur_set].output_size)) != KERN_SUCCESS)
		mach_fatal(r, "can't vm_deallocate() memory for output");
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */
#ifdef RLD_VM_ALLOC_DEBUG
	    print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
		  (unsigned int)sets[cur_set].output_addr,
		  (unsigned int)sets[cur_set].output_size);
#endif /* RLD_VM_ALLOC_DEBUG */
	    sets[cur_set].output_addr = NULL;
	}

	/*
	 * The very last thing to do to unload a set is to remove the set
	 * allocated in the sets array and reduce the cur_set.
	 */
	remove_set();

#if !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__))
	/*
	 * If we were maintaining state for the debugger let it know the state
	 * has changed.
	 */
	if(rld_maintain_states == TRUE)
	    rld_loaded_state_changed();
#endif /* !defined(SA_RLD) && !(defined(KLD) && defined(__STATIC__)) */

	return(1);
}

#ifndef SA_RLD
/*
 * rld_unload_all() frees up all dynamic memory for the rld package that store
 * the information about all object sets and the base program.  Also if the
 * parameter deallocate_sets is non-zero it deallocates the object sets
 * otherwise it leaves them around and can be still be used by the program.
 * It returns 1 if it is successfull and 0 otherwize.  If any errors ocurr
 * and the specified stream, stream, is not zero the error messages are printed
 * on that stream.
 */
long
#ifdef KLD
kld_unload_all(
#else /* !defined(KLD) */
rld_unload_all(
NXStream *stream,
#endif /* KLD */
long deallocate_sets)
{
#if !(defined(KLD) && defined(__STATIC__))
    kern_return_t r;
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#ifndef KLD
    unsigned long i, j, n;
#endif /* !defined(KLD) */

#ifndef KLD
	error_stream = stream;
#endif /* !defined(KLD) */

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/*
	 * Set up and handle link edit errors and fatal errors
	 */
	if(setjmp(rld_env) != 0){
	    /*
	     * It takes a longjmp() to get to this point.  If it was a fatal
	     * error or not just return failure.
	     */
	    return(0);
	}

	/* Set up the globals for rld */
#ifdef KLD
	progname = "kld()";
#else /* !defined(KLD) */
	progname = "rld()";
#endif /* KLD */
	host_byte_sex = get_host_byte_sex();
	force_cpusubtype_ALL = TRUE;

	/* This must be cleared for each call to rld() */
	errors = 0;

	free_multiple_defs();
	free_undefined_list();

	/*
	 * If nothing has been loaded at this point return failure.
	 */
	if(cur_set == -1 && base_obj == NULL){
	    error("no object sets or base program currently loaded");
	    return(0);
	}

#ifndef KLD
	/*
	 * First adjust the state maintained for the debugger.  This is done
	 * first before the unload happens so if the debugger attaches while
	 * in this unload it does not use the state that is being unloaded.
	 */
	if(rld_maintain_states == TRUE){
	    n = rld_nloaded_states;
	    rld_nloaded_states = 0;
	    for(i = 0; i < n; i++){
		for(j = 0; j < rld_loaded_state[i].nobject_filenames; j++)
		    free(rld_loaded_state[i].object_filenames[j]);
		free(rld_loaded_state[i].object_filenames);

		rld_loaded_state[i].object_filenames = NULL;
		rld_loaded_state[i].nobject_filenames = 0;
		rld_loaded_state[i].header_addr = NULL;
	    }
	    free(rld_loaded_state);
	    rld_loaded_state = NULL;
	    rld_nallocated_states = 0;
	}
#endif /* !defined(KLD) */

	/*
	 * Remove all sets currently loaded.
	 */
	while(cur_set != -1){
	    /*
	     * Remove the merged symbols for the current set of objects.
	     */
	    remove_merged_symbols();

	    /*
	     * Remove the merged sections for the current set of objects.
	     */
	    remove_merged_sections();

	    /*
	     * Clean and remove the object structures for the current set of
	     * objects.
	     */
	    clean_objects();
	    clean_archives_and_fats();
	    remove_objects();

#if !(defined(KLD) && defined(__STATIC__))
	    /*
	     * deallocate the output memory for the current set if specified and
	     * it had been allocated.
	     */
	    if(deallocate_sets && sets[cur_set].output_addr != NULL){
		if((r = vm_deallocate(mach_task_self(),
				  (vm_address_t)sets[cur_set].output_addr,
				  sets[cur_set].output_size)) != KERN_SUCCESS)
		    mach_fatal(r, "can't vm_deallocate() memory for output");
#ifdef RLD_VM_ALLOC_DEBUG
		print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
		      (unsigned int)sets[cur_set].output_addr,
		      (unsigned int)sets[cur_set].output_size);
#endif /* RLD_VM_ALLOC_DEBUG */
	    }
#endif /* !(defined(KLD) && defined(__STATIC__)) */
	    sets[cur_set].output_addr = NULL;

	    /*
	     * The very last thing to do to unload a set is to remove the set
	     * allocated in the sets array and reduce the cur_set.
	     */
	    remove_set();
	}
	/*
	 * Remove the merged symbols for the base program.
	 */
	remove_merged_symbols();

	/*
	 * Remove the merged sections for the base program.
	 */
	remove_merged_sections();

	/*
	 * Remove the object structure for the base program.
	 */
	if(base_name != NULL){
	    clean_objects();
	    clean_archives_and_fats();
	    free(base_name);
	    base_name = NULL;
	}
	remove_objects();

	/*
	 * Now free the memory for the sets.
	 */
	free_sets();

	/*
	 * Set the pointer to the base object to NULL so that if another load
	 * is done it will get reloaded.
	 */
	base_obj = NULL;

#ifndef KLD
	/*
	 * If we were maintaining state for the debugger let it know the state
	 * has changed.  Then clear the flag for maintaining state for the
	 * debugger.
	 */
	if(rld_maintain_states == TRUE)
	    rld_loaded_state_changed();
	rld_maintain_states = FALSE;

	if(zonep != NULL)
	    NXDestroyZone(zonep);
	zonep = NULL;
#endif /* !defined(KLD) */

	target_byte_sex = UNKNOWN_BYTE_SEX;
	return(1);
}
#endif /* !defined(SA_RLD) */

#ifndef SA_RLD

/*
 * rld_lookup() looks up the specified symbol name, symbol_name, and returns
 * its value indirectly through the pointer specified, value.  It returns
 * 1 if it finds the symbol and 0 otherwise.  If any errors ocurr and the
 * specified stream, stream, is not zero the error messages are printed on
 * that stream (for this routine only internal errors could result).
 */
long
#ifdef KLD
kld_lookup(
#else /* !defined(KLD) */
rld_lookup(
NXStream *stream,
#endif /* KLD */
const char *symbol_name,
unsigned long *value)
{
    struct merged_symbol *merged_symbol;

#ifndef KLD
	error_stream = stream;
#endif /* !defined(KLD) */

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/* This must be cleared for each call to rld() */
	errors = 0;

	merged_symbol = lookup_symbol((char *)symbol_name);
	if(merged_symbol->name_len != 0){
	    if(value != NULL)
		*value = merged_symbol->nlist.n_value;
	    return(1);
	}
	else{
	    if(value != NULL)
		*value = 0;
	    return(0);
	}
}

/*
 * rld_forget_symbol() looks up the specified symbol name, symbol_name, and
 * stomps on the name so rld effectively forgets the symbol exists. It returns
 * 1 if it finds the symbol and 0 otherwise.  If any errors ocurr and the
 * specified stream, stream, is not zero the error messages are printed on
 * that stream (for this routine only internal errors could result).
 */
long
#ifdef KLD
kld_forget_symbol(
#else /* !defined(KLD) */
rld_forget_symbol(
NXStream *stream,
#endif /* KLD */
const char *symbol_name)
{
    struct merged_symbol *merged_symbol;

#ifndef KLD
	error_stream = stream;
#endif /* !defined(KLD) */

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/* This must be cleared for each call to rld() */
	errors = 0;

	merged_symbol = lookup_symbol((char *)symbol_name);
	if(merged_symbol->name_len != 0){
	    merged_symbol->nlist.n_un.n_name[0] = '\0';
	    return(1);
	}
	else{
	    return(0);
	}
}

#ifndef KLD
/*
 * rld_write_symfile() writes a object file containing just absolute symbols
 * mirroring the last set loaded.  This can be used to recreate the stack of
 * the loaded state to come back after things are unloaded and load more stuff.
 */
long
rld_write_symfile(
NXStream *stream,
const char *output_filename)
{
    int fd;
    long symbol_size, return_value;
    kern_return_t r;

	return_value = 1;
	error_stream = stream;

	/* If a fatal error has ever occured no other calls will be processed */
	if(fatals == 1){
	    print("previous fatal errors occured, can no longer succeed");
	    return(0);
	}

	/*
	 * Set up and handle link edit errors and fatal errors
	 */
	if(setjmp(rld_env) != 0){
	    /*
	     * It takes a longjmp() to get to this point.  If it was a fatal
	     * error or not just return failure.
	     */
	    return(0);
	}

	/* Set up the globals for rld */
#ifdef KLD
	progname = "kld()";
#else /* !defined(KLD) */
	progname = "rld()";
#endif /* KLD */
	host_byte_sex = get_host_byte_sex();
	force_cpusubtype_ALL = TRUE;

	/* This must be cleared for each call to rld() */
	errors = 0;

	/*
	 * If no set has been loaded at this point return failure.  That is a
	 * basefile and at least one object set must be loaded to create a
	 * symfile.
	 */
	if(cur_set < 0){
	    error("no object sets currently loaded");
	    return(0);
	}

	layout_rld_symfile();
	if(errors){
	    return_value = 0;
	    goto deallocate_and_return;
	}

	pass2_rld_symfile();
	if(errors){
	    return_value = 0;
	    goto deallocate_and_return;
	}

	/*
	 * Create the output file.  The unlink() is done to handle the
	 * problem when the outputfile is not writable but the directory
	 * allows the file to be removed (since the file may not be there
	 * the return code of the unlink() is ignored).
	 */
	symbol_size = output_symtab_info.symtab_command.nsyms *
		      sizeof(struct nlist) +
		      output_symtab_info.symtab_command.strsize;
	(void)unlink(output_filename);
	if((fd = open(output_filename, O_WRONLY | O_CREAT | O_TRUNC,
		      0666)) == -1){
	    system_error("can't create output file: %s", output_filename);
	    return_value = 0;
	    goto deallocate_and_return;
	}
	else {
	    /*
	     * Write the entire output file.
	     */
	    if(write(fd, output_addr, output_size + symbol_size) !=
	       (int)(output_size + symbol_size)){
		system_error("can't write output file: %s",output_filename);
		(void)unlink(output_filename);
		return_value = 0;
		goto deallocate_and_return;
	    }
	    if(close(fd) == -1){
		system_error("can't close output file: %s",output_filename);
		(void)unlink(output_filename);
		return_value = 0;
		goto deallocate_and_return;
	    }
	}

deallocate_and_return:

	if((r = vm_deallocate(mach_task_self(), (vm_address_t)(output_addr),
			      output_size)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_deallocate() buffer for output "
		       "file's symbol table");
#ifdef RLD_VM_ALLOC_DEBUG
	print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
	      (unsigned int)(output_addr), output_size);
			     rnd(output_size, host_pagesize)),
	      (unsigned int)deallocate_size);
#endif /* RLD_VM_ALLOC_DEBUG */
	return(return_value);
}
#endif /* !defined(KLD) */

#if !(defined(KLD) && defined(__STATIC__))
/*
 * The debugger places a break point at this routine and it is called when the
 * the loaded state into the program has changed.
 */
static
void
rld_loaded_state_changed(
void)
{
#ifdef RLD_TEST

    unsigned long i, j;

	if(rld_maintain_states == TRUE)
	    print("rld_maintain_states = TRUE\n");
	else
	    print("rld_maintain_states = FALSE\n");
	print("rld_nloaded_states = %lu\n", rld_nloaded_states);
	print("rld_loaded_state 0x%x\n", (unsigned int)rld_loaded_state);
	for(i = 0; i < rld_nloaded_states; i++){
	    print("state %lu\n\tnobject_filenames %lu\n\tobject_filenames 0x%x"
		 "\n\theader_addr 0x%x\n", i,
		 rld_loaded_state[i].nobject_filenames,
		 (unsigned int)(rld_loaded_state[i].object_filenames),
		 (unsigned int)(rld_loaded_state[i].header_addr));
	    for(j = 0; j < rld_loaded_state[i].nobject_filenames; j++)
		print("\t\t%s\n", rld_loaded_state[i].object_filenames[j]);
	}
#endif /* RLD_TEST */
}
#endif /* !(defined(KLD) && defined(__STATIC__)) */

#ifndef KLD
/*
 * rld_get_loaded_state() is returned by moninitrld() to allow the profiling
 * runtime routine monoutput() to get the rld_loaded_state and write it into
 * the gmon.out file for later processing by gprof(1).
 */
static
void
rld_get_loaded_state(
struct rld_loaded_state **s,
unsigned long *n)
{
	*s = rld_loaded_state;
	*n = rld_nloaded_states;
}

/*
 * moninitrld() is called from the profiling runtime routine moninit() to cause 
 * the rld loaded code to be profiled.  It is passed a pointer to the the
 * profiling runtime routine monaddtion() to be called after a sucessfull
 * rld_load.  It returns a pointer to rld_get_loaded_state() and is used as
 * described above.
 */
void (*
moninitrld(
void (*m)(char *lowpc, char *highpc))
)(struct rld_loaded_state **s, unsigned long *n)
{
	rld_monaddition = m;
	return(rld_get_loaded_state);
}

/*
 * rld_get_current_header() is only used by the objective-C runtime to do
 * unloading to get the current header so it does not have to save this
 * information.  It returns NULL if there is nothing is loaded currently.
 */
char *
rld_get_current_header(
void)
{
	/*
	 * If no set has been loaded at this point return NULL.
	 */
	if(cur_set == -1)
	    return(NULL);
	else
	    return(sets[cur_set].output_addr);
}
#endif /* !defined(KLD) */

/*
 * rld_address_func() is passed a pointer to a function that is then called on
 * subsequent rld_load() calls to get the address that the user wants the object
 * set loaded at.  That function is passed the memory size of the resulting
 * object set.
 */
void
#ifdef KLD
kld_address_func(
#else /* !defined(KLD) */
rld_address_func(
#endif /* KLD */
unsigned long (*func)(unsigned long size, unsigned long headers_size))
{
	address_func = func;
}

/*
 * kld_set_link_options() .
 */
void
#ifdef KLD
kld_set_link_options(
#else /* !defined(KLD) */
rld_set_link_options(
#endif /* KLD */
unsigned long link_options)
{
#ifdef KLD
	if(KLD_STRIP_NONE & link_options)
	    kld_requested_strip_level = STRIP_NONE;
	else
#endif /* KLD */
	    kld_requested_strip_level = STRIP_ALL;
}
#endif /* !defined(SA_RLD) */

/*
 * cleanup() is called by all routines handling fatal errors.
 */
__private_extern__
void
cleanup(void)
{
	fatals = 1;
	longjmp(rld_env, 1);
}

#if !defined(SA_RLD) && !defined(KLD)
/*
 * All printing of all messages goes through this function.
 */
__private_extern__
void
vprint(
const char *format,
va_list ap)
{
	if(error_stream != NULL)
	    NXVPrintf(error_stream, format, ap);
NXVPrintf(error_stream, format, ap);
}
#endif /* !defined(SA_RLD) && !defined(KLD) */

#ifdef KLD
/*
 * All printing of all messages goes through this function.
 */
__private_extern__
void
vprint(
const char *format,
va_list ap)
{
	kld_error_vprintf(format, ap);
}
#endif /* KLD */

#if !defined(SA_RLD) && !defined(KLD)
/*
 * allocate() is just a wrapper around malloc that prints and error message and
 * exits if the malloc fails.
 */
__private_extern__
void *
allocate(
unsigned long size)
{
    void *p;

	if(zonep == NULL){
	    zonep = NXCreateZone(vm_page_size, vm_page_size, 1);
	    if(zonep == NULL)
		fatal("can't create NXZone");
	    NXNameZone(zonep, "rld");
	}
	if(size == 0)
	    return(NULL);
	if((p = NXZoneMalloc(zonep, size)) == NULL)
	    system_fatal("virtual memory exhausted (NXZoneMalloc failed)");
	return(p);
}

/*
 * reallocate() is just a wrapper around realloc that prints and error message
 * and exits if the realloc fails.
 */
__private_extern__
void *
reallocate(
void *p,
unsigned long size)
{
	if(zonep == NULL){
	    zonep = NXCreateZone(vm_page_size, vm_page_size, 1);
	    if(zonep == NULL)
		fatal("can't create NXZone");
	    NXNameZone(zonep, "rld");
	}
	if(p == NULL)
	    return(allocate(size));
	if((p = NXZoneRealloc(zonep, p, size)) == NULL)
	    system_fatal("virtual memory exhausted (NXZoneRealloc failed)");
	return(p);
}
#endif /* !defined(SA_RLD) && !defined(KLD) */

#ifdef SA_RLD
/*
 * These two variables are set in sa_rld() and used in layout_segments()
 * as the place to put the output in memory.
 */
__private_extern__ char         *sa_rld_output_addr = NULL;
__private_extern__ unsigned long sa_rld_output_size = 0;

/*
 * These two variables are set in sa_rld() and used in vprint() (defined in this
 * file) as the buffer to put error messages and the size of the buffer.
 */
static char         *sa_rld_error_buf_addr = NULL;
static unsigned long sa_rld_error_buf_size = 0;

/*
 * If this is FALSE the SA_RLD malloc package has not been initialized
 * and needs to be.
 */
static enum bool sa_rld_malloc_initialized = FALSE;

/*
 * sa_rld_internal() is the function that implements sa_rld() and
 * sa_rld_with_symtab().  If symtab is NULL then the symbol table is found via
 * the mach header.
 */
static
int
sa_rld_internal(
char		   *basefile_name,  /* base file name */
struct mach_header *basefile_addr,  /* mach header of the base file */

char               *object_name,    /* name of the object to load */
char               *object_addr,    /* addr of the object in memory to load */
unsigned long       object_size,    /* size of the object in memory to load */

char               *workmem_addr,   /* address of working memory */
unsigned long      *workmem_size,   /* size of working memory (in/out) */

char               *error_buf_addr, /* address of error message buffer */
unsigned long       error_buf_size, /* size of error message buffer */

char               *malloc_addr,    /* address to use for initializing malloc */
unsigned long       malloc_len,     /* length to use for same */

struct nlist       *symtab,         /* pointer to the symbol table */
unsigned long      nsyms,           /* number of symbols */

char               *strtab,         /* pointer to the string table */
unsigned long      strsize)         /* sizeof the string table */
{
    int status;
    struct segment_command *linkedit;

	/*
	 * Initialized the stand alone malloc package if needed.
	 */
	if(sa_rld_malloc_initialized == FALSE){
	    malloc_init(malloc_addr, malloc_len, 1000);
	    sa_rld_malloc_initialized = TRUE;
	}

	/*
	 * Set up and handle link edit errors and fatal errors
	 */
	if(setjmp(rld_env) != 0){
	    /*
	     * It takes a longjmp() to get to this point.  If it was not a fatal
	     * error unload the base file being loaded.  Otherwise just return
	     * failure.
	     */
	    if(fatals == 0)
		rld_unload_all(NULL, 1);
	    return(0);
	}

	/* This must be cleared for each call to rld() */
	errors = 0;

	/* Set up the globals for rld */
#ifdef KLD
	progname = "kld()";
#else /* !defined(KLD) */
	progname = "rld()";
#endif /* KLD */
	host_pagesize = getpagesize();
	host_byte_sex = get_host_byte_sex();
	strip_base_symbols = TRUE;
	force_cpusubtype_ALL = TRUE;

	/* Set up the globals for sa_rld */
	sa_rld_output_size = *workmem_size;
	sa_rld_output_addr = workmem_addr;
	sa_rld_error_buf_addr = error_buf_addr;
	sa_rld_error_buf_size = error_buf_size;

	/*
	 * If the symbols from base program has not been loaded load them.
	 * This will happen the first time rld() is called or will not happen.
	 */
	if(base_obj == NULL){
 	    if(symtab == NULL){
		linkedit = getsegbynamefromheader(basefile_addr, SEG_LINKEDIT);
		if(linkedit != NULL)
		    merge_base_program(basefile_name, basefile_addr, linkedit,
					NULL, 0, NULL, 0);
	    }
	    else{
		merge_base_program(basefile_name, basefile_addr, NULL,
				   symtab, nsyms, strtab, strsize);
	    }
	    if (target_byte_sex == UNKNOWN_BYTE_SEX)
		target_byte_sex = host_byte_sex;
	    /*
	     * If there were any errors in processing the base program it is
	     * treated as a fatal error and no futher processing is done.
	     */
	    if(errors){
		fatals = 1;
		return(0);
	    }
	}

	/*
	 * The work of loading the mapped file is done like very much like
	 * a call to rld_load_from_memory().
	 */
	status = internal_rld_load(NULL, /* NXStream *stream */
				   NULL, /* struct mach_header **header_addr */
				   NULL, /* char * const *object_filenames, */
				   NULL, /* char *output_filename */
				   object_name, object_addr, object_size);
	if(status == 0)
	    return(0);

	/*
	 * Now that the mapped file has been loaded unload it but leave the
	 * linked output in memory.  This is done with a normal call to
	 * internal_rld_unload() which has in it an ifdef SA_RLD to not
	 * deallocate the output memory.
	 */ 
	status = internal_rld_unload(NULL, FALSE);

	/*
	 * Return the size of the working memory used for the output.
	 */
	*workmem_size = output_size;

	return(status);
}

/*
 * sa_rld() loads the specified object in memory against the specified base file
 * in memory.  The output is placed in memory starting at the value of the
 * parameter workmem_addr and the size of the memory used for the output
 * returned indirectly through workmem_size.  Initially *workmem_size is the
 * size of the working memory.
 */
int
sa_rld(
char		   *basefile_name,  /* base file name */
struct mach_header *basefile_addr,  /* mach header of the base file */

char               *object_name,    /* name of the object to load */
char               *object_addr,    /* addr of the object in memory to load */
unsigned long       object_size,    /* size of the object in memory to load */

char               *workmem_addr,   /* address of working memory */
unsigned long      *workmem_size,   /* size of working memory (in/out) */

char               *error_buf_addr, /* address of error message buffer */
unsigned long       error_buf_size, /* size of error message buffer */

char               *malloc_addr,    /* address to use for initializing malloc */
unsigned long       malloc_len)     /* length to use for same */
{
	return(sa_rld_internal(basefile_name, basefile_addr, object_name,
			       object_addr, object_size, workmem_addr,
			       workmem_size, error_buf_addr, error_buf_size,
			       malloc_addr, malloc_len, NULL, 0, NULL, 0));
}

/*
 * sa_rld_with_symtab() is the same as sa_rld() except it passed in a pointer
 * to the symbol table, its size and a pointer to the string table and its
 * size.  Rather getting the the symbol table off of the mach header and the
 * link edit segment.
 */
int
sa_rld_with_symtab(
char		   *basefile_name,  /* base file name */
struct mach_header *basefile_addr,  /* mach header of the base file */

char               *object_name,    /* name of the object to load */
char               *object_addr,    /* addr of the object in memory to load */
unsigned long       object_size,    /* size of the object in memory to load */

char               *workmem_addr,   /* address of working memory */
unsigned long      *workmem_size,   /* size of working memory (in/out) */

char               *error_buf_addr, /* address of error message buffer */
unsigned long       error_buf_size, /* size of error message buffer */

char               *malloc_addr,    /* address to use for initializing malloc */
unsigned long       malloc_len,     /* length to use for same */

struct nlist       *symtab,         /* pointer to the symbol table */
unsigned long      nsyms,           /* number of symbols */

char               *strtab,         /* pointer to the string table */
unsigned long      strsize)         /* sizeof the string table */
{
	return(sa_rld_internal(basefile_name, basefile_addr, object_name,
			       object_addr, object_size, workmem_addr,
			       workmem_size, error_buf_addr, error_buf_size,
			       malloc_addr, malloc_len, symtab, nsyms, strtab,
			       strsize));
}

/*
 * All printing of all SA_RLD messages goes through this function.
 */
__private_extern__
void
vprint(
const char *format,
va_list ap)
{
    unsigned long new;

	new = slvprintf(sa_rld_error_buf_addr,
			sa_rld_error_buf_size, format, ap);
	sa_rld_error_buf_addr += new;
	sa_rld_error_buf_size -= new;
}
#endif /* SA_RLD */

#if defined(SA_RLD) || defined(KLD)

/*
 * allocate() is just a wrapper around malloc that prints and error message and
 * exits if the malloc fails.
 */
__private_extern__
void *
allocate(
unsigned long size)
{
    void *p;

	if(size == 0)
	    return(NULL);
	if((p = malloc(size)) == NULL)
	    fatal("virtual memory exhausted (malloc failed)");
	return(p);
}

/*
 * reallocate() is just a wrapper around realloc that prints and error message
 * and exits if the realloc fails.
 */
__private_extern__
void *
reallocate(
void *p,
unsigned long size)
{
	if(p == NULL)
	    return(allocate(size));
	if((p = realloc(p, size)) == NULL)
	    fatal("virtual memory exhausted (realloc failed)");
	return(p);
}
#endif /* defined(SA_RLD) || defined(KLD) */

/*
 * savestr() malloc's space for the string passed to it, copys the string into
 * the space and returns a pointer to that space.
 */
__private_extern__
char *
savestr(
const char *s)
{
    long len;
    char *r;

	len = strlen(s) + 1;
	r = (char *)allocate(len);
	strcpy(r, s);
	return(r);
}

#if defined(KLD) && defined(__STATIC__)
/*
 * The Kernel framework does not provide this API so we have a copy here.
 */
__private_extern__
struct mach_header *
_NSGetMachExecuteHeader(void)
{
    return((struct mach_header *)&_mh_execute_header);
}
#endif /* defined(KLD) && defined(__STATIC__) */

#endif /* RLD */
                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/sections.c                               0100644 0001750 0001750 00000641034 12612724205 023041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to manage the merging of the sections that
 * appear in the headers of the input files.  It builds a merged section table
 * (which is a linked list of merged_segments with merged_sections linked to
 * them).  The merged section list becomes the output files's section list.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <sys/time.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/ppc/reloc.h>
#include <mach-o/hppa/reloc.h>
#include <ar.h>
#include "stuff/arch.h"
#include "stuff/reloc.h"

#include "ld.h"
#include "specs.h"
#include "live_refs.h"
#include "objects.h"
#include "pass1.h"
#include "symbols.h"
#include "sections.h"
#include "cstring_literals.h"
#include "4byte_literals.h"
#include "8byte_literals.h"
#include "literal_pointers.h"
#include "indirect_sections.h"
#include "mod_sections.h"
#include "coalesced_sections.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "i860_reloc.h"
#include "ppc_reloc.h"
#include "m88k_reloc.h"
#include "hppa_reloc.h"
#include "sparc_reloc.h"
#include "arm_reloc.h"
#include "sets.h"
#include "hash_string.h"
#include "layout.h"
#include "dylibs.h"

/* the pointer to the head of the output file's section list */
__private_extern__ struct merged_segment *merged_segments = NULL;
#ifdef RLD
/*
 * The pointer to the head of the output file's section list before they are
 * all placed in one segment for the MH_OBJECT format in layout().  This is
 * used in reset_merged_sections() to put the list back with it's original
 * segments.
 */
__private_extern__ struct merged_segment *original_merged_segments = NULL;
#endif /* RLD */

/*
 * Any debug sections will be merged in the first pass and placed in their
 * merged segments to allow for error checking.  Their contents are not put in
 * the output file so before the segments are layed out they are removed from
 * the list by remove_debug_segments() and placed on this list.
 */
__private_extern__ struct merged_segment *debug_merged_segments = NULL;

/*
 * The total number relocation entries, used only in layout() to help
 * calculate the size of the link edit segment.
 */
__private_extern__ unsigned long nreloc = 0;

/*
 * This is set to TRUE if any of the input objects do not have the
 * MH_SUBSECTIONS_VIA_SYMBOLS bit set in the mach_header flags field.
 */
__private_extern__ enum bool some_non_subsection_via_symbols_objects = FALSE;

/* table for S_* flags (section types) for error messages */
static const char *
#ifndef __DYNAMIC__
const
#endif
section_flags[] = {
	"S_REGULAR",
	"S_ZEROFILL",
	"S_CSTRING_LITERALS",
	"S_4BYTE_LITERALS",
	"S_8BYTE_LITERALS",
	"S_LITERAL_POINTERS",
	"S_NON_LAZY_SYMBOL_POINTERS",
	"S_LAZY_SYMBOL_POINTERS",
	"S_SYMBOL_STUBS",
	"S_MOD_INIT_FUNC_POINTERS",
	"S_MOD_TERM_FUNC_POINTERS",
	"S_COALESCED"
};

#ifndef RLD
/*
 * These are the arrays used for finding archive,object,symbol name
 * triples and object,symbol name pairs when processing -sectorder options.
 * The array of symbol names is the load_order structure pointed to by
 * the cur_load_orders field of the object_file structure.
 */
struct archive_name {
    char *archive_name;	/* name of the archive file */
    struct object_name
	*object_names;	/* names of the archive members */
    unsigned long
	nobject_names;	/* number of archive members */
};
static struct archive_name *archive_names = NULL;
static unsigned long narchive_names = 0;

struct object_name {
    char *object_name;	/* name of object file */
    unsigned long
	index_length;	/* if this is not in an archive its an index into the */
			/*  object_name to the base name of the object file */
			/*  name else it is the length of the object name */
			/*  which is an archive member name that may have */
			/*  been truncated. */
    struct object_file	/* pointer to the object file */
	*object_file;
};
static struct object_name *object_names = NULL;
static unsigned long nobject_names = 0;

struct load_symbol {
    char *symbol_name;	/* the symbol name this is hashed on */
    char *object_name;	/* the loaded object that contains this symbol */
    char *archive_name;	/* the loaded archive that contains this object */
			/*  or NULL if not in an archive */
    unsigned long
	index_length;	/* if archive_name is NULL the this is index into the */
			/*  object_name to the base name of the object file */
			/*  name else it is the length of the object name */
			/*  which is an archive member name that may have */
			/*  been truncated. */
    struct load_order
	*load_order;	/* the load order for the above triple names */
    struct load_symbol
	*other_names;	/* other load symbols for the same symbol_name */
    struct load_symbol
	*next;		/* next hash table pointer */
};
#define LOAD_SYMBOL_HASHTABLE_SIZE 10000
static struct load_symbol **load_symbol_hashtable = NULL;
static struct load_symbol *load_symbols = NULL;
static unsigned long load_symbols_size = 0;
static unsigned long load_symbols_used = 0;
static unsigned long ambiguous_specifications = 0;

static void layout_ordered_section(
    struct merged_section *ms);
static void create_name_arrays(
    void);
static struct archive_name *create_archive_name(
    char *archive_name);
static void create_object_name(
    struct object_name **object_names,
    unsigned long *nobject_names,
    char *object_name,
    unsigned long index_length,
    char *archive_name);
static void free_name_arrays(
    void);
static void create_load_symbol_hash_table(
    unsigned long nsection_symbols,
    struct merged_section *ms);
static void free_load_symbol_hash_table(
    void);
static void create_load_symbol_hash_table_for_object(
    char *archive_name,
    char *object_name,
    unsigned long index_length,
    struct load_order *load_orders,
    unsigned long nload_orders,
    struct merged_section *ms);
static struct load_order *lookup_load_order(
    char *archive_name,
    char *object_name,
    char *symbol_name,
    struct merged_section *ms,
    unsigned long line_number);
static char * trim(
    char *name);
static struct section_map *lookup_section_map(
    char *archive_name,
    char *object_name);
static int qsort_load_order_names(
    const struct load_order *load_order1,
    const struct load_order *load_order2);
static int bsearch_load_order_names(
    char *symbol_name,
    const struct load_order *load_order);
static int qsort_load_order_input_offset(
    const struct load_order *load_order1,
    const struct load_order *load_order2);
static int qsort_archive_names(
    const struct archive_name *archive_name1,
    const struct archive_name *archive_name2);
static int bsearch_archive_names(
    const char *name,
    const struct archive_name *archive_name);
static int qsort_object_names(
    const struct object_name *object_name1,
    const struct object_name *object_name2);
static int bsearch_object_names(
    const char *name,
    const struct object_name *object_name);
static int qsort_fine_reloc_input_offset(
    const struct fine_reloc *fine_reloc1,
    const struct fine_reloc *fine_reloc2);
static int qsort_order_load_map_orders(
    const struct order_load_map *order_load_map1,
    const struct order_load_map *order_load_map2);
static void create_order_load_maps(
    struct merged_section *ms,
    unsigned long norder_load_maps);
#ifdef DEBUG
static void print_symbol_name_from_order_load_maps(
    struct section_map *map,
    unsigned long value);
#endif /* DEBUG */
static void resize_live_section(
    struct merged_section *ms);
static void count_relocs(
    struct section_map *map,
    struct relocation_info *relocs,
    unsigned long *nlocrel,
    unsigned long *nextrel);
#endif /* !defined(RLD) */
static void scatter_copy(
    struct section_map *map,
    char *contents);
#ifndef RLD
static void reloc_output_for_dyld(
    struct section_map *map,
    struct relocation_info *relocs,
    struct relocation_info *output_locrel,
    struct relocation_info *output_extrel,
    unsigned long *nlocrel,
    unsigned long *nextrel);
static enum bool is_merged_section_read_only(
    struct merged_section *key);
static unsigned long scatter_copy_relocs(
    struct section_map *map,
    struct relocation_info *relocs,
    struct relocation_info *output_relocs);
static double calculate_time_used(
    struct timeval *start,
    struct timeval *end);
static void build_references(
    void);
static void print_references(
    void);
static void setup_references_in_section(
    struct merged_section *ms);
static void setup_references(
    struct section_map *map,
    struct object_file *obj);
static void setup_reference(
    struct live_ref *ref,
    struct object_file *obj,
    struct fine_reloc *self_fine_reloc);
static void mark_all_fine_relocs_live_in_section(
    struct merged_section *ms);
/*
 * The routines that walk the references these are the operations:
 * mark live references
 * search down for any live references (and if so mark it live)
 * check for references that touch a live block (and if so mark it live)
 */
enum walk_references_operation {
    MARK_LIVE,
    SEARCH_FOR_LIVE,
    CHECK_FOR_LIVE_TOUCH
};
#ifdef DEBUG
char * walk_references_operation_names[] = {
    "MARK_LIVE",
    "SEARCH_FOR_LIVE",
    "CHECK_FOR_LIVE_TOUCH"
};
#endif /* DEBUG */
static void walk_references_in_section(
    enum walk_references_operation operation,
    struct merged_section *ms);
static enum bool walk_references(
    enum walk_references_operation operation,
    struct fine_reloc *fine_reloc,
    struct section_map *map,
    struct object_file *obj);
static enum bool ref_operation(
    enum walk_references_operation operation,
    struct ref *ref,
    struct object_file *obj);

#endif /* !defined(RLD) */
#ifdef DEBUG
static void print_load_symbol_hash_table(
    void);
#endif /* DEBUG */

/*
 * merge_sections() merges the sections of the current object file (cur_obj)
 * into the merged section list that will be in the output file.  For each
 * section in the current object file it records the offset that section will
 * start in the output file.  It also accumulates the size of each merged
 * section, the number of relocation entries in it and the maximum alignment.
 */
__private_extern__
void
merge_sections(void)
{
    unsigned long i;
    struct section *s;
    struct merged_section *ms;
    struct mach_header *mh;

	/*
	 * We need to preserve the marking of objects that can have their
	 * sections safely divided up by the symbols for dead code stripping.
	 * Only if all input objects are marked with this will the output also
	 * be marked with this.
	 */
	if(cur_obj != base_obj){
	    mh = (struct mach_header *)(cur_obj->obj_addr);
	    if((mh->flags & MH_SUBSECTIONS_VIA_SYMBOLS) !=
	       MH_SUBSECTIONS_VIA_SYMBOLS){
		some_non_subsection_via_symbols_objects = TRUE;
	    }
	}

	for(i = 0; i < cur_obj->nsection_maps; i++){
	    s = cur_obj->section_maps[i].s;
	    ms = create_merged_section(s);
	    if(errors)
		return;
	    cur_obj->section_maps[i].output_section = ms;
	    /*
	     * If this is a debug section it will not be in the output file.
	     * Set the debug attribute in the merged section (if dynamic is
	     * TRUE it would not have been set).  Then just return not
	     * accounting for it size, alignment and number of relocation		     * entries as none of that info will be in the output file.
	     * Also set output_uuid_info.emit to TRUE since we have seen an
	     * input file with a debug section.
	     */
	    if((s->flags & S_ATTR_DEBUG) == S_ATTR_DEBUG){
		ms->s.flags |= S_ATTR_DEBUG;
		output_uuid_info.emit = TRUE;
		continue;
	    }
	    switch(ms->s.flags & SECTION_TYPE){
	    case S_REGULAR:
	    case S_ZEROFILL:
		/*
		 * For the base file of an incremental link all that is needed
		 * is the section (and it's alignment) so the symbols can refer
		 * to them.  Their contents do not appear in the output file.
		 * If the section size is zero then do NOT adjust the merged
		 * section size to the alignment because if the merged size
		 * was not aligned then that area created does not get flushed
		 * because its associated with a section of size 0.
		 */
		if(cur_obj != base_obj && s->size != 0){
		    cur_obj->section_maps[i].flush_offset = ms->s.size;
		    ms->s.size = rnd(ms->s.size, 1 << s->align);
		    cur_obj->section_maps[i].offset = ms->s.size;
		    ms->s.size   += s->size;
		    ms->s.nreloc += s->nreloc;
		    nreloc += s->nreloc;
		}
#ifdef KLD
		/*
		 * For KLD the section's alignment from the base file is NOT
		 * picked up.
		 */
		if(cur_obj != base_obj)
#endif /* KLD */
		    if(s->align > ms->s.align)
			ms->s.align = s->align;
		if(dynamic == TRUE)
		    ms->s.flags |= (s->flags & SECTION_ATTRIBUTES);
		break;

	    case S_CSTRING_LITERALS:
	    case S_4BYTE_LITERALS:
	    case S_8BYTE_LITERALS:
	    case S_LITERAL_POINTERS:
	    case S_SYMBOL_STUBS:
	    case S_NON_LAZY_SYMBOL_POINTERS:
	    case S_LAZY_SYMBOL_POINTERS:
	    case S_MOD_INIT_FUNC_POINTERS:
	    case S_MOD_TERM_FUNC_POINTERS:
	    case S_COALESCED:
		if(arch_flag.cputype == CPU_TYPE_I860)
			error_with_cur_obj("literal section (%.16s,%.16s) "
		    		       "not allowed in I860 cputype objects",
				       ms->s.segname, ms->s.sectname);
#ifdef KLD
		/*
		 * For KLD the section's alignment from the base file is NOT
		 * picked up.
		 */
		if(cur_obj != base_obj)
#endif /* KLD */
		    if(s->align > ms->s.align)
			ms->s.align = s->align;
		if(dynamic == TRUE)
		    ms->s.flags |= (s->flags & SECTION_ATTRIBUTES);
		break;

	    default:
		fatal("internal error: merge_section() called "
		    "with unknown section type (0x%x) for section (%.16s,"
		    "%.16s)", (unsigned int)(ms->s.flags & SECTION_TYPE),
		    ms->s.segname, ms->s.sectname);
		break;
	    }
#ifndef RLD
	    /*
	     * For dynamic shared libraries record the section map of the
	     * (__OBJC,__module_info) section so it can be used to fill in
	     * objc_module_info_{addr,size} of the module table entries.
	     * Also check to see that it is a regular section.
	     */
	    if(filetype == MH_DYLIB &&
	       strcmp(s->segname, SEG_OBJC) == 0 &&
	       strcmp(s->sectname, SECT_OBJC_MODULES) == 0){
		if((ms->s.flags & SECTION_TYPE) != S_REGULAR)
		    error_with_cur_obj("for MH_DYLIB output files section "
			"(%.16s,%.16s) must have a section type of S_REGULAR",
			s->segname, s->sectname);
		cur_obj->objc_module_info = cur_obj->section_maps + i;
	    }
#endif
	}
}

/*
 * create_merged_section() looks for the section passed to it in the merged
 * section list.  If the section is found then it is check to see the flags
 * of the section matches and if so returns a pointer to the merged section
 * structure for it.  If the flags don't match it is an error.  If no merged
 * section structure is found then one is created and added to the end of the
 * list and a pointer to it is returned.
 */
__private_extern__
struct merged_section *
create_merged_section(
struct section *s)
{
    struct merged_segment **p, *msg;
    struct merged_section **q, **r, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    /* see if this is section is in this segment */
	    if(strncmp(msg->sg.segname, s->segname, sizeof(s->segname)) == 0){
		/*
		 * If this segment contains debug sections then this section too
		 * must be a debug section.  And if it exists and does not
		 * contain debug sections then this section must not be a debug
		 * section.
		 */
		if(msg->debug_only == TRUE &&
		   (s->flags & S_ATTR_DEBUG) != S_ATTR_DEBUG){
		    error_with_cur_obj("section's (%.16s,%.16s) does not have "
			"have debug attribute (S_ATTR_DEBUG) which does not "
			"match previously loaded object's sections for this "
			"segment", s->segname, s->sectname);
		    return(NULL);
		}
		if(msg->debug_only == FALSE &&
		   (s->flags & S_ATTR_DEBUG) == S_ATTR_DEBUG){
		    error_with_cur_obj("section's (%.16s,%.16s) has debug "
			"attribute (S_ATTR_DEBUG) which does not match "
			"previously loaded object's sections for this segment",
			s->segname, s->sectname);
		    return(NULL);
		}
		/*
		 * Depending on the flags of the section depends on which list
		 * it might be found in.  In either case it must not be found in
		 * the other list.
		 */
		if((s->flags & SECTION_TYPE) == S_ZEROFILL){
		    q = &(msg->zerofill_sections);
		    r = &(msg->content_sections);
		}
		else{
		    q = &(msg->content_sections);
		    r = &(msg->zerofill_sections);
		}
		/* check to see if it is in the list it might be found in */
		while(*q){
		    ms = *q;
		    if(strncmp(ms->s.sectname, s->sectname,
			       sizeof(s->sectname)) == 0){
			if((ms->s.flags & SECTION_TYPE) !=
			   (s->flags & SECTION_TYPE)){
			    error_with_cur_obj("section's (%.16s,%.16s) type "
				"%s does not match previous objects type %s",
				s->segname, s->sectname,
				section_flags[s->flags & SECTION_TYPE],
				section_flags[ms->s.flags & SECTION_TYPE]);
			    return(NULL);
			}
			if((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
			   ms->s.reserved2 != s->reserved2){
			    error_with_cur_obj("section's (%.16s,%.16s) sizeof "
				"stub %u does not match previous objects "
				"sizeof stub %u", s->segname, s->sectname,
				s->reserved2, ms->s.reserved2);
			    return(NULL);
			}
			return(ms);
		    }
		    q = &(ms->next);
		}
		/*
		 * It was not found in the list it might be in so check to make
		 * sure it is not in the other list where it shouldn't be. 
		 */
		while(*r){
		    ms = *r;
		    if(strncmp(ms->s.sectname, s->sectname,
			       sizeof(s->sectname)) == 0){
			error_with_cur_obj("section's (%.16s,%.16s) type %s "
			    "does not match previous objects type %s",
			    s->segname, s->sectname,
			    section_flags[s->flags & SECTION_TYPE],
			    section_flags[ms->s.flags & SECTION_TYPE]);
			return(NULL);
		    }
		    r = &(ms->next);
		}
		/* add it to the list it should be in */
		msg->sg.nsects++;
		*q = allocate(sizeof(struct merged_section));
		ms = *q;
		memset(ms, '\0', sizeof(struct merged_section));
		strncpy(ms->s.sectname, s->sectname, sizeof(s->sectname));
		strncpy(ms->s.segname, s->segname, sizeof(s->segname));
		/*
		 * This needs to be something other than zero (NO_SECT) so the
		 * call to the *_reloc() routines in count_reloc() can determine
		 * if a relocation to a symbol stub is now referencing an
		 * absolute symbol with a pcrel relocation entry.
		 */
		ms->output_sectnum = 1;
		if(dynamic != TRUE)
		    ms->s.flags = (s->flags & ~SECTION_ATTRIBUTES);
		else
		    ms->s.flags = s->flags;
		if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS){
		    ms->literal_data = allocate(sizeof(struct cstring_data));
		    memset(ms->literal_data, '\0', sizeof(struct cstring_data));
		    ms->literal_merge = cstring_merge;
		    ms->literal_order = cstring_order;
		    ms->literal_reset_live = cstring_reset_live;
		    ms->literal_output = cstring_output;
		    ms->literal_free = cstring_free;
		}
		else if((ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS){
		    ms->literal_data = allocate(sizeof(struct literal4_data));
		    memset(ms->literal_data, '\0',sizeof(struct literal4_data));
		    ms->literal_merge = literal4_merge;
		    ms->literal_order = literal4_order;
		    ms->literal_reset_live = literal4_reset_live;
		    ms->literal_output = literal4_output;
		    ms->literal_free = literal4_free;
		}
		else if((ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS){
		    ms->literal_data = allocate(sizeof(struct literal8_data));
		    memset(ms->literal_data, '\0',sizeof(struct literal8_data));
		    ms->literal_merge = literal8_merge;
		    ms->literal_order = literal8_order;
		    ms->literal_reset_live = literal8_reset_live;
		    ms->literal_output = literal8_output;
		    ms->literal_free = literal8_free;
		}
		else if((ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS){
		    ms->literal_data =
				  allocate(sizeof(struct literal_pointer_data));
		    memset(ms->literal_data, '\0',
					   sizeof(struct literal_pointer_data));
		    ms->literal_merge = literal_pointer_merge;
		    ms->literal_order = literal_pointer_order;
		    ms->literal_reset_live = literal_pointer_reset_live;
		    ms->literal_output = literal_pointer_output;
 		    ms->literal_free = literal_pointer_free;
		}
#ifndef SA_RLD
		else if((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		   (ms->s.flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
		   (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS){
		    ms->literal_data =
			allocate(sizeof(struct indirect_section_data));
		    memset(ms->literal_data, '\0',
			   sizeof(struct indirect_section_data));
		    ms->literal_merge = indirect_section_merge;
		    ms->literal_order = indirect_section_order;
		    ms->literal_reset_live = indirect_section_reset_live;
		    ms->literal_output = NULL;
		    ms->literal_free = indirect_section_free;
		    if((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS)
			ms->s.reserved2 = s->reserved2;
		}
#endif /* !defined(SA_RLD) */
		else if((ms->s.flags & SECTION_TYPE) ==
			S_MOD_INIT_FUNC_POINTERS ||
		        (ms->s.flags & SECTION_TYPE) ==
			S_MOD_TERM_FUNC_POINTERS){
		    ms->literal_data = allocate(sizeof(struct mod_term_data));
		    memset(ms->literal_data, '\0',
			   sizeof(struct mod_term_data));
		    ms->literal_merge = mod_section_merge;
		    ms->literal_order = mod_section_order;
		    ms->literal_reset_live = mod_section_reset_live;
		    ms->literal_output = NULL;
 		    ms->literal_free = mod_section_free;
		}
		else if((ms->s.flags & SECTION_TYPE) == S_COALESCED){
		    ms->literal_data = NULL;
		    ms->literal_merge = coalesced_section_merge;
		    ms->literal_order = coalesced_section_order;
		    ms->literal_reset_live = coalesced_section_reset_live;
		    ms->literal_output = NULL;
		    ms->literal_free = NULL;
		}
#ifdef RLD
		ms->set_num = cur_set;
#endif /* RLD */
		return(ms);
	    }
	    p = &(msg->next);
	}
	/*
	 * The segment this section is in wasn't found so add a merged segment
	 * for it and add a merged section to that segment for this section.
	 */
	*p = allocate(sizeof(struct merged_segment));
	msg = *p;
	memset(msg, '\0', sizeof(struct merged_segment));
	strncpy(msg->sg.segname, s->segname, sizeof(s->segname));
	msg->sg.nsects = 1;
	msg->filename = outputfile;
#ifdef RLD
	msg->set_num = cur_set;
#endif /* RLD */
	if((s->flags & SECTION_TYPE) == S_ZEROFILL)
	    q = &(msg->zerofill_sections);
	else
	    q = &(msg->content_sections);
	*q = allocate(sizeof(struct merged_section));
	ms = *q;
	memset(ms, '\0', sizeof(struct merged_section));
	strncpy(ms->s.sectname, s->sectname, sizeof(s->sectname));
	strncpy(ms->s.segname, s->segname, sizeof(s->segname));
	/*
	 * This needs to be something other than zero (NO_SECT) so the
	 * call to the *_reloc() routines in count_reloc() can determine
	 * if a relocation to a symbol stub is now referencing an
	 * absolute symbol with a pcrel relocation entry.
	 */
	ms->output_sectnum = 1;
	if(dynamic != TRUE)
	    ms->s.flags = (s->flags & ~SECTION_ATTRIBUTES);
	else
	    ms->s.flags = s->flags;
	if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS){
	    ms->literal_data = allocate(sizeof(struct cstring_data));
	    memset(ms->literal_data, '\0', sizeof(struct cstring_data));
	    ms->literal_merge = cstring_merge;
	    ms->literal_order = cstring_order;
	    ms->literal_reset_live = cstring_reset_live;
	    ms->literal_output = cstring_output;
	    ms->literal_free = cstring_free;
	}
	else if((ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS){
	    ms->literal_data = allocate(sizeof(struct literal4_data));
	    memset(ms->literal_data, '\0', sizeof(struct literal4_data));
	    ms->literal_merge = literal4_merge;
	    ms->literal_order = literal4_order;
	    ms->literal_reset_live = literal4_reset_live;
	    ms->literal_output = literal4_output;
	    ms->literal_free = literal4_free;
	}
	else if((ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS){
	    ms->literal_data = allocate(sizeof(struct literal8_data));
	    memset(ms->literal_data, '\0', sizeof(struct literal8_data));
	    ms->literal_merge = literal8_merge;
	    ms->literal_order = literal8_order;
	    ms->literal_reset_live = literal8_reset_live;
	    ms->literal_output = literal8_output;
	    ms->literal_free = literal8_free;
	}
	else if((ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS) {
	    ms->literal_data = allocate(sizeof(struct literal_pointer_data));
	    memset(ms->literal_data, '\0', sizeof(struct literal_pointer_data));
	    ms->literal_merge = literal_pointer_merge;
	    ms->literal_order = literal_pointer_order;
	    ms->literal_reset_live = literal_pointer_reset_live;
	    ms->literal_output = literal_pointer_output;
	    ms->literal_free = literal_pointer_free;
	}
#ifndef SA_RLD
	else if((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
	   (ms->s.flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
	   (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS){
	    ms->literal_data = allocate(sizeof(struct indirect_section_data));
	    memset(ms->literal_data, '\0',sizeof(struct indirect_section_data));
	    ms->literal_merge = indirect_section_merge;
	    ms->literal_order = indirect_section_order;
	    ms->literal_reset_live = indirect_section_reset_live;
	    ms->literal_output = NULL;
	    ms->literal_free = indirect_section_free;
	    if((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS)
		ms->s.reserved2 = s->reserved2;
	}
#endif /* !defined(SA_RLD) */
	else if((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
		(ms->s.flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS){
	    ms->literal_data = NULL;
	    ms->literal_merge = mod_section_merge;
	    ms->literal_order = mod_section_order;
	    ms->literal_reset_live = mod_section_reset_live;
	    ms->literal_output = NULL;
	    ms->literal_free = NULL;
	}
	else if((ms->s.flags & SECTION_TYPE) == S_COALESCED){
	    ms->literal_data = NULL;
	    ms->literal_merge = coalesced_section_merge;
	    ms->literal_order = coalesced_section_order;
	    ms->literal_reset_live = coalesced_section_reset_live;
	    ms->literal_output = NULL;
	    ms->literal_free = NULL;
	}
#ifdef RLD
	ms->set_num = cur_set;
#endif /* RLD */
	msg->debug_only = (s->flags & S_ATTR_DEBUG) == S_ATTR_DEBUG;
	return(ms);
}

/*
 * lookup_merged_segment() looks up the specified segment name 
 * in the merged segment list and returns a pointer to the
 * merged segment if it exist.  It returns NULL if it doesn't exist.
 */
__private_extern__
struct merged_segment *
lookup_merged_segment(
char *segname)
{
    struct merged_segment **p, *msg;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    if(strncmp(msg->sg.segname, segname, sizeof(msg->sg.segname)) == 0)
		return(msg);
	    p = &(msg->next);
	}
	return(NULL);
}

/*
 * lookup_merged_section() looks up the specified section name 
 * (segname,sectname) in the merged section list and returns a pointer to the
 * merged section if it exist.  It returns NULL if it doesn't exist.
 */
__private_extern__
struct merged_section *
lookup_merged_section(
char *segname,
char *sectname)
{
    struct merged_segment **p, *msg;
    struct merged_section **q, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    if(strncmp(msg->sg.segname, segname, sizeof(msg->sg.segname)) == 0){
		q = &(msg->content_sections);
		while(*q){
		    ms = *q;
		    if(strncmp(ms->s.sectname, sectname,
			       sizeof(ms->s.sectname)) == 0){
			return(ms);
		    }
		    q = &(ms->next);
		}
		q = &(msg->zerofill_sections);
		while(*q){
		    ms = *q;
		    if(strncmp(ms->s.sectname, sectname,
			       sizeof(ms->s.sectname)) == 0){
			return(ms);
		    }
		    q = &(ms->next);
		}
		return(NULL);
	    }
	    p = &(msg->next);
	}
	return(NULL);
}

/*
 * remove_debug_segments() removed the debug segments from the list of merged
 * segments.  These segments and the sections in them are on the merged list in
 * pass1 to allow checking that all sections in the segment are debug section.
 * This gets called in layout_segments() so that these segments are not in the
 * output.  The output_sectnum for these sections is set to MAX_SECT+1 so that
 * it can't match any legal section number in the output, so when searching an
 * object's section map for a matching output section number it is never
 * matched.
 */
__private_extern__
void
remove_debug_segments(
void)
{
    struct merged_segment **p, **q, *msg;
    struct merged_section **c, *ms;

	p = &merged_segments;
	q = &debug_merged_segments;
	while(*p){
	    msg = *p;
	    /*
	     * If this is a segment with only debug sections take it off the
	     * list of merged_segments and put it on the list of
	     * debug_merged_segments.
	     */
	    if(msg->debug_only == TRUE){
		*q = msg;
		q = &(msg->next);
		*p = msg->next;
		/*
		 * Set the output_sectnum to an value that is not legal so it
		 * won't be matched when searching for output symbols section
		 * incorrectly to this section.
		 */
		c = &(msg->content_sections);
		while(*c){
		    ms = *c;
		    ms->output_sectnum = MAX_SECT + 1;
		    c = &(ms->next);
		}
		/*
		 * We leave this merged segment to point to the next segment
		 * in the list so we can walk the rest of the list of merged
		 * segments.  Even though this is a debug segment.  We will
		 * terminate the list of debug segments after the end of the
		 * loop.
		 */
	    }
	    p = &(msg->next);
	}
	/*
	 * If we put any debug segments on the list of debug_merged_segments
	 * then set the last one's next pointer to NULL to terminate the list.
	 */
	if(*q != NULL){
	    *q = NULL;
	}
}

/*
 * merge_literal_sections() goes through all the object files to be loaded and
 * merges the literal sections from them.  This is called from layout(), with
 * redo_live == FALSE, and has to be done after all the alignment from all the
 * sections headers have been merged and the command line section alignment has
 * been folded in.  This way the individual literal items from all the objects
 * can be aligned to the output alignment.
 *
 * If -dead_strip is specified this is called a second time from layout() with
 * redo_live == TRUE.  In this case it is used to drive re-merging of only live
 * literals.
 */
__private_extern__
void
merge_literal_sections(
enum bool redo_live)
{
    unsigned long i, j;
    struct object_list *object_list, **p;
    struct merged_section *ms;
#ifndef RLD
    struct merged_segment **q, *msg;
    struct merged_section **content;

	/*
	 * If any literal (except literal pointer) section has an order file
	 * then process it for that section if redo_live == FALSE.  If redo_live
	 * is TRUE then we are being called a second time so instead call the
	 * literal_reset_live function that resets the literal section before
	 * only the live literals are re-merged.
	 */
	q = &merged_segments;
	while(*q){
	    msg = *q;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS ||
		   (ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS ||
		   (ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS ||
		   (ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		   (ms->s.flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS||
		   (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		   (ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
		   (ms->s.flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS ||
		   (ms->s.flags & SECTION_TYPE) == S_COALESCED){
		    if(redo_live == FALSE){
			if(ms->order_filename != NULL)
			    (*ms->literal_order)(ms->literal_data, ms);
		    }
		    else
			(*ms->literal_reset_live)(ms->literal_data, ms);
		}
		content = &(ms->next);
	    }
	    q = &(msg->next);
	}
#endif /* !defined(RLD) */

	/*
	 * Merged the literals for each object for each section that is a 
	 * literal (but not a literal pointer section).
	 */
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
#ifdef RLD
		if(cur_obj->set_num != cur_set)
		    continue;
#endif /* RLD */
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    ms = cur_obj->section_maps[j].output_section;
		    if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS ||
		       (ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS ||
		       (ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS ||
		       (ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		       (ms->s.flags & SECTION_TYPE) ==
						S_NON_LAZY_SYMBOL_POINTERS ||
		       (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		       (ms->s.flags & SECTION_TYPE) ==
						S_MOD_INIT_FUNC_POINTERS ||
		       (ms->s.flags & SECTION_TYPE) ==
						S_MOD_TERM_FUNC_POINTERS ||
		       (ms->s.flags & SECTION_TYPE) == S_COALESCED)
		       (*ms->literal_merge)(ms->literal_data, ms,
					     cur_obj->section_maps[j].s,
					     &(cur_obj->section_maps[j]),
					     redo_live);
		}
	    }
	}

#ifndef RLD
	/*
	 * Now that the the literals are all merged if any literal pointer
	 * section has an order file then process it for that section if
	 * redo_live == FALSE. If redo_live is TRUE then we are being called a
	 * second time so instead call the literal_reset_live function that
	 * resets the literal section before only the live literals are
	 * re-merged.
	 */
	q = &merged_segments;
	while(*q){
	    msg = *q;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if((ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS){
		    if(redo_live == FALSE){
			if(ms->order_filename != NULL)
			    (*ms->literal_order)(ms->literal_data, ms);
		    }
		    else{
			(*ms->literal_reset_live)(ms->literal_data, ms);
		    }
		}
		content = &(ms->next);
	    }
	    q = &(msg->next);
	}
#endif /* !defined(RLD) */
	/*
	 * Now that the the literals are all merged merge the literal pointers
	 * for each object for each section that is a a literal pointer section.
	 */
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
#ifdef RLD
		if(cur_obj->set_num != cur_set)
		    continue;
#endif /* RLD */
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    ms = cur_obj->section_maps[j].output_section;
		    if((ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS)
			(*ms->literal_merge)(ms->literal_data, ms,
					     cur_obj->section_maps[j].s,
					     &(cur_obj->section_maps[j]),
					     redo_live);
		}
	    }
	}
}

#ifndef RLD
/*
 * layout_ordered_sections() calls layout_ordered_section() for each section
 * that has an order file specified with -sectorder, or if -dead_strip is
 * specified.
 */
__private_extern__
void
layout_ordered_sections(void)
{
    enum bool ordered_sections;
    struct merged_segment **p, *msg;
    struct merged_section **content, **zerofill, *ms;
    struct object_file *last_object;

	/*
	 * Determine if their are any sections that have an order file or 
	 * -dead_strip is specified and if not just return.  This saves
	 * creating the name arrays when there is no need to.
	 */
	ordered_sections = FALSE;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->order_filename != NULL){
		    ordered_sections = TRUE;
		    break;
		}
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		if(ms->order_filename != NULL){
		    ordered_sections = TRUE;
		    break;
		}
		zerofill = &(ms->next);
	    }
	    if(ordered_sections == TRUE)
		break;
	    p = &(msg->next);
	}
	if(ordered_sections == FALSE && dead_strip == FALSE)
	    return;

	/*
	 * Add the object file the common symbols that the link editor allocated
	 * into the object file list.
	 */
	last_object = add_last_object_file(&link_edit_common_object);

	/*
	 * Build the arrays of archive names and object names which along
	 * with the load order maps will be use to search for archive,object,
	 * symbol name triples from the load order files specified by the user.
	 */
	create_name_arrays();
#ifdef DEBUG
	if(debug & (1 << 13))
	    print_name_arrays();
#endif /* DEBUG */

	/*
	 * For each merged section that has a load order file, or all merged
	 * sections if -dead_strip is specified, layout all objects that have
	 * this section in it.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		/* no load order for this section, or no -dead_strip continue */
		if((ms->order_filename == NULL && dead_strip == FALSE) ||
		   ms->contents_filename != NULL){
		    content = &(ms->next);
		    continue;
		}
		/*
		 * If a regular section (not a literal section) then layout
		 * the sections using symbol names.  Literal sections are
		 * handled by their specific literal merge functions.
		 */
		if((ms->s.flags & SECTION_TYPE) == S_REGULAR)
		    layout_ordered_section(ms);
		if(errors != 0)
		    return;
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		/* no load order for this section, or no -dead_strip continue */
		if(ms->order_filename == NULL && dead_strip == FALSE){
		    zerofill = &(ms->next);
		    continue;
		}
		layout_ordered_section(ms);
		if(errors != 0)
		    return;
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}

	/*
	 * Free the space for the symbol table.
	 */
	free_load_symbol_hash_table();

	/*
	 * Free the space for the name arrays if there has been no load order
	 * map specified (this is because the map has pointers to the object
	 * names that were allocated in the name arrarys).
	 */
	if(load_map == FALSE)
	    free_name_arrays();

	/*
	 * Remove the object file the common symbols that the link editor
	 * allocated from the object file list.
	 */
	remove_last_object_file(last_object);
}

/*
 * layout_ordered_section() creates the fine reloc maps for the section in
 * each object from the load order file specified with -sectorder.
 */
static
void
layout_ordered_section(
struct merged_section *ms)
{
    unsigned long i, j, k, l;
    struct object_list *object_list, **q;

    unsigned long nsect, nload_orders, nsection_symbols;
    struct load_order *load_orders;
    enum bool start_section, any_order;

    struct nlist *object_symbols;
    char *object_strings;

    unsigned long n, order, output_offset, line_number, line_length;
    unsigned long unused_specifications, no_specifications;
    char *line, *archive_name, *object_name, *symbol_name;
    struct load_order *load_order;
    struct section_map *section_map;
    kern_return_t r;

    struct fine_reloc *fine_relocs;
    struct merged_symbol *merged_symbol;

	/*
	 * Reset the count of the number of symbol for this
	 * section (used as the number of load_symbol structs
	 * to allocate).
	 */
	nsection_symbols = 0;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		/*
		 * Reset the current section map which points to the
		 * load order map and count in this object that
		 * is being processed for this merged section.  This
		 * will be used in later loops to avoid going through
		 * the section maps again.
		 */
		cur_obj->cur_section_map = NULL;

		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(cur_obj->section_maps[j].output_section != ms)
			continue;
		    if(cur_obj->section_maps[j].s->size == 0)
			continue;
		    /*
		     * We can only handle only be one of these sections in
		     * the section maps for a given object file but their might
		     * be more than one.  So this test will check to see if
		     * more than one section with the same name exists in the
		     * same object.
		     */
		    if(cur_obj->cur_section_map != NULL){
			error_with_cur_obj("can't use -sectorder or -dead_strip"
			    " with objects that contain more than one section "
			    "with the same name (section %d and %ld are both "
			    "named (%.16s,%.16s))", cur_obj->cur_section_map -
			    cur_obj->section_maps + 1, j + 1, ms->s.segname,
			    ms->s.sectname);
			return;
		    }

		    cur_obj->cur_section_map = &(cur_obj->section_maps[j]);

		    /*
		     * Count the number of symbols in this section in
		     * this object file.  For this object nsect is the
		     * section number for the merged section.  Also
		     * acount for one extra symbol if there is no symbol
		     * at the beginning of the section.
		     */
		    object_symbols = (struct nlist *)(cur_obj->obj_addr 
					     + cur_obj->symtab->symoff);
		    object_strings = (char *)(cur_obj->obj_addr +
					       cur_obj->symtab->stroff);
		    nsect = j + 1;
		    nload_orders = 0;
		    start_section = FALSE;
		    for(k = 0; k < cur_obj->symtab->nsyms; k++){
			if(object_symbols[k].n_sect == nsect &&
			   (object_symbols[k].n_type & N_STAB) == 0){
			    nload_orders++;
			    if(object_symbols[k].n_value == 
			       cur_obj->section_maps[j].s->addr)
				start_section = TRUE;
			}
		    }
		    if(start_section == FALSE)
			nload_orders++;

		    /*
		     * Allocate the load order map for this section in
		     * this object file and set the current section map
		     * in this object that will point to the load order
		     * map and count.
		     */
		    load_orders = allocate(sizeof(struct load_order) *
					   nload_orders);
		    memset(load_orders, '\0',
			   sizeof(struct load_order) * nload_orders);
		    cur_obj->section_maps[j].nload_orders= nload_orders;
		    cur_obj->section_maps[j].load_orders = load_orders;
		    cur_obj->cur_section_map =
					    &(cur_obj->section_maps[j]);
		    cur_obj->cur_section_map->start_section = start_section;

		    /*
		     * Fill in symbol names and values the load order
		     * map for this section in this object file.
		     */
		    l = 0;
		    if(start_section == FALSE){
			load_orders[l].name = ".section_start";
			load_orders[l].value =
				       cur_obj->section_maps[j].s->addr;
			l++;
		    }
		    for(k = 0; k < cur_obj->symtab->nsyms; k++){
			if(object_symbols[k].n_sect == nsect &&
			   (object_symbols[k].n_type & N_STAB) == 0){
			    load_orders[l].name = object_strings +
					  object_symbols[k].n_un.n_strx;
			    load_orders[l].value =
					  object_symbols[k].n_value;
			    load_orders[l].index = k;
			    l++;
			}
		    }
#ifdef DEBUG
		    if(debug & (1 << 14))
			print_load_order(load_orders, nload_orders, ms,
					 cur_obj, "names and values");
#endif /* DEBUG */

		    /*
		     * Sort the load order map by symbol value so the
		     * size and input offset fields can be set.
		     */
		    qsort(load_orders,
			  nload_orders,
			  sizeof(struct load_order),
			  (int (*)(const void *, const void *))
					       qsort_load_order_values);
		    for(l = 0; l < nload_orders - 1; l++){
			load_orders[l].input_offset =
				       load_orders[l].value -
				       cur_obj->section_maps[j].s->addr;
			load_orders[l].input_size =
					      load_orders[l + 1].value -
					      load_orders[l].value;
		    }
		    load_orders[l].input_offset = load_orders[l].value -
				       cur_obj->section_maps[j].s->addr;
		    load_orders[l].input_size =
				      cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size -
				      load_orders[l].value;
#ifdef DEBUG
		    if(debug & (1 << 15))
			print_load_order(load_orders, nload_orders, ms,
					 cur_obj, "sizes and offsets");
#endif /* DEBUG */

		    /*
		     * Now sort the load order map by symbol name so
		     * that it can be used for lookup.
		     */
		    qsort(load_orders,
			  nload_orders,
			  sizeof(struct load_order),
			  (int (*)(const void *, const void *))
					       qsort_load_order_names);
#ifdef DEBUG
		    if(debug & (1 << 16))
			print_load_order(load_orders, nload_orders, ms,
					 cur_obj, "sorted by name");
#endif /* DEBUG */
		    /*
		     * Increment the number of load_symbol needed for
		     * this section by the number of symbols in this
		     * object.
		     */
		    nsection_symbols += nload_orders;

		    /*
		     * We can only handle one of these sections in the section
		     * maps for a given object file but their might be more than
		     * one.  So let the loop continue and the test at the top
		     * of the loop will check to see if more than one section
		     * with the same name exists in the same object.
		     */
		}
	    }
	}
	/*
	 * Create the load_symbol hash table.  Used for looking up
	 * symbol names and trying to match load order file lines to
	 * them if the line is not a perfect match.
	 */
	create_load_symbol_hash_table(nsection_symbols, ms);
	
	/*
	 * Clear the counter of ambiguous secifications before the next
	 * section is processed.
	 */
	ambiguous_specifications = 0;
#ifdef DEBUG
	if(debug & (1 << 13))
	    print_load_symbol_hash_table();
#endif /* DEBUG */

	/*
	 * Parse the load order file by changing '\n' to '\0'.
	 */
	for(i = 0; i < ms->order_size; i++){
	    if(ms->order_addr[i] == '\n')
		ms->order_addr[i] = '\0';
	}

	/*
	 * For lines in the order file set the orders and output_offset
	 * in the load maps for this section in all the object files
	 * that have this section.
	 */
	order = 1;
	output_offset = 0;
	line_number = 1;
	unused_specifications = 0;
	for(i = 0; i < ms->order_size; ){
	    line = ms->order_addr + i;
	    line_length = strlen(line);

	    /*
	     * Igore lines that start with a '#'.
	     */
	    if(*line == '#'){
		i += line_length + 1;
		line_number++;
		continue;
	    }

	    parse_order_line(line, &archive_name, &object_name, &symbol_name,
			     ms, line_number);

	    load_order = lookup_load_order(archive_name, object_name,
					   symbol_name, ms, line_number);
	    if(load_order != NULL){
		if(load_order->order != 0){
		    if(archive_name == NULL){
			if(*object_name == '\0'){
			    warning("multiple specification of symbol: %s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s)",
				    symbol_name, ms->order_filename,
				    line_number, ms->s.segname,
				    ms->s.sectname);
			}
			else{
			    warning("multiple specification of %s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s)", object_name,
				    symbol_name, ms->order_filename,
				    line_number, ms->s.segname,
				    ms->s.sectname);
			}
		    }
		    else
			warning("multiple specification of %s:%s:%s in "
				"-sectorder file: %s line %lu for "
				"section (%.16s,%.16s)", archive_name,
				object_name, symbol_name,
				ms->order_filename, line_number,
				ms->s.segname, ms->s.sectname);
		}
		else{
		    load_order->order = order++;
		    load_order->line_number = line_number;
		    output_offset = align_to_input_mod(output_offset,
						       load_order->input_offset,
						       ms->s.align);
		    load_order->output_offset = output_offset;
		    output_offset += load_order->input_size;
		}
	    }
	    else{
		if(strncmp(symbol_name, ".section_offset",
			   sizeof(".section_offset") - 1) == 0){
		    char *p, *endp;
		    unsigned long offset;

		    p = symbol_name + sizeof(".section_offset");
		    offset = strtoul(p, &endp, 0);
		    if(*endp != '\0')
			error("bad specification of .section_offset in "
			      "-sectorder file: %s line %lu for section "
			      "(%.16s,%.16s) (junk after offset value)",
			      ms->order_filename, line_number, ms->s.segname,
			      ms->s.sectname);
		    else if(offset < output_offset)
			error("bad offset value (0x%x) of .section_offset in "
			      "-sectorder file: %s line %lu for section "
			      "(%.16s,%.16s) (value less than current "
			      "offset 0x%x)", (unsigned int)offset,
			      ms->order_filename, line_number, ms->s.segname,
			      ms->s.sectname, (unsigned int)output_offset);
		    else
			output_offset = offset;
		}
		if(strncmp(symbol_name, ".section_align",
			   sizeof(".section_align") - 1) == 0){
		    char *p, *endp;
		    unsigned long align;

		    p = symbol_name + sizeof(".section_align");
		    align = strtoul(p, &endp, 0);
		    if(*endp != '\0')
			error("bad specification of .section_align in "
			      "-sectorder file: %s line %lu for section "
			      "(%.16s,%.16s) (junk after align value)",
			      ms->order_filename, line_number, ms->s.segname,
			      ms->s.sectname);
		    else if(align > MAXSECTALIGN)
			error("bad align value (%lu) of .section_align in "
			      "-sectorder file: %s line %lu for section "
			      "(%.16s,%.16s) (value must be equal to or less "
			      "than %d)", align, ms->order_filename,
			      line_number, ms->s.segname, ms->s.sectname,
			      MAXSECTALIGN);
		    else
			output_offset = rnd(output_offset, 1 << align);
		}
		else if(strcmp(symbol_name, ".section_all") == 0){
		    section_map = lookup_section_map(archive_name,
						     object_name);
		    if(section_map != NULL){
			section_map->no_load_order = TRUE;
			section_map->order = order++;
			output_offset = rnd(output_offset,
					      (1 << section_map->s->align));
			section_map->offset = output_offset;
			output_offset += section_map->s->size;
		    }
		    else if(sectorder_detail == TRUE){
			if(archive_name == NULL){
			    warning("specification of %s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s) not used "
				    "(object with that section not in "
				    "loaded objects)", object_name,
				    symbol_name, ms->order_filename,
				    line_number, ms->s.segname,
				    ms->s.sectname);
			}
			else{
			    warning("specification of %s:%s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s) not used "
				    "(object with that section not in "
				    "loaded objects)", archive_name,
				    object_name, symbol_name,
				    ms->order_filename, line_number,
				    ms->s.segname, ms->s.sectname);
			}
		    }
		    else{
			unused_specifications++;
		    }
		}
		else if(sectorder_detail == TRUE){
		    if(archive_name == NULL){
			warning("specification of %s:%s in -sectorder "
				"file: %s line %lu for section (%.16s,"
				"%.16s) not found in loaded objects",
				object_name, symbol_name,
				ms->order_filename, line_number,
				ms->s.segname, ms->s.sectname);
		    }
		    else{
			warning("specification of %s:%s:%s in "
				"-sectorder file: %s line %lu for "
				"section (%.16s,%.16s) not found in "
				"loaded objects", archive_name,
				object_name, symbol_name,
				ms->order_filename, line_number,
				ms->s.segname, ms->s.sectname);
		    }
		}
		else{
		    unused_specifications++;
		}
	    }
	    i += line_length + 1;
	    line_number++;
	}

	/*
	 * Deallocate the memory for the load order file now that it is
	 * nolonger needed (since the memory has been written on it is
	 * always deallocated so it won't get written to the swap file
	 * unnecessarily).
	 */
	if((r = vm_deallocate(mach_task_self(), (vm_address_t)
	    ms->order_addr, ms->order_size)) != KERN_SUCCESS)
	    mach_fatal(r, "can't vm_deallocate() memory for -sectorder "
		       "file: %s for section (%.16s,%.16s)",
		       ms->order_filename, ms->s.segname,
		       ms->s.sectname);
	ms->order_addr = NULL;

	/*
	 * For all entries in the load maps that do not have an order
	 * because they were not specified in the load order file
	 * assign them an order.
	 */
	no_specifications = 0;
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		if(cur_obj->cur_section_map == NULL)
		    continue;
#ifdef DEBUG
		if(debug & (1 << 17))
		    print_load_order(
				cur_obj->cur_section_map->load_orders,
				cur_obj->cur_section_map->nload_orders,
				ms, cur_obj, "file orders assigned");
#endif /* DEBUG */
		load_order = cur_obj->cur_section_map->load_orders;
		n = cur_obj->cur_section_map->nload_orders;

		/*
		 * When there is no load order or in the case of dead stripping,
		 * we re-sort the load orders by input_offset to keep them in
		 * the "natural" link order.  For dead code stripping this can
		 * still lead to problems with assembly code where blocks can
		 * get removed or padding can be added between blocks for
		 * alignment.  For sections with order files that are incomplete
		 * the "natural" link order is said to be better for symbols not
		 * listed.
		 */
		qsort(load_order, n, sizeof(struct load_order),
		      (int (*)(const void *, const void *))
				       qsort_load_order_input_offset);

		/*
		 * If there is no orders in this object then cause it to be
		 * treated as if it had a .section_all by default unless
		 * -dead_strip is specified.  This is done to help the default
		 * case work in more cases and not scatter the object when no
		 * symbols were ordered from it.
		 */
		any_order = FALSE;
		for(j = 0; j < n; j++){
		    if(load_order[j].order != 0){
			any_order = TRUE;
			break;
		    }
		}
		if(any_order == FALSE &&
		   cur_obj->cur_section_map->no_load_order == FALSE){
		    /*
		     * If -dead_strip is specified, even if this there were
		     * no orders listed in the order file we need to break up
		     * the section into blocks so it can effectively dead
		     * stripped by falling through to the code below.  However
		     * if this section has the no dead strip attribute we will
		     * be keeping all the blocks.  And in this case it is better
		     * to make one block in order to make more cases work.  Or
		     * If this section comes from an object file that is not
		     * marked with MH_SUBSECTIONS_VIA_SYMBOLS we make one block
		     * for the section.
		     */
		    if(dead_strip == FALSE ||
		       (cur_obj->cur_section_map->s->flags &
			S_ATTR_NO_DEAD_STRIP) == S_ATTR_NO_DEAD_STRIP ||
		       (cur_obj->obj_addr != NULL &&
		        (((struct mach_header *)(cur_obj->obj_addr))->flags &
		         MH_SUBSECTIONS_VIA_SYMBOLS) !=
			 MH_SUBSECTIONS_VIA_SYMBOLS)){

			cur_obj->cur_section_map->no_load_order = TRUE;
			if(cur_obj->cur_section_map->order == 0)
			    cur_obj->cur_section_map->order = order++;
			output_offset = rnd(output_offset,
				  (1 << cur_obj->cur_section_map->s->align));
			cur_obj->cur_section_map->offset = output_offset;
			output_offset += cur_obj->cur_section_map->s->size;

			if(sectorder_detail == TRUE &&
			   ms->order_filename != NULL){
			    if(no_specifications == 0)
				warning("no specification for the following "
					"symbols in -sectorder file: %s for "
					"section (%.16s,%.16s):",
					ms->order_filename,
					ms->s.segname, ms->s.sectname);
			    for(j = 0; j < n; j++){
				if(cur_obj->ar_hdr == NULL){
				    if(nowarnings == FALSE)
					print("%s:%s\n", cur_obj->file_name,
					      load_order[j].name);
				}
				else{
				    if(nowarnings == FALSE)
					print("%s:%.*s:%s\n",
					      cur_obj->file_name,
					      (int)cur_obj->ar_name_size,
					      cur_obj->ar_name,
					      load_order[j].name);
				}
			    }
			}
			no_specifications += n;
		    }
		}

		for(j = 0; j < n; j++){
		    if(load_order[j].order == 0){
			if(cur_obj->cur_section_map->no_load_order == TRUE)
			    continue;
			load_order[j].order = order++;
			output_offset = align_to_input_mod(
						    output_offset,
						    load_order[j].input_offset,
						    ms->s.align);
			load_order[j].output_offset = output_offset;
			output_offset += load_order[j].input_size;
			if(sectorder_detail == TRUE &&
			   ms->order_filename != NULL){
			    if(no_specifications == 0)
				warning("no specification for the following "
					"symbols in -sectorder file: %s for "
					"section (%.16s,%.16s):",
					ms->order_filename,
					ms->s.segname, ms->s.sectname);
			    if(cur_obj->ar_hdr == NULL){
				if(nowarnings == FALSE)
				    print("%s:%s\n", cur_obj->file_name,
					  load_order[j].name);
			    }
			    else{
				if(nowarnings == FALSE)
				    print("%s:%.*s:%s\n", cur_obj->file_name,
					  (int)cur_obj->ar_name_size,
					  cur_obj->ar_name, load_order[j].name);
			    }
			}
			no_specifications++;
		    }
		    else{
			if(cur_obj->cur_section_map->no_load_order == TRUE &&
			   any_order == TRUE){
			    if(cur_obj->ar_hdr == NULL){
				error("specification for both %s:%s "
				      "and %s:%s in -sectorder file: "
				      "%s for section (%.16s,%.16s) "
				      "(not allowed)",
				      cur_obj->file_name,
				      ".section_all",
				      cur_obj->file_name,
				      load_order[j].name,
				      ms->order_filename,
				      ms->s.segname, ms->s.sectname);
			    }
			    else{
				error("specification for both "
				      "%s:%.*s:%s and %s:%.*s:%s "
				      "in -sectorder file: %s for "
				      "section (%.16s,%.16s) "
				      "(not allowed)",
				      cur_obj->file_name,
				      (int)cur_obj->ar_name_size,
				      cur_obj->ar_name,
				      ".section_all",
				      cur_obj->file_name,
				      (int)cur_obj->ar_name_size,
				      cur_obj->ar_name,
				      load_order[j].name,
				      ms->order_filename,
				      ms->s.segname, ms->s.sectname);
			    }
			}
		    }
		}

		/*
		 * If .section_all has been seen for this object (or we forced
		 * that effect) and we are creating a load map or -dead_strip
		 * was specified toss the old load_orders and create one load
		 * order that represents the entire section.
		 */ 
		if(cur_obj->cur_section_map->no_load_order == TRUE &&
		   (load_map == TRUE || dead_strip == TRUE)){
		    free(cur_obj->cur_section_map->load_orders);
		    load_order = allocate(sizeof(struct load_order));
		    n = 1;
		    cur_obj->cur_section_map->load_orders = load_order;
		    cur_obj->cur_section_map->nload_orders = n;
		    load_order->order = cur_obj->cur_section_map->order;
		    if(dead_strip == TRUE)
			load_order->name = ".section_all";
		    else
			load_order->name = NULL;
		    load_order->value = cur_obj->section_maps->s->addr;
		    load_order->input_offset = 0;
		    load_order->output_offset = output_offset;
		    load_order->input_size = cur_obj->cur_section_map->s->size;
		}

#ifdef DEBUG
		if(debug & (1 << 18))
		    print_load_order(
				cur_obj->cur_section_map->load_orders,
				cur_obj->cur_section_map->nload_orders,
				ms, cur_obj, "all orders assigned");
#endif /* DEBUG */
	    }
	}
	if(sectorder_detail == FALSE && ms->order_filename != NULL){
	    if(unused_specifications != 0)
		warning("%lu symbols specified in -sectorder file: %s "
			"for section (%.16s,%.16s) not found in "
			"loaded objects", unused_specifications,
			ms->order_filename, ms->s.segname,
			ms->s.sectname);
	    if(no_specifications != 0)
		warning("%lu symbols have no specifications in "
			"-sectorder file: %s for section (%.16s,"
			"%.16s)",no_specifications, ms->order_filename,
			ms->s.segname, ms->s.sectname);
	    if(ambiguous_specifications != 0)
		warning("%lu symbols have ambiguous specifications in "
			"-sectorder file: %s for section (%.16s,"
			"%.16s)", ambiguous_specifications,
			ms->order_filename, ms->s.segname,
			ms->s.sectname);
	}

	/*
	 * There can be seen a ".section_all" and symbol names for the
	 * same object file and these are reported as an error not a
	 * warning.
	 */
	if(errors)
	    return;

	/*
	 * Now the final size of the merged section can be set with all
	 * the contents of the section laid out.
	 */
	ms->s.size = output_offset;

	/*
	 * Finally the fine relocation maps can be allocated and filled
	 * in from the load order maps.
	 */
	object_symbols = NULL;
	object_strings = NULL;
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		if(cur_obj->cur_section_map == NULL)
		    continue;
		/*
		 * If this object file has no load orders (a .section_all for it
		 * was specified) or -dead_strip was spefified and this section
		 * has the no dead strip attribute then just create a single
		 * fine relocation entry for it that take care of the whole
		 * section.
		 */
		if(cur_obj->cur_section_map->no_load_order == TRUE ||
		   (dead_strip == TRUE &&
		    (cur_obj->cur_section_map->s->flags &
		     S_ATTR_NO_DEAD_STRIP) == S_ATTR_NO_DEAD_STRIP &&
		    ms->order_filename == NULL) ){
		    fine_relocs = allocate(sizeof(struct fine_reloc));
		    memset(fine_relocs, '\0', sizeof(struct fine_reloc));
		    cur_obj->cur_section_map->fine_relocs = fine_relocs;
		    cur_obj->cur_section_map->nfine_relocs = 1;
		    fine_relocs[0].input_offset = 0;
		    fine_relocs[0].output_offset =
				       cur_obj->cur_section_map->offset;
		    if(dead_strip == TRUE){
			load_orders = cur_obj->cur_section_map->load_orders;
			load_orders[0].fine_reloc = fine_relocs + 0;
			load_orders[0].order = cur_obj->cur_section_map->order;
		    }
		    continue;
		}
		n = cur_obj->cur_section_map->nload_orders;
		load_orders = cur_obj->cur_section_map->load_orders;
		start_section = cur_obj->cur_section_map->start_section;
		fine_relocs = allocate(sizeof(struct fine_reloc) * n);
		memset(fine_relocs, '\0', sizeof(struct fine_reloc) * n);
		cur_obj->cur_section_map->fine_relocs = fine_relocs;
		cur_obj->cur_section_map->nfine_relocs = n;
		if(dead_strip == TRUE){
		    object_symbols = (struct nlist *)(cur_obj->obj_addr 
					     + cur_obj->symtab->symoff);
		    object_strings = (char *)(cur_obj->obj_addr +
					       cur_obj->symtab->stroff);
		}
		for(j = 0; j < n ; j++){
		    fine_relocs[j].input_offset =
					   load_orders[j].input_offset;
		    fine_relocs[j].output_offset =
					   load_orders[j].output_offset;
		    if(dead_strip == TRUE){
			if((start_section == TRUE || j != 0) &&
			   object_symbols[load_orders[j].index].n_type & N_EXT){
			    merged_symbol = lookup_symbol(object_strings +
				object_symbols[load_orders[j].index].
				    n_un.n_strx);
			    if(merged_symbol->name_len != 0 &&
			       merged_symbol->definition_object == cur_obj){
				fine_relocs[j].merged_symbol = merged_symbol;
				merged_symbol->fine_reloc = fine_relocs + j;
			    }
			}
		    }
		}
		/*
		 * Leave the fine relocation map in sorted order by
		 * their input offset so that the pass2 routines can
		 * use them.
		 */
		qsort(fine_relocs,
		      n,
		      sizeof(struct fine_reloc),
		      (int (*)(const void *, const void *))
					 qsort_fine_reloc_input_offset);

		/*
		 * When -dead_strip is specified resize_live_section() walks the
		 * order_load_map that will be created in
		 * create_order_load_maps() when reassigning the output_offset
		 * to live items.  To know what is live the load_order structs
		 * need to point at the fine_reloc so it can use the live field
		 * in there.  We must set the pointer to the fine_reloc after
		 * the above last sort of the fine_relocs.  To do that we also
		 * sort the load_orders by the input_offset so we can then
		 * assign the correct fine_reloc pointer to the corresponding
		 * load_order.
		 */
		if(dead_strip == TRUE){
		    qsort(load_orders, n, sizeof(struct load_order),
			  (int (*)(const void *, const void *))
					   qsort_load_order_input_offset);
		    for(j = 0; j < n ; j++)
			load_orders[j].fine_reloc = fine_relocs + j;
		}

		/*
		 * The load order maps are now no longer needed unless
		 * the load map (-M) has been specified or we are doing dead
		 * stripping (-dead_strip).
		 */
		if(load_map == FALSE && dead_strip == FALSE){
		    free(cur_obj->cur_section_map->load_orders);
		    cur_obj->cur_section_map->load_orders = NULL;
		    cur_obj->cur_section_map->nload_orders = 0;
		}
	    }
	}

	/*
	 * If the load map option (-M) or dead stripping (-dead_strip) is
	 * specified build the structures to print the map.
	 */
	if(load_map == TRUE || dead_strip == TRUE)
	    create_order_load_maps(ms, order - 1);
}
#endif /* !RLD */

/*
 * align_to_input_mod() is passed the current output_offset, and returns the
 * next output_offset aligned to the passed input offset modulus the passed
 * power of 2 alignment.
 */
__private_extern__
unsigned long
align_to_input_mod(
unsigned long output_offset,
unsigned long input_offset,
unsigned long align)
{
    unsigned long output_mod, input_mod;

	output_mod = output_offset % (1 << align);
	input_mod  = input_offset  % (1 << align);
	if(output_mod <= input_mod)
	    return(output_offset + (input_mod - output_mod));
	else
	    return(rnd(output_offset, (1 << align)) + input_mod);
}

#ifndef RLD
/*
 * is_literal_output_offset_live() is passed a pointer to a merged literal
 * section and an output_offset in there and returns if the literal for that
 * is live.  This is only used literal sections that have order files and when
 * -dead_strip is specified.  It is very brute force and not fast.
 */
__private_extern__
enum bool
is_literal_output_offset_live(
struct merged_section *ms,
unsigned long output_offset)
{
    unsigned long i, j, k, n;
    struct object_list *object_list, **q;
    struct fine_reloc *fine_relocs;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(cur_obj->section_maps[j].output_section != ms)
			continue;
		    fine_relocs = cur_obj->section_maps[j].fine_relocs;
		    n = cur_obj->section_maps[j].nfine_relocs;
		    for(k = 0; k < n ; k++){
			if(fine_relocs[k].output_offset == output_offset &&
			   fine_relocs[k].live == TRUE)
			    return(TRUE);
		    }
		    /*
		     * Since there can only be one of these sections in
		     * the section map and it was found just break out
		     * of the loop looking for it.
		     */
		    break;
		}
	    }
	}
	return(FALSE);
}

/*
 * parse_order_line() parses a load order line into it's archive name, object
 * name and symbol name.  The format for the lines is the following:
 *
 * [<archive name>:]<object name>:<symbol name>
 *
 * If the archive name is not present NULL is returned, if the object name is
 * not present it is set to point at "" and if the symbol name is not present it
 * is set to "".
 */
__private_extern__
void
parse_order_line(
char *line,
char **archive_name,
char **object_name,
char **symbol_name,
struct merged_section *ms,
unsigned long line_number)
{
    unsigned long line_length;
    char *left_bracket;

	/*
	 * The trim has to be done before the checking for objective-C names
	 * syntax because it could have spaces at the end of the line.
	 */ 
	line = trim(line);

	line_length = strlen(line);
	if(line_length == 0){
	    *archive_name = NULL;
	    (*object_name) = "";
	    (*symbol_name) = "";
	    return;
	}

	/*
	 * To allow the objective-C symbol syntax of:
	 * +-[ClassName(CategoryName) Method:Name]
	 * since the method name can have ':'s the brackets
	 * have to be recognized.  This is the only place where
	 * the link editor knows about this.
	 */
	if(line[line_length - 1] == ']'){
	    left_bracket = strrchr(line, '[');
	    if(left_bracket == NULL)
		fatal("format error in -sectorder file: %s line %lu "
		      "for section (%.16s,%.16s) (no matching "
		      "'[' for ending ']' found in symbol name)",
		      ms->order_filename, line_number,
		      ms->s.segname, ms->s.sectname);
	    *left_bracket = '\0';
	    *symbol_name = strrchr(line, ':');
	    *left_bracket = '[';
	}
	/*
	 * A hack for the 3.2 C++ compiler where the symbol name does not end
	 * with a ']' but with the encoded arguments.
	 */
	else if((left_bracket = strrchr(line, '[')) != NULL){
	    *left_bracket = '\0';
	    *symbol_name = strrchr(line, ':');
	    *left_bracket = '[';
	}
	else
	    *symbol_name = strrchr(line, ':');

	if(*symbol_name == NULL){
	    *symbol_name = line;
	    line = "";
	}
	else{
	    **symbol_name = '\0';
	    (*symbol_name)++;
	}

	*object_name = strrchr(line, ':');
	if(*object_name == NULL){
	    *object_name = line;
	    *archive_name = NULL;
	}
	else{
	    **object_name = '\0';
	    (*object_name)++;
	    *archive_name = line;
	}
}

/*
 * create_name_arrays() build the sorted arrays of archive names and object
 * names which along with the load order maps will be use to search for archive,
 * object,symbol name triples from the load order files specified by the user.
 */
static
void
create_name_arrays(void)
{
    unsigned long i;
    long j;
    struct object_list *object_list, **p;
    struct archive_name *ar;
    char *ar_name, *last_slash;

	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		if(cur_obj->command_line)
		    continue;
		if(cur_obj->ar_hdr != NULL){
		    ar = create_archive_name(cur_obj->file_name);
		    ar_name = allocate(cur_obj->ar_name_size + 1);
    		    strncpy(ar_name, cur_obj->ar_name, cur_obj->ar_name_size);
		    ar_name[cur_obj->ar_name_size] = '\0';
		    create_object_name(&(ar->object_names),&(ar->nobject_names),
				       ar_name, strlen(ar_name),
				       cur_obj->file_name);
		}
		else{
		    last_slash = strrchr(cur_obj->file_name, '/');
		    if(last_slash == NULL)
			j = 0;
		    else
			j = last_slash - cur_obj->file_name + 1;
		    create_object_name(&object_names, &nobject_names,
				       cur_obj->file_name, j, NULL);
		}
	    }
	}

	/*
	 * Sort the arrays of names.
	 */
	if(narchive_names != 0){
	    archive_names = reallocate(archive_names, 
				       sizeof(struct archive_name) *
				       narchive_names);
	    qsort(archive_names,
		  narchive_names,
		  sizeof(struct archive_name),
		  (int (*)(const void *, const void *))qsort_archive_names);
	    for(i = 0; i < narchive_names; i++){
		archive_names[i].object_names = reallocate(
						archive_names[i].object_names,
						sizeof(struct object_name) *
						archive_names[i].nobject_names);
		qsort(archive_names[i].object_names,
		      archive_names[i].nobject_names,
		      sizeof(struct object_name),
		      (int (*)(const void *, const void *))qsort_object_names);
	    }
	}
	if(nobject_names != nobjects)
	    object_names = reallocate(object_names,
				  sizeof(struct object_name) * nobject_names);
	qsort(object_names,
	      nobject_names,
	      sizeof(struct object_name),
	      (int (*)(const void *, const void *))qsort_object_names);
}

/*
 * create_archive_name() creates a slot in the archive names array for the name
 * passed to it.  The name may be seen more than once.  The archive name must
 * not have a ':' in it since that is used to delimit names in the -sectorder
 * files.
 */
static
struct archive_name *
create_archive_name(
char *archive_name)
{
    unsigned long i;
    struct archive_name *ar;

	if(strchr(archive_name, ':') != NULL)
	    fatal("archive name: %s has a ':' (it can't when -sectorder "
		  "options are used)", archive_name);
	ar = archive_names;
	for(i = 0; i < narchive_names; i++){
	    if(strcmp(ar->archive_name, archive_name) == 0)
		return(ar);
	    ar++;
	}
	if(archive_names == NULL)
	    archive_names = allocate(sizeof(struct archive_name) * nobjects);
	ar = archive_names + narchive_names;
	narchive_names++;
	ar->archive_name = archive_name;
	ar->object_names = NULL;
	ar->nobject_names = 0;
	return(ar);
}

/*
 * create_object_name() creates a slot in the object names array passed to it
 * for the name passed to it and the current object (cur_obj).  The size of the
 * array is in nobject_names.  Both the object names array and it's size are
 * passed indirectly since it may be allocated to add the name.  The name should
 * not be duplicated in the array.  If this objects array is for an archive
 * the archive_name is passed for error messages and is NULL in not in an
 * archive.  The object name must not have a ':' in it since that is used to
 * delimit names in the -sectorder files.
 */
static
void
create_object_name(
struct object_name **object_names,
unsigned long *nobject_names,
char *object_name,
unsigned long index_length,
char *archive_name)
{
    unsigned long n, i;
    struct object_name *o;

	if(strchr(object_name, ':') != NULL){
	    if(archive_name != NULL)
		fatal("archive member name: %s(%s) has a ':' in it (it can't "
		      "when -sectorder options are used)", archive_name,
		      object_name);
	    else
		fatal("object file name: %s has a ':' in it (it can't when "
		      "-sectorder options are used)", object_name);
	}

	o = *object_names;
	n = *nobject_names;
	for(i = 0; i < n; i++){
	    if(strcmp(o->object_name, object_name) == 0){
		if(archive_name != NULL){
#ifdef notdef
/*
 * Since the 4.4bsd extened format #1 could be used for long member names this
 * warning is now always printed again.
 */
		    struct ar_hdr ar_hdr;
		    /*
		     * The warning is not printed when the name is likely to
		     * have been truncated.  Some tools use the whole ar_name
		     * but ar(1) uses one less so it can put a '\0' in when
		     * in memory.
		     */
		    if(strlen(object_name) != sizeof(ar_hdr.ar_name) &&
		       strlen(object_name) != sizeof(ar_hdr.ar_name) - 1)
#endif
			warning("duplicate archive member name: %s(%s) loaded ("
				"could be ambiguous when -sectorder options "
				"are used)", archive_name, object_name);
		}
		else
		    warning("duplicate object file name: %s loaded (could be "
			    "ambiguous when -sectorder options are used)",
			    object_name);
	    }
	    o++;
	}
	if(*object_names == NULL)
	    *object_names = allocate(sizeof(struct object_name) * nobjects);
	o = *object_names + *nobject_names;
	(*nobject_names)++;
	o->object_name = object_name;
	o->object_file = cur_obj;
	o->index_length = index_length;
}

/*
 * free_name_arrays() frees up the space created for the sorted name arrays.
 */
static
void
free_name_arrays(void)
{
    unsigned long i, j;

	if(archive_names != NULL){
	    for(i = 0; i < narchive_names; i++){
		for(j = 0; j < archive_names[i].nobject_names; j++){
		    free(archive_names[i].object_names[j].object_name);
		}
	    }
	    free(archive_names);
	    archive_names = NULL;
	    narchive_names = 0;
	}
	if(object_names != NULL){
	    free(object_names);
	    object_names = NULL;
	    nobject_names = 0;
	}
}

/*
 * create_load_symbol_hash_table() creates a hash table of all the symbol names
 * in the section for the current section map.  This table is use by
 * lookup_load_order when an exact match for the specification can't be found.
 */
static
void
create_load_symbol_hash_table(
unsigned long nsection_symbols,
struct merged_section *ms)
{
    unsigned long i, j;

	/* set up the hash table */
	if(load_symbol_hashtable == NULL)
	    load_symbol_hashtable = allocate(sizeof(struct load_symbol *) *
					     LOAD_SYMBOL_HASHTABLE_SIZE);
	memset(load_symbol_hashtable, '\0', sizeof(struct load_symbol *) *
					    LOAD_SYMBOL_HASHTABLE_SIZE);

	/* set up the load_symbols */
	if(nsection_symbols > load_symbols_size){
	    load_symbols_size = nsection_symbols;
	    load_symbols = reallocate(load_symbols, sizeof(struct load_symbol) *
						    load_symbols_size);
	}
	memset(load_symbols, '\0', sizeof(struct load_symbol) *
				   load_symbols_size);
	load_symbols_used = 0;

	for(i = 0; i < narchive_names; i++){
	    for(j = 0; j < archive_names[i].nobject_names; j++){
		if(archive_names[i].object_names[j].object_file->
							cur_section_map != NULL)
		    create_load_symbol_hash_table_for_object(
			    archive_names[i].archive_name,
			    archive_names[i].object_names[j].object_name,
			    archive_names[i].object_names[j].index_length,
			    archive_names[i].object_names[j].object_file->
						 cur_section_map->load_orders,
			    archive_names[i].object_names[j].object_file->
						 cur_section_map->nload_orders,
			    ms);
	    }
	}

	for(j = 0; j < nobject_names; j++){
	    if(object_names[j].object_file->cur_section_map != NULL)
		create_load_symbol_hash_table_for_object(
		    NULL,
		    object_names[j].object_name,
		    object_names[j].index_length,
		    object_names[j].object_file->cur_section_map->load_orders,
		    object_names[j].object_file->cur_section_map->nload_orders,
		    ms);
	}
}

/*
 * free_load_symbol_hash_table() frees up the space used by the symbol hash
 * table.
 */
static
void
free_load_symbol_hash_table(
void)
{
	/* free the hash table */
	if(load_symbol_hashtable != NULL)
	    free(load_symbol_hashtable);
	load_symbol_hashtable = NULL;

	/* free the load_symbols */
	if(load_symbols != NULL)
	    free(load_symbols);
	load_symbols_size = 0;
	load_symbols_used = 0;
}

/*
 * create_load_symbol_hash_table_for_object() is used by
 * create_load_symbol_hash_table() to create the hash table of all the symbol
 * names in the section that is being scatter loaded.  This routine enters all
 * the symbol names in the load_orders in to the hash table for the specified
 * archive_name object_name pair.
 */
static
void
create_load_symbol_hash_table_for_object(
char *archive_name,
char *object_name,
unsigned long index_length,
struct load_order *load_orders,
unsigned long nload_orders,
struct merged_section *ms)
{
    unsigned long i, hash_index;
    struct load_symbol *load_symbol, *hash_load_symbol, *other_name;

	for(i = 0; i < nload_orders; i++){
	    /*
	     * Get a new load symbol and set the fields for it this load order
	     * entry.
	     */
	    load_symbol = load_symbols + load_symbols_used;
	    load_symbols_used++;
	    load_symbol->symbol_name = load_orders[i].name;
	    load_symbol->object_name = object_name;
	    load_symbol->archive_name = archive_name;
	    load_symbol->index_length = index_length;
	    load_symbol->load_order = &(load_orders[i]);

	    /* find this symbol's place in the hash table */
	    hash_index = hash_string(load_orders[i].name, NULL) %
			 LOAD_SYMBOL_HASHTABLE_SIZE;
	    for(hash_load_symbol = load_symbol_hashtable[hash_index]; 
		hash_load_symbol != NULL;
		hash_load_symbol = hash_load_symbol->next){
		if(strcmp(load_orders[i].name,
			  hash_load_symbol->symbol_name) == 0)
		    break;
	    }
	    /* if the symbol was not found in the hash table enter it */
	    if(hash_load_symbol == NULL){
		load_symbol->other_names = NULL;
		load_symbol->next = load_symbol_hashtable[hash_index]; 
		load_symbol_hashtable[hash_index] = load_symbol;
	    }
	    else{
		/*
		 * If the symbol was found in the hash table go through the
		 * other load symbols for the same name checking if their is
		 * another with exactly the same archive and object name and
		 * generate a warning if so.  Then add this load symbol to the
		 * list of other names.
		 */
		for(other_name = hash_load_symbol;
		    other_name != NULL && ms->order_filename != NULL;
		    other_name = other_name->other_names){

		    if(archive_name != NULL){
			if(strcmp(other_name->object_name, object_name) == 0 &&
			   other_name->archive_name != NULL &&
			   strcmp(other_name->archive_name, archive_name) == 0){
			    warning("symbol appears more than once in the same "
				    "file (%s:%s:%s) which is ambiguous when "
				    "using a -sectorder option",
				    other_name->archive_name,
				    other_name->object_name,
				    other_name->symbol_name);
			    break;
			}
		    }
		    else{
			if(strcmp(other_name->object_name, object_name) == 0 &&
			   other_name->archive_name == NULL){
			    warning("symbol appears more than once in the same "
				    "file (%s:%s) which is ambiguous when "
				    "using a -sectorder option",
				    other_name->object_name,
				    other_name->symbol_name);
			    break;
			}
		    }
		}
		load_symbol->other_names = hash_load_symbol->other_names;
		hash_load_symbol->other_names = load_symbol;
		load_symbol->next = NULL;
	    }
	}
}

/*
 * lookup_load_order() is passed an archive, object, symbol name triple and that
 * is looked up in the name arrays and the load order map and returns a pointer
 * to the load order map that matches it.  Only archive_name may be NULL on
 * input.  It returns NULL if not found.
 */
static
struct load_order *
lookup_load_order(
char *archive_name,
char *object_name,
char *symbol_name,
struct merged_section *ms,
unsigned long line_number)
{
    struct archive_name *a;
    struct object_name *o;
    struct load_order *l;
    unsigned long n;

    unsigned long hash_index, number_of_matches;
    struct load_symbol *hash_load_symbol, *other_name, *first_match;
    char *last_slash, *base_name, *archive_base_name;

	if(archive_name != NULL){
	    a = bsearch(archive_name, archive_names, narchive_names,
			sizeof(struct archive_name),
			(int (*)(const void *, const void *))
						  	 bsearch_archive_names);
	    if(a == NULL)
		goto no_exact_match;
	    o = a->object_names;
	    n = a->nobject_names;
	}
	else{
	    o = object_names;
	    n = nobject_names;
	}

	o = bsearch(object_name, o, n, sizeof(struct object_name),
		    (int (*)(const void *, const void *))bsearch_object_names);
	if(o == NULL)
	    goto no_exact_match;
	if(o->object_file->cur_section_map == NULL)
	    goto no_exact_match;

	l = o->object_file->cur_section_map->load_orders;
	n = o->object_file->cur_section_map->nload_orders;
	l = bsearch(symbol_name, l, n, sizeof(struct load_order),
		    (int (*)(const void *, const void *))
						      bsearch_load_order_names);
	if(l == NULL)
	    goto no_exact_match;
	return(l);

no_exact_match:
	/*
	 * To get here an exact match of the archive_name, object_name, and
	 * symbol_name was not found so try to find some load_order for the
	 * symbol_name using the hash table of symbol names.  First thing here
	 * is to strip leading and trailing blanks from the names.
	 */
	archive_name = trim(archive_name);
	object_name = trim(object_name);
	symbol_name = trim(symbol_name);

	/* find this symbol's place in the hash table */
	hash_index = hash_string(symbol_name, NULL) %
		     LOAD_SYMBOL_HASHTABLE_SIZE;
	for(hash_load_symbol = load_symbol_hashtable[hash_index]; 
	    hash_load_symbol != NULL;
	    hash_load_symbol = hash_load_symbol->next){
	    if(strcmp(symbol_name, hash_load_symbol->symbol_name) == 0)
		break;
	}
	/* if the symbol was not found then give up */
	if(hash_load_symbol == NULL)
	    return(NULL);

	/* if this symbol is in only one object file then use that */
	if(hash_load_symbol->other_names == NULL)
	    return(hash_load_symbol->load_order);

	/*
	 * Now try to see if their is just one name that has not had an order
	 * specified for it and use that if that is the case.  This ignores both
	 * the archive_name and the object_name.
	 */
	number_of_matches = 0;
	first_match = NULL;
	for(other_name = hash_load_symbol;
	    other_name != NULL;
	    other_name = other_name->other_names){
	    if(other_name->load_order->order == 0){
		if(first_match == NULL)
		    first_match = other_name;
		number_of_matches++;
	    }
	}
	if(number_of_matches == 1)
	    return(first_match->load_order);
	if(number_of_matches == 0)
	    return(NULL);

	/*
	 * Now try to see if their is just one name that the object file name
	 * specified for it matches and use that if that is the case.  Only the
	 * object basename is used and matched against the base name of the
	 * objects or the archive member name that may have been truncated.
	 * This ignores the archive name.
	 */
	last_slash = strrchr(object_name, '/');
	if(last_slash == NULL)
	    base_name = object_name;
	else
	    base_name = last_slash + 1;
	number_of_matches = 0;
	first_match = NULL;
	for(other_name = hash_load_symbol;
	    other_name != NULL;
	    other_name = other_name->other_names){
	    if(other_name->load_order->order == 0){
		if(other_name->archive_name != NULL){
		    if(strncmp(base_name, other_name->object_name,
			       other_name->index_length) == 0){
			if(first_match == NULL)
			    first_match = other_name;
			number_of_matches++;
		    }
		}
		else{
		    if(strcmp(base_name, other_name->object_name +
			      other_name->index_length) == 0){
			if(first_match == NULL)
			    first_match = other_name;
			number_of_matches++;
		    }
		}
	    }
	}
	if(number_of_matches == 1)
	    return(first_match->load_order);

	/*
	 * Now try to see if their is just one name that the base name of the
	 * archive file name specified for it matches and use that if that is
	 * the case.  This ignores the object name.
	 */
	if(archive_name != NULL){
	    last_slash = strrchr(archive_name, '/');
	    if(last_slash == NULL)
		base_name = archive_name;
	    else
		base_name = last_slash + 1;
	    number_of_matches = 0;
	    first_match = NULL;
	    for(other_name = hash_load_symbol;
		other_name != NULL;
		other_name = other_name->other_names){
		if(other_name->load_order->order == 0){
		    if(other_name->archive_name != NULL){
			last_slash = strrchr(other_name->archive_name, '/');
			if(last_slash == NULL)
			    archive_base_name = other_name->archive_name;
			else
			    archive_base_name = last_slash + 1;

			if(strcmp(base_name, archive_base_name) == 0){
			    if(first_match == NULL)
				first_match = other_name;
			    number_of_matches++;
			}
		    }
		}
	    }
	    if(number_of_matches == 1)
		return(first_match->load_order);
	}

	/*
	 * Now we know their is more than one possible match for this symbol
	 * name.  So the first one that does not have an order is picked and
	 * either the ambiguous_specifications count is incremented or warnings
	 * are generated.
	 */
	first_match = NULL;
	for(other_name = hash_load_symbol;
	    other_name != NULL;
	    other_name = other_name->other_names){
	    if(other_name->load_order->order == 0){
		first_match = other_name;
		if(sectorder_detail){
		    if(archive_name != NULL){
			if(other_name->archive_name != NULL)
			    warning("ambiguous specification of %s:%s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s) using %s:%s:%s",
				    archive_name, object_name, symbol_name,
				    ms->order_filename, line_number,
				    ms->s.segname, ms->s.sectname,
				    other_name->archive_name,
				    other_name->object_name,
				    other_name->symbol_name);
			else
			    warning("ambiguous specification of %s:%s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s) using %s:%s",
				    archive_name, object_name, symbol_name,
				    ms->order_filename, line_number,
				    ms->s.segname, ms->s.sectname,
				    other_name->object_name,
				    other_name->symbol_name);
		    }
		    else{
			if(other_name->archive_name != NULL)
			    warning("ambiguous specification of %s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s) using %s:%s:%s",
				    object_name, symbol_name,
				    ms->order_filename, line_number,
				    ms->s.segname, ms->s.sectname,
				    other_name->archive_name,
				    other_name->object_name,
				    other_name->symbol_name);
			else
			    warning("ambiguous specification of %s:%s in "
				    "-sectorder file: %s line %lu for "
				    "section (%.16s,%.16s) using %s:%s",
				    object_name, symbol_name,
				    ms->order_filename, line_number,
				    ms->s.segname, ms->s.sectname,
				    other_name->object_name,
				    other_name->symbol_name);
		    }
		}
		break;
	    }
	}
	if(sectorder_detail == TRUE){
	    for(other_name = hash_load_symbol;
		other_name != NULL;
		other_name = other_name->other_names){
		if(other_name->load_order->order == 0 &&
		   first_match != other_name){
		    if(archive_name != NULL){
			if(other_name->archive_name != NULL)
			    warning("specification %s:%s:%s ambiguous with "
				    "%s:%s:%s", archive_name, object_name,
				    symbol_name, other_name->archive_name,
				    other_name->object_name,
				    other_name->symbol_name);
			else
			    warning("specification %s:%s:%s ambiguous with "
				    "%s:%s", archive_name, object_name,
				    symbol_name, other_name->object_name,
				    other_name->symbol_name);
		    }
		    else{
			if(other_name->archive_name != NULL)
			    warning("specification %s:%s ambiguous with "
				    "%s:%s:%s", object_name, symbol_name,
				    other_name->archive_name,
				    other_name->object_name,
				    other_name->symbol_name);
			else
			    warning("specification %s:%s ambiguous with "
				    "%s:%s", object_name, symbol_name,
				    other_name->object_name,
				    other_name->symbol_name);
		    }
		}
	    }
	}
	else{
	    ambiguous_specifications++;
	}
	return(first_match->load_order);
}

/*
 * trim() is passed a name and trims the spaces off the begining and endding of
 * the name.  It writes '\0' in the spaces at the end of the name.  It returns
 * a pointer into the trimed name.
 */
static
char *
trim(
char *name)
{
    char *p;

	if(name == NULL)
	    return(name);
	
	while(*name != '\0' && *name == ' ')
	    name++;
	if(*name == '\0')
	    return(name);

	p = name;
	while(*p != '\0')
	    p++;
	p--;
	while(p != name && *p == ' ')
	    *p-- = '\0';
	return(name);
}

/*
 * lookup_section_map() is passed an archive, object pair and that is looked up
 * in the name arrays and returns a pointer to the section map that matches it.
 * It returns NULL if not found.
 */
static
struct section_map *
lookup_section_map(
char *archive_name,
char *object_name)
{
    struct archive_name *a;
    struct object_name *o;
    unsigned long n;

	if(archive_name != NULL){
	    a = bsearch(archive_name, archive_names, narchive_names,
			sizeof(struct archive_name),
			(int (*)(const void *, const void *))
						  	 bsearch_archive_names);
	    if(a == NULL)
		return(NULL);
	    o = a->object_names;
	    n = a->nobject_names;
	}
	else{
	    o = object_names;
	    n = nobject_names;
	}

	o = bsearch(object_name, o, n, sizeof(struct object_name),
		    (int (*)(const void *, const void *))bsearch_object_names);
	if(o == NULL)
	    return(NULL);
	return(o->object_file->cur_section_map);
}
#endif /* RLD */

/*
 * Function for qsort to sort load_order structs by their value
 */
__private_extern__
int
qsort_load_order_values(
const struct load_order *load_order1,
const struct load_order *load_order2)
{
	/*
	 * This test is needed to fix an obscure bug where two symbols have
	 * the same value.  This fix makes the load_orders and the fine_relocs
	 * sorted by value end up in the same order even though the load_order
	 * was sorted by name between their sorts by value.  Without this the
	 * blocks for the symbols at the same address get placed in the file
	 * in the wrong place because the subtraction of their input offsets
	 * does not yeild the size of the block in this case.  This is kinda
	 * a funky fix to avoid adding a size field to the fine reloc struct
	 * which would be very expensive in space.
	 */
	if(load_order1->value == load_order2->value)
	    return(strcmp(load_order1->name, load_order2->name));
	else
	    return(load_order1->value - load_order2->value);
}

#ifndef RLD
/*
 * Function for qsort to sort load_order structs by their name.
 */
static
int
qsort_load_order_names(
const struct load_order *load_order1,
const struct load_order *load_order2)
{
	return(strcmp(load_order1->name, load_order2->name));
}

/*
 * Function for bsearch to search load_order structs for their name.
 */
static
int
bsearch_load_order_names(
char *symbol_name,
const struct load_order *load_order)
{
	return(strcmp(symbol_name, load_order->name));
}

/*
 * Function for qsort to sort load_order structs by their input_offset.
 */
static
int
qsort_load_order_input_offset(
const struct load_order *load_order1,
const struct load_order *load_order2)
{
	/*
	 * This test is needed to fix an obscure bug where two symbols have
	 * the same value.  This fix makes the load_orders and the fine_relocs
	 * sorted by value end up in the same order even though the load_order
	 * was sorted by name between their sorts by value then by name.
	 */
	if(load_order1->input_offset == load_order2->input_offset)
	    return(strcmp(load_order1->name, load_order2->name));
	else
	    return(load_order1->input_offset - load_order2->input_offset);
}

/*
 * Function for qsort for comparing archive names.
 */
static
int
qsort_archive_names(
const struct archive_name *archive_name1,
const struct archive_name *archive_name2)
{
	return(strcmp(archive_name1->archive_name,
		      archive_name2->archive_name));
}

/*
 * Function for bsearch for finding archive names.
 */
static
int
bsearch_archive_names(
const char *name,
const struct archive_name *archive_name)
{
	return(strcmp(name, archive_name->archive_name));
}

/*
 * Function for qsort for comparing object names.
 */
static
int
qsort_object_names(
const struct object_name *object_name1,
const struct object_name *object_name2)
{
	return(strcmp(object_name1->object_name,
		      object_name2->object_name));
}

/*
 * Function for bsearch for finding object names.
 */
static
int
bsearch_object_names(
const char *name,
const struct object_name *object_name)
{
	return(strcmp(name, object_name->object_name));
}

/*
 * Function for qsort to sort fine_reloc structs by their input_offset
 */
static
int
qsort_fine_reloc_input_offset(
const struct fine_reloc *fine_reloc1,
const struct fine_reloc *fine_reloc2)
{
	return(fine_reloc1->input_offset - fine_reloc2->input_offset);
}

/*
 * Function for qsort to sort order_load_map structs by their order.
 */
static
int
qsort_order_load_map_orders(
const struct order_load_map *order_load_map1,
const struct order_load_map *order_load_map2)
{
	return(order_load_map1->order - order_load_map2->order);
}

/*
 * create_order_load_map() creates the structures to be use for printing the
 * load map and for -dead_strip.
 */
static
void
create_order_load_maps(
struct merged_section *ms,
unsigned long norder_load_maps)
{
    unsigned long i, j, k, l, m, n;
    struct order_load_map *order_load_maps;
    struct load_order *load_orders;

	order_load_maps = allocate(sizeof(struct order_load_map) *
				   norder_load_maps);
	ms->order_load_maps = order_load_maps;
	ms->norder_load_maps = norder_load_maps;
	l = 0;
	for(i = 0; i < narchive_names; i++){
	    for(j = 0; j < archive_names[i].nobject_names; j++){
	        cur_obj = archive_names[i].object_names[j].object_file;
		for(m = 0; m < cur_obj->nsection_maps; m++){
		    if(cur_obj->section_maps[m].output_section != ms)
			continue;
/*
		    if(cur_obj->section_maps[m].no_load_order == TRUE){
			continue;
		    }
*/
		    n = cur_obj->section_maps[m].nload_orders;
		    load_orders = cur_obj->section_maps[m].load_orders;
		    for(k = 0; k < n ; k++){
		        order_load_maps[l].archive_name = 
			    archive_names[i].archive_name;
		        order_load_maps[l].object_name = 
			    archive_names[i].object_names[j].object_name;
		        order_load_maps[l].symbol_name = load_orders[k].name;
		        order_load_maps[l].value = load_orders[k].value;
		        order_load_maps[l].section_map =
			    &(cur_obj->section_maps[m]);
		        order_load_maps[l].size = load_orders[k].input_size;
		        order_load_maps[l].order = load_orders[k].order;
			order_load_maps[l].load_order = load_orders + k;
		        l++;
		    }
		    break;
		}
	    }
	}
	for(j = 0; j < nobject_names; j++){
	    cur_obj = object_names[j].object_file;
	    for(m = 0; m < cur_obj->nsection_maps; m++){
		if(cur_obj->section_maps[m].output_section != ms)
		    continue;
/*
		if(cur_obj->section_maps[m].no_load_order == TRUE)
		    continue;
*/
		n = cur_obj->section_maps[m].nload_orders;
		load_orders = cur_obj->section_maps[m].load_orders;
		for(k = 0; k < n ; k++){
		    order_load_maps[l].archive_name = NULL;
		    order_load_maps[l].object_name =
			object_names[j].object_name;
		    order_load_maps[l].symbol_name = load_orders[k].name;
		    order_load_maps[l].value = load_orders[k].value;
		    order_load_maps[l].section_map =
			&(cur_obj->section_maps[m]);
		    order_load_maps[l].size = load_orders[k].input_size;
		    order_load_maps[l].order = load_orders[k].order;
		    order_load_maps[l].load_order = load_orders + k;
		    l++;
		}
	    }
	}

#ifdef DEBUG
	if(debug & (1 << 19)){
	    for(i = 0; i < norder_load_maps; i++){
		if(order_load_maps[i].archive_name != NULL)
		    print("%s:", order_load_maps[i].archive_name);
		if(order_load_maps[i].symbol_name != NULL)
		    print("%s:%s\n", order_load_maps[i].object_name,
		    order_load_maps[i].symbol_name);
		else
		    print("%s\n", order_load_maps[i].object_name);
	    }
	}
#endif /* DEBUG */

	qsort(order_load_maps,
	      norder_load_maps,
	      sizeof(struct order_load_map),
	      (int (*)(const void *, const void *))qsort_order_load_map_orders);
}

#ifdef DEBUG
/*
 * print_symbol_name_from_order_load_maps() is used in printing a symbol name
 * for a block in the -dead_code stripping debug printing.
 */
static
void
print_symbol_name_from_order_load_maps(
struct section_map *map,
unsigned long value)
{
    unsigned int i, n;
    struct order_load_map *order_load_maps;

	order_load_maps = map->output_section->order_load_maps;
	n = map->output_section->norder_load_maps;
	for(i = 0; i < n; i++){
	   if(order_load_maps[i].value == value){
		print(":%s", order_load_maps[i].symbol_name);
		return;
	   }
	}
}
#endif /* DEBUG */

/*
 * resize_live_sections() resizes the regular and zerofill sections using the
 * live file_reloc sizes.
 */
__private_extern__
void
resize_live_sections(
void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, **zerofill, *ms;

	/*
	 * For each merged S_REGULAR and zerofill section cause the section to
	 * be resized to include only the live fine_relocs.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		/*
		 * If a regular section (not a literal section) then call
		 * resize_live_section() on it.
		 */
		if((ms->s.flags & SECTION_TYPE) == S_REGULAR &&
		   ms->contents_filename == NULL)
		    resize_live_section(ms);
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		resize_live_section(ms);
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

/*
 * resize_live_section() resizes the merged section based on the live
 * fine_relocs.
 */
static
void
resize_live_section(
struct merged_section *ms)
{
    unsigned long n, i, output_offset;
    struct order_load_map *order_load_maps;
    struct load_order *load_order;
    struct fine_reloc *fine_reloc;

	/*
	 * Using the order_load_map of the merged section reassign the
	 * output_offset of each live fine_reloc.
	 */
	output_offset = 0;
	n = ms->norder_load_maps;
	order_load_maps = ms->order_load_maps;
	for(i = 0; i < n; i++){
	    if(order_load_maps[i].load_order->fine_reloc->live == FALSE){
		if(ms->order_filename != NULL &&
		   sectorder_detail == TRUE &&
		   order_load_maps[i].load_order->line_number != 0)
		    warning("specification of symbol: %s in -sectorder file: "
			    "%s line %lu for section (%.16s,%.16s) not used "
			    "(dead stripped)",
			    order_load_maps[i].load_order->name,
			    ms->order_filename,
			    order_load_maps[i].load_order->line_number,
			    ms->s.segname, ms->s.sectname);
		continue;
	    }

	    load_order = order_load_maps[i].load_order;
	    fine_reloc = load_order->fine_reloc;

	    output_offset = align_to_input_mod(output_offset,
					       load_order->input_offset,
					       ms->s.align);
	    load_order->output_offset = output_offset;
	    fine_reloc->output_offset = output_offset;
	    output_offset += load_order->input_size;
	}

	/*
	 * Now the size of the resized merged section can be set with just
	 * the sizes of the live file_relocs included in the section.
	 */
	ms->s.size = output_offset;
}

/*
 * relayout_relocs() resets the counts and indexes for the relocation
 * entries that will be in the output file when output_for_dyld is TRUE or
 * -dead_strip is specified.
 */
__private_extern__
void
relayout_relocs(
void)
{
    unsigned long i, j, section_type, nlocrel, nextrel;
    struct object_list *object_list, **p;
    struct section_map *map;
    struct relocation_info *relocs;

    struct merged_segment **q, *msg;
    struct merged_section **content, *ms;

	/*
	 * For regular and module initialization function pointer sections count
	 * the number of relocation entries that will be in the output file
	 * being created (which in the case of output_for_dyld depends on the
	 * type of output file).
	 */
	nlocrel = 0;
	nextrel = 0;
	for(p = &objects; *p; p = &(object_list->next)){
	    object_list = *p;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		cur_obj->ilocrel = nlocrel;
		cur_obj->iextrel = nextrel;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(cur_obj->section_maps[j].s->flags & S_ATTR_DEBUG)
			continue;
		    section_type = cur_obj->section_maps[j].s->flags &
				   SECTION_TYPE;
		    if(section_type == S_REGULAR ||
		       section_type == S_MOD_INIT_FUNC_POINTERS ||
		       section_type == S_MOD_TERM_FUNC_POINTERS){
			map = cur_obj->section_maps + j;
			relocs = (struct relocation_info *)
				 (cur_obj->obj_addr + map->s->reloff);
			count_relocs(map, relocs, &nlocrel, &nextrel);
		    }
		}
		/*
		 * For merged sections that have external relocation entries
		 * they need to be kept with the object's other external
		 * relocation entries so that in a dynamic library they get
		 * relocated.
		 */
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    section_type = cur_obj->section_maps[j].s->flags &
				   SECTION_TYPE;
		    if(section_type == S_COALESCED){
			map = cur_obj->section_maps + j;
			if(map->nextrel != 0){
			    map->iextrel = nextrel;
			    nextrel += map->nextrel;
			    cur_obj->nextrel += map->nextrel;
			}
			if(map->nlocrel != 0){
			    map->ilocrel = nlocrel;
			    nlocrel += map->nlocrel;
			    cur_obj->nlocrel += map->nlocrel;
			}
		    }
		}
	    }
	}

	/*
	 * For merged sections that could have relocation entries the number
	 * that will be in the type of output file being created was counted
	 * up as the section was merged.  So here just set the indexes into
	 * the local and external relocation entries and add their counts to
	 * the total.
	 */
	q = &merged_segments;
	while(*q){
	    msg = *q;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		section_type = ms->s.flags & SECTION_TYPE;
		if(section_type == S_LITERAL_POINTERS ||
		   section_type == S_SYMBOL_STUBS ||
		   section_type == S_LAZY_SYMBOL_POINTERS){
		    if(ms->nlocrel != 0){
			ms->ilocrel = nlocrel;
			nlocrel += ms->nlocrel;
			ms->s.flags |= S_ATTR_LOC_RELOC;
		    }
		    /*
		     * It is an error if one of these types of merged sections
		     * has an external relocation entry and the output is a
		     * multi module dynamic library.  As in a multi module dylib
		     * no library module will "own" it and it will never get
		     * used by the dynamic linker and the item relocated.
		     */
		    if(ms->nextrel != 0){
			if(filetype == MH_DYLIB && multi_module_dylib == TRUE)
			    fatal("internal error: relayout_relocs() "
			      "called with external relocation entries for "
			      "merged section (%.16s,%.16s) for multi module "
			      "MH_DYLIB output", ms->s.segname, ms->s.sectname);
/* TODO: can this ever get here?  even if not MH_DYLIB? */
			ms->iextrel = nextrel;
			nextrel += ms->nextrel;
			ms->s.flags |= S_ATTR_EXT_RELOC;
		    }
		}
		content = &(ms->next);
	    }
	    q = &(msg->next);
	}

	output_dysymtab_info.dysymtab_command.nlocrel = nlocrel;
	output_dysymtab_info.dysymtab_command.nextrel = nextrel;
}

/*
 * count_relocs() increments the counts of the nlocrel and nextrel for the
 * current object for the specified section based on which relocation entries
 * will be in the output file.
 */
static
void
count_relocs(
struct section_map *map,
struct relocation_info *relocs,
unsigned long *nlocrel,
unsigned long *nextrel)
{
    unsigned long i, j, pair, prev_nlocrel, prev_nextrel;
    struct relocation_info reloc, pair_reloc;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address, r_type, r_extern, r_symbolnum, r_pcrel, r_value,
		  r_length;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct nlist *nlists;
    char *strings;
    enum bool defined, pic;
    struct section_map *local_map;
    struct section_map fake_map;
    struct section fake_s;
    char fake_contents[4];
    struct relocation_info fake_relocs[2];

	/* to shut up compiler warning messages "may be used uninitialized" */
	merged_symbol = NULL;
	defined = FALSE;

	prev_nlocrel = cur_obj->nlocrel;
	prev_nextrel = cur_obj->nextrel;
	for(i = 0; i < map->s->nreloc; i++){
	    /*
	     * Note all errors are not flagged here but left for the *_reloc()
	     * routines to flag them.
	     */
	    reloc = relocs[i];
	    if(cur_obj->swapped && map->input_relocs_already_swapped == FALSE)
		swap_relocation_info(&reloc, 1, host_byte_sex);
	    /*
	     * Break out the fields of the relocation entry we need here.
	     */
	    if((reloc.r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(&reloc);
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_type = sreloc->r_type;
		r_length = sreloc->r_length;
		r_extern = 0;
		r_value = sreloc->r_value;
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			return;
		    }
		}
	    }
	    else{
		r_address = reloc.r_address;
		r_pcrel = reloc.r_pcrel;
		r_type = reloc.r_type;
		r_length = reloc.r_length;
		r_extern = reloc.r_extern;
		r_symbolnum = reloc.r_symbolnum;
	    }
	    if(r_extern){
		if(r_symbolnum >= cur_obj->symtab->nsyms)
		    return;
		undefined_map = bsearch(&r_symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL)
		    merged_symbol = undefined_map->merged_symbol;
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[r_symbolnum].n_type & N_EXT) != N_EXT)
			return;
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[r_symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[r_symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[r_symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in count_relocs() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[r_symbolnum].n_un.n_strx);
			}
		    }
		    else
			return;
		}
		if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR &&
		   merged_symbol->defined_in_dylib == FALSE)
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		   merged_symbol->nlist.n_type == (N_EXT | N_PBUD) ||
		   (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		    merged_symbol->defined_in_dylib == TRUE)){
		    defined = FALSE;
		}
		else{
		    /*
		     * The symbol is defined but may be a coalesced symbol.
		     * If so and the output is not an executable (does not
		     * have a dynamic linker command) this relocation entry
		     * will remain as an external relocation entry so set
		     * the variable 'defined' to FALSE.
		     */
		    if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		       (merged_symbol->definition_object->section_maps[
			 merged_symbol->nlist.n_sect-1].
			 s->flags & SECTION_TYPE) == S_COALESCED &&
		       has_dynamic_linker_command == FALSE){
			defined = FALSE;
		    }
		    else{
			defined = TRUE;
		    }
		}
	    }
	    if(reloc_has_pair(arch_flag.cputype, r_type))
		pair = 1;
	    else
		pair = 0;
	    if(r_extern == 0){
		/*
		 * If the r_symbolnum refers to a symbol stub section where
		 * the indirect symbol for what is being reference is now
		 * defined as an N_ABS symbol it will turn r_symbolnum
		 * into NO_SECT.  So what was a pcrel relocation entry refering
		 * to another section now refers to absolute symbol and the
		 * relocation entry is no longer pic and must be kept.
		 */
		if(r_symbolnum > cur_obj->nsection_maps)
		    return;
		local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		if(r_symbolnum != NO_SECT &&
		   (local_map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
		   local_map->absolute_indirect_defineds == TRUE &&
		   r_pcrel == 1){
		    /*
		     * So we need to know if r_symbolnum will turn into NO_SECT.
		     * We do this by faking doing the relocation and pick up
		     * the resulting r_symbolnum after relocation.
		     */
		    if(r_address >= map->s->size)
			return;
		    if(pair && i == map->s->nreloc - 1)
			return;
		    /* fake up a section contents using just this item */
		    memcpy(fake_contents,
			   cur_obj->obj_addr + map->s->offset + r_address,
			   1 << r_length);
		    /* fake up relocation entries using just the ones for item*/
		    fake_relocs[0] = reloc;
		    if((reloc.r_address & R_SCATTERED) != 0){
			sreloc = (struct scattered_relocation_info *)
				 (&fake_relocs[0]);
			sreloc->r_address = 0;
		    }
		    else
			fake_relocs[0].r_address = 0;
		    if(pair){
			pair_reloc = relocs[i+1];
			if(cur_obj->swapped &&
	       		   map->input_relocs_already_swapped == FALSE)
			    swap_relocation_info(&pair_reloc, 1, host_byte_sex);
			fake_relocs[1] = pair_reloc;
		    }
		    /*
		     * fake up a section map that will cause the correct
		     * r_symbolnum (the relocation may be wrong but we don't
		     * need that).
		     */
		    fake_s = *(map->s);
		    fake_s.nreloc = 1 + pair;
		    fake_s.size = 1 << r_length;
		    fake_s.addr += r_address;
		    fake_map = *map;
		    fake_map.s = &fake_s;
		    fake_map.nfine_relocs = 0;
		    fake_map.fine_relocs = NULL;

		    /* do the fake relocation */
		    if(arch_flag.cputype == CPU_TYPE_MC680x0)
			generic_reloc(fake_contents, fake_relocs, &fake_map,
				      FALSE, NULL, 0);
		    else if(arch_flag.cputype == CPU_TYPE_I386)
			generic_reloc(fake_contents, fake_relocs, &fake_map,
				      TRUE, NULL, 0);
		    else if(arch_flag.cputype == CPU_TYPE_POWERPC ||
			    arch_flag.cputype == CPU_TYPE_VEO)
			ppc_reloc(fake_contents, fake_relocs, &fake_map,
				  NULL, 0);
		    else if(arch_flag.cputype == CPU_TYPE_MC88000)
			m88k_reloc(fake_contents, fake_relocs, &fake_map);
		    else if(arch_flag.cputype == CPU_TYPE_HPPA)
			hppa_reloc(fake_contents, fake_relocs, &fake_map);
		    else if(arch_flag.cputype == CPU_TYPE_SPARC)
			sparc_reloc(fake_contents, fake_relocs, &fake_map);
#ifndef RLD
		    else if(arch_flag.cputype == CPU_TYPE_I860)
			i860_reloc(fake_contents, fake_relocs, map);
#endif /* RLD */
		    else if(arch_flag.cputype == CPU_TYPE_ARM)
			arm_reloc(fake_contents, fake_relocs, &fake_map,
				  NULL, 0);

		    /* now pick up the correct resulting r_symbolnum */
		    r_symbolnum = fake_relocs[0].r_symbolnum;
		}
		/*
		 * If this local relocation entry is refering to a coalesced
		 * section and the r_value is that of a global coalesced
		 * symbol then this relocation entry will into a external
		 * relocation entry and the item to be relocated will be
		 * "unrelocated" removing the value of the global coalesced
		 * symbol. 
		 */
		else if(r_symbolnum != NO_SECT &&
		   (local_map->s->flags & SECTION_TYPE) == S_COALESCED){
		    /*
		     * The address of the item being referenced for a scattered
		     * relocation entry is r_address.  But for local relocation
		     * entries the address is in the contents of the item being
		     * relocated (which is architecure/relocation type dependent
		     * to get).
		     *
		     * Once you have that address you have to go through the 
		     * cur_obj's symbol table trying to matching that address.
		     * If you find a match then to need to determine if that
		     * symbols is global in the output file (not a private
		     * extern turned in to a static).
		     *
		     * If all this is true then this relocation entry will
		     * be turned back into an external relocation entry.
		     */
		    ;
		}
		pic = (enum bool)
		       (reloc_is_sectdiff(arch_flag.cputype, r_type) ||
		        (r_pcrel == 1 && r_symbolnum != NO_SECT));
	    }
	    else
		pic = (enum bool)
		       (r_pcrel == 1 &&
		        (merged_symbol->nlist.n_type & N_TYPE) == N_SECT);
	    /*
	     * For output_for_dyld PPC_RELOC_JBSR and HPPA_RELOC_JBSR's are
	     * never put out.
	     */
	    if((arch_flag.cputype == CPU_TYPE_POWERPC &&
		r_type == PPC_RELOC_JBSR) ||
	       (arch_flag.cputype == CPU_TYPE_HPPA &&
		r_type == HPPA_RELOC_JBSR)){
		i += pair;
		continue;
	    }

	    /*
	     * If -dead_strip is specified then this relocation entry may be
	     * part of a dead block and thus will not be put out.
	     */
	    if(dead_strip == TRUE){
		if(fine_reloc_offset_in_output(map, r_address) == FALSE){
		    i += pair;
		    continue;
		}
	    }

	    /*
	     * When output_for_dyld is FALSE all of relocation entries not in
	     * dead blocks will be in the output if save_reloc == TRUE.  And
	     * will be extern if from an extern reloc and the symbol is not
	     * defined else it will be local.
	     */
	    if(output_for_dyld == FALSE){
		if(save_reloc == TRUE){
		    if(r_extern == TRUE && defined == FALSE){
			(*nextrel) += 1 + pair;
			cur_obj->nextrel += 1 + pair;
		    }
		    else{
			(*nlocrel) += 1 + pair;
			cur_obj->nlocrel += 1 + pair;
		    }
		}
		i += pair;
		continue;
	    }

	    /*
	     * When output_for_dyld is TRUE the number of relocation entries in
	     * the output file is based on one of three different cases:
	     * 	The output file is a multi module dynamic shared library
	     *  The output file has a dynamic linker load command
	     *  The output does not have a dynamic linker load command
	     */
	    if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		/*
		 * For multi module dynamic shared library files all external
		 * relocations are kept as external relocation entries except
		 * for references to private externs (which are kept as locals) 
		 * and all non-position-independent local relocation entries
		 * are kept. Modules of multi module dylibs are not linked
		 * together and can only be slid keeping all sections relative
		 * to each other the same.
		 */
		if(r_extern && (merged_symbol->nlist.n_type & N_PEXT) == 0){
		    (*nextrel) += 1 + pair;
		    cur_obj->nextrel += 1 + pair;
		}
		else if(pic == FALSE){
		    (*nlocrel) += 1 + pair;
		    cur_obj->nlocrel += 1 + pair;
		}
	    }
	    else if(has_dynamic_linker_command){
		/*
		 * For an file with a dynamic linker load command only external
		 * relocation entries for undefined symbols are kept.  This
		 * output file is a fixed address and can't be moved.
		 */
		if(r_extern){
		    if(defined == FALSE){
			(*nextrel) += 1 + pair;
			cur_obj->nextrel += 1 + pair;
		    }
		}
	    }
	    else{
		/*
		 * For an file without a dynamic linker load command external
		 * relocation entries for undefined symbols are kept and locals
		 * that are non-position-independent are kept.  This file can
		 * only be slid keeping all sections relative to each other the
		 * same.
		 */
		if(r_extern && (merged_symbol->nlist.n_type & N_PEXT) == 0){
		    if(defined == FALSE){
			(*nextrel) += 1 + pair;
			cur_obj->nextrel += 1 + pair;
		    }
		    else if(pic == FALSE){
			(*nlocrel) += 1 + pair;
			cur_obj->nlocrel += 1 + pair;
		    }
		}
		else if(pic == FALSE){
		    (*nlocrel) += 1 + pair;
		    cur_obj->nlocrel += 1 + pair;
		}
	    }
	    i += pair;
	}
	map->nextrel = cur_obj->nextrel - prev_nextrel;
	map->nlocrel = cur_obj->nlocrel - prev_nlocrel;
	if(prev_nextrel != cur_obj->nextrel)
	    map->output_section->s.flags |= S_ATTR_EXT_RELOC;
	if(prev_nlocrel != cur_obj->nlocrel)
	    map->output_section->s.flags |= S_ATTR_LOC_RELOC;
}
#endif /* !defined(RLD) */

/*
 * output_literal_sections() causes each merged literal section to be copied
 * to the output file.  It is called from pass2().
 */
__private_extern__
void
output_literal_sections(void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS ||
		   (ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS ||
		   (ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS ||
		   (ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS)
		    (*ms->literal_output)(ms->literal_data, ms);
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

#ifndef RLD
/*
 * output_sections_from_files() causes each section created from a file to be
 * copied to the output file.  It is called from pass2().
 */
__private_extern__
void
output_sections_from_files(void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;
#ifdef DEBUG
    kern_return_t r;
#endif /* DEBUG */

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->contents_filename != NULL){
		    memcpy(output_addr + ms->s.offset,
			   ms->file_addr, ms->file_size);
		    /*
		     * The entire section size is flushed (ms->s.size) not just
		     * the size of the file used to create it (ms->filesize) so
		     * to flush the padding due to alignment.
		     */
		    output_flush(ms->s.offset, ms->s.size);
#ifdef DEBUG
		    if((r = vm_deallocate(mach_task_self(), (vm_address_t)
			ms->file_addr, ms->file_size)) != KERN_SUCCESS)
			mach_fatal(r, "can't vm_deallocate() memory for file: "
				   "%s used to create section (%.16s,%.16s)",
				   ms->contents_filename, ms->s.segname,
				   ms->s.sectname);
		    ms->file_addr = NULL;
#endif /* DEBUG */
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
}
#endif /* !defined(RLD) */

/*
 * output_section() copies the contents of a section and it's relocation entries
 * (if saving relocation entries) into the output file's memory buffer.  Then it
 * calls the appropriate routine specific to the target machine to relocate the
 * section and update the relocation entries (if saving relocation entries).
 */
__private_extern__
void
output_section(
struct section_map *map)
{
    char *contents;
    struct relocation_info *relocs;
#ifndef RLD
    struct relocation_info *output_relocs, *output_locrel, *output_extrel;
    unsigned long nlocrel, nextrel;
    unsigned long nreloc;
#endif

#ifdef DEBUG
	/* The compiler "warning: `output_relocs' may be used uninitialized */
	/* in this function" can safely be ignored */
	output_relocs = NULL;
#endif

	/*
	 * If this section has no contents and no relocation entries just
	 * return.  This can happen a lot with object files that have empty
	 * sections.
	 */ 
	if(map->s->size == 0 && map->s->nreloc == 0)
	    return;

	/*
	 * Copy the contents of the section from the input file into the memory
	 * buffer for the output file.
	 */
	if(map->nfine_relocs != 0)
	    contents = allocate(map->s->size);
	else{
	    /*
	     * This is a hack to pad an i386 pure instructions sections with
	     * nop's (opcode 0x90) to make disassembly cleaner between object's
	     * sections.
	     */
	    if(arch_flag.cputype == CPU_TYPE_I386 &&
	       (map->s->flags & S_ATTR_PURE_INSTRUCTIONS) != 0){
		contents = output_addr + map->output_section->s.offset +
			   map->flush_offset;
		memset(contents, 0x90, map->offset - map->flush_offset);
	    }
	    contents = output_addr + map->output_section->s.offset +map->offset;
	}
	memcpy(contents, cur_obj->obj_addr + map->s->offset, map->s->size);

	/*
	 * If the section has no relocation entries then no relocation is to be
	 * done so just flush the contents and return.
	 */
	if(map->s->nreloc == 0){
#ifndef RLD
	    if(map->nfine_relocs != 0){
		scatter_copy(map, contents);
		free(contents);
	    }
	    else
		output_flush(map->output_section->s.offset + map->flush_offset,
			     map->s->size + (map->offset - map->flush_offset));
#endif /* !defined(RLD) */
	    return;
	}
	else
	    map->output_section->relocated = TRUE;

	/*
	 * Set up the pointer to the relocation entries to be used by the 
	 * relocation routine.  If the relocation entries appear in the file
	 * the relocation routine will update them.  If only some but not all
	 * of the relocation entries will appear in the output file then copy
	 * them from the input file into the memory buffer.  If all of the
	 * relocation entries will appear in the output file then copy them into
	 * the buffer for the output file.  Lastly if no relocation entries will
	 * appear in the output file just used the input files relocation
	 * entries for the relocation routines.
	 */
	if(output_for_dyld){
	    relocs = allocate(map->s->nreloc * sizeof(struct relocation_info));
	    memcpy(relocs,
		   cur_obj->obj_addr + map->s->reloff,
		   map->s->nreloc * sizeof(struct relocation_info));
	}
	else if(save_reloc){
	    /*
	     * For indirect and coalesced sections only those relocation entries
	     * for items in the section used from this object will be saved.  So
	     * allocate a buffer to put them in to use to do the relocation and
	     * later scatter_copy_relocs() will pick out the the relocation
	     * entries to be put in the output file.
	     */
	    if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
	       (map->s->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_COALESCED){
		relocs = allocate(map->s->nreloc *
				  sizeof(struct relocation_info));
		memcpy(relocs,
		       cur_obj->obj_addr + map->s->reloff,
		       map->s->nreloc * sizeof(struct relocation_info));
	    }
	    else{
		relocs = (struct relocation_info *)(output_addr +
			 map->output_section->s.reloff +
			 map->output_section->output_nrelocs *
						sizeof(struct relocation_info));
		memcpy(relocs,
		       cur_obj->obj_addr + map->s->reloff,
		       map->s->nreloc * sizeof(struct relocation_info));
	    }
	}
	else{
	    relocs = (struct relocation_info *)(cur_obj->obj_addr +
					        map->s->reloff);
	}
	if(cur_obj->swapped && map->input_relocs_already_swapped == FALSE){
	    swap_relocation_info(relocs, map->s->nreloc, host_byte_sex);
	    map->input_relocs_already_swapped = TRUE;
	}

	/*
	 * Relocate the contents of the section (based on the target machine)
	 */
	if(arch_flag.cputype == CPU_TYPE_MC680x0)
	    generic_reloc(contents, relocs, map, FALSE, NULL, 0);
	else if(arch_flag.cputype == CPU_TYPE_I386)
	    generic_reloc(contents, relocs, map, TRUE, NULL, 0);
	else if(arch_flag.cputype == CPU_TYPE_POWERPC ||
		arch_flag.cputype == CPU_TYPE_VEO)
	    ppc_reloc(contents, relocs, map, NULL, 0);
	else if(arch_flag.cputype == CPU_TYPE_MC88000)
	    m88k_reloc(contents, relocs, map);
	else if(arch_flag.cputype == CPU_TYPE_HPPA)
	    hppa_reloc(contents, relocs, map);
	else if(arch_flag.cputype == CPU_TYPE_SPARC)
	    sparc_reloc(contents, relocs, map);
#ifndef RLD
	else if(arch_flag.cputype == CPU_TYPE_I860)
	    i860_reloc(contents, relocs, map);
#endif /* RLD */
	else if(arch_flag.cputype == CPU_TYPE_ARM)
	    arm_reloc(contents, relocs, map, NULL, 0);
	else
	    fatal("internal error: output_section() called with unknown "
		  "cputype (%d) set", arch_flag.cputype);

	/*
	 * If the reloc routines caused errors then return as so to not cause
	 * later internal error below.
	 */
	if(errors)
	    return;

	/*
	 * Copy and/or flush the relocated section contents to the output file.
	 */
	if(map->nfine_relocs != 0){
	    scatter_copy(map, contents);
	    free(contents);
	}
#ifndef RLD
	else
	    output_flush(map->output_section->s.offset + map->flush_offset,
			 map->s->size + (map->offset - map->flush_offset));

	/*
	 * If relocation entries will be in the output file copy and/or flush
	 * them to the output file.
	 */
	if(output_for_dyld){
	    /*
	     * Setup pointers in the output file buffer for local and external
	     * relocation entries.
	     */
	    if((map->s->flags & SECTION_TYPE) == S_REGULAR ||
	       (map->s->flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS){
		output_locrel = (struct relocation_info *)(output_addr +
			    output_dysymtab_info.dysymtab_command.locreloff +
			    cur_obj->ilocrel * sizeof(struct relocation_info));
		output_extrel = (struct relocation_info *)(output_addr +
			    output_dysymtab_info.dysymtab_command.extreloff +
			    cur_obj->iextrel * sizeof(struct relocation_info));
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_COALESCED){
		output_locrel = (struct relocation_info *)(output_addr +
			    output_dysymtab_info.dysymtab_command.locreloff +
			    map->ilocrel * sizeof(struct relocation_info));
		output_extrel = (struct relocation_info *)(output_addr +
			    output_dysymtab_info.dysymtab_command.extreloff +
			    map->iextrel * sizeof(struct relocation_info));
	    }
	    else{
		output_locrel = (struct relocation_info *)(output_addr +
			    output_dysymtab_info.dysymtab_command.locreloff +
			    map->output_section->ilocrel *
				sizeof(struct relocation_info));
		output_extrel = (struct relocation_info *)(output_addr +
			    output_dysymtab_info.dysymtab_command.extreloff +
			    map->output_section->iextrel *
				sizeof(struct relocation_info));
	    }
	    /*
	     * Copy out the local and external relocation entries to be kept
	     * for the output file type and adjust the r_address values to be
	     * based on the offset from starting address of the first segment
	     * rather than the offset of the section.
	     */
	    reloc_output_for_dyld(map, relocs, output_locrel, output_extrel,
				  &nlocrel, &nextrel);
	    /*
	     * count_reloc() and coalesced_section_merge() counted and recorded
	     * the number of relocation entries the section was to have in the
	     * output.  This should match what reloc_output_for_dyld() copied
	     * out.
	     */
	    if((map->s->flags & SECTION_TYPE) == S_REGULAR ||
	       (map->s->flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_COALESCED){
		if(nextrel != map->nextrel)
		    fatal("internal error: output_section() count of external "
			  "relocation entries does not match\n");
		if(nlocrel != map->nlocrel)
		    fatal("internal error: output_section() count of local "
			  "relocation entries does not match\n");
	    }

	    if(host_byte_sex != target_byte_sex){
		swap_relocation_info(output_locrel, nlocrel, target_byte_sex);
		swap_relocation_info(output_extrel, nextrel, target_byte_sex);
	    }
	    /*
	     * Flush output file buffer's local and external relocation entries
	     * and increment the counts.
	     */
	    if((map->s->flags & SECTION_TYPE) == S_REGULAR ||
	       (map->s->flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS){
		output_flush(output_dysymtab_info.dysymtab_command.locreloff +
			     cur_obj->ilocrel * sizeof(struct relocation_info),
			     nlocrel * sizeof(struct relocation_info));
		cur_obj->ilocrel += nlocrel;
		output_flush(output_dysymtab_info.dysymtab_command.extreloff +
			     cur_obj->iextrel * sizeof(struct relocation_info),
			     nextrel * sizeof(struct relocation_info));
		cur_obj->iextrel += nextrel;
	    }
	    else if((map->s->flags & SECTION_TYPE) == S_COALESCED){
		output_flush(output_dysymtab_info.dysymtab_command.locreloff +
			     map->ilocrel * sizeof(struct relocation_info),
			     nlocrel * sizeof(struct relocation_info));
		/* no increment of map->nlocrel */
		output_flush(output_dysymtab_info.dysymtab_command.extreloff +
			     map->iextrel * sizeof(struct relocation_info),
			     nextrel * sizeof(struct relocation_info));
		/* no increment of map->nextrel */
	    }
	    else{
		output_flush(output_dysymtab_info.dysymtab_command.locreloff +
			     map->output_section->ilocrel *
				sizeof(struct relocation_info),
			     nlocrel * sizeof(struct relocation_info));
		map->output_section->ilocrel += nlocrel;
		output_flush(output_dysymtab_info.dysymtab_command.extreloff +
			     map->output_section->iextrel *
				sizeof(struct relocation_info),
			     nextrel * sizeof(struct relocation_info));
		map->output_section->iextrel += nextrel;
	    }
	    free(relocs);
	}
	else if(save_reloc){
	    if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
	       (map->s->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_COALESCED){

		output_relocs = (struct relocation_info *)(output_addr +
			 	 map->output_section->s.reloff +
			 	 map->output_section->output_nrelocs *
						sizeof(struct relocation_info));
		nreloc = scatter_copy_relocs(map, relocs, output_relocs);
		free(relocs);
	    }
	    else{
		nreloc = map->s->nreloc;
		output_relocs = relocs;
	    }
	    if(host_byte_sex != target_byte_sex)
		swap_relocation_info(output_relocs, nreloc, target_byte_sex);
	    output_flush(map->output_section->s.reloff +
			 map->output_section->output_nrelocs *
			 sizeof(struct relocation_info),
			 nreloc * sizeof(struct relocation_info));
	    map->output_section->output_nrelocs += nreloc;
	}
#endif /* !defined(RLD) */
}

#ifndef RLD

/*
 * is_pass2_merged_symbol_coalesced() is passed a merged symbol as it appears
 * in the second pass (that is with its n_sect) set to the output's section
 * number) and returns TRUE if the symbol is in a coalesced section and FALSE
 * otherwise.  This is used by scatter_copy() below to set the value of
 * non-lazy pointers.  This absolutely need to be done by the static linker for
 * private extern coalesced symbols (when -keep_private_extern is not in effect)
 * as their indirect symbol table will be INDIRECT_SYMBOL_LOCAL on output and
 * then the dynamic linker can't fix them up.
 */
static 
enum bool
is_pass2_merged_symbol_coalesced(
struct merged_symbol *merged_symbol)
{
    unsigned long i;

	if(merged_symbol == NULL)
	    return(FALSE);
	if((merged_symbol->nlist.n_type & N_TYPE) != N_SECT)
	    return(FALSE);
	for(i = 0; i < merged_symbol->definition_object->nsection_maps; i++){
	    if(merged_symbol->nlist.n_sect == merged_symbol->definition_object->
			section_maps[i].output_section->output_sectnum)
	    if((merged_symbol->definition_object->section_maps[
		 i].output_section->s.flags & SECTION_TYPE) == S_COALESCED)
		return(TRUE);
	}
	return(FALSE);
}
#endif /* !defined(RLD) */

/*
 * pass2_nsect_merged_symbol_section_type() is passed an n_sect merged symbol as
 * it appears in the second pass (that is with its n_sect) set to the output's
 * section number) and returns the section type of that symbol in the output.
 * otherwise.  This is used by legal_reference() in the case of weak coalesced
 * symbols being discarded for some other symbol to figure out what section is
 * being referenced in the output.
 */
__private_extern__
unsigned long
pass2_nsect_merged_symbol_section_type(
struct merged_symbol *merged_symbol)
{
    unsigned long i;

	if(merged_symbol == NULL ||
	   (merged_symbol->nlist.n_type & N_TYPE) != N_SECT)
	    fatal("internal error, s_pass2_merged_symbol_coalesced() passed "
		  "a non-N_SECT symbol");
	for(i = 0; i < merged_symbol->definition_object->nsection_maps; i++){
	    if(merged_symbol->nlist.n_sect == merged_symbol->definition_object->
			section_maps[i].output_section->output_sectnum)
	    return(merged_symbol->definition_object->section_maps[i].
		   output_section->s.flags & SECTION_TYPE);
	}
	fatal("internal error, s_pass2_merged_symbol_coalesced() failed\n");
	return(0);
}

/*
 * scatter_copy() copies the relocated contents of a section into the output
 * file's memory buffer based on the section's fine relocation maps.
 */
static
void
scatter_copy(
struct section_map *map,
char *contents)
{
    unsigned long i;
#ifndef RLD
    unsigned long j;
    struct nlist *nlists;
    unsigned long *indirect_symtab, index, value;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    char *strings;
    struct section_map *section_map;
    long delta;
    char *jmpEntry;

	/*
	 * For non-lazy pointer type indirect sections only copy those parts of
	 * the section who's contents are used in the output file and if the
	 * symbol for the non-lazy pointer is defined then use that as instead
	 * of the contents.  This bit of code assumes that all the checks done
	 * when merging the indirect section are valid and so none of them are
	 * done here.  It also assumes that the fine relocation entries each
	 * cover the 4 byte non-lazy pointer.
	 *
	 * If prebinding and this is a lazy pointer section do the same as for
	 * non-lazy pointers.  That is use the value of the indirect symbol.
	 */
	if((map->s->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
	   (prebinding == TRUE &&
	    (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS)){
	    /* setup pointers to the symbol table and indirect symbol table */
	    nlists = (struct nlist *)(cur_obj->obj_addr +
				      cur_obj->symtab->symoff);
	    indirect_symtab = (unsigned long *)(cur_obj->obj_addr +
					    cur_obj->dysymtab->indirectsymoff);
	    strings = cur_obj->obj_addr + cur_obj->symtab->stroff;
	    for(i = 0; i < map->nfine_relocs - 1; i++){
		if(map->fine_relocs[i].use_contents == TRUE &&
		   (dead_strip == FALSE || map->fine_relocs[i].live == TRUE)){
		    index = indirect_symtab[map->s->reserved1 + 
			    (map->fine_relocs[i].input_offset / 4)];
		    if(map->fine_relocs[i].indirect_defined == TRUE ||
		       is_pass2_merged_symbol_coalesced(
			    map->fine_relocs[i].merged_symbol) == TRUE ||
		       (prebinding == TRUE && 
			(index != INDIRECT_SYMBOL_LOCAL &&
			 index != INDIRECT_SYMBOL_ABS))){
			if(is_pass2_merged_symbol_coalesced(
			    map->fine_relocs[i].merged_symbol) == TRUE){
    			    value = map->fine_relocs[i].merged_symbol->
				    nlist.n_value;
			    if((map->fine_relocs[i].merged_symbol->
				nlist.n_desc & N_ARM_THUMB_DEF))
				value |= 1;
			}
			else if(map->fine_relocs[i].local_symbol == FALSE){
			    undefined_map = bsearch(&index,
				cur_obj->undefined_maps, cur_obj->nundefineds,
				sizeof(struct undefined_map),
				(int (*)(const void *, const void *))
				undef_bsearch);
			    if(undefined_map == NULL){
				merged_symbol = lookup_symbol(strings +
						    nlists[index].n_un.n_strx);
				if(merged_symbol->name_len == 0)
				    fatal("interal error, scatter_copy() failed"
					  " in looking up external symbol");
			    }
			    else
				merged_symbol = undefined_map->merged_symbol;
			    if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
				merged_symbol = (struct merged_symbol *)
						merged_symbol->nlist.n_value;
			    value = merged_symbol->nlist.n_value;
			    if((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF))
				value |= 1;
			}
			else{
			    if(nlists[index].n_sect == NO_SECT)
				value = nlists[index].n_value;
			    else{
				section_map = &(cur_obj->section_maps[
				    nlists[index].n_sect -1]);
				if(section_map->nfine_relocs == 0)
				    value = nlists[index].n_value -
					   section_map->s->addr +
					   section_map->output_section->s.addr +
					   section_map->offset;
				else
				    value =
					section_map->output_section->s.addr +
					   fine_reloc_output_offset(section_map,
							nlists[index].n_value -
							section_map->s->addr);
			    }
			    if((nlists[index].n_desc & N_ARM_THUMB_DEF))
				value |= 1;
			}
			if(host_byte_sex != target_byte_sex)
			    value = SWAP_LONG(value);
			memcpy(output_addr + map->output_section->s.offset +
			       map->fine_relocs[i].output_offset,
			       &value, sizeof(unsigned long));
		    }
		    else{
			/*
			 * If the indirect symbol table entry is
			 * INDIRECT_SYMBOL_LOCAL the value of the symbol pointer
			 * neededs to be adjusted to where it is in the output.
			 */
			if(index == INDIRECT_SYMBOL_LOCAL){
			    memcpy(&value, contents +
				   map->fine_relocs[i].input_offset, 4);
			    if(cur_obj->swapped)
				value = SWAP_LONG(value);
			    for(j = 0; j < cur_obj->nsection_maps; j++){
				if(value >= cur_obj->section_maps[j].s->addr &&
				   value < cur_obj->section_maps[j].s->addr +
					     cur_obj->section_maps[j].s->size){
				    break;
				}
			    }
			    if(j >= cur_obj->nsection_maps){
				error_with_cur_obj("value of symbol pointer "
				    "(0x%x) in section (%.16s,%.16s) at index "
				    "%ld out of range for an indirect symbol "
				    "table value of INDIRECT_SYMBOL_LOCAL",
				    (unsigned int)value,
				    map->output_section->s.segname,
				    map->output_section->s.sectname, i);
				return;
			    }
			    section_map = &(cur_obj->section_maps[j]);
			    if(section_map->nfine_relocs == 0)
				value = value -
				       section_map->s->addr +
				       section_map->output_section->s.addr +
				       section_map->offset;
			    else
				value =
				    section_map->output_section->s.addr +
				       fine_reloc_output_offset(section_map,
						value - section_map->s->addr);
			    if(host_byte_sex != target_byte_sex)
				value = SWAP_LONG(value);
			    memcpy(output_addr + map->output_section->s.offset +
				   map->fine_relocs[i].output_offset,
				   &value, sizeof(unsigned long));
			}
			else{
			    memcpy(output_addr + map->output_section->s.offset +
					      map->fine_relocs[i].output_offset,
			       contents + map->fine_relocs[i].input_offset,
			       map->fine_relocs[i+1].input_offset -
					      map->fine_relocs[i].input_offset);
			}
		    }
		}
	    }
	    if(map->fine_relocs[i].use_contents == TRUE &&
	       (dead_strip == FALSE || map->fine_relocs[i].live == TRUE)){
		index = indirect_symtab[map->s->reserved1 + 
			(map->fine_relocs[i].input_offset / 4)];
		if(map->fine_relocs[i].indirect_defined == TRUE ||
		   is_pass2_merged_symbol_coalesced(
			map->fine_relocs[i].merged_symbol) == TRUE ||
		   (prebinding == TRUE && 
		    (index != INDIRECT_SYMBOL_LOCAL &&
		     index != INDIRECT_SYMBOL_ABS))){
		    if(is_pass2_merged_symbol_coalesced(
			map->fine_relocs[i].merged_symbol) == TRUE){
			value = map->fine_relocs[i].merged_symbol->
				nlist.n_value;
			if((map->fine_relocs[i].merged_symbol->
			    nlist.n_desc & N_ARM_THUMB_DEF))
			    value |= 1;
		    }
		    else if(map->fine_relocs[i].local_symbol == FALSE){
			undefined_map = bsearch(&index,
			    cur_obj->undefined_maps, cur_obj->nundefineds,
			    sizeof(struct undefined_map),
			    (int (*)(const void *, const void *))
			    undef_bsearch);
			if(undefined_map == NULL){
			    merged_symbol = lookup_symbol(strings +
						nlists[index].n_un.n_strx);
			    if(merged_symbol->name_len == 0)
				fatal("interal error, scatter_copy() failed"
				      " in looking up external symbol");
			}
			else
			    merged_symbol = undefined_map->merged_symbol;
			if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
			    merged_symbol = (struct merged_symbol *)
					    merged_symbol->nlist.n_value;
			value = merged_symbol->nlist.n_value;
			if((merged_symbol->nlist.n_desc & N_ARM_THUMB_DEF))
			    value |= 1;
		    }
		    else{
			if(nlists[index].n_sect == NO_SECT)
			    value = nlists[index].n_value;
			else{
			    section_map = &(cur_obj->section_maps[
				nlists[index].n_sect -1]);
			    if(section_map->nfine_relocs == 0)
				value = nlists[index].n_value -
				       section_map->s->addr +
				       section_map->output_section->s.addr +
				       section_map->offset;
			    else
				value =
				    section_map->output_section->s.addr +
				       fine_reloc_output_offset(section_map,
						    nlists[index].n_value -
						    section_map->s->addr);
			}
			if((nlists[index].n_desc & N_ARM_THUMB_DEF))
			    value |= 1;
		    }
		    if(host_byte_sex != target_byte_sex)
			value = SWAP_LONG(value);
		    memcpy(output_addr + map->output_section->s.offset +
			   map->fine_relocs[i].output_offset,
			   &value, sizeof(unsigned long));
		}
		else{
		    /*
		     * If the indirect symbol table entry is
		     * INDIRECT_SYMBOL_LOCAL the value of the symbol pointer
		     * neededs to be adjusted to where it is in the output.
		     */
		    if(index == INDIRECT_SYMBOL_LOCAL){
			memcpy(&value, contents +
			       map->fine_relocs[i].input_offset, 4);
			if(cur_obj->swapped)
			    value = SWAP_LONG(value);
			for(j = 0; j < cur_obj->nsection_maps; j++){
			    if(value >= cur_obj->section_maps[j].s->addr &&
			       value < cur_obj->section_maps[j].s->addr +
					 cur_obj->section_maps[j].s->size){
				break;
			    }
			}
			if(j >= cur_obj->nsection_maps){
			    error_with_cur_obj("value of symbol pointer (0x%x) "
				"in section (%.16s,%.16s) at index %ld out of "
				"range for an indirect symbol table value of "
				"INDIRECT_SYMBOL_LOCAL", (unsigned int)value,
				map->output_section->s.segname,
				map->output_section->s.sectname, i);
			    return;
			}
			section_map = &(cur_obj->section_maps[j]);
			if(section_map->nfine_relocs == 0)
			    value = value -
				   section_map->s->addr +
				   section_map->output_section->s.addr +
				   section_map->offset;
			else
			    value =
				section_map->output_section->s.addr +
				   fine_reloc_output_offset(section_map,
						value - section_map->s->addr);
			if(host_byte_sex != target_byte_sex)
			    value = SWAP_LONG(value);
			memcpy(output_addr + map->output_section->s.offset +
			       map->fine_relocs[i].output_offset,
			       &value, sizeof(unsigned long));
		    }
		    else{
			memcpy(output_addr + map->output_section->s.offset +
					      map->fine_relocs[i].output_offset,
			   contents + map->fine_relocs[i].input_offset,
			   map->s->size - map->fine_relocs[i].input_offset);
		    }
		}
	    }
	}
	/*
	 * The i386 has a special 5 byte stub that is modify by dyld to become 
	 * a JMP instruction.  When building prebound, we set the stub to be
	 * the JMP instruction. 
	 */
	else if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS &&
		prebinding == TRUE &&
		arch_flag.cputype == CPU_TYPE_I386 &&
	        (map->s->flags & S_ATTR_SELF_MODIFYING_CODE) ==
		    S_ATTR_SELF_MODIFYING_CODE &&
		map->s->reserved2 == 5){
	    nlists = (struct nlist *)(cur_obj->obj_addr +
				      cur_obj->symtab->symoff);
	    indirect_symtab = (unsigned long *)(cur_obj->obj_addr +
					    cur_obj->dysymtab->indirectsymoff);
	    strings = cur_obj->obj_addr + cur_obj->symtab->stroff;
	    for(i = 0; i < map->nfine_relocs; i++){
		if(map->fine_relocs[i].use_contents == TRUE &&
		   (dead_strip == FALSE || map->fine_relocs[i].live == TRUE)){
		    index = indirect_symtab[map->s->reserved1 + 
			    (map->fine_relocs[i].input_offset / 5)];
					    undefined_map = bsearch(&index,
			cur_obj->undefined_maps, cur_obj->nundefineds,
			sizeof(struct undefined_map),
			(int (*)(const void *, const void *))
			undef_bsearch);
		    if(undefined_map == NULL){
			merged_symbol = lookup_symbol(strings +
					    nlists[index].n_un.n_strx);
			if(merged_symbol->name_len == 0)
				fatal("interal error, scatter_copy() failed"
				  " in looking up external symbol");
		    }
		    else
			merged_symbol = undefined_map->merged_symbol;
		    value = merged_symbol->nlist.n_value;
		    delta = value - (map->output_section->s.addr +
				     map->fine_relocs[i].output_offset + 5);
		    jmpEntry = output_addr + map->output_section->s.offset +
			       map->fine_relocs[i].output_offset;
		    if(host_byte_sex != target_byte_sex)
			delta = SWAP_LONG(delta);
		    *jmpEntry = 0xE9; /* JMP rel32 */
		    memcpy(jmpEntry + 1, &delta, sizeof(unsigned long));
		}
	    }
	}
	else
#endif /* !defined(RLD) */
	/*
	 * For other indirect sections and coalesced sections only copy those
	 * parts of the section who's contents are used in the output file.
	 */
	 if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
	    (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
	    (map->s->flags & SECTION_TYPE) == S_COALESCED){
	    for(i = 0; i < map->nfine_relocs - 1; i++){
		if(map->fine_relocs[i].use_contents == TRUE &&
		   (dead_strip == FALSE || map->fine_relocs[i].live == TRUE)){
		    memcpy(output_addr + map->output_section->s.offset +
					      map->fine_relocs[i].output_offset,
			   contents + map->fine_relocs[i].input_offset,
			   map->fine_relocs[i+1].input_offset -
					      map->fine_relocs[i].input_offset);
		}
	    }
	    if(map->fine_relocs[i].use_contents == TRUE &&
	       (dead_strip == FALSE || map->fine_relocs[i].live == TRUE)){
		memcpy(output_addr + map->output_section->s.offset +
					      map->fine_relocs[i].output_offset,
		       contents + map->fine_relocs[i].input_offset,
		       map->s->size - map->fine_relocs[i].input_offset);
	    }
	}
	else{
	    for(i = 0; i < map->nfine_relocs - 1; i++){
		if(dead_strip == FALSE || map->fine_relocs[i].live == TRUE){
		    memcpy(output_addr + map->output_section->s.offset +
					      map->fine_relocs[i].output_offset,
			   contents + map->fine_relocs[i].input_offset,
			   map->fine_relocs[i+1].input_offset -
					      map->fine_relocs[i].input_offset);
		}
	    }
	    if(dead_strip == FALSE || map->fine_relocs[i].live == TRUE){
		memcpy(output_addr + map->output_section->s.offset +
					      map->fine_relocs[i].output_offset,
		       contents + map->fine_relocs[i].input_offset,
		       map->s->size - map->fine_relocs[i].input_offset);
	    }
	}
}

#ifndef RLD
/*
 * reloc_output_for_dyld() takes the relocation entries after being processed by
 * a relocation routine and copys the ones to be in the output file for a file
 * the is output for dyld.  It also changes the r_address field of the of the
 * relocation entries to be relative to the first segment's address rather than
 * the section's address.
 */
static
void
reloc_output_for_dyld(
struct section_map *map,
struct relocation_info *relocs,
struct relocation_info *output_locrel,
struct relocation_info *output_extrel,
unsigned long *nlocrel,
unsigned long *nextrel)
{
    unsigned long i, addr_adjust, temp, pair;
    struct relocation_info *reloc;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address, r_extern, r_type, r_scattered, r_pcrel,
		  r_symbolnum, r_value;
    enum bool partial_section, sectdiff, pic, has_sect_diff_relocs;
    enum bool flag_relocs, first_time;

	/* to shut up compiler warning messages "may be used uninitialized" */
	sreloc = NULL;

	/*
	 * If we are flagging relocation entries in read only sections set up
	 * to do that.
	 */
	first_time = TRUE;
	if(read_only_reloc_flag != READ_ONLY_RELOC_SUPPRESS)
	    flag_relocs = is_merged_section_read_only(map->output_section);
	else
	    flag_relocs = FALSE;
	if(flag_relocs == TRUE)
	    clear_read_only_reloc_flags();
	has_sect_diff_relocs = FALSE;

	*nlocrel = 0;
	*nextrel = 0;
	partial_section = (enum bool)
		(dead_strip == TRUE ||
		 (map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
	         (map->s->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ||
	         (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
	         (map->s->flags & SECTION_TYPE) == S_COALESCED);
	/*
	 * For MH_SPLIT_SEGS images the r_address is relative to the first
	 * read-write segment and there are no relocation entries allowed in
	 * the read-only segments.  This is needed because the r_address field
	 * is 24 bits which means that the normal split of 265meg wouldn't allow
	 * the use of 24 bits from the address of the first segment which is
	 * what is normally used for outputs for dyld.
	 */
	if(segs_read_only_addr_specified == TRUE)
	    addr_adjust = map->output_section->s.addr - 
	    		  segs_read_write_addr;
	else
	    addr_adjust = map->output_section->s.addr - 
			  merged_segments->sg.vmaddr;
	/*
	 * These relocation entries have been processed by a relocation routine
	 * turning external relocation entries into local relocation entries and
	 * updating the r_address field to be relative to the output section's
	 * address.
	 */
	for(i = 0; i < map->s->nreloc; i++){
	    reloc = relocs + i;
	    /*
	     * Break out the fields of the relocation entry we need here.
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_type = sreloc->r_type;
		r_extern = 0;
		r_value = sreloc->r_value;
		/*
		 * For a scattered relocation entry the r_symbolnum is never
		 * NO_SECT and that is all we need to know in this routine for
		 * a scattered relocation entry.  Calculating the r_symbolnum
		 * (n_sect) from the r_value now that it has been processed by
		 * a relocation routine is not easy as the value could be
		 * in a section with fine relocation entries.  It is doable but
		 * not needed here.  So we fake r_symbolnum to be anything but
		 * NO_SECT (the first section ordinal is used).
		 */
		r_symbolnum = 1;
	    }
	    else{
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_type = reloc->r_type;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
	    }
	    if(reloc_has_pair(arch_flag.cputype, r_type))
		pair = 1;
	    else
		pair = 0;
	    if(partial_section){
		if(fine_reloc_offset_in_output_for_output_offset(map,
							r_address) == FALSE){
		    i += pair;
		    continue;
		}
	    }
	    if(r_extern == 0){
		sectdiff = reloc_is_sectdiff(arch_flag.cputype, r_type);
		has_sect_diff_relocs |= sectdiff;
		pic = (enum bool)
		      (sectdiff == TRUE ||
		       (r_pcrel == 1 && r_symbolnum != NO_SECT));
	    }
	    else
		pic = FALSE;
	    /*
	     * For output_for_dyld PPC_RELOC_JBSR and HPPA_RELOC_JBSR's are
	     * never put out.
	     */
	    if((arch_flag.cputype == CPU_TYPE_POWERPC &&
		r_type == PPC_RELOC_JBSR) ||
	       (arch_flag.cputype == CPU_TYPE_HPPA &&
		r_type == HPPA_RELOC_JBSR)){
		i += pair;
		continue;
	    }

	    /*
	     * The relocation entries in the output file is based on one of
	     * three different cases:
	     * 	The output file is a multi module dynamic shared library
	     *  The output file has a dynamic linker load command
	     *  The output does not have a dynamic linker load command
	     */
	    if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		/*
		 * For multi module dynamic shared library files all external
		 * relocations are kept as external relocation entries except
		 * for references to private externs (which are have been turned
		 * into locals and kept as locals) and all non-position-
		 * independent local relocation entrie are kept. Modules of
		 * multi module dylibs are not linked together and can only be
		 * slid keeping all sections relative to each other the same.
		 */
		if(r_extern){
		    reloc->r_address += addr_adjust;
		    memcpy(output_extrel + *nextrel, reloc,
			   sizeof(struct relocation_info) * (1 + pair));
		    (*nextrel) += 1 + pair;
		    if(flag_relocs == TRUE)
			flag_read_only_reloc(map->s, r_symbolnum, &first_time);
		}
		else if(pic == FALSE){
		    if(r_scattered)
			sreloc->r_address += addr_adjust;
		    else
			reloc->r_address += addr_adjust;
		    memcpy(output_locrel + *nlocrel, reloc,
			   sizeof(struct relocation_info) * (1 + pair));
		    (*nlocrel) += 1 + pair;
		}
	    }
	    else if(has_dynamic_linker_command){
		/*
		 * For an file with a dynamic linker load command only external
		 * relocation entries for undefined symbols (those that have
		 * not been turned into locals) are kept.  This output file is
		 * at a fixed address and can't be moved.
		 */
		if(r_extern){
		    reloc->r_address += addr_adjust;
		    memcpy(output_extrel + *nextrel, reloc,
			   sizeof(struct relocation_info) * (1 + pair));
		    (*nextrel) += 1 + pair;
		    if(flag_relocs == TRUE)
			flag_read_only_reloc(map->s, r_symbolnum, &first_time);
		}
		/*
		 * Even though the file can't be moved we may be trying to
		 * prebind.  If we are prebinging we need the local
		 * relocation entries for lazy symbol pointers to be saved
		 * so dyld will have the info to undo this if it fails.
		 */
		else if(save_lazy_symbol_pointer_relocs == TRUE &&
			(map->s->flags & SECTION_TYPE) ==
				S_LAZY_SYMBOL_POINTERS){
		    if(r_scattered){
			temp = sreloc->r_address + addr_adjust;
			sreloc->r_address += addr_adjust;
			if(sreloc->r_address != temp)
			    error_with_cur_obj("can't create relocation entry "
				"for prebinding (address of section (%.16s,"
				"%.16s) more than 24-bits away from first "
				"segment, use -noprebind)",
				map->s->segname, map->s->sectname);
		    }
		    else
			reloc->r_address += addr_adjust;
		    memcpy(output_locrel + *nlocrel, reloc,
			   sizeof(struct relocation_info) * (1 + pair));
		    (*nlocrel) += 1 + pair;
		}
	    }
	    else{
		/*
		 * For an file without a dynamic linker load command external
		 * relocation entries for undefined symbols (those that have
		 * not been turned into locals) are kept and locals that are
		 * non-position-independent are kept.  This file can only be
		 * slid keeping all sections relative to each other the same.
		 */
		if(r_extern){
		    reloc->r_address += addr_adjust;
		    memcpy(output_extrel + *nextrel, reloc,
			   sizeof(struct relocation_info) * (1 + pair));
		    (*nextrel) += 1 + pair;
		    if(flag_relocs == TRUE)
			flag_read_only_reloc(map->s, r_symbolnum, &first_time);
		}
		else if(pic == FALSE){
		    if(r_scattered)
			sreloc->r_address += addr_adjust;
		    else
			reloc->r_address += addr_adjust;
		    memcpy(output_locrel + *nlocrel, reloc,
			   sizeof(struct relocation_info) * (1 + pair));
		    (*nlocrel) += 1 + pair;
		}
	    }
	    i += pair;
	}
	if(flag_relocs == TRUE && *nlocrel != 0){
	    if(read_only_reloc_flag == READ_ONLY_RELOC_ERROR)
		error_with_cur_obj("has local relocation entries in "
		    "non-writable section (%.16s,%.16s)",
		    map->s->segname, map->s->sectname);
	    else
		warning_with_cur_obj("has local relocation entries in "
		    "non-writable section (%.16s,%.16s)",
		    map->s->segname, map->s->sectname);
	}
	if(sect_diff_reloc_flag != SECT_DIFF_RELOC_SUPPRESS &&
	   has_sect_diff_relocs == TRUE){
	    if(sect_diff_reloc_flag == SECT_DIFF_RELOC_ERROR)
		error_with_cur_obj("has section difference relocation entries "
		    "in section (%.16s,%.16s)", map->s->segname,
		    map->s->sectname);
	    else
		warning_with_cur_obj("has section difference relocation entries"
		    " in section (%.16s,%.16s)", map->s->segname,
		    map->s->sectname);
	}
}

/*
 * is_merged_section_read_only() returns TRUE if the merged section is in a
 * segment that does not have write permision.  Otherwise it returns FALSE.
 */
static
enum bool
is_merged_section_read_only(
struct merged_section *key)
{
    struct merged_segment **p, *msg;
    struct merged_section **q, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    q = &(msg->content_sections);
	    while(*q){
		ms = *q;
		if(ms == key){
		    if((msg->sg.initprot & VM_PROT_WRITE) == 0)
			return(TRUE);
		    else
			return(FALSE);
		}
		q = &(ms->next);
	    }
	    q = &(msg->zerofill_sections);
	    while(*q){
		ms = *q;
		if(ms == key){
		    if((msg->sg.initprot & VM_PROT_WRITE) == 0)
			return(TRUE);
		    else
			return(FALSE);
		}
		q = &(ms->next);
	    }
	    p = &(msg->next);
	}
	fatal("internal error: is_merged_section_read_only() called with "
	      "bad merged section");
	return(FALSE);
}

/*
 * is_merged_symbol_coalesced() is needed by the relocation routines to check
 * for illegal references to coalesced symbols via external relocation routines.
 * The section number in a merged symbol when relocation is done is the section
 * number in the output file so we have to look through the merged sections to
 * find which section this is.  This routine returns TRUE if the symbol is in
 * a coalesced section.
 */
__private_extern__
enum bool
is_merged_symbol_coalesced(
struct merged_symbol *merged_symbol)
{
    struct merged_segment **p, *msg;
    struct merged_section **q, *ms;

	if((merged_symbol->nlist.n_type & N_TYPE) != N_SECT)
	    return(FALSE);

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    q = &(msg->content_sections);
	    while(*q){
		ms = *q;
		if(ms->output_sectnum == merged_symbol->nlist.n_sect){
		    if((ms->s.flags & SECTION_TYPE) == S_COALESCED)
			return(TRUE);
		    else
			return(FALSE);
		}
		q = &(ms->next);
	    }
	    p = &(msg->next);
	}
	fatal("internal error: is_merged_symbol_coalesced() called with "
	      "bad merged symbol");
	return(FALSE);
}

/*
 * scatter_copy_relocs() copies the relocation entries for an indirect section
 * or coalesced section (or any regular section if -dead_strip is specified)
 * into the output file based on which items in the section are in the output
 * file.  It returns the number of relocation entries that were put in the
 * output file.
 */
static
unsigned long
scatter_copy_relocs(
struct section_map *map,
struct relocation_info *relocs,
struct relocation_info *output_relocs)
{
    unsigned long i, nreloc;
    struct relocation_info *reloc;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address, r_type;

	/*
	 * No checks done here as they were previously done and if there were
	 * errors this will not even get called.
	 */
	nreloc = 0;
	for(i = 0; i < map->s->nreloc; i++){
	    reloc = relocs + i;
	    /*
	     * Break out the fields of the relocation entry we need here.
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		r_address = sreloc->r_address;
		r_type = sreloc->r_type;
	    }
	    else{
		r_address = reloc->r_address;
		r_type = reloc->r_type;
	    }
	    if(fine_reloc_offset_in_output_for_output_offset(map, r_address)){
		/* copy reloc into output file */
		memcpy(output_relocs + nreloc, reloc,
		       sizeof(struct relocation_info));
		nreloc++;
		if(reloc_has_pair(arch_flag.cputype, r_type)){
		    /* copy the reloc's pair into output file */
		    memcpy(output_relocs + nreloc, reloc + 1,
			   sizeof(struct relocation_info));
		    nreloc++;
		    i++;
		}
	    }
	    else if(reloc_has_pair(arch_flag.cputype, r_type))
		i++;
	}
	return(nreloc);
}

/*
 * nop_pure_instruction_scattered_sections() is a hack to pad an i386 pure
 * instructions sections with nop's (opcode 0x90) to make disassembly cleaner
 * between scatter loaded symbols.
 */
__private_extern__
void
nop_pure_instruction_scattered_sections(void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;
    char *contents;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if((ms->order_filename != NULL &&
		    (ms->s.flags & SECTION_TYPE) == S_REGULAR) ||
		   ((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		    (ms->s.flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS||
		    (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		    (ms->s.flags & SECTION_TYPE) == S_COALESCED)){
		    if(arch_flag.cputype == CPU_TYPE_I386 &&
		       (ms->s.flags & S_ATTR_PURE_INSTRUCTIONS) != 0){
			contents = output_addr + ms->s.offset;
			memset(contents, 0x90, ms->s.size);
		    }
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

/*
 * flush_scatter_copied_sections() flushes the entire merged section's output
 * for each merged regular (non-literal) content section that has a load order
 * (and indirect sections).
 */
__private_extern__
void
flush_scatter_copied_sections(void)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if((ms->contents_filename == NULL &&
		    (ms->order_filename != NULL || dead_strip == TRUE) &&
		    (ms->s.flags & SECTION_TYPE) == S_REGULAR) ||
		   ((ms->s.flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
		    (ms->s.flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS||
		    (ms->s.flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
		    (ms->s.flags & SECTION_TYPE) == S_COALESCED)){
		    output_flush(ms->s.offset, ms->s.size);
		}
		else if((dead_strip == TRUE) &&
		   ((ms->s.flags & SECTION_TYPE) == S_MOD_INIT_FUNC_POINTERS ||
		    (ms->s.flags & SECTION_TYPE) == S_MOD_TERM_FUNC_POINTERS)){
		    output_flush(ms->s.offset, ms->s.size);
		}
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

/*
 * live_marking() is called when -dead_strip is specified and marks the
 * fine_relocs of the sections and symbols live if they can be reached by the
 * exported symbols or other live blocks.
 */
__private_extern__
void
live_marking(void)
{
    struct merged_symbol *merged_symbol;
    enum bool found;
    unsigned long i, input_offset, section_type;
    struct fine_reloc *fine_reloc;
    struct merged_segment *msg, **p;
    struct merged_section *ms, **content, **zerofill;
    struct timeval t0, t1, t2, t3, t4, t5;
    double time_used;

	if(dead_strip_times == TRUE)
	    gettimeofday(&t0, NULL);

	/*
	 * First set up all the refs arrays in each fine_reloc and the pointer
	 * to the fine_reloc in each merged_symbol.
	 */
	build_references();
	/*
	 * If build_references() encountered a relocation error just return now.
	 */
	if(errors)
	    return;

	if(dead_strip_times == TRUE)
	    gettimeofday(&t1, NULL);

	/*
	 * If the output filetype has an entry point mark it live.  If the
	 * entry point symbol was specified mark it live and if it is in a
	 * section mark the fine_reloc for it live.  Else if no entry point
	 * symbol symbol specified mark the first non-zero sized fine_reloc in
	 * the first content section if there is one.
	 */
 	if(filetype != MH_FVMLIB &&
	   filetype != MH_DYLIB &&
	   filetype != MH_BUNDLE){
	    if(entry_point_name != NULL){
		merged_symbol = lookup_symbol(entry_point_name);
		/*
		 * If the symbol is not found the entry point it can't be
		 * marked live. Note: the error of specifying a bad entry point
		 * name is handled in layout_segments() in layout.c .
		 */
		if(merged_symbol->name_len != 0){
#ifdef DEBUG
		    if(((debug & (1 << 25)) || (debug & (1 << 26)))){
			print("** In live_marking() -e symbol ");
			print_obj_name(merged_symbol->definition_object);
			print("%s\n", merged_symbol->nlist.n_un.n_name);
		    }
#endif /* DEBUG */
		    merged_symbol->live = TRUE;
		    fine_reloc = merged_symbol->fine_reloc;
		    if(fine_reloc != NULL)
			fine_reloc->live = TRUE;
		}
	    }
	    else{
		/*
		 * To find the first non-zero sized fine_reloc in the the first
		 * content section we require that we have the info for the
		 * load maps.
		 */
		found = FALSE;
		for(msg = merged_segments;
		    msg != NULL && found == FALSE;
		    msg = msg->next){
		    for(ms = msg->content_sections;
			ms != NULL && found == FALSE;
			ms = ms->next){
			for(i = 0;
			    i < ms->norder_load_maps && found == FALSE;
			    i++){
			    if(ms->order_load_maps[i].size != 0){
				input_offset = ms->order_load_maps[i].value -
				    ms->order_load_maps[i].section_map->s->addr;
				fine_reloc = fine_reloc_for_input_offset(
				    ms->order_load_maps[i].section_map,
				    input_offset);
				fine_reloc->live = TRUE;
				if(fine_reloc->merged_symbol != NULL)
				    fine_reloc->merged_symbol->live = TRUE;
				found = TRUE;
#ifdef DEBUG
				if(((debug & (1 << 25)) ||
				   (debug & (1 << 26)))){
				    print("** In live_marking() entry point ");
				    if(ms->order_load_maps[i].archive_name !=
				       NULL)
					print("%s(%s):",
					    ms->order_load_maps[i].archive_name,
					    ms->order_load_maps[i].object_name);
				    else
					print("%s:",
					    ms->order_load_maps[i].object_name);
				    print("(%.16s,%.16s):0x%x:",
					  ms->s.segname, ms->s.sectname,
					  (unsigned int)
						(fine_reloc->input_offset));
		       		    print("%s\n",
					  ms->order_load_maps[i].symbol_name);
				}
#endif /* DEBUG */
			    }
			}
		    }
		}
	    }
	}

	/*
	 * If this is a shared library and a -init symbol was specified mark it
	 * live.
	 */
	if(filetype == MH_DYLIB && init_name != NULL){
	    merged_symbol = lookup_symbol(init_name);
	    /*
	     * If the symbol is not found the init routine it can't be marked
	     * live. Note: the error of specifying a bad init routine name is
	     * handled in layout_segments() in layout.c .
	     */
	    if(merged_symbol->name_len != 0){
#ifdef DEBUG
		if(((debug & (1 << 25)) || (debug & (1 << 26)))){
		    print("** In live_marking() -init symbol ");
		    print_obj_name(merged_symbol->definition_object);
		    print("%s\n", merged_symbol->nlist.n_un.n_name);
		}
#endif /* DEBUG */
		merged_symbol->live = TRUE;
		if(merged_symbol->fine_reloc != NULL)
		    merged_symbol->fine_reloc->live = TRUE;
	    }
	}

	/*
	 * Now mark the "exported" merged symbols and their fine_relocs live.
	 */
	mark_globals_live();

	/*
         * Now mark the fine_relocs for local symbols with the N_NO_DEAD_STRIP
	 * bit set live.
	 */
	mark_N_NO_DEAD_STRIP_local_symbols_live();

	/*
	 * Now mark all the fine_relocs in sections with the
	 * S_ATTR_NO_DEAD_STRIP attribute live.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->s.flags & S_ATTR_NO_DEAD_STRIP)
		    mark_all_fine_relocs_live_in_section(ms);
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		if(ms->s.flags & S_ATTR_NO_DEAD_STRIP)
		    mark_all_fine_relocs_live_in_section(ms);
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}

	/*
	 * If -no_dead_strip_inits_and_terms is specified for all things in
	 * mod init and term sections to be live.
	 */
	if(no_dead_strip_inits_and_terms == TRUE){
	    p = &merged_segments;
	    while(*p){
		msg = *p;
		content = &(msg->content_sections);
		while(*content){
		    ms = *content;
		    section_type = ms->s.flags & SECTION_TYPE;
		    if(section_type == S_MOD_INIT_FUNC_POINTERS ||
		       section_type == S_MOD_TERM_FUNC_POINTERS)
			mark_all_fine_relocs_live_in_section(ms);
		    content = &(ms->next);
		}
		p = &(msg->next);
	    }
	}

	if(dead_strip_times == TRUE)
	    gettimeofday(&t2, NULL);

	/*
	 * Now with the above code marking the initial fine_relocs live cause
	 * the references from the live fine relocs to be marked live.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
#ifdef DEBUG
		if(debug & (1 << 25))
		    print("In live_marking() for section (%.16s,%.16s)\n",
			  ms->s.segname, ms->s.sectname);
#endif /* DEBUG */
		walk_references_in_section(MARK_LIVE, ms);
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}

	if(dead_strip_times == TRUE)
	    gettimeofday(&t3, NULL);

	/*
	 * If -no_dead_strip_inits_and_terms was not specified, now with all
	 * other things marked live determine if the mod init and term
	 * routines are touching something live and if so mark them and their
	 * references live.
	 */
	if(no_dead_strip_inits_and_terms == FALSE){
	    p = &merged_segments;
	    while(*p){
		msg = *p;
		content = &(msg->content_sections);
		while(*content){
		    ms = *content;
		    section_type = ms->s.flags & SECTION_TYPE;
		    if(section_type == S_MOD_INIT_FUNC_POINTERS ||
		       section_type == S_MOD_TERM_FUNC_POINTERS)
			walk_references_in_section(SEARCH_FOR_LIVE, ms);
		    content = &(ms->next);
		}
		p = &(msg->next);
	    }
	}

	if(dead_strip_times == TRUE)
	    gettimeofday(&t4, NULL);

	/*
	 * Now with all other things marked live, for the sections marked with
	 * the S_ATTR_LIVE_SUPPORT attribute check to see if any of the
	 * references for each the fine_reloc touches some thing live.  If so
	 * cause it and its references to be live.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->s.flags & S_ATTR_LIVE_SUPPORT)
		    walk_references_in_section(CHECK_FOR_LIVE_TOUCH, ms);
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}

	if(dead_strip_times == TRUE){
	    gettimeofday(&t5, NULL);
	    time_used = calculate_time_used(&t0, &t1);
	    print("building of references: %f\n", time_used);
	    time_used = calculate_time_used(&t1, &t2);
	    print("mark initial live blocks: %f\n", time_used);
	    time_used = calculate_time_used(&t2, &t3);
	    print("mark live blocks referenced: %f\n", time_used);
	    time_used = calculate_time_used(&t3, &t4);
	    print("mark live constructors: %f\n", time_used);
	    time_used = calculate_time_used(&t4, &t5);
	    print("mark live exception frames: %f\n", time_used);
	}
}

/*
 * calculate_time_used() takes a start timeval and and an end time value and
 * calculates the difference as a double value and returns that.
 */
static
double
calculate_time_used(
struct timeval *start,
struct timeval *end)
{
    double time_used;

	time_used = end->tv_sec - start->tv_sec;
	if(end->tv_usec >= start->tv_usec)
	    time_used += ((double)(end->tv_usec - start->tv_usec)) / 1000000.0;
	else
	    time_used += -1.0 +
		((double)(1000000 + end->tv_usec - start->tv_usec) / 1000000.0);
	return(time_used);
}

/*
 * build_references() is called by live_marking() to set up the references
 * arrays off each fine reloc structure in each section.
 */
static
void
build_references(
void)
{
    struct merged_segment *msg, **p;
    struct merged_section *ms, **content;

	/*
	 * For objects that there sections loaded as one block we need to get
	 * all the merged symbols in those blocks to have their fine_reloc
	 * pointer set correctly.
	 */
	set_fine_relocs_for_merged_symbols();

	/*
	 * Set up the references for each section.
	 */
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
#ifdef DEBUG
		if(debug & (1 << 27))
		    print("In build_references() for section (%.16s,%.16s)\n",
			  ms->s.segname, ms->s.sectname);
#endif /* DEBUG */
		setup_references_in_section(ms);
		/*
		 * If setup_references_in_section() encountered a relocation
		 * error just return now.
		 */
		if(errors)
		    return;
		content = &(ms->next);
	    }
	    p = &(msg->next);
	}

#ifdef DEBUG
	if(debug & (1 << 28))
	    print_references();
#endif /* DEBUG */
}

#ifdef DEBUG
/*
 * print_references() is a debugging routine to print the references off each
 * fine_reloc after build_references() has been called.
 */
static
void
print_references(
void)
{
    unsigned long i, j, k;
    struct object_list *object_list, **q;
    struct object_file *obj;
    struct fine_reloc *fine_relocs, *fine_reloc;
    struct section_map *map;
    struct ref *ref;

	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		obj = &(object_list->object_files[i]);
		if(obj == base_obj)
		    continue;
		if(obj->dylib)
		    continue;
		if(obj->bundle_loader)
		    continue;
		if(obj->dylinker)
		    continue;
		for(j = 0; j < obj->nsection_maps; j++){
		    if(obj->section_maps[j].s->size == 0)
			continue;
		    map = &(obj->section_maps[j]);
		    if(map->nfine_relocs == 0)
			continue;
		    print("references for ");
		    print_obj_name(obj);
		    print("in section (%.16s,%.16s)\n",
			  map->s->segname, map->s->sectname);
		    fine_relocs = map->fine_relocs;
		    for(k = 0; k < map->nfine_relocs; k++){
			fine_reloc = map->fine_relocs + k;
			if(fine_reloc->refs != NULL){
			    print("  offset:0x%x",
				  (unsigned int)(fine_reloc->input_offset));
			    if(fine_reloc->merged_symbol != NULL)
				print(":%s", fine_reloc->
					     merged_symbol->nlist.n_un.n_name);
			    else
				print_symbol_name_from_order_load_maps(map,
				      map->s->addr + fine_reloc->input_offset);
			    print("\n");
			}
			for(ref = fine_reloc->refs;
			    ref != NULL;
			    ref = ref->next){
			    if(ref->merged_symbol != NULL)
				print("    %s\n",
				      ref->merged_symbol->nlist.n_un.n_name);
			    else{
				print("    (%.16s,%.16s):0x%x",
				  ref->map->s->segname,
				  ref->map->s->sectname,
				  (unsigned int)
				   (ref->fine_reloc->input_offset));
				print_symbol_name_from_order_load_maps(
				  ref->map,
				  ref->map->s->addr +
				  ref->fine_reloc->input_offset);
				printf("\n");
			    }
			}
		    }
		}
	    }
	}
}
#endif /* DEBUG */

/*
 * setup_references_in_section() is called with a merged section and sets up all
 * the references of the fine_relocs in that section.
 */
static
void
setup_references_in_section(
struct merged_section *ms)
{
    unsigned long i, j;
    struct object_list *object_list, **q;
    struct object_file *obj;
    struct section_map *map;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		obj = &(object_list->object_files[i]);
		if(obj == base_obj)
		    continue;
		if(obj->dylib)
		    continue;
		if(obj->bundle_loader)
		    continue;
		if(obj->dylinker)
		    continue;
		map = NULL;
		for(j = 0; j < obj->nsection_maps; j++){
		    if(obj->section_maps[j].output_section != ms)
			continue;
		    if(obj->section_maps[j].s->size == 0)
			continue;
		    map = &(obj->section_maps[j]);
		    break;
		}
		if(map == NULL)
		    continue;
#ifdef DEBUG
		if(debug & (1 << 27)){
		    print(" In setup_references_in_section() with object ");
		    print_obj_name(obj);
		    print("\n");
		}
#endif /* DEBUG */
		setup_references(map, obj);
	    }
	}
}

/*
 * setup_references() is passed a section map and the object file it is in.  It
 * digs through the relocation entries of the section creating a references for
 * each.
 */
static
void
setup_references(
struct section_map *map,
struct object_file *obj)
{
    unsigned long i, pair;
    struct relocation_info *relocs, reloc;
    struct scattered_relocation_info *sreloc;
    unsigned long r_address, r_type;
    char *contents;
    struct live_refs refs;
    struct fine_reloc *fine_reloc;

#ifdef DEBUG
	if(debug & (1 << 27)){
	    print("  In setup_references() ");
	    print_obj_name(obj);
	    print("(%.16s,%.16s)\n", map->s->segname, map->s->sectname);
	}
#endif /* DEBUG */

	/*
	 * Walk all the relocation entries of this section creating the
	 * references between blocks.
	 */
	relocs = (struct relocation_info *)(obj->obj_addr + map->s->reloff);
	if(obj->swapped && map->input_relocs_already_swapped == FALSE){
	    swap_relocation_info(relocs, map->s->nreloc, host_byte_sex);
	    map->input_relocs_already_swapped = TRUE;
	}
	for(i = 0; i < map->s->nreloc; i++){
	    /*
	     * Note all errors are not flagged here but left for the *_reloc()
	     * routines to flag them.  So for errors we just return from here.
	     */
	    reloc = relocs[i];
	    /*
	     * Break out just the fields of the relocation entry we need to
	     * determine if this entry (and its possible pair) are for this
	     * fine_reloc.
	     */
	    if((reloc.r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(&reloc);
		r_address = sreloc->r_address;
		r_type = sreloc->r_type;
	    }
	    else{
		r_address = reloc.r_address;
		r_type = reloc.r_type;
	    }
	    if(reloc_has_pair(arch_flag.cputype, r_type)){
		if(i + 1 >= map->s->nreloc)
		    return;
		pair = 1;
	    }
	    else
		pair = 0;
#ifdef DEBUG
	    if(debug & (1 << 27)){
		print("    reloc entry %lu", i);
		if(pair)
		    print(",%lu", i+1);
		print("\n");
	    }
#endif /* DEBUG */

	    /*
	     * Get the references for this relocation entry(s).
	     */
	    cur_obj = obj;
	    contents = obj->obj_addr + map->s->offset;
	    if(arch_flag.cputype == CPU_TYPE_POWERPC ||
		    arch_flag.cputype == CPU_TYPE_VEO)
		ppc_reloc(contents, relocs, map, &refs, i);
	    else if(arch_flag.cputype == CPU_TYPE_MC680x0)
		generic_reloc(contents, relocs, map, FALSE, &refs, i);
	    else if(arch_flag.cputype == CPU_TYPE_I386)
		generic_reloc(contents, relocs, map, TRUE, &refs, i);
	    else if(arch_flag.cputype == CPU_TYPE_ARM)
	      arm_reloc(contents, relocs, map, &refs, i);
	    else if(arch_flag.cputype == CPU_TYPE_MC88000 ||
		    arch_flag.cputype == CPU_TYPE_HPPA ||
		    arch_flag.cputype == CPU_TYPE_SPARC ||
		    arch_flag.cputype == CPU_TYPE_I860)
		fatal("-dead_strip not supported with cputype (%d)",
		      arch_flag.cputype);
	    else
		fatal("internal error: setup_references() "
		      "called with unknown cputype (%d) set",
		      arch_flag.cputype);
	    /* if there was a problem with the relocation just return now */
	    if(errors)
		return;

	    /*
	     * If this reloc has references then add them to the tmp_refs[] 
	     * array if they are new.
	     */
	    if(refs.ref1.ref_type != LIVE_REF_NONE){
		fine_reloc = fine_reloc_for_input_offset(map, r_address);
		setup_reference(&refs.ref1, obj, fine_reloc);
	    }
	    if(refs.ref2.ref_type != LIVE_REF_NONE){
		fine_reloc = fine_reloc_for_input_offset(map, r_address);
		setup_reference(&refs.ref2, obj, fine_reloc);
	    }
	    i += pair;
	}
}

/*
 * setup_reference() is passed a pointer to a live_ref struct in the specified
 * object and the fine_reloc that reference comes from.  It creates a struct
 * ref for the live_ref struct.  Then if that reference is not to itself and
 * already on the list for the fine_reloc it is added to the list.
 */
static
void
setup_reference(
struct live_ref *ref,
struct object_file *obj,
struct fine_reloc *self_fine_reloc)
{
    unsigned long r_symbolnum;
    struct section_map *local_map;
    struct fine_reloc *ref_fine_reloc;
    struct ref r, *refs, *new_ref;

	r.next = NULL;
	r.fine_reloc = NULL;
	r.map = NULL;
	r.obj = NULL;
	r.merged_symbol = NULL;
	if(ref->ref_type == LIVE_REF_VALUE){
	    r_symbolnum = r_symbolnum_from_r_value(ref->value, obj);
	    local_map = &(obj->section_maps[r_symbolnum - 1]);
	    ref_fine_reloc = fine_reloc_for_input_offset(local_map,
			      ref->value - local_map->s->addr);
#ifdef DEBUG
	    if(debug & (1 << 27)){
		print("      ref ");
		print("(%.16s,%.16s):0x%x", local_map->s->segname,
		      local_map->s->sectname,
		      (unsigned int)(ref_fine_reloc->input_offset));
		print_symbol_name_from_order_load_maps(local_map,
		    local_map->s->addr + ref_fine_reloc->input_offset);
		printf("\n");
	    }
#endif /* DEBUG */
	    if(self_fine_reloc == ref_fine_reloc)
		return;
	    r.fine_reloc = ref_fine_reloc;
	    r.map = local_map;
	    r.obj = obj;
	    r.merged_symbol = NULL;
	}
	else if(ref->ref_type == LIVE_REF_SYMBOL){
	    r.merged_symbol = ref->merged_symbol;
	    r.fine_reloc = NULL;
	    r.map = NULL;
	    r.obj = NULL;
#ifdef DEBUG
	    if(debug & (1 << 27)){
		print("      ref ");
		print("%s", ref->merged_symbol->nlist.n_un.n_name);
		printf("\n");
	    }
#endif /* DEBUG */
	}
	/*
	 * See if this reference is already in the list of references.
	 */
	for(refs = self_fine_reloc->refs ; refs != NULL ; refs = refs->next){
	    if(r.fine_reloc == refs->fine_reloc &&
	       r.map == refs->map &&
	       r.obj == refs->obj &&
	       r.merged_symbol == refs->merged_symbol)
		return;
	}
	/* it is not in the list so add it */
	new_ref = allocate(sizeof(struct ref));
	*new_ref = r;
	new_ref->next = self_fine_reloc->refs;
	self_fine_reloc->refs = new_ref;
}

/*
 * get_fine_reloc_for_merged_symbol() finds the fine_reloc for the
 * specified merged_symbol (if any) and returns it or NULL.  It also returns
 * the section map for the symbol if local_map is not NULL.
 */
__private_extern__
struct fine_reloc *
get_fine_reloc_for_merged_symbol(
struct merged_symbol *merged_symbol,
struct section_map **local_map)
{
    unsigned long n_sect, input_offset, i;
    struct section_map *map;
    struct fine_reloc *fine_reloc;

	/* N_INDR symbols have had their indirection resolved at this point. */
	if((merged_symbol->nlist.n_type & N_TYPE) == N_INDR)
	    merged_symbol = (struct merged_symbol *)
			    merged_symbol->nlist.n_value;

	/*
	 * Find the fine_reloc for this symbol if any.  That will be in the
	 * section map for the object that defines this symbol.
	 */
	if(merged_symbol->defined_in_dylib == FALSE &&
	   (merged_symbol->nlist.n_type & N_TYPE) == N_SECT){
	    n_sect = merged_symbol->nlist.n_sect;
	    map = &(merged_symbol->definition_object->section_maps[n_sect - 1]);
	    if(map->nfine_relocs != 0){
		/*
		 * The value of the merged symbol is the value in the input
		 * file at this point.
		 */
		input_offset = merged_symbol->nlist.n_value - map->s->addr;
		fine_reloc = fine_reloc_for_input_offset(map, input_offset);
		/*
		 * It is possible that there may be more than one merged symbol
		 * at the same input_offset.  If this fine_reloc is not for this
		 * merged symbol search the fine_relocs for one that has this
		 * merged_symbol.
		 */
		if(fine_reloc->merged_symbol != merged_symbol){
		    for(i = 0; i < map->nfine_relocs; i++){
			if(map->fine_relocs[i].merged_symbol == merged_symbol){
			    fine_reloc = map->fine_relocs + i;
			    break;
			}
		    }
		}
		if(local_map != NULL)
		    *local_map = map;
		return(fine_reloc);
	    }
	}
	return(NULL);
}

/*
 * mark_all_fine_relocs_live_in_section() is called for sections that have the
 * S_ATTR_NO_DEAD_STRIP section attribute and marks all the fine_relocs in
 * objects with that section live.
 */
static
void
mark_all_fine_relocs_live_in_section(
struct merged_section *ms)
{
    unsigned long i, j;
    struct object_list *object_list, **q;
    struct fine_reloc *fine_relocs;
    struct object_file *obj;
    struct section_map *map;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		obj = &(object_list->object_files[i]);
		if(obj == base_obj)
		    continue;
		if(obj->dylib)
		    continue;
		if(obj->bundle_loader)
		    continue;
		if(obj->dylinker)
		    continue;
		map = NULL;
		for(j = 0; j < obj->nsection_maps; j++){
		    if(obj->section_maps[j].output_section != ms)
			continue;
		    if(obj->section_maps[j].s->size == 0)
			continue;
		    map = &(obj->section_maps[j]);
		    break;
		}
		if(map == NULL)
		    continue;

#ifdef DEBUG
		if(debug & (1 << 25)){
		    print(" mark_all_fine_relocs_live_in_section() with "
			  "object");
		    print_obj_name(obj);
		    print("\n");
		}
#endif /* DEBUG */

		fine_relocs = map->fine_relocs;
		for(j = 0; j < map->nfine_relocs; j++){
		    fine_relocs[j].live = TRUE;
		}
	    }
	}
}

/*
 * walk_references_in_section() is called with an operation and a merged section
 * and walks the references of the fine_relocs in that section.
 *
 * If the operation is MARK_LIVE it looks for live fine_relocs in the specified
 * section and causes its references to be marked live.
 *
 * If the operation is SEARCH_FOR_LIVE it is being called with a mod init or
 * term section and for each fine_reloc in the section it determines if it's
 * references reach something that is live.  If it does it marks the fine_reloc
 * live and causes all of its references to be marked live.
 *
 * If the operation is CHECK_FOR_LIVE_TOUCH it is being called for a section
 * with the live support attribute and for each fine_reloc in the section it
 * determines if it directly references something that is live.  If it does it
 * marks the fine_reloc live and causes all of its references to be marked live.
 */
static
void
walk_references_in_section(
enum walk_references_operation operation,
struct merged_section *ms)
{
    unsigned long i, j;
    struct object_list *object_list, **q;
    struct fine_reloc *fine_relocs;
    struct object_file *obj;
    struct section_map *map;
    enum bool found_live;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		obj = &(object_list->object_files[i]);
		if(obj == base_obj)
		    continue;
		if(obj->dylib)
		    continue;
		if(obj->bundle_loader)
		    continue;
		if(obj->dylinker)
		    continue;
		map = NULL;
		for(j = 0; j < obj->nsection_maps; j++){
		    if(obj->section_maps[j].output_section != ms)
			continue;
		    if(obj->section_maps[j].s->size == 0)
			continue;
		    map = &(obj->section_maps[j]);
		    break;
		}
		if(map == NULL)
		    continue;

#ifdef DEBUG
		if(debug & (1 << 25)){
		    print(" In walk_references_in_section() with object ");
		    print_obj_name(obj);
		    print("\n");
		}
#endif /* DEBUG */

		fine_relocs = map->fine_relocs;
		for(j = 0; j < map->nfine_relocs; j++){
		    if(operation == MARK_LIVE){
			if(fine_relocs[j].live == TRUE &&
			   fine_relocs[j].refs_marked_live == FALSE){
			    walk_references(
				MARK_LIVE,
				fine_relocs + j,
				map,
				obj);
			}
		    }
		    else if(operation == SEARCH_FOR_LIVE ||
		            operation == CHECK_FOR_LIVE_TOUCH){
			found_live = FALSE;
			if(fine_relocs[j].searched_for_live_refs == FALSE ||
			   operation == CHECK_FOR_LIVE_TOUCH){
			    found_live = walk_references(
			        operation,
				fine_relocs + j,
				map,
				obj);
			    /*
			     * If something reached or touched from this
			     * fine_reloc was found to be live then mark it
			     * live and cause its references to be marked live.
			     */ 
			    if(found_live == TRUE){
#ifdef DEBUG
				if(debug & (1 << 25)){
				    print("  In walk_references_in_section("
					  "%s) with object ",
					  walk_references_operation_names[
					  operation]);
				    print_obj_name(obj);
				    print("fine_relocs[%lu].input_offset = "
					  "0x%x found_live == TRUE\n", j,
					  (unsigned int)
					  (fine_relocs[j].input_offset) );
				}
#endif /* DEBUG */
				fine_relocs[j].live = TRUE;
				if(fine_relocs[j].refs_marked_live == FALSE){
				    walk_references(
					MARK_LIVE,
					fine_relocs + j,
					map,
					obj);
				}
			    }
			}
		    }
		    else{
			fatal("internal error: walk_references_in_section() "
			      "called with unknown operation (%d)", operation);
		    }
		}
	    }
	}
}

/*
 * walk_references() walks the references of the specified fine_reloc in the
 * specified map, in the the specified object.
 *
 * For the MARK_LIVE operation it is called with a fine_reloc that is live,
 * this routine marks all the fine_reloc references live.  The return value is
 * meaningless for the MARK_LIVE operation.
 *
 * For the SEARCH_FOR_LIVE operation it searches for any referenced fine_reloc
 * that is marked live.  If it finds a referenced fine_reloc that is marked
 * live it returns TRUE and stops searching.  If it completes it search without 
 * finding a fine_reloc that is marked live it returns FALSE.
 *
 * For the CHECK_FOR_LIVE_TOUCH operation it checks only the directly referenced
 * fine_reloc's to see if one of them is live. If it finds a referenced
 * fine_reloc that is marked live it returns TRUE.  If it does not it returns
 * FALSE.
 */
static
enum bool
walk_references(
enum walk_references_operation operation,
struct fine_reloc *fine_reloc,
struct section_map *map,
struct object_file *obj)
{
    enum bool found_live;
    struct ref r, *ref;

#ifdef DEBUG
	if(debug & (1 << 25)){
	    print("  In walk_references(%s) ",
		  walk_references_operation_names[operation]);
	    print_obj_name(obj);
	    print("(%.16s,%.16s):0x%x", map->s->segname, map->s->sectname,
		  (unsigned int)(fine_reloc->input_offset));
	    if(fine_reloc->merged_symbol != NULL)
		print(":%s", fine_reloc->merged_symbol->nlist.n_un.n_name);
	    print("\n");
	}
#endif /* DEBUG */

	if(operation == MARK_LIVE){
	    fine_reloc->refs_marked_live = TRUE;
	    /*
	     * Since this fine_reloc is live if this is in a symbol stub or
	     * or symbol pointer section we need to mark the indirect symbol
	     * for it live.
	     */
	    if((map->s->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||
	       (map->s->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||
	       (map->s->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS){
		if(indirect_live_ref(fine_reloc, map, obj, &r) == TRUE)
		    ref_operation(MARK_LIVE, &r, obj);
	    }
	}
	else{ /* operation == SEARCH_FOR_LIVE */
	    fine_reloc->searched_for_live_refs = TRUE;
	    if(fine_reloc->live == TRUE)
		return(TRUE);
	}

	/*
	 * Walk the references of this fine_reloc.
	 */
	for(ref = fine_reloc->refs; ref != NULL; ref = ref->next){
	    if(operation == MARK_LIVE){
		ref_operation(MARK_LIVE, ref, obj);
	    }
	    else if(operation == SEARCH_FOR_LIVE ||
		    operation == CHECK_FOR_LIVE_TOUCH){
		found_live = ref_operation(operation, ref, obj);
		    if(found_live == TRUE)
			return(TRUE);
	    }
	    else{
		fatal("internal error: walk_references() called with "
		      "unknown operation (%d)", operation);
	    }
	}
	return(FALSE);
}

/*
 * ref_operation() gets the fine_reloc being referenced from the specified
 * ref in the specified object then preforms the specified operation.
 *
 * For the MARK_LIVE operation if the fine_reloc is not marked live, it is
 * marked live and then walk_references() is called with the MARK_LIVE operation
 * to mark its references live.  If the specified ref is a symbol defined
 * in a dylib then
mark_dylib_references_live() is called to mark that dylib's module's
 * references live. For the MARK_LIVE operation the return value is meaningless.
 *
 * For the SEARCH_FOR_LIVE operation if the fine_reloc is marked live then TRUE
 * is returned.  Else walk_references() is called with the SEARCH_FOR_LIVE
 * operation and if it returns TRUE then TRUE is returned.  Else FALSE is
 * returned.  If the specified ref is a symbol defined in a dylib then
something will called to walk the references of the dylib searching for a live
 * symbol.
 * 
 * For the CHECK_FOR_LIVE_TOUCH operation if the fine_reloc is marked live the
 * TRUE is returned else FALSE is returned.
 */
static
enum bool
ref_operation(
enum walk_references_operation operation,
struct ref *ref,
struct object_file *obj)
{
    unsigned long n_sect;
    struct section_map *local_map;
    struct merged_symbol *indr_merged_symbol;
    enum bool found_live;
    struct fine_reloc *ref_fine_reloc;

	if(ref->merged_symbol == NULL){
#ifdef DEBUG
	    if((((debug & (1 << 25)) || (debug & (1 << 26))) &&
	       ref->fine_reloc->live != TRUE)){
		print("** In ref_operation(%s) ",
		      walk_references_operation_names[operation]);
		print_obj_name(obj);
		print("(%.16s,%.16s):0x%x", ref->map->s->segname,
		      ref->map->s->sectname,
		      (unsigned int)(ref->fine_reloc->input_offset));
		if(ref->fine_reloc->merged_symbol != NULL){
		    print(":%s",
			  ref->fine_reloc->merged_symbol->nlist.n_un.n_name);
		}
		else{
		    print_symbol_name_from_order_load_maps(ref->map,
			ref->map->s->addr + ref->fine_reloc->input_offset);
		}
		print("\n");
	    }
#endif /* DEBUG */

	    if(operation == MARK_LIVE){
		ref->fine_reloc->live = TRUE;
		if(ref->fine_reloc->merged_symbol != NULL)
		    ref->fine_reloc->merged_symbol->live = TRUE;
		if(ref->fine_reloc->refs_marked_live == FALSE){
		    walk_references(
			MARK_LIVE,
			ref->fine_reloc,
			ref->map,
			ref->obj);
		}
	    }
	    else if(operation == SEARCH_FOR_LIVE){
		if(ref->fine_reloc->live == TRUE)
		    return(TRUE);
		else{
		    if(ref->fine_reloc->searched_for_live_refs == FALSE){
			found_live = walk_references(
			    SEARCH_FOR_LIVE,
			    ref->fine_reloc,
			    ref->map,
			    ref->obj);
			if(found_live == TRUE)
			    return(TRUE);
		    }
		}
	    }
	    else if(operation == CHECK_FOR_LIVE_TOUCH){
		if(ref->fine_reloc->live == TRUE && 
		   (ref->map->s->flags & S_ATTR_LIVE_SUPPORT) == 0)
		    return(TRUE);
		else
		    return(FALSE);
	    }
	    else{
		fatal("internal error: ref_operation() called with "
		      "unknown operation (%d)", operation);
	    }
	}
	else /* ref->merged_symbol != NULL */ {
	    if(operation == MARK_LIVE){
		ref->merged_symbol->live = TRUE;
		if((ref->merged_symbol->nlist.n_type & N_TYPE) == N_INDR){
		    indr_merged_symbol = (struct merged_symbol *)
				    ref->merged_symbol->nlist.n_value;
		    indr_merged_symbol->live = TRUE;
		}
	    }
	    else if(operation == SEARCH_FOR_LIVE){
		if(ref->merged_symbol->live == TRUE)
		    return(TRUE);
	    }
	    else if(operation == CHECK_FOR_LIVE_TOUCH){
		if(ref->merged_symbol->live == TRUE)
		    return(TRUE);
		else
		    return(FALSE);
	    }
	    else{
		fatal("internal error: ref_operation() called with "
		      "unknown operation (%d)", operation);
	    }
	    
	    if(ref->merged_symbol->defined_in_dylib == TRUE){
		if(operation == MARK_LIVE){
		    /*
		     * If this is defined in a dylib then we need to mark
		     * that module's referernces live in case the references
		     * loop back and reference something in the objects
		     * being loaded.
		    mark_dylib_references_live(ref->merged_symbol);
		     */
		    ;
		}
		else{ /* operation == SEARCH_FOR_LIVE */
/* need to add code to search through a dylib's references for live symbols */
		    ;
		}
	    }
	    else /* merged_symbol->defined_in_dylib == FALSE */ {
		ref_fine_reloc = ref->merged_symbol->fine_reloc;
		if((ref->merged_symbol->nlist.n_type & N_TYPE) == N_SECT){
		    n_sect = ref->merged_symbol->nlist.n_sect;
		    local_map = &(ref->merged_symbol->definition_object->
				  section_maps[n_sect - 1]);
		}
		else
		    local_map = NULL;
		if(ref_fine_reloc != NULL){
#ifdef DEBUG
		    if((((debug & (1 << 25)) || (debug & (1 << 26))) &&
		       ref_fine_reloc->live != TRUE)){
			print("** In ref_operation(%s) ",
			      walk_references_operation_names[operation]);
			print_obj_name(ref->merged_symbol->definition_object);
			if(local_map != NULL)
			    print("(%.16s,%.16s)", local_map->s->segname,
				  local_map->s->sectname);
			print(":%s\n", ref->merged_symbol->nlist.n_un.n_name);
		    }
#endif /* DEBUG */
		    if(operation == MARK_LIVE){
			ref_fine_reloc->live = TRUE;
			if(ref_fine_reloc->refs_marked_live == FALSE){
			    walk_references(
				MARK_LIVE,
				ref_fine_reloc,
				local_map,
				ref->merged_symbol->definition_object);
			}
		    }
		    else{ /* operation == SEARCH_FOR_LIVE */
			if(ref_fine_reloc->live == TRUE)
			    return(TRUE);
			if(ref_fine_reloc->searched_for_live_refs == FALSE){
			    found_live = walk_references(
				SEARCH_FOR_LIVE,
				ref_fine_reloc,
				local_map,
				ref->merged_symbol->definition_object);
			    if(found_live == TRUE)
				return(TRUE);
			}
		    }
		}
	    }
	}
	return(FALSE);
}

/*
 * r_symbolnum_from_r_value calculates the r_symbolnum (n_sect) from the 
 * specified r_value in the specified object_file.  If the r_value is not in
 * any section then 0 (NO_SECT) is returned.
 */
__private_extern__
unsigned long
r_symbolnum_from_r_value(
unsigned long r_value,
struct object_file *obj)
{
    unsigned i, r_symbolnum;

	r_symbolnum = 0;
	for(i = 0; i < obj->nsection_maps; i++){
	    if(r_value >= obj->section_maps[i].s->addr &&
	       r_value < obj->section_maps[i].s->addr +
			 obj->section_maps[i].s->size){
		r_symbolnum = i + 1;
		break;
	    }
	}
	if(r_symbolnum == 0){
	    /*
	     * The edge case where the last address past the end of
	     * of the last section is referenced.
	     */
	    for(i = 0; i < obj->nsection_maps; i++){
		if(r_value == obj->section_maps[i].s->addr +
			      obj->section_maps[i].s->size){
		    r_symbolnum = i + 1;
		    break;
		}
	    }
	}
	return(r_symbolnum);
}

#endif /* !defined(RLD) */

#ifdef RLD
/*
 * reset_merged_sections() is called from rld_load() to place the merged
 * sections back on their merged segment (layout() placed all of them on the
 * object_segment for the MH_OBJECT filetype) and it zeros the size of each the
 * merged section so it can be accumulated for the next rld_load().
 */
__private_extern__
void
reset_merged_sections(void)
{
    struct merged_segment *msg;
    struct merged_section *ms, *prev_ms;

	/*
	 * First add the debug segments back on the end of the list of the
	 * original merged segments.
	 */
	for(msg = original_merged_segments;
	    msg != NULL;
	    /* no increment expression */){
	    if(msg->next == NULL)
		break;
	    msg = msg->next;
	}
	if(msg != NULL)
	    msg->next = debug_merged_segments;

	msg = original_merged_segments;
	if(msg != NULL && merged_segments->content_sections != NULL){
	    ms = merged_segments->content_sections;
	    while(ms != NULL){
		if(strncmp(ms->s.segname, msg->sg.segname,
			   sizeof(msg->sg.segname)) == 0){
		    msg->content_sections = ms;
		    ms->s.size = 0;
		    prev_ms = ms;
		    ms = ms->next;
		    while(ms != NULL && strncmp(ms->s.segname, msg->sg.segname,
			   			sizeof(msg->sg.segname)) == 0){
			ms->s.size = 0;
			prev_ms = ms;
			ms = ms->next;
		    }
		    prev_ms->next = NULL;
		}
		else{
		    msg = msg->next;
		}
	    }
	}

	msg = original_merged_segments;
	if(msg != NULL && merged_segments->zerofill_sections != NULL){
	    ms = merged_segments->zerofill_sections;
	    while(ms != NULL){
		if(strncmp(ms->s.segname, msg->sg.segname,
			   sizeof(msg->sg.segname)) == 0){
		    msg->zerofill_sections = ms;
		    ms->s.size = 0;
		    prev_ms = ms;
		    ms = ms->next;
		    while(ms != NULL && strncmp(ms->s.segname, msg->sg.segname,
			   			sizeof(msg->sg.segname)) == 0){
			ms->s.size = 0;
			prev_ms = ms;
			ms = ms->next;
		    }
		    prev_ms->next = NULL;
		}
		else{
		    msg = msg->next;
		}
	    }
	}
	merged_segments = original_merged_segments;
	original_merged_segments = NULL;
}

/*
 * zero_merged_sections_sizes() is called from rld_load() to zero the size field
 * in the merged sections so the sizes can be accumulated and free the literal
 * data for any literal sections.  Also the alignment of the existing sections
 * is reset to zero.
 */
__private_extern__
void
zero_merged_sections_sizes(void)
{
    struct merged_segment **p, *msg;
    struct merged_section **q, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    q = &(msg->content_sections);
	    while(*q){
		ms = *q;
		ms->s.size = 0;
		ms->s.align = 0;
		if(ms->literal_data != NULL){
		    if(ms->literal_free != NULL){
			(*ms->literal_free)(ms->literal_data, ms);
		    }
		}
		q = &(ms->next);
	    }
	    q = &(msg->zerofill_sections);
	    while(*q){
		ms = *q;
		ms->s.size = 0;
		ms->s.align = 0;
		q = &(ms->next);
	    }
	    p = &(msg->next);
	}
}

/*
 * remove_sections() removes the sections and segments that first came from the
 * current set from the merged section list.  The order that sections are
 * merged on to the lists is taken advantaged of here.
 */
__private_extern__
void
remove_merged_sections(void)
{
    struct merged_segment *msg, *prev_msg, *next_msg;
    struct merged_section *ms, *prev_ms, *next_ms;

	/* The compiler "warning: `prev_msg' and `prev_ms' may be used */
	/* uninitialized in this function" can safely be ignored */
	prev_msg = NULL;
	prev_ms = NULL;

	if(original_merged_segments != NULL)
	    reset_merged_sections();

	for(msg = merged_segments; msg != NULL; msg = msg->next){
	    /*
	     * If this segment first comes from the current set then all
	     * remaining segments also come from this set and all of their
	     * sections.  So they are all removed from the list.
	     */
	    if(msg->set_num == cur_set){
		if(msg == merged_segments)
		    merged_segments = NULL;
		else
		    prev_msg->next = NULL;
		while(msg != NULL){
		    ms = msg->content_sections;
		    while(ms != NULL){
			if(ms->literal_data != NULL){
			    if(ms->literal_free != NULL){
				(*ms->literal_free)(ms->literal_data, ms);
				free(ms->literal_data);
				ms->literal_data = NULL;
			    }
			}
			next_ms = ms->next;
			free(ms);
			ms = next_ms;
		    }
		    ms = msg->zerofill_sections;
		    while(ms != NULL){
			next_ms = ms->next;
			free(ms);
			ms = next_ms;
		    }
		    next_msg = msg->next;
		    free(msg);
		    msg = next_msg;
		}
		break;
	    }
	    else{
		/*
		 * This segment first comes from other than the current set
		 * so check to see in any of it's sections from from the 
		 * current set and if so remove them.  Again advantage of the
		 * order is taken so that if a section if found to come from
		 * the current set all remaining sections in that list also come
		 * from that set.
		 */
		for(ms = msg->content_sections; ms != NULL; ms = ms->next){
		    if(ms->set_num == cur_set){
			if(ms == msg->content_sections)
			    msg->content_sections = NULL;
			else
			    prev_ms->next = NULL;
			while(ms != NULL){
			    msg->sg.nsects--;
			    if(ms->literal_data != NULL)
				free(ms->literal_data);
			    next_ms = ms->next;
			    free(ms);
			    ms = next_ms;
			}
			break;
		    }
		    prev_ms = ms;
		}
		for(ms = msg->zerofill_sections; ms != NULL; ms = ms->next){
		    if(ms->set_num == cur_set){
			if(ms == msg->zerofill_sections)
			    msg->zerofill_sections = NULL;
			else
			    prev_ms->next = NULL;
			while(ms != NULL){
			    msg->sg.nsects--;
			    next_ms = ms->next;
			    free(ms);
			    ms = next_ms;
			}
			break;
		    }
		    prev_ms = ms;
		}
	    }
	    prev_msg = msg;
	}
}
#endif /* RLD */

#ifdef DEBUG
/*
 * print_merged_sections() prints the merged section table.  For debugging.
 */
__private_extern__
void
print_merged_sections(
char *string)
{
    struct merged_segment *msg;
    struct merged_section *ms;

	print("Merged section list (%s)\n", string);
	for(msg = merged_segments; msg ; msg = msg->next){
	    print("    Segment %.16s\n", msg->sg.segname);
	    print("\tcmd %u\n", msg->sg.cmd);
	    print("\tcmdsize %u\n", msg->sg.cmdsize);
	    print("\tvmaddr 0x%x ", (unsigned int)msg->sg.vmaddr);
	    print("(addr_set %s)\n", msg->addr_set ? "TRUE" : "FALSE");
	    print("\tvmsize 0x%x\n", (unsigned int)msg->sg.vmsize);
	    print("\tfileoff %u\n", msg->sg.fileoff);
	    print("\tfilesize %u\n", msg->sg.filesize);
	    print("\tmaxprot ");
	    print_prot(msg->sg.maxprot);
	    print(" (prot_set %s)\n", msg->prot_set ? "TRUE" : "FALSE");
	    print("\tinitprot ");
	    print_prot(msg->sg.initprot);
	    print("\n");
	    print("\tnsects %u\n", msg->sg.nsects);
	    print("\tflags %u\n", msg->sg.flags);
#ifdef RLD
	    print("\tset_num %lu\n", msg->set_num);
#endif /* RLD */
	    print("\tfilename %s\n", msg->filename);
	    print("\tcontent_sections\n");
	    for(ms = msg->content_sections; ms ; ms = ms->next){
		print("\t    Section (%.16s,%.16s)\n",
		       ms->s.segname, ms->s.sectname);
		print("\t\taddr 0x%x\n", (unsigned int)ms->s.addr);
		print("\t\tsize %u\n", ms->s.size);
		print("\t\toffset %u\n", ms->s.offset);
		print("\t\talign %u\n", ms->s.align);
		print("\t\tnreloc %u\n", ms->s.nreloc);
		print("\t\treloff %u\n", ms->s.reloff);
		print("\t\tflags %s\n",
		      section_flags[ms->s.flags & SECTION_TYPE]);
#ifdef RLD
		print("\t\tset_num %d\n", ms->set_num);
#endif /* RLD */
		if(ms->relocated == TRUE)
    		    print("\t    relocated TRUE\n");
		else
    		    print("\t    relocated FALSE\n");
		if(ms->referenced == TRUE)
    		    print("\t    referenced TRUE\n");
		else
    		    print("\t    referenced FALSE\n");
		if(ms->contents_filename){
		    print("\t    contents_filename %s\n",
			  ms->contents_filename);
		    print("\t    file_addr 0x%x\n",
			  (unsigned int)ms->file_addr);
		    print("\t    file_size %lu\n", ms->file_size);
		}
		if(ms->order_filename){
		    print("\t    order_filename %s\n",
			  ms->order_filename);
		    print("\t    order_addr 0x%x\n",
			  (unsigned int)ms->order_addr);
		    print("\t    order_size %lu\n", ms->order_size);
		}
		if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS)
		    print_cstring_data(ms->literal_data, "\t    ");
		if((ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS)
		    print_literal4_data(ms->literal_data, "\t    ");
		if((ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS)
		    print_literal8_data(ms->literal_data, "\t    ");
		if((ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS)
		    print_literal_pointer_data(ms->literal_data, "\t    ");
	    }
	    print("\tzerofill_sections\n");
	    for(ms = msg->zerofill_sections; ms ; ms = ms->next){
		print("\t    Section (%.16s,%.16s)\n",
		       ms->s.segname, ms->s.sectname);
		print("\t\taddr 0x%x\n", (unsigned int)ms->s.addr);
		print("\t\tsize %u\n", ms->s.size);
		print("\t\toffset %u\n", ms->s.offset);
		print("\t\talign %u\n", ms->s.align);
		print("\t\tnreloc %u\n", ms->s.nreloc);
		print("\t\treloff %u\n", ms->s.reloff);
		print("\t\tflags %s\n",
		      section_flags[ms->s.flags & SECTION_TYPE]);
#ifdef RLD
		print("\t\tset_num %lu\n", ms->set_num);
#endif /* RLD */
	    }
	}
}

/*
 * print_merged_section_stats() prints the stats for the merged sections.
 * For tuning..
 */
__private_extern__
void
print_merged_section_stats(void)
{
    struct merged_segment *msg;
    struct merged_section *ms;

	for(msg = merged_segments; msg ; msg = msg->next){
	    for(ms = msg->content_sections; ms ; ms = ms->next){
		if((ms->s.flags & SECTION_TYPE) == S_LITERAL_POINTERS)
		    literal_pointer_data_stats(ms->literal_data, ms);
		else if((ms->s.flags & SECTION_TYPE) == S_CSTRING_LITERALS)
		    cstring_data_stats(ms->literal_data, ms);
		else if((ms->s.flags & SECTION_TYPE) == S_4BYTE_LITERALS)
		    literal4_data_stats(ms->literal_data, ms);
		else if((ms->s.flags & SECTION_TYPE) == S_8BYTE_LITERALS)
		    literal8_data_stats(ms->literal_data, ms);
	    }
	}
}

/*
 * print_load_order() prints the load_order array passed to it.
 * For debugging.
 */
__private_extern__
void
print_load_order(
struct load_order *load_order,
unsigned long nload_order,
struct merged_section *ms,
struct object_file *object_file,
char *string)
{
    unsigned long i;

	print("Load order 0x%x %lu entries for (%.16s,%.16s) of ",
	      (unsigned int)load_order, nload_order,
	      ms->s.segname, ms->s.sectname);
	print_obj_name(object_file);
	print("(%s)\n", string);
	for(i = 0; i < nload_order; i++){
	    print("entry[%lu]\n", i);
	    print("           name %s\n", load_order[i].name == NULL ? "null" :
		  load_order[i].name);
	    print("          value 0x%08x\n",(unsigned int)load_order[i].value);
	    print("          order %lu\n", load_order[i].order);
	    print("   input_offset %lu\n", load_order[i].input_offset);
	    print("     input_size %lu\n", load_order[i].input_size);
	    print("  output_offset %lu\n", load_order[i].output_offset);
	}
}

/*
 * print_name_arrays() prints the sorted arrays of archive and object names.
 * For debugging.
 */
__private_extern__
void
print_name_arrays(void)
{
    unsigned long i, j;

	print("Sorted archive names:\n");
	for(i = 0; i < narchive_names; i++){
	    print("    archive name %s\n", archive_names[i].archive_name);
	    print("    number of objects %lu\n",archive_names[i].nobject_names);
	    print("    Sorted object names:\n");
	    for(j = 0; j < archive_names[i].nobject_names; j++){
		print("\tobject name %s\n",
		      archive_names[i].object_names[j].object_name);
		print("\tlength %lu\n",
		      archive_names[i].object_names[j].index_length);
		print("\tobject file 0x%x ", (unsigned int)
		      (archive_names[i].object_names[j].object_file));
		print_obj_name(archive_names[i].object_names[j].object_file);
		print("\n");
	    }
	}
	print("Sorted object names:\n");
	for(j = 0; j < nobject_names; j++){
	    print("\tobject name %s\n", object_names[j].object_name);
	    print("\tindex %lu\n", object_names[j].index_length);
	    print("\tobject file 0x%x ",
		  (unsigned int)(object_names[j].object_file));
	    print_obj_name(object_names[j].object_file);
	    print("\n");
	}
}

static
void
print_load_symbol_hash_table(void)
{
    unsigned long i;
    struct load_symbol *load_symbol, *other_name;

	print("load_symbol_hash_table:\n");
	if(load_symbol_hashtable == NULL)
	    return;
	for(i = 0; i < LOAD_SYMBOL_HASHTABLE_SIZE; i++){
	    if(load_symbol_hashtable[i] != NULL)
		print("[%lu]\n", i);
	    for(load_symbol = load_symbol_hashtable[i]; 
	        load_symbol != NULL;
	        load_symbol = load_symbol->next){
		print("load symbol: %lu\n", i);
		if(load_symbol->archive_name != NULL){
		    print("    (%s:%s:%s) length %lu\n",
			  load_symbol->archive_name,
			  load_symbol->object_name,
			  load_symbol->symbol_name,
			  load_symbol->index_length);
		}
		else{
		    print("    (%s:%s) index %lu\n",
			  load_symbol->object_name,
			  load_symbol->symbol_name,
			  load_symbol->index_length);
		}
		print("    load_order 0x%x\n",
		      (unsigned int)(load_symbol->load_order));
		print("    other_names 0x%x\n",
		      (unsigned int)(load_symbol->other_names));
		print("    next 0x%x\n",
		      (unsigned int)(load_symbol->next));
		for(other_name = load_symbol->other_names;
		    other_name != NULL;
		    other_name = other_name->other_names){
		    print("other name\n");
		    if(other_name->archive_name != NULL){
			print("    (%s:%s:%s) length %lu\n",
			      other_name->archive_name,
			      other_name->object_name,
			      other_name->symbol_name,
			      other_name->index_length);
		    }
		    else{
			print("    (%s:%s) index %lu\n",
			      other_name->object_name,
			      other_name->symbol_name,
			      other_name->index_length);
		    }
		    print("    load_order 0x%x\n",
			  (unsigned int)(other_name->load_order));
		    print("    other_names 0x%x\n",
			  (unsigned int)(other_name->other_names));
		    print("    next 0x%x\n",
			  (unsigned int)(load_symbol->next));
		}
	    }
	}
}
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/sections.h                               0100644 0001750 0001750 00000023612 12612724205 023042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file sections.c.
 *
 * The following include file need to be included before this file:
 * #include <sys/loader.h> 
 * #include "ld.h"
 * #include "objects.h"
 */

/*
 * The fields of the segment command in a merged segment are set and
 * maintained as follows:
 *	cmd		set in layout_segments() (layout)
 *	cmdsize		set in layout_segments() (layout)
 *	segname		set when the merged segment is created (pass1)
 *	vmaddr		set in process_segments() or layout_segments() (layout)
 *	vmsize		set in layout_segments() (layout)
 *	fileoff		set in layout_segments() (layout)
 *	filesize	set in layout_segments() (layout)
 *	maxprot		set in process_segments() or layout_segments() (layout)
 *	initprot	set in process_segments() or layout_segments() (layout)
 *	nsects		incremented as each section is merged (pass1)
 *	flags		set to 0 in process_segments and SG_NORELOC
 *			 conditionally or'ed in in pass2() (pass2)
 */
struct merged_segment {
    struct segment_command sg;	/* The output file's segment structure. */
    struct merged_section	/* The list of section that contain contents */
	*content_sections;	/*  that is non-zerofill sections. */
    struct merged_section	/* The list of zerofill sections. */
	*zerofill_sections;
    char *filename;		/* File this segment is in, the output file */
				/*  or a fixed VM shared library */
    enum bool addr_set;		/* TRUE when address of this segment is set */
    enum bool prot_set;		/* TRUE when protection of this segment is set*/
    enum bool split_dylib;	/* TRUE when this segment is from a dylib */
				/*  which is MH_SPLIT_SEGS */
    enum bool debug_only;	/* TRUE if segment contains sections with the */
				/*  S_ATTR_DEBUG attribute */
#ifdef RLD
    long set_num;		/* Object set this segment first appears in. */
#endif /* RLD */
    struct merged_segment *next;/* The next segment in the list. */
};

/*
 * The fields of the section structure in a merged section are set and
 * maintained as follows:
 *	sectname	set when the merged segment is created (pass1)
 *	segname		set when the merged segment is created (pass1)
 *	addr		set in layout_segments (layout)
 *	size		accumulated to the total size (pass1)
 *	offset		set in layout_segments (layout)
 *	align		merged to the maximum alignment (pass1)
 *	reloff		set in layout_segments (layout)
 *	nreloc		accumulated to the total count (pass1)
 *	flags		set when the merged segment is created (pass1)
 *	reserved1	zeroed when created in merged_section (pass1)
 *	reserved2	zeroed when created in merged_section (pass1)
 */
struct merged_section {
    struct section s;		/* The output file's section structure. */
    unsigned long output_sectnum;/* Section number in the output file. */
    unsigned long output_nrelocs;/* The current number of relocation entries */
				/*  written to the output file in pass2 for */
				/*  this section */
    /* These two fields are used to help set the SG_NORELOC flag */
    enum bool relocated;	/* This section was relocated */
    enum bool referenced;	/* This section was referenced by a relocation*/
				/*  entry (local or through a symbol). */
    /* The literal_* fields are used only if this section is a literal section*/
    void (*literal_merge)();	/* The routine to merge the literals. */
    void (*literal_output)();	/* The routine to write the literals. */
    void (*literal_free)();	/* The routine to free the literals. */
    void (*literal_order)();	/* The routine to order the literals. */
    void (*literal_reset_live)(); /* The routine to reset literal data before
				     only the live literals are re-merged */
    void *literal_data;		/* A pointer to a block of data to help merge */
				/*  and hold the literals. */
    /* These three fields are used only if this section is created from a file*/
    char *contents_filename;	/* File name for the contents of the section */
				/*  if it is created from a file, else NULL */
    char *file_addr;		/* address the above file is mapped at */
    unsigned long file_size;	/* size of above file as returned by stat(2) */

    /* These three fields are used only if this section has a -sectorder file */
    char *order_filename;	/* File name that contains the order that */
				/*  symbols are to loaded in this section */
    char *order_addr;		/* address the above file is mapped at */
    unsigned long order_size;	/* size of above file as returned by stat(2) */
    struct order_load_map	/* the load map for printing with -M */
	*order_load_maps;
    unsigned long
	norder_load_maps;	/* size of the above map */
#ifdef RLD
    long set_num;		/* Object set this section first appears in. */
#endif /* RLD */
    /* These four are used for output_for_dyld only if this is a non-regular
       section that will have relocation entries */
    unsigned long iextrel;	/* index into output external reloc entries */
    unsigned long nextrel;	/* number of output external reloc entries */
    unsigned long ilocrel;	/* index into output local reloc entries */
    unsigned long nlocrel;	/* number of output local reloc entries */
    struct merged_section *next;/* The next section in the list. */
};

/*
 * This is the load map (-M) for sections that have had their sections orders
 * with -sectorder option.
 */
struct order_load_map {
    char *archive_name;		/* archive name */
    char *object_name;		/* object name */
    char *symbol_name;		/* symbol name */
    unsigned long value;	/* symbol's value */
    struct section_map
	*section_map;		/* section map to relocate symbol's value */
    unsigned long size;		/* size of symbol in the input file */
    unsigned long order;	/* order the symbol appears in the section */
    struct load_order *load_order; /* the load_order for this map entry */
};

/* the pointer to the head of the output file's section list */
__private_extern__ struct merged_segment *merged_segments;
#ifdef RLD
__private_extern__ struct merged_segment *original_merged_segments;
#endif /* RLD */

/* the total number relocation entries */
__private_extern__ unsigned long nreloc;

/*
 * This is set to TRUE if any of the input objects do not have the
 * MH_SUBSECTIONS_VIA_SYMBOLS bit set in the mach_header flags field.
 */
__private_extern__ enum bool some_non_subsection_via_symbols_objects;

__private_extern__ void merge_sections(
    void);
__private_extern__ void remove_debug_segments(
    void);
__private_extern__ void merge_literal_sections(
    enum bool redo_live);
__private_extern__ void layout_ordered_sections(
    void);
__private_extern__ enum bool is_literal_output_offset_live(
    struct merged_section *ms,
    unsigned long output_offset);
__private_extern__ void parse_order_line(
    char *line,
    char **archive_name,
    char **object_name,
    char **symbol_name,
    struct merged_section *ms,
    unsigned long line_number);
__private_extern__ void resize_live_sections(
    void);
__private_extern__ void relayout_relocs(
    void);
__private_extern__ void output_literal_sections(
    void);
__private_extern__ void output_sections_from_files(
    void);
__private_extern__ void output_section(
    struct section_map *map);
__private_extern__ unsigned long pass2_nsect_merged_symbol_section_type(
    struct merged_symbol *merged_symbol);
__private_extern__ void nop_pure_instruction_scattered_sections(
    void);
__private_extern__ void flush_scatter_copied_sections(
    void);
__private_extern__ void live_marking(
    void);
__private_extern__ struct fine_reloc *get_fine_reloc_for_merged_symbol(
    struct merged_symbol *merged_symbol,
    struct section_map **local_map);
__private_extern__ unsigned long r_symbolnum_from_r_value(
    unsigned long r_value,
    struct object_file *obj);
__private_extern__ struct merged_section *create_merged_section(
    struct section *s);
__private_extern__ struct merged_segment *lookup_merged_segment(
    char *segname);
__private_extern__ struct merged_section *lookup_merged_section(
    char *segname,
    char *sectname);
__private_extern__ enum bool is_merged_symbol_coalesced(
    struct merged_symbol *merged_symbol);
__private_extern__ int qsort_load_order_values(
    const struct load_order *load_order1,
    const struct load_order *load_order2);
__private_extern__ unsigned long align_to_input_mod(
    unsigned long output_offset,
    unsigned long input_offset,
    unsigned long align);
#ifdef RLD
__private_extern__ void reset_merged_sections(
    void);
__private_extern__ void zero_merged_sections_sizes(
    void);
__private_extern__ void remove_merged_sections(
    void);
#endif /* RLD */

#ifdef DEBUG
__private_extern__ void print_merged_sections(
    char *string);
__private_extern__ void print_merged_section_stats(
    void);
__private_extern__ void print_name_arrays(
    void);
__private_extern__ void print_load_order(
    struct load_order *load_order,
    unsigned long nload_order,
    struct merged_section *ms,
    struct object_file *object_file,
    char *string);
#endif /* DEBUG */
                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/sets.c                                   0100644 0001750 0001750 00000013676 12612724205 022175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#undef CATS_BUG_FIX1
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to manage the structures that hold the
 * information for the rld package of the object file sets.
 */
#ifdef RLD
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#include <mach/vm_map.h>
#include <mach/mach.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include "stuff/openstep_mach.h"
#include <mach-o/loader.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sets.h"
/*
 * The ammount to increase the sets array when needed.
 */
#define NSETS_INCREMENT 10

/*
 * A pointer to the array of sets
 */
__private_extern__ struct set *sets = NULL;
/*
 * The number of set structures allocated in the above array.
 */
static long nsets = 0;
/*
 * The index into the sets array for the current set.
 */
__private_extern__ long cur_set = -1;

/*
 * new_set() allocates another structure for a new set in the sets array and
 * increments the cur_set to index into the sets array for the new set.
 */
__private_extern__
void
new_set(void)
{
    long i;

	if(cur_set + 2 > nsets){
	    sets = reallocate(sets,
			      (nsets + NSETS_INCREMENT) * sizeof(struct set));
	    for(i = 0; i < NSETS_INCREMENT; i++){
		memset(sets + nsets + i, '\0', sizeof(struct set));
		sets[nsets + i].link_edit_common_object =
			allocate(sizeof(struct object_file));
		memset(sets[nsets + i].link_edit_common_object, '\0',
			sizeof(struct object_file));
		sets[nsets + i].link_edit_section_maps =
			allocate(sizeof(struct section_map));
		memset(sets[nsets + i].link_edit_section_maps, '\0',
			sizeof(struct section_map));
		sets[nsets + i].link_edit_common_section =
			allocate(sizeof(struct section));
		memset(sets[nsets + i].link_edit_common_section, '\0',
		       sizeof(struct section));
	    }
	    nsets += NSETS_INCREMENT;
	}
	cur_set++;
}

/*
 * new_archive_or_fat() is called from pass1() for rld_load and keeps track of
 * the archives and fat files that are mapped so clean_archives_and_fats() can
 * deallocate their memory.
 */
__private_extern__
void
new_archive_or_fat(
char *file_name,
char *file_addr,
unsigned long file_size)
{
	sets[cur_set].archives = reallocate(sets[cur_set].archives,
					    (sets[cur_set].narchives + 1) *
					    sizeof(struct archive));

	sets[cur_set].archives[sets[cur_set].narchives].file_name =
						allocate(strlen(file_name) + 1);
	strcpy(sets[cur_set].archives[sets[cur_set].narchives].file_name,
	       file_name);
	sets[cur_set].archives[sets[cur_set].narchives].file_addr = file_addr;
	sets[cur_set].archives[sets[cur_set].narchives].file_size = file_size;
	sets[cur_set].narchives++;
}

/*
 * clean_archives_and_fats() deallocates any archives and fat files that were
 * loaded in the current set.
 */
__private_extern__
void
clean_archives_and_fats(void)
{
#ifndef SA_RLD
    unsigned long i;
    kern_return_t r;
    char *file_addr, *file_name;
    long file_size;

	if(sets != NULL && cur_set != -1){
	    for(i = 0; i < sets[cur_set].narchives; i++){
		file_addr = sets[cur_set].archives[i].file_addr;
		file_size = sets[cur_set].archives[i].file_size;
		file_name = sets[cur_set].archives[i].file_name;
		if((r = vm_deallocate(mach_task_self(), (vm_address_t)file_addr,
				      file_size)) != KERN_SUCCESS)
		    mach_fatal(r, "can't vm_deallocate() memory for "
			       "mapped file %s", file_name);
#ifdef RLD_VM_ALLOC_DEBUG
		    print("rld() vm_deallocate: addr = 0x%0x size = 0x%x\n",
			  (unsigned int)file_addr,
			  (unsigned int)file_size);
#endif /* RLD_VM_ALLOC_DEBUG */
		free(file_name);
	    }
	    if(sets[cur_set].archives != NULL)
		free(sets[cur_set].archives);
	    sets[cur_set].archives = NULL;
	    sets[cur_set].narchives = 0;
	}
#endif /* !defined(SA_RLD) */
}

/*
 * remove_set deallocates the current set structure from the sets array.
 */
__private_extern__
void
remove_set(void)
{
	if(cur_set >= 0){
	    sets[cur_set].output_addr = NULL;
	    sets[cur_set].output_size = 0;
	    memset(sets[cur_set].link_edit_common_object, '\0',
		    sizeof(struct object_file));
	    memset(sets[cur_set].link_edit_section_maps, '\0',
		    sizeof(struct section_map));
	    memset(sets[cur_set].link_edit_common_section, '\0',
		   sizeof(struct section));
	    cur_set--;
	}
}

/*
 * free_sets frees all storage for the sets and resets everything back to the
 * initial state.
 */
__private_extern__
void
free_sets(void)
{
    long i;

	if(sets != NULL){
	    for(i = 0; i < nsets; i++){
		if(sets[i].link_edit_common_object != NULL){
		    free(sets[i].link_edit_common_object);
		}
		if(sets[i].link_edit_section_maps != NULL){
		    free(sets[i].link_edit_section_maps);
		}
		if(sets[i].link_edit_common_section != NULL){
		    free(sets[i].link_edit_common_section);
		}
	    }
	    free(sets);
	}

	sets = NULL;
	nsets = 0;
	cur_set = -1;
}
#endif /* RLD */
                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/sets.h                                   0100644 0001750 0001750 00000004676 12612724205 022202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#ifdef RLD
/*
 * The set structure that holds the information for a set of dynamicly loaded
 * object files.
 */
struct set {
    char *output_addr;		/* the output memory for this set */
    unsigned long output_size;	/* the size of the output memory for this set */
    struct object_file		/* the structures for the common symbols of */
       *link_edit_common_object;/*  this set that are allocated by rld() */
    struct section_map
       *link_edit_section_maps;
    struct section
       *link_edit_common_section;
    unsigned long narchives;	/* the number of archives loaded in this set */
    struct archive *archives;	/* addresses and sizes of where they are */
};
struct archive {
    char *file_name;		/* name of the archive that is mapped */
    char *file_addr;		/* address the archive is mapped at */
    unsigned long file_size;	/* size that is mapped */
};
/*
 * Pointer to the array of set structures.
 */
__private_extern__ struct set *sets;
/*
 * Index into the array of set structures for the current set.
 */
__private_extern__ long cur_set;

__private_extern__ void new_set(
    void);
__private_extern__ void new_archive_or_fat(
    char *file_name,
    char *file_addr,
    unsigned long file_size);
__private_extern__ void remove_set(
    void);
__private_extern__ void free_sets(
    void);
__private_extern__ void clean_archives_and_fats(
    void);

#endif /* RLD */
                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/sparc_reloc.c                            0100644 0001750 0001750 00000113444 12612724205 023505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to do relocation for SPARC processor architecture.
 */
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include <mach-o/reloc.h>
#include <mach-o/sparc/reloc.h>
#include <mach-o/nlist.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"

#include "ld.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "pass2.h"
#include "generic_reloc.h"
#include "sparc_reloc.h"
#include "indirect_sections.h"
#include "dylibs.h"

#define U_ABS(l) (((long)(l))<0 ? (unsigned long)(-(l)) : (l))

#undef DEBUG1

/*
 * sparc_reloc() relocates the contents of the specified section for the 
 * relocation entries using the section map from the current object (cur_obj).
 */
__private_extern__
void
sparc_reloc(
char *contents,
struct relocation_info *relocs,
struct section_map *section_map)
{
    unsigned long i, j, symbolnum, value, input_pc, output_pc;
    unsigned long instruction, immediate;
    struct nlist *nlists;
    char *strings;
    enum bool force_extern_reloc;
    struct undefined_map *undefined_map;
    struct merged_symbol *merged_symbol;
    struct section_map *local_map, *pair_local_map;
    struct relocation_info *reloc, *pair_reloc;
    struct scattered_relocation_info *sreloc, *spair_reloc;
    unsigned long r_address, r_symbolnum, r_pcrel, r_length, r_extern,
		  r_scattered, r_value, pair_r_symbolnum, pair_r_value;
    enum reloc_type_sparc r_type, pair_r_type;
    unsigned long other_half;
    unsigned long offset;

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler "warnings: ... may be used uninitialized in this
	 * function" can safely be ignored
	 */
	merged_symbol = NULL;
	local_map = NULL;
	instruction = 0;
	other_half = 0;
	immediate = 0;
	offset = 0;
	pair_r_symbolnum = 0;
	pair_r_value = 0;
	pair_local_map = NULL;
#endif /* defined(DEBUG) || defined(RLD) */

	for(i = 0; i < section_map->s->nreloc; i++){
	    force_extern_reloc = FALSE;
	    /*
	     * Break out the fields of the relocation entry and set pointer to
	     * the type of relocation entry it is (for updating later).
	     */
	    if((relocs[i].r_address & R_SCATTERED) != 0){
		sreloc = (struct scattered_relocation_info *)(relocs + i);
		reloc = NULL;
		r_scattered = 1;
		r_address = sreloc->r_address;
		r_pcrel = sreloc->r_pcrel;
		r_length = sreloc->r_length;
		r_value = sreloc->r_value;
		r_type = (enum reloc_type_sparc)sreloc->r_type;
		r_extern = 0;
		/*
		 * Since the r_value field is reserved in a SPARC_RELOC_PAIR
		 * type to report the correct error a check for a stray
		 * SPARC_RELOC_PAIR relocation types needs to be done before
		 * it is assumed that r_value is legal.  A SPARC_RELOC_PAIR
		 * follows SPARC_RELOC_{HI22,LO10,SECTDIFF, HI22_SECTDIFF,LO10_SECTDIFF} 
		 * relocation types and it is an error to see one otherwise.
		 */
		if(r_type == SPARC_RELOC_PAIR){
		    error_with_cur_obj("stray relocation SPARC_RELOC_PAIR entry "
			"(%lu) in section (%.16s,%.16s)", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		/* calculate the r_symbolnum (n_sect) from the r_value */
		r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(r_value >= cur_obj->section_maps[j].s->addr &&
		       r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			r_symbolnum = j + 1;
			break;
		    }
		}
		if(r_symbolnum == 0){
		    /*
		     * The edge case where the last address past then end of
		     * of the last section is referenced.
		     */
		    for(j = 0; j < cur_obj->nsection_maps; j++){
			if(r_value == cur_obj->section_maps[j].s->addr +
				      cur_obj->section_maps[j].s->size){
			    r_symbolnum = j + 1;
			    break;
			}
		    }
		    if(r_symbolnum == 0){
			error_with_cur_obj("r_value (0x%x) field of relocation "
			    "entry %lu in section (%.16s,%.16s) out of range",
			    (unsigned int)r_value, i, section_map->s->segname,
			    section_map->s->sectname);
			return;
		    }
		}
	    }
	    else{
		reloc = relocs + i;
		sreloc = NULL;
		r_scattered = 0;
		r_address = reloc->r_address;
		r_pcrel = reloc->r_pcrel;
		r_length = reloc->r_length;
		r_extern = reloc->r_extern;
		r_symbolnum = reloc->r_symbolnum;
		r_type = (enum reloc_type_sparc)reloc->r_type;
		r_value = 0;
	    }
	    /*
	     * SPARC_RELOC_PAIR relocation types only follows SPARC_RELOC_
	     * {HI22,LO10,SECTDIFFi,HI22_SECTDIFF,LO10_SECTDIFF}
	     * relocation types and it is an error to
	     * see one otherwise.
	     */
	    if(r_type == SPARC_RELOC_PAIR){
		error_with_cur_obj("stray relocation SPARC_RELOC_PAIR entry "
		    "(%lu) in section (%.16s,%.16s)", i,
		    section_map->s->segname, section_map->s->sectname);
		continue;
	    }
	    /*
	     * The r_address field is really an offset into the contents of the
	     * section and must reference something inside the section (Note
	     * that this is not the case for SPARC_RELOC_PAIR entries but this
	     * can't be one with the above checks).
	     */
	    if(r_address >= section_map->s->size){
		error_with_cur_obj("r_address (0x%x) field of relocation entry "
		    "%lu in section (%.16s,%.16s) out of range",
		    (unsigned int)r_address, i, section_map->s->segname,
		    section_map->s->sectname);
		return;
	    }
	    /*
	     * If this relocation type is to have a pair make sure it is there
	     * and then break out it's fields.
	     */
	    pair_r_type = (enum reloc_type_sparc)0;
	    pair_reloc = NULL;
	    spair_reloc = NULL;
	    if(r_type == SPARC_RELOC_HI22 || r_type == SPARC_RELOC_LO10) {
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc  = NULL;
			pair_r_type = (enum reloc_type_sparc)
				      spair_reloc->r_type;
			other_half  = spair_reloc->r_address;
		    }
		    else{
			pair_r_type = (enum reloc_type_sparc)
				      pair_reloc->r_type;
			other_half  = pair_reloc->r_address;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != SPARC_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"SPARC_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
	    }
	    else if(r_type == SPARC_RELOC_SECTDIFF ||
		    r_type == SPARC_RELOC_HI22_SECTDIFF ||
		    r_type == SPARC_RELOC_LO10_SECTDIFF){
		if(r_scattered != 1){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) r_type is SPARC_RELOC_SECTDIFF but "
			"relocation entry not scattered type", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		if(i + 1 < section_map->s->nreloc){
		    pair_reloc = relocs + i + 1;
		    if((pair_reloc->r_address & R_SCATTERED) != 0){
			spair_reloc = (struct scattered_relocation_info *)
				      pair_reloc;
			pair_reloc = NULL;
			pair_r_type = (enum reloc_type_sparc)
				      spair_reloc->r_type;
			pair_r_value = spair_reloc->r_value;
			other_half  = spair_reloc->r_address;
		    }
		    else{
			error_with_cur_obj("relocation entry (%lu) in section "
			    "(%.16s,%.16s) following associated relocation "
			    "entry not scattered type", i,
			    section_map->s->segname, section_map->s->sectname);
			continue;
		    }
		}
		if((pair_reloc == NULL && spair_reloc == NULL) ||
		   pair_r_type != SPARC_RELOC_PAIR){
		    error_with_cur_obj("relocation entry (%lu) in section "
			"(%.16s,%.16s) missing following associated "
			"SPARC_RELOC_PAIR entry", i, section_map->s->segname,
			section_map->s->sectname);
		    continue;
		}
		/*
		 * Calculate the pair_r_symbolnum (n_sect) from the
		 * pair_r_value.
		 */
		pair_r_symbolnum = 0;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(pair_r_value >= cur_obj->section_maps[j].s->addr &&
		       pair_r_value < cur_obj->section_maps[j].s->addr +
				 cur_obj->section_maps[j].s->size){
			pair_r_symbolnum = j + 1;
			break;
		    }
		}
		if(pair_r_symbolnum == 0){
		    error_with_cur_obj("r_value (0x%x) field of relocation "
			"entry %lu in section (%.16s,%.16s) out of range",
			(unsigned int)r_value, i + 1, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * If r_extern is set this relocation entry is an external entry
	     * else it is a local entry (or scattered entry).
	     */
	    input_pc = section_map->s->addr + r_address;

	    if(r_extern){
		/*
		 * This is an external relocation entry.  So the value to be
		 * added to the item to be relocated is the value of the symbol.
		 * r_symbolnum is an index into the input file's symbol table
		 * of the symbol being refered to.  The symbol must be an
		 * undefined or coalesced symbol to be used in an external
		 * relocation entry.
		 */
		if(r_symbolnum >= cur_obj->symtab->nsyms){
		    error_with_cur_obj("r_symbolnum (%lu) field of external "
			"relocation entry %lu in section (%.16s,%.16s) out of "
			"range", r_symbolnum, i, section_map->s->segname,
			section_map->s->sectname);
		    return;
		}
		symbolnum = r_symbolnum;
		undefined_map = bsearch(&symbolnum, cur_obj->undefined_maps,
		    cur_obj->nundefineds, sizeof(struct undefined_map),
		    (int (*)(const void *, const void *))undef_bsearch);
		if(undefined_map != NULL){
		    merged_symbol = undefined_map->merged_symbol;
		}
		else{
		    nlists = (struct nlist *)(cur_obj->obj_addr +
					      cur_obj->symtab->symoff);
		    strings = (char *)(cur_obj->obj_addr +
				       cur_obj->symtab->stroff);
		    if((nlists[symbolnum].n_type & N_EXT) != N_EXT){
			error_with_cur_obj("r_symbolnum (%lu) field of external"
			    " relocation entry %lu in section (%.16s,%.16s) "
			    "refers to a non-external symbol", symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    /*
		     * We must allow and create references to defined global
		     * coalesced symbols with external relocation entries so
		     * that the dynamic linker can relocate all references to
		     * the same symbol.
		     */
		    if((nlists[symbolnum].n_type & N_TYPE) == N_SECT &&
		       (cur_obj->section_maps[nlists[symbolnum].n_sect-1].
			s->flags & SECTION_TYPE) == S_COALESCED){
			merged_symbol = lookup_symbol(strings +
					     nlists[symbolnum].n_un.n_strx);
			if(merged_symbol->name_len == 0){
			    fatal("internal error, in sparc_reloc() failed to "
			          "lookup coalesced symbol %s", strings +
				  nlists[symbolnum].n_un.n_strx);
			}
		    }
		    else{
			if((nlists[symbolnum].n_type & N_EXT) != N_EXT ||
			   (nlists[symbolnum].n_type & N_TYPE) != N_UNDF){
			    error_with_cur_obj("r_symbolnum (%lu) field of "
				"external relocation entry %lu in section "
				"(%.16s,%.16s) refers to a non-undefined "
				"symbol", symbolnum, i, section_map->s->segname,
				 section_map->s->sectname);
			    return;
			}
			print_obj_name(cur_obj);
			fatal("internal error, in sparc_reloc() symbol index "
			    "%lu in above file not in undefined map",symbolnum);
		    }
		}
		if((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		   (get_output_section(merged_symbol->nlist.n_sect)->
		    flags & SECTION_TYPE) == S_COALESCED){
		    if(((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
			keep_private_externs == FALSE) ||
		       dynamic == FALSE ||
		       (output_for_dyld && has_dynamic_linker_command))
			force_extern_reloc = FALSE;
		    else
			force_extern_reloc = TRUE;
		}
		/*
		 * If this is an indirect symbol resolve indirection (all chains
		 * of indirect symbols have been resolved so that they point at
		 * a symbol that is not an indirect symbol).
		 */
		if(merged_symbol->nlist.n_type == (N_EXT | N_INDR))
		    merged_symbol = (struct merged_symbol *)
				    merged_symbol->nlist.n_value;
		/*
		 * If the symbol is undefined (or common) or a global coalesced 
		 * symbol where we need to force an external relocation entry
		 * and we are not prebinding no relocation is done.  Or if the
		 * output file is a multi module MH_DYLIB no relocation is done
		 * unless the symbol is a private extern or we are prebinding.
		 */
		if(((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF) ||
		   (force_extern_reloc == TRUE && prebinding == FALSE) ||
		   ((filetype == MH_DYLIB && multi_module_dylib == TRUE) &&
		    (((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT) &&
		     prebinding == FALSE) ) )
		    value = 0;
		else{
		    value = merged_symbol->nlist.n_value;
		    /*
		     * To know which type (local or scattered) of relocation
		     * entry to convert this one to (if relocation entries are
		     * saved) the offset to be added to the symbol's value is
		     * needed to see if it reaches outside the block in which
		     * the symbol is in.  In here if the offset is not zero then
		     * it is assumed to reach out of the block and a scattered
		     * relocation entry is used.
		     */
		    if(r_type == SPARC_RELOC_VANILLA){
			switch(r_length){
			case 0: /* byte */
			    offset = get_byte((char *)(contents + r_address));
			    break;
			case 1: /* word (2 byte) */
			    offset = get_short((short *)(contents + r_address));
			    break;
			case 2: /* long (4 byte) */
			    offset = get_long((long *)(contents + r_address));
			    break;
			default:
			    /* the error check is catched below */
			    break;
			}
			if(r_pcrel)
			    offset += input_pc;
		    }
		    else{
			instruction = get_long((long *)(contents + r_address));
			switch(r_type){
			case SPARC_RELOC_HI22:
			    offset = ((instruction & 0x3fffff) << 10) |
			      (other_half & 0x3ff);
			    break;
			case SPARC_RELOC_LO10:
			    offset = (instruction & 0x3ff) | 
			      ((other_half & 0x3fffff) << 10);
			    break;
			case SPARC_RELOC_WDISP22:
			    offset = (instruction & 0x3fffff);
			    /* sign extend offset */
			    if ((offset & 0x200000) != 0)
			      offset |= 0xffc00000;
			    offset <<= 2; /* offset is long boundary */
			    offset += input_pc;
			    break;
			case SPARC_RELOC_WDISP30:
			    offset = (instruction & 0x3fffffff);
			    offset <<= 2; /* offset is on a long boundary */
			    offset += input_pc;
			    break;
			default:
			    /* the error check is caught below */
			    break;
			}
		    }
		}

		if(merged_symbol->nlist.n_type == (N_EXT | N_SECT))
		    output_sections[merged_symbol->nlist.n_sect]->referenced =
									   TRUE;
	    }
	    else{
		/*
		 * This is a local relocation entry (the value to which the item
		 * to be relocated is refering to is defined in section number
		 * r_symbolnum).  So the address of that section in the input
		 * file is subtracted and the value of that section in the
		 * output is added to the item being relocated.
		 */
		value = 0;
		/*
		 * If the symbol is not in any section the value to be added to
		 * the item to be relocated is the zero above and any pc
		 * relative change in value added below.
		 */
		if(r_symbolnum != R_ABS){
		    if(r_symbolnum > cur_obj->nsection_maps){
			error_with_cur_obj("r_symbolnum (%lu) field of local "
			    "relocation entry %lu in section (%.16s,%.16s) "
			    "out of range", r_symbolnum, i,
			    section_map->s->segname, section_map->s->sectname);
			return;
		    }
		    local_map = &(cur_obj->section_maps[r_symbolnum - 1]);
		    local_map->output_section->referenced = TRUE;
		    if(local_map->s->flags & S_ATTR_DEBUG){
			error_with_cur_obj("illegal reference to debug section,"
			    " from non-debug section (%.16s,%.16s) via "
			    "relocation entry (%lu) to section (%.16s,%.16s)",
			    section_map->s->segname, section_map->s->sectname,
			    i, local_map->s->segname, local_map->s->sectname);
			return;
		    }
		    pair_local_map = NULL;

		    if(r_type == SPARC_RELOC_SECTDIFF ||
		       r_type == SPARC_RELOC_HI22_SECTDIFF ||
		       r_type == SPARC_RELOC_LO10_SECTDIFF){
			pair_local_map =
			    &(cur_obj->section_maps[pair_r_symbolnum - 1]);
			pair_local_map->output_section->referenced = TRUE;
			if(pair_local_map->s->flags & S_ATTR_DEBUG){
			    error_with_cur_obj("illegal reference to debug "
				"section, from non-debug section (%.16s,%.16s) "
				"via relocation entry (%lu) to section (%.16s,"
				"%.16s)", section_map->s->segname,
				section_map->s->sectname, i,
				pair_local_map->s->segname,
				pair_local_map->s->sectname);
			    return;
			}
		    }
		    if(local_map->nfine_relocs == 0 && 
		       (pair_local_map == NULL ||
			pair_local_map->nfine_relocs == 0) ){
			if(r_type == SPARC_RELOC_SECTDIFF ||
			   r_type == SPARC_RELOC_HI22_SECTDIFF ||
			   r_type == SPARC_RELOC_LO10_SECTDIFF){
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset)
				    + pair_local_map->s->addr
				    - (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			}
			else{
			    value = - local_map->s->addr
				    + (local_map->output_section->s.addr +
				       local_map->offset);
			}
		    }
		    else{
			/*
			 * For items to be relocated that refer to a section
			 * with fine relocation the value is set (not adjusted
			 * with addition).  So the new value is directly
			 * calculated from the old value.
			 */
			if(r_pcrel) {
			    if(section_map->nfine_relocs == 0)
				output_pc = section_map->output_section->s.addr
					    + section_map->offset +
					    r_address;
			    else
			      output_pc = section_map->output_section->s.addr + 
				fine_reloc_output_offset(section_map, r_address);
			}
			else{
			    input_pc = 0;
			    output_pc = 0;
			}
			/*
			 * Get the value of the expresion of the item to be
			 * relocated.
			 */
			if(r_type == SPARC_RELOC_VANILLA ||
			   r_type == SPARC_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				value = get_byte((char *)(contents +
							  r_address));
				break;
			    case 1: /* word (2 byte) */
				value = get_short((short *)(contents +
							    r_address));
				break;
			    case 2: /* long (4 byte) */
				value = get_long((long *)(contents +
							  r_address));
				break;
			    default:
				/* the error check is catched below */
				break;
			    }
			}
			else{
			    instruction = get_long((long *)(contents +
							    r_address));
			    switch(r_type){
			    case SPARC_RELOC_HI22:
			    case SPARC_RELOC_HI22_SECTDIFF:
				value = ((instruction & 0x3fffff) << 10) | 
				  (other_half & 0x3ff) ;
				break;
			    case SPARC_RELOC_LO10:
			    case SPARC_RELOC_LO10_SECTDIFF:
				value = (instruction & 0x3ff) | 
				  ((other_half & 0x3fffff) << 10);
				break;
			    case SPARC_RELOC_WDISP22:
				value = (instruction & 0x3fffff);
				if ((value & 0x200000) != 0)
				  value |= 0xffc00000;
				value <<= 2;
				break;
			    case SPARC_RELOC_WDISP30:
				value = (instruction & 0x3fffffff);
				value <<= 2;
				break;
			    default:
				/* the error check is caught below */
				break;
			    }
			}
			if(r_type == SPARC_RELOC_SECTDIFF ||
			   r_type == SPARC_RELOC_HI22_SECTDIFF ||
			   r_type == SPARC_RELOC_LO10_SECTDIFF){
			    /*
			     * For SPARC_RELOC_SECTDIFF's the item to be
			     * relocated, in value, is the value of the
			     * expression:
			     *     r_value - pair_r_value + offset
			     * To set the value of the relocated expression,
			     * it is set from relocating the two r_value's and
			     * adding back in the offset.  So here get the
			     * offset from the value of the expression.
			     */
			    value += input_pc; /* adjust for pcrel */
			    offset = value - r_value + pair_r_value;

			    /*
			     * Now build up the value of the relocated
			     * expression one part at a time.  First set the
			     * new value to the relocated r_value.
			     */
		    	    if(local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    local_map, r_value - local_map->s->addr +
				    offset, i, TRUE);
				value = fine_reloc_output_address(local_map,
					    r_value - local_map->s->addr,
					    local_map->output_section->s.addr);
			    }
			    else{
				value = local_map->output_section->s.addr +
					local_map->offset +
					r_value - local_map->s->addr;
			    }
			    /* Second subtract the relocated pair_r_value. */
			    if(pair_local_map->nfine_relocs != 0){
				/*
				 * Check to see if this reference is legal with
				 * respect to indirect sections.
				 */
				legal_reference(section_map, r_address,
				    pair_local_map, pair_r_value -
				    pair_local_map->s->addr, i, TRUE);
				value -=
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
				        pair_local_map->output_section->s.addr);
			    }
			    else{
				value -=
				    pair_local_map->output_section->s.addr +
				    pair_local_map->offset +
				    pair_r_value - pair_local_map->s->addr;
			    }
			    /* Third add in the offset. */
			    value += offset;
			    value -= output_pc; /* adjust for pcrel */
			}
			else{
			    /*
			     * If the relocation entry is not a scattered
			     * relocation entry then the relocation is based on
			     * the value of value of the expresion of the item
			     * to be relocated.  If it is a scattered relocation
			     * entry then the relocation is based on the r_value
			     * in the relocation entry and the offset part of
			     * the expression at the item to be relocated is
			     * extracted so it can be added after the relocation
			     * is done.
			     */
			    value += input_pc;
			    if(r_scattered == 0){
				r_value = value;
				offset = 0;
			    }
			    else{
				offset = value - r_value;
			    }
			    /*
			     * Check to see if this reference is legal with
			     * respect to indirect sections.
			     */
			    legal_reference(section_map, r_address, local_map,
				    r_value - local_map->s->addr + offset, i,
				    FALSE);
			    value = fine_reloc_output_address(local_map,
					r_value - local_map->s->addr,
					local_map->output_section->s.addr);
			    value -= output_pc;
			    value += offset;
			}
			if(r_type == SPARC_RELOC_VANILLA ||
			   r_type == SPARC_RELOC_SECTDIFF){
			    switch(r_length){
			    case 0: /* byte */
				if( (value & 0xffffff00) &&
				   ((value & 0xffffff80) != 0xffffff80))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 1 byte", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_byte((char *)(contents + r_address), value);
				break;
			    case 1: /* word (2 byte) */
				if( (value & 0xffff0000) &&
				   ((value & 0xffff8000) != 0xffff8000))
				    error_with_cur_obj("relocation for entry "
					"%lu in section (%.16s,%.16s) does not "
					"fit in 2 bytes", i,
					section_map->s->segname,
					section_map->s->sectname);
				set_short((short *)(contents + r_address),
					  value);
				break;
			    case 2: /* long (4 byte) */
				set_long((long *)(contents + r_address), value);
				break;
			    default:
				error_with_cur_obj("r_length field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			}
			else{
			    switch(r_type){
			    case SPARC_RELOC_HI22:
			    case SPARC_RELOC_HI22_SECTDIFF:
				other_half = value & 0x3ff;
				instruction = (instruction & 0xffc00000) |
					      ((value >> 10) & 0x3fffff);
				break;
			    case SPARC_RELOC_LO10:
			    case SPARC_RELOC_LO10_SECTDIFF:
				other_half = (value >> 10) & 0x3fffff;
				instruction = (instruction & 0xfffffc00) |
					      (value & 0x3ff);
				break;
			      case SPARC_RELOC_WDISP22:
				if ((value & 0xff800000) != 0xff800000 &&
				    (value & 0xff800000) != 0x00000000)
				    error_with_cur_obj("relocation overflow "
					"for relocation entry %lu in section "
					"(%.16s,%.16s) (displacement too large)"
					, i, section_map->s->segname,
					section_map->s->sectname);
				value >>= 2;
				instruction = (instruction & 0xffc00000) |
				  (value & 0x003fffff);
				break;
			      case SPARC_RELOC_WDISP30:
				value >>= 2;
				instruction = (instruction & 0xc0000000) |
				  (value & 0x3fffffff);
				break;
			    default:
				error_with_cur_obj("r_type field of "
				    "relocation entry %lu in section (%.16s,"
				    "%.16s) invalid", i,
				    section_map->s->segname,
				    section_map->s->sectname);
				return;
			    }
			    set_long((long *)(contents + r_address),
				     instruction);
			}

			goto update_reloc;
		    }
		}
	    }
	    if(r_pcrel){
		/*
		 * This is a relocation entry is also pc relative which means
		 * the value of the pc will get added to it when it is executed.
		 * The item being relocated has the value of the pc in the input
		 * file subtracted from it.  So to relocate this the value of
		 * pc in the input file is added and then value of the output
		 * pc is subtracted (since the offset into the section remains
		 * constant it is not added in and then subtracted out).
		 */
		if(section_map->nfine_relocs == 0)
		    value += + section_map->s->addr + /* r_address */
		             - (section_map->output_section->s.addr +
				section_map->offset /* + r_address */);
		else
		    value += + section_map->s->addr + r_address
			     - (section_map->output_section->s.addr +
			        fine_reloc_output_offset(section_map,
							 r_address));
	    }
	    if(r_type == SPARC_RELOC_VANILLA ||
	       r_type == SPARC_RELOC_SECTDIFF){
		switch(r_length){
		case 0: /* byte */
		    value += get_byte((char *)(contents + r_address));
		    if( (value & 0xffffff00) &&
		       ((value & 0xffffff80) != 0xffffff80))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 1 byte", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_byte((char *)(contents + r_address), value);
		    break;
		case 1: /* word (2 byte) */
		    value += get_short((short *)(contents + r_address));
		    if( (value & 0xffff0000) &&
		       ((value & 0xffff8000) != 0xffff8000))
			error_with_cur_obj("relocation for entry %lu in section"
			    " (%.16s,%.16s) does not fit in 2 bytes", i,
			    section_map->s->segname, section_map->s->sectname);
		    set_short((short *)(contents + r_address), value);
		    break;
		case 2: /* long (4 byte) */
		    value += get_long((long *)(contents + r_address));
		    set_long((long *)(contents + r_address), value);
		    break;
		default:
		    error_with_cur_obj("r_length field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    return;
		}
	    }
	    /*
	     * Do SPARC specific relocation based on the r_type.
	     */
	    else {
		instruction = get_long((long *)(contents + r_address));
		switch(r_type){
		case SPARC_RELOC_HI22_SECTDIFF:
		    immediate = ((instruction & 0x3fffff) << 10) | other_half;
		    immediate += value;
		    instruction = (instruction & 0xffc00000) |
				  ((immediate >> 10) & 0x3fffff);
		    other_half = immediate & 0x3ff;
		    break;

		case SPARC_RELOC_HI22:
		    immediate = ((instruction & 0x3fffff) << 10) | other_half;
		    immediate += value;
		    instruction = (instruction & 0xffc00000) |
				  ((immediate >> 10) & 0x3fffff);
		    other_half = immediate & 0x3ff;
		    break;
		case SPARC_RELOC_LO10:
		    immediate = (instruction & 0x3ff) | (other_half << 10);
		    immediate += value;
		    instruction = (instruction & 0xfffffc00) | 
					(immediate & 0x3ff);
		    other_half = (immediate >> 10) & 0x3fffff;
		    break;
		case SPARC_RELOC_LO10_SECTDIFF:
		    immediate = (instruction & 0x3ff) | (other_half << 10);
		    immediate += value;
		    instruction = (instruction & 0xfffffc00) |
				  (immediate & 0x3ff);
		    other_half = (immediate >> 10) & 0x3fffff;
		    break;
		  case SPARC_RELOC_WDISP22:
		    immediate = (instruction & 0x3fffff);
		    if ((immediate & 0x200000) != 0)
		      immediate |= 0xffc00000;
		    immediate <<= 2;
		    immediate += value;
		    if ((immediate & 0xff800000) != 0xff800000 &&
		      (immediate & 0xff800000) != 0x00)
			error_with_cur_obj("relocation overflow for relocation "
			    "entry %lu in section (%.16s,%.16s) (displacement "
			    "too large)", i, section_map->s->segname,
			    section_map->s->sectname);
		    immediate >>= 2;
		    instruction = (instruction & 0xffc00000) | 
					(immediate & 0x3fffff);
		    break;
		  case SPARC_RELOC_WDISP30:
		    immediate = (instruction & 0x3fffffff);
		    immediate <<= 2;
		    immediate += value;
		    immediate >>= 2;
		    instruction = (instruction & 0xc0000000) | 
					(immediate & 0x3fffffff);
		    break;
		default:
		    error_with_cur_obj("r_type field of relocation entry %lu "
			"in section (%.16s,%.16s) invalid", i,
			section_map->s->segname, section_map->s->sectname);
		    continue;
		}
		set_long((long *)(contents + r_address), instruction);
	    }

	    /*
	     * If relocation entries are to be saved in the output file then
	     * update the entry for the output file.
	     */
update_reloc:
	    ;
#ifndef RLD
	    if(save_reloc || output_for_dyld){
		if(r_extern){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a SPARC_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = SPARC_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For external relocation entries that the symbol is
		     * defined (not undefined or common) but not when we are
		     * forcing an external relocation entry for a global
		     * coalesced symbol and if the output file is not a multi
		     * module MH_DYLIB or the symbol is a private extern, it is
		     * changed to a local relocation entry using the section
		     * that symbol is defined in.  If still undefined or forcing
		     * an external relocation entry for a global coalesced
		     * symbol, then the index of the symbol in the output file
		     * is set into r_symbolnum.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		            (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		            force_extern_reloc == FALSE &&
		            ((filetype != MH_DYLIB ||
			      multi_module_dylib == FALSE) ||
			     (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT)){
			reloc->r_extern = 0;
			/*
			 * If this symbol was in the base file then no futher
			 * relocation can ever be done (the symbols in the base
			 * file are fixed). Or if the symbol was an absolute
			 * symbol.
			 */
			if(merged_symbol->definition_object == base_obj ||
			   (merged_symbol->nlist.n_type & N_TYPE) == N_ABS){
				reloc->r_symbolnum = R_ABS;
			}
			else{
			    /*
			     * The symbol that this relocation entry is refering
			     * to is defined so convert this external relocation
			     * entry into a local or scattered relocation entry.
			     * If the item to be relocated has an offset added
			     * to the symbol's value and the output is not for
			     * dyld make it a scattered relocation entry else
			     * make it a local relocation entry.
			     */
			    if(offset == 0 || output_for_dyld){
				reloc->r_symbolnum =merged_symbol->nlist.n_sect;
			    }
			    else{
				sreloc = (struct scattered_relocation_info *)
					 reloc;
				r_scattered = 1;
				sreloc->r_scattered = r_scattered;
				sreloc->r_address = r_address;
				sreloc->r_pcrel = r_pcrel;
				sreloc->r_length = r_length;
				sreloc->r_type = r_type;
				sreloc->r_value = merged_symbol->nlist.n_value;
			    }
			}
		    }
		    else{
			reloc->r_symbolnum =
				      merged_symbol_output_index(merged_symbol);
		    }
		}
		else if(r_scattered == 0){
		    /*
		     * If we are prebinding and this is a lazy pointer section
		     * change the relocation entry to a SPARC_RELOC_PB_LA_PTR
		     * type.  This stuffs the value of the lazy pointer as it
		     * wouldn't be prebound in the r_value field.  So if the
		     * prebounding can't be used at runtime the value of the
		     * lazy pointer will get set back to the r_value by dyld.
		     */
		    if(prebinding == TRUE &&
		       (section_map->s->flags & SECTION_TYPE) ==
			S_LAZY_SYMBOL_POINTERS){
			sreloc = (struct scattered_relocation_info *)reloc;
			r_scattered = 1;
			sreloc->r_scattered = r_scattered;
			sreloc->r_address = r_address;
			sreloc->r_pcrel = r_pcrel;
			sreloc->r_length = r_length;
			sreloc->r_type = SPARC_RELOC_PB_LA_PTR;
			sreloc->r_value = value;
		    }
		    /*
		     * For local relocation entries the section number is
		     * changed to the section number in the output file.
		     */
		    else if(reloc->r_symbolnum != R_ABS){
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		}
		else{
		    /*
		     * This is a scattered relocation entry.  If the output is
		     * for dyld convert it to a local relocation entry so as
		     * to not overflow the 24-bit r_address field in a scattered
		     * relocation entry.  The overflow would happen in
		     * reloc_output_for_dyld() in sections.c when it adjusts
		     * the r_address fields of the relocation entries.
		     */
		    if(output_for_dyld){
			reloc = (struct relocation_info *)sreloc;
			r_scattered = 0;
			reloc->r_address = r_address;
			reloc->r_pcrel = r_pcrel;
			reloc->r_extern = 0;
			reloc->r_length = r_length;
			reloc->r_type = r_type;
			if(local_map->nfine_relocs == 0){
			    reloc->r_symbolnum =
				      local_map->output_section->output_sectnum;
			}
			else{
			    reloc->r_symbolnum =
				fine_reloc_output_sectnum(local_map,
						r_value - local_map->s->addr);
			}
		    }
		    else{
			/*
			 * For scattered relocation entries the r_value field is
			 * relocated.
			 */
			if(local_map->nfine_relocs == 0)
			    sreloc->r_value +=
					   - local_map->s->addr
					   + local_map->output_section->s.addr +
					   local_map->offset;
			else
			    sreloc->r_value =
					fine_reloc_output_address(local_map,
						r_value - local_map->s->addr,
					   local_map->output_section->s.addr);
		    }
		}
		/*
		 * If this section that the reloation is being done for has fine
		 * relocation then the offset in the r_address field has to be
		 * set to where it will end up in the output file.  Otherwise
		 * it simply has to have the offset to where this contents
		 * appears in the output file. 
		 */
		if(r_scattered == 0){
		    if(section_map->nfine_relocs == 0){
			reloc->r_address += section_map->offset;
		    }
		    else{
			reloc->r_address = fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		else{
		    if(section_map->nfine_relocs == 0){
			sreloc->r_address += section_map->offset;
		    }
		    else{
			sreloc->r_address =fine_reloc_output_offset(section_map,
								    r_address);
		    }
		}
		/*
		 * If their was a paired relocation entry then update the
		 * paired relocation entry.
		 */
		if(pair_r_type == SPARC_RELOC_PAIR){
		    if(pair_reloc != NULL)
			pair_reloc->r_address = other_half;
		    else if(spair_reloc != NULL){
			if(r_type == SPARC_RELOC_SECTDIFF ||
			   r_type == SPARC_RELOC_HI22_SECTDIFF ||
			   r_type == SPARC_RELOC_LO10_SECTDIFF){
			    /*
			     * For SPARC_RELOC_SECTDIFF relocation entries (which
			     * are always scattered types) the r_value field is
			     * relocated.
			     */
			    if(pair_local_map->nfine_relocs == 0)
				spair_reloc->r_value +=
				    - pair_local_map->s->addr
				    + (pair_local_map->output_section->s.addr +
				       pair_local_map->offset);
			    else
				spair_reloc->r_value =
				    fine_reloc_output_address(pair_local_map,
					pair_r_value - pair_local_map->s->addr,
					pair_local_map->output_section->s.addr);
			    if(r_type == SPARC_RELOC_HI22_SECTDIFF ||
			       r_type == SPARC_RELOC_LO10_SECTDIFF)
				spair_reloc->r_address = other_half;
			}
			else{
			    spair_reloc->r_address = other_half;
			}
		    }
		    else{
			fatal("internal error, in sparc_reloc() pair_r_type "
			    "is SPARC_RELOC_PAIR but pair_reloc and spair_reloc "
			    "are NULL");
		    }
		}
	    }
#endif /* !defined(RLD) */
	    /*
	     * If their was a paired relocation entry then it has been processed
	     * so skip it by incrementing the index of the relocation entry that
	     * is being processed.
	     */
	    if(pair_r_type == SPARC_RELOC_PAIR)
		i++;
	}
}
                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/sparc_reloc.h                            0100644 0001750 0001750 00000002615 12612724205 023507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file sparc_reloc.c.
 *
 * The following include file need to be included before this file:
 * #include <reloc.h>
 * #include "section.h"
 */
__private_extern__ void sparc_reloc(
    char *contents,
    struct relocation_info *relocs,
    struct section_map *map);

                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/specs.c                                  0100644 0001750 0001750 00000036306 12612724205 022327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* SHLIB */
/*
 * This file contains the routines to manage the structures that hold the
 * command line specifications about segment and sections.
 */
#if !(defined(KLD) && defined(__STATIC__))
#include <stdlib.h>
#include <stdio.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <string.h>
#include <stdarg.h>
#include <mach-o/loader.h>
#include "stuff/arch.h"

#include "ld.h"
#ifndef RLD
#include "specs.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"

/* The structures to hold the information specified about segments */
__private_extern__ struct segment_spec *segment_specs = NULL;
__private_extern__ unsigned long nsegment_specs = 0;

/*
 * create_segment_spec() looks through the segment_specs and returns a pointer
 * to the segment_spec for the specified segment name.  If none exist then one
 * is created for this segname, the segname is set, it is initialized to zero
 * and a pointer to it is returned.
 */ 
__private_extern__
struct segment_spec *
create_segment_spec(
char *segname)
{
    unsigned long i;

	for(i = 0; i < nsegment_specs; i++){
	    if(strcmp(segment_specs[i].segname, segname) == 0)
		return(&(segment_specs[i]));
	}
	segment_specs = reallocate(segment_specs, (nsegment_specs + 1) *
						  sizeof(struct segment_spec));
	memset(&(segment_specs[nsegment_specs]), '\0',
	       sizeof(struct segment_spec));
	segment_specs[nsegment_specs].segname = segname;
	return(&(segment_specs[nsegment_specs++]));
}

/*
 * create_section_spec() looks through the section_specs for the specificed and
 * segment_spec and returns a pointer to the section_spec for the specified
 * section name.  If none exist then one is created for this sectname, the
 * sectname is set, it is initialized to zero and a pointer to it is returned.
 */ 
__private_extern__
struct section_spec *
create_section_spec(
struct segment_spec *seg_spec,
char *sectname)
{
    unsigned long i;

	for(i = 0; i < seg_spec->nsection_specs; i++){
	    if(strcmp(seg_spec->section_specs[i].sectname, sectname) == 0)
		return(&(seg_spec->section_specs[i]));
	}
	seg_spec->section_specs = reallocate(seg_spec->section_specs,
					     (seg_spec->nsection_specs + 1) *
					     sizeof(struct section_spec));
	memset(&(seg_spec->section_specs[seg_spec->nsection_specs]), '\0',
	       sizeof(struct section_spec));
	seg_spec->section_specs[seg_spec->nsection_specs].sectname = sectname;
	return(&(seg_spec->section_specs[seg_spec->nsection_specs++]));
}

/*
 * lookup_segment_spec() returns a pointer to the segment_spec for the specified
 * segment name.  NULL is returned if none exists.
 */
__private_extern__
struct segment_spec *
lookup_segment_spec(
char *segname)
{
    unsigned long i;

	for(i = 0; i < nsegment_specs; i++){
	    if(strcmp(segment_specs[i].segname, segname) == 0)
		return(&(segment_specs[i]));
	}
	return(NULL);
}

/*
 * lookup_section_spec() returns a pointer to the section_spec for the specified
 * section name (segname,sectname).  NULL is returned if none exists.
 */
__private_extern__
struct section_spec *
lookup_section_spec(
char *segname,
char *sectname)
{
    unsigned long i, j;

	for(i = 0; i < nsegment_specs; i++){
	    if(strcmp(segment_specs[i].segname, segname) == 0){
		for(j = 0; j < segment_specs[i].nsection_specs; j++){
		    if(strcmp(segment_specs[i].section_specs[j].sectname,
			      sectname) == 0)
			return(&(segment_specs[i].section_specs[j]));
		}
	    }
	}
	return(NULL);
}

/*
 * process_section_specs() folds in the information specified by command line
 * options into the merged section table (called by layout()).  Currently three
 * things can be specified for segments alignment, creation from a file, and a
 * layout order.  If there is an alignment specified for a section that does not
 * exist it is an error.  If the alignment specified is less than the merged
 * alignment a warning is issued.  If a section is to be created and it already
 * exist from the object files it is an error.  Section layout order can only be
 * specified for regular sections (non-zero fill, non-literal, not created from
 * a file, etc).
 */
__private_extern__
void
process_section_specs(void)
{
    unsigned long i, j, k;
    struct merged_section *ms;
    struct section_spec *sect_spec;
    struct section s = { {0} };

	/* check for long non-unique names in the specifications */
	for(i = 0; i < nsegment_specs; i++){
	    for(j = i + 1; j < nsegment_specs; j++){
		if(strncmp(segment_specs[i].segname, segment_specs[j].segname,
			   sizeof(s.segname)) == 0)
		    error("segment names: %s and %s not unique to %lu "
			  "characters\n", segment_specs[i].segname,
			  segment_specs[j].segname, sizeof(s.segname));
	    }
	    for(j = 0; j < segment_specs[i].nsection_specs; j++){
		for(k = j + 1; k < segment_specs[i].nsection_specs; k++){
		if(strncmp(segment_specs[i].section_specs[j].sectname,
			   segment_specs[i].section_specs[k].sectname,
			   sizeof(s.sectname)) == 0)
		    error("section names: %s and %s (in segment %s) not unique "
			  "to %lu characters\n",
			  segment_specs[i].section_specs[j].sectname,
			  segment_specs[i].section_specs[k].sectname,
			  segment_specs[i].segname, sizeof(s.segname));
		}
	    }
	}

	/* fold in the specifications about sections into the merged sections */
	for(i = 0; i < nsegment_specs; i++){
	    for(j = 0; j < segment_specs[i].nsection_specs; j++){
		/*
		 * The (__DATA,__common) section specification has already been
		 * processed if it it exists by define_common_symbols() and will
		 * be marked as processed so it doesn't have to be special cased
		 * here.
		 */
		if(segment_specs[i].section_specs[j].processed)
		    continue;
		/* lookup this section to see it there is a merged section */
		ms = lookup_merged_section(segment_specs[i].segname,
			  segment_specs[i].section_specs[j].sectname);
		sect_spec = &(segment_specs[i].section_specs[j]);
		if(ms == NULL){
		    /*
		     * There is no merged section so if this section is not to
		     * be created from a file issue a warning for it's
		     * specifications.
		     */
		    if(sect_spec->contents_filename == NULL){
			if(sect_spec->align_specified)
			    warning("no (%s,%s) section in output file, "
				    "specified alignment not used",
				    segment_specs[i].segname,
				    sect_spec->sectname);
			if(sect_spec->order_filename)
			    warning("no (%s,%s) section in output file, "
				    "-sectorder file: %s not used",
				    segment_specs[i].segname,
				    sect_spec->sectname,
				    sect_spec->order_filename);
		    }
		    else{
			if(sect_spec->order_filename)
			    warning("section (%s,%s) is to be created from "
				    "file: %s and is meaningless to have a "
				    "-sectorder file: %s for it",
				    segment_specs[i].segname,
				    sect_spec->sectname,
				    sect_spec->contents_filename,
				    sect_spec->order_filename);
			/*
			 * This section doesn't exist and is to be created from
			 * a file so create a merged section for it and apply
			 * all the specifications to it.
			 */
			strncpy(s.segname, segment_specs[i].segname,
				sizeof(s.segname));
			strncpy(s.sectname, sect_spec->sectname,
				sizeof(s.segname));
			ms = create_merged_section(&s);
			ms->contents_filename = sect_spec->contents_filename;
			ms->file_addr = sect_spec->file_addr;
			ms->file_size = sect_spec->file_size;
			if(sect_spec->align_specified)
			    ms->s.align = sect_spec->align;
			else
			    ms->s.align = defaultsectalign;
			ms->s.size = rnd(sect_spec->file_size,
					 1 << ms->s.align);
			/*
			 * Sections created from files don't have symbols and
			 * can't be referenced via a relocation entry.  So to
			 * avoid having their contents removed when -dead_strip
			 * is specified on later links we set this section
			 * attribute.
			 */
			ms->s.flags |= S_ATTR_NO_DEAD_STRIP;
		    }
		    sect_spec->processed = TRUE;
		    continue;
		}
		/*
		 * There is a merged section for this section specification
		 * so if this section is to be created from a file it is an
		 * error.
		 */
		if(sect_spec->contents_filename != NULL)
		    error("section (%.16s,%.16s) exist in the loaded object "
			  "files and can't be created from the file: %s",
			  ms->s.segname, ms->s.sectname,
			  sect_spec->contents_filename);
		else{
		    /* Increase the alignment to the specified alignment */
		    if(sect_spec->align_specified){
			if(ms->s.align > sect_spec->align)
			    warning("specified alignment (0x%x) for section (%s"
				    ",%s) not used (less than the required "
				    "alignment in the input files (0x%x))",
				    (unsigned int)(1 << sect_spec->align),
				    segment_specs[i].segname,
				    sect_spec->sectname,
				    (unsigned int)(1 << ms->s.align));
			else
			    ms->s.align = sect_spec->align;
		    }
		    if(sect_spec->order_filename != NULL){
			if(arch_flag.cputype == CPU_TYPE_I860)
			    warning("sections can't be ordered in I860 cputype "
				    "objects (-sectorder %s %s %s ignored)",
				    segment_specs[i].segname,
				    sect_spec->sectname,
				    sect_spec->order_filename);
			else if(filetype == MH_DYLIB &&
				strcmp(ms->s.segname, SEG_OBJC) == 0 &&
				strcmp(ms->s.sectname, SECT_OBJC_MODULES) == 0){
			    warning("for MH_DYLIB output files section ("
				SEG_OBJC "," SECT_OBJC_MODULES ") can't be "
				"ordered (-sectorder %s %s %s ignored)",
				segment_specs[i].segname, sect_spec->sectname,
				sect_spec->order_filename);
			}
			else if((ms->s.flags & S_ATTR_DEBUG) == S_ATTR_DEBUG){
			    warning("debug sections can't be ordered as they "
				    "won't appear in the output (-sectorder %s "
				    "%s %s ignored)", segment_specs[i].segname,
				    sect_spec->sectname,
				    sect_spec->order_filename);
			}
			else{
			    ms->order_filename = sect_spec->order_filename;
			    ms->order_addr = sect_spec->order_addr;
			    ms->order_size = sect_spec->order_size;
			}
		    }
		}
		sect_spec->processed = TRUE;
	    }
	}
}
/*
 * process_segment_specs() folds in the information specified by command line
 * options into the merged segment table (called by layout_segments()).  If
 * there is a specification for a segment that does not exist a warning is
 * issued.  If the address is not a multiple of the segment alignment it is an
 * error.
 */
__private_extern__
void
process_segment_specs(void)
{
    unsigned long i;
    struct merged_segment *msg;

	/* fold in the specifications about sections into the merged sections */
	for(i = 0; i < nsegment_specs; i++){
	    if(segment_specs[i].processed)
		continue;
	    /* lookup this segment to see it there is a merged segment */
	    msg = lookup_merged_segment(segment_specs[i].segname);
	    if(msg != NULL){
		if(segment_specs[i].addr_specified){
		    if(segment_specs[i].addr % segalign != 0){
			error("address: 0x%x specified for segment: %s not a "
			      "multiple of the segment alignment (0x%x)",
			      (unsigned int)(segment_specs[i].addr),
			      segment_specs[i].segname,
			      (unsigned int)(segalign));
		    }
		    else{
			msg->sg.vmaddr = segment_specs[i].addr;
			msg->addr_set = TRUE;
		    }
		}
		if(segment_specs[i].prot_specified){
		    msg->sg.maxprot = segment_specs[i].maxprot;
		    msg->sg.initprot = segment_specs[i].initprot;
		    msg->prot_set = TRUE;
		}
	    }
	    else{
		/*
		 * If the output format is MH_OBJECT just issue one warning
		 * and return if there are any specifications.
		 */
		if(filetype == MH_OBJECT &&
		   (segment_specs[i].addr_specified ||
		    segment_specs[i].prot_specified)){
		    warning("all named segment specifications ignored with "
			    "MH_OBJECT output file format");
		    return;
		}
		/*
		 * There is no merged segment so issue a warnings for it's
		 * specifications.
		 */
		if(segment_specs[i].addr_specified)
		    warning("segment: %s not in output file, specified address "
			    "not used", segment_specs[i].segname);
		if(segment_specs[i].prot_specified)
		    warning("segment: %s not in output file, specified "
			    "protection not used", segment_specs[i].segname);
	    }
	}
}
#endif /* !defined(RLD) */

#ifdef DEBUG
#ifndef RLD
/*
 * print_segment_specs() prints the segment specs.  Used for debugging.
 */
__private_extern__
void
print_segment_specs(void)
{
    unsigned long i, j;

	print("Segment specs\n");
	for(i = 0; i < nsegment_specs; i++){
	    print("    segname = %s\n", segment_specs[i].segname);
	    if(segment_specs[i].addr_specified)
		print("\taddr_specified TRUE\n"
		      "\taddr 0x%08x\n", (unsigned int)(segment_specs[i].addr));
	    else
		print("\taddr_specified FALSE\n");
	    if(segment_specs[i].prot_specified){
		print("\tprot_specified TRUE\n");
		print("\tmaxprot ");
		print_prot(segment_specs[i].maxprot);
		print("\n");
		print("\tinitprot ");
		print_prot(segment_specs[i].initprot);
		print("\n");
	    }
	    else{
		print("\tprot_specified FALSE\n");
	    }
	    print("\tnsection_specs %lu\n", segment_specs[i].nsection_specs);
	    print("\tSection specs\n");
	    for(j = 0; j < segment_specs[i].nsection_specs; j++){
		print("\t    sectname %s\n",
		       segment_specs[i].section_specs[j].sectname);
		if(segment_specs[i].section_specs[j].contents_filename != NULL){
		    print("\t    contents_filename %s\n",
			   segment_specs[i].section_specs[j].contents_filename);
		    print("\t    file_addr 0x%x\n", (unsigned int)
			   (segment_specs[i].section_specs[j].file_addr));
		    print("\t    file_size %lu\n",
			   segment_specs[i].section_specs[j].file_size);
		}
		if(segment_specs[i].section_specs[j].order_filename != NULL){
		    print("\t    order_filename %s\n",
			   segment_specs[i].section_specs[j].order_filename);
		    print("\t    order_addr 0x%x\n", (unsigned int)
			   (segment_specs[i].section_specs[j].order_addr));
		    print("\t    order_size %lu\n",
			   segment_specs[i].section_specs[j].order_size);
		}
		if(segment_specs[i].section_specs[j].align_specified)
		    print("\t    align_specified TRUE\n"
		           "\t    align %lu\n",
			   segment_specs[i].section_specs[j].align);
		else
		    print("\t    align_specified FALSE\n");
	    }
	}
}
#endif /* !defined(RLD) */

__private_extern__
void
print_prot(
vm_prot_t prot)
{
	if(prot & VM_PROT_READ)
	    print("r");
	else
	    print("-");
	if(prot & VM_PROT_WRITE)
	    print("w");
	else
	    print("-");
	if(prot & VM_PROT_EXECUTE)
	    print("x");
	else
	    print("-");
}
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/specs.h                                  0100644 0001750 0001750 00000007162 12612724205 022332  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file specs.c.
 *
 * The following include file need to be included before this file:
 * #include <mach.h>
 * #include "ld.h"
 */

/* Type to hold the information specified on the command line about segments */
struct segment_spec {
    char *segname;		/* full segment name from command line */
    enum bool addr_specified;	/* TRUE if address has been specified */
    enum bool prot_specified;	/* TRUE if protection has been specified */
    unsigned long addr;		/* specified address */
    vm_prot_t maxprot;		/* specified maximum protection */
    vm_prot_t initprot;		/* specified initial protection */
    unsigned long
	nsection_specs;		/* count of section_spec structures below */
    struct section_spec		/* list of section_spec structures for */
	  *section_specs;	/*  -segcreate options */
    enum bool processed;	/* TRUE after this has been processed */
};

/* Type to hold the information about sections specified on the command line */
struct section_spec {
    char *sectname;		/* full section name from command line */
    enum bool align_specified;	/* TRUE if alignment has been specified */
    unsigned long align;	/* the alignment (as a power of two) */
    char *contents_filename;	/* file name for the contents of the section */
    char *file_addr;		/* address the above file is mapped at */
    unsigned long file_size;	/* size of above file as returned by stat(2) */
    char *order_filename;	/* file name that contains the order that */
				/*  symbols are to loaded in this section */
    char *order_addr;		/* address the above file is mapped at */
    unsigned long order_size;	/* size of above file as returned by stat(2) */
    enum bool processed;	/* TRUE after this has been processed */
};

/* The structures to hold the information specified about segments */
__private_extern__ struct segment_spec *segment_specs;
__private_extern__ unsigned long nsegment_specs;

__private_extern__ struct segment_spec *create_segment_spec(
    char *segname);
__private_extern__ struct section_spec *create_section_spec(
    struct segment_spec *seg_spec,
    char *sectname);
__private_extern__ struct segment_spec * lookup_segment_spec(
    char *segname);
__private_extern__ struct section_spec *lookup_section_spec(
    char *segname,
    char *sectname);
__private_extern__ void process_section_specs(
    void);
__private_extern__ void process_segment_specs(
    void);
#ifdef DEBUG
__private_extern__ void print_segment_specs(
    void);
__private_extern__ void print_prot(
    vm_prot_t prot);
#endif /* DEBUG */
                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/symbols.c                                0100644 0001750 0001750 00001111617 12612724205 022702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2007 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
#ifdef SHLIB
#include "shlib.h"
#endif /* 